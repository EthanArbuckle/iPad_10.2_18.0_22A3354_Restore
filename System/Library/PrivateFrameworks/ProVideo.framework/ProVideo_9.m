uint64_t HgcToneParamCurve1::GetParameter(HgcToneParamCurve1 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcPixelFormatConversion_kV4B10Bit_BE_output::GetProgram(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003db\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(255.7500000, 63.93750000, 15.98437500, 0.000000000);\n"
             "    const half4 c1 = half4(4.000000000, 16.00000000, 64.00000000, 0.000000000);\n"
             "    const half4 c2 = half4(1.000000000, 0.003921568859, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = clamp((half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy), 0.00000h, 1.00000h);\n"
             "    r0 = r0*c0;\n"
             "    r1 = fract(r0);\n"
             "    r1 = r1*c1;\n"
             "    r1 = floor(r1.wxyz);\n"
             "    r1 = r1*c1.wzyx;\n"
             "    r0 = floor(r0);\n"
             "    r0 = r0*c2.xxxw + r1;\n"
             "    output.color0 = float4(r0)*float4(c2.yyyy);\n"
             "    return output;\n"
             "}\n"
             "//MD5=bb27e3be:38664bb7:ce3c51bf:a917b29d\n"
             "//SIG=00400000:00000001:00000001:00000001:0003:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003cb\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(255.7500000, 63.93750000, 15.98437500, 0.000000000);\n"
             "    const float4 c1 = float4(4.000000000, 16.00000000, 64.00000000, 0.000000000);\n"
             "    const float4 c2 = float4(1.000000000, 0.003921568859, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = clamp(hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy), 0.00000f, 1.00000f);\n"
             "    r0 = r0*c0;\n"
             "    r1 = fract(r0);\n"
             "    r1 = r1*c1;\n"
             "    r1 = floor(r1.wxyz);\n"
             "    r1 = r1*c1.wzyx;\n"
             "    r0 = floor(r0);\n"
             "    r0 = r0*c2.xxxw + r1;\n"
             "    output.color0 = r0*c2.yyyy;\n"
             "    return output;\n"
             "}\n"
             "//MD5=61aa77c2:f5fae104:c9ee071c:f4d1cc49\n"
             "//SIG=00000000:00000001:00000001:00000000:0003:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000382\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(255.7500000, 63.93750000, 15.98437500, 0.000000000);\n"
           "    const mediump vec4 c1 = vec4(4.000000000, 16.00000000, 64.00000000, 0.000000000);\n"
           "    const mediump vec4 c2 = vec4(1.000000000, 0.003921568859, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = clamp(texture2D(hg_Texture0, hg_TexCoord0.xy), vec4(0.00000), vec4(1.00000));\n"
           "    r0 = r0*c0;\n"
           "    r1 = fract(r0);\n"
           "    r1 = r1*c1;\n"
           "    r1 = floor(r1.wxyz);\n"
           "    r1 = r1*c1.wzyx;\n"
           "    r0 = floor(r0);\n"
           "    r0 = r0*c2.xxxw + r1;\n"
           "    gl_FragColor = r0*c2.yyyy;\n"
           "}\n"
           "//MD5=ca498554:4fd18e60:1c6325ca:76efb0c5\n"
           "//SIG=00000000:00000001:00000001:00000000:0003:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4B10Bit_BE_output::InitProgramDescriptor(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4B10Bit_BE_output_hgc_visible", "//Metal1.0     \n//LEN=00000002c1\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4B10Bit_BE_output_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(255.7500000, 63.93750000, 15.98437500, 0.000000000);\n"
    "    const float4 c1 = float4(4.000000000, 16.00000000, 64.00000000, 0.000000000);\n"
    "    const float4 c2 = float4(1.000000000, 0.003921568859, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = clamp(color0, 0.00000f, 1.00000f);\n"
    "    r0 = r0*c0;\n"
    "    r1 = fract(r0);\n"
    "    r1 = r1*c1;\n"
    "    r1 = floor(r1.wxyz);\n"
    "    r1 = r1*c1.wzyx;\n"
    "    r0 = floor(r0);\n"
    "    r0 = r0*c2.xxxw + r1;\n"
    "    output.color0 = r0*c2.yyyy;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BCE730(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BCE760(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BCE758);
}

double HgcPixelFormatConversion_kV4B10Bit_BE_output::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x38uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B309DA70;
  strcpy(v3, "HgcPixelFormatConversion_kV4B10Bit_BE_output [hgc1]");
  return *(double *)"it_BE_output [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_output::BindTexture(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_output::Bind(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, HGHandler *a2)
{
  (*(void (**)(HgcPixelFormatConversion_kV4B10Bit_BE_output *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_output::RenderTile(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t *v11;
  float32x4_t *v12;
  unint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  uint64_t v16;
  float32x4_t *v17;
  float32x4_t *v18;
  float32x4_t v19;
  float32x4_t *v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  int8x16_t v36;
  int8x16_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t *v55;
  float32x4_t v56;
  float32x4_t *v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int8x16_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  float32x4_t *v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int8x16_t v75;
  float32x4_t v76;
  float32x4_t v77;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v65 = 0;
        v66 = 16 * v7;
        v67 = 16 * v6;
        v68 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v69 = 0;
          do
          {
            v70 = (float32x4_t *)*((_QWORD *)this + 51);
            v71 = v70[1];
            v72 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v69 / 0x10], *v70), v71), v70[2]);
            v73 = vcvtq_f32_s32(vcvtq_s32_f32(v72));
            v74 = vsubq_f32(v73, (float32x4_t)vandq_s8((int8x16_t)v71, (int8x16_t)vcgtq_f32(v73, v72)));
            v75 = (int8x16_t)vmulq_f32(v70[3], vsubq_f32(v72, v74));
            v76 = (float32x4_t)vextq_s8(v75, v75, 0xCuLL);
            v77 = vcvtq_f32_s32(vcvtq_s32_f32(v76));
            v5[v69 / 0x10] = vmulq_f32(v70[6], vaddq_f32(vmulq_f32(v74, v70[5]), vmulq_f32(v70[4], vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v71, (int8x16_t)vcgtq_f32(v77, v76))))));
            v69 += 16;
          }
          while (v68 != v69);
          ++v65;
          v4 = (float32x4_t *)((char *)v4 + v66);
          v5 = (float32x4_t *)((char *)v5 + v67);
        }
        while (v65 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = (float32x4_t *)*((_QWORD *)this + 51);
          v19 = v18[1];
          v20 = v14;
          v21 = v18[2];
          v22 = v18[3];
          v23 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16 - 2], *v18), v19), v21);
          v24 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16 - 1], *v18), v19), v21);
          v25 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16], *v18), v19), v21);
          v26 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16 + 1], *v18), v19), v21);
          v27 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
          v28 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
          v29 = vcvtq_f32_s32(vcvtq_s32_f32(v25));
          v30 = vcvtq_f32_s32(vcvtq_s32_f32(v26));
          v31 = vsubq_f32(v27, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v27, v23)));
          v32 = vsubq_f32(v28, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v28, v24)));
          v33 = vsubq_f32(v29, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v29, v25)));
          v34 = vsubq_f32(v30, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v30, v26)));
          v35 = (int8x16_t)vmulq_f32(v22, vsubq_f32(v23, v31));
          v36 = (int8x16_t)vmulq_f32(v22, vsubq_f32(v24, v32));
          v37 = (int8x16_t)vmulq_f32(v22, vsubq_f32(v25, v33));
          v38 = (int8x16_t)vmulq_f32(v22, vsubq_f32(v26, v34));
          v39 = (float32x4_t)vextq_s8(v35, v35, 0xCuLL);
          v40 = (float32x4_t)vextq_s8(v36, v36, 0xCuLL);
          v41 = (float32x4_t)vextq_s8(v37, v37, 0xCuLL);
          v42 = (float32x4_t)vextq_s8(v38, v38, 0xCuLL);
          v43 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
          v44 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
          v45 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
          v46 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
          v47 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v43, v39)));
          v48 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v44, v40)));
          v49 = vsubq_f32(v45, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v45, v41)));
          v50 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v46, v42)));
          v51 = v18[4];
          v52 = v18[5];
          v53 = vaddq_f32(vmulq_f32(v31, v52), vmulq_f32(v51, v47));
          v54 = v18[6];
          v55 = &v5[v16];
          v13 += 4;
          v55[-2] = vmulq_f32(v54, v53);
          v55[-1] = vmulq_f32(v54, vaddq_f32(vmulq_f32(v32, v52), vmulq_f32(v51, v48)));
          *v55 = vmulq_f32(v54, vaddq_f32(vmulq_f32(v33, v52), vmulq_f32(v51, v49)));
          v55[1] = vmulq_f32(v54, vaddq_f32(vmulq_f32(v34, v52), vmulq_f32(v51, v50)));
          v16 += 4;
          v15 = v17 + 4;
          v14 += 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v56 = *v17++;
            v57 = (float32x4_t *)*((_QWORD *)this + 51);
            v58 = v57[1];
            v59 = vmulq_f32(vminq_f32(vmaxq_f32(v56, *v57), v58), v57[2]);
            v60 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
            v61 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v58, (int8x16_t)vcgtq_f32(v60, v59)));
            v62 = (int8x16_t)vmulq_f32(v57[3], vsubq_f32(v59, v61));
            v63 = (float32x4_t)vextq_s8(v62, v62, 0xCuLL);
            v64 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
            *v20++ = vmulq_f32(v57[6], vaddq_f32(vmulq_f32(v61, v57[5]), vmulq_f32(v57[4], vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v58, (int8x16_t)vcgtq_f32(v64, v63))))));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (float32x4_t *)((char *)v5 + v9);
        v4 = (float32x4_t *)((char *)v4 + v10);
        v11 = (float32x4_t *)((char *)v11 + v10);
        v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_output::GetDOD(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_output::GetROI(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcPixelFormatConversion_kV4B10Bit_BE_output::HgcPixelFormatConversion_kV4B10Bit_BE_output(HgcPixelFormatConversion_kV4B10Bit_BE_output *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6542F50;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v3 + 16) = _Q0;
  *(_OWORD *)(v3 + 32) = xmmword_1B3553BC0;
  *(_OWORD *)(v3 + 48) = xmmword_1B3553BD0;
  *(_OWORD *)(v3 + 64) = xmmword_1B3553BE0;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051560;
  *(int32x4_t *)(v3 + 96) = vdupq_n_s32(0x3B808081u);
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BCECB4(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4B10Bit_BE_output::~HgcPixelFormatConversion_kV4B10Bit_BE_output(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6542F50;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6542F50;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6542F50;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_output::SetParameter(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_output::GetParameter(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcPixelFormatConversion_kV4B_WXYZ_input::GetProgram(HgcPixelFormatConversion_kV4B_WXYZ_input *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000023d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0.yxwz) - hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=1dbd242c:497308d0:b7cfb140:ddbffa01\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000022f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0.yxwz - hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=2f76817a:3863da94:44205a76:e1835bc2\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001fd\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0.yxwz - hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=0342e6cd:919b4f83:c06c49fe:3495a499\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4B_WXYZ_input::InitProgramDescriptor(HgcPixelFormatConversion_kV4B_WXYZ_input *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4B_WXYZ_input_hgc_visible", "//Metal1.0     \n//LEN=0000000121\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4B_WXYZ_input_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0.yxwz - hg_Params[0];\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BCF054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BCF084(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BCF07CLL);
}

double HgcPixelFormatConversion_kV4B_WXYZ_input::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x30uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3553C20;
  strcpy(v3, "HgcPixelFormatConversion_kV4B_WXYZ_input [hgc1]");
  return *(double *)"XYZ_input [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_input::BindTexture(HgcPixelFormatConversion_kV4B_WXYZ_input *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_input::Bind(HgcPixelFormatConversion_kV4B_WXYZ_input *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcPixelFormatConversion_kV4B_WXYZ_input *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_input::RenderTile(HgcPixelFormatConversion_kV4B_WXYZ_input *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  int32x4_t *v4;
  float32x4_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int32x4_t *v11;
  float32x4_t *v12;
  unint64_t v13;
  float32x4_t *v14;
  int32x4_t *v15;
  uint64_t v16;
  int32x4_t *v17;
  float32x4_t *v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t *v23;
  int32x4_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (int32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v25 = 0;
        v26 = 16 * v7;
        v27 = 16 * v6;
        v28 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v29 = 0;
          do
          {
            v5[v29 / 0x10] = vsubq_f32((float32x4_t)vrev64q_s32(v4[v29 / 0x10]), *(float32x4_t *)*((_QWORD *)this + 51));
            v29 += 16;
          }
          while (v28 != v29);
          ++v25;
          v4 = (int32x4_t *)((char *)v4 + v26);
          v5 = (float32x4_t *)((char *)v5 + v27);
        }
        while (v25 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = v14;
          v19 = *(float32x4_t *)*((_QWORD *)this + 51);
          v20 = vsubq_f32((float32x4_t)vrev64q_s32(v4[v16 - 1]), v19);
          v21 = vsubq_f32((float32x4_t)vrev64q_s32(v4[v16]), v19);
          v22 = vsubq_f32((float32x4_t)vrev64q_s32(v4[v16 + 1]), v19);
          v23 = &v5[v16];
          v23[-2] = vsubq_f32((float32x4_t)vrev64q_s32(v4[v16 - 2]), v19);
          v23[-1] = v20;
          v13 += 4;
          *v23 = v21;
          v23[1] = v22;
          v16 += 4;
          v15 += 4;
          v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v24 = *v17++;
            *v18++ = vsubq_f32((float32x4_t)vrev64q_s32(v24), *(float32x4_t *)*((_QWORD *)this + 51));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (float32x4_t *)((char *)v5 + v9);
        v4 = (int32x4_t *)((char *)v4 + v10);
        v11 = (int32x4_t *)((char *)v11 + v10);
        v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_input::GetDOD(HgcPixelFormatConversion_kV4B_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_input::GetROI(HgcPixelFormatConversion_kV4B_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcPixelFormatConversion_kV4B_WXYZ_input::HgcPixelFormatConversion_kV4B_WXYZ_input(HgcPixelFormatConversion_kV4B_WXYZ_input *this)
{
  _QWORD *v2;
  _QWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65431B8;
  v3 = (_QWORD *)operator new();
  *v3 = 0;
  v3[1] = 0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BCF3F0(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4B_WXYZ_input::~HgcPixelFormatConversion_kV4B_WXYZ_input(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65431B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E65431B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65431B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_input::SetParameter(HgcPixelFormatConversion_kV4B_WXYZ_input *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcPixelFormatConversion_kV4B_WXYZ_input::GetParameter(HgcPixelFormatConversion_kV4B_WXYZ_input *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcPixelFormatConversion_kV4B_WXYZ_output::GetProgram(HgcPixelFormatConversion_kV4B_WXYZ_output *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000022e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0.yxwz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1444beee:fe229edf:8efe5f39:cebbac56\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000220\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0.yxwz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=55de5a34:399890da:0381eeee:8693b352\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0.yxwz;\n"
           "}\n"
           "//MD5=db620396:7a9f1d56:e8273dfb:0aa51d5a\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4B_WXYZ_output::InitProgramDescriptor(HgcPixelFormatConversion_kV4B_WXYZ_output *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4B_WXYZ_output_hgc_visible", "//Metal1.0     \n//LEN=0000000113\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4B_WXYZ_output_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0.yxwz;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BCF828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BCF858(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BCF850);
}

double HgcPixelFormatConversion_kV4B_WXYZ_output::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x38uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3553C60;
  strcpy(v3, "HgcPixelFormatConversion_kV4B_WXYZ_output [hgc1]");
  return *(double *)"YZ_output [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_output::BindTexture(HgcPixelFormatConversion_kV4B_WXYZ_output *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_output::Bind(HgcPixelFormatConversion_kV4B_WXYZ_output *this, HGHandler *a2)
{
  (*(void (**)(HgcPixelFormatConversion_kV4B_WXYZ_output *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_output::RenderTile(HgcPixelFormatConversion_kV4B_WXYZ_output *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  int32x4_t *v4;
  int32x4_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int32x4_t *v11;
  int32x4_t *v12;
  unint64_t v13;
  int32x4_t *v14;
  int32x4_t *v15;
  uint64_t v16;
  int32x4_t *v17;
  int32x4_t *v18;
  int32x4_t v19;
  int32x4_t v20;
  int32x4_t v21;
  int32x4_t *v22;
  int32x4_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (int32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (int32x4_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v24 = 0;
        v25 = 16 * v7;
        v26 = 16 * v6;
        v27 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v28 = 0;
          do
          {
            v5[v28 / 0x10] = vrev64q_s32(v4[v28 / 0x10]);
            v28 += 16;
          }
          while (v27 != v28);
          ++v24;
          v4 = (int32x4_t *)((char *)v4 + v25);
          v5 = (int32x4_t *)((char *)v5 + v26);
        }
        while (v24 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = v14;
          v19 = vrev64q_s32(v4[v16 - 1]);
          v20 = vrev64q_s32(v4[v16]);
          v21 = vrev64q_s32(v4[v16 + 1]);
          v22 = &v5[v16];
          v22[-2] = vrev64q_s32(v4[v16 - 2]);
          v22[-1] = v19;
          v13 += 4;
          *v22 = v20;
          v22[1] = v21;
          v16 += 4;
          v15 += 4;
          v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v23 = *v17++;
            *v18++ = vrev64q_s32(v23);
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (int32x4_t *)((char *)v5 + v9);
        v4 = (int32x4_t *)((char *)v4 + v10);
        v11 = (int32x4_t *)((char *)v11 + v10);
        v12 = (int32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_output::GetDOD(HgcPixelFormatConversion_kV4B_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_output::GetROI(HgcPixelFormatConversion_kV4B_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcPixelFormatConversion_kV4B_WXYZ_output::HgcPixelFormatConversion_kV4B_WXYZ_output(HgcPixelFormatConversion_kV4B_WXYZ_output *this)
{
  uint64_t v2;
  _OWORD *v3;

  HGColorMatrix::HGColorMatrix(this);
  *(_QWORD *)v2 = off_1E6543420;
  *(_DWORD *)(v2 + 504) = 1;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B304F230;
  v3[1] = xmmword_1B304F240;
  v3[2] = xmmword_1B304F250;
  v3[3] = xmmword_1B304EFF0;
  v3[4] = xmmword_1B304F230;
  v3[5] = xmmword_1B304F240;
  v3[6] = xmmword_1B304F250;
  v3[7] = xmmword_1B304EFF0;
  *((_QWORD *)this + 62) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BCFB94(_Unwind_Exception *a1)
{
  HGColorMatrix *v1;

  HGColorMatrix::~HGColorMatrix(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4B_WXYZ_output::~HgcPixelFormatConversion_kV4B_WXYZ_output(HgcPixelFormatConversion_kV4B_WXYZ_output *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6543420;
  v2 = *((_QWORD *)this + 62);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGColorMatrix::~HGColorMatrix(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6543420;
  v2 = *((_QWORD *)this + 62);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGColorMatrix::~HGColorMatrix(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6543420;
  v2 = *((_QWORD *)this + 62);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGColorMatrix::~HGColorMatrix(this);
  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_output::SetParameter(HgcPixelFormatConversion_kV4B_WXYZ_output *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_output::GetParameter(HgcPixelFormatConversion_kV4B_WXYZ_output *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

HGNode *HgcPixelFormatConversion_kV4B_WXYZ_output::GetOutput(__n128 *this, HGRenderer *a2, __n128 a3, __n128 a4, __n128 a5)
{
  int32x4_t *v5;
  int32x4_t v6;
  __n128 *v7;

  if (this[31].n128_u32[2])
  {
    v5 = (int32x4_t *)this[31].n128_u64[0];
    a4 = (__n128)vrev64q_s32(v5[5]);
    a5 = (__n128)vrev64q_s32(v5[6]);
    v6 = vrev64q_s32(v5[7]);
    *v5 = vrev64q_s32(v5[4]);
    *(__n128 *)(this[31].n128_u64[0] + 16) = a4;
    *(__n128 *)(this[31].n128_u64[0] + 32) = a5;
    *(int32x4_t *)(this[31].n128_u64[0] + 48) = v6;
    v7 = (__n128 *)this[31].n128_u64[0];
    this[27] = *v7;
    this[28] = v7[1];
    this[29] = v7[2];
    a3 = v7[3];
    this[30] = a3;
    this[31].n128_u32[2] = 0;
  }
  return HGColorMatrix::GetOutput((HGColorMatrix *)this, a2, a3.n128_f64[0], a4.n128_f64[0], (int32x2_t)a5.n128_u64[0]);
}

const char *HgcColorGamma_v216_yxzx_expand::GetProgram(HgcColorGamma_v216_yxzx_expand *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000303\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    s0.x = float(fract(0.500000f*frag._texCoord1.x) >= 0.500000f);\n"
             "    r1 = half4(r0.y, r0.x, r0.z, 1.00000h);\n"
             "    s1.yzw = float3(r1.yzw);\n"
             "    s1.x = select(float(r1.x), float(r0.w), -s0.x < 0.00000h);\n"
             "    output.color0 = s1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e21a45a6:09902464:305afcf0:4fad99f2\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0004:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002c4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = float(fract(0.500000f*frag._texCoord1.x) >= 0.500000f);\n"
             "    r2 = float4(r0.y, r0.x, r0.z, 1.00000f);\n"
             "    r2.x = select(r2.x, r0.w, -r1.x < 0.00000f);\n"
             "    output.color0 = r2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=255181fe:8739b9fa:717e3924:0c6abb8c\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0003:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002e4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.x*hg_TexCoord1.x;\n"
           "    r1.x = fract(r1.x);\n"
           "    r1.x = float(r1.x >= c0.x);\n"
           "    r2 = vec4(r0.y, r0.x, r0.z, 1.00000);\n"
           "    r2.x = -r1.x < 0.00000 ? r0.w : r2.x;\n"
           "    gl_FragColor = r2;\n"
           "}\n"
           "//MD5=d30aa489:0cf70260:00ac23f3:bdc5057d\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0000:0003:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcColorGamma_v216_yxzx_expand::InitProgramDescriptor(HgcColorGamma_v216_yxzx_expand *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_v216_yxzx_expand_hgc_visible", "//Metal1.0     \n//LEN=0000000225\n[[ visible ]] FragmentOut HgcColorGamma_v216_yxzx_expand_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, texCoord0.xy);\n"
    "    r1.x = float(fract(0.500000f*texCoord1.x) >= 0.500000f);\n"
    "    r2 = float4(r0.y, r0.x, r0.z, 1.00000f);\n"
    "    r2.x = select(r2.x, r0.w, -r1.x < 0.00000f);\n"
    "    output.color0 = r2;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BD0164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BD01A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BD0198);
}

char *HgcColorGamma_v216_yxzx_expand::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A20;
  strcpy(result, "HgcColorGamma_v216_yxzx_expand [hgc1]");
  return result;
}

uint64_t HgcColorGamma_v216_yxzx_expand::BindTexture(HgcColorGamma_v216_yxzx_expand *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 0.5, 1.0, 1.0);
  return 0;
}

uint64_t HgcColorGamma_v216_yxzx_expand::Bind(HgcColorGamma_v216_yxzx_expand *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(void (**)(HgcColorGamma_v216_yxzx_expand *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcColorGamma_v216_yxzx_expand::RenderTile(HgcColorGamma_v216_yxzx_expand *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  float32x4_t v7;
  float32x4_t v8;
  int8x16_t v9;
  int8x16_t *v10;
  int8x16_t *v11;
  uint64_t v12;
  float32x4_t v18;
  int v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t *v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int32x2_t v27;
  __int32 v28;
  float32x4_t v29;
  int32x4_t v30;
  float32x4_t v31;
  int32x4_t v32;
  int8x16_t v33;
  float32x4_t v34;
  int32x4_t v35;
  int8x16_t v36;
  __int32 v37;
  float32x4_t v38;
  int32x4_t v39;
  int8x16_t v40;
  int8x16_t v41;
  uint64_t v42;
  float32x4_t v43;
  int8x16_t v44;
  int8x8_t v45;
  int8x16_t v46;
  int8x16_t v47;
  int8x16_t v48;
  int8x16_t v49;
  int8x16_t v50;
  int8x16_t v51;
  int8x16_t v52;
  uint64_t v53;
  float32x4_t v54;
  int32x4_t v55;
  int8x16_t v56;
  uint64_t v57;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B3552B60);
    *(float32x2_t *)v8.f32 = vcvt_f32_s32((int32x2_t)vand_s8((int8x8_t)v2, (int8x8_t)0x100000001));
    v8.i64[1] = 0x3F80000000000000;
    *(float *)v9.i32 = (float)(v6 & 1);
    v9.i32[1] = 1.0;
    v9.i64[1] = 0;
    v10 = (int8x16_t *)a2[2];
    v11 = v10 + 2;
    v12 = 16 * a2[3].i32[0];
    __asm { FMOV            V16.4S, #4.0 }
    v18.i64[0] = 0x3F0000003F000000;
    v18.i64[1] = 0x3F0000003F000000;
    while (v6 < 4)
    {
      LODWORD(v53) = 0;
      v21 = 0uLL;
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B304F240);
      v8 = (float32x4_t)veorq_s8((int8x16_t)v8, v9);
      ++v4;
      v11 = (int8x16_t *)((char *)v11 + v12);
      v10 = (int8x16_t *)((char *)v10 + v12);
      if (v4 == v3)
        return 0;
    }
    v19 = 0;
    v20 = (float32x4_t)veorq_s8((int8x16_t)v8, (int8x16_t)xmmword_1B304F230);
    v21 = 0uLL;
    v22 = v11;
    do
    {
      v23 = vaddq_f32(v7, vmulq_f32(v21, (float32x4_t)xmmword_1B3051880));
      v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B3051880);
      v25 = vaddq_f32(v24, (float32x4_t)xmmword_1B3051880);
      v26 = vaddq_f32(v25, (float32x4_t)xmmword_1B3051880);
      v27 = a2[10];
      v28 = a2[11].i32[0];
      v29 = vaddq_f32(vsubq_f32(v23, v5), v18);
      v30 = vcvtq_s32_f32(v29);
      v29.i64[0] = vaddq_s32(v30, vcgtq_f32(vcvtq_f32_s32(v30), v29)).u64[0];
      v31 = vaddq_f32(vsubq_f32(v24, v5), v18);
      v32 = vcvtq_s32_f32(v31);
      v33 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v29.i32[0] + v29.i32[1] * v28));
      v31.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
      v34 = vaddq_f32(vsubq_f32(v25, v5), v18);
      v35 = vcvtq_s32_f32(v34);
      v36 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v31.i32[0] + v31.i32[1] * v28));
      v34.i64[0] = vaddq_s32(v35, vcgtq_f32(vcvtq_f32_s32(v35), v34)).u64[0];
      v37 = v34.i32[0] + v34.i32[1] * v28;
      v38 = vaddq_f32(vsubq_f32(v26, v5), v18);
      v39 = vcvtq_s32_f32(v38);
      v40 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * v37);
      v38.i64[0] = vaddq_s32(v39, vcgtq_f32(vcvtq_f32_s32(v39), v38)).u64[0];
      v41 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v38.i32[0] + v38.i32[1] * v28));
      v42 = *((_QWORD *)this + 51);
      v43 = *(float32x4_t *)(v42 + 16);
      *(int8x8_t *)v44.i8 = vqtbl1_s8(v33, *(int8x8_t *)v42);
      v45 = (int8x8_t)vextq_s8(*(int8x16_t *)v42, *(int8x16_t *)v42, 8uLL).u64[0];
      v44.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v33, v45).u32[0]);
      *(int8x8_t *)v46.i8 = vqtbl1_s8(v36, *(int8x8_t *)v42);
      v46.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v36, v45).u32[0]);
      *(int8x8_t *)v47.i8 = vqtbl1_s8(v40, *(int8x8_t *)v42);
      v47.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v40, v45).u32[0]);
      *(int8x8_t *)v39.i8 = vqtbl1_s8(v41, *(int8x8_t *)v42);
      v39.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v41, v45).u32[0]);
      v48 = (int8x16_t)vcgtq_f32(v8, v43);
      v49 = (int8x16_t)vcgtq_f32(v20, v43);
      v50 = vbslq_s8(v49, vextq_s8(v36, v36, 0xCuLL), v46);
      v51 = vbslq_s8(v49, vextq_s8(v41, v41, 0xCuLL), (int8x16_t)v39);
      v52 = *(int8x16_t *)(v42 + 32);
      v21 = vaddq_f32(v21, _Q16);
      v22[-2] = vbslq_s8(v52, vbslq_s8(v48, vextq_s8(v33, v33, 0xCuLL), v44), v44);
      v22[-1] = vbslq_s8(v52, v50, v46);
      *v22 = vbslq_s8(v52, vbslq_s8(v48, vextq_s8(v40, v40, 0xCuLL), v47), v47);
      v22[1] = vbslq_s8(v52, v51, (int8x16_t)v39);
      v22 += 4;
      v19 -= 4;
    }
    while (v6 + v19 > 3);
    LODWORD(v53) = -v19;
    if ((int)v53 >= v6)
      goto LABEL_3;
LABEL_10:
    v53 = v53;
    do
    {
      v54 = vaddq_f32(vsubq_f32(vaddq_f32(v7, vmulq_f32(v21, (float32x4_t)xmmword_1B3051880)), v5), v18);
      v55 = vcvtq_s32_f32(v54);
      v54.i64[0] = vaddq_s32(v55, vcgtq_f32(vcvtq_f32_s32(v55), v54)).u64[0];
      v56 = *(int8x16_t *)(*(_QWORD *)&a2[10] + 16 * (v54.i32[0] + v54.i32[1] * a2[11].i32[0]));
      v57 = *((_QWORD *)this + 51);
      *(int8x8_t *)v55.i8 = vqtbl1_s8(v56, *(int8x8_t *)v57);
      v55.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v56, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v57, *(int8x16_t *)v57, 8uLL)).u32[0]);
      v10[v53] = vbslq_s8(*(int8x16_t *)(v57 + 32), vbslq_s8((int8x16_t)vcgtq_f32(v8, *(float32x4_t *)(v57 + 16)), vextq_s8(v56, v56, 0xCuLL), (int8x16_t)v55), (int8x16_t)v55);
      v8 = (float32x4_t)veorq_s8((int8x16_t)v8, (int8x16_t)xmmword_1B304F230);
      __asm { FMOV            V19.4S, #1.0 }
      v21 = vaddq_f32(v21, _Q19);
      ++v53;
    }
    while (v53 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcColorGamma_v216_yxzx_expand::GetDOD(HgcColorGamma_v216_yxzx_expand *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  float v9;
  double v10;
  float v11;
  double v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0, 0, 1u, 0);
  v8 = HGRectGrow(v6, v5, v7);
  v9 = HGRectFloat(v8);
  v13 = HGRectScale(v9, v10, v11, v12, 2.0);
  v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcColorGamma_v216_yxzx_expand::GetROI(HgcColorGamma_v216_yxzx_expand *this, HGRenderer *a2, int a3, HGRect a4)
{
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = HGRectFloat(a4.var0);
  v9 = HGRectScale(v5, v6, v7, v8, 0.5);
  v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  v16 = v15;
  v17 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
  v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcColorGamma_v216_yxzx_expand::HgcColorGamma_v216_yxzx_expand(HgcColorGamma_v216_yxzx_expand *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6543698;
  v3 = operator new();
  *(_OWORD *)v3 = xmmword_1B3553CA0;
  *(_QWORD *)(v3 + 16) = 0;
  *(_QWORD *)(v3 + 24) = 0;
  *(_OWORD *)(v3 + 32) = xmmword_1B3050E20;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcColorGamma_v216_yxzx_expand *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BD07E0(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_v216_yxzx_expand::~HgcColorGamma_v216_yxzx_expand(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6543698;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40EED21634);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6543698;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40EED21634);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6543698;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40EED21634);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_v216_yxzx_expand::SetParameter(HgcColorGamma_v216_yxzx_expand *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_v216_yxzx_expand::GetParameter(HgcColorGamma_v216_yxzx_expand *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcBlur_g4u2::GetProgram(HgcBlur_g4u2 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000918\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    float4 s0, s1, s2, s3, s4, s5, s6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord1.xy*hg_Params[4].xy;\n"
             "    s0.xy = s0.xy + frag._texCoord0.xy;\n"
             "    s0.zw = s0.xy + hg_Params[5].xy;\n"
             "    s1.zw = s0.zw + hg_Params[6].xy;\n"
             "    s1.xy = s0.xy + -hg_Params[6].xy;\n"
             "    s2.zw = floor(s0.xy);\n"
             "    s2.xy = floor(s0.zw);\n"
             "    s2.xy = s2.xy + -s2.zw;\n"
             "    s1.zw = s1.zw + hg_Params[7].xy;\n"
             "    s1.zw = s1.zw*hg_Params[7].zw;\n"
             "    s1.xy = s1.xy + hg_Params[7].xy;\n"
             "    s0.zw = s0.zw + hg_Params[7].xy;\n"
             "    s0.xy = s0.xy + hg_Params[7].xy;\n"
             "    s3.x = s2.x + s2.y;\n"
             "    s5.xy = s1.zw*hg_Params[8].xy;\n"
             "    s5.xy = fmax(s5.xy, float2(c0.xy));\n"
             "    s6.xy = hg_Params[8].xy - float2(c0.xy);\n"
             "    s5.xy = fmin(s5.xy, s6.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s5.xy);\n"
             "    s1.xy = s1.xy*hg_Params[7].zw;\n"
             "    s6.xy = s1.xy*hg_Params[8].xy;\n"
             "    s6.xy = fmax(s6.xy, float2(c0.xy));\n"
             "    s5.xy = hg_Params[8].xy - float2(c0.xy);\n"
             "    s6.xy = fmin(s6.xy, s5.xy);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, s6.xy);\n"
             "    r0 = r1 + r0;\n"
             "    r1 = half4(hg_Params[1]);\n"
             "    r1 = -r1 + half4(hg_Params[3]);\n"
             "    s2 = s3.xxxx*float4(r1) + hg_Params[1];\n"
             "    r1 = half4(hg_Params[0]);\n"
             "    s2 = float4(r0)*s2;\n"
             "    r0 = -r1 + half4(hg_Params[2]);\n"
             "    s0.zw = s0.zw*hg_Params[7].zw;\n"
             "    s5.xy = s0.zw*hg_Params[8].xy;\n"
             "    s5.xy = fmax(s5.xy, float2(c0.xy));\n"
             "    s6.xy = hg_Params[8].xy - float2(c0.xy);\n"
             "    s5.xy = fmin(s5.xy, s6.xy);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, s5.xy);\n"
             "    s0.xy = s0.xy*hg_Params[7].zw;\n"
             "    s6.xy = s0.xy*hg_Params[8].xy;\n"
             "    s6.xy = fmax(s6.xy, float2(c0.xy));\n"
             "    s5.xy = hg_Params[8].xy - float2(c0.xy);\n"
             "    s6.xy = fmin(s6.xy, s5.xy);\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, s6.xy);\n"
             "    r2 = r2 + r1;\n"
             "    s4 = s3.xxxx*float4(r0) + hg_Params[0];\n"
             "    output.color0 = float4(r2)*s4 + s2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=82cbc070:1e8f1392:17c94f80:ede0e467\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0009:000a:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000869\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord1.xy*hg_Params[4].xy;\n"
             "    r0.xy = r0.xy + frag._texCoord0.xy;\n"
             "    r0.zw = r0.xy + hg_Params[5].xy;\n"
             "    r1.zw = r0.zw + hg_Params[6].xy;\n"
             "    r1.xy = r0.xy + -hg_Params[6].xy;\n"
             "    r3.zw = floor(r0.xy);\n"
             "    r3.xy = floor(r0.zw);\n"
             "    r3.xy = r3.xy + -r3.zw;\n"
             "    r1.zw = r1.zw + hg_Params[7].xy;\n"
             "    r1.zw = r1.zw*hg_Params[7].zw;\n"
             "    r1.xy = r1.xy + hg_Params[7].xy;\n"
             "    r0.zw = r0.zw + hg_Params[7].xy;\n"
             "    r0.xy = r0.xy + hg_Params[7].xy;\n"
             "    r4.x = r3.x + r3.y;\n"
             "    r5.xy = r1.zw*hg_Params[8].xy;\n"
             "    r5.xy = fmax(r5.xy, c0.xy);\n"
             "    r6.xy = hg_Params[8].xy - c0.xy;\n"
             "    r5.xy = fmin(r5.xy, r6.xy);\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
             "    r1.xy = r1.xy*hg_Params[7].zw;\n"
             "    r6.xy = r1.xy*hg_Params[8].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r5.xy = hg_Params[8].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r5.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r2 = r1 + r2;\n"
             "    r1 = hg_Params[1];\n"
             "    r1 = -r1 + hg_Params[3];\n"
             "    r3 = r4.xxxx*r1 + hg_Params[1];\n"
             "    r1 = hg_Params[0];\n"
             "    r3 = r2*r3;\n"
             "    r2 = -r1 + hg_Params[2];\n"
             "    r0.zw = r0.zw*hg_Params[7].zw;\n"
             "    r5.xy = r0.zw*hg_Params[8].xy;\n"
             "    r5.xy = fmax(r5.xy, c0.xy);\n"
             "    r6.xy = hg_Params[8].xy - c0.xy;\n"
             "    r5.xy = fmin(r5.xy, r6.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
             "    r0.xy = r0.xy*hg_Params[7].zw;\n"
             "    r6.xy = r0.xy*hg_Params[8].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r5.xy = hg_Params[8].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r5.xy);\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r0 = r0 + r1;\n"
             "    r1 = r4.xxxx*r2 + hg_Params[0];\n"
             "    output.color0 = r0*r1 + r3;\n"
             "    return output;\n"
             "}\n"
             "//MD5=27c82f99:05d3f9c9:9a09a632:03ef48aa\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0009:0007:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000838\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "uniform highp vec4 hg_ProgramLocal7;\n"
           "uniform highp vec4 hg_ProgramLocal8;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0.xy = hg_TexCoord1.xy*hg_ProgramLocal4.xy;\n"
           "    r0.xy = r0.xy + hg_TexCoord0.xy;\n"
           "    r0.zw = r0.xy + hg_ProgramLocal5.xy;\n"
           "    r1.zw = r0.zw + hg_ProgramLocal6.xy;\n"
           "    r1.xy = r0.xy + -hg_ProgramLocal6.xy;\n"
           "    r3.zw = floor(r0.xy);\n"
           "    r3.xy = floor(r0.zw);\n"
           "    r3.xy = r3.xy + -r3.zw;\n"
           "    r1.zw = r1.zw + hg_ProgramLocal7.xy;\n"
           "    r1.zw = r1.zw*hg_ProgramLocal7.zw;\n"
           "    r1.xy = r1.xy + hg_ProgramLocal7.xy;\n"
           "    r0.zw = r0.zw + hg_ProgramLocal7.xy;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal7.xy;\n"
           "    r4.x = r3.x + r3.y;\n"
           "    r5.xy = hg_ProgramLocal8.xy*c0.xy + r1.zw;\n"
           "    r2 = texture2D(hg_Texture0, r5.xy);\n"
           "    r1.xy = r1.xy*hg_ProgramLocal7.zw;\n"
           "    r5.xy = hg_ProgramLocal8.xy*c0.xy + r1.xy;\n"
           "    r1 = texture2D(hg_Texture0, r5.xy);\n"
           "    r2 = r1 + r2;\n"
           "    r1 = hg_ProgramLocal1;\n"
           "    r1 = -r1 + hg_ProgramLocal3;\n"
           "    r3 = r4.xxxx*r1 + hg_ProgramLocal1;\n"
           "    r1 = hg_ProgramLocal0;\n"
           "    r3 = r2*r3;\n"
           "    r2 = -r1 + hg_ProgramLocal2;\n"
           "    r0.zw = r0.zw*hg_ProgramLocal7.zw;\n"
           "    r5.xy = hg_ProgramLocal8.xy*c0.xy + r0.zw;\n"
           "    r1 = texture2D(hg_Texture0, r5.xy);\n"
           "    r0.xy = r0.xy*hg_ProgramLocal7.zw;\n"
           "    r5.xy = hg_ProgramLocal8.xy*c0.xy + r0.xy;\n"
           "    r0 = texture2D(hg_Texture0, r5.xy);\n"
           "    r0 = r0 + r1;\n"
           "    r1 = r4.xxxx*r2 + hg_ProgramLocal0;\n"
           "    gl_FragColor = r0*r1 + r3;\n"
           "}\n"
           "//MD5=b7d40998:4cb87aed:89098058:1dba952d\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0009:0006:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcBlur_g4u2::InitProgramDescriptor(HgcBlur_g4u2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlur_g4u2_hgc_visible", "//Metal1.0     \n//LEN=00000007b8\n[[ visible ]] FragmentOut HgcBlur_g4u2_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord1.xy*hg_Params[4].xy;\n"
    "    r0.xy = r0.xy + texCoord0.xy;\n"
    "    r0.zw = r0.xy + hg_Params[5].xy;\n"
    "    r1.zw = r0.zw + hg_Params[6].xy;\n"
    "    r1.xy = r0.xy + -hg_Params[6].xy;\n"
    "    r3.zw = floor(r0.xy);\n"
    "    r3.xy = floor(r0.zw);\n"
    "    r3.xy = r3.xy + -r3.zw;\n"
    "    r1.zw = r1.zw + hg_Params[7].xy;\n"
    "    r1.zw = r1.zw*hg_Params[7].zw;\n"
    "    r1.xy = r1.xy + hg_Params[7].xy;\n"
    "    r0.zw = r0.zw + hg_Params[7].xy;\n"
    "    r0.xy = r0.xy + hg_Params[7].xy;\n"
    "    r4.x = r3.x + r3.y;\n"
    "    r5.xy = r1.zw*hg_Params[8].xy;\n"
    "    r5.xy = fmax(r5.xy, c0.xy);\n"
    "    r6.xy = hg_Params[8].xy - c0.xy;\n"
    "    r5.xy = fmin(r5.xy, r6.xy);\n"
    "    r2 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
    "    r1.xy = r1.xy*hg_Params[7].zw;\n"
    "    r6.xy = r1.xy*hg_Params[8].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r5.xy = hg_Params[8].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r5.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r2 = r1 + r2;\n"
    "    r1 = hg_Params[1];\n"
    "    r1 = -r1 + hg_Params[3];\n"
    "    r3 = r4.xxxx*r1 + hg_Params[1];\n"
    "    r1 = hg_Params[0];\n"
    "    r3 = r2*r3;\n"
    "    r2 = -r1 + hg_Params[2];\n"
    "    r0.zw = r0.zw*hg_Params[7].zw;\n"
    "    r5.xy = r0.zw*hg_Params[8].xy;\n"
    "    r5.xy = fmax(r5.xy, c0.xy);\n"
    "    r6.xy = hg_Params[8].xy - c0.xy;\n"
    "    r5.xy = fmin(r5.xy, r6.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
    "    r0.xy = r0.xy*hg_Params[7].zw;\n"
    "    r6.xy = r0.xy*hg_Params[8].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r5.xy = hg_Params[8].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r5.xy);\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r0 = r0 + r1;\n"
    "    r1 = r4.xxxx*r2 + hg_Params[0];\n"
    "    output.color0 = r0*r1 + r3;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BD0D48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BD0D84(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BD0D7CLL);
}

void HgcBlur_g4u2::shaderDescription(char *a1@<X8>)
{
  a1[23] = 19;
  strcpy(a1, "HgcBlur_g4u2 [hgc1]");
}

uint64_t HgcBlur_g4u2::BindTexture(HgcBlur_g4u2 *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 8, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcBlur_g4u2::Bind(HgcBlur_g4u2 *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 6, *((_QWORD *)this + 51) + 96, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 7, *((_QWORD *)this + 51) + 112, 1);
  (*(void (**)(HgcBlur_g4u2 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBlur_g4u2::RenderTile(HgcBlur_g4u2 *this, int32x2_t *a2)
{
  uint64_t v4;
  int v5;
  int32x2_t v6;
  int v7;
  int v8;
  int v9;
  float32x2_t v10;
  float32x2_t v16;
  float32x2_t v17;
  float32x4_t v18;
  int32x2_t v19;
  uint64_t v20;
  uint64_t v21;
  float32x4_t v22;
  uint64_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int32x2_t v26;
  int32x2_t v27;
  int32x2_t v28;
  __int32 v29;
  float32x4_t v30;
  float32x4_t v31;
  uint64_t v32;
  int8x16_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x2_t v42;
  int32x2_t v43;
  uint64_t v44;
  float32x2_t v45;
  float32x2_t v46;
  int32x2_t v47;
  float32x2_t v48;
  float32x2_t v49;
  int32x2_t v50;
  float32x2_t v51;
  int32x2_t v52;
  float32x4_t *v53;
  uint64_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t *v57;
  float32x4_t v58;
  float32x4_t v59;
  int32x2_t v60;
  int32x2_t v61;
  int32x2_t v62;
  __int32 v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int8x16_t v67;
  float32x4_t v68;
  int8x16_t v69;
  float32x2_t v70;
  float v71;
  float32x2_t v72;
  float32x2_t v73;
  int32x2_t v74;
  float32x2_t v75;
  float32x2_t v76;
  int32x2_t v77;
  float32x2_t v78;
  int32x2_t v79;
  float32x4_t *v80;
  uint64_t v81;
  float32x4_t v82;
  float32x4_t *v83;
  float32x4_t v84;

  v4 = HGTile::Renderer((HGTile *)a2);
  v5 = (*(uint64_t (**)(HgcBlur_g4u2 *, uint64_t))(*(_QWORD *)this + 312))(this, v4);
  v6 = *a2;
  v7 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v7 >= 1)
  {
    v8 = a2[1].i32[0] - v6.i32[0];
    if (v8 >= 1)
    {
      v9 = 0;
      v10 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
      __asm { FMOV            V2.2S, #-1.0 }
      v16 = vadd_f32(v10, _D2);
      v17 = vadd_f32(v16, _D2);
      *(float32x2_t *)v18.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
      v18.i64[1] = 0x3F80000000000000;
      v19 = a2[2];
      v20 = 16 * a2[3].i32[0];
      v21 = 16 * v8;
      v22 = v18;
      do
      {
        v23 = 0;
        v24 = v18;
        v25 = v22;
        do
        {
          v32 = *((_QWORD *)this + 51);
          v33 = (int8x16_t)vaddq_f32(v24, vmulq_f32(v25, *(float32x4_t *)(v32 + 64)));
          v34 = (int8x16_t)vdupq_lane_s64(vaddq_f32(*(float32x4_t *)(v32 + 80), (float32x4_t)v33).i64[0], 0);
          v35.i64[1] = v34.i64[1];
          v35.i64[0] = v33.i64[0];
          v36 = *(float32x4_t *)(v32 + 96);
          v37 = *(int8x16_t *)(v32 + 112);
          v38 = vaddq_f32((float32x4_t)vdupq_lane_s64(v36.i64[0], 0), v35);
          v39 = vsubq_f32((float32x4_t)v33, v36);
          v40 = (float32x4_t)vextq_s8(v37, v37, 8uLL);
          v41 = (int8x16_t)vmulq_f32((float32x4_t)v37, vaddq_f32(v40, v38));
          v42 = (float32x2_t)vaddq_f32((float32x4_t)v37, v39).u64[0];
          v43 = a2[10];
          v44 = a2[11].i32[0];
          v45 = vmul_f32(v10, (float32x2_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL));
          if (v5)
          {
            v46 = vmin_f32(vmax_f32(vadd_f32(v45, (float32x2_t)0xBF000000BF000000), 0), v16);
            v47 = vcvt_s32_f32(vmin_f32(v46, v17));
            v48 = vsub_f32(v46, vcvt_f32_s32(v47));
            v49 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, v42)), (float32x2_t)0xBF000000BF000000), 0), v16);
            v50 = vcvt_s32_f32(vmin_f32(v49, v17));
            v51 = vsub_f32(v49, vcvt_f32_s32(v50));
            v52 = vmla_s32(vzip1_s32(v47, v50), vzip2_s32(v47, v50), vdup_n_s32(v44));
            v53 = (float32x4_t *)(*(_QWORD *)&v43 + 16 * v52.i32[0]);
            v54 = (int)v44 + 1;
            v55 = vaddq_f32(*v53, vmulq_n_f32(vsubq_f32(v53[1], *v53), v48.f32[0]));
            v56 = vaddq_f32(v55, vmulq_lane_f32(vsubq_f32(vaddq_f32(v53[v44], vmulq_n_f32(vsubq_f32(v53[v54], v53[v44]), v48.f32[0])), v55), v48, 1));
            v57 = (float32x4_t *)(*(_QWORD *)&v43 + 16 * v52.i32[1]);
            v58 = vaddq_f32(*v57, vmulq_n_f32(vsubq_f32(v57[1], *v57), v51.f32[0]));
            v59 = vaddq_f32(v58, vmulq_lane_f32(vsubq_f32(vaddq_f32(v57[v44], vmulq_n_f32(vsubq_f32(v57[v54], v57[v44]), v51.f32[0])), v58), v51, 1));
          }
          else
          {
            v60 = vcvt_s32_f32(vmin_f32(vmax_f32(v45, 0), v16));
            v61 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, v42)), 0), v16));
            v62 = vmla_s32(vzip1_s32(v60, v61), vzip2_s32(v60, v61), vdup_n_s32(v44));
            v63 = v62.i32[1];
            v56 = *(float32x4_t *)(*(_QWORD *)&v43 + 16 * v62.i32[0]);
            v59 = *(float32x4_t *)(*(_QWORD *)&v43 + 16 * v63);
          }
          v64 = (float32x4_t)vextq_s8(v34, v33, 8uLL);
          v65 = vcvtq_f32_s32(vcvtq_s32_f32(v64));
          v66 = vsubq_f32(v65, (float32x4_t)vandq_s8(*(int8x16_t *)(v32 + 128), (int8x16_t)vcgtq_f32(v65, v64)));
          v67 = (int8x16_t)vnegq_f32(v66);
          v68 = vaddq_f32(v66, (float32x4_t)vextq_s8(v67, v67, 8uLL));
          v69 = (int8x16_t)vaddq_f32(v35, v40);
          v70 = vadd_f32(*(float32x2_t *)v33.i8, *(float32x2_t *)v37.i8);
          LODWORD(v71) = vaddq_f32(v68, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 1)).u32[0];
          v72 = vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, (float32x2_t)*(_OWORD *)&vextq_s8(v69, v69, 8uLL)));
          if (v5)
          {
            v73 = vmin_f32(vmax_f32(vadd_f32(v72, (float32x2_t)0xBF000000BF000000), 0), v16);
            v74 = vcvt_s32_f32(vmin_f32(v73, v17));
            v75 = vsub_f32(v73, vcvt_f32_s32(v74));
            v76 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, v70)), (float32x2_t)0xBF000000BF000000), 0), v16);
            v77 = vcvt_s32_f32(vmin_f32(v76, v17));
            v78 = vsub_f32(v76, vcvt_f32_s32(v77));
            v79 = vmla_s32(vzip1_s32(v74, v77), vzip2_s32(v74, v77), vdup_n_s32(v44));
            v80 = (float32x4_t *)(*(_QWORD *)&v43 + 16 * v79.i32[0]);
            v81 = (int)v44 + 1;
            v82 = vaddq_f32(*v80, vmulq_n_f32(vsubq_f32(v80[1], *v80), v75.f32[0]));
            v30 = vaddq_f32(v82, vmulq_lane_f32(vsubq_f32(vaddq_f32(v80[v44], vmulq_n_f32(vsubq_f32(v80[v81], v80[v44]), v75.f32[0])), v82), v75, 1));
            v83 = (float32x4_t *)(*(_QWORD *)&v43 + 16 * v79.i32[1]);
            v84 = vaddq_f32(*v83, vmulq_n_f32(vsubq_f32(v83[1], *v83), v78.f32[0]));
            v31 = vaddq_f32(v84, vmulq_lane_f32(vsubq_f32(vaddq_f32(v83[v44], vmulq_n_f32(vsubq_f32(v83[v81], v83[v44]), v78.f32[0])), v84), v78, 1));
          }
          else
          {
            v26 = vcvt_s32_f32(vmin_f32(vmax_f32(v72, 0), v16));
            v27 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, v70)), 0), v16));
            v28 = vmla_s32(vzip1_s32(v26, v27), vzip2_s32(v26, v27), vdup_n_s32(v44));
            v29 = v28.i32[1];
            v30 = *(float32x4_t *)(*(_QWORD *)&v43 + 16 * v28.i32[0]);
            v31 = *(float32x4_t *)(*(_QWORD *)&v43 + 16 * v29);
          }
          *(float32x4_t *)(*(_QWORD *)&v19 + v23) = vaddq_f32(vmulq_f32(vaddq_f32(v56, v59), vaddq_f32(*(float32x4_t *)(v32 + 16), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v32 + 48), *(float32x4_t *)(v32 + 16)), v71))), vmulq_f32(vaddq_f32(*(float32x4_t *)v32, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v32 + 32), *(float32x4_t *)v32), v71)), vaddq_f32(v30, v31)));
          v24 = vaddq_f32(v24, (float32x4_t)xmmword_1B304F230);
          v25 = vaddq_f32(v25, (float32x4_t)xmmword_1B304F230);
          v23 += 16;
        }
        while (v21 != v23);
        v18 = vaddq_f32(v18, (float32x4_t)xmmword_1B304F240);
        v22 = vaddq_f32(v22, (float32x4_t)xmmword_1B304F240);
        ++v9;
        *(_QWORD *)&v19 += v20;
      }
      while (v9 != v7);
    }
  }
  return 0;
}

uint64_t HgcBlur_g4u2::GetDOD(HgcBlur_g4u2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcBlur_g4u2::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcBlur_g4u2::HgcBlur_g4u2(HgcBlur_g4u2 *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6543900;
  v3 = (_OWORD *)operator new();
  v3[6] = 0u;
  v3[7] = 0u;
  v3[4] = 0u;
  v3[5] = 0u;
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  __asm { FMOV            V0.4S, #1.0 }
  v3[8] = _Q0;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcBlur_g4u2 *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 5);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BD14EC(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBlur_g4u2::~HgcBlur_g4u2(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6543900;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6543900;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6543900;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBlur_g4u2::SetParameter(HgcBlur_g4u2 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 7)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlur_g4u2::GetParameter(HgcBlur_g4u2 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 7)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBlur_g4u2_rect::GetProgram(HgcBlur_g4u2_rect *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000005f2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    float4 s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord1.xy*hg_Params[4].xy + frag._texCoord0.xy;\n"
             "    s1.xy = s0.xy - hg_Params[6].xy;\n"
             "    s2.xy = s0.xy + hg_Params[5].xy;\n"
             "    s3.xy = s2.xy + hg_Params[6].xy;\n"
             "    s4.xy = floor(s0.xy);\n"
             "    s5.xy = floor(s2.xy);\n"
             "    s4.xy = s5.xy - s4.xy;\n"
             "    s4 = s4.xxxx + s4.yyyy;\n"
             "    s6 = mix(hg_Params[0], hg_Params[2], s4);\n"
             "    s7 = mix(hg_Params[1], hg_Params[3], s4);\n"
             "    s9.xy = s1.xy + hg_Params[7].xy;\n"
             "    s9.xy = s9.xy*hg_Params[7].zw;\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s9.xy = s3.xy + hg_Params[7].xy;\n"
             "    s9.xy = s9.xy*hg_Params[7].zw;\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    r0 = r0 + r1;\n"
             "    s9.xy = s0.xy + hg_Params[7].xy;\n"
             "    s9.xy = s9.xy*hg_Params[7].zw;\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s9.xy = s2.xy + hg_Params[7].xy;\n"
             "    s9.xy = s9.xy*hg_Params[7].zw;\n"
             "    r3 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    r2 = r2 + r3;\n"
             "    s8 = float4(r0)*s7;\n"
             "    s8 = float4(r2)*s6 + s8;\n"
             "    output.color0 = s8;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6880a678:737fce71:a2b9662a:27e9fc5b\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0008:000e:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000005a5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r1.xy = frag._texCoord1.xy*hg_Params[4].xy + frag._texCoord0.xy;\n"
             "    r0.xy = r1.xy - hg_Params[6].xy;\n"
             "    r2.xy = r1.xy + hg_Params[5].xy;\n"
             "    r3.xy = r2.xy + hg_Params[6].xy;\n"
             "    r4.xy = floor(r1.xy);\n"
             "    r5.xy = floor(r2.xy);\n"
             "    r4.xy = r5.xy - r4.xy;\n"
             "    r4 = r4.xxxx + r4.yyyy;\n"
             "    r6 = mix(hg_Params[0], hg_Params[2], r4);\n"
             "    r7 = mix(hg_Params[1], hg_Params[3], r4);\n"
             "    r8.xy = r0.xy + hg_Params[7].xy;\n"
             "    r8.xy = r8.xy*hg_Params[7].zw;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
             "    r8.xy = r3.xy + hg_Params[7].xy;\n"
             "    r8.xy = r8.xy*hg_Params[7].zw;\n"
             "    r3 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
             "    r0 = r0 + r3;\n"
             "    r8.xy = r1.xy + hg_Params[7].xy;\n"
             "    r8.xy = r8.xy*hg_Params[7].zw;\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
             "    r8.xy = r2.xy + hg_Params[7].xy;\n"
             "    r8.xy = r8.xy*hg_Params[7].zw;\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
             "    r1 = r1 + r2;\n"
             "    r0 = r0*r7;\n"
             "    r0 = r1*r6 + r0;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=325c15d5:053de68f:ddd38fee:92ec3141\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0008:0009:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000006af\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "uniform highp vec4 hg_ProgramLocal7;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5, r6, r7, r8;\n"
           "\n"
           "    r1.xy = hg_TexCoord1.xy*hg_ProgramLocal4.xy + hg_TexCoord0.xy;\n"
           "    r0.xy = r1.xy - hg_ProgramLocal6.xy;\n"
           "    r2.xy = r1.xy + hg_ProgramLocal5.xy;\n"
           "    r3.xy = r2.xy + hg_ProgramLocal6.xy;\n"
           "    r4.xy = floor(r1.xy);\n"
           "    r5.xy = floor(r2.xy);\n"
           "    r4.xy = r5.xy - r4.xy;\n"
           "    r4 = r4.xxxx + r4.yyyy;\n"
           "    r6 = mix(hg_ProgramLocal0, hg_ProgramLocal2, r4);\n"
           "    r7 = mix(hg_ProgramLocal1, hg_ProgramLocal3, r4);\n"
           "    r8.xy = r0.xy + hg_ProgramLocal7.xy;\n"
           "    r8.xy = r8.xy*hg_ProgramLocal7.zw;\n"
           "    r0 = texture2D(hg_Texture0, r8.xy);\n"
           "    r8.xy = r3.xy + hg_ProgramLocal7.xy;\n"
           "    r8.xy = r8.xy*hg_ProgramLocal7.zw;\n"
           "    r3 = texture2D(hg_Texture0, r8.xy);\n"
           "    r0 = r0 + r3;\n"
           "    r8.xy = r1.xy + hg_ProgramLocal7.xy;\n"
           "    r8.xy = r8.xy*hg_ProgramLocal7.zw;\n"
           "    r1 = texture2D(hg_Texture0, r8.xy);\n"
           "    r8.xy = r2.xy + hg_ProgramLocal7.xy;\n"
           "    r8.xy = r8.xy*hg_ProgramLocal7.zw;\n"
           "    r2 = texture2D(hg_Texture0, r8.xy);\n"
           "    r1 = r1 + r2;\n"
           "    r0 = r0*r7;\n"
           "    r0 = r1*r6 + r0;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=497577be:b0d0ecde:f4ebf00e:861916a5\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0008:0009:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcBlur_g4u2_rect::InitProgramDescriptor(HgcBlur_g4u2_rect *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlur_g4u2_rect_hgc_visible", "//Metal1.0     \n//LEN=00000004f9\n[[ visible ]] FragmentOut HgcBlur_g4u2_rect_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r1.xy = texCoord1.xy*hg_Params[4].xy + texCoord0.xy;\n"
    "    r0.xy = r1.xy - hg_Params[6].xy;\n"
    "    r2.xy = r1.xy + hg_Params[5].xy;\n"
    "    r3.xy = r2.xy + hg_Params[6].xy;\n"
    "    r4.xy = floor(r1.xy);\n"
    "    r5.xy = floor(r2.xy);\n"
    "    r4.xy = r5.xy - r4.xy;\n"
    "    r4 = r4.xxxx + r4.yyyy;\n"
    "    r6 = mix(hg_Params[0], hg_Params[2], r4);\n"
    "    r7 = mix(hg_Params[1], hg_Params[3], r4);\n"
    "    r8.xy = r0.xy + hg_Params[7].xy;\n"
    "    r8.xy = r8.xy*hg_Params[7].zw;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
    "    r8.xy = r3.xy + hg_Params[7].xy;\n"
    "    r8.xy = r8.xy*hg_Params[7].zw;\n"
    "    r3 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
    "    r0 = r0 + r3;\n"
    "    r8.xy = r1.xy + hg_Params[7].xy;\n"
    "    r8.xy = r8.xy*hg_Params[7].zw;\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
    "    r8.xy = r2.xy + hg_Params[7].xy;\n"
    "    r8.xy = r8.xy*hg_Params[7].zw;\n"
    "    r2 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
    "    r1 = r1 + r2;\n"
    "    r0 = r0*r7;\n"
    "    r0 = r1*r6 + r0;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BD1B10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BD1B4C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BD1B44);
}

char *HgcBlur_g4u2_rect::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3525EE0;
  strcpy(result, "HgcBlur_g4u2_rect [hgc1]");
  return result;
}

uint64_t HgcBlur_g4u2_rect::BindTexture(HgcBlur_g4u2_rect *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 7, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcBlur_g4u2_rect::Bind(HgcBlur_g4u2_rect *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 6, *((_QWORD *)this + 51) + 96, 1);
  (*(void (**)(HgcBlur_g4u2_rect *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBlur_g4u2_rect::RenderTile(HgcBlur_g4u2_rect *this, HGTile *a2)
{
  uint64_t v4;
  int v5;
  int32x2_t v6;
  int v7;
  uint64_t v8;
  float32x4_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  uint64_t v16;
  float32x4_t v17;
  float32x4_t v18;
  uint64_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  uint64_t v31;
  uint64_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int32x4_t v35;
  float32x4_t v36;
  float32x4_t *v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  uint64_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t *v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  int32x4_t v55;
  float32x4_t v56;
  float32x4_t *v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  int32x4_t v61;
  float32x4_t v62;
  float32x4_t *v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  uint64_t v68;
  float32x4_t v69;
  float32x4_t v70;
  uint64_t v71;
  float32x4_t v72;
  float32x4_t v73;
  int8x16_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  uint64_t v83;
  float32x4_t v84;
  int32x4_t v85;
  int v86;
  __int32 v87;
  __int32 v88;
  float32x4_t v89;
  int32x4_t v90;
  float32x4_t v91;
  int32x4_t v92;
  __int32 v93;
  __int32 v94;
  __int32 v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  int32x4_t v102;

  v4 = HGTile::Renderer(a2);
  v5 = (*(uint64_t (**)(HgcBlur_g4u2_rect *, uint64_t))(*(_QWORD *)this + 312))(this, v4);
  v6 = *(int32x2_t *)a2;
  v7 = *((_DWORD *)a2 + 3) - HIDWORD(*(_QWORD *)a2);
  if (v7 >= 1)
  {
    v8 = (*((_DWORD *)a2 + 2) - v6.i32[0]);
    if ((int)v8 >= 1)
    {
      *(float32x2_t *)v9.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
      v9.i64[1] = 0x3F80000000000000;
      v10 = *((_QWORD *)a2 + 2);
      v11 = 0;
      v12 = 16 * *((int *)a2 + 6);
      v13 = 16 * v8;
      if (v5)
      {
        v14 = v9;
        v15 = v9;
        do
        {
          v16 = 0;
          v17 = v14;
          v18 = v15;
          do
          {
            v19 = *((_QWORD *)this + 51);
            v20 = vaddq_f32(v17, vmulq_f32(v18, *(float32x4_t *)(v19 + 64)));
            v21 = *(float32x4_t *)(v19 + 96);
            v22 = vsubq_f32(v20, v21);
            v23 = vaddq_f32(v20, *(float32x4_t *)(v19 + 80));
            v24 = vaddq_f32(v21, v23);
            v25 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
            v26 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
            v25.i64[0] = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v25, v20), *(int8x16_t *)(v19 + 112), (int8x16_t)0), v25), vsubq_f32(v26, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v26, v23), *(int8x16_t *)(v19 + 112), (int8x16_t)0))).u64[0];
            v27 = *(float32x4_t *)v19;
            v28 = *(float32x4_t *)(v19 + 16);
            v29 = vsubq_f32(*(float32x4_t *)(v19 + 32), *(float32x4_t *)v19);
            v30 = vsubq_f32(*(float32x4_t *)(v19 + 48), v28);
            v31 = *((_QWORD *)a2 + 10);
            v32 = *((int *)a2 + 22);
            v33 = vsubq_f32(v22, v9);
            v34 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1));
            v35 = vaddq_s32(vcvtq_s32_f32(v33), vcltzq_f32(v33));
            v36 = vmulq_f32(v29, v34);
            v33.i64[0] = vsubq_f32(v33, vcvtq_f32_s32(v35)).u64[0];
            v37 = (float32x4_t *)(v31 + 16 * (v35.i32[0] + v35.i32[1] * (int)v32));
            v38 = vmulq_f32(v30, v34);
            v39 = *v37;
            v40 = v37[v32];
            v41 = vmulq_n_f32(vsubq_f32(v37[1], *v37), v33.f32[0]);
            v42 = (int)v32 + 1;
            v43 = vmulq_n_f32(vsubq_f32(v37[v42], v40), v33.f32[0]);
            v44 = vsubq_f32(v24, v9);
            v45 = vaddq_s32(vcvtq_s32_f32(v44), vcltzq_f32(v44));
            v46 = vaddq_f32(v27, v36);
            v36.i64[0] = vsubq_f32(v44, vcvtq_f32_s32(v45)).u64[0];
            v47 = vaddq_f32(v28, v38);
            v48 = (float32x4_t *)(v31 + 16 * (v45.i32[0] + v45.i32[1] * (int)v32));
            v49 = *v48;
            v50 = v48[v32];
            v51 = vaddq_f32(v39, v41);
            v52 = vsubq_f32(v48[v42], v50);
            v53 = vsubq_f32(v20, v9);
            v54 = vaddq_f32(v40, v43);
            v55 = vaddq_s32(vcvtq_s32_f32(v53), vcltzq_f32(v53));
            v53.i64[0] = vsubq_f32(v53, vcvtq_f32_s32(v55)).u64[0];
            v56 = vmulq_n_f32(vsubq_f32(v48[1], *v48), v36.f32[0]);
            v57 = (float32x4_t *)(v31 + 16 * (v55.i32[0] + v55.i32[1] * (int)v32));
            v58 = vaddq_f32(*v57, vmulq_n_f32(vsubq_f32(v57[1], *v57), v53.f32[0]));
            v59 = vaddq_f32(v49, v56);
            v60 = vsubq_f32(v23, v9);
            v61 = vaddq_s32(vcvtq_s32_f32(v60), vcltzq_f32(v60));
            v60.i64[0] = vsubq_f32(v60, vcvtq_f32_s32(v61)).u64[0];
            v62 = vaddq_f32(v51, vmulq_lane_f32(vsubq_f32(v54, v51), *(float32x2_t *)v33.f32, 1));
            v63 = (float32x4_t *)(v31 + 16 * (v61.i32[0] + v61.i32[1] * (int)v32));
            v64 = vaddq_f32(*v63, vmulq_n_f32(vsubq_f32(v63[1], *v63), v60.f32[0]));
            *(float32x4_t *)(v10 + v16) = vaddq_f32(vmulq_f32(v47, vaddq_f32(v62, vaddq_f32(v59, vmulq_lane_f32(vsubq_f32(vaddq_f32(v50, vmulq_n_f32(v52, v36.f32[0])), v59), *(float32x2_t *)v36.f32, 1)))), vmulq_f32(v46, vaddq_f32(vaddq_f32(v58, vmulq_lane_f32(vsubq_f32(vaddq_f32(v57[v32],
                                                        vmulq_n_f32(vsubq_f32(v57[v42], v57[v32]), v53.f32[0])),
                                                      v58),
                                                    *(float32x2_t *)v53.f32,
                                                    1)),
                                                vaddq_f32(v64, vmulq_lane_f32(vsubq_f32(vaddq_f32(v63[v32], vmulq_n_f32(vsubq_f32(v63[v42], v63[v32]), v60.f32[0])), v64), *(float32x2_t *)v60.f32, 1)))));
            v17 = vaddq_f32(v17, (float32x4_t)xmmword_1B304F230);
            v18 = vaddq_f32(v18, (float32x4_t)xmmword_1B304F230);
            v16 += 16;
          }
          while (v13 != v16);
          v14 = vaddq_f32(v14, (float32x4_t)xmmword_1B304F240);
          v15 = vaddq_f32(v15, (float32x4_t)xmmword_1B304F240);
          ++v11;
          v10 += v12;
        }
        while (v11 != v7);
      }
      else
      {
        v65.i64[0] = 0x3F0000003F000000;
        v65.i64[1] = 0x3F0000003F000000;
        v66 = v9;
        v67 = v9;
        do
        {
          v68 = 0;
          v69 = v66;
          v70 = v67;
          do
          {
            v71 = *((_QWORD *)this + 51);
            v72 = vaddq_f32(v69, vmulq_f32(v70, *(float32x4_t *)(v71 + 64)));
            v73 = *(float32x4_t *)(v71 + 96);
            v74 = *(int8x16_t *)(v71 + 112);
            v75 = vaddq_f32(v72, *(float32x4_t *)(v71 + 80));
            v76 = vcvtq_f32_s32(vcvtq_s32_f32(v72));
            v77 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v76, v72), v74, (int8x16_t)0);
            v78 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
            v79 = vsubq_f32(v78, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v78, v75), v74, (int8x16_t)0));
            v80 = vsubq_f32(v77, v76);
            v81 = *(float32x4_t *)(v71 + 32);
            v82 = *(float32x4_t *)(v71 + 48);
            v83 = *((_QWORD *)a2 + 10);
            v79.i64[0] = vaddq_f32(v80, v79).u64[0];
            v84 = vaddq_f32(vsubq_f32(vsubq_f32(v72, v73), v9), v65);
            v85 = vcvtq_s32_f32(v84);
            v86 = *((_DWORD *)a2 + 22);
            v84.i64[0] = vaddq_s32(v85, vcgtq_f32(vcvtq_f32_s32(v85), v84)).u64[0];
            v87 = v84.i32[1];
            v88 = v84.i32[0];
            v89 = vaddq_f32(vsubq_f32(vaddq_f32(v73, v75), v9), v65);
            v90 = vcvtq_s32_f32(v89);
            v89.i64[0] = vaddq_s32(v90, vcgtq_f32(vcvtq_f32_s32(v90), v89)).u64[0];
            v91 = vaddq_f32(vsubq_f32(v72, v9), v65);
            v92 = vcvtq_s32_f32(v91);
            v91.i64[0] = vaddq_s32(v92, vcgtq_f32(vcvtq_f32_s32(v92), v91)).u64[0];
            v93 = v88 + v87 * v86;
            v94 = v91.i32[1];
            v95 = v91.i32[0];
            v96 = *(float32x4_t *)v71;
            v97 = *(float32x4_t *)(v71 + 16);
            LODWORD(v71) = v89.i32[0] + v89.i32[1] * v86;
            v98 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v79.f32, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v79.f32, 1));
            v99 = vaddq_f32(v96, vmulq_f32(vsubq_f32(v81, v96), v98));
            v100 = vaddq_f32(v97, vmulq_f32(vsubq_f32(v82, v97), v98));
            v101 = vaddq_f32(vsubq_f32(v75, v9), v65);
            v102 = vcvtq_s32_f32(v101);
            v101.i64[0] = vaddq_s32(v102, vcgtq_f32(vcvtq_f32_s32(v102), v101)).u64[0];
            *(float32x4_t *)(v10 + v68) = vaddq_f32(vmulq_f32(v100, vaddq_f32(*(float32x4_t *)(v83 + 16 * v93), *(float32x4_t *)(v83 + 16 * (int)v71))), vmulq_f32(v99, vaddq_f32(*(float32x4_t *)(v83 + 16 * (v95 + v94 * v86)), *(float32x4_t *)(v83 + 16 * (v101.i32[0] + v101.i32[1] * v86)))));
            v69 = vaddq_f32(v69, (float32x4_t)xmmword_1B304F230);
            v70 = vaddq_f32(v70, (float32x4_t)xmmword_1B304F230);
            v68 += 16;
          }
          while (v13 != v68);
          v66 = vaddq_f32(v66, (float32x4_t)xmmword_1B304F240);
          v67 = vaddq_f32(v67, (float32x4_t)xmmword_1B304F240);
          ++v11;
          v10 += v12;
        }
        while (v11 != v7);
      }
    }
  }
  return 0;
}

uint64_t HgcBlur_g4u2_rect::GetDOD(HgcBlur_g4u2_rect *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  if ((*(int (**)(HgcBlur_g4u2_rect *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2) >= 1)
  {
    v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    HGRectGrow(v6, v5, v7);
  }
  return 0x8000000080000000;
}

uint64_t HgcBlur_g4u2_rect::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t DOD;
  HGNode *Input;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  DOD = HGRenderer::GetDOD(a2, Input);
  v10 = v9;
  if ((*(int (**)(HGNode *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2) < 1)
    return DOD;
  v11 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  return HGRectGrow(DOD, v10, v11);
}

void HgcBlur_g4u2_rect::HgcBlur_g4u2_rect(HgcBlur_g4u2_rect *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6543B68;
  v3 = (_OWORD *)operator new();
  v3[4] = 0u;
  v3[5] = 0u;
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  v3[6] = 0u;
  v3[7] = xmmword_1B30520F0;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcBlur_g4u2_rect *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BD23E4(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBlur_g4u2_rect::~HgcBlur_g4u2_rect(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6543B68;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6543B68;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6543B68;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBlur_g4u2_rect::SetParameter(HgcBlur_g4u2_rect *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 6)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlur_g4u2_rect::GetParameter(HgcBlur_g4u2_rect *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 6)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcApply3DLUTTetrahedral_basekernel::GetProgram(HgcApply3DLUTTetrahedral_basekernel *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return aMetal10Len0000_1169;
    else
      return aMetal10Len0000_1170;
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_438;
  }
}

void HgcApply3DLUTTetrahedral_basekernel::InitProgramDescriptor(HgcApply3DLUTTetrahedral_basekernel *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcApply3DLUTTetrahedral_basekernel_hgc_visible", aMetal10Len0000_1171);
}

void sub_1B2BD2A9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,void *a23)
{
  if (a20 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a23);
  _Unwind_Resume(a1);
}

void sub_1B2BD2ADC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BD2AD4);
}

double HgcApply3DLUTTetrahedral_basekernel::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x30uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3553D00;
  strcpy(v3, "HgcApply3DLUTTetrahedral_basekernel [hgc1]");
  return *(double *)"asekernel [hgc1]";
}

uint64_t HgcApply3DLUTTetrahedral_basekernel::BindTexture(HgcApply3DLUTTetrahedral_basekernel *this, HGHandler *a2, int a3)
{
  int v4;
  uint64_t result;
  __n128 v6;
  __n128 v7;
  __n128 v8;
  __n128 v9;
  __n128 v10;
  __n128 v11;
  __n128 v12;
  __n128 v13;

  if (a3 == 2)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    {
      v8.n128_u32[0] = 1.0;
      v9.n128_u32[0] = 1.0;
    }
    else
    {
      v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v9.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v6.n128_f32[0] = (float)*((int *)a2 + 60);
    v7.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 5, v6, v7, v8, v9);
    return 0;
  }
  else if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    {
      v12.n128_u32[0] = 1.0;
      v13.n128_u32[0] = 1.0;
    }
    else
    {
      v12.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v13.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v10.n128_f32[0] = (float)*((int *)a2 + 60);
    v11.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 4, v10, v11, v12, v13);
    return 0;
  }
  else if (a3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    v4 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
    result = 0;
    if (!v4)
    {
      (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcApply3DLUTTetrahedral_basekernel::Bind(HgcApply3DLUTTetrahedral_basekernel *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HgcApply3DLUTTetrahedral_basekernel *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcApply3DLUTTetrahedral_basekernel::RenderTile(HgcApply3DLUTTetrahedral_basekernel *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  int v5;
  float32x4_t v6;
  int32x2_t v7;
  int32x2_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  _OWORD *v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int32x2_t v33;
  __int32 v34;
  float32x4_t v35;
  int32x4_t v36;
  __int32 v37;
  __int32 v38;
  float32x4_t v39;
  float32x4_t v40;
  __int32 v41;
  int32x4_t v42;
  __int32 v43;
  __int32 v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  int32x4_t v49;
  __int32 v50;
  __int32 v51;
  int8x16_t v52;
  float32x4_t v53;
  __int32 v54;
  float32x4_t v55;
  int32x4_t v56;
  float32x4_t v57;
  int8x16_t v58;
  float32x4_t v59;
  float32x4_t v60;
  int32x4_t v61;
  int32x4_t v62;
  int32x2_t v63;
  __int32 v64;
  __int32 v65;
  float32x4_t v66;
  int32x4_t v67;
  __int32 v68;
  int32x4_t v69;
  __int32 v70;
  float32x4_t v71;
  int32x4_t v72;
  int32x4_t v73;
  float32x4_t v74;
  __int32 v75;
  float32x4_t v76;
  float32x4_t v77;
  int32x4_t v78;
  __int32 v79;
  __int32 v80;
  __int32 v81;
  __int32 v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int32x4_t v86;
  __int32 v87;
  __int32 v88;
  int8x16_t v89;
  int32x4_t v90;
  __int32 v91;
  float32x4_t v92;
  float32x4_t v93;
  int32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  __int32 v99;
  int32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  int8x16_t v105;
  __int32 v106;
  float32x4_t v107;
  int8x16_t v108;
  int32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  int32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  int8x16_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      v7 = a2[10];
      v8 = a2[2];
      v9 = 16 * a2[11].i32[0];
      v10 = 16 * a2[3].i32[0];
      v11 = 16 * v4;
      v12.i64[0] = 0x3F0000003F000000;
      v12.i64[1] = 0x3F0000003F000000;
      do
      {
        v13 = 0;
        do
        {
          v14 = *(float32x4_t *)(*(_QWORD *)&v7 + v13);
          v15 = (_OWORD *)*((_QWORD *)this + 51);
          v16 = *(float32x4_t *)v15;
          v17 = *((float32x4_t *)v15 + 1);
          v18 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15, 1), vmulq_n_f32(v14, COERCE_FLOAT(*v15)));
          v19 = *((float32x4_t *)v15 + 2);
          v20 = vmulq_f32(v18, v18);
          v21 = *((float32x4_t *)v15 + 4);
          v22 = *((float32x4_t *)v15 + 5);
          v23 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1), v22);
          v24 = vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)v15[3], 0), vmulq_lane_f32(v18, (float32x2_t)v15[3], 1)), vmulq_laneq_f32(v20, *((float32x4_t *)v15 + 3), 2)), vmulq_laneq_f32(vmulq_f32(v18, v20), *((float32x4_t *)v15 + 3), 3)), v21), v23);
          v25 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
          v26 = vsubq_f32(v25, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v25, v24)));
          v27 = vminq_f32(vaddq_f32(v22, v26), v23);
          v28 = vmulq_f32(v17, v26);
          v29 = *((float32x4_t *)v15 + 6);
          v30 = *((float32x4_t *)v15 + 7);
          v31 = vmulq_f32(v17, vsubq_f32(v27, v26));
          v32 = vaddq_f32(v30, (float32x4_t)vbslq_s8((int8x16_t)v29, (int8x16_t)vaddq_f32(v28, (float32x4_t)vrev64q_s32((int32x4_t)v28)), vextq_s8((int8x16_t)v26, (int8x16_t)v26, 4uLL)));
          v33 = a2[12];
          v34 = a2[13].i32[0];
          v35 = vaddq_f32(vsubq_f32(v32, v6), v12);
          v36 = vcvtq_s32_f32(v35);
          v35.i64[0] = vaddq_s32(v36, vcgtq_f32(vcvtq_f32_s32(v36), v35)).u64[0];
          v37 = v35.i32[1];
          v38 = v35.i32[0];
          v39 = (float32x4_t)vbslq_s8((int8x16_t)v29, (int8x16_t)vaddq_f32(v31, v32), (int8x16_t)v32);
          v40 = vaddq_f32(vsubq_f32(v39, v6), v12);
          v41 = v38 + v37 * v34;
          v42 = vcvtq_s32_f32(v40);
          v40.i64[0] = vaddq_s32(v42, vcgtq_f32(vcvtq_f32_s32(v42), v40)).u64[0];
          v43 = v40.i32[1];
          v44 = v40.i32[0];
          v45 = (float32x4_t)vrev64q_s32((int32x4_t)v31);
          v46 = (float32x4_t)vbslq_s8((int8x16_t)v29, (int8x16_t)vaddq_f32(v45, v39), (int8x16_t)v32);
          v47 = *(float32x4_t *)(*(_QWORD *)&v33 + 16 * v41);
          v48 = vaddq_f32(vsubq_f32(v46, v6), v12);
          v49 = vcvtq_s32_f32(v48);
          v50 = v44 + v43 * v34;
          v48.i64[0] = vaddq_s32(v49, vcgtq_f32(vcvtq_f32_s32(v49), v48)).u64[0];
          v51 = v48.i32[1];
          v52 = (int8x16_t)vsubq_f32(v46, v31);
          v53 = (float32x4_t)vbslq_s8((int8x16_t)v29, v52, (int8x16_t)v32);
          v54 = v48.i32[0];
          v55 = vaddq_f32(vsubq_f32(v53, v6), v12);
          v56 = vcvtq_s32_f32(v55);
          v57 = *(float32x4_t *)(*(_QWORD *)&v33 + 16 * v50);
          v58 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v31, (int8x16_t)v31, 4uLL), v53);
          v59 = (float32x4_t)vbslq_s8((int8x16_t)v29, v52, v58);
          v55.i64[0] = vaddq_s32(v56, vcgtq_f32(vcvtq_f32_s32(v56), v55)).u64[0];
          v60 = vaddq_f32(vsubq_f32(v59, v6), v12);
          v61 = vcvtq_s32_f32(v60);
          v62 = (int32x4_t)vaddq_f32(v30, v26);
          v63 = a2[14];
          v64 = v54 + v51 * v34;
          v65 = a2[15].i32[0];
          v66 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)v29, (int8x16_t)v62, (int8x16_t)v30), v6), v12);
          v67 = vcvtq_s32_f32(v66);
          v66.i64[0] = vaddq_s32(v67, vcgtq_f32(vcvtq_f32_s32(v67), v66)).u64[0];
          v68 = v55.i32[1];
          v69 = *(int32x4_t *)(*(_QWORD *)&v63 + 16 * (v66.i32[0] + v66.i32[1] * v65));
          v70 = v55.i32[0];
          v71 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)v29, (int8x16_t)vrev64q_s32(v62), (int8x16_t)v30), v6), v12);
          v72 = vcvtq_s32_f32(v71);
          v73 = vcgtq_f32(vcvtq_f32_s32(v61), v60);
          v71.i64[0] = vaddq_s32(v72, vcgtq_f32(vcvtq_f32_s32(v72), v71)).u64[0];
          v74 = *(float32x4_t *)(*(_QWORD *)&v33 + 16 * v64);
          v75 = v71.i32[0] + v71.i32[1] * v65;
          v76 = vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)v29, vextq_s8((int8x16_t)v62, (int8x16_t)v62, 8uLL), (int8x16_t)v30), v6);
          v30.i64[0] = vaddq_s32(v61, v73).u64[0];
          v77 = vaddq_f32(v76, v12);
          v78 = vcvtq_s32_f32(v77);
          v77.i64[0] = vaddq_s32(v78, vcgtq_f32(vcvtq_f32_s32(v78), v77)).u64[0];
          v79 = v70 + v68 * v34;
          v80 = v77.i32[0] + v77.i32[1] * v65;
          v81 = v30.i32[1];
          v82 = v30.i32[0];
          v83 = (float32x4_t)vbslq_s8((int8x16_t)v29, (int8x16_t)vsubq_f32(v59, v45), v58);
          v84 = *(float32x4_t *)(*(_QWORD *)&v33 + 16 * v79);
          v85 = vaddq_f32(vsubq_f32(v83, v6), v12);
          v86 = vcvtq_s32_f32(v85);
          v85.i64[0] = vaddq_s32(v86, vcgtq_f32(vcvtq_f32_s32(v86), v85)).u64[0];
          v87 = v82 + v81 * v34;
          v88 = v85.i32[1];
          v89 = (int8x16_t)vaddq_f32(v31, v83);
          v90 = *(int32x4_t *)(*(_QWORD *)&v63 + 16 * v75);
          v91 = v85.i32[0];
          v92 = (float32x4_t)vbslq_s8((int8x16_t)v29, v89, v58);
          v93 = vaddq_f32(vsubq_f32(v92, v6), v12);
          v94 = vcvtq_s32_f32(v93);
          v95 = *(float32x4_t *)(*(_QWORD *)&v33 + 16 * v87);
          v93.i64[0] = vaddq_s32(v94, vcgtq_f32(vcvtq_f32_s32(v94), v93)).u64[0];
          v96 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)v29, (int8x16_t)vaddq_f32(v45, v92), v58), v6), v12);
          v97 = *(float32x4_t *)(*(_QWORD *)&v63 + 16 * v80);
          v63.i32[0] = v93.i32[1];
          v98 = (float32x4_t)vcvtq_s32_f32(v96);
          v72.i64[0] = vrev64q_s32(v90).u64[0];
          v90.i64[0] = vbslq_s8((int8x16_t)v29, (int8x16_t)vrev64q_s32(v69), (int8x16_t)v90).u64[0];
          v99 = v93.i32[0];
          *(int8x8_t *)v29.f32 = vorr_s8(vand_s8(*(int8x8_t *)v72.i8, (int8x8_t)*(_OWORD *)&vmvnq_s8((int8x16_t)v29)), vand_s8(*(int8x8_t *)v29.f32, *(int8x8_t *)v69.i8));
          v29.i64[1] = v97.i64[0];
          v100 = vcgtq_f32(vcvtq_f32_s32((int32x4_t)v98), v96);
          v101 = (float32x4_t)vextq_s8((int8x16_t)v6, (int8x16_t)v97, 0xCuLL);
          v101.i64[0] = v90.i64[0];
          v102 = *(float32x4_t *)(*(_QWORD *)&v33 + 16 * (v91 + v88 * v34));
          v103 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v21, vsubq_f32(v18, v22)), (int8x16_t)vmulq_f32(v101, vsubq_f32(vmaxq_f32(v18, v21), v29)), (int8x16_t)v21);
          v29.i64[0] = vaddq_s32((int32x4_t)v98, v100).u64[0];
          v104 = *((float32x4_t *)v15 + 8);
          v105 = *((int8x16_t *)v15 + 9);
          *(int8x8_t *)v97.f32 = vqtbl1_s8((int8x16_t)v103, *(int8x8_t *)v104.f32);
          *(int8x8_t *)&v97.u32[2] = vqtbl1_s8((int8x16_t)v103, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v104, (int8x16_t)v104, 8uLL));
          *(int8x8_t *)v104.f32 = vqtbl1_s8((int8x16_t)v103, *(int8x8_t *)v105.i8);
          v106 = v29.i32[1];
          *(int8x8_t *)&v104.u32[2] = vqtbl1_s8((int8x16_t)v103, (int8x8_t)*(_OWORD *)&vextq_s8(v105, v105, 8uLL));
          v107 = *((float32x4_t *)v15 + 10);
          v108 = *((int8x16_t *)v15 + 11);
          LODWORD(v15) = v29.i32[0];
          v109 = (int32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v104, v97));
          v110 = *(float32x4_t *)(*(_QWORD *)&v33 + 16 * (v99 + v63.i32[0] * v34));
          *(int8x8_t *)v98.f32 = vqtbl1_s8((int8x16_t)v103, *(int8x8_t *)v107.f32);
          *(int8x8_t *)&v98.u32[2] = vqtbl1_s8((int8x16_t)v103, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v107, (int8x16_t)v107, 8uLL));
          v104.i64[0] = vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v103), v103)).u64[0];
          *(int8x8_t *)v107.f32 = vqtbl1_s8((int8x16_t)v103, *(int8x8_t *)v108.i8);
          v111 = *(float32x4_t *)(*(_QWORD *)&v33 + 16 * ((int)v15 + v106 * v34));
          *(int8x8_t *)&v107.u32[2] = vqtbl1_s8((int8x16_t)v103, (int8x8_t)*(_OWORD *)&vextq_s8(v108, v108, 8uLL));
          v112 = (int32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgeq_f32(v107, v98));
          v113 = vmulq_lane_f32(vsubq_f32(v84, v47), *(float32x2_t *)v103.f32, 1);
          v114 = vmulq_n_f32(vsubq_f32(v111, v95), v103.f32[0]);
          v115 = vmulq_n_f32(vsubq_f32(v110, v102), v103.f32[0]);
          v116 = vmulq_laneq_f32(vsubq_f32(v102, v47), v103, 2);
          v117 = vmulq_lane_f32(vsubq_f32(v111, v110), *(float32x2_t *)v103.f32, 1);
          v118 = vmulq_lane_f32(vsubq_f32(v95, v102), *(float32x2_t *)v103.f32, 1);
          v119 = (int8x16_t)vaddq_f32(vmulq_laneq_f32(vsubq_f32(v95, v84), v103, 2), vaddq_f32(v114, v113));
          v120 = vmulq_n_f32(vsubq_f32(v57, v47), v103.f32[0]);
          v121 = vaddq_f32(v120, vmulq_lane_f32(vsubq_f32(v74, v57), *(float32x2_t *)v103.f32, 1));
          v122 = vmulq_laneq_f32(vsubq_f32(v111, v74), v103, 2);
          v123 = vaddq_f32(vmulq_n_f32(vsubq_f32(v74, v84), v103.f32[0]), v113);
          v124 = (float32x4_t)vdupq_laneq_s32(v112, 2);
          *(int8x16_t *)(*(_QWORD *)&v8 + v13) = vbslq_s8((int8x16_t)vcgtq_f32(v21, v19), (int8x16_t)v14, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), vmulq_laneq_f32(vaddq_f32(v47, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32(v112, 3), v124), v21), (int8x16_t)vaddq_f32(vmulq_laneq_f32(vsubq_f32(v110, v57), v103, 2), vaddq_f32(v120, v117)),
                                                                                   vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32(v124, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v104.f32, 0)), v21), (int8x16_t)vaddq_f32(v122, v123), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32(v109, 3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v112.i8, 1)), v21), (int8x16_t)vaddq_f32(v122, v121), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v112.i8, 0), (float32x4_t)vdupq_laneq_s32(v109, 2)), v21), (int8x16_t)vaddq_f32(v116, vaddq_f32(v114, v118)), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v109.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v109.i8, 1)), v21), (int8x16_t)vaddq_f32(v116, vaddq_f32(v115, v117)), v119)))))), v16,
                                                                  2)));
          v13 += 16;
        }
        while (v11 != v13);
        ++v5;
        *(_QWORD *)&v7 += v9;
        *(_QWORD *)&v8 += v10;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcApply3DLUTTetrahedral_basekernel::GetDOD(HgcApply3DLUTTetrahedral_basekernel *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 2 || a3 == 1)
    return 0x8000000080000000;
  if (a3)
    return 0;
  return *(_QWORD *)&a4.var0;
}

uint64_t HgcApply3DLUTTetrahedral_basekernel::GetROI(HGNode *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  HGNode *Input;

  if (a3 == 2 || a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, a3);
    return HGRenderer::GetDOD(a2, Input);
  }
  else
  {
    if (a3)
      *(_QWORD *)&a4.var0 = 0;
    return *(_QWORD *)&a4.var0;
  }
}

void HgcApply3DLUTTetrahedral_basekernel::HgcApply3DLUTTetrahedral_basekernel(HgcApply3DLUTTetrahedral_basekernel *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6543DD0;
  v3 = (_OWORD *)operator new();
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  __asm { FMOV            V1.4S, #1.0 }
  v3[4] = 0u;
  v3[5] = _Q1;
  v3[6] = xmmword_1B3050E20;
  v3[7] = xmmword_1B3051510;
  v3[8] = xmmword_1B3553D10;
  v3[9] = xmmword_1B3553D20;
  v3[10] = xmmword_1B3553D30;
  v3[11] = xmmword_1B3553D40;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcApply3DLUTTetrahedral_basekernel *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  (*(void (**)(HgcApply3DLUTTetrahedral_basekernel *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 2, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BD34C8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcApply3DLUTTetrahedral_basekernel::~HgcApply3DLUTTetrahedral_basekernel(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6543DD0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C408070C27FLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6543DD0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C408070C27FLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6543DD0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C408070C27FLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcApply3DLUTTetrahedral_basekernel::SetParameter(HgcApply3DLUTTetrahedral_basekernel *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcApply3DLUTTetrahedral_basekernel::GetParameter(HgcApply3DLUTTetrahedral_basekernel *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcApply3DLUTTrilinear_basekernel::GetProgram(HgcApply3DLUTTrilinear_basekernel *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return aMetal10Len0000_1172;
    else
      return "//Metal1.0     \n"
             "//LEN=0000000ea9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = r1.xyz*r1.xyz;\n"
             "    r3.xyz = r2.xyz*r1.xyz;\n"
             "    r4.xyz = r1.xyz*hg_Params[3].yyy + hg_Params[3].xxx;\n"
             "    r4.xyz = r2.xyz*hg_Params[3].zzz + r4.xyz;\n"
             "    r4.xyz = r3.xyz*hg_Params[3].www + r4.xyz;\n"
             "    r4.xyz = fmax(r4.xyz, c0.xxx);\n"
             "    r2.xyz = hg_Params[1].yyy - c0.yyy;\n"
             "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
             "    r4.xyz = floor(r4.xyz);\n"
             "    r3.xyz = r4.xyz + c0.yyy;\n"
             "    r3.xyz = fmin(r3.xyz, r2.xyz);\n"
             "    r3.xyz = r3.xyz - r4.xyz;\n"
             "    r3.xyz = r3.xyz*hg_Params[1].xyz;\n"
             "    r2.x = dot(r4.xy, hg_Params[1].xy);\n"
             "    r2.y = r4.z;\n"
             "    r2.xy = r2.xy + c0.zz;\n"
             "    r5.xy = r2.xy + hg_Params[4].xy;\n"
             "    r5.xy = r5.xy*hg_Params[4].zw;\n"
             "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
             "    r2.x = r2.x + r3.x;\n"
             "    r6.xy = r2.xy + hg_Params[4].xy;\n"
             "    r6.xy = r6.xy*hg_Params[4].zw;\n"
             "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
             "    r2.x = r2.x + r3.y;\n"
             "    r7.xy = r2.xy + hg_Params[4].xy;\n"
             "    r7.xy = r7.xy*hg_Params[4].zw;\n"
             "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
             "    r2.x = r2.x - r3.x;\n"
             "    r8.xy = r2.xy + hg_Params[4].xy;\n"
             "    r8.xy = r8.xy*hg_Params[4].zw;\n"
             "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
             "    r2.y = r2.y + r3.z;\n"
             "    r9.xy = r2.xy + hg_Params[4].xy;\n"
             "    r9.xy = r9.xy*hg_Params[4].zw;\n"
             "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
             "    r2.x = r2.x - r3.y;\n"
             "    r10.xy = r2.xy + hg_Params[4].xy;\n"
             "    r10.xy = r10.xy*hg_Params[4].zw;\n"
             "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
             "    r2.x = r2.x + r3.x;\n"
             "    r11.xy = r2.xy + hg_Params[4].xy;\n"
             "    r11.xy = r11.xy*hg_Params[4].zw;\n"
             "    r11 = hg_Texture1.sample(hg_Sampler1, r11.xy);\n"
             "    r2.x = r2.x + r3.y;\n"
             "    r2.xy = r2.xy + hg_Params[4].xy;\n"
             "    r2.xy = r2.xy*hg_Params[4].zw;\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
             "    r4.xyz = r4.xyz + c0.zzz;\n"
             "    r3.y = c0.z;\n"
             "    r3.x = r4.x;\n"
             "    r12.xy = r3.xy + hg_Params[5].xy;\n"
             "    r12.xy = r12.xy*hg_Params[5].zw;\n"
             "    r12.xy = hg_Texture2.sample(hg_Sampler2, r12.xy).xy;\n"
             "    r13.x = r12.x;\n"
             "    r12.x = r12.y;\n"
             "    r3.x = r4.y;\n"
             "    r14.xy = r3.xy + hg_Params[5].xy;\n"
             "    r14.xy = r14.xy*hg_Params[5].zw;\n"
             "    r14.xy = hg_Texture2.sample(hg_Sampler2, r14.xy).xy;\n"
             "    r13.y = r14.x;\n"
             "    r12.y = r14.y;\n"
             "    r3.x = r4.z;\n"
             "    r3.xy = r3.xy + hg_Params[5].xy;\n"
             "    r3.xy = r3.xy*hg_Params[5].zw;\n"
             "    r3.xy = hg_Texture2.sample(hg_Sampler2, r3.xy).xy;\n"
             "    r13.z = r3.x;\n"
             "    r12.z = r3.y;\n"
             "    r14.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r14.xyz = r14.xyz - r13.xyz;\n"
             "    r14.xyz = r14.xyz*r12.xyz;\n"
             "    r1.xyz = r1.xyz - c0.yyy;\n"
             "    r14.xyz = select(c0.xxx, r14.xyz, r1.xyz < 0.00000f);\n"
             "    r5 = mix(r5, r6, r14.xxxx);\n"
             "    r8 = mix(r8, r7, r14.xxxx);\n"
             "    r10 = mix(r10, r11, r14.xxxx);\n"
             "    r9 = mix(r9, r2, r14.xxxx);\n"
             "    r5 = mix(r5, r8, r14.yyyy);\n"
             "    r10 = mix(r10, r9, r14.yyyy);\n"
             "    r14 = mix(r5, r10, r14.zzzz);\n"
             "    r14 = r14*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
             "    output.color0 = select(r14, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d69a83c9:92974476:ebb55401:991c55ef\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0006:000f:0000:0000:0000:0002:0000:0001:03:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_439;
  }
}

void HgcApply3DLUTTrilinear_basekernel::InitProgramDescriptor(HgcApply3DLUTTrilinear_basekernel *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcApply3DLUTTrilinear_basekernel_hgc_visible", "//Metal1.0     \n//LEN=0000000d50\n[[ visible ]] FragmentOut HgcApply3DLUTTrilinear_basekernel_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1, \n    texture2d< float > hg_Texture2, \n    sampler hg_Sampler2)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = r1.xyz*r1.xyz;\n"
    "    r3.xyz = r2.xyz*r1.xyz;\n"
    "    r4.xyz = r1.xyz*hg_Params[3].yyy + hg_Params[3].xxx;\n"
    "    r4.xyz = r2.xyz*hg_Params[3].zzz + r4.xyz;\n"
    "    r4.xyz = r3.xyz*hg_Params[3].www + r4.xyz;\n"
    "    r4.xyz = fmax(r4.xyz, c0.xxx);\n"
    "    r2.xyz = hg_Params[1].yyy - c0.yyy;\n"
    "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
    "    r4.xyz = floor(r4.xyz);\n"
    "    r3.xyz = r4.xyz + c0.yyy;\n"
    "    r3.xyz = fmin(r3.xyz, r2.xyz);\n"
    "    r3.xyz = r3.xyz - r4.xyz;\n"
    "    r3.xyz = r3.xyz*hg_Params[1].xyz;\n"
    "    r2.x = dot(r4.xy, hg_Params[1].xy);\n"
    "    r2.y = r4.z;\n"
    "    r2.xy = r2.xy + c0.zz;\n"
    "    r5.xy = r2.xy + hg_Params[4].xy;\n"
    "    r5.xy = r5.xy*hg_Params[4].zw;\n"
    "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
    "    r2.x = r2.x + r3.x;\n"
    "    r6.xy = r2.xy + hg_Params[4].xy;\n"
    "    r6.xy = r6.xy*hg_Params[4].zw;\n"
    "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
    "    r2.x = r2.x + r3.y;\n"
    "    r7.xy = r2.xy + hg_Params[4].xy;\n"
    "    r7.xy = r7.xy*hg_Params[4].zw;\n"
    "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
    "    r2.x = r2.x - r3.x;\n"
    "    r8.xy = r2.xy + hg_Params[4].xy;\n"
    "    r8.xy = r8.xy*hg_Params[4].zw;\n"
    "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
    "    r2.y = r2.y + r3.z;\n"
    "    r9.xy = r2.xy + hg_Params[4].xy;\n"
    "    r9.xy = r9.xy*hg_Params[4].zw;\n"
    "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
    "    r2.x = r2.x - r3.y;\n"
    "    r10.xy = r2.xy + hg_Params[4].xy;\n"
    "    r10.xy = r10.xy*hg_Params[4].zw;\n"
    "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
    "    r2.x = r2.x + r3.x;\n"
    "    r11.xy = r2.xy + hg_Params[4].xy;\n"
    "    r11.xy = r11.xy*hg_Params[4].zw;\n"
    "    r11 = hg_Texture1.sample(hg_Sampler1, r11.xy);\n"
    "    r2.x = r2.x + r3.y;\n"
    "    r2.xy = r2.xy + hg_Params[4].xy;\n"
    "    r2.xy = r2.xy*hg_Params[4].zw;\n"
    "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
    "    r4.xyz = r4.xyz + c0.zzz;\n"
    "    r3.y = c0.z;\n"
    "    r3.x = r4.x;\n"
    "    r12.xy = r3.xy + hg_Params[5].xy;\n"
    "    r12.xy = r12.xy*hg_Params[5].zw;\n"
    "    r12.xy = hg_Texture2.sample(hg_Sampler2, r12.xy).xy;\n"
    "    r13.x = r12.x;\n"
    "    r12.x = r12.y;\n"
    "    r3.x = r4.y;\n"
    "    r14.xy = r3.xy + hg_Params[5].xy;\n"
    "    r14.xy = r14.xy*hg_Params[5].zw;\n"
    "    r14.xy = hg_Texture2.sample(hg_Sampler2, r14.xy).xy;\n"
    "    r13.y = r14.x;\n"
    "    r12.y = r14.y;\n"
    "    r3.x = r4.z;\n"
    "    r3.xy = r3.xy + hg_Params[5].xy;\n"
    "    r3.xy = r3.xy*hg_Params[5].zw;\n"
    "    r3.xy = hg_Texture2.sample(hg_Sampler2, r3.xy).xy;\n"
    "    r13.z = r3.x;\n"
    "    r12.z = r3.y;\n"
    "    r14.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r14.xyz = r14.xyz - r13.xyz;\n"
    "    r14.xyz = r14.xyz*r12.xyz;\n"
    "    r1.xyz = r1.xyz - c0.yyy;\n"
    "    r14.xyz = select(c0.xxx, r14.xyz, r1.xyz < 0.00000f);\n"
    "    r5 = mix(r5, r6, r14.xxxx);\n"
    "    r8 = mix(r8, r7, r14.xxxx);\n"
    "    r10 = mix(r10, r11, r14.xxxx);\n"
    "    r9 = mix(r9, r2, r14.xxxx);\n"
    "    r5 = mix(r5, r8, r14.yyyy);\n"
    "    r10 = mix(r10, r9, r14.yyyy);\n"
    "    r14 = mix(r5, r10, r14.zzzz);\n"
    "    r14 = r14*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
    "    output.color0 = select(r14, r0, hg_Params[2] < 0.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BD3B80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,void *a23)
{
  if (a20 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a23);
  _Unwind_Resume(a1);
}

void sub_1B2BD3BC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BD3BB8);
}

char *HgcApply3DLUTTrilinear_basekernel::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x30uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A90;
  strcpy(result, "HgcApply3DLUTTrilinear_basekernel [hgc1]");
  return result;
}

uint64_t HgcApply3DLUTTrilinear_basekernel::BindTexture(HgcApply3DLUTTrilinear_basekernel *this, HGHandler *a2, int a3)
{
  int v4;
  uint64_t result;
  __n128 v6;
  __n128 v7;
  __n128 v8;
  __n128 v9;
  __n128 v10;
  __n128 v11;
  __n128 v12;
  __n128 v13;

  if (a3 == 2)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    {
      v8.n128_u32[0] = 1.0;
      v9.n128_u32[0] = 1.0;
    }
    else
    {
      v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v9.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v6.n128_f32[0] = (float)*((int *)a2 + 60);
    v7.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 5, v6, v7, v8, v9);
    return 0;
  }
  else if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    {
      v12.n128_u32[0] = 1.0;
      v13.n128_u32[0] = 1.0;
    }
    else
    {
      v12.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v13.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v10.n128_f32[0] = (float)*((int *)a2 + 60);
    v11.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 4, v10, v11, v12, v13);
    return 0;
  }
  else if (a3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    v4 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
    result = 0;
    if (!v4)
    {
      (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcApply3DLUTTrilinear_basekernel::Bind(HgcApply3DLUTTrilinear_basekernel *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HgcApply3DLUTTrilinear_basekernel *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcApply3DLUTTrilinear_basekernel::RenderTile(HgcApply3DLUTTrilinear_basekernel *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  int v5;
  float32x4_t v6;
  int32x2_t v7;
  int32x2_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  _OWORD *v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int32x2_t v34;
  __int32 v35;
  float32x4_t v36;
  int32x4_t v37;
  __int32 v38;
  float32x4_t v39;
  __int32 v40;
  float32x4_t v41;
  int32x4_t v42;
  __int32 v43;
  __int32 v44;
  __int32 v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  int32x4_t v50;
  __int32 v51;
  int8x16_t v52;
  __int32 v53;
  float32x4_t v54;
  float32x4_t v55;
  int32x4_t v56;
  __int32 v57;
  int32x4_t v58;
  int8x16_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int32x4_t v63;
  float32x4_t v64;
  int32x4_t v65;
  int32x4_t v66;
  __int32 v67;
  __int32 v68;
  __int32 v69;
  __int32 v70;
  float32x4_t v71;
  int32x4_t v72;
  __int32 v73;
  __int32 v74;
  __int32 v75;
  __int32 v76;
  __int32 v77;
  float32x4_t v78;
  float32x4_t v79;
  int32x4_t v80;
  __int32 v81;
  __int32 v82;
  __int32 v83;
  __int32 v84;
  __int32 v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int32x4_t v89;
  __int32 v90;
  __int32 v91;
  __int32 v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  int32x4_t v96;
  int32x2_t v97;
  int32x4_t v98;
  __int32 v99;
  int32x4_t v100;
  __int32 v101;
  float32x4_t v102;
  float32x4_t v103;
  int32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      v7 = a2[10];
      v8 = a2[2];
      v9 = 16 * a2[11].i32[0];
      v10 = 16 * a2[3].i32[0];
      v11 = 16 * v4;
      v12.i64[0] = 0x3F0000003F000000;
      v12.i64[1] = 0x3F0000003F000000;
      do
      {
        v13 = 0;
        do
        {
          v14 = *(float32x4_t *)(*(_QWORD *)&v7 + v13);
          v15 = (_OWORD *)*((_QWORD *)this + 51);
          v16 = *(float32x4_t *)v15;
          v17 = *((float32x4_t *)v15 + 1);
          v18 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15, 1), vmulq_n_f32(v14, COERCE_FLOAT(*v15)));
          v19 = *((float32x4_t *)v15 + 2);
          v20 = vmulq_f32(v18, v18);
          v21 = vaddq_f32(vaddq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)v15[3], 0), vmulq_lane_f32(v18, (float32x2_t)v15[3], 1)), vmulq_laneq_f32(v20, *((float32x4_t *)v15 + 3), 2)), vmulq_laneq_f32(vmulq_f32(v18, v20), *((float32x4_t *)v15 + 3), 3));
          v22 = *((float32x4_t *)v15 + 4);
          v23 = *((float32x4_t *)v15 + 5);
          v24 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1), v23);
          v25 = vminq_f32(vmaxq_f32(v21, v22), v24);
          v26 = vcvtq_f32_s32(vcvtq_s32_f32(v25));
          v27 = vsubq_f32(v26, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v26, v25)));
          v28 = vmulq_f32(v17, v27);
          v29 = (int8x16_t)vaddq_f32(v28, (float32x4_t)vrev64q_s32((int32x4_t)v28));
          v30 = *((int8x16_t *)v15 + 6);
          v31 = *((float32x4_t *)v15 + 7);
          v32 = vmulq_f32(v17, vsubq_f32(vminq_f32(vaddq_f32(v23, v27), v24), v27));
          v33 = vaddq_f32(v31, (float32x4_t)vbslq_s8(v30, v29, vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL)));
          v34 = a2[12];
          v35 = a2[13].i32[0];
          v36 = vaddq_f32(vsubq_f32(v33, v6), v12);
          v37 = vcvtq_s32_f32(v36);
          v36.i64[0] = vaddq_s32(v37, vcgtq_f32(vcvtq_f32_s32(v37), v36)).u64[0];
          v38 = v36.i32[1];
          v39 = (float32x4_t)vbslq_s8(v30, (int8x16_t)vaddq_f32(v32, v33), (int8x16_t)v33);
          v40 = v36.i32[0];
          v41 = vaddq_f32(vsubq_f32(v39, v6), v12);
          v42 = vcvtq_s32_f32(v41);
          v41.i64[0] = vaddq_s32(v42, vcgtq_f32(vcvtq_f32_s32(v42), v41)).u64[0];
          v43 = v40 + v38 * v35;
          v44 = v41.i32[1];
          v45 = v41.i32[0];
          v46 = (float32x4_t)vrev64q_s32((int32x4_t)v32);
          v47 = *(float32x4_t *)(*(_QWORD *)&v34 + 16 * v43);
          v48 = (float32x4_t)vbslq_s8(v30, (int8x16_t)vaddq_f32(v46, v39), (int8x16_t)v33);
          v49 = vaddq_f32(vsubq_f32(v48, v6), v12);
          v50 = vcvtq_s32_f32(v49);
          v51 = v45 + v44 * v35;
          v49.i64[0] = vaddq_s32(v50, vcgtq_f32(vcvtq_f32_s32(v50), v49)).u64[0];
          v52 = (int8x16_t)vsubq_f32(v48, v32);
          v53 = v49.i32[1];
          v54 = (float32x4_t)vbslq_s8(v30, v52, (int8x16_t)v33);
          v55 = vaddq_f32(vsubq_f32(v54, v6), v12);
          v56 = vcvtq_s32_f32(v55);
          v57 = v49.i32[0];
          v58 = vcgtq_f32(vcvtq_f32_s32(v56), v55);
          v59 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v32, (int8x16_t)v32, 4uLL), v54);
          v60 = (float32x4_t)vbslq_s8(v30, v52, v59);
          v61 = *(float32x4_t *)(*(_QWORD *)&v34 + 16 * v51);
          v62 = vaddq_f32(vsubq_f32(v60, v6), v12);
          v63 = (int32x4_t)vaddq_f32(v31, v27);
          v58.i64[0] = vaddq_s32(v56, v58).u64[0];
          v64 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v30, (int8x16_t)v63, (int8x16_t)v31), v6), v12);
          v65 = vcvtq_s32_f32(v64);
          v66 = vcvtq_s32_f32(v62);
          v67 = v57 + v53 * v35;
          v64.i64[0] = vaddq_s32(v65, vcgtq_f32(vcvtq_f32_s32(v65), v64)).u64[0];
          v68 = v64.i32[1];
          v69 = v64.i32[0];
          v70 = v58.i32[1];
          v71 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v30, (int8x16_t)vrev64q_s32(v63), (int8x16_t)v31), v6), v12);
          v72 = vcvtq_s32_f32(v71);
          v73 = v58.i32[0];
          v74 = a2[15].i32[0];
          v75 = v69 + v68 * v74;
          v58.i64[0] = vaddq_s32(v72, vcgtq_f32(vcvtq_f32_s32(v72), v71)).u64[0];
          v76 = v58.i32[1];
          v77 = v58.i32[0];
          v78 = *(float32x4_t *)(*(_QWORD *)&v34 + 16 * v67);
          v79 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v30, vextq_s8((int8x16_t)v63, (int8x16_t)v63, 8uLL), (int8x16_t)v31), v6), v12);
          v80 = vcvtq_s32_f32(v79);
          v71.i64[0] = vaddq_s32(v66, vcgtq_f32(vcvtq_f32_s32(v66), v62)).u64[0];
          v79.i64[0] = vaddq_s32(v80, vcgtq_f32(vcvtq_f32_s32(v80), v79)).u64[0];
          v81 = v73 + v70 * v35;
          v82 = v77 + v76 * v74;
          v83 = v79.i32[0] + v79.i32[1] * v74;
          v84 = v71.i32[1];
          v85 = v71.i32[0];
          v86 = (float32x4_t)vbslq_s8(v30, (int8x16_t)vsubq_f32(v60, v46), v59);
          v87 = vaddq_f32(vsubq_f32(v86, v6), v12);
          v88 = *(float32x4_t *)(*(_QWORD *)&v34 + 16 * v81);
          v89 = vcvtq_s32_f32(v87);
          v87.i64[0] = vaddq_s32(v89, vcgtq_f32(vcvtq_f32_s32(v89), v87)).u64[0];
          v90 = v87.i32[1];
          v91 = v85 + v84 * v35;
          v92 = v87.i32[0];
          v93 = (float32x4_t)vbslq_s8(v30, (int8x16_t)vaddq_f32(v32, v86), v59);
          v94 = *(float32x4_t *)(*(_QWORD *)&v34 + 16 * v91);
          v95 = vaddq_f32(vsubq_f32(v93, v6), v12);
          v96 = vcvtq_s32_f32(v95);
          v95.i64[0] = vaddq_s32(v96, vcgtq_f32(vcvtq_f32_s32(v96), v95)).u64[0];
          v97 = a2[14];
          v98 = *(int32x4_t *)(*(_QWORD *)&v97 + 16 * v75);
          v99 = v95.i32[1];
          v100 = *(int32x4_t *)(*(_QWORD *)&v97 + 16 * v82);
          v101 = v95.i32[0];
          v102 = *(float32x4_t *)(*(_QWORD *)&v34 + 16 * (v92 + v90 * v35));
          v103 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v30, (int8x16_t)vaddq_f32(v46, v93), v59), v6), v12);
          v104 = vcvtq_s32_f32(v103);
          v103.i64[0] = vaddq_s32(v104, vcgtq_f32(vcvtq_f32_s32(v104), v103)).u64[0];
          v46.i64[0] = vbslq_s8(v30, (int8x16_t)vrev64q_s32(v98), (int8x16_t)v100).u64[0];
          *(int8x8_t *)v17.f32 = vorr_s8(vand_s8((int8x8_t)*(_OWORD *)&vrev64q_s32(v100), (int8x8_t)*(_OWORD *)&vmvnq_s8(v30)), vand_s8(*(int8x8_t *)v30.i8, *(int8x8_t *)v98.i8));
          v17.i64[1] = *(_QWORD *)(*(_QWORD *)&v97 + 16 * v83);
          v105 = (float32x4_t)vextq_s8((int8x16_t)v6, *(int8x16_t *)(*(_QWORD *)&v97 + 16 * v83), 0xCuLL);
          v105.i64[0] = v46.i64[0];
          v106 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v22, vsubq_f32(v18, v23)), (int8x16_t)vmulq_f32(v105, vsubq_f32(vmaxq_f32(v18, v22), v17)), (int8x16_t)v22);
          v107 = vaddq_f32(v47, vmulq_n_f32(vsubq_f32(v61, v47), v106.f32[0]));
          v108 = vaddq_f32(v102, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(_QWORD *)&v34 + 16 * (v101 + v99 * v35)), v102), v106.f32[0]));
          v109 = vaddq_f32(v107, vmulq_lane_f32(vsubq_f32(vaddq_f32(v88, vmulq_n_f32(vsubq_f32(v78, v88), v106.f32[0])), v107), *(float32x2_t *)v106.f32, 1));
          *(int8x16_t *)(*(_QWORD *)&v8 + v13) = vbslq_s8((int8x16_t)vcgtq_f32(v22, v19), (int8x16_t)v14, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), vmulq_laneq_f32(vaddq_f32(v109, vmulq_laneq_f32(vsubq_f32(vaddq_f32(v108, vmulq_lane_f32(vsubq_f32(vaddq_f32(v94, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(_QWORD *)&v34 + 16 * (v103.i32[0] + v103.i32[1] * v35)), v94),
                                                                                  v106.f32[0])),
                                                                              v108),
                                                                            *(float32x2_t *)v106.f32,
                                                                            1)),
                                                                        v109),
                                                                      v106,
                                                                      2)),
                                                                  v16,
                                                                  2)));
          v13 += 16;
        }
        while (v11 != v13);
        ++v5;
        *(_QWORD *)&v7 += v9;
        *(_QWORD *)&v8 += v10;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcApply3DLUTTrilinear_basekernel::GetDOD(HgcApply3DLUTTrilinear_basekernel *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 2 || a3 == 1)
    return 0x8000000080000000;
  if (a3)
    return 0;
  return *(_QWORD *)&a4.var0;
}

uint64_t HgcApply3DLUTTrilinear_basekernel::GetROI(HGNode *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  HGNode *Input;

  if (a3 == 2 || a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, a3);
    return HGRenderer::GetDOD(a2, Input);
  }
  else
  {
    if (a3)
      *(_QWORD *)&a4.var0 = 0;
    return *(_QWORD *)&a4.var0;
  }
}

void HgcApply3DLUTTrilinear_basekernel::HgcApply3DLUTTrilinear_basekernel(HgcApply3DLUTTrilinear_basekernel *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6544038;
  v3 = (_OWORD *)operator new();
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  v3[4] = 0u;
  v3[5] = xmmword_1B3051560;
  v3[6] = xmmword_1B3050E20;
  v3[7] = xmmword_1B3051510;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcApply3DLUTTrilinear_basekernel *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  (*(void (**)(HgcApply3DLUTTrilinear_basekernel *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 2, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BD4464(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcApply3DLUTTrilinear_basekernel::~HgcApply3DLUTTrilinear_basekernel(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6544038;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6544038;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6544038;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcApply3DLUTTrilinear_basekernel::SetParameter(HgcApply3DLUTTrilinear_basekernel *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcApply3DLUTTrilinear_basekernel::GetParameter(HgcApply3DLUTTrilinear_basekernel *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcApply3DLUTTrilinearUniform_basekernel::GetProgram(HgcApply3DLUTTrilinearUniform_basekernel *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000ba7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = half3(hg_Params[1].yyy) - c0.xxx;\n"
             "    r1.xyz = r1.xyz*r2.xyz;\n"
             "    r1.xyz = fmax(r1.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
             "    r3.xyz = fract(r1.xyz);\n"
             "    r1.xyz = floor(r1.xyz);\n"
             "    r4.xyz = r1.xyz + c0.xxx;\n"
             "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
             "    r4.xyz = r4.xyz - r1.xyz;\n"
             "    r4.xyz = r4.xyz*half3(hg_Params[1].xyz);\n"
             "    r2.x = dot(r1.xy, half2(hg_Params[1].xy));\n"
             "    r2.y = r1.z;\n"
             "    r2.xy = r2.xy + c0.zz;\n"
             "    r1.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r1.xy = r1.xy*half2(hg_Params[3].zw);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r1.xy));\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r5.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r5.xy = r5.xy*half2(hg_Params[3].zw);\n"
             "    r5 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r5.xy));\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r6.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r6.xy = r6.xy*half2(hg_Params[3].zw);\n"
             "    r6 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r6.xy));\n"
             "    r2.x = r2.x - r4.x;\n"
             "    r7.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r7.xy = r7.xy*half2(hg_Params[3].zw);\n"
             "    r7 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r7.xy));\n"
             "    r2.y = r2.y + r4.z;\n"
             "    r8.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r8.xy = r8.xy*half2(hg_Params[3].zw);\n"
             "    r8 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r8.xy));\n"
             "    r2.x = r2.x - r4.y;\n"
             "    r9.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r9.xy = r9.xy*half2(hg_Params[3].zw);\n"
             "    r9 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r9.xy));\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r10.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r10.xy = r10.xy*half2(hg_Params[3].zw);\n"
             "    r10 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r10.xy));\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r2.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r2.xy = r2.xy*half2(hg_Params[3].zw);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r2.xy));\n"
             "    r1 = mix(r1, r5, r3.xxxx);\n"
             "    r7 = mix(r7, r6, r3.xxxx);\n"
             "    r9 = mix(r9, r10, r3.xxxx);\n"
             "    r8 = mix(r8, r2, r3.xxxx);\n"
             "    r1 = mix(r1, r7, r3.yyyy);\n"
             "    r9 = mix(r9, r8, r3.yyyy);\n"
             "    r3 = mix(r1, r9, r3.zzzz);\n"
             "    r3 = r3*half4(hg_Params[0].zzzz) + half4(hg_Params[0].wwww);\n"
             "    output.color0 = select(float4(r3), float4(r0), hg_Params[2] < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=4a246928:7d77d0f6:04f061a8:55d417f5\n"
             "//SIG=00400000:00000001:00000001:00000003:0001:0004:000b:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000a73\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = hg_Params[1].yyy - c0.xxx;\n"
             "    r1.xyz = r1.xyz*r2.xyz;\n"
             "    r1.xyz = fmax(r1.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
             "    r3.xyz = fract(r1.xyz);\n"
             "    r1.xyz = floor(r1.xyz);\n"
             "    r4.xyz = r1.xyz + c0.xxx;\n"
             "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
             "    r4.xyz = r4.xyz - r1.xyz;\n"
             "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
             "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
             "    r2.y = r1.z;\n"
             "    r2.xy = r2.xy + c0.zz;\n"
             "    r1.xy = r2.xy + hg_Params[3].xy;\n"
             "    r1.xy = r1.xy*hg_Params[3].zw;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r5.xy = r2.xy + hg_Params[3].xy;\n"
             "    r5.xy = r5.xy*hg_Params[3].zw;\n"
             "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r6.xy = r2.xy + hg_Params[3].xy;\n"
             "    r6.xy = r6.xy*hg_Params[3].zw;\n"
             "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
             "    r2.x = r2.x - r4.x;\n"
             "    r7.xy = r2.xy + hg_Params[3].xy;\n"
             "    r7.xy = r7.xy*hg_Params[3].zw;\n"
             "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
             "    r2.y = r2.y + r4.z;\n"
             "    r8.xy = r2.xy + hg_Params[3].xy;\n"
             "    r8.xy = r8.xy*hg_Params[3].zw;\n"
             "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
             "    r2.x = r2.x - r4.y;\n"
             "    r9.xy = r2.xy + hg_Params[3].xy;\n"
             "    r9.xy = r9.xy*hg_Params[3].zw;\n"
             "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r10.xy = r2.xy + hg_Params[3].xy;\n"
             "    r10.xy = r10.xy*hg_Params[3].zw;\n"
             "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r2.xy = r2.xy + hg_Params[3].xy;\n"
             "    r2.xy = r2.xy*hg_Params[3].zw;\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
             "    r1 = mix(r1, r5, r3.xxxx);\n"
             "    r7 = mix(r7, r6, r3.xxxx);\n"
             "    r9 = mix(r9, r10, r3.xxxx);\n"
             "    r8 = mix(r8, r2, r3.xxxx);\n"
             "    r1 = mix(r1, r7, r3.yyyy);\n"
             "    r9 = mix(r9, r8, r3.yyyy);\n"
             "    r3 = mix(r1, r9, r3.zzzz);\n"
             "    r3 = r3*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
             "    output.color0 = select(r3, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=f2a8ef5a:d246eef6:2592a446:679ba2ae\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:000b:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000b19\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = hg_ProgramLocal1.yyy - c0.xxx;\n"
           "    r1.xyz = r1.xyz*r2.xyz;\n"
           "    r1.xyz = max(r1.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, r2.xyz);\n"
           "    r3.xyz = fract(r1.xyz);\n"
           "    r1.xyz = floor(r1.xyz);\n"
           "    r4.xyz = r1.xyz + c0.xxx;\n"
           "    r4.xyz = min(r4.xyz, r2.xyz);\n"
           "    r4.xyz = r4.xyz - r1.xyz;\n"
           "    r4.xyz = r4.xyz*hg_ProgramLocal1.xyz;\n"
           "    r2.x = dot(r1.xy, hg_ProgramLocal1.xy);\n"
           "    r2.y = r1.z;\n"
           "    r2.xy = r2.xy + c0.zz;\n"
           "    r1.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r1.xy = r1.xy*hg_ProgramLocal3.zw;\n"
           "    r1 = texture2D(hg_Texture1, r1.xy);\n"
           "    r2.x = r2.x + r4.x;\n"
           "    r5.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r5.xy = r5.xy*hg_ProgramLocal3.zw;\n"
           "    r5 = texture2D(hg_Texture1, r5.xy);\n"
           "    r2.x = r2.x + r4.y;\n"
           "    r6.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r6.xy = r6.xy*hg_ProgramLocal3.zw;\n"
           "    r6 = texture2D(hg_Texture1, r6.xy);\n"
           "    r2.x = r2.x - r4.x;\n"
           "    r7.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r7.xy = r7.xy*hg_ProgramLocal3.zw;\n"
           "    r7 = texture2D(hg_Texture1, r7.xy);\n"
           "    r2.y = r2.y + r4.z;\n"
           "    r8.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r8.xy = r8.xy*hg_ProgramLocal3.zw;\n"
           "    r8 = texture2D(hg_Texture1, r8.xy);\n"
           "    r2.x = r2.x - r4.y;\n"
           "    r9.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal3.zw;\n"
           "    r9 = texture2D(hg_Texture1, r9.xy);\n"
           "    r2.x = r2.x + r4.x;\n"
           "    r10.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r10.xy = r10.xy*hg_ProgramLocal3.zw;\n"
           "    r10 = texture2D(hg_Texture1, r10.xy);\n"
           "    r2.x = r2.x + r4.y;\n"
           "    r2.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal3.zw;\n"
           "    r2 = texture2D(hg_Texture1, r2.xy);\n"
           "    r1 = mix(r1, r5, r3.xxxx);\n"
           "    r7 = mix(r7, r6, r3.xxxx);\n"
           "    r9 = mix(r9, r10, r3.xxxx);\n"
           "    r8 = mix(r8, r2, r3.xxxx);\n"
           "    r1 = mix(r1, r7, r3.yyyy);\n"
           "    r9 = mix(r9, r8, r3.yyyy);\n"
           "    r3 = mix(r1, r9, r3.zzzz);\n"
           "    r3 = r3*hg_ProgramLocal0.zzzz + hg_ProgramLocal0.wwww;\n"
           "    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r3.x, hg_ProgramLocal2.y < 0.00000 ? r0.y : r3."
           "y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r3.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r3.w);\n"
           "}\n"
           "//MD5=66dd5ce0:835ac03a:cf594cc7:10f7ddbe\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0004:000b:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
  }
}

void HgcApply3DLUTTrilinearUniform_basekernel::InitProgramDescriptor(HgcApply3DLUTTrilinearUniform_basekernel *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcApply3DLUTTrilinearUniform_basekernel_hgc_visible", "//Metal1.0     \n//LEN=0000000943\n[[ visible ]] FragmentOut HgcApply3DLUTTrilinearUniform_basekernel_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = hg_Params[1].yyy - c0.xxx;\n"
    "    r1.xyz = r1.xyz*r2.xyz;\n"
    "    r1.xyz = fmax(r1.xyz, c0.yyy);\n"
    "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
    "    r3.xyz = fract(r1.xyz);\n"
    "    r1.xyz = floor(r1.xyz);\n"
    "    r4.xyz = r1.xyz + c0.xxx;\n"
    "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
    "    r4.xyz = r4.xyz - r1.xyz;\n"
    "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
    "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
    "    r2.y = r1.z;\n"
    "    r2.xy = r2.xy + c0.zz;\n"
    "    r1.xy = r2.xy + hg_Params[3].xy;\n"
    "    r1.xy = r1.xy*hg_Params[3].zw;\n"
    "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r5.xy = r2.xy + hg_Params[3].xy;\n"
    "    r5.xy = r5.xy*hg_Params[3].zw;\n"
    "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r6.xy = r2.xy + hg_Params[3].xy;\n"
    "    r6.xy = r6.xy*hg_Params[3].zw;\n"
    "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
    "    r2.x = r2.x - r4.x;\n"
    "    r7.xy = r2.xy + hg_Params[3].xy;\n"
    "    r7.xy = r7.xy*hg_Params[3].zw;\n"
    "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
    "    r2.y = r2.y + r4.z;\n"
    "    r8.xy = r2.xy + hg_Params[3].xy;\n"
    "    r8.xy = r8.xy*hg_Params[3].zw;\n"
    "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
    "    r2.x = r2.x - r4.y;\n"
    "    r9.xy = r2.xy + hg_Params[3].xy;\n"
    "    r9.xy = r9.xy*hg_Params[3].zw;\n"
    "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r10.xy = r2.xy + hg_Params[3].xy;\n"
    "    r10.xy = r10.xy*hg_Params[3].zw;\n"
    "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r2.xy = r2.xy + hg_Params[3].xy;\n"
    "    r2.xy = r2.xy*hg_Params[3].zw;\n"
    "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
    "    r1 = mix(r1, r5, r3.xxxx);\n"
    "    r7 = mix(r7, r6, r3.xxxx);\n"
    "    r9 = mix(r9, r10, r3.xxxx);\n"
    "    r8 = mix(r8, r2, r3.xxxx);\n"
    "    r1 = mix(r1, r7, r3.yyyy);\n"
    "    r9 = mix(r9, r8, r3.yyyy);\n"
    "    r3 = mix(r1, r9, r3.zzzz);\n"
    "    r3 = r3*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
    "    output.color0 = select(r3, r0, hg_Params[2] < 0.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BD49F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BD4A28(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BD4A20);
}

double HgcApply3DLUTTrilinearUniform_basekernel::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x30uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3553C20;
  strcpy(v3, "HgcApply3DLUTTrilinearUniform_basekernel [hgc1]");
  return *(double *)"asekernel [hgc1]";
}

uint64_t HgcApply3DLUTTrilinearUniform_basekernel::BindTexture(HgcApply3DLUTTrilinearUniform_basekernel *this, HGHandler *a2, int a3)
{
  int v4;
  uint64_t result;
  __n128 v6;
  __n128 v7;
  __n128 v8;
  __n128 v9;

  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    {
      v8.n128_u32[0] = 1.0;
      v9.n128_u32[0] = 1.0;
    }
    else
    {
      v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v9.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v6.n128_f32[0] = (float)*((int *)a2 + 60);
    v7.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 3, v6, v7, v8, v9);
    return 0;
  }
  else if (a3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    v4 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
    result = 0;
    if (!v4)
    {
      (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcApply3DLUTTrilinearUniform_basekernel::Bind(HgcApply3DLUTTrilinearUniform_basekernel *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HgcApply3DLUTTrilinearUniform_basekernel *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcApply3DLUTTrilinearUniform_basekernel::RenderTile(HgcApply3DLUTTrilinearUniform_basekernel *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  int v5;
  float32x4_t v6;
  int32x2_t v7;
  int32x2_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  _OWORD *v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int32x2_t v29;
  __int32 v30;
  float32x4_t v31;
  int32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  int32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int32x4_t v44;
  __int32 v45;
  int8x16_t v46;
  float32x4_t v47;
  float32x4_t v48;
  int32x4_t v49;
  __int32 v50;
  __int32 v51;
  float32x4_t v52;
  float32x4_t v53;
  int32x4_t v54;
  float32x4_t v55;
  __int32 v56;
  __int32 v57;
  __int32 v58;
  float32x4_t v59;
  float32x4_t v60;
  int32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      v7 = a2[10];
      v8 = a2[2];
      v9 = 16 * a2[11].i32[0];
      v10 = 16 * a2[3].i32[0];
      v11 = 16 * v4;
      v12.i64[0] = 0x3F0000003F000000;
      v12.i64[1] = 0x3F0000003F000000;
      do
      {
        v13 = 0;
        do
        {
          v14 = *(float32x4_t *)(*(_QWORD *)&v7 + v13);
          v15 = (_OWORD *)*((_QWORD *)this + 51);
          v16 = *(float32x4_t *)v15;
          v17 = *((float32x4_t *)v15 + 1);
          v19 = *((float32x4_t *)v15 + 2);
          v18 = *((float32x4_t *)v15 + 3);
          v20 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1), v18);
          v21 = *((float32x4_t *)v15 + 4);
          v22 = *((int8x16_t *)v15 + 5);
          v23 = vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15, 1), vmulq_n_f32(v14, COERCE_FLOAT(*v15))), v20), v21), v20);
          v24 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
          v25 = vsubq_f32(v24, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v24, v23)));
          v26 = vmulq_f32(v17, vsubq_f32(vminq_f32(vaddq_f32(v18, v25), v20), v25));
          v27 = vmulq_f32(v17, v25);
          v28 = vaddq_f32(*((float32x4_t *)v15 + 6), (float32x4_t)vbslq_s8(v22, (int8x16_t)vaddq_f32(v27, (float32x4_t)vrev64q_s32((int32x4_t)v27)), vextq_s8((int8x16_t)v25, (int8x16_t)v25, 4uLL)));
          v29 = a2[12];
          v30 = a2[13].i32[0];
          v31 = vaddq_f32(vsubq_f32(v28, v6), v12);
          v32 = vcvtq_s32_f32(v31);
          v31.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
          v33 = *(float32x4_t *)(*(_QWORD *)&v29 + 16 * (v31.i32[0] + v31.i32[1] * v30));
          v34 = (float32x4_t)vbslq_s8(v22, (int8x16_t)vaddq_f32(v26, v28), (int8x16_t)v28);
          v35 = vaddq_f32(vsubq_f32(v34, v6), v12);
          v36 = vcvtq_s32_f32(v35);
          v35.i64[0] = vaddq_s32(v36, vcgtq_f32(vcvtq_f32_s32(v36), v35)).u64[0];
          v37 = (float32x4_t)vrev64q_s32((int32x4_t)v26);
          v38 = (float32x4_t)vbslq_s8(v22, (int8x16_t)vaddq_f32(v37, v34), (int8x16_t)v28);
          v39 = vaddq_f32(vsubq_f32(v38, v6), v12);
          v40 = vcvtq_s32_f32(v39);
          v39.i64[0] = vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)).u64[0];
          v41 = (int8x16_t)vsubq_f32(v38, v26);
          v42 = (float32x4_t)vbslq_s8(v22, v41, (int8x16_t)v28);
          v43 = vaddq_f32(vsubq_f32(v42, v6), v12);
          v44 = vcvtq_s32_f32(v43);
          v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
          v45 = v43.i32[0] + v43.i32[1] * v30;
          v46 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 4uLL), v42);
          v47 = (float32x4_t)vbslq_s8(v22, v41, v46);
          v48 = vaddq_f32(vsubq_f32(v47, v6), v12);
          v49 = vcvtq_s32_f32(v48);
          v48.i64[0] = vaddq_s32(v49, vcgtq_f32(vcvtq_f32_s32(v49), v48)).u64[0];
          v50 = v48.i32[1];
          v51 = v48.i32[0];
          v52 = (float32x4_t)vbslq_s8(v22, (int8x16_t)vsubq_f32(v47, v37), v46);
          v53 = vaddq_f32(vsubq_f32(v52, v6), v12);
          v54 = vcvtq_s32_f32(v53);
          v55 = *(float32x4_t *)(*(_QWORD *)&v29 + 16 * v45);
          v56 = v51 + v50 * v30;
          v53.i64[0] = vaddq_s32(v54, vcgtq_f32(vcvtq_f32_s32(v54), v53)).u64[0];
          v57 = v53.i32[1];
          v58 = v53.i32[0];
          v59 = (float32x4_t)vbslq_s8(v22, (int8x16_t)vaddq_f32(v26, v52), v46);
          v60 = vaddq_f32(vsubq_f32(v59, v6), v12);
          v61 = vcvtq_s32_f32(v60);
          v60.i64[0] = vaddq_s32(v61, vcgtq_f32(vcvtq_f32_s32(v61), v60)).u64[0];
          v62 = *(float32x4_t *)(*(_QWORD *)&v29 + 16 * (v58 + v57 * v30));
          v63 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v22, (int8x16_t)vaddq_f32(v37, v59), v46), v6), v12);
          v64 = vcvtq_s32_f32(v63);
          v63.i64[0] = vaddq_s32(v64, vcgtq_f32(vcvtq_f32_s32(v64), v63)).u64[0];
          v65 = vsubq_f32(v23, v25);
          v66 = vaddq_f32(v33, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(_QWORD *)&v29 + 16 * (v35.i32[0] + v35.i32[1] * v30)), v33), v65.f32[0]));
          v67 = vaddq_f32(v62, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(_QWORD *)&v29 + 16 * (v60.i32[0] + v60.i32[1] * v30)), v62), v65.f32[0]));
          v68 = vaddq_f32(v66, vmulq_lane_f32(vsubq_f32(vaddq_f32(v55, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(_QWORD *)&v29 + 16 * (v39.i32[0] + v39.i32[1] * v30)), v55), v65.f32[0])), v66), *(float32x2_t *)v65.f32, 1));
          *(int8x16_t *)(*(_QWORD *)&v8 + v13) = vbslq_s8((int8x16_t)vcgtq_f32(v21, v19), (int8x16_t)v14, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), vmulq_laneq_f32(vaddq_f32(v68, vmulq_laneq_f32(vsubq_f32(vaddq_f32(v67, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)(*(_QWORD *)&v29+ 16 * v56), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(_QWORD *)&v29 + 16 * (v63.i32[0] + v63.i32[1] * v30)),
                                                                                    *(float32x4_t *)(*(_QWORD *)&v29 + 16 * v56)),
                                                                                  v65.f32[0])),
                                                                              v67),
                                                                            *(float32x2_t *)v65.f32,
                                                                            1)),
                                                                        v68),
                                                                      v65,
                                                                      2)),
                                                                  v16,
                                                                  2)));
          v13 += 16;
        }
        while (v11 != v13);
        ++v5;
        *(_QWORD *)&v7 += v9;
        *(_QWORD *)&v8 += v10;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcApply3DLUTTrilinearUniform_basekernel::GetDOD(HgcApply3DLUTTrilinearUniform_basekernel *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 1)
    return 0x8000000080000000;
  if (a3)
    return 0;
  return *(_QWORD *)&a4.var0;
}

uint64_t HgcApply3DLUTTrilinearUniform_basekernel::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, 1u);
    return HGRenderer::GetDOD(a2, Input);
  }
  else if (a3)
  {
    return 0;
  }
  else
  {
    return *(_QWORD *)&a4.var0;
  }
}

void HgcApply3DLUTTrilinearUniform_basekernel::HgcApply3DLUTTrilinearUniform_basekernel(HgcApply3DLUTTrilinearUniform_basekernel *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65442A0;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = xmmword_1B3051560;
  *(_QWORD *)(v3 + 64) = 0;
  *(_QWORD *)(v3 + 72) = 0;
  *(_OWORD *)(v3 + 80) = xmmword_1B3050E20;
  *(_OWORD *)(v3 + 96) = xmmword_1B3052100;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcApply3DLUTTrilinearUniform_basekernel *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BD50DC(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcApply3DLUTTrilinearUniform_basekernel::~HgcApply3DLUTTrilinearUniform_basekernel(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65442A0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E65442A0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65442A0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcApply3DLUTTrilinearUniform_basekernel::SetParameter(HgcApply3DLUTTrilinearUniform_basekernel *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcApply3DLUTTrilinearUniform_basekernel::GetParameter(HgcApply3DLUTTrilinearUniform_basekernel *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcApply3DLUTTrilinearFast_basekernel::GetProgram(HgcApply3DLUTTrilinearFast_basekernel *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000c76\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = r1.xyz*r1.xyz;\n"
             "    r3.xyz = r2.xyz*r1.xyz;\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[3].yyy) + half3(hg_Params[3].xxx);\n"
             "    r1.xyz = r2.xyz*half3(hg_Params[3].zzz) + r1.xyz;\n"
             "    r1.xyz = r3.xyz*half3(hg_Params[3].www) + r1.xyz;\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r2.xyz = half3(hg_Params[1].yyy) - c0.yyy;\n"
             "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
             "    r3.xyz = fract(r1.xyz);\n"
             "    r1.xyz = floor(r1.xyz);\n"
             "    r4.xyz = r1.xyz + c0.yyy;\n"
             "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
             "    r4.xyz = r4.xyz - r1.xyz;\n"
             "    r4.xyz = r4.xyz*half3(hg_Params[1].xyz);\n"
             "    r2.x = dot(r1.xy, half2(hg_Params[1].xy));\n"
             "    r2.y = r1.z;\n"
             "    r2.xy = r2.xy + c0.zz;\n"
             "    r1.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r1.xy = r1.xy*half2(hg_Params[4].zw);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r1.xy));\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r5.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r5.xy = r5.xy*half2(hg_Params[4].zw);\n"
             "    r5 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r5.xy));\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r6.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r6.xy = r6.xy*half2(hg_Params[4].zw);\n"
             "    r6 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r6.xy));\n"
             "    r2.x = r2.x - r4.x;\n"
             "    r7.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r7.xy = r7.xy*half2(hg_Params[4].zw);\n"
             "    r7 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r7.xy));\n"
             "    r2.y = r2.y + r4.z;\n"
             "    r8.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r8.xy = r8.xy*half2(hg_Params[4].zw);\n"
             "    r8 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r8.xy));\n"
             "    r2.x = r2.x - r4.y;\n"
             "    r9.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r9.xy = r9.xy*half2(hg_Params[4].zw);\n"
             "    r9 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r9.xy));\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r10.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r10.xy = r10.xy*half2(hg_Params[4].zw);\n"
             "    r10 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r10.xy));\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r2.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r2.xy = r2.xy*half2(hg_Params[4].zw);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r2.xy));\n"
             "    r1 = mix(r1, r5, r3.xxxx);\n"
             "    r7 = mix(r7, r6, r3.xxxx);\n"
             "    r9 = mix(r9, r10, r3.xxxx);\n"
             "    r8 = mix(r8, r2, r3.xxxx);\n"
             "    r1 = mix(r1, r7, r3.yyyy);\n"
             "    r9 = mix(r9, r8, r3.yyyy);\n"
             "    r3 = mix(r1, r9, r3.zzzz);\n"
             "    r3 = r3*half4(hg_Params[0].zzzz) + half4(hg_Params[0].wwww);\n"
             "    output.color0 = select(float4(r3), float4(r0), hg_Params[2] < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e070033f:1d621a63:785fa6c2:a792b420\n"
             "//SIG=00400000:00000001:00000001:00000003:0001:0005:000b:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000b26\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = r1.xyz*r1.xyz;\n"
             "    r3.xyz = r2.xyz*r1.xyz;\n"
             "    r1.xyz = r1.xyz*hg_Params[3].yyy + hg_Params[3].xxx;\n"
             "    r1.xyz = r2.xyz*hg_Params[3].zzz + r1.xyz;\n"
             "    r1.xyz = r3.xyz*hg_Params[3].www + r1.xyz;\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r2.xyz = hg_Params[1].yyy - c0.yyy;\n"
             "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
             "    r3.xyz = fract(r1.xyz);\n"
             "    r1.xyz = floor(r1.xyz);\n"
             "    r4.xyz = r1.xyz + c0.yyy;\n"
             "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
             "    r4.xyz = r4.xyz - r1.xyz;\n"
             "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
             "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
             "    r2.y = r1.z;\n"
             "    r2.xy = r2.xy + c0.zz;\n"
             "    r1.xy = r2.xy + hg_Params[4].xy;\n"
             "    r1.xy = r1.xy*hg_Params[4].zw;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r5.xy = r2.xy + hg_Params[4].xy;\n"
             "    r5.xy = r5.xy*hg_Params[4].zw;\n"
             "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r6.xy = r2.xy + hg_Params[4].xy;\n"
             "    r6.xy = r6.xy*hg_Params[4].zw;\n"
             "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
             "    r2.x = r2.x - r4.x;\n"
             "    r7.xy = r2.xy + hg_Params[4].xy;\n"
             "    r7.xy = r7.xy*hg_Params[4].zw;\n"
             "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
             "    r2.y = r2.y + r4.z;\n"
             "    r8.xy = r2.xy + hg_Params[4].xy;\n"
             "    r8.xy = r8.xy*hg_Params[4].zw;\n"
             "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
             "    r2.x = r2.x - r4.y;\n"
             "    r9.xy = r2.xy + hg_Params[4].xy;\n"
             "    r9.xy = r9.xy*hg_Params[4].zw;\n"
             "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r10.xy = r2.xy + hg_Params[4].xy;\n"
             "    r10.xy = r10.xy*hg_Params[4].zw;\n"
             "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r2.xy = r2.xy + hg_Params[4].xy;\n"
             "    r2.xy = r2.xy*hg_Params[4].zw;\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
             "    r1 = mix(r1, r5, r3.xxxx);\n"
             "    r7 = mix(r7, r6, r3.xxxx);\n"
             "    r9 = mix(r9, r10, r3.xxxx);\n"
             "    r8 = mix(r8, r2, r3.xxxx);\n"
             "    r1 = mix(r1, r7, r3.yyyy);\n"
             "    r9 = mix(r9, r8, r3.yyyy);\n"
             "    r3 = mix(r1, r9, r3.zzzz);\n"
             "    r3 = r3*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
             "    output.color0 = select(r3, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c61a1f18:8e6819ed:8e5b4072:dd86156d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0005:000b:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000c03\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "uniform mediump vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = r1.xyz*r1.xyz;\n"
           "    r3.xyz = r2.xyz*r1.xyz;\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal3.yyy + hg_ProgramLocal3.xxx;\n"
           "    r1.xyz = r2.xyz*hg_ProgramLocal3.zzz + r1.xyz;\n"
           "    r1.xyz = r3.xyz*hg_ProgramLocal3.www + r1.xyz;\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r2.xyz = hg_ProgramLocal1.yyy - c0.yyy;\n"
           "    r1.xyz = min(r1.xyz, r2.xyz);\n"
           "    r3.xyz = fract(r1.xyz);\n"
           "    r1.xyz = floor(r1.xyz);\n"
           "    r4.xyz = r1.xyz + c0.yyy;\n"
           "    r4.xyz = min(r4.xyz, r2.xyz);\n"
           "    r4.xyz = r4.xyz - r1.xyz;\n"
           "    r4.xyz = r4.xyz*hg_ProgramLocal1.xyz;\n"
           "    r2.x = dot(r1.xy, hg_ProgramLocal1.xy);\n"
           "    r2.y = r1.z;\n"
           "    r2.xy = r2.xy + c0.zz;\n"
           "    r1.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r1.xy = r1.xy*hg_ProgramLocal4.zw;\n"
           "    r1 = texture2D(hg_Texture1, r1.xy);\n"
           "    r2.x = r2.x + r4.x;\n"
           "    r5.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r5.xy = r5.xy*hg_ProgramLocal4.zw;\n"
           "    r5 = texture2D(hg_Texture1, r5.xy);\n"
           "    r2.x = r2.x + r4.y;\n"
           "    r6.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r6.xy = r6.xy*hg_ProgramLocal4.zw;\n"
           "    r6 = texture2D(hg_Texture1, r6.xy);\n"
           "    r2.x = r2.x - r4.x;\n"
           "    r7.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r7.xy = r7.xy*hg_ProgramLocal4.zw;\n"
           "    r7 = texture2D(hg_Texture1, r7.xy);\n"
           "    r2.y = r2.y + r4.z;\n"
           "    r8.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r8.xy = r8.xy*hg_ProgramLocal4.zw;\n"
           "    r8 = texture2D(hg_Texture1, r8.xy);\n"
           "    r2.x = r2.x - r4.y;\n"
           "    r9.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal4.zw;\n"
           "    r9 = texture2D(hg_Texture1, r9.xy);\n"
           "    r2.x = r2.x + r4.x;\n"
           "    r10.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r10.xy = r10.xy*hg_ProgramLocal4.zw;\n"
           "    r10 = texture2D(hg_Texture1, r10.xy);\n"
           "    r2.x = r2.x + r4.y;\n"
           "    r2.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal4.zw;\n"
           "    r2 = texture2D(hg_Texture1, r2.xy);\n"
           "    r1 = mix(r1, r5, r3.xxxx);\n"
           "    r7 = mix(r7, r6, r3.xxxx);\n"
           "    r9 = mix(r9, r10, r3.xxxx);\n"
           "    r8 = mix(r8, r2, r3.xxxx);\n"
           "    r1 = mix(r1, r7, r3.yyyy);\n"
           "    r9 = mix(r9, r8, r3.yyyy);\n"
           "    r3 = mix(r1, r9, r3.zzzz);\n"
           "    r3 = r3*hg_ProgramLocal0.zzzz + hg_ProgramLocal0.wwww;\n"
           "    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r3.x, hg_ProgramLocal2.y < 0.00000 ? r0.y : r3."
           "y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r3.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r3.w);\n"
           "}\n"
           "//MD5=73a1f61c:d101d00f:5112a8c9:baad1c77\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0005:000b:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
  }
}

void HgcApply3DLUTTrilinearFast_basekernel::InitProgramDescriptor(HgcApply3DLUTTrilinearFast_basekernel *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcApply3DLUTTrilinearFast_basekernel_hgc_visible", "//Metal1.0     \n//LEN=00000009f3\n[[ visible ]] FragmentOut HgcApply3DLUTTrilinearFast_basekernel_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = r1.xyz*r1.xyz;\n"
    "    r3.xyz = r2.xyz*r1.xyz;\n"
    "    r1.xyz = r1.xyz*hg_Params[3].yyy + hg_Params[3].xxx;\n"
    "    r1.xyz = r2.xyz*hg_Params[3].zzz + r1.xyz;\n"
    "    r1.xyz = r3.xyz*hg_Params[3].www + r1.xyz;\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r2.xyz = hg_Params[1].yyy - c0.yyy;\n"
    "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
    "    r3.xyz = fract(r1.xyz);\n"
    "    r1.xyz = floor(r1.xyz);\n"
    "    r4.xyz = r1.xyz + c0.yyy;\n"
    "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
    "    r4.xyz = r4.xyz - r1.xyz;\n"
    "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
    "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
    "    r2.y = r1.z;\n"
    "    r2.xy = r2.xy + c0.zz;\n"
    "    r1.xy = r2.xy + hg_Params[4].xy;\n"
    "    r1.xy = r1.xy*hg_Params[4].zw;\n"
    "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r5.xy = r2.xy + hg_Params[4].xy;\n"
    "    r5.xy = r5.xy*hg_Params[4].zw;\n"
    "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r6.xy = r2.xy + hg_Params[4].xy;\n"
    "    r6.xy = r6.xy*hg_Params[4].zw;\n"
    "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
    "    r2.x = r2.x - r4.x;\n"
    "    r7.xy = r2.xy + hg_Params[4].xy;\n"
    "    r7.xy = r7.xy*hg_Params[4].zw;\n"
    "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
    "    r2.y = r2.y + r4.z;\n"
    "    r8.xy = r2.xy + hg_Params[4].xy;\n"
    "    r8.xy = r8.xy*hg_Params[4].zw;\n"
    "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
    "    r2.x = r2.x - r4.y;\n"
    "    r9.xy = r2.xy + hg_Params[4].xy;\n"
    "    r9.xy = r9.xy*hg_Params[4].zw;\n"
    "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r10.xy = r2.xy + hg_Params[4].xy;\n"
    "    r10.xy = r10.xy*hg_Params[4].zw;\n"
    "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r2.xy = r2.xy + hg_Params[4].xy;\n"
    "    r2.xy = r2.xy*hg_Params[4].zw;\n"
    "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
    "    r1 = mix(r1, r5, r3.xxxx);\n"
    "    r7 = mix(r7, r6, r3.xxxx);\n"
    "    r9 = mix(r9, r10, r3.xxxx);\n"
    "    r8 = mix(r8, r2, r3.xxxx);\n"
    "    r1 = mix(r1, r7, r3.yyyy);\n"
    "    r9 = mix(r9, r8, r3.yyyy);\n"
    "    r3 = mix(r1, r9, r3.zzzz);\n"
    "    r3 = r3*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
    "    output.color0 = select(r3, r0, hg_Params[2] < 0.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BD5668(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BD56A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BD5698);
}

double HgcApply3DLUTTrilinearFast_basekernel::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x30uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3553DD0;
  strcpy(v3, "HgcApply3DLUTTrilinearFast_basekernel [hgc1]");
  return *(double *)"asekernel [hgc1]";
}

uint64_t HgcApply3DLUTTrilinearFast_basekernel::BindTexture(HgcApply3DLUTTrilinearFast_basekernel *this, HGHandler *a2, int a3)
{
  int v4;
  uint64_t result;
  __n128 v6;
  __n128 v7;
  __n128 v8;
  __n128 v9;

  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    {
      v8.n128_u32[0] = 1.0;
      v9.n128_u32[0] = 1.0;
    }
    else
    {
      v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v9.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v6.n128_f32[0] = (float)*((int *)a2 + 60);
    v7.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 4, v6, v7, v8, v9);
    return 0;
  }
  else if (a3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    v4 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
    result = 0;
    if (!v4)
    {
      (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcApply3DLUTTrilinearFast_basekernel::Bind(HgcApply3DLUTTrilinearFast_basekernel *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HgcApply3DLUTTrilinearFast_basekernel *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcApply3DLUTTrilinearFast_basekernel::RenderTile(HgcApply3DLUTTrilinearFast_basekernel *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  int v5;
  float32x4_t v6;
  int32x2_t v7;
  int32x2_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  _OWORD *v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t v36;
  float32x4_t v37;
  int32x2_t v38;
  __int32 v39;
  float32x4_t v40;
  int32x4_t v41;
  __int32 v42;
  float32x4_t v43;
  __int32 v44;
  float32x4_t v45;
  int32x4_t v46;
  __int32 v47;
  __int32 v48;
  __int32 v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int32x4_t v54;
  __int32 v55;
  __int32 v56;
  __int32 v57;
  int8x16_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int32x4_t v62;
  __int32 v63;
  __int32 v64;
  __int32 v65;
  int8x16_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  int32x4_t v70;
  __int32 v71;
  __int32 v72;
  __int32 v73;
  float32x4_t v74;
  float32x4_t v75;
  int32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  int32x4_t v79;
  int8x16_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      v7 = a2[10];
      v8 = a2[2];
      v9 = 16 * a2[11].i32[0];
      v10 = 16 * a2[3].i32[0];
      v11 = 16 * v4;
      v12.i64[0] = 0x3F0000003F000000;
      v12.i64[1] = 0x3F0000003F000000;
      do
      {
        v13 = 0;
        do
        {
          v14 = *(float32x4_t *)(*(_QWORD *)&v7 + v13);
          v15 = (_OWORD *)*((_QWORD *)this + 51);
          v16 = *(float32x4_t *)v15;
          v17 = *((float32x4_t *)v15 + 1);
          v18 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15, 1), vmulq_n_f32(v14, COERCE_FLOAT(*v15)));
          v20 = *((float32x4_t *)v15 + 2);
          v19 = *((float32x4_t *)v15 + 3);
          v21 = vmulq_f32(v18, v18);
          v22 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v19.f32, 1));
          v23 = vmulq_f32(v18, v21);
          v24 = vaddq_f32(v22, vmulq_laneq_f32(v21, v19, 2));
          v25 = vmulq_laneq_f32(v23, v19, 3);
          v26 = *((float32x4_t *)v15 + 4);
          v27 = *((float32x4_t *)v15 + 5);
          v28 = vmaxq_f32(vaddq_f32(v24, v25), v26);
          v29 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1), v27);
          v30 = vminq_f32(v28, v29);
          v31 = vcvtq_f32_s32(vcvtq_s32_f32(v30));
          v32 = vsubq_f32(v31, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v31, v30)));
          v33 = vsubq_f32(vminq_f32(vaddq_f32(v27, v32), v29), v32);
          v34 = vmulq_f32(v17, v32);
          v35 = vmulq_f32(v17, v33);
          v36 = *((int8x16_t *)v15 + 6);
          v37 = vaddq_f32(*((float32x4_t *)v15 + 7), (float32x4_t)vbslq_s8(v36, (int8x16_t)vaddq_f32(v34, (float32x4_t)vrev64q_s32((int32x4_t)v34)), vextq_s8((int8x16_t)v32, (int8x16_t)v32, 4uLL)));
          v38 = a2[12];
          v39 = a2[13].i32[0];
          v40 = vaddq_f32(vsubq_f32(v37, v6), v12);
          v41 = vcvtq_s32_f32(v40);
          v40.i64[0] = vaddq_s32(v41, vcgtq_f32(vcvtq_f32_s32(v41), v40)).u64[0];
          v42 = v40.i32[1];
          v43 = (float32x4_t)vbslq_s8(v36, (int8x16_t)vaddq_f32(v35, v37), (int8x16_t)v37);
          v44 = v40.i32[0];
          v45 = vaddq_f32(vsubq_f32(v43, v6), v12);
          v46 = vcvtq_s32_f32(v45);
          v45.i64[0] = vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)).u64[0];
          v47 = v44 + v42 * v39;
          v48 = v45.i32[1];
          v49 = v45.i32[0];
          v50 = (float32x4_t)vrev64q_s32((int32x4_t)v35);
          v51 = *(float32x4_t *)(*(_QWORD *)&v38 + 16 * v47);
          v52 = (float32x4_t)vbslq_s8(v36, (int8x16_t)vaddq_f32(v50, v43), (int8x16_t)v37);
          v53 = vaddq_f32(vsubq_f32(v52, v6), v12);
          v54 = vcvtq_s32_f32(v53);
          v55 = v49 + v48 * v39;
          v53.i64[0] = vaddq_s32(v54, vcgtq_f32(vcvtq_f32_s32(v54), v53)).u64[0];
          v56 = v53.i32[1];
          v57 = v53.i32[0];
          v58 = (int8x16_t)vsubq_f32(v52, v35);
          v59 = (float32x4_t)vbslq_s8(v36, v58, (int8x16_t)v37);
          v60 = vaddq_f32(vsubq_f32(v59, v6), v12);
          v61 = *(float32x4_t *)(*(_QWORD *)&v38 + 16 * v55);
          v62 = vcvtq_s32_f32(v60);
          v60.i64[0] = vaddq_s32(v62, vcgtq_f32(vcvtq_f32_s32(v62), v60)).u64[0];
          v63 = v60.i32[1];
          v64 = v57 + v56 * v39;
          v65 = v60.i32[0];
          v66 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v35, (int8x16_t)v35, 4uLL), v59);
          v67 = *(float32x4_t *)(*(_QWORD *)&v38 + 16 * v64);
          v68 = (float32x4_t)vbslq_s8(v36, v58, v66);
          v69 = vaddq_f32(vsubq_f32(v68, v6), v12);
          v70 = vcvtq_s32_f32(v69);
          v71 = v65 + v63 * v39;
          v69.i64[0] = vaddq_s32(v70, vcgtq_f32(vcvtq_f32_s32(v70), v69)).u64[0];
          v72 = v69.i32[1];
          v73 = v69.i32[0];
          v74 = (float32x4_t)vbslq_s8(v36, (int8x16_t)vsubq_f32(v68, v50), v66);
          v75 = vaddq_f32(vsubq_f32(v74, v6), v12);
          v76 = vcvtq_s32_f32(v75);
          v75.i64[0] = vaddq_s32(v76, vcgtq_f32(vcvtq_f32_s32(v76), v75)).u64[0];
          v77 = (float32x4_t)vbslq_s8(v36, (int8x16_t)vaddq_f32(v35, v74), v66);
          v78 = vaddq_f32(vsubq_f32(v77, v6), v12);
          v79 = vcvtq_s32_f32(v78);
          v78.i64[0] = vaddq_s32(v79, vcgtq_f32(vcvtq_f32_s32(v79), v78)).u64[0];
          v80 = (int8x16_t)vaddq_f32(v50, v77);
          v81 = *(float32x4_t *)(*(_QWORD *)&v38 + 16 * (v75.i32[0] + v75.i32[1] * v39));
          v82 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v36, v80, v66), v6), v12);
          v83 = vcvtq_s32_f32(v82);
          v82.i64[0] = vaddq_s32(v83, vcgtq_f32(vcvtq_f32_s32(v83), v82)).u64[0];
          v84 = vsubq_f32(v30, v32);
          v85 = vaddq_f32(v51, vmulq_n_f32(vsubq_f32(v61, v51), v84.f32[0]));
          v86 = vaddq_f32(v81, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(_QWORD *)&v38 + 16 * (v78.i32[0] + v78.i32[1] * v39)), v81), v84.f32[0]));
          v87 = vaddq_f32(v85, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)(*(_QWORD *)&v38 + 16 * v71), vmulq_n_f32(vsubq_f32(v67, *(float32x4_t *)(*(_QWORD *)&v38 + 16 * v71)), v84.f32[0])), v85), *(float32x2_t *)v84.f32, 1));
          *(int8x16_t *)(*(_QWORD *)&v8 + v13) = vbslq_s8((int8x16_t)vcgtq_f32(v26, v20), (int8x16_t)v14, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), vmulq_laneq_f32(vaddq_f32(v87, vmulq_laneq_f32(vsubq_f32(vaddq_f32(v86, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)(*(_QWORD *)&v38+ 16* (v73 + v72 * v39)), vmulq_n_f32(vsubq_f32(
                                                                                    *(float32x4_t *)(*(_QWORD *)&v38 + 16 * (v82.i32[0] + v82.i32[1] * v39)),
                                                                                    *(float32x4_t *)(*(_QWORD *)&v38 + 16 * (v73 + v72 * v39))),
                                                                                  v84.f32[0])),
                                                                              v86),
                                                                            *(float32x2_t *)v84.f32,
                                                                            1)),
                                                                        v87),
                                                                      v84,
                                                                      2)),
                                                                  v16,
                                                                  2)));
          v13 += 16;
        }
        while (v11 != v13);
        ++v5;
        *(_QWORD *)&v7 += v9;
        *(_QWORD *)&v8 += v10;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcApply3DLUTTrilinearFast_basekernel::GetDOD(HgcApply3DLUTTrilinearFast_basekernel *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 1)
    return 0x8000000080000000;
  if (a3)
    return 0;
  return *(_QWORD *)&a4.var0;
}

uint64_t HgcApply3DLUTTrilinearFast_basekernel::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, 1u);
    return HGRenderer::GetDOD(a2, Input);
  }
  else if (a3)
  {
    return 0;
  }
  else
  {
    return *(_QWORD *)&a4.var0;
  }
}

void HgcApply3DLUTTrilinearFast_basekernel::HgcApply3DLUTTrilinearFast_basekernel(HgcApply3DLUTTrilinearFast_basekernel *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6544508;
  v3 = (_OWORD *)operator new();
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  v3[4] = 0u;
  v3[5] = xmmword_1B3051560;
  v3[6] = xmmword_1B3050E20;
  v3[7] = xmmword_1B3052100;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcApply3DLUTTrilinearFast_basekernel *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BD5D94(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcApply3DLUTTrilinearFast_basekernel::~HgcApply3DLUTTrilinearFast_basekernel(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6544508;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6544508;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6544508;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcApply3DLUTTrilinearFast_basekernel::SetParameter(HgcApply3DLUTTrilinearFast_basekernel *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcApply3DLUTTrilinearFast_basekernel::GetParameter(HgcApply3DLUTTrilinearFast_basekernel *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcColorGamma_2vuy_yxzx_expand::GetProgram(HgcColorGamma_2vuy_yxzx_expand *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003fa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord0.xy*float2(c0.xy);\n"
             "    s0.xy = floor(s0.xy);\n"
             "    s0.xy = s0.xy + float2(c0.xx);\n"
             "    s0.xy = s0.xy + hg_Params[0].xy;\n"
             "    s0.xy = s0.xy*hg_Params[0].zw;\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s0.xy);\n"
             "    s0.x = float(fract(0.500000f*frag._texCoord0.x) >= 0.500000f);\n"
             "    r1 = half4(r0.y, r0.z, r0.x, 1.00000h);\n"
             "    s1.yzw = float3(r1.yzw);\n"
             "    s1.x = select(float(r1.x), float(r0.w), -s0.x < 0.00000h);\n"
             "    output.color0 = s1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=3f268be6:187954fb:6e0dcb63:6ce755ba\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0001:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003ad\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy*c0.xy;\n"
             "    r0.xy = floor(r0.xy);\n"
             "    r0.xy = r0.xy + c0.xx;\n"
             "    r0.xy = r0.xy + hg_Params[0].xy;\n"
             "    r0.xy = r0.xy*hg_Params[0].zw;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r1.x = float(fract(0.500000f*frag._texCoord0.x) >= 0.500000f);\n"
             "    r2 = float4(r0.y, r0.z, r0.x, 1.00000f);\n"
             "    r2.x = select(r2.x, r0.w, -r1.x < 0.00000f);\n"
             "    output.color0 = r2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9aad681a:95105c3e:57454f67:c4097cd0\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000386\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy*c0.xy;\n"
           "    r0.xy = floor(r0.xy);\n"
           "    r0.xy = r0.xy + c0.xx;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal0.zw;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r1.x = c0.x*hg_TexCoord0.x;\n"
           "    r1.x = fract(r1.x);\n"
           "    r1.x = float(r1.x >= c0.x);\n"
           "    r2 = vec4(r0.y, r0.z, r0.x, 1.00000);\n"
           "    r2.x = -r1.x < 0.00000 ? r0.w : r2.x;\n"
           "    gl_FragColor = r2;\n"
           "}\n"
           "//MD5=1b446ee9:f22ade39:784a51a7:e86f3a81\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorGamma_2vuy_yxzx_expand::InitProgramDescriptor(HgcColorGamma_2vuy_yxzx_expand *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_2vuy_yxzx_expand_hgc_visible", "//Metal1.0     \n//LEN=00000002f8\n[[ visible ]] FragmentOut HgcColorGamma_2vuy_yxzx_expand_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy*c0.xy;\n"
    "    r0.xy = floor(r0.xy);\n"
    "    r0.xy = r0.xy + c0.xx;\n"
    "    r0.xy = r0.xy + hg_Params[0].xy;\n"
    "    r0.xy = r0.xy*hg_Params[0].zw;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r1.x = float(fract(0.500000f*texCoord0.x) >= 0.500000f);\n"
    "    r2 = float4(r0.y, r0.z, r0.x, 1.00000f);\n"
    "    r2.x = select(r2.x, r0.w, -r1.x < 0.00000f);\n"
    "    output.color0 = r2;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BD6320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BD6358(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BD6350);
}

char *HgcColorGamma_2vuy_yxzx_expand::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A20;
  strcpy(result, "HgcColorGamma_2vuy_yxzx_expand [hgc1]");
  return result;
}

uint64_t HgcColorGamma_2vuy_yxzx_expand::BindTexture(HgcColorGamma_2vuy_yxzx_expand *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, _QWORD, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 0, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcColorGamma_2vuy_yxzx_expand::Bind(HgcColorGamma_2vuy_yxzx_expand *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HgcColorGamma_2vuy_yxzx_expand *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcColorGamma_2vuy_yxzx_expand::RenderTile(HgcColorGamma_2vuy_yxzx_expand *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  int32x2_t v7;
  uint64_t v8;
  float32x4_t v9;
  float32x4_t v10;
  uint64_t v11;
  int v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  uint64_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  __int32 v29;
  float32x4_t v30;
  int32x4_t v31;
  __int32 v32;
  float32x4_t v33;
  int32x4_t v34;
  __int32 v35;
  float32x4_t v36;
  int32x4_t v37;
  __int32 v38;
  __int32 v39;
  __int32 v40;
  int32x2_t v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int8x16_t v46;
  float32x4_t v47;
  float32x4_t v48;
  int8x16_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int8x16_t v54;
  float32x4_t v55;
  int8x16_t v56;
  int8x16_t *v57;
  uint64_t v58;
  int8x16_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x16_t v64;
  float32x4_t v65;
  int32x4_t v66;
  __int32 v67;
  float32x4_t v68;
  float32x4_t v69;
  int8x16_t v70;
  int8x16_t v71;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = a2[2];
    v8 = 16 * a2[3].i32[0];
    v9.i64[0] = 0x3F0000003F000000;
    v9.i64[1] = 0x3F0000003F000000;
    v10 = v5;
    while (v6 < 3)
    {
      v11 = 0;
      v13 = v10;
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      v10 = vaddq_f32(v10, (float32x4_t)xmmword_1B304F240);
      ++v4;
      *(_QWORD *)&v7 += v8;
      if (v4 == v3)
        return 0;
    }
    v11 = 0;
    v12 = v6;
    v13 = v10;
    do
    {
      v14 = vaddq_f32(v13, (float32x4_t)xmmword_1B304F230);
      v15 = vaddq_f32(v14, (float32x4_t)xmmword_1B304F230);
      v16 = *((_QWORD *)this + 51);
      v17 = *(int8x16_t *)(v16 + 16);
      v18 = vmulq_f32(v13, *(float32x4_t *)v16);
      v19 = vmulq_f32(v14, *(float32x4_t *)v16);
      v20 = vmulq_f32(v15, *(float32x4_t *)v16);
      v21 = vcvtq_f32_s32(vcvtq_s32_f32(v18));
      v22 = vcvtq_f32_s32(vcvtq_s32_f32(v19));
      v23 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
      v24 = vsubq_f32(v21, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v21, v18)));
      v25 = vsubq_f32(v22, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v22, v19)));
      v26 = vsubq_f32(v23, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v23, v20)));
      v27 = *(float32x4_t *)(v16 + 32);
      v28 = *(int8x16_t *)(v16 + 48);
      v29 = a2[11].i32[0];
      v30 = vaddq_f32(vsubq_f32(vaddq_f32(v27, v24), v5), v9);
      v31 = vcvtq_s32_f32(v30);
      v30.i64[0] = vaddq_s32(v31, vcgtq_f32(vcvtq_f32_s32(v31), v30)).u64[0];
      v32 = v30.i32[1];
      v33 = vaddq_f32(vsubq_f32(vaddq_f32(v27, v25), v5), v9);
      v34 = vcvtq_s32_f32(v33);
      v33.i64[0] = vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v33)).u64[0];
      v35 = v30.i32[0];
      v36 = vaddq_f32(vsubq_f32(vaddq_f32(v27, v26), v5), v9);
      v37 = vcvtq_s32_f32(v36);
      v36.i64[0] = vaddq_s32(v37, vcgtq_f32(vcvtq_f32_s32(v37), v36)).u64[0];
      v38 = v35 + v32 * v29;
      v39 = v33.i32[0] + v33.i32[1] * v29;
      v40 = v36.i32[0] + v36.i32[1] * v29;
      v41 = a2[10];
      v42 = *(int8x16_t *)(*(_QWORD *)&v41 + 16 * v38);
      v43 = vmulq_f32(v13, v27);
      v44 = vmulq_f32(v14, v27);
      v45 = vmulq_f32(v15, v27);
      v46 = *(int8x16_t *)(*(_QWORD *)&v41 + 16 * v39);
      v47 = vcvtq_f32_s32(vcvtq_s32_f32(v43));
      v48 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      v49 = *(int8x16_t *)(*(_QWORD *)&v41 + 16 * v40);
      v50 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      v51 = (float32x4_t)vandq_s8(v17, (int8x16_t)vcgeq_f32(vsubq_f32(v43, vsubq_f32(v47, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v47, v43)))), v27));
      v52 = (float32x4_t)vandq_s8(v17, (int8x16_t)vcgeq_f32(vsubq_f32(v44, vsubq_f32(v48, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v48, v44)))), v27));
      v53 = (float32x4_t)vandq_s8(v17, (int8x16_t)vcgeq_f32(vsubq_f32(v45, vsubq_f32(v50, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v50, v45)))), v27));
      *(int8x8_t *)v27.f32 = vqtbl1_s8(v42, *(int8x8_t *)v28.i8);
      v45.i64[0] = vextq_s8(v28, v28, 8uLL).u64[0];
      v27.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v42, *(int8x8_t *)v45.f32).u32[0]);
      *(int8x8_t *)v47.f32 = vqtbl1_s8(v46, *(int8x8_t *)v28.i8);
      *(int8x8_t *)v28.i8 = vqtbl1_s8(v49, *(int8x8_t *)v28.i8);
      v47.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v46, *(int8x8_t *)v45.f32).u32[0]);
      v28.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v49, *(int8x8_t *)v45.f32).u32[0]);
      v54 = vextq_s8(v46, v46, 0xCuLL);
      v55 = *(float32x4_t *)(v16 + 64);
      v56 = *(int8x16_t *)(v16 + 80);
      v57 = (int8x16_t *)(*(_QWORD *)&v7 + 16 * v11);
      *v57 = vbslq_s8(v56, vbslq_s8((int8x16_t)vcgtq_f32(v51, v55), vextq_s8(v42, v42, 0xCuLL), (int8x16_t)v27), (int8x16_t)v27);
      v57[1] = vbslq_s8(v56, vbslq_s8((int8x16_t)vcgtq_f32(v52, v55), v54, (int8x16_t)v47), (int8x16_t)v47);
      v57[2] = vbslq_s8(v56, vbslq_s8((int8x16_t)vcgtq_f32(v53, v55), vextq_s8(v49, v49, 0xCuLL), v28), v28);
      v13 = vaddq_f32(v15, (float32x4_t)xmmword_1B304F230);
      v11 += 3;
      v12 -= 3;
    }
    while (v12 > 2);
    v11 = v11;
    if ((int)v11 >= v6)
      goto LABEL_3;
    do
    {
LABEL_10:
      v58 = *((_QWORD *)this + 51);
      v59 = *(int8x16_t *)(v58 + 16);
      v60 = vmulq_f32(v13, *(float32x4_t *)v58);
      v61 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v62 = vsubq_f32(v61, (float32x4_t)vandq_s8(v59, (int8x16_t)vcgtq_f32(v61, v60)));
      v63 = *(float32x4_t *)(v58 + 32);
      v64 = *(int8x16_t *)(v58 + 48);
      v65 = vaddq_f32(vsubq_f32(vaddq_f32(v63, v62), v5), v9);
      v66 = vcvtq_s32_f32(v65);
      v65.i64[0] = vaddq_s32(v66, vcgtq_f32(vcvtq_f32_s32(v66), v65)).u64[0];
      v67 = v65.i32[0] + v65.i32[1] * a2[11].i32[0];
      v68 = vmulq_f32(v13, v63);
      v69 = vcvtq_f32_s32(vcvtq_s32_f32(v68));
      v70 = *(int8x16_t *)(*(_QWORD *)&a2[10] + 16 * v67);
      v71 = (int8x16_t)vcgeq_f32(vsubq_f32(v68, vsubq_f32(v69, (float32x4_t)vandq_s8(v59, (int8x16_t)vcgtq_f32(v69, v68)))), v63);
      *(int8x8_t *)v63.f32 = vqtbl1_s8(v70, *(int8x8_t *)v64.i8);
      v63.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v70, (int8x8_t)*(_OWORD *)&vextq_s8(v64, v64, 8uLL)).u32[0]);
      *(int8x16_t *)(*(_QWORD *)&v7 + 16 * v11) = vbslq_s8(*(int8x16_t *)(v58 + 80), vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8(v59, v71), *(float32x4_t *)(v58 + 64)), vextq_s8(v70, v70, 0xCuLL), (int8x16_t)v63), (int8x16_t)v63);
      v13 = vaddq_f32(v13, (float32x4_t)xmmword_1B304F230);
      ++v11;
    }
    while (v11 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcColorGamma_2vuy_yxzx_expand::GetDOD(HgcColorGamma_2vuy_yxzx_expand *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  float v9;
  double v10;
  float v11;
  double v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
  v8 = HGRectGrow(v6, v5, v7);
  v9 = HGRectFloat(v8);
  v13 = HGRectScale(v9, v10, v11, v12, 2.0);
  v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcColorGamma_2vuy_yxzx_expand::GetROI(HgcColorGamma_2vuy_yxzx_expand *this, HGRenderer *a2, int a3, HGRect a4)
{
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = HGRectFloat(a4.var0);
  v9 = HGRectScale(v5, v6, v7, v8, 0.5);
  v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  v16 = v15;
  v17 = HGRectMake4i(0, 0, 1u, 0);
  v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcColorGamma_2vuy_yxzx_expand::HgcColorGamma_2vuy_yxzx_expand(HgcColorGamma_2vuy_yxzx_expand *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6544770;
  v3 = operator new();
  *(_OWORD *)v3 = xmmword_1B3553E10;
  *(_OWORD *)(v3 + 16) = xmmword_1B30520F0;
  *(_OWORD *)(v3 + 32) = xmmword_1B3052100;
  *(_OWORD *)(v3 + 48) = xmmword_1B3052910;
  *(_QWORD *)(v3 + 64) = 0;
  *(_QWORD *)(v3 + 72) = 0;
  *(_OWORD *)(v3 + 80) = xmmword_1B3050E20;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcColorGamma_2vuy_yxzx_expand *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BD6A24(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_2vuy_yxzx_expand::~HgcColorGamma_2vuy_yxzx_expand(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6544770;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6544770;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6544770;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_2vuy_yxzx_expand::SetParameter(HgcColorGamma_2vuy_yxzx_expand *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_2vuy_yxzx_expand::GetParameter(HgcColorGamma_2vuy_yxzx_expand *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcPremultiply::GetProgram(HgcPremultiply *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000245\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d94e4443:daab1afb:2b68adf7:815e6ba9\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000237\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=a13a6a2f:33512419:9d3fb3a8:463fe70f\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001d9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=ebd2844b:d31991ae:bbb76419:aca54bd2\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPremultiply::InitProgramDescriptor(HgcPremultiply *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPremultiply_hgc_visible", "//Metal1.0     \n//LEN=000000010f\n[[ visible ]] FragmentOut HgcPremultiply_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BD6DC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BD6DF4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BD6DECLL);
}

void HgcPremultiply::shaderDescription(char *a1@<X8>)
{
  a1[23] = 21;
  strcpy(a1, "HgcPremultiply [hgc1]");
}

uint64_t HgcPremultiply::BindTexture(HgcPremultiply *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPremultiply::Bind(HgcPremultiply *this, HGHandler *a2)
{
  (*(void (**)(HgcPremultiply *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcPremultiply::RenderTile(HgcPremultiply *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  int8x16_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t *v11;
  int8x16_t *v12;
  unint64_t v13;
  int8x16_t *v14;
  float32x4_t *v15;
  uint64_t v16;
  float32x4_t *v17;
  int8x16_t *v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t *v23;
  float32x4_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (int8x16_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v25 = 0;
        v26 = 16 * v7;
        v27 = 16 * v6;
        v28 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v29 = 0;
          do
          {
            v5[v29 / 0x10] = vbslq_s8(*(int8x16_t *)*((_QWORD *)this + 51), (int8x16_t)v4[v29 / 0x10], (int8x16_t)vmulq_laneq_f32(v4[v29 / 0x10], v4[v29 / 0x10], 3));
            v29 += 16;
          }
          while (v28 != v29);
          ++v25;
          v4 = (float32x4_t *)((char *)v4 + v26);
          v5 = (int8x16_t *)((char *)v5 + v27);
        }
        while (v25 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = v14;
          v19 = *(int8x16_t *)*((_QWORD *)this + 51);
          v20 = vbslq_s8(v19, (int8x16_t)v4[v16 - 1], (int8x16_t)vmulq_laneq_f32(v4[v16 - 1], v4[v16 - 1], 3));
          v21 = vbslq_s8(v19, (int8x16_t)v4[v16], (int8x16_t)vmulq_laneq_f32(v4[v16], v4[v16], 3));
          v22 = vbslq_s8(v19, (int8x16_t)v4[v16 + 1], (int8x16_t)vmulq_laneq_f32(v4[v16 + 1], v4[v16 + 1], 3));
          v23 = &v5[v16];
          v23[-2] = vbslq_s8(v19, (int8x16_t)v4[v16 - 2], (int8x16_t)vmulq_laneq_f32(v4[v16 - 2], v4[v16 - 2], 3));
          v23[-1] = v20;
          v13 += 4;
          *v23 = v21;
          v23[1] = v22;
          v16 += 4;
          v15 += 4;
          v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v24 = *v17++;
            *v18++ = vbslq_s8(*(int8x16_t *)*((_QWORD *)this + 51), (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v24, v24, 3));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (int8x16_t *)((char *)v5 + v9);
        v4 = (float32x4_t *)((char *)v4 + v10);
        v11 = (float32x4_t *)((char *)v11 + v10);
        v12 = (int8x16_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPremultiply::GetDOD(HgcPremultiply *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcPremultiply::GetROI(HgcPremultiply *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcPremultiply::HgcPremultiply(HgcPremultiply *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65449D8;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BD710C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPremultiply::~HgcPremultiply(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65449D8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65449D8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcPremultiply::SetParameter(HgcPremultiply *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPremultiply::GetParameter(HgcPremultiply *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcToneParamCurve4::GetProgram(HgcToneParamCurve4 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003b2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = half3(hg_Params[1].xyz)*r0.xyz + half3(hg_Params[2].xyz);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xyz));\n"
             "    r1.xyz = r1.xyz + half3(hg_Params[5].xyz);\n"
             "    r2.xyz = r0.xyz - half3(hg_Params[4].xyz);\n"
             "    r3.xyz = r0.xyz*half3(hg_Params[3].xyz) + half3(hg_Params[6].xyz);\n"
             "    output.color0.xyz = select(float3(r1.xyz), float3(r3.xyz), float3(r2.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1d41385c:778e5a27:1d60d889:a8729d7e\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0007:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000035c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
             "    r1.xyz = r1.xyz + hg_Params[5].xyz;\n"
             "    r2.xyz = r0.xyz - hg_Params[4].xyz;\n"
             "    r3.xyz = r0.xyz*hg_Params[3].xyz + hg_Params[6].xyz;\n"
             "    output.color0.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=13f252c1:8bebdb6c:281a8258:9f05e0c5\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0007:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000045e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "uniform mediump vec4 hg_ProgramLocal4;\n"
           "uniform mediump vec4 hg_ProgramLocal5;\n"
           "uniform mediump vec4 hg_ProgramLocal6;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = hg_ProgramLocal1.xyz*r0.xyz + hg_ProgramLocal2.xyz;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xyz);\n"
           "    r1.xyz = r1.xyz + hg_ProgramLocal5.xyz;\n"
           "    r2.xyz = r0.xyz - hg_ProgramLocal4.xyz;\n"
           "    r3.xyz = r0.xyz*hg_ProgramLocal3.xyz + hg_ProgramLocal6.xyz;\n"
           "    gl_FragColor.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z"
           " : r1.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=2ab6ce4c:9d775dbf:c9e5cc75:c3634fc7\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0007:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve4::InitProgramDescriptor(HgcToneParamCurve4 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve4_hgc_visible", "//Metal1.0     \n//LEN=0000000238\n[[ visible ]] FragmentOut HgcToneParamCurve4_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
    "    r1.xyz = r1.xyz + hg_Params[5].xyz;\n"
    "    r2.xyz = r0.xyz - hg_Params[4].xyz;\n"
    "    r3.xyz = r0.xyz*hg_Params[3].xyz + hg_Params[6].xyz;\n"
    "    output.color0.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BD7464(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BD7494(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BD748CLL);
}

double HgcToneParamCurve4::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcToneParamCurve4 [hgc1]");
  return *(double *)"ramCurve4 [hgc1]";
}

uint64_t HgcToneParamCurve4::BindTexture(HgcToneParamCurve4 *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve4::Bind(HgcToneParamCurve4 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 6, *((_QWORD *)this + 51) + 96, 1);
  (*(void (**)(HgcToneParamCurve4 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcToneParamCurve4::RenderTile(HgcToneParamCurve4 *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int32x4_t v58;
  int32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int8x16_t v65;
  int8x16_t v66;
  int8x16_t v67;
  int8x16_t *v68;
  int v69;
  uint64_t v70;
  float32x4_t v71;
  uint64_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v69 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v12 = *(float32x4_t *)(v6 + v10 - 16);
      v11 = *(float32x4_t *)(v6 + v10);
      v13 = *((_QWORD *)this + 51);
      v14 = *(float32x4_t *)(v13 + 16);
      v15 = *(float32x4_t *)(v13 + 32);
      v16 = *(float32x4_t *)(v13 + 48);
      v17 = vaddq_f32(v15, vmulq_f32(v12, v14));
      v18 = vaddq_f32(v15, vmulq_f32(v11, v14));
      v20 = *(float32x4_t *)(v13 + 96);
      v19 = *(int8x16_t *)(v13 + 112);
      v21 = *(float32x4_t *)(v13 + 128);
      v22 = *(float32x4_t *)(v13 + 144);
      v23 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v17), (int8x16_t)v21);
      v24 = *(int8x16_t *)(v13 + 160);
      v25 = *(float32x4_t *)(v13 + 176);
      v26 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v18), (int8x16_t)v21);
      v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v18)));
      v28 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v17))), v25);
      v29 = *(float32x4_t *)(v13 + 192);
      v30 = *(float32x4_t *)(v13 + 208);
      v31 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v23, v29));
      v32 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v26, v29));
      v33 = vaddq_f32(v28, v31);
      v34 = vaddq_f32(vsubq_f32(v27, v25), v32);
      v35 = vsubq_f32(vsubq_f32(v23, v21), vmulq_f32(vmulq_f32(v30, v31), v23));
      v36 = vsubq_f32(vsubq_f32(v26, v21), vmulq_f32(vmulq_f32(v30, v32), v26));
      v37 = *(float32x4_t *)(v13 + 224);
      v38 = *(float32x4_t *)(v13 + 240);
      v39 = vaddq_f32(v37, vmulq_f32(v38, v35));
      v40 = vaddq_f32(v37, vmulq_f32(v38, v36));
      v41 = *(float32x4_t *)(v13 + 256);
      v42 = *(float32x4_t *)(v13 + 272);
      v43 = vmulq_f32(*(float32x4_t *)v13, vaddq_f32(v34, vmulq_f32(v36, vaddq_f32(vaddq_f32(v41, vmulq_f32(v36, v42)), vmulq_f32(vmulq_f32(v36, v36), v40)))));
      v44 = *(float32x4_t *)(v13 + 288);
      v45 = *(float32x4_t *)(v13 + 304);
      v46 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v13, vaddq_f32(v33, vmulq_f32(v35, vaddq_f32(vaddq_f32(v41, vmulq_f32(v35, v42)), vmulq_f32(vmulq_f32(v35, v35), v39))))), v44);
      v47 = vmaxq_f32(v43, v44);
      v48 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
      v49 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      v50 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v48, v46)));
      v51 = vsubq_f32(v49, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v49, v47)));
      v52 = vsubq_f32(v46, v50);
      v53 = vsubq_f32(v47, v51);
      v54 = *(float32x4_t *)(v13 + 320);
      v55 = *(float32x4_t *)(v13 + 336);
      v56 = vmulq_f32(v53, vaddq_f32(v55, vmulq_f32(v53, vaddq_f32(v45, vmulq_f32(v54, v53)))));
      v57 = vaddq_f32(v21, vmulq_f32(v52, vaddq_f32(v55, vmulq_f32(v52, vaddq_f32(v45, vmulq_f32(v54, v52))))));
      v58 = vcvtq_s32_f32(v51);
      v59 = *(int32x4_t *)(v13 + 352);
      v60 = *(float32x4_t *)(v13 + 368);
      v61 = vmulq_f32(v57, (float32x4_t)vshlq_n_s32(vaddq_s32(v59, vcvtq_s32_f32(v50)), 0x17uLL));
      v62 = vmulq_f32(vaddq_f32(v21, v56), (float32x4_t)vshlq_n_s32(vaddq_s32(v59, v58), 0x17uLL));
      v64 = *(float32x4_t *)(v13 + 64);
      v63 = *(float32x4_t *)(v13 + 80);
      v65 = (int8x16_t)vaddq_f32(v63, v62);
      v66 = vbslq_s8((int8x16_t)vcgtq_f32(v60, vsubq_f32(v12, v64)), (int8x16_t)vaddq_f32(v20, vmulq_f32(v12, v16)), (int8x16_t)vaddq_f32(v63, v61));
      v67 = *(int8x16_t *)(v13 + 384);
      v68 = (int8x16_t *)(v5 + v10);
      v68[-1] = vbslq_s8(v67, (int8x16_t)v12, v66);
      *v68 = vbslq_s8(v67, (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32(v60, vsubq_f32(v11, v64)), (int8x16_t)vaddq_f32(v20, vmulq_f32(v11, v16)), v65));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v69 = -v9;
    if (v69 >= v4)
      goto LABEL_3;
LABEL_10:
    v70 = 16 * v69;
    v71 = *(float32x4_t *)(v6 + v70);
    v72 = *((_QWORD *)this + 51);
    v73 = vaddq_f32(*(float32x4_t *)(v72 + 32), vmulq_f32(v71, *(float32x4_t *)(v72 + 16)));
    v74 = *(float32x4_t *)(v72 + 128);
    v75 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v72 + 112), (int8x16_t)v73), (int8x16_t)v74);
    v76 = (float32x4_t)vandq_s8((int8x16_t)v74, (int8x16_t)vcgtq_f32(v75, *(float32x4_t *)(v72 + 192)));
    v77 = vsubq_f32(vsubq_f32(v75, v74), vmulq_f32(vmulq_f32(*(float32x4_t *)(v72 + 208), v76), v75));
    v78 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v72, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v73, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v72 + 160), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v72 + 144), v73))), *(float32x4_t *)(v72 + 176)), v76), vmulq_f32(v77, vaddq_f32(vaddq_f32(*(float32x4_t *)(v72 + 256), vmulq_f32(v77, *(float32x4_t *)(v72 + 272))), vmulq_f32(vmulq_f32(v77, v77), vaddq_f32(*(float32x4_t *)(v72 + 224), vmulq_f32(*(float32x4_t *)(v72 + 240), v77))))))),
            *(float32x4_t *)(v72 + 288));
    v79 = vcvtq_f32_s32(vcvtq_s32_f32(v78));
    v80 = vsubq_f32(v79, (float32x4_t)vandq_s8((int8x16_t)v74, (int8x16_t)vcgtq_f32(v79, v78)));
    v81 = vsubq_f32(v78, v80);
    *(int8x16_t *)(v5 + v70) = vbslq_s8(*(int8x16_t *)(v72 + 384), (int8x16_t)v71, vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(v72 + 368), vsubq_f32(v71, *(float32x4_t *)(v72 + 64))), (int8x16_t)vaddq_f32(*(float32x4_t *)(v72 + 96), vmulq_f32(v71, *(float32x4_t *)(v72 + 48))), (int8x16_t)vaddq_f32(*(float32x4_t *)(v72 + 80), vmulq_f32(vaddq_f32(v74, vmulq_f32(v81, vaddq_f32(*(float32x4_t *)(v72 + 336), vmulq_f32(
                                                          v81,
                                                          vaddq_f32(*(float32x4_t *)(v72 + 304), vmulq_f32(*(float32x4_t *)(v72 + 320), v81)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v72 + 352), vcvtq_s32_f32(v80)), 0x17uLL)))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcToneParamCurve4::GetDOD(HgcToneParamCurve4 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcToneParamCurve4::GetROI(HgcToneParamCurve4 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcToneParamCurve4::HgcToneParamCurve4(HgcToneParamCurve4 *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6544C40;
  v3 = operator new();
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 96) = 0u;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051600;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051560;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051610;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051620;
  *(_OWORD *)(v3 + 176) = xmmword_1B3051630;
  *(_OWORD *)(v3 + 192) = xmmword_1B3051640;
  *(_OWORD *)(v3 + 208) = xmmword_1B3051510;
  *(_OWORD *)(v3 + 224) = xmmword_1B3051650;
  *(_OWORD *)(v3 + 240) = xmmword_1B3051660;
  *(_OWORD *)(v3 + 256) = xmmword_1B3051670;
  *(_OWORD *)(v3 + 272) = xmmword_1B3051680;
  *(_OWORD *)(v3 + 288) = xmmword_1B3051690;
  *(_OWORD *)(v3 + 304) = xmmword_1B30516A0;
  *(_OWORD *)(v3 + 320) = xmmword_1B30516B0;
  *(_OWORD *)(v3 + 336) = xmmword_1B30516C0;
  *(_OWORD *)(v3 + 352) = xmmword_1B30516D0;
  *(_QWORD *)(v3 + 368) = 0;
  *(_QWORD *)(v3 + 376) = 0;
  *(_OWORD *)(v3 + 384) = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BD7BA4(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve4::~HgcToneParamCurve4(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6544C40;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C402BC884A0);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6544C40;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C402BC884A0);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve4::SetParameter(HgcToneParamCurve4 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 6)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcToneParamCurve4::GetParameter(HgcToneParamCurve4 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 6)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcColorGamma_v210_yxzx_rgba_expand::GetProgram(HgcColorGamma_v210_yxzx_rgba_expand *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000955\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.1666669995, 1.000000000, 4.000000000, 0.5000000000);\n"
             "    const half4 c1 = half4(6.000000000, 1.000000000, 0.000000000, 5.000000000);\n"
             "    const half4 c2 = half4(3.000000000, 2.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    float4 s0, s1, s2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord0.xy*float2(c0.xy);\n"
             "    s0.xy = floor(s0.xy);\n"
             "    s0.xy = s0.xy*float2(c0.zy) + float2(c0.ww);\n"
             "    s1.xyz = floor(frag._texCoord0.xxx);\n"
             "    s1.xyz = s1.xyz - float3(c1.xxx)*floor(s1.xyz/float3(c1.xxx));\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r0.xyz = (half3) hg_Texture0.sample(hg_Sampler0, s2.xy).xyz;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r1.xyz = (half3) hg_Texture0.sample(hg_Sampler0, s2.xy).xyz;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r2.xyz = (half3) hg_Texture0.sample(hg_Sampler0, s2.xy).xyz;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s0.xy = s0.xy + hg_Params[0].xy;\n"
             "    s0.xy = s0.xy*hg_Params[0].zw;\n"
             "    r3.xyz = (half3) hg_Texture0.sample(hg_Sampler0, s0.xy).xyz;\n"
             "    r0.xyz = r0.yxz;\n"
             "    r4.yz = r0.yz;\n"
             "    r4.x = r1.x;\n"
             "    r1.xy = r1.zy;\n"
             "    r1.z = r2.x;\n"
             "    r5.yz = r1.yz;\n"
             "    r5.x = r2.y;\n"
             "    r6.xz = r3.xy;\n"
             "    r6.y = r2.z;\n"
             "    r2.yz = r6.yz;\n"
             "    r2.x = r3.z;\n"
             "    s2.xyz = s1.xyz - float3(c1.www);\n"
             "    s2.xyz = select(float3(r2.xyz), float3(r6.xyz), s2.xyz < 0.00000h);\n"
             "    s0.xyz = s1.xyz - float3(c0.zzz);\n"
             "    s2.xyz = select(s2.xyz, float3(r5.xyz), s0.xyz < 0.00000h);\n"
             "    s0.xyz = s1.xyz - float3(c2.xxx);\n"
             "    s2.xyz = select(s2.xyz, float3(r1.xyz), s0.xyz < 0.00000h);\n"
             "    s0.xyz = s1.xyz - float3(c2.yyy);\n"
             "    s2.xyz = select(s2.xyz, float3(r4.xyz), s0.xyz < 0.00000h);\n"
             "    s1.xyz = s1.xyz - float3(c1.yyy);\n"
             "    s2.xyz = select(s2.xyz, float3(r0.xyz), s1.xyz < 0.00000h);\n"
             "    s2.w = float(c1.y);\n"
             "    output.color0 = s2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9faef4db:63ae184b:410e2309:949438a2\n"
             "//SIG=00400000:00000000:00000000:00000001:0003:0001:000a:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000088b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.1666669995, 1.000000000, 4.000000000, 0.5000000000);\n"
             "    const float4 c1 = float4(6.000000000, 1.000000000, 0.000000000, 5.000000000);\n"
             "    const float4 c2 = float4(3.000000000, 2.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy*c0.xy;\n"
             "    r0.xy = floor(r0.xy);\n"
             "    r0.xy = r0.xy*c0.zy + c0.ww;\n"
             "    r1.xyz = floor(frag._texCoord0.xxx);\n"
             "    r1.xyz = r1.xyz - c1.xxx*floor(r1.xyz/c1.xxx);\n"
             "    r2.xy = r0.xy + hg_Params[0].xy;\n"
             "    r2.xy = r2.xy*hg_Params[0].zw;\n"
             "    r2.xyz = hg_Texture0.sample(hg_Sampler0, r2.xy).xyz;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r3.xy = r0.xy + hg_Params[0].xy;\n"
             "    r3.xy = r3.xy*hg_Params[0].zw;\n"
             "    r3.xyz = hg_Texture0.sample(hg_Sampler0, r3.xy).xyz;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r4.xy = r0.xy + hg_Params[0].xy;\n"
             "    r4.xy = r4.xy*hg_Params[0].zw;\n"
             "    r4.xyz = hg_Texture0.sample(hg_Sampler0, r4.xy).xyz;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r0.xy = r0.xy + hg_Params[0].xy;\n"
             "    r0.xy = r0.xy*hg_Params[0].zw;\n"
             "    r0.xyz = hg_Texture0.sample(hg_Sampler0, r0.xy).xyz;\n"
             "    r2.xyz = r2.yxz;\n"
             "    r5.yz = r2.yz;\n"
             "    r5.x = r3.x;\n"
             "    r3.xy = r3.zy;\n"
             "    r3.z = r4.x;\n"
             "    r6.yz = r3.yz;\n"
             "    r6.x = r4.y;\n"
             "    r7.xz = r0.xy;\n"
             "    r7.y = r4.z;\n"
             "    r4.yz = r7.yz;\n"
             "    r4.x = r0.z;\n"
             "    r0.xyz = r1.xyz - c1.www;\n"
             "    r4.xyz = select(r4.xyz, r7.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz - c0.zzz;\n"
             "    r4.xyz = select(r4.xyz, r6.xyz, r0.xyz < 0.00000f);\n"
             "    r7.xyz = r1.xyz - c2.xxx;\n"
             "    r4.xyz = select(r4.xyz, r3.xyz, r7.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz - c2.yyy;\n"
             "    r4.xyz = select(r4.xyz, r5.xyz, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz - c1.yyy;\n"
             "    r4.xyz = select(r4.xyz, r2.xyz, r1.xyz < 0.00000f);\n"
             "    r4.w = c1.y;\n"
             "    output.color0 = r4;\n"
             "    return output;\n"
             "}\n"
             "//MD5=d483035d:436789a8:f3f21232:16bff0a5\n"
             "//SIG=00000000:00000000:00000000:00000000:0003:0001:0008:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000094f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.1666669995, 1.000000000, 4.000000000, 0.5000000000);\n"
           "    const highp vec4 c1 = vec4(6.000000000, 1.000000000, 0.000000000, 5.000000000);\n"
           "    const highp vec4 c2 = vec4(3.000000000, 2.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy*c0.xy;\n"
           "    r0.xy = floor(r0.xy);\n"
           "    r0.xy = r0.xy*c0.zy + c0.ww;\n"
           "    r1.xyz = floor(hg_TexCoord0.xxx);\n"
           "    r1.xyz = mod(r1.xyz, c1.xxx);\n"
           "    r2.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal0.zw;\n"
           "    r2.xyz = texture2D(hg_Texture0, r2.xy).xyz;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r3.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r3.xy = r3.xy*hg_ProgramLocal0.zw;\n"
           "    r3.xyz = texture2D(hg_Texture0, r3.xy).xyz;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r4.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r4.xy = r4.xy*hg_ProgramLocal0.zw;\n"
           "    r4.xyz = texture2D(hg_Texture0, r4.xy).xyz;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal0.zw;\n"
           "    r0.xyz = texture2D(hg_Texture0, r0.xy).xyz;\n"
           "    r2.xyz = r2.yxz;\n"
           "    r5.yz = r2.yz;\n"
           "    r5.x = r3.x;\n"
           "    r3.xy = r3.zy;\n"
           "    r3.z = r4.x;\n"
           "    r6.yz = r3.yz;\n"
           "    r6.x = r4.y;\n"
           "    r7.xz = r0.xy;\n"
           "    r7.y = r4.z;\n"
           "    r4.yz = r7.yz;\n"
           "    r4.x = r0.z;\n"
           "    r0.xyz = r1.xyz - c1.www;\n"
           "    r4.xyz = vec3(r0.x < 0.00000 ? r7.x : r4.x, r0.y < 0.00000 ? r7.y : r4.y, r0.z < 0.00000 ? r7.z : r4.z);\n"
           "    r0.xyz = r1.xyz - c0.zzz;\n"
           "    r4.xyz = vec3(r0.x < 0.00000 ? r6.x : r4.x, r0.y < 0.00000 ? r6.y : r4.y, r0.z < 0.00000 ? r6.z : r4.z);\n"
           "    r7.xyz = r1.xyz - c2.xxx;\n"
           "    r4.xyz = vec3(r7.x < 0.00000 ? r3.x : r4.x, r7.y < 0.00000 ? r3.y : r4.y, r7.z < 0.00000 ? r3.z : r4.z);\n"
           "    r0.xyz = r1.xyz - c2.yyy;\n"
           "    r4.xyz = vec3(r0.x < 0.00000 ? r5.x : r4.x, r0.y < 0.00000 ? r5.y : r4.y, r0.z < 0.00000 ? r5.z : r4.z);\n"
           "    r1.xyz = r1.xyz - c1.yyy;\n"
           "    r4.xyz = vec3(r1.x < 0.00000 ? r2.x : r4.x, r1.y < 0.00000 ? r2.y : r4.y, r1.z < 0.00000 ? r2.z : r4.z);\n"
           "    r4.w = c1.y;\n"
           "    gl_FragColor = r4;\n"
           "}\n"
           "//MD5=81b6259d:b55db391:9900b607:19b19d79\n"
           "//SIG=00000000:00000000:00000000:00000000:0003:0001:0008:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorGamma_v210_yxzx_rgba_expand::InitProgramDescriptor(HgcColorGamma_v210_yxzx_rgba_expand *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_v210_yxzx_rgba_expand_hgc_visible", "//Metal1.0     \n//LEN=00000007db\n[[ visible ]] FragmentOut HgcColorGamma_v210_yxzx_rgba_expand_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.1666669995, 1.000000000, 4.000000000, 0.5000000000);\n"
    "    const float4 c1 = float4(6.000000000, 1.000000000, 0.000000000, 5.000000000);\n"
    "    const float4 c2 = float4(3.000000000, 2.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy*c0.xy;\n"
    "    r0.xy = floor(r0.xy);\n"
    "    r0.xy = r0.xy*c0.zy + c0.ww;\n"
    "    r1.xyz = floor(texCoord0.xxx);\n"
    "    r1.xyz = r1.xyz - c1.xxx*floor(r1.xyz/c1.xxx);\n"
    "    r2.xy = r0.xy + hg_Params[0].xy;\n"
    "    r2.xy = r2.xy*hg_Params[0].zw;\n"
    "    r2.xyz = hg_Texture0.sample(hg_Sampler0, r2.xy).xyz;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r3.xy = r0.xy + hg_Params[0].xy;\n"
    "    r3.xy = r3.xy*hg_Params[0].zw;\n"
    "    r3.xyz = hg_Texture0.sample(hg_Sampler0, r3.xy).xyz;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r4.xy = r0.xy + hg_Params[0].xy;\n"
    "    r4.xy = r4.xy*hg_Params[0].zw;\n"
    "    r4.xyz = hg_Texture0.sample(hg_Sampler0, r4.xy).xyz;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r0.xy = r0.xy + hg_Params[0].xy;\n"
    "    r0.xy = r0.xy*hg_Params[0].zw;\n"
    "    r0.xyz = hg_Texture0.sample(hg_Sampler0, r0.xy).xyz;\n"
    "    r2.xyz = r2.yxz;\n"
    "    r5.yz = r2.yz;\n"
    "    r5.x = r3.x;\n"
    "    r3.xy = r3.zy;\n"
    "    r3.z = r4.x;\n"
    "    r6.yz = r3.yz;\n"
    "    r6.x = r4.y;\n"
    "    r7.xz = r0.xy;\n"
    "    r7.y = r4.z;\n"
    "    r4.yz = r7.yz;\n"
    "    r4.x = r0.z;\n"
    "    r0.xyz = r1.xyz - c1.www;\n"
    "    r4.xyz = select(r4.xyz, r7.xyz, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz - c0.zzz;\n"
    "    r4.xyz = select(r4.xyz, r6.xyz, r0.xyz < 0.00000f);\n"
    "    r7.xyz = r1.xyz - c2.xxx;\n"
    "    r4.xyz = select(r4.xyz, r3.xyz, r7.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz - c2.yyy;\n"
    "    r4.xyz = select(r4.xyz, r5.xyz, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz - c1.yyy;\n"
    "    r4.xyz = select(r4.xyz, r2.xyz, r1.xyz < 0.00000f);\n"
    "    r4.w = c1.y;\n"
    "    output.color0 = r4;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BD80E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BD8120(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BD8118);
}

double HgcColorGamma_v210_yxzx_rgba_expand::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x30uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3553D00;
  strcpy(v3, "HgcColorGamma_v210_yxzx_rgba_expand [hgc1]");
  return *(double *)"ba_expand [hgc1]";
}

uint64_t HgcColorGamma_v210_yxzx_rgba_expand::BindTexture(HgcColorGamma_v210_yxzx_rgba_expand *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, _QWORD, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 0, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_expand::Bind(HgcColorGamma_v210_yxzx_rgba_expand *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HgcColorGamma_v210_yxzx_rgba_expand *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_expand::RenderTile(HgcColorGamma_v210_yxzx_rgba_expand *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  int v5;
  float32x4_t v6;
  int32x2_t v7;
  uint64_t v8;
  uint64_t v9;
  float32x4_t v10;
  float32x4_t v11;
  uint64_t v12;
  float32x4_t v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  __int32 v24;
  float32x4_t v25;
  int32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  __int32 v29;
  float32x4_t v30;
  float32x4_t v31;
  int32x4_t v32;
  __int32 v33;
  __int32 v34;
  __int32 v35;
  float32x4_t v36;
  float32x4_t v37;
  int32x4_t v38;
  __int32 v39;
  __int32 v40;
  __int32 v41;
  __int32 v42;
  float32x4_t v43;
  int32x4_t v44;
  __int32 v45;
  __int32 v46;
  int32x2_t v47;
  int8x16_t v48;
  float32x4_t v49;
  int8x16_t v50;
  int32x4_t v51;
  int8x16_t v52;
  int8x16_t v53;
  int8x16_t v54;
  int8x16_t v55;
  float32x4_t v56;
  int8x16_t v57;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      v7 = a2[2];
      v8 = 16 * a2[3].i32[0];
      v9 = 16 * v4;
      v10.i64[0] = 0x3F0000003F000000;
      v10.i64[1] = 0x3F0000003F000000;
      v11 = v6;
      do
      {
        v12 = 0;
        v13 = v11;
        do
        {
          v14 = *((_QWORD *)this + 51);
          v15 = *(float32x4_t *)(v14 + 16);
          v16 = vmulq_f32(v13, *(float32x4_t *)v14);
          v17 = vcvtq_f32_s32(vcvtq_s32_f32(v16));
          v18 = vmulq_f32(*(float32x4_t *)(v14 + 48), vsubq_f32(v17, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v17, v16))));
          v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 0);
          v20 = vcvtq_f32_s32(vcvtq_s32_f32(v19));
          v21 = vmulq_f32(*(float32x4_t *)(v14 + 64), vsubq_f32(v20, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v20, v19))));
          v22 = vaddq_f32(*(float32x4_t *)(v14 + 32), v18);
          v23 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
          v24 = a2[11].i32[0];
          v25 = vaddq_f32(vsubq_f32(v22, v6), v10);
          v26 = vcvtq_s32_f32(v25);
          v25.i64[0] = vaddq_s32(v26, vcgtq_f32(vcvtq_f32_s32(v26), v25)).u64[0];
          v27 = *(float32x4_t *)(v14 + 96);
          v28 = *(int8x16_t *)(v14 + 112);
          v29 = v25.i32[1];
          v30 = vaddq_f32(v22, v27);
          v31 = vaddq_f32(vsubq_f32(v30, v6), v10);
          v32 = vcvtq_s32_f32(v31);
          v33 = v25.i32[0];
          v25.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
          v34 = v25.i32[1];
          v35 = v25.i32[0];
          v36 = vaddq_f32(v27, v30);
          v37 = vaddq_f32(vsubq_f32(v36, v6), v10);
          v38 = vcvtq_s32_f32(v37);
          v39 = v33 + v29 * v24;
          v37.i64[0] = vaddq_s32(v38, vcgtq_f32(vcvtq_f32_s32(v38), v37)).u64[0];
          v40 = v37.i32[1];
          v41 = v37.i32[0];
          v42 = v35 + v34 * v24;
          v43 = vaddq_f32(vsubq_f32(vaddq_f32(v27, v36), v6), v10);
          v44 = vcvtq_s32_f32(v43);
          v45 = v41 + v40 * v24;
          v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
          v46 = v43.i32[0] + v43.i32[1] * v24;
          v47 = a2[10];
          v48 = *(int8x16_t *)(*(_QWORD *)&v47 + 16 * v39);
          v49 = vmulq_f32(*(float32x4_t *)(v14 + 80), vsubq_f32(v21, vsubq_f32(v23, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v23, v21)))));
          v50 = *(int8x16_t *)(*(_QWORD *)&v47 + 16 * v42);
          *(int8x8_t *)v23.f32 = vqtbl1_s8(v48, *(int8x8_t *)v28.i8);
          v51 = *(int32x4_t *)(*(_QWORD *)&v47 + 16 * v45);
          *(int8x8_t *)&v23.u32[2] = vqtbl1_s8(v48, (int8x8_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL));
          v52 = *(int8x16_t *)(*(_QWORD *)&v47 + 16 * v46);
          *(int8x8_t *)v27.f32 = vqtbl1_s8(v50, *(int8x8_t *)(v14 + 144));
          v27.i64[1] = *(_QWORD *)(*(_QWORD *)&v47 + 16 * v45);
          v53 = (int8x16_t)vrev64q_s32(v51);
          v54.i64[0] = v52.u32[0];
          v54.i64[1] = v52.u32[1];
          v55 = vbslq_s8(*(int8x16_t *)(v14 + 160), vextq_s8((int8x16_t)v51, (int8x16_t)v51, 4uLL), v54);
          v56 = *(float32x4_t *)(v14 + 192);
          v57 = vbslq_s8((int8x16_t)vcgtq_f32(v56, vsubq_f32(v49, v15)), (int8x16_t)v23, vbslq_s8((int8x16_t)vcgtq_f32(v56, vsubq_f32(v49, *(float32x4_t *)(v14 + 240))), vbslq_s8(*(int8x16_t *)(v14 + 128), v50, (int8x16_t)v23), vbslq_s8((int8x16_t)vcgtq_f32(v56, vsubq_f32(v49, *(float32x4_t *)(v14 + 224))), (int8x16_t)v27, vbslq_s8((int8x16_t)vcgtq_f32(v56, vsubq_f32(v49, *(float32x4_t *)(v14 + 208))), vbslq_s8(*(int8x16_t *)(v14 + 128), v53, (int8x16_t)v27), vbslq_s8((int8x16_t)vcgtq_f32(v56, vsubq_f32(v49, *(float32x4_t *)(v14 + 176))), v55, vbslq_s8(*(int8x16_t *)(v14 + 128), vextq_s8(v52, v52, 8uLL), v55))))));
          v57.i32[3] = 1.0;
          *(int8x16_t *)(*(_QWORD *)&v7 + v12) = v57;
          v13 = vaddq_f32(v13, (float32x4_t)xmmword_1B304F230);
          v12 += 16;
        }
        while (v9 != v12);
        v11 = vaddq_f32(v11, (float32x4_t)xmmword_1B304F240);
        ++v5;
        *(_QWORD *)&v7 += v8;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_expand::GetDOD(HgcColorGamma_v210_yxzx_rgba_expand *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_expand::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcColorGamma_v210_yxzx_rgba_expand::HgcColorGamma_v210_yxzx_rgba_expand(HgcColorGamma_v210_yxzx_rgba_expand *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6544EA8;
  v3 = operator new();
  *(_OWORD *)v3 = xmmword_1B3553E70;
  *(_OWORD *)(v3 + 16) = xmmword_1B3051560;
  *(_OWORD *)(v3 + 32) = xmmword_1B3052100;
  *(_OWORD *)(v3 + 48) = xmmword_1B3553E80;
  *(_OWORD *)(v3 + 64) = xmmword_1B3553E90;
  *(_OWORD *)(v3 + 80) = xmmword_1B3553EA0;
  *(_OWORD *)(v3 + 96) = xmmword_1B304F230;
  *(_OWORD *)(v3 + 112) = xmmword_1B3553CA0;
  *(_OWORD *)(v3 + 128) = xmmword_1B3050E20;
  *(_OWORD *)(v3 + 144) = xmmword_1B3553EB0;
  *(_OWORD *)(v3 + 160) = xmmword_1B3050FF0;
  *(_OWORD *)(v3 + 176) = xmmword_1B3553EC0;
  *(_QWORD *)(v3 + 192) = 0;
  *(_QWORD *)(v3 + 200) = 0;
  *(_OWORD *)(v3 + 208) = xmmword_1B3052960;
  *(_OWORD *)(v3 + 224) = xmmword_1B3052B60;
  *(_OWORD *)(v3 + 240) = xmmword_1B3051520;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcColorGamma_v210_yxzx_rgba_expand *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BD8688(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_v210_yxzx_rgba_expand::~HgcColorGamma_v210_yxzx_rgba_expand(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6544EA8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40104B78CFLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6544EA8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40104B78CFLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6544EA8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40104B78CFLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_v210_yxzx_rgba_expand::SetParameter(HgcColorGamma_v210_yxzx_rgba_expand *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_expand::GetParameter(HgcColorGamma_v210_yxzx_rgba_expand *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcBlur_g4u2_noborder::GetProgram(HgcBlur_g4u2_noborder *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000c4a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    float4 s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord1.xy*hg_Params[4].xy;\n"
             "    s1.xy = s0.xy + frag._texCoord0.xy;\n"
             "    s1.zw = s1.xy + hg_Params[5].xy;\n"
             "    s0.xy = s1.zw + hg_Params[7].xy;\n"
             "    s0.zw = s0.xy*hg_Params[7].zw;\n"
             "    s0.xy = s0.zw + -float2(c0.xx);\n"
             "    s0.xy = s0.xy*hg_Params[8].zw;\n"
             "    s0.xy = abs(s0.xy);\n"
             "    s8.xy = s0.zw*hg_Params[9].xy;\n"
             "    s8.xy = fmax(s8.xy, float2(c0.xy));\n"
             "    s9.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s8.xy = fmin(s8.xy, s9.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s8.xy);\n"
             "    s0.zw = clamp(-s0.xy + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    s0.xy = s1.xy + hg_Params[7].xy;\n"
             "    s0.z = s0.z*s0.w;\n"
             "    s0.xy = s0.xy*hg_Params[7].zw;\n"
             "    s2.xy = s0.xy + -float2(c0.xx);\n"
             "    s2.zw = s2.xy*hg_Params[8].zw;\n"
             "    s2.xy = s1.zw + hg_Params[6].xy;\n"
             "    s3 = float4(r0)*s0.zzzz;\n"
             "    s2.zw = abs(s2.zw);\n"
             "    s2.zw = clamp(-s2.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    s2.xy = s2.xy + hg_Params[7].xy;\n"
             "    s2.xy = s2.xy*hg_Params[7].zw;\n"
             "    s2.z = s2.z*s2.w;\n"
             "    s9.xy = s0.xy*hg_Params[9].xy;\n"
             "    s9.xy = fmax(s9.xy, float2(c0.xy));\n"
             "    s8.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s9.xy = fmin(s9.xy, s8.xy);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s4 = float4(r1)*s2.zzzz + s3;\n"
             "    s2.zw = s1.xy + -hg_Params[6].xy;\n"
             "    s8.xy = s2.xy*hg_Params[9].xy;\n"
             "    s8.xy = fmax(s8.xy, float2(c0.xy));\n"
             "    s9.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s8.xy = fmin(s8.xy, s9.xy);\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, s8.xy);\n"
             "    s2.zw = s2.zw + hg_Params[7].xy;\n"
             "    s2.xy = s2.xy + -float2(c0.xx);\n"
             "    s5.xy = s2.zw*hg_Params[7].zw;\n"
             "    s2.xy = s2.xy*hg_Params[8].zw;\n"
             "    s2.zw = abs(s2.xy);\n"
             "    s2.xy = s5.xy + -float2(c0.xx);\n"
             "    s2.zw = clamp(-s2.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    s2.xy = s2.xy*hg_Params[8].zw;\n"
             "    s5.zw = abs(s2.xy);\n"
             "    s2.z = s2.z*s2.w;\n"
             "    s2 = float4(r2)*s2.zzzz;\n"
             "    s9.xy = s5.xy*hg_Params[9].xy;\n"
             "    s9.xy = fmax(s9.xy, float2(c0.xy));\n"
             "    s8.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s9.xy = fmin(s9.xy, s8.xy);\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s5.zw = clamp(-s5.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    s5.x = s5.z*s5.w;\n"
             "    s2 = float4(r2)*s5.xxxx + s2;\n"
             "    r2 = half4(hg_Params[0]);\n"
             "    r3 = half4(hg_Params[1]);\n"
             "    s1.xy = floor(s1.xy);\n"
             "    s1.zw = floor(s1.zw);\n"
             "    s1.xy = s1.zw + -s1.xy;\n"
             "    s1.x = s1.x + s1.y;\n"
             "    r3 = -r3 + half4(hg_Params[3]);\n"
             "    s6 = s1.xxxx*float4(r3) + hg_Params[1];\n"
             "    r2 = -r2 + half4(hg_Params[2]);\n"
             "    s2 = s2*s6;\n"
             "    s7 = s1.xxxx*float4(r2) + hg_Params[0];\n"
             "    output.color0 = s4*s7 + s2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5c82e3c7:07ba83f7:2ad9cba3:69e3d725\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:000a:000e:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000b5b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord1.xy*hg_Params[4].xy;\n"
             "    r4.xy = r0.xy + frag._texCoord0.xy;\n"
             "    r4.zw = r4.xy + hg_Params[5].xy;\n"
             "    r0.xy = r4.zw + hg_Params[7].xy;\n"
             "    r0.zw = r0.xy*hg_Params[7].zw;\n"
             "    r0.xy = r0.zw + -c0.xx;\n"
             "    r0.xy = r0.xy*hg_Params[8].zw;\n"
             "    r0.xy = abs(r0.xy);\n"
             "    r5.xy = r0.zw*hg_Params[9].xy;\n"
             "    r5.xy = fmax(r5.xy, c0.xy);\n"
             "    r6.xy = hg_Params[9].xy - c0.xy;\n"
             "    r5.xy = fmin(r5.xy, r6.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
             "    r0.zw = clamp(-r0.xy + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    r0.xy = r4.xy + hg_Params[7].xy;\n"
             "    r0.z = r0.z*r0.w;\n"
             "    r0.xy = r0.xy*hg_Params[7].zw;\n"
             "    r2.xy = r0.xy + -c0.xx;\n"
             "    r2.zw = r2.xy*hg_Params[8].zw;\n"
             "    r2.xy = r4.zw + hg_Params[6].xy;\n"
             "    r1 = r1*r0.zzzz;\n"
             "    r2.zw = abs(r2.zw);\n"
             "    r2.zw = clamp(-r2.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    r2.xy = r2.xy + hg_Params[7].xy;\n"
             "    r2.xy = r2.xy*hg_Params[7].zw;\n"
             "    r2.z = r2.z*r2.w;\n"
             "    r6.xy = r0.xy*hg_Params[9].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r5.xy = hg_Params[9].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r5.xy);\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r0 = r0*r2.zzzz + r1;\n"
             "    r2.zw = r4.xy + -hg_Params[6].xy;\n"
             "    r5.xy = r2.xy*hg_Params[9].xy;\n"
             "    r5.xy = fmax(r5.xy, c0.xy);\n"
             "    r6.xy = hg_Params[9].xy - c0.xy;\n"
             "    r5.xy = fmin(r5.xy, r6.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
             "    r2.zw = r2.zw + hg_Params[7].xy;\n"
             "    r2.xy = r2.xy + -c0.xx;\n"
             "    r3.xy = r2.zw*hg_Params[7].zw;\n"
             "    r2.xy = r2.xy*hg_Params[8].zw;\n"
             "    r2.zw = abs(r2.xy);\n"
             "    r2.xy = r3.xy + -c0.xx;\n"
             "    r2.zw = clamp(-r2.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    r2.xy = r2.xy*hg_Params[8].zw;\n"
             "    r3.zw = abs(r2.xy);\n"
             "    r2.z = r2.z*r2.w;\n"
             "    r2 = r1*r2.zzzz;\n"
             "    r6.xy = r3.xy*hg_Params[9].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r5.xy = hg_Params[9].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r5.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r3.zw = clamp(-r3.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    r3.x = r3.z*r3.w;\n"
             "    r2 = r1*r3.xxxx + r2;\n"
             "    r1 = hg_Params[0];\n"
             "    r3 = hg_Params[1];\n"
             "    r4.xy = floor(r4.xy);\n"
             "    r4.zw = floor(r4.zw);\n"
             "    r4.xy = r4.zw + -r4.xy;\n"
             "    r4.x = r4.x + r4.y;\n"
             "    r3 = -r3 + hg_Params[3];\n"
             "    r3 = r4.xxxx*r3 + hg_Params[1];\n"
             "    r1 = -r1 + hg_Params[2];\n"
             "    r2 = r2*r3;\n"
             "    r1 = r4.xxxx*r1 + hg_Params[0];\n"
             "    output.color0 = r0*r1 + r2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bc2fcd6f:3857ab61:c84a8e17:e752aad0\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:000a:0007:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000bec\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "uniform highp vec4 hg_ProgramLocal7;\n"
           "uniform highp vec4 hg_ProgramLocal8;\n"
           "uniform highp vec4 hg_ProgramLocal9;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    const highp vec4 c1 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0.xy = hg_TexCoord1.xy*hg_ProgramLocal4.xy;\n"
           "    r4.xy = r0.xy + hg_TexCoord0.xy;\n"
           "    r4.zw = r4.xy + hg_ProgramLocal5.xy;\n"
           "    r0.xy = r4.zw + hg_ProgramLocal7.xy;\n"
           "    r0.zw = r0.xy*hg_ProgramLocal7.zw;\n"
           "    r0.xy = r0.zw + -c0.xx;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal8.zw;\n"
           "    r0.xy = abs(r0.xy);\n"
           "    r5.xy = hg_ProgramLocal9.xy*c1.xy + r0.zw;\n"
           "    r1 = texture2D(hg_Texture0, r5.xy);\n"
           "    r0.zw = clamp(-r0.xy + hg_ProgramLocal8.xy, vec2(0.00000), vec2(1.00000));\n"
           "    r0.xy = r4.xy + hg_ProgramLocal7.xy;\n"
           "    r0.z = r0.z*r0.w;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal7.zw;\n"
           "    r2.xy = r0.xy + -c0.xx;\n"
           "    r2.zw = r2.xy*hg_ProgramLocal8.zw;\n"
           "    r2.xy = r4.zw + hg_ProgramLocal6.xy;\n"
           "    r1 = r1*r0.zzzz;\n"
           "    r2.zw = abs(r2.zw);\n"
           "    r2.zw = clamp(-r2.zw + hg_ProgramLocal8.xy, vec2(0.00000), vec2(1.00000));\n"
           "    r2.xy = r2.xy + hg_ProgramLocal7.xy;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal7.zw;\n"
           "    r2.z = r2.z*r2.w;\n"
           "    r5.xy = hg_ProgramLocal9.xy*c1.xy + r0.xy;\n"
           "    r0 = texture2D(hg_Texture0, r5.xy);\n"
           "    r0 = r0*r2.zzzz + r1;\n"
           "    r2.zw = r4.xy + -hg_ProgramLocal6.xy;\n"
           "    r5.xy = hg_ProgramLocal9.xy*c1.xy + r2.xy;\n"
           "    r1 = texture2D(hg_Texture0, r5.xy);\n"
           "    r2.zw = r2.zw + hg_ProgramLocal7.xy;\n"
           "    r2.xy = r2.xy + -c0.xx;\n"
           "    r3.xy = r2.zw*hg_ProgramLocal7.zw;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal8.zw;\n"
           "    r2.zw = abs(r2.xy);\n"
           "    r2.xy = r3.xy + -c0.xx;\n"
           "    r2.zw = clamp(-r2.zw + hg_ProgramLocal8.xy, vec2(0.00000), vec2(1.00000));\n"
           "    r2.xy = r2.xy*hg_ProgramLocal8.zw;\n"
           "    r3.zw = abs(r2.xy);\n"
           "    r2.z = r2.z*r2.w;\n"
           "    r2 = r1*r2.zzzz;\n"
           "    r5.xy = hg_ProgramLocal9.xy*c1.xy + r3.xy;\n"
           "    r1 = texture2D(hg_Texture0, r5.xy);\n"
           "    r3.zw = clamp(-r3.zw + hg_ProgramLocal8.xy, vec2(0.00000), vec2(1.00000));\n"
           "    r3.x = r3.z*r3.w;\n"
           "    r2 = r1*r3.xxxx + r2;\n"
           "    r1 = hg_ProgramLocal0;\n"
           "    r3 = hg_ProgramLocal1;\n"
           "    r4.xy = floor(r4.xy);\n"
           "    r4.zw = floor(r4.zw);\n"
           "    r4.xy = r4.zw + -r4.xy;\n"
           "    r4.x = r4.x + r4.y;\n"
           "    r3 = -r3 + hg_ProgramLocal3;\n"
           "    r3 = r4.xxxx*r3 + hg_ProgramLocal1;\n"
           "    r1 = -r1 + hg_ProgramLocal2;\n"
           "    r2 = r2*r3;\n"
           "    r1 = r4.xxxx*r1 + hg_ProgramLocal0;\n"
           "    gl_FragColor = r0*r1 + r2;\n"
           "}\n"
           "//MD5=a34df5a0:4fe9daf3:c474f320:d4b51f6c\n"
           "//SIG=00000000:00000000:00000000:00000000:0002:000a:0006:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcBlur_g4u2_noborder::InitProgramDescriptor(HgcBlur_g4u2_noborder *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlur_g4u2_noborder_hgc_visible", "//Metal1.0     \n//LEN=0000000ab3\n[[ visible ]] FragmentOut HgcBlur_g4u2_noborder_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord1.xy*hg_Params[4].xy;\n"
    "    r4.xy = r0.xy + texCoord0.xy;\n"
    "    r4.zw = r4.xy + hg_Params[5].xy;\n"
    "    r0.xy = r4.zw + hg_Params[7].xy;\n"
    "    r0.zw = r0.xy*hg_Params[7].zw;\n"
    "    r0.xy = r0.zw + -c0.xx;\n"
    "    r0.xy = r0.xy*hg_Params[8].zw;\n"
    "    r0.xy = abs(r0.xy);\n"
    "    r5.xy = r0.zw*hg_Params[9].xy;\n"
    "    r5.xy = fmax(r5.xy, c0.xy);\n"
    "    r6.xy = hg_Params[9].xy - c0.xy;\n"
    "    r5.xy = fmin(r5.xy, r6.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
    "    r0.zw = clamp(-r0.xy + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
    "    r0.xy = r4.xy + hg_Params[7].xy;\n"
    "    r0.z = r0.z*r0.w;\n"
    "    r0.xy = r0.xy*hg_Params[7].zw;\n"
    "    r2.xy = r0.xy + -c0.xx;\n"
    "    r2.zw = r2.xy*hg_Params[8].zw;\n"
    "    r2.xy = r4.zw + hg_Params[6].xy;\n"
    "    r1 = r1*r0.zzzz;\n"
    "    r2.zw = abs(r2.zw);\n"
    "    r2.zw = clamp(-r2.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
    "    r2.xy = r2.xy + hg_Params[7].xy;\n"
    "    r2.xy = r2.xy*hg_Params[7].zw;\n"
    "    r2.z = r2.z*r2.w;\n"
    "    r6.xy = r0.xy*hg_Params[9].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r5.xy = hg_Params[9].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r5.xy);\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r0 = r0*r2.zzzz + r1;\n"
    "    r2.zw = r4.xy + -hg_Params[6].xy;\n"
    "    r5.xy = r2.xy*hg_Params[9].xy;\n"
    "    r5.xy = fmax(r5.xy, c0.xy);\n"
    "    r6.xy = hg_Params[9].xy - c0.xy;\n"
    "    r5.xy = fmin(r5.xy, r6.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
    "    r2.zw = r2.zw + hg_Params[7].xy;\n"
    "    r2.xy = r2.xy + -c0.xx;\n"
    "    r3.xy = r2.zw*hg_Params[7].zw;\n"
    "    r2.xy = r2.xy*hg_Params[8].zw;\n"
    "    r2.zw = abs(r2.xy);\n"
    "    r2.xy = r3.xy + -c0.xx;\n"
    "    r2.zw = clamp(-r2.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
    "    r2.xy = r2.xy*hg_Params[8].zw;\n"
    "    r3.zw = abs(r2.xy);\n"
    "    r2.z = r2.z*r2.w;\n"
    "    r2 = r1*r2.zzzz;\n"
    "    r6.xy = r3.xy*hg_Params[9].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r5.xy = hg_Params[9].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r5.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r3.zw = clamp(-r3.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
    "    r3.x = r3.z*r3.w;\n"
    "    r2 = r1*r3.xxxx + r2;\n"
    "    r1 = hg_Params[0];\n"
    "    r3 = hg_Params[1];\n"
    "    r4.xy = floor(r4.xy);\n"
    "    r4.zw = floor(r4.zw);\n"
    "    r4.xy = r4.zw + -r4.xy;\n"
    "    r4.x = r4.x + r4.y;\n"
    "    r3 = -r3 + hg_Params[3];\n"
    "    r3 = r4.xxxx*r3 + hg_Params[1];\n"
    "    r1 = -r1 + hg_Params[2];\n"
    "    r2 = r2*r3;\n"
    "    r1 = r4.xxxx*r1 + hg_Params[0];\n"
    "    output.color0 = r0*r1 + r2;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BD8BF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BD8C2C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BD8C24);
}

double HgcBlur_g4u2_noborder::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552E10;
  strcpy(v3, "HgcBlur_g4u2_noborder [hgc1]");
  return *(double *)"_noborder [hgc1]";
}

uint64_t HgcBlur_g4u2_noborder::BindTexture(HgcBlur_g4u2_noborder *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 9, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcBlur_g4u2_noborder::Bind(HgcBlur_g4u2_noborder *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 6, *((_QWORD *)this + 51) + 96, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 7, *((_QWORD *)this + 51) + 112, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 8, *((_QWORD *)this + 51) + 128, 1);
  (*(void (**)(HgcBlur_g4u2_noborder *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBlur_g4u2_noborder::RenderTile(HgcBlur_g4u2_noborder *this, int32x2_t *a2)
{
  uint64_t v4;
  int v5;
  int32x2_t v6;
  int v7;
  int v8;
  int v9;
  float32x2_t v10;
  float32x2_t v16;
  float32x4_t v17;
  float32x2_t v18;
  int32x2_t v19;
  uint64_t v20;
  uint64_t v21;
  float32x4_t v22;
  uint64_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int32x2_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x2_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  int8x16_t v40;
  int8x16_t v41;
  float32x4_t v42;
  int8x16_t v43;
  float32x4_t v44;
  float32x4_t v45;
  uint64_t v46;
  int8x16_t v47;
  int8x16_t v48;
  float32x2_t v49;
  int8x16_t v50;
  float32x4_t v51;
  float32x2_t v52;
  int32x2_t v53;
  uint64_t v54;
  float32x2_t v55;
  float32x2_t v56;
  int32x2_t v57;
  float32x2_t v58;
  float32x4_t *v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x2_t v63;
  float32x2_t v64;
  int32x2_t v65;
  float32x2_t v66;
  float32x4_t *v67;
  float32x4_t v68;
  float32x4_t v69;
  int32x2_t v70;
  int32x2_t v71;
  int8x16_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x2_t v76;
  float32x2_t v77;
  int32x2_t v78;
  float32x2_t v79;
  float32x4_t *v80;
  float32x4_t v81;
  float32x4_t v82;
  int32x2_t v83;
  float32x2_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int8x16_t v87;
  float32x2_t v88;
  float32x2_t v89;
  int32x2_t v90;
  float32x2_t v91;
  float32x4_t *v92;
  float32x4_t v93;

  v4 = HGTile::Renderer((HGTile *)a2);
  v5 = (*(uint64_t (**)(HgcBlur_g4u2_noborder *, uint64_t))(*(_QWORD *)this + 312))(this, v4);
  v6 = *a2;
  v7 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v7 >= 1)
  {
    v8 = a2[1].i32[0] - v6.i32[0];
    if (v8 >= 1)
    {
      v9 = 0;
      v10 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
      __asm { FMOV            V3.2S, #-1.0 }
      v16 = vadd_f32(v10, _D3);
      *(float32x2_t *)v17.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
      v17.i64[1] = 0x3F80000000000000;
      v18 = vadd_f32(v16, _D3);
      v19 = a2[2];
      v20 = 16 * a2[3].i32[0];
      v21 = 16 * v8;
      v22 = v17;
      do
      {
        v23 = 0;
        v24 = v17;
        v25 = v22;
        do
        {
          v46 = *((_QWORD *)this + 51);
          v47 = (int8x16_t)vaddq_f32(v24, vmulq_f32(v25, *(float32x4_t *)(v46 + 64)));
          v48 = (int8x16_t)vdupq_lane_s64(vaddq_f32(*(float32x4_t *)(v46 + 80), (float32x4_t)v47).i64[0], 0);
          v49 = (float32x2_t)vextq_s8(v48, v48, 8uLL).u64[0];
          v50 = *(int8x16_t *)(v46 + 112);
          v51 = (float32x4_t)vextq_s8(v50, v50, 8uLL);
          v52 = vmul_f32(*(float32x2_t *)v51.f32, vadd_f32(*(float32x2_t *)v50.i8, v49));
          v53 = a2[10];
          v54 = a2[11].i32[0];
          v55 = vmul_f32(v10, v52);
          if (v5)
          {
            v56 = vmin_f32(vmax_f32(vadd_f32(v55, (float32x2_t)0xBF000000BF000000), 0), v16);
            v57 = vcvt_s32_f32(vmin_f32(v56, v18));
            v58 = vsub_f32(v56, vcvt_f32_s32(v57));
            v59 = (float32x4_t *)(*(_QWORD *)&v53 + 16 * (v57.i32[0] + v57.i32[1] * (int)v54));
            v60 = vaddq_f32(*v59, vmulq_n_f32(vsubq_f32(v59[1], *v59), v58.f32[0]));
            v61 = vaddq_f32(v60, vmulq_lane_f32(vsubq_f32(vaddq_f32(v59[v54], vmulq_n_f32(vsubq_f32(v59[(int)v54 + 1], v59[v54]), v58.f32[0])), v60), v58, 1));
            v62.i64[1] = v48.i64[1];
            v62.i64[0] = v47.i64[0];
            v63 = vmul_f32(*(float32x2_t *)v51.f32, vadd_f32(*(float32x2_t *)v50.i8, *(float32x2_t *)v47.i8));
            v64 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, v63), (float32x2_t)0xBF000000BF000000), 0), v16);
            v65 = vcvt_s32_f32(vmin_f32(v64, v18));
            v66 = vsub_f32(v64, vcvt_f32_s32(v65));
            v67 = (float32x4_t *)(*(_QWORD *)&v53 + 16 * (v65.i32[0] + v65.i32[1] * (int)v54));
            v68 = vaddq_f32(*v67, vmulq_n_f32(vsubq_f32(v67[1], *v67), v66.f32[0]));
            v69 = vaddq_f32(v68, vmulq_lane_f32(vsubq_f32(vaddq_f32(v67[v54], vmulq_n_f32(vsubq_f32(v67[(int)v54 + 1], v67[v54]), v66.f32[0])), v68), v66, 1));
          }
          else
          {
            v70 = vcvt_s32_f32(vmin_f32(vmax_f32(v55, 0), v16));
            v61 = *(float32x4_t *)(*(_QWORD *)&v53 + 16 * (v70.i32[0] + v70.i32[1] * (int)v54));
            v62.i64[1] = v48.i64[1];
            v62.i64[0] = v47.i64[0];
            v63 = vmul_f32(*(float32x2_t *)v51.f32, vadd_f32(*(float32x2_t *)v50.i8, *(float32x2_t *)v47.i8));
            v71 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, v63), 0), v16));
            v69 = *(float32x4_t *)(*(_QWORD *)&v53 + 16 * (v71.i32[0] + v71.i32[1] * (int)v54));
          }
          v72 = vextq_s8(v48, v47, 8uLL);
          v73 = *(float32x4_t *)(v46 + 96);
          v74 = vaddq_f32((float32x4_t)v72, v73);
          v75 = vmulq_f32(v51, vaddq_f32((float32x4_t)v50, v74));
          v76 = vmul_f32(v10, *(float32x2_t *)v75.f32);
          if (v5)
          {
            v77 = vmin_f32(vmax_f32(vadd_f32(v76, (float32x2_t)0xBF000000BF000000), 0), v16);
            v78 = vcvt_s32_f32(vmin_f32(v77, v18));
            v79 = vsub_f32(v77, vcvt_f32_s32(v78));
            v80 = (float32x4_t *)(*(_QWORD *)&v53 + 16 * (v78.i32[0] + v78.i32[1] * (int)v54));
            v81 = vaddq_f32(*v80, vmulq_n_f32(vsubq_f32(v80[1], *v80), v79.f32[0]));
            v82 = vaddq_f32(v81, vmulq_lane_f32(vsubq_f32(vaddq_f32(v80[v54], vmulq_n_f32(vsubq_f32(v80[(int)v54 + 1], v80[v54]), v79.f32[0])), v81), v79, 1));
          }
          else
          {
            v83 = vcvt_s32_f32(vmin_f32(vmax_f32(v76, 0), v16));
            v82 = *(float32x4_t *)(*(_QWORD *)&v53 + 16 * (v83.i32[0] + v83.i32[1] * (int)v54));
          }
          v84 = vsub_f32((float32x2_t)*(_OWORD *)&vextq_s8(v72, v72, 8uLL), *(float32x2_t *)v73.f32);
          v85.i64[0] = v75.i64[0];
          *(float32x2_t *)&v85.u32[2] = v84;
          v86 = *(float32x4_t *)(v46 + 176);
          v87 = (int8x16_t)vaddq_f32(v86, v75);
          *(float32x2_t *)v51.f32 = vmul_f32(*(float32x2_t *)v51.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)vaddq_f32(v51, v85), v87, 8uLL));
          v88 = vmul_f32(v10, *(float32x2_t *)v51.f32);
          if (v5)
          {
            v89 = vmin_f32(vmax_f32(vadd_f32(v88, (float32x2_t)0xBF000000BF000000), 0), v16);
            v90 = vcvt_s32_f32(vmin_f32(v89, v18));
            v91 = vsub_f32(v89, vcvt_f32_s32(v90));
            v92 = (float32x4_t *)(*(_QWORD *)&v53 + 16 * (v90.i32[0] + v90.i32[1] * (int)v54));
            v93 = vaddq_f32(*v92, vmulq_n_f32(vsubq_f32(v92[1], *v92), v91.f32[0]));
            v27 = vaddq_f32(v93, vmulq_lane_f32(vsubq_f32(vaddq_f32(v92[v54], vmulq_n_f32(vsubq_f32(v92[(int)v54 + 1], v92[v54]), v91.f32[0])), v93), v91, 1));
          }
          else
          {
            v26 = vcvt_s32_f32(vmin_f32(vmax_f32(v88, 0), v16));
            v27 = *(float32x4_t *)(*(_QWORD *)&v53 + 16 * (v26.i32[0] + v26.i32[1] * (int)v54));
          }
          v28 = *(float32x4_t *)(v46 + 144);
          v29 = (float32x4_t)vextq_s8(*(int8x16_t *)(v46 + 128), *(int8x16_t *)(v46 + 128), 8uLL);
          *(int8x8_t *)v30.f32 = vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v29.f32, vadd_f32(*(float32x2_t *)v28.f32, v52)), *(int8x8_t *)(v46 + 160));
          *(float32x2_t *)&v30.u32[2] = v52;
          v31 = (int8x16_t)vnegq_f32(v30);
          v32 = vminq_f32(vmaxq_f32(vaddq_f32(v29, (float32x4_t)vextq_s8(v31, v31, 8uLL)), v28), v86);
          v33 = vmulq_laneq_f32(v61, vmulq_laneq_f32(v32, v32, 3), 2);
          *(int8x8_t *)&v74.u32[2] = vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v29.f32, vadd_f32(*(float32x2_t *)v86.f32, v63)), *(int8x8_t *)(v46 + 200));
          v34 = vminq_f32(vmaxq_f32(vsubq_f32(v29, v74), v28), v86);
          v35 = vaddq_f32(v33, vmulq_laneq_f32(v69, vmulq_laneq_f32(v34, v34, 3), 2));
          *(float32x2_t *)v34.f32 = vadd_f32(*(float32x2_t *)v86.f32, *(float32x2_t *)v51.f32);
          v36 = vmul_f32(*(float32x2_t *)v29.f32, *(float32x2_t *)v34.f32);
          *(float32x2_t *)&v34.u32[2] = vabs_f32(vmul_f32(*(float32x2_t *)v29.f32, *(float32x2_t *)v87.i8));
          v37 = vminq_f32(vmaxq_f32(vsubq_f32(v29, v34), v28), v86);
          *(float32x2_t *)&v51.u32[2] = vabs_f32(v36);
          v38 = vminq_f32(vmaxq_f32(vsubq_f32(v29, v51), v28), v86);
          v39 = vcvtq_f32_s32(vcvtq_s32_f32(v62));
          v40 = *(int8x16_t *)(v46 + 208);
          v41 = (int8x16_t)vsubq_f32(v39, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v39, v62), v40, (int8x16_t)0));
          v39.i64[0] = v41.i64[0];
          *(float32x2_t *)&v39.u32[2] = v49;
          v42 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
          v43 = (int8x16_t)vsubq_f32(v42, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v42, v39), v40, (int8x16_t)0));
          v44 = (float32x4_t)vextq_s8(v43, v41, 8uLL);
          v41.i64[1] = v43.i64[1];
          v45 = vsubq_f32(v44, (float32x4_t)v41);
          v45.i32[0] = vaddq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1)).u32[0];
          *(float32x4_t *)(*(_QWORD *)&v19 + v23) = vaddq_f32(vmulq_f32(v35, vaddq_f32(*(float32x4_t *)v46, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v46 + 32), *(float32x4_t *)v46), v45.f32[0]))), vmulq_f32(vaddq_f32(vmulq_laneq_f32(v82, vmulq_laneq_f32(v37, v37, 3), 2), vmulq_n_f32(v27, vmulq_laneq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 3), v38, 2).f32[0])), vaddq_f32(*(float32x4_t *)(v46 + 16), vmulq_n_f32(
                                                            vsubq_f32(*(float32x4_t *)(v46 + 48), *(float32x4_t *)(v46 + 16)), v45.f32[0]))));
          v24 = vaddq_f32(v24, (float32x4_t)xmmword_1B304F230);
          v25 = vaddq_f32(v25, (float32x4_t)xmmword_1B304F230);
          v23 += 16;
        }
        while (v21 != v23);
        v17 = vaddq_f32(v17, (float32x4_t)xmmword_1B304F240);
        v22 = vaddq_f32(v22, (float32x4_t)xmmword_1B304F240);
        ++v9;
        *(_QWORD *)&v19 += v20;
      }
      while (v9 != v7);
    }
  }
  return 0;
}

uint64_t HgcBlur_g4u2_noborder::GetDOD(HgcBlur_g4u2_noborder *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcBlur_g4u2_noborder::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcBlur_g4u2_noborder::HgcBlur_g4u2_noborder(HgcBlur_g4u2_noborder *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6545110;
  v3 = (_OWORD *)operator new();
  v3[6] = 0u;
  v3[7] = 0u;
  v3[4] = 0u;
  v3[5] = 0u;
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  v3[8] = 0u;
  v3[9] = xmmword_1B3553F00;
  v3[10] = xmmword_1B3553F10;
  v3[11] = xmmword_1B3553F20;
  __asm { FMOV            V1.4S, #1.0 }
  v3[12] = xmmword_1B3052C50;
  v3[13] = _Q1;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcBlur_g4u2_noborder *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 5);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BD94F4(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBlur_g4u2_noborder::~HgcBlur_g4u2_noborder(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6545110;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C405DF52C91);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6545110;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C405DF52C91);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6545110;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C405DF52C91);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBlur_g4u2_noborder::SetParameter(HgcBlur_g4u2_noborder *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 8)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlur_g4u2_noborder::GetParameter(HgcBlur_g4u2_noborder *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 8)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcColorGamma_2vuy_xyxz_expand::GetProgram(HgcColorGamma_2vuy_xyxz_expand *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003fa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord0.xy*float2(c0.xy);\n"
             "    s0.xy = floor(s0.xy);\n"
             "    s0.xy = s0.xy + float2(c0.xx);\n"
             "    s0.xy = s0.xy + hg_Params[0].xy;\n"
             "    s0.xy = s0.xy*hg_Params[0].zw;\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s0.xy);\n"
             "    s0.x = float(fract(0.500000f*frag._texCoord0.x) >= 0.500000f);\n"
             "    r1 = half4(r0.z, r0.y, r0.w, 1.00000h);\n"
             "    s1.yzw = float3(r1.yzw);\n"
             "    s1.x = select(float(r1.x), float(r0.x), -s0.x < 0.00000h);\n"
             "    output.color0 = s1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e2f1359f:d962dc38:6d45378e:c9de3178\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0001:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003ad\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy*c0.xy;\n"
             "    r0.xy = floor(r0.xy);\n"
             "    r0.xy = r0.xy + c0.xx;\n"
             "    r0.xy = r0.xy + hg_Params[0].xy;\n"
             "    r0.xy = r0.xy*hg_Params[0].zw;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r1.x = float(fract(0.500000f*frag._texCoord0.x) >= 0.500000f);\n"
             "    r2 = float4(r0.z, r0.y, r0.w, 1.00000f);\n"
             "    r2.x = select(r2.x, r0.x, -r1.x < 0.00000f);\n"
             "    output.color0 = r2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9c2db72b:e94c7326:0f4dea4f:07e48d03\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000386\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy*c0.xy;\n"
           "    r0.xy = floor(r0.xy);\n"
           "    r0.xy = r0.xy + c0.xx;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal0.zw;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r1.x = c0.x*hg_TexCoord0.x;\n"
           "    r1.x = fract(r1.x);\n"
           "    r1.x = float(r1.x >= c0.x);\n"
           "    r2 = vec4(r0.z, r0.y, r0.w, 1.00000);\n"
           "    r2.x = -r1.x < 0.00000 ? r0.x : r2.x;\n"
           "    gl_FragColor = r2;\n"
           "}\n"
           "//MD5=10673228:1a421a4c:e2f1387f:08423341\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorGamma_2vuy_xyxz_expand::InitProgramDescriptor(HgcColorGamma_2vuy_xyxz_expand *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_2vuy_xyxz_expand_hgc_visible", "//Metal1.0     \n//LEN=00000002f8\n[[ visible ]] FragmentOut HgcColorGamma_2vuy_xyxz_expand_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy*c0.xy;\n"
    "    r0.xy = floor(r0.xy);\n"
    "    r0.xy = r0.xy + c0.xx;\n"
    "    r0.xy = r0.xy + hg_Params[0].xy;\n"
    "    r0.xy = r0.xy*hg_Params[0].zw;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r1.x = float(fract(0.500000f*texCoord0.x) >= 0.500000f);\n"
    "    r2 = float4(r0.z, r0.y, r0.w, 1.00000f);\n"
    "    r2.x = select(r2.x, r0.x, -r1.x < 0.00000f);\n"
    "    output.color0 = r2;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BD9A80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BD9AB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BD9AB0);
}

char *HgcColorGamma_2vuy_xyxz_expand::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A20;
  strcpy(result, "HgcColorGamma_2vuy_xyxz_expand [hgc1]");
  return result;
}

uint64_t HgcColorGamma_2vuy_xyxz_expand::BindTexture(HgcColorGamma_2vuy_xyxz_expand *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, _QWORD, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 0, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcColorGamma_2vuy_xyxz_expand::Bind(HgcColorGamma_2vuy_xyxz_expand *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HgcColorGamma_2vuy_xyxz_expand *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcColorGamma_2vuy_xyxz_expand::RenderTile(HgcColorGamma_2vuy_xyxz_expand *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  int32x2_t v7;
  uint64_t v8;
  float32x4_t v9;
  float32x4_t v10;
  uint64_t v11;
  int v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  uint64_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  __int32 v29;
  float32x4_t v30;
  int32x4_t v31;
  __int32 v32;
  float32x4_t v33;
  int32x4_t v34;
  __int32 v35;
  __int32 v36;
  __int32 v37;
  __int32 v38;
  float32x4_t v39;
  int32x4_t v40;
  __int32 v41;
  __int32 v42;
  int32x2_t v43;
  int8x16_t v44;
  float32x4_t v45;
  int8x16_t v46;
  float32x4_t v47;
  float32x4_t v48;
  int8x16_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  int8x16_t v53;
  int8x16_t v54;
  int8x16_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int8x16_t v59;
  float32x4_t v60;
  int8x16_t *v61;
  uint64_t v62;
  int8x16_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int8x16_t v67;
  float32x4_t v68;
  float32x4_t v69;
  int32x4_t v70;
  __int32 v71;
  float32x4_t v72;
  float32x4_t v73;
  int8x16_t v74;
  int8x16_t v75;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = a2[2];
    v8 = 16 * a2[3].i32[0];
    v9.i64[0] = 0x3F0000003F000000;
    v9.i64[1] = 0x3F0000003F000000;
    v10 = v5;
    while (v6 < 3)
    {
      v11 = 0;
      v13 = v10;
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      v10 = vaddq_f32(v10, (float32x4_t)xmmword_1B304F240);
      ++v4;
      *(_QWORD *)&v7 += v8;
      if (v4 == v3)
        return 0;
    }
    v11 = 0;
    v12 = v6;
    v13 = v10;
    do
    {
      v14 = vaddq_f32(v13, (float32x4_t)xmmword_1B304F230);
      v15 = vaddq_f32(v14, (float32x4_t)xmmword_1B304F230);
      v16 = *((_QWORD *)this + 51);
      v17 = *(int8x16_t *)(v16 + 16);
      v18 = vmulq_f32(v13, *(float32x4_t *)v16);
      v19 = vmulq_f32(v14, *(float32x4_t *)v16);
      v20 = vmulq_f32(v15, *(float32x4_t *)v16);
      v21 = vcvtq_f32_s32(vcvtq_s32_f32(v18));
      v22 = vcvtq_f32_s32(vcvtq_s32_f32(v19));
      v23 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
      v24 = vsubq_f32(v21, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v21, v18)));
      v25 = vsubq_f32(v22, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v22, v19)));
      v26 = vsubq_f32(v23, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v23, v20)));
      v27 = *(float32x4_t *)(v16 + 32);
      v28 = *(int8x16_t *)(v16 + 48);
      v29 = a2[11].i32[0];
      v30 = vaddq_f32(vsubq_f32(vaddq_f32(v27, v24), v5), v9);
      v31 = vcvtq_s32_f32(v30);
      v30.i64[0] = vaddq_s32(v31, vcgtq_f32(vcvtq_f32_s32(v31), v30)).u64[0];
      v32 = v30.i32[1];
      v33 = vaddq_f32(vsubq_f32(vaddq_f32(v27, v25), v5), v9);
      v34 = vcvtq_s32_f32(v33);
      v35 = v30.i32[0];
      v30.i64[0] = vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v33)).u64[0];
      v36 = v30.i32[1];
      v37 = v35 + v32 * v29;
      v38 = v30.i32[0];
      v39 = vaddq_f32(vsubq_f32(vaddq_f32(v27, v26), v5), v9);
      v40 = vcvtq_s32_f32(v39);
      v41 = v38 + v36 * v29;
      v39.i64[0] = vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)).u64[0];
      v42 = v39.i32[0] + v39.i32[1] * v29;
      v43 = a2[10];
      v44 = *(int8x16_t *)(*(_QWORD *)&v43 + 16 * v37);
      v45 = vmulq_f32(v13, v27);
      v46 = *(int8x16_t *)(*(_QWORD *)&v43 + 16 * v41);
      v47 = vmulq_f32(v14, v27);
      v48 = vmulq_f32(v15, v27);
      v49 = *(int8x16_t *)(*(_QWORD *)&v43 + 16 * v42);
      v50 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      v51 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      v52 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
      v53 = (int8x16_t)vcgeq_f32(vsubq_f32(v45, vsubq_f32(v50, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v50, v45)))), v27);
      v54 = (int8x16_t)vcgeq_f32(vsubq_f32(v47, vsubq_f32(v51, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v51, v47)))), v27);
      v55 = (int8x16_t)vcgeq_f32(vsubq_f32(v48, vsubq_f32(v52, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v52, v48)))), v27);
      v56 = (float32x4_t)vandq_s8(v17, v53);
      v57 = (float32x4_t)vandq_s8(v17, v54);
      *(int8x8_t *)v48.f32 = vqtbl1_s8(v44, *(int8x8_t *)v28.i8);
      v50.i64[0] = vextq_s8(v28, v28, 8uLL).u64[0];
      v48.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v44, *(int8x8_t *)v50.f32).u32[0]);
      *(int8x8_t *)v51.f32 = vqtbl1_s8(v46, *(int8x8_t *)v28.i8);
      v51.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v46, *(int8x8_t *)v50.f32).u32[0]);
      *(int8x8_t *)v28.i8 = vqtbl1_s8(v49, *(int8x8_t *)v28.i8);
      v28.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v49, *(int8x8_t *)v50.f32).u32[0]);
      v58 = (float32x4_t)vandq_s8(v17, v55);
      v60 = *(float32x4_t *)(v16 + 64);
      v59 = *(int8x16_t *)(v16 + 80);
      v61 = (int8x16_t *)(*(_QWORD *)&v7 + 16 * v11);
      *v61 = vbslq_s8(v59, vbslq_s8((int8x16_t)vcgtq_f32(v56, v60), v44, (int8x16_t)v48), (int8x16_t)v48);
      v61[1] = vbslq_s8(v59, vbslq_s8((int8x16_t)vcgtq_f32(v57, v60), v46, (int8x16_t)v51), (int8x16_t)v51);
      v61[2] = vbslq_s8(v59, vbslq_s8((int8x16_t)vcgtq_f32(v58, v60), v49, v28), v28);
      v13 = vaddq_f32(v15, (float32x4_t)xmmword_1B304F230);
      v11 += 3;
      v12 -= 3;
    }
    while (v12 > 2);
    v11 = v11;
    if ((int)v11 >= v6)
      goto LABEL_3;
    do
    {
LABEL_10:
      v62 = *((_QWORD *)this + 51);
      v63 = *(int8x16_t *)(v62 + 16);
      v64 = vmulq_f32(v13, *(float32x4_t *)v62);
      v65 = vcvtq_f32_s32(vcvtq_s32_f32(v64));
      v66 = vsubq_f32(v65, (float32x4_t)vandq_s8(v63, (int8x16_t)vcgtq_f32(v65, v64)));
      v68 = *(float32x4_t *)(v62 + 32);
      v67 = *(int8x16_t *)(v62 + 48);
      v69 = vaddq_f32(vsubq_f32(vaddq_f32(v68, v66), v5), v9);
      v70 = vcvtq_s32_f32(v69);
      v69.i64[0] = vaddq_s32(v70, vcgtq_f32(vcvtq_f32_s32(v70), v69)).u64[0];
      v71 = v69.i32[0] + v69.i32[1] * a2[11].i32[0];
      v72 = vmulq_f32(v13, v68);
      v73 = vcvtq_f32_s32(vcvtq_s32_f32(v72));
      v74 = *(int8x16_t *)(*(_QWORD *)&a2[10] + 16 * v71);
      v75 = (int8x16_t)vcgeq_f32(vsubq_f32(v72, vsubq_f32(v73, (float32x4_t)vandq_s8(v63, (int8x16_t)vcgtq_f32(v73, v72)))), v68);
      *(int8x8_t *)v68.f32 = vqtbl1_s8(v74, *(int8x8_t *)v67.i8);
      v68.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v74, (int8x8_t)*(_OWORD *)&vextq_s8(v67, v67, 8uLL)).u32[0]);
      *(int8x16_t *)(*(_QWORD *)&v7 + 16 * v11) = vbslq_s8(*(int8x16_t *)(v62 + 80), vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8(v63, v75), *(float32x4_t *)(v62 + 64)), v74, (int8x16_t)v68), (int8x16_t)v68);
      v13 = vaddq_f32(v13, (float32x4_t)xmmword_1B304F230);
      ++v11;
    }
    while (v11 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcColorGamma_2vuy_xyxz_expand::GetDOD(HgcColorGamma_2vuy_xyxz_expand *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  float v9;
  double v10;
  float v11;
  double v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
  v8 = HGRectGrow(v6, v5, v7);
  v9 = HGRectFloat(v8);
  v13 = HGRectScale(v9, v10, v11, v12, 2.0);
  v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcColorGamma_2vuy_xyxz_expand::GetROI(HgcColorGamma_2vuy_xyxz_expand *this, HGRenderer *a2, int a3, HGRect a4)
{
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = HGRectFloat(a4.var0);
  v9 = HGRectScale(v5, v6, v7, v8, 0.5);
  v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  v16 = v15;
  v17 = HGRectMake4i(0, 0, 1u, 0);
  v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcColorGamma_2vuy_xyxz_expand::HgcColorGamma_2vuy_xyxz_expand(HgcColorGamma_2vuy_xyxz_expand *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6545378;
  v3 = operator new();
  *(_OWORD *)v3 = xmmword_1B3553E10;
  *(_OWORD *)(v3 + 16) = xmmword_1B30520F0;
  *(_OWORD *)(v3 + 32) = xmmword_1B3052100;
  *(_OWORD *)(v3 + 48) = xmmword_1B3553F50;
  *(_QWORD *)(v3 + 64) = 0;
  *(_QWORD *)(v3 + 72) = 0;
  *(_OWORD *)(v3 + 80) = xmmword_1B3050E20;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcColorGamma_2vuy_xyxz_expand *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BDA174(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_2vuy_xyxz_expand::~HgcColorGamma_2vuy_xyxz_expand(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6545378;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6545378;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6545378;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_2vuy_xyxz_expand::SetParameter(HgcColorGamma_2vuy_xyxz_expand *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_2vuy_xyxz_expand::GetParameter(HgcColorGamma_2vuy_xyxz_expand *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcBlur_cs9s_es_noborder::GetProgram(HgcBlur_cs9s_es_noborder *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return aMetal10Len0000_1199;
    else
      return aMetal10Len0000_1200;
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_448;
  }
}

void HgcBlur_cs9s_es_noborder::InitProgramDescriptor(HgcBlur_cs9s_es_noborder *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlur_cs9s_es_noborder_hgc_visible", aMetal10Len0000_1201);
}

void sub_1B2BDA6DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BDA718(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BDA710);
}

double HgcBlur_cs9s_es_noborder::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A60;
  strcpy(v3, "HgcBlur_cs9s_es_noborder [hgc1]");
  return *(double *)"_noborder [hgc1]";
}

uint64_t HgcBlur_cs9s_es_noborder::BindTexture(HgcBlur_cs9s_es_noborder *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 10, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcBlur_cs9s_es_noborder::Bind(HgcBlur_cs9s_es_noborder *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 6, *((_QWORD *)this + 51) + 96, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 7, *((_QWORD *)this + 51) + 112, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 8, *((_QWORD *)this + 51) + 128, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 9, *((_QWORD *)this + 51) + 144, 1);
  (*(void (**)(HgcBlur_cs9s_es_noborder *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBlur_cs9s_es_noborder::RenderTile(HgcBlur_cs9s_es_noborder *this, int32x2_t *a2)
{
  uint64_t v4;
  int v5;
  int32x2_t v6;
  int v7;
  int v8;
  float32x2_t v9;
  float32x2_t v15;
  float32x2_t v16;
  float32x4_t v17;
  int32x2_t v18;
  uint64_t v19;
  uint64_t v20;
  float32x4_t v21;
  uint64_t v22;
  int32x2_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  int32x2_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  uint64_t v40;
  int8x16_t v41;
  int8x16_t v42;
  int8x16_t v43;
  int8x16_t v44;
  int8x16_t v45;
  float32x4_t v46;
  float32x4_t v47;
  int8x16_t v48;
  int8x16_t v49;
  int8x16_t v50;
  float32x4_t v51;
  int8x16_t v52;
  int8x16_t v53;
  int8x16_t v54;
  float32x2_t v55;
  float32x2_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int32x2_t v65;
  uint64_t v66;
  float32x2_t v67;
  float32x2_t v68;
  int32x2_t v69;
  float32x2_t v70;
  float32x4_t v71;
  float32x2_t v72;
  int32x2_t v73;
  float32x2_t v74;
  int32x2_t v75;
  float32x4_t *v76;
  uint64_t v77;
  float32x4_t v78;
  float32x4_t *v79;
  float32x4_t v80;
  float32x4_t v81;
  int32x2_t v82;
  int32x2_t v83;
  int32x2_t v84;
  float32x2_t v85;
  float32x4_t v86;
  float32x2_t v87;
  float32x2_t v88;
  int32x2_t v89;
  float32x2_t v90;
  float32x4_t *v91;
  float32x4_t v92;
  float32x4_t v93;
  int32x2_t v94;
  int8x16_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  int8x16_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x2_t v103;
  float32x2_t v104;
  float32x2_t v105;
  int32x2_t v106;
  float32x2_t v107;
  float32x4_t *v108;
  float32x4_t v109;
  float32x2_t v110;
  float32x2_t v111;
  int32x2_t v112;
  float32x2_t v113;
  float32x4_t *v114;
  float32x4_t v115;
  float32x4_t v116;
  int32x2_t v117;
  int32x2_t v118;
  int8x16_t v119;
  float32x2_t v120;
  float32x2_t v121;
  float32x2_t v122;
  int32x2_t v123;
  float32x2_t v124;
  float32x4_t *v125;
  float32x4_t v126;
  float32x4_t v127;
  int8x16_t v128;
  float32x2_t v129;
  float32x4_t *v130;
  float32x4_t v131;
  float32x4_t v132;
  int32x2_t v133;
  int8x16_t v134;
  float32x4_t v135;
  float32x2_t v136;
  float32x2_t v137;
  int32x2_t v138;
  float32x2_t v139;
  float32x4_t *v140;
  float32x4_t v141;
  float32x4_t v142;
  int32x2_t v143;
  int8x16_t v144;
  int8x16_t v145;
  float32x2_t v146;
  float32x2_t v147;
  int32x2_t v148;
  float32x2_t v149;
  float32x4_t *v150;
  float32x4_t v151;
  float32x4_t v153;
  float32x4_t v154;
  float32x2_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x2_t v161;

  v4 = HGTile::Renderer((HGTile *)a2);
  v5 = (*(uint64_t (**)(HgcBlur_cs9s_es_noborder *, uint64_t))(*(_QWORD *)this + 312))(this, v4);
  v6 = *a2;
  v7 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v7 >= 1 && a2[1].i32[0] - v6.i32[0] >= 1)
  {
    v8 = 0;
    v9 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    __asm { FMOV            V2.2S, #-1.0 }
    v15 = vadd_f32(v9, _D2);
    v16 = vadd_f32(v15, _D2);
    *(float32x2_t *)v17.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
    v17.i64[1] = 0x3F80000000000000;
    v18 = a2[2];
    v19 = 16 * a2[3].i32[0];
    v20 = 16 * (a2[1].i32[0] - v6.i32[0]);
    v21 = v17;
    v155 = v16;
    do
    {
      v22 = 0;
      v153 = v21;
      v154 = v17;
      do
      {
        v40 = *((_QWORD *)this + 51);
        v41 = (int8x16_t)vaddq_f32(*(float32x4_t *)(v40 + 96), vaddq_f32(v17, vmulq_f32(v21, *(float32x4_t *)(v40 + 80))));
        v42 = *(int8x16_t *)(v40 + 112);
        v43 = *(int8x16_t *)(v40 + 128);
        v44 = vextq_s8(v42, v42, 8uLL);
        v45 = (int8x16_t)vdupq_lane_s64(vaddq_f32((float32x4_t)v42, (float32x4_t)v41).i64[0], 0);
        v46 = vaddq_f32((float32x4_t)v42, (float32x4_t)vextq_s8(v45, v41, 8uLL));
        v47 = vaddq_f32((float32x4_t)v42, v46);
        v48 = (int8x16_t)vaddq_f32((float32x4_t)v42, v47);
        v49 = vextq_s8(v48, v48, 8uLL);
        v50 = (int8x16_t)vaddq_f32((float32x4_t)v44, (float32x4_t)v49);
        v51 = vaddq_f32((float32x4_t)v42, (float32x4_t)vdupq_laneq_s64((int64x2_t)v50, 1));
        v52 = vextq_s8(v43, v43, 8uLL);
        v54 = *(int8x16_t *)(v40 + 144);
        v53 = *(int8x16_t *)(v40 + 160);
        v55 = (float32x2_t)vextq_s8(v53, v53, 8uLL).u64[0];
        v56 = vmul_f32(*(float32x2_t *)v52.i8, vadd_f32(*(float32x2_t *)v43.i8, *(float32x2_t *)v51.f32));
        v57 = (float32x4_t)vextq_s8(v54, v54, 8uLL);
        v58.i64[0] = v46.i64[0];
        *(float32x2_t *)&v58.u32[2] = vabs_f32(vmul_f32(*(float32x2_t *)v57.f32, vadd_f32(v55, v56)));
        v63.i64[0] = vaddq_f32((float32x4_t)v43, v46).u64[0];
        v59 = vsubq_f32(v57, v58);
        v61 = *(float32x4_t *)(v40 + 176);
        v60 = *(float32x4_t *)(v40 + 192);
        v62 = vminq_f32(vmaxq_f32(v59, v61), v60);
        v63.i64[1] = v62.i64[1];
        v64 = vmulq_f32((float32x4_t)v52, v63);
        v65 = a2[10];
        v66 = a2[11].i32[0];
        v67 = vmul_f32(v9, v56);
        v161 = v55;
        if (v5)
        {
          v68 = vmin_f32(vmax_f32(vadd_f32(v67, (float32x2_t)0xBF000000BF000000), 0), v15);
          v69 = vcvt_s32_f32(vmin_f32(v68, v16));
          v70 = vsub_f32(v68, vcvt_f32_s32(v69));
          v71 = vmulq_laneq_f32(v63, v62, 3);
          v72 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, *(float32x2_t *)v64.f32), (float32x2_t)0xBF000000BF000000), 0), v15);
          v73 = vcvt_s32_f32(vmin_f32(v72, v16));
          v74 = vsub_f32(v72, vcvt_f32_s32(v73));
          v75 = vmla_s32(vzip1_s32(v69, v73), vzip2_s32(v69, v73), vdup_n_s32(v66));
          v76 = (float32x4_t *)(*(_QWORD *)&v65 + 16 * v75.i32[0]);
          v77 = (int)v66 + 1;
          v78 = vaddq_f32(*v76, vmulq_n_f32(vsubq_f32(v76[1], *v76), v70.f32[0]));
          v157 = vmulq_laneq_f32(vaddq_f32(v78, vmulq_lane_f32(vsubq_f32(vaddq_f32(v76[v66], vmulq_n_f32(vsubq_f32(v76[v77], v76[v66]), v70.f32[0])), v78), v70, 1)), v71, 2);
          v79 = (float32x4_t *)(*(_QWORD *)&v65 + 16 * v75.i32[1]);
          v80 = vaddq_f32(*v79, vmulq_n_f32(vsubq_f32(v79[1], *v79), v74.f32[0]));
          v81 = vaddq_f32(v80, vmulq_lane_f32(vsubq_f32(vaddq_f32(v79[v66], vmulq_n_f32(vsubq_f32(v79[v77], v79[v66]), v74.f32[0])), v80), v74, 1));
        }
        else
        {
          v82 = vcvt_s32_f32(vmin_f32(vmax_f32(v67, 0), v15));
          v83 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v9, *(float32x2_t *)v64.f32), 0), v15));
          v84 = vmla_s32(vzip1_s32(v82, v83), vzip2_s32(v82, v83), vdup_n_s32(v66));
          v157 = vmulq_laneq_f32(*(float32x4_t *)(*(_QWORD *)&v65 + 16 * v84.i32[0]), vmulq_laneq_f32(v63, v62, 3), 2);
          v81 = *(float32x4_t *)(*(_QWORD *)&v65 + 16 * v84.i32[1]);
        }
        v156 = v81;
        v86 = (float32x4_t)vextq_s8(v50, v50, 8uLL);
        v85 = (float32x2_t)vextq_s8(v52, v52, 8uLL).u64[0];
        *(float32x2_t *)v86.f32 = vmul_f32(*(float32x2_t *)v52.i8, vadd_f32(v85, *(float32x2_t *)v86.f32));
        v87 = vmul_f32(v9, *(float32x2_t *)v86.f32);
        if (v5)
        {
          v88 = vmin_f32(vmax_f32(vadd_f32(v87, (float32x2_t)0xBF000000BF000000), 0), v15);
          v89 = vcvt_s32_f32(vmin_f32(v88, v16));
          v90 = vsub_f32(v88, vcvt_f32_s32(v89));
          v91 = (float32x4_t *)(*(_QWORD *)&v65 + 16 * (v89.i32[0] + v89.i32[1] * (int)v66));
          v92 = vaddq_f32(*v91, vmulq_n_f32(vsubq_f32(v91[1], *v91), v90.f32[0]));
          v93 = vaddq_f32(v92, vmulq_lane_f32(vsubq_f32(vaddq_f32(v91[v66], vmulq_n_f32(vsubq_f32(v91[(int)v66 + 1], v91[v66]), v90.f32[0])), v92), v90, 1));
        }
        else
        {
          v94 = vcvt_s32_f32(vmin_f32(vmax_f32(v87, 0), v15));
          v93 = *(float32x4_t *)(*(_QWORD *)&v65 + 16 * (v94.i32[0] + v94.i32[1] * (int)v66));
        }
        v160 = v93;
        v95 = (int8x16_t)vmulq_f32(v57, vaddq_f32(v60, v64));
        v96 = vminq_f32(vmaxq_f32(vsubq_f32(v57, vabsq_f32((float32x4_t)vextq_s8(v95, v95, 8uLL))), v61), v60);
        v97.i64[0] = vaddq_f32(v60, v86).u64[0];
        v98 = vmulq_laneq_f32(v96, v96, 3);
        v97.i64[1] = v98.i64[1];
        v99 = (int8x16_t)vnegq_f32(vabsq_f32(vmulq_f32(v57, v97)));
        v100 = vminq_f32(vmaxq_f32(vaddq_f32(v57, (float32x4_t)vextq_s8(v99, v99, 8uLL)), v61), v60);
        v101.i64[0] = vaddq_f32((float32x4_t)v43, v47).u64[0];
        v102 = vmulq_laneq_f32(v100, v100, 3);
        v101.i64[1] = v102.i64[1];
        v103 = (float32x2_t)vmulq_f32((float32x4_t)v52, v101).u64[0];
        v104 = vmul_f32(v9, v103);
        if (v5)
        {
          v105 = vmin_f32(vmax_f32(vadd_f32(v104, (float32x2_t)0xBF000000BF000000), 0), v15);
          v106 = vcvt_s32_f32(vmin_f32(v105, v16));
          v107 = vsub_f32(v105, vcvt_f32_s32(v106));
          v108 = (float32x4_t *)(*(_QWORD *)&v65 + 16 * (v106.i32[0] + v106.i32[1] * (int)v66));
          v109 = vaddq_f32(*v108, vmulq_n_f32(vsubq_f32(v108[1], *v108), v107.f32[0]));
          v159 = vaddq_f32(v109, vmulq_lane_f32(vsubq_f32(vaddq_f32(v108[v66], vmulq_n_f32(vsubq_f32(v108[(int)v66 + 1], v108[v66]), v107.f32[0])), v109), v107, 1));
          v110 = vmul_f32(*(float32x2_t *)v52.i8, vadd_f32(v85, (float32x2_t)*(_OWORD *)&vextq_s8(v49, v49, 8uLL)));
          v111 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, v110), (float32x2_t)0xBF000000BF000000), 0), v15);
          v112 = vcvt_s32_f32(vmin_f32(v111, v16));
          v113 = vsub_f32(v111, vcvt_f32_s32(v112));
          v114 = (float32x4_t *)(*(_QWORD *)&v65 + 16 * (v112.i32[0] + v112.i32[1] * (int)v66));
          v115 = vaddq_f32(*v114, vmulq_n_f32(vsubq_f32(v114[1], *v114), v113.f32[0]));
          v116 = vaddq_f32(v115, vmulq_lane_f32(vsubq_f32(vaddq_f32(v114[v66], vmulq_n_f32(vsubq_f32(v114[(int)v66 + 1], v114[v66]), v113.f32[0])), v115), v113, 1));
        }
        else
        {
          v117 = vcvt_s32_f32(vmin_f32(vmax_f32(v104, 0), v15));
          v159 = *(float32x4_t *)(*(_QWORD *)&v65 + 16 * (v117.i32[0] + v117.i32[1] * (int)v66));
          v110 = vmul_f32(*(float32x2_t *)v52.i8, vadd_f32(v85, (float32x2_t)*(_OWORD *)&vextq_s8(v49, v49, 8uLL)));
          v118 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v9, v110), 0), v15));
          v116 = *(float32x4_t *)(*(_QWORD *)&v65 + 16 * (v118.i32[0] + v118.i32[1] * (int)v66));
        }
        v158 = v116;
        v42.i64[0] = vaddq_f32((float32x4_t)v42, v51).u64[0];
        v119 = (int8x16_t)vdupq_lane_s64(v42.i64[0], 0);
        v120 = (float32x2_t)vextq_s8(v119, v119, 8uLL).u64[0];
        *(float32x2_t *)v51.f32 = vmul_f32(*(float32x2_t *)v52.i8, vadd_f32(v85, v120));
        v121 = vmul_f32(v9, *(float32x2_t *)v51.f32);
        if (v5)
        {
          v122 = vmin_f32(vmax_f32(vadd_f32(v121, (float32x2_t)0xBF000000BF000000), 0), v15);
          v123 = vcvt_s32_f32(vmin_f32(v122, v16));
          v124 = vsub_f32(v122, vcvt_f32_s32(v123));
          v125 = (float32x4_t *)(*(_QWORD *)&v65 + 16 * (v123.i32[0] + v123.i32[1] * (int)v66));
          v126 = vaddq_f32(*v125, vmulq_n_f32(vsubq_f32(v125[1], *v125), v124.f32[0]));
          v127 = vaddq_f32(v126, vmulq_lane_f32(vsubq_f32(vaddq_f32(v125[v66], vmulq_n_f32(vsubq_f32(v125[(int)v66 + 1], v125[v66]), v124.f32[0])), v126), v124, 1));
          v128 = (int8x16_t)vmulq_f32((float32x4_t)v43, vaddq_f32((float32x4_t)v52, (float32x4_t)v45));
          v129 = (float32x2_t)vextq_s8(v128, v128, 8uLL).u64[0];
          *(float32x2_t *)v128.i8 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, v129), (float32x2_t)0xBF000000BF000000), 0), v15);
          *(int32x2_t *)v126.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v128.i8, v16));
          *(float32x2_t *)v128.i8 = vsub_f32(*(float32x2_t *)v128.i8, vcvt_f32_s32(*(int32x2_t *)v126.f32));
          v130 = (float32x4_t *)(*(_QWORD *)&v65 + 16 * (v126.i32[0] + v126.i32[1] * (int)v66));
          v131 = vaddq_f32(*v130, vmulq_n_f32(vsubq_f32(v130[1], *v130), *(float *)v128.i32));
          v132 = vaddq_f32(v131, vmulq_lane_f32(vsubq_f32(vaddq_f32(v130[v66], vmulq_n_f32(vsubq_f32(v130[(int)v66 + 1], v130[v66]), *(float *)v128.i32)), v131), *(float32x2_t *)v128.i8, 1));
        }
        else
        {
          v133 = vcvt_s32_f32(vmin_f32(vmax_f32(v121, 0), v15));
          v127 = *(float32x4_t *)(*(_QWORD *)&v65 + 16 * (v133.i32[0] + v133.i32[1] * (int)v66));
          v134 = (int8x16_t)vmulq_f32((float32x4_t)v43, vaddq_f32((float32x4_t)v52, (float32x4_t)v45));
          v129 = (float32x2_t)vextq_s8(v134, v134, 8uLL).u64[0];
          *(int32x2_t *)v134.i8 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v9, v129), 0), v15));
          v132 = *(float32x4_t *)(*(_QWORD *)&v65 + 16 * (v134.i32[0] + v134.i32[1] * (int)v66));
        }
        *(float32x2_t *)v135.f32 = vmul_f32(*(float32x2_t *)v52.i8, vadd_f32(v85, vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v44, v44, 8uLL), v120)));
        v136 = vmul_f32(v9, *(float32x2_t *)v135.f32);
        if (v5)
        {
          v137 = vmin_f32(vmax_f32(vadd_f32(v136, (float32x2_t)0xBF000000BF000000), 0), v15);
          v138 = vcvt_s32_f32(vmin_f32(v137, v16));
          v139 = vsub_f32(v137, vcvt_f32_s32(v138));
          v140 = (float32x4_t *)(*(_QWORD *)&v65 + 16 * (v138.i32[0] + v138.i32[1] * (int)v66));
          v141 = vaddq_f32(*v140, vmulq_n_f32(vsubq_f32(v140[1], *v140), v139.f32[0]));
          v142 = vaddq_f32(v141, vmulq_lane_f32(vsubq_f32(vaddq_f32(v140[v66], vmulq_n_f32(vsubq_f32(v140[(int)v66 + 1], v140[v66]), v139.f32[0])), v141), v139, 1));
        }
        else
        {
          v143 = vcvt_s32_f32(vmin_f32(vmax_f32(v136, 0), v15));
          v142 = *(float32x4_t *)(*(_QWORD *)&v65 + 16 * (v143.i32[0] + v143.i32[1] * (int)v66));
        }
        v135.i64[1] = v41.i64[0];
        v144 = (int8x16_t)vaddq_f32((float32x4_t)v52, v135);
        v145 = (int8x16_t)vmulq_f32(v57, vaddq_f32(v60, v135));
        v41.i64[0] = vmulq_f32((float32x4_t)v52, (float32x4_t)vextq_s8(v144, v145, 8uLL)).u64[0];
        v146 = vmul_f32(v9, *(float32x2_t *)v41.i8);
        if (v5)
        {
          v147 = vmin_f32(vmax_f32(vadd_f32(v146, (float32x2_t)0xBF000000BF000000), 0), v15);
          v16 = v155;
          v148 = vcvt_s32_f32(vmin_f32(v147, v155));
          v149 = vsub_f32(v147, vcvt_f32_s32(v148));
          v150 = (float32x4_t *)(*(_QWORD *)&v65 + 16 * (v148.i32[0] + v148.i32[1] * (int)v66));
          v151 = vaddq_f32(*v150, vmulq_n_f32(vsubq_f32(v150[1], *v150), v149.f32[0]));
          v24 = vaddq_f32(v151, vmulq_lane_f32(vsubq_f32(vaddq_f32(v150[v66], vmulq_n_f32(vsubq_f32(v150[(int)v66 + 1], v150[v66]), v149.f32[0])), v151), v149, 1));
        }
        else
        {
          v23 = vcvt_s32_f32(vmin_f32(vmax_f32(v146, 0), v15));
          v24 = *(float32x4_t *)(*(_QWORD *)&v65 + 16 * (v23.i32[0] + v23.i32[1] * (int)v66));
          v16 = v155;
        }
        *(float32x2_t *)v25.f32 = vmul_f32(*(float32x2_t *)v57.f32, vadd_f32(*(float32x2_t *)v60.f32, v110));
        *(int8x8_t *)v26.f32 = vand_s8(*(int8x8_t *)(v40 + 224), *(int8x8_t *)v25.f32);
        *(int8x8_t *)&v25.u32[2] = vand_s8(*(int8x8_t *)(v40 + 216), (int8x8_t)vmul_f32(*(float32x2_t *)v57.f32, vadd_f32(*(float32x2_t *)v60.f32, v103)));
        v27 = vminq_f32(vmaxq_f32(vsubq_f32(v57, v25), v61), v60);
        v28 = (int8x16_t)vmulq_laneq_f32(v27, v27, 3);
        v26.i64[1] = vextq_s8(v28, v28, 8uLL).u64[0];
        v29 = (int32x2_t)vminq_f32(vmaxq_f32(vsubq_f32((float32x4_t)v54, v26), v61), (float32x4_t)v53).u64[0];
        v30 = vaddq_f32(vmulq_f32(vaddq_f32(vmulq_laneq_f32(v160, v102, 2), vmulq_laneq_f32(v159, (float32x4_t)v28, 2)), *(float32x4_t *)(v40 + 16)), vmulq_f32(*(float32x4_t *)v40, vmulq_laneq_f32(v158, vmulq_n_f32((float32x4_t)vdupq_lane_s32(v29, 1), *(float *)v29.i32), 2)));
        v51.i64[1] = v42.i64[0];
        v31.i64[0] = v42.i64[0];
        *(float32x2_t *)&v31.u32[2] = vabs_f32((float32x2_t)*(_OWORD *)&vmulq_f32(v57, vaddq_f32(v60, v51)));
        v32 = vaddq_f32(vmulq_f32(vaddq_f32(v157, vmulq_laneq_f32(v156, v98, 2)), *(float32x4_t *)(v40 + 32)), v30);
        v33 = vminq_f32(vmaxq_f32(vsubq_f32(v57, v31), v61), v60);
        v42.u64[1] = (unint64_t)vadd_f32(v161, v129);
        v34 = (int8x16_t)vnegq_f32(vabsq_f32(vmulq_f32((float32x4_t)v54, (float32x4_t)v42)));
        v35 = vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)v54, (float32x4_t)vextq_s8(v34, v34, 8uLL)), v61), (float32x4_t)v53);
        v36 = vaddq_f32(v32, vmulq_f32(*(float32x4_t *)(v40 + 48), vaddq_f32(vmulq_n_f32(v127, vmulq_laneq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 3), v33, 2).f32[0]), vmulq_n_f32(v132, vmulq_lane_f32(v35, *(float32x2_t *)v35.f32, 1).f32[0]))));
        v145.i64[1] = vmulq_f32(*(float32x4_t *)&v54, vaddq_f32(*(float32x4_t *)&v53, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v41, 0))).i64[1];
        v37 = vabsq_f32((float32x4_t)v145);
        v41.i64[1] = v37.i64[1];
        v38 = vminq_f32(vmaxq_f32(vsubq_f32((float32x4_t)v54, v37), v61), (float32x4_t)v53);
        v39 = vminq_f32(vmaxq_f32(vsubq_f32(v57, (float32x4_t)v41), v61), v60);
        *(float32x4_t *)(*(_QWORD *)&v18 + v22) = vaddq_f32(v36, vmulq_f32(*(float32x4_t *)(v40 + 64), vaddq_f32(vmulq_n_f32(v142, vmulq_lane_f32(v38, *(float32x2_t *)v38.f32, 1).f32[0]), vmulq_n_f32(v24, vmulq_laneq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 3), v39, 2).f32[0]))));
        v17 = vaddq_f32(v17, (float32x4_t)xmmword_1B304F230);
        v21 = vaddq_f32(v21, (float32x4_t)xmmword_1B304F230);
        v22 += 16;
      }
      while (v20 != v22);
      v17 = vaddq_f32(v154, (float32x4_t)xmmword_1B304F240);
      v21 = vaddq_f32(v153, (float32x4_t)xmmword_1B304F240);
      ++v8;
      *(_QWORD *)&v18 += v19;
    }
    while (v8 != v7);
  }
  return 0;
}

uint64_t HgcBlur_cs9s_es_noborder::GetDOD(HgcBlur_cs9s_es_noborder *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcBlur_cs9s_es_noborder::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcBlur_cs9s_es_noborder::HgcBlur_cs9s_es_noborder(HgcBlur_cs9s_es_noborder *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65455E0;
  v3 = operator new();
  *(_OWORD *)(v3 + 128) = 0u;
  *(_OWORD *)(v3 + 144) = 0u;
  *(_OWORD *)(v3 + 96) = 0u;
  *(_OWORD *)(v3 + 112) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 160) = xmmword_1B3553F90;
  *(_QWORD *)(v3 + 176) = 0;
  *(_QWORD *)(v3 + 184) = 0;
  *(_OWORD *)(v3 + 192) = xmmword_1B3553F20;
  *(_OWORD *)(v3 + 208) = xmmword_1B3052C50;
  *(_OWORD *)(v3 + 224) = xmmword_1B3553F10;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcBlur_cs9s_es_noborder *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 5);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BDB438(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBlur_cs9s_es_noborder::~HgcBlur_cs9s_es_noborder(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65455E0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4019FCA701);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E65455E0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4019FCA701);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65455E0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4019FCA701);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBlur_cs9s_es_noborder::SetParameter(HgcBlur_cs9s_es_noborder *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 9)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlur_cs9s_es_noborder::GetParameter(HgcBlur_cs9s_es_noborder *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 9)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcPixelFormatConversion_kV4S_BE_WXYZ_output::GetProgram(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
    return "//Metal1.0     \n"
           "//LEN=000000031d\n"
           "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
           "    const constant float4* hg_Params [[ buffer(0) ]], \n"
           "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
           "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    const float4 c0 = float4(255.9960938, 256.0000000, 1.525902189e-05, 0.000000000);\n"
           "    float4 r0, r1;\n"
           "    FragmentOut output;\n"
           "\n"
           "    r0 = clamp(hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy), 0.00000f, 1.00000f);\n"
           "    r0 = r0*c0.xxxx;\n"
           "    r1 = fract(r0);\n"
           "    r1 = r1*c0.yyyy;\n"
           "    r1 = floor(r1);\n"
           "    r0 = floor(r0);\n"
           "    r1 = r1*c0.yyyy + r0;\n"
           "    output.color0 = r1.wxyz*c0.zzzz;\n"
           "    return output;\n"
           "}\n"
           "//MD5=13ee12da:76615530:14d039ae:fe550c56\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  if (Target <= 0x6060F || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
    return 0;
  return "//GLfs2.0      \n"
         "//LEN=00000002cc\n"
         "#ifndef GL_ES\n"
         "#define lowp\n"
         "#define mediump\n"
         "#define highp\n"
         "#endif\n"
         "#define defaultp mediump\n"
         "uniform defaultp sampler2D hg_Texture0;\n"
         "varying highp vec4 hg_TexCoord0;\n"
         "void main()\n"
         "{\n"
         "    const mediump vec4 c0 = vec4(255.9960938, 256.0000000, 1.525902189e-05, 0.000000000);\n"
         "    mediump vec4 r0, r1;\n"
         "\n"
         "    r0 = clamp(texture2D(hg_Texture0, hg_TexCoord0.xy), vec4(0.00000), vec4(1.00000));\n"
         "    r0 = r0*c0.xxxx;\n"
         "    r1 = fract(r0);\n"
         "    r1 = r1*c0.yyyy;\n"
         "    r1 = floor(r1);\n"
         "    r0 = floor(r0);\n"
         "    r1 = r1*c0.yyyy + r0;\n"
         "    gl_FragColor = r1.wxyz*c0.zzzz;\n"
         "}\n"
         "//MD5=6e72eee3:66e0366d:476be069:a678dd79\n"
         "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
}

void HgcPixelFormatConversion_kV4S_BE_WXYZ_output::InitProgramDescriptor(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4S_BE_WXYZ_output_hgc_visible", "//Metal1.0     \n//LEN=0000000213\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4S_BE_WXYZ_output_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(255.9960938, 256.0000000, 1.525902189e-05, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = clamp(color0, 0.00000f, 1.00000f);\n"
    "    r0 = r0*c0.xxxx;\n"
    "    r1 = fract(r0);\n"
    "    r1 = r1*c0.yyyy;\n"
    "    r1 = floor(r1);\n"
    "    r0 = floor(r0);\n"
    "    r1 = r1*c0.yyyy + r0;\n"
    "    output.color0 = r1.wxyz*c0.zzzz;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BDB870(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BDB8A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BDB898);
}

double HgcPixelFormatConversion_kV4S_BE_WXYZ_output::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x38uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B309DA70;
  strcpy(v3, "HgcPixelFormatConversion_kV4S_BE_WXYZ_output [hgc1]");
  return *(double *)"_WXYZ_output [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_output::BindTexture(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_output::Bind(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, HGHandler *a2)
{
  (*(void (**)(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_output::RenderTile(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t *v11;
  float32x4_t *v12;
  unint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  uint64_t v16;
  float32x4_t *v17;
  float32x4_t *v18;
  float32x4_t v19;
  float32x4_t *v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  int8x16_t v43;
  int8x16_t v44;
  int8x16_t v45;
  int8x16_t v46;
  float32x4_t v47;
  float32x4_t *v48;
  float32x4_t v49;
  float32x4_t *v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int8x16_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  float32x4_t *v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  int8x16_t v72;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v59 = 0;
        v60 = 16 * v7;
        v61 = 16 * v6;
        v62 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v63 = 0;
          do
          {
            v64 = (float32x4_t *)*((_QWORD *)this + 51);
            v65 = v64[1];
            v66 = v64[3];
            v67 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v63 / 0x10], *v64), v65), v64[2]);
            v68 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
            v69 = vsubq_f32(v68, (float32x4_t)vandq_s8((int8x16_t)v65, (int8x16_t)vcgtq_f32(v68, v67)));
            v70 = vmulq_f32(v66, vsubq_f32(v67, v69));
            v71 = vcvtq_f32_s32(vcvtq_s32_f32(v70));
            v72 = (int8x16_t)vaddq_f32(v69, vmulq_f32(v66, vsubq_f32(v71, (float32x4_t)vandq_s8((int8x16_t)v65, (int8x16_t)vcgtq_f32(v71, v70)))));
            v5[v63 / 0x10] = vmulq_f32(v64[4], (float32x4_t)vextq_s8(v72, v72, 0xCuLL));
            v63 += 16;
          }
          while (v62 != v63);
          ++v59;
          v4 = (float32x4_t *)((char *)v4 + v60);
          v5 = (float32x4_t *)((char *)v5 + v61);
        }
        while (v59 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = (float32x4_t *)*((_QWORD *)this + 51);
          v19 = v18[1];
          v20 = v14;
          v21 = v18[2];
          v22 = v18[3];
          v23 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16 - 2], *v18), v19), v21);
          v24 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16 - 1], *v18), v19), v21);
          v25 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16], *v18), v19), v21);
          v26 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16 + 1], *v18), v19), v21);
          v27 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
          v28 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
          v29 = vcvtq_f32_s32(vcvtq_s32_f32(v25));
          v30 = vcvtq_f32_s32(vcvtq_s32_f32(v26));
          v31 = vsubq_f32(v27, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v27, v23)));
          v32 = vsubq_f32(v28, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v28, v24)));
          v33 = vsubq_f32(v29, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v29, v25)));
          v34 = vsubq_f32(v30, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v30, v26)));
          v35 = vmulq_f32(v22, vsubq_f32(v23, v31));
          v36 = vmulq_f32(v22, vsubq_f32(v24, v32));
          v37 = vmulq_f32(v22, vsubq_f32(v25, v33));
          v38 = vmulq_f32(v22, vsubq_f32(v26, v34));
          v39 = vcvtq_f32_s32(vcvtq_s32_f32(v35));
          v40 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
          v41 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
          v42 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
          v43 = (int8x16_t)vaddq_f32(v31, vmulq_f32(v22, vsubq_f32(v39, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v39, v35)))));
          v44 = (int8x16_t)vaddq_f32(v32, vmulq_f32(v22, vsubq_f32(v40, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v40, v36)))));
          v45 = (int8x16_t)vaddq_f32(v33, vmulq_f32(v22, vsubq_f32(v41, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v41, v37)))));
          v46 = (int8x16_t)vaddq_f32(v34, vmulq_f32(v22, vsubq_f32(v42, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v42, v38)))));
          v47 = v18[4];
          v48 = &v5[v16];
          v13 += 4;
          v48[-2] = vmulq_f32(v47, (float32x4_t)vextq_s8(v43, v43, 0xCuLL));
          v48[-1] = vmulq_f32(v47, (float32x4_t)vextq_s8(v44, v44, 0xCuLL));
          *v48 = vmulq_f32(v47, (float32x4_t)vextq_s8(v45, v45, 0xCuLL));
          v48[1] = vmulq_f32(v47, (float32x4_t)vextq_s8(v46, v46, 0xCuLL));
          v16 += 4;
          v15 = v17 + 4;
          v14 += 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v49 = *v17++;
            v50 = (float32x4_t *)*((_QWORD *)this + 51);
            v51 = v50[1];
            v52 = v50[3];
            v53 = vmulq_f32(vminq_f32(vmaxq_f32(v49, *v50), v51), v50[2]);
            v54 = vcvtq_f32_s32(vcvtq_s32_f32(v53));
            v55 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v54, v53)));
            v56 = vmulq_f32(v52, vsubq_f32(v53, v55));
            v57 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
            v58 = (int8x16_t)vaddq_f32(v55, vmulq_f32(v52, vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v57, v56)))));
            *v20++ = vmulq_f32(v50[4], (float32x4_t)vextq_s8(v58, v58, 0xCuLL));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (float32x4_t *)((char *)v5 + v9);
        v4 = (float32x4_t *)((char *)v4 + v10);
        v11 = (float32x4_t *)((char *)v11 + v10);
        v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_output::GetDOD(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_output::GetROI(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcPixelFormatConversion_kV4S_BE_WXYZ_output::HgcPixelFormatConversion_kV4S_BE_WXYZ_output(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6545848;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v3 + 16) = _Q0;
  *(int32x4_t *)(v3 + 32) = vdupq_n_s32(0x437FFF00u);
  *(int32x4_t *)(v3 + 48) = vdupq_n_s32(0x43800000u);
  *(int32x4_t *)(v3 + 64) = vdupq_n_s32(0x37800080u);
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BDBDC0(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4S_BE_WXYZ_output::~HgcPixelFormatConversion_kV4S_BE_WXYZ_output(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6545848;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6545848;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6545848;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_output::SetParameter(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_output::GetParameter(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcUnpremultiply::GetProgram(HgcUnpremultiply *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000025a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0) / float4(fmax((float3)r0.www, 1.00000e-06f), 1.);\n"
             "    return output;\n"
             "}\n"
             "//MD5=164cdd96:703f1726:5bc85274:a1b49ed0\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000244\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c6ed00a3:77233d55:f54fcc5b:9f5ee2d3\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001e1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    mediump vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "}\n"
           "//MD5=4fca7993:d83f0755:ff909c75:c8074a19\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcUnpremultiply::InitProgramDescriptor(HgcUnpremultiply *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcUnpremultiply_hgc_visible", "//Metal1.0     \n//LEN=000000011e\n[[ visible ]] FragmentOut HgcUnpremultiply_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BDC160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BDC190(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BDC188);
}

char *HgcUnpremultiply::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x19uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A10;
  strcpy(result, "HgcUnpremultiply [hgc1]");
  return result;
}

uint64_t HgcUnpremultiply::BindTexture(HgcUnpremultiply *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcUnpremultiply::Bind(HgcUnpremultiply *this, HGHandler *a2)
{
  (*(void (**)(HgcUnpremultiply *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcUnpremultiply::RenderTile(HgcUnpremultiply *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t *v11;
  float32x4_t *v12;
  unint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  uint64_t v16;
  float32x4_t *v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  uint64_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  int8x16_t v35;
  float32x4_t *v36;
  float32x4_t *v37;
  float32x4_t v38;
  uint64_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  float32x4_t v47;
  uint64_t v48;
  float32x4_t v49;
  float32x4_t v50;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v42 = 0;
        v43 = 16 * v7;
        v44 = 16 * v6;
        v45 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v46 = 0;
          do
          {
            v47 = v4[v46 / 0x10];
            v48 = *((_QWORD *)this + 51);
            v49 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 3), *(float32x4_t *)v48);
            v50 = vmulq_f32(vrecpeq_f32(v49), *(float32x4_t *)(v48 + 16));
            v5[v46 / 0x10] = vmulq_f32(v47, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v48 + 32), (int8x16_t)vmulq_f32(v50, vrecpsq_f32(v50, v49))), *(int8x16_t *)(v48 + 48)));
            v46 += 16;
          }
          while (v45 != v46);
          ++v42;
          v4 = (float32x4_t *)((char *)v4 + v43);
          v5 = (float32x4_t *)((char *)v5 + v44);
        }
        while (v42 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = v4[v16 - 2];
          v19 = v4[v16 - 1];
          v20 = v4[v16];
          v21 = v4[v16 + 1];
          v22 = *((_QWORD *)this + 51);
          v23 = *(float32x4_t *)(v22 + 16);
          v24 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 3), *(float32x4_t *)v22);
          v25 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3), *(float32x4_t *)v22);
          v26 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 3), *(float32x4_t *)v22);
          v27 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 3), *(float32x4_t *)v22);
          v28 = vmulq_f32(vrecpeq_f32(v24), v23);
          v29 = vmulq_f32(vrecpeq_f32(v25), v23);
          v30 = vmulq_f32(vrecpeq_f32(v26), v23);
          v31 = vmulq_f32(vrecpeq_f32(v27), v23);
          v32 = (int8x16_t)vmulq_f32(v28, vrecpsq_f32(v28, v24));
          v33 = (int8x16_t)vmulq_f32(v31, vrecpsq_f32(v31, v27));
          v34 = *(int8x16_t *)(v22 + 32);
          v35 = *(int8x16_t *)(v22 + 48);
          v36 = v14;
          v37 = &v5[v16];
          v13 += 4;
          v37[-2] = vmulq_f32(v18, (float32x4_t)vorrq_s8(vandq_s8(v34, v32), v35));
          v37[-1] = vmulq_f32(v19, (float32x4_t)vorrq_s8(vandq_s8(v34, (int8x16_t)vmulq_f32(v29, vrecpsq_f32(v29, v25))), v35));
          *v37 = vmulq_f32(v20, (float32x4_t)vorrq_s8(vandq_s8(v34, (int8x16_t)vmulq_f32(v30, vrecpsq_f32(v30, v26))), v35));
          v37[1] = vmulq_f32(v21, (float32x4_t)vorrq_s8(vandq_s8(v34, v33), v35));
          v16 += 4;
          v15 += 4;
          v14 = v36 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v38 = *v17++;
            v39 = *((_QWORD *)this + 51);
            v40 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 3), *(float32x4_t *)v39);
            v41 = vmulq_f32(vrecpeq_f32(v40), *(float32x4_t *)(v39 + 16));
            *v36++ = vmulq_f32(v38, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v39 + 32), (int8x16_t)vmulq_f32(v41, vrecpsq_f32(v41, v40))), *(int8x16_t *)(v39 + 48)));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (float32x4_t *)((char *)v5 + v9);
        v4 = (float32x4_t *)((char *)v4 + v10);
        v11 = (float32x4_t *)((char *)v11 + v10);
        v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcUnpremultiply::GetDOD(HgcUnpremultiply *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcUnpremultiply::GetROI(HgcUnpremultiply *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcUnpremultiply::HgcUnpremultiply(HgcUnpremultiply *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6545AB0;
  v3 = operator new();
  *(int32x4_t *)v3 = vdupq_n_s32(0x358637BDu);
  *(int32x4_t *)(v3 + 16) = vdupq_n_s32(0x3F804020u);
  *(_OWORD *)(v3 + 32) = xmmword_1B30514E0;
  *(_OWORD *)(v3 + 48) = xmmword_1B304EFF0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BDC5A8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcUnpremultiply::~HgcUnpremultiply(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6545AB0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40FA0F61DDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6545AB0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40FA0F61DDLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcUnpremultiply::SetParameter(HgcUnpremultiply *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcUnpremultiply::GetParameter(HgcUnpremultiply *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcUnpremultiplySanitized::GetProgram(HgcUnpremultiplySanitized *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000334\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 9.999999975e-07, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.y = half(r0.w >= c0.y);\n"
             "    r0.xyz = r1.yyy*r0.xyz;\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    output.color0.xyz = fmin(float3(r0.xyz), hg_Params[0].xyz);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8c43997a:1a09e3c5:feddaaaa:95fee0f9\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000323\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 9.999999975e-07, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.y = float(r0.w >= c0.y);\n"
             "    r0.xyz = r1.yyy*r0.xyz;\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    output.color0.xyz = fmin(r0.xyz, hg_Params[0].xyz);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9aa70715:fed71175:863959e2:0a892a0e\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002ed\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 9.999999975e-07, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.y = float(r0.w >= c0.y);\n"
           "    r0.xyz = r1.yyy*r0.xyz;\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    gl_FragColor.xyz = min(r0.xyz, hg_ProgramLocal0.xyz);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=1eda26ab:681475ba:00ce9047:1b229bc3\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcUnpremultiplySanitized::InitProgramDescriptor(HgcUnpremultiplySanitized *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcUnpremultiplySanitized_hgc_visible", "//Metal1.0     \n//LEN=0000000206\n[[ visible ]] FragmentOut HgcUnpremultiplySanitized_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 9.999999975e-07, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.y = float(r0.w >= c0.y);\n"
    "    r0.xyz = r1.yyy*r0.xyz;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    output.color0.xyz = fmin(r0.xyz, hg_Params[0].xyz);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BDC900(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BDC930(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BDC928);
}

char *HgcUnpremultiplySanitized::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552EC0;
  strcpy(result, "HgcUnpremultiplySanitized [hgc1]");
  return result;
}

uint64_t HgcUnpremultiplySanitized::BindTexture(HgcUnpremultiplySanitized *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcUnpremultiplySanitized::Bind(HgcUnpremultiplySanitized *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcUnpremultiplySanitized *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcUnpremultiplySanitized::RenderTile(HgcUnpremultiplySanitized *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  int8x16_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t *v11;
  int8x16_t *v12;
  unint64_t v13;
  int8x16_t *v14;
  float32x4_t *v15;
  uint64_t v16;
  _OWORD *v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t *v36;
  int8x16_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  int8x16_t *v43;
  int8x16_t *v44;
  float32x4_t v45;
  uint64_t v46;
  float32x4_t v47;
  int8x16_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  float32x4_t v59;
  int8x16_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (int8x16_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v53 = 0;
        v54 = 16 * v7;
        v55 = 16 * v6;
        v56 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v57 = 0;
          do
          {
            v58 = *((_QWORD *)this + 51);
            v59 = *(float32x4_t *)(v58 + 16);
            v60 = *(int8x16_t *)(v58 + 48);
            v61 = (float32x4_t)vbslq_s8(v60, (int8x16_t)v4[v57 / 0x10], (int8x16_t)vmulq_lane_f32(v4[v57 / 0x10], (float32x2_t)*(_OWORD *)&vandq_s8(*(int8x16_t *)(v58 + 32), (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8((int8x16_t)v4[v57 / 0x10], (int8x16_t)v4[v57 / 0x10], 8uLL), v59)), 1));
            v62 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v61, 3), v59);
            v63 = vmulq_f32(vrecpeq_f32(v62), *(float32x4_t *)(v58 + 64));
            v64 = vmulq_f32(v61, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v58 + 80), (int8x16_t)vmulq_f32(v63, vrecpsq_f32(v63, v62))), *(int8x16_t *)(v58 + 96)));
            v5[v57 / 0x10] = vbslq_s8(v60, (int8x16_t)v64, (int8x16_t)vminq_f32(v64, *(float32x4_t *)v58));
            v57 += 16;
          }
          while (v56 != v57);
          ++v53;
          v4 = (float32x4_t *)((char *)v4 + v54);
          v5 = (int8x16_t *)((char *)v5 + v55);
        }
        while (v53 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = (_OWORD *)*((_QWORD *)this + 51);
          v19 = *(float32x4_t *)v17;
          v18 = *((float32x4_t *)v17 + 1);
          v20 = *((int8x16_t *)v17 + 2);
          v21 = *((int8x16_t *)v17 + 3);
          v22 = (float32x4_t)vbslq_s8(v21, (int8x16_t)v4[v16 - 2], (int8x16_t)vmulq_lane_f32(v4[v16 - 2], (float32x2_t)*(_OWORD *)&vandq_s8(v20, (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8((int8x16_t)v4[v16 - 2], (int8x16_t)v4[v16 - 2], 8uLL), v18)), 1));
          v23 = (float32x4_t)vbslq_s8(v21, (int8x16_t)v4[v16 - 1], (int8x16_t)vmulq_lane_f32(v4[v16 - 1], (float32x2_t)*(_OWORD *)&vandq_s8(v20, (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8((int8x16_t)v4[v16 - 1], (int8x16_t)v4[v16 - 1], 8uLL), v18)), 1));
          v24 = (float32x4_t)vbslq_s8(v21, (int8x16_t)v4[v16], (int8x16_t)vmulq_lane_f32(v4[v16], (float32x2_t)*(_OWORD *)&vandq_s8(v20, (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8((int8x16_t)v4[v16], (int8x16_t)v4[v16], 8uLL), v18)), 1));
          v25 = (float32x4_t)vbslq_s8(v21, (int8x16_t)v4[v16 + 1], (int8x16_t)vmulq_lane_f32(v4[v16 + 1], (float32x2_t)*(_OWORD *)&vandq_s8(v20, (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8((int8x16_t)v4[v16 + 1], (int8x16_t)v4[v16 + 1], 8uLL), v18)), 1));
          v26 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 3), v18);
          v27 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 3), v18);
          v28 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 3), v18);
          v29 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 3), v18);
          v30 = *((float32x4_t *)v17 + 4);
          v31 = *((int8x16_t *)v17 + 5);
          v32 = vmulq_f32(vrecpeq_f32(v26), v30);
          v33 = vmulq_f32(vrecpeq_f32(v27), v30);
          v34 = vmulq_f32(vrecpeq_f32(v28), v30);
          v35 = vmulq_f32(vrecpeq_f32(v29), v30);
          v36 = v15;
          v37 = vandq_s8(v31, (int8x16_t)vmulq_f32(v32, vrecpsq_f32(v32, v26)));
          v38 = *((int8x16_t *)v17 + 6);
          v39 = vmulq_f32(v22, (float32x4_t)vorrq_s8(v37, v38));
          v40 = vmulq_f32(v23, (float32x4_t)vorrq_s8(vandq_s8(v31, (int8x16_t)vmulq_f32(v33, vrecpsq_f32(v33, v27))), v38));
          v41 = vmulq_f32(v24, (float32x4_t)vorrq_s8(vandq_s8(v31, (int8x16_t)vmulq_f32(v34, vrecpsq_f32(v34, v28))), v38));
          v42 = vmulq_f32(v25, (float32x4_t)vorrq_s8(vandq_s8(v31, (int8x16_t)vmulq_f32(v35, vrecpsq_f32(v35, v29))), v38));
          v43 = v14;
          v44 = &v5[v16];
          v13 += 4;
          v44[-2] = vbslq_s8(v21, (int8x16_t)v39, (int8x16_t)vminq_f32(v39, v19));
          v44[-1] = vbslq_s8(v21, (int8x16_t)v40, (int8x16_t)vminq_f32(v40, v19));
          *v44 = vbslq_s8(v21, (int8x16_t)v41, (int8x16_t)vminq_f32(v41, v19));
          v44[1] = vbslq_s8(v21, (int8x16_t)v42, (int8x16_t)vminq_f32(v42, v19));
          v16 += 4;
          v15 += 4;
          v14 = v43 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v45 = *v36++;
            v46 = *((_QWORD *)this + 51);
            v47 = *(float32x4_t *)(v46 + 16);
            v48 = *(int8x16_t *)(v46 + 48);
            v49 = (float32x4_t)vbslq_s8(v48, (int8x16_t)v45, (int8x16_t)vmulq_lane_f32(v45, (float32x2_t)*(_OWORD *)&vandq_s8(*(int8x16_t *)(v46 + 32), (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8((int8x16_t)v45, (int8x16_t)v45, 8uLL), v47)), 1));
            v50 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 3), v47);
            v51 = vmulq_f32(vrecpeq_f32(v50), *(float32x4_t *)(v46 + 64));
            v52 = vmulq_f32(v49, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v46 + 80), (int8x16_t)vmulq_f32(v51, vrecpsq_f32(v51, v50))), *(int8x16_t *)(v46 + 96)));
            *v43++ = vbslq_s8(v48, (int8x16_t)v52, (int8x16_t)vminq_f32(v52, *(float32x4_t *)v46));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (int8x16_t *)((char *)v5 + v9);
        v4 = (float32x4_t *)((char *)v4 + v10);
        v11 = (float32x4_t *)((char *)v11 + v10);
        v12 = (int8x16_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcUnpremultiplySanitized::GetDOD(HgcUnpremultiplySanitized *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcUnpremultiplySanitized::GetROI(HgcUnpremultiplySanitized *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcUnpremultiplySanitized::HgcUnpremultiplySanitized(HgcUnpremultiplySanitized *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6545D18;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(int32x4_t *)(v3 + 16) = vdupq_n_s32(0x358637BDu);
  *(_OWORD *)(v3 + 32) = xmmword_1B304F240;
  *(_OWORD *)(v3 + 48) = xmmword_1B3050F70;
  *(int32x4_t *)(v3 + 64) = vdupq_n_s32(0x3F804020u);
  *(_OWORD *)(v3 + 80) = xmmword_1B30514E0;
  *(_OWORD *)(v3 + 96) = xmmword_1B304EFF0;
  *(_OWORD *)(v3 + 112) = 0u;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BDCE50(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcUnpremultiplySanitized::~HgcUnpremultiplySanitized(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6545D18;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6545D18;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcUnpremultiplySanitized::SetParameter(HgcUnpremultiplySanitized *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  __n128 *v8;
  int32x4_t v9;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (__n128 *)*((_QWORD *)this + 51);
  if (v8->n128_f32[0] == a3.n128_f32[0]
    && v8->n128_f32[1] == a3.n128_f32[0]
    && v8->n128_f32[2] == a3.n128_f32[0]
    && v8->n128_f32[3] == 0.0)
  {
    return 0;
  }
  v9 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
  v9.i32[2] = a3.n128_u32[0];
  a3.n128_f32[1] = a4;
  *v8 = (__n128)v9;
  a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
  v8[7] = a3;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcUnpremultiplySanitized::GetParameter(HgcUnpremultiplySanitized *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = v3[28];
    a3[1] = v3[29];
    a3[2] = v3[30];
    result = v3[31];
    a3[3] = result;
  }
  return result;
}

const char *HgcApply3DLUTTetrahedralFast_basekernel::GetProgram(HgcApply3DLUTTetrahedralFast_basekernel *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return aMetal10Len0000_1210;
    else
      return "//Metal1.0     \n"
             "//LEN=0000000f3c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = r1.xyz*r1.xyz;\n"
             "    r3.xyz = r2.xyz*r1.xyz;\n"
             "    r1.xyz = r1.xyz*hg_Params[3].yyy + hg_Params[3].xxx;\n"
             "    r1.xyz = r2.xyz*hg_Params[3].zzz + r1.xyz;\n"
             "    r1.xyz = r3.xyz*hg_Params[3].www + r1.xyz;\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r2.xyz = hg_Params[1].yyy - c0.yyy;\n"
             "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
             "    r3.xyz = fract(r1.xyz);\n"
             "    r1.xyz = floor(r1.xyz);\n"
             "    r4.xyz = r1.xyz + c0.yyy;\n"
             "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
             "    r4.xyz = r4.xyz - r1.xyz;\n"
             "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
             "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
             "    r2.y = r1.z;\n"
             "    r2.xy = r2.xy + c0.zz;\n"
             "    r1.xy = r2.xy + hg_Params[4].xy;\n"
             "    r1.xy = r1.xy*hg_Params[4].zw;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r5.xy = r2.xy + hg_Params[4].xy;\n"
             "    r5.xy = r5.xy*hg_Params[4].zw;\n"
             "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r6.xy = r2.xy + hg_Params[4].xy;\n"
             "    r6.xy = r6.xy*hg_Params[4].zw;\n"
             "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
             "    r2.x = r2.x - r4.x;\n"
             "    r7.xy = r2.xy + hg_Params[4].xy;\n"
             "    r7.xy = r7.xy*hg_Params[4].zw;\n"
             "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
             "    r2.y = r2.y + r4.z;\n"
             "    r8.xy = r2.xy + hg_Params[4].xy;\n"
             "    r8.xy = r8.xy*hg_Params[4].zw;\n"
             "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
             "    r2.x = r2.x - r4.y;\n"
             "    r9.xy = r2.xy + hg_Params[4].xy;\n"
             "    r9.xy = r9.xy*hg_Params[4].zw;\n"
             "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r10.xy = r2.xy + hg_Params[4].xy;\n"
             "    r10.xy = r10.xy*hg_Params[4].zw;\n"
             "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r2.xy = r2.xy + hg_Params[4].xy;\n"
             "    r2.xy = r2.xy*hg_Params[4].zw;\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
             "    r4 = float4(r3.xzzy > r3.yxyz);\n"
             "    r11.x = float(r3.y > r3.x);\n"
             "    r12 = float4(r3.yxxz >= r3.xyzy);\n"
             "    r13 = r2 - r8;\n"
             "    r14 = r7 - r1;\n"
             "    r15 = r8 - r7;\n"
             "    r16 = r13*r3.xxxx;\n"
             "    r16 = r14*r3.yyyy + r16;\n"
             "    r15 = r15*r3.zzzz + r16;\n"
             "    r16 = r10 - r9;\n"
             "    r17 = r2 - r10;\n"
             "    r18 = r9 - r1;\n"
             "    r16 = r16*r3.xxxx;\n"
             "    r16 = r17*r3.yyyy + r16;\n"
             "    r16 = r18*r3.zzzz + r16;\n"
             "    r19 = fmin(r4.xxxx, r4.yyyy);\n"
             "    r15 = select(r15, r16, r19 > 0.00000f);\n"
             "    r8 = r8 - r9;\n"
             "    r13 = r13*r3.xxxx;\n"
             "    r13 = r8*r3.yyyy + r13;\n"
             "    r13 = r18*r3.zzzz + r13;\n"
             "    r19 = fmin(r12.xxxx, r4.zzzz);\n"
             "    r15 = select(r15, r13, r19 > 0.00000f);\n"
             "    r16 = r5 - r1;\n"
             "    r9 = r6 - r5;\n"
             "    r2 = r2 - r6;\n"
             "    r8 = r16*r3.xxxx;\n"
             "    r8 = r9*r3.yyyy + r8;\n"
             "    r8 = r2*r3.zzzz + r8;\n"
             "    r4 = fmin(r4.wwww, r12.yyyy);\n"
             "    r15 = select(r15, r8, r4 > 0.00000f);\n"
             "    r6 = r6 - r7;\n"
             "    r6 = r6*r3.xxxx;\n"
             "    r6 = r14*r3.yyyy + r6;\n"
             "    r6 = r2*r3.zzzz + r6;\n"
             "    r11 = fmin(r12.zzzz, r11.xxxx);\n"
             "    r15 = select(r15, r6, r11 > 0.00000f);\n"
             "    r10 = r10 - r5;\n"
             "    r16 = r16*r3.xxxx;\n"
             "    r16 = r17*r3.yyyy + r16;\n"
             "    r16 = r10*r3.zzzz + r16;\n"
             "    r12 = fmin(r12.wwww, r12.zzzz);\n"
             "    r12 = select(r15, r16, r12 > 0.00000f);\n"
             "    r12 = r12 + r1;\n"
             "    r12 = r12*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
             "    output.color0 = select(r12, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d988d904:dace4484:6b5f78dc:2808f41f\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0005:0014:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_452;
  }
}

void HgcApply3DLUTTetrahedralFast_basekernel::InitProgramDescriptor(HgcApply3DLUTTetrahedralFast_basekernel *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcApply3DLUTTetrahedralFast_basekernel_hgc_visible", "//Metal1.0     \n//LEN=0000000e0b\n[[ visible ]] FragmentOut HgcApply3DLUTTetrahedralFast_basekernel_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = r1.xyz*r1.xyz;\n"
    "    r3.xyz = r2.xyz*r1.xyz;\n"
    "    r1.xyz = r1.xyz*hg_Params[3].yyy + hg_Params[3].xxx;\n"
    "    r1.xyz = r2.xyz*hg_Params[3].zzz + r1.xyz;\n"
    "    r1.xyz = r3.xyz*hg_Params[3].www + r1.xyz;\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r2.xyz = hg_Params[1].yyy - c0.yyy;\n"
    "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
    "    r3.xyz = fract(r1.xyz);\n"
    "    r1.xyz = floor(r1.xyz);\n"
    "    r4.xyz = r1.xyz + c0.yyy;\n"
    "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
    "    r4.xyz = r4.xyz - r1.xyz;\n"
    "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
    "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
    "    r2.y = r1.z;\n"
    "    r2.xy = r2.xy + c0.zz;\n"
    "    r1.xy = r2.xy + hg_Params[4].xy;\n"
    "    r1.xy = r1.xy*hg_Params[4].zw;\n"
    "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r5.xy = r2.xy + hg_Params[4].xy;\n"
    "    r5.xy = r5.xy*hg_Params[4].zw;\n"
    "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r6.xy = r2.xy + hg_Params[4].xy;\n"
    "    r6.xy = r6.xy*hg_Params[4].zw;\n"
    "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
    "    r2.x = r2.x - r4.x;\n"
    "    r7.xy = r2.xy + hg_Params[4].xy;\n"
    "    r7.xy = r7.xy*hg_Params[4].zw;\n"
    "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
    "    r2.y = r2.y + r4.z;\n"
    "    r8.xy = r2.xy + hg_Params[4].xy;\n"
    "    r8.xy = r8.xy*hg_Params[4].zw;\n"
    "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
    "    r2.x = r2.x - r4.y;\n"
    "    r9.xy = r2.xy + hg_Params[4].xy;\n"
    "    r9.xy = r9.xy*hg_Params[4].zw;\n"
    "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r10.xy = r2.xy + hg_Params[4].xy;\n"
    "    r10.xy = r10.xy*hg_Params[4].zw;\n"
    "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r2.xy = r2.xy + hg_Params[4].xy;\n"
    "    r2.xy = r2.xy*hg_Params[4].zw;\n"
    "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
    "    r4 = float4(r3.xzzy > r3.yxyz);\n"
    "    r11.x = float(r3.y > r3.x);\n"
    "    r12 = float4(r3.yxxz >= r3.xyzy);\n"
    "    r13 = r2 - r8;\n"
    "    r14 = r7 - r1;\n"
    "    r15 = r8 - r7;\n"
    "    r16 = r13*r3.xxxx;\n"
    "    r16 = r14*r3.yyyy + r16;\n"
    "    r15 = r15*r3.zzzz + r16;\n"
    "    r16 = r10 - r9;\n"
    "    r17 = r2 - r10;\n"
    "    r18 = r9 - r1;\n"
    "    r16 = r16*r3.xxxx;\n"
    "    r16 = r17*r3.yyyy + r16;\n"
    "    r16 = r18*r3.zzzz + r16;\n"
    "    r19 = fmin(r4.xxxx, r4.yyyy);\n"
    "    r15 = select(r15, r16, r19 > 0.00000f);\n"
    "    r8 = r8 - r9;\n"
    "    r13 = r13*r3.xxxx;\n"
    "    r13 = r8*r3.yyyy + r13;\n"
    "    r13 = r18*r3.zzzz + r13;\n"
    "    r19 = fmin(r12.xxxx, r4.zzzz);\n"
    "    r15 = select(r15, r13, r19 > 0.00000f);\n"
    "    r16 = r5 - r1;\n"
    "    r9 = r6 - r5;\n"
    "    r2 = r2 - r6;\n"
    "    r8 = r16*r3.xxxx;\n"
    "    r8 = r9*r3.yyyy + r8;\n"
    "    r8 = r2*r3.zzzz + r8;\n"
    "    r4 = fmin(r4.wwww, r12.yyyy);\n"
    "    r15 = select(r15, r8, r4 > 0.00000f);\n"
    "    r6 = r6 - r7;\n"
    "    r6 = r6*r3.xxxx;\n"
    "    r6 = r14*r3.yyyy + r6;\n"
    "    r6 = r2*r3.zzzz + r6;\n"
    "    r11 = fmin(r12.zzzz, r11.xxxx);\n"
    "    r15 = select(r15, r6, r11 > 0.00000f);\n"
    "    r10 = r10 - r5;\n"
    "    r16 = r16*r3.xxxx;\n"
    "    r16 = r17*r3.yyyy + r16;\n"
    "    r16 = r10*r3.zzzz + r16;\n"
    "    r12 = fmin(r12.wwww, r12.zzzz);\n"
    "    r12 = select(r15, r16, r12 > 0.00000f);\n"
    "    r12 = r12 + r1;\n"
    "    r12 = r12*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
    "    output.color0 = select(r12, r0, hg_Params[2] < 0.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BDD38C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BDD3C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BDD3BCLL);
}

double HgcApply3DLUTTetrahedralFast_basekernel::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x30uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3554020;
  strcpy(v3, "HgcApply3DLUTTetrahedralFast_basekernel [hgc1]");
  return *(double *)"asekernel [hgc1]";
}

uint64_t HgcApply3DLUTTetrahedralFast_basekernel::BindTexture(HgcApply3DLUTTetrahedralFast_basekernel *this, HGHandler *a2, int a3)
{
  int v4;
  uint64_t result;
  __n128 v6;
  __n128 v7;
  __n128 v8;
  __n128 v9;

  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    {
      v8.n128_u32[0] = 1.0;
      v9.n128_u32[0] = 1.0;
    }
    else
    {
      v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v9.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v6.n128_f32[0] = (float)*((int *)a2 + 60);
    v7.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 4, v6, v7, v8, v9);
    return 0;
  }
  else if (a3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    v4 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
    result = 0;
    if (!v4)
    {
      (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcApply3DLUTTetrahedralFast_basekernel::Bind(HgcApply3DLUTTetrahedralFast_basekernel *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HgcApply3DLUTTetrahedralFast_basekernel *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcApply3DLUTTetrahedralFast_basekernel::RenderTile(HgcApply3DLUTTetrahedralFast_basekernel *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  int v5;
  float32x4_t v6;
  int32x2_t v7;
  int32x2_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  _OWORD *v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  int32x2_t v37;
  float32x4_t v38;
  int32x4_t v39;
  __int32 v40;
  __int32 v41;
  float32x4_t v42;
  float32x4_t v43;
  __int32 v44;
  int32x4_t v45;
  __int32 v46;
  __int32 v47;
  __int32 v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  int32x4_t v53;
  __int32 v54;
  __int32 v55;
  float32x4_t v56;
  __int32 v57;
  int8x16_t v58;
  float32x4_t v59;
  float32x4_t v60;
  __int32 v61;
  int32x4_t v62;
  __int32 v63;
  __int32 v64;
  int8x16_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int32x4_t v69;
  __int32 v70;
  __int32 v71;
  __int32 v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  int32x4_t v76;
  __int32 v77;
  __int32 v78;
  __int32 v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int32x4_t v83;
  __int32 v84;
  __int32 v85;
  __int32 v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  int32x4_t v90;
  float32x4_t v91;
  int8x16_t v92;
  __int32 v93;
  float32x4_t v94;
  int8x16_t v95;
  int32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  int32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  int8x16_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      v7 = a2[10];
      v8 = a2[2];
      v9 = 16 * a2[11].i32[0];
      v10 = 16 * a2[3].i32[0];
      v11 = 16 * v4;
      v12.i64[0] = 0x3F0000003F000000;
      v12.i64[1] = 0x3F0000003F000000;
      do
      {
        v13 = 0;
        do
        {
          v14 = *(float32x4_t *)(*(_QWORD *)&v7 + v13);
          v15 = (_OWORD *)*((_QWORD *)this + 51);
          v16 = *(float32x4_t *)v15;
          v17 = *((float32x4_t *)v15 + 1);
          v18 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15, 1), vmulq_n_f32(v14, COERCE_FLOAT(*v15)));
          v19 = vmulq_f32(v18, v18);
          v21 = *((float32x4_t *)v15 + 2);
          v20 = *((float32x4_t *)v15 + 3);
          v22 = vmulq_f32(v18, v19);
          v23 = vaddq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v20.f32, 1)), vmulq_laneq_f32(v19, v20, 2));
          v24 = vmulq_laneq_f32(v22, v20, 3);
          v25 = *((float32x4_t *)v15 + 4);
          v26 = *((float32x4_t *)v15 + 5);
          v27 = vmaxq_f32(vaddq_f32(v23, v24), v25);
          v28 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1), v26);
          v29 = vminq_f32(v27, v28);
          v30 = vcvtq_f32_s32(vcvtq_s32_f32(v29));
          v31 = vsubq_f32(v30, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v30, v29)));
          v32 = vsubq_f32(v29, v31);
          v33 = vmulq_f32(v17, v31);
          v34 = vmulq_f32(v17, vsubq_f32(vminq_f32(vaddq_f32(v26, v31), v28), v31));
          v35 = *((int8x16_t *)v15 + 6);
          v36 = vaddq_f32(*((float32x4_t *)v15 + 7), (float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v33, (float32x4_t)vrev64q_s32((int32x4_t)v33)), vextq_s8((int8x16_t)v31, (int8x16_t)v31, 4uLL)));
          v37 = a2[12];
          v38 = vaddq_f32(vsubq_f32(v36, v6), v12);
          v39 = vcvtq_s32_f32(v38);
          v38.i64[0] = vaddq_s32(v39, vcgtq_f32(vcvtq_f32_s32(v39), v38)).u64[0];
          v40 = v38.i32[1];
          v41 = a2[13].i32[0];
          v42 = (float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v34, v36), (int8x16_t)v36);
          v43 = vaddq_f32(vsubq_f32(v42, v6), v12);
          v44 = v38.i32[0];
          v45 = vcvtq_s32_f32(v43);
          v45.i64[0] = vaddq_s32(v45, vcgtq_f32(vcvtq_f32_s32(v45), v43)).u64[0];
          v46 = v45.i32[1];
          v47 = v44 + v40 * v41;
          v48 = v45.i32[0];
          v49 = (float32x4_t)vrev64q_s32((int32x4_t)v34);
          v50 = *(float32x4_t *)(*(_QWORD *)&v37 + 16 * v47);
          v51 = (float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v49, v42), (int8x16_t)v36);
          v52 = vaddq_f32(vsubq_f32(v51, v6), v12);
          v53 = vcvtq_s32_f32(v52);
          v54 = v48 + v46 * v41;
          v53.i64[0] = vaddq_s32(v53, vcgtq_f32(vcvtq_f32_s32(v53), v52)).u64[0];
          v55 = v53.i32[1];
          v56 = *(float32x4_t *)(*(_QWORD *)&v37 + 16 * v54);
          v57 = v53.i32[0];
          v58 = (int8x16_t)vsubq_f32(v51, v34);
          v59 = (float32x4_t)vbslq_s8(v35, v58, (int8x16_t)v36);
          v60 = vaddq_f32(vsubq_f32(v59, v6), v12);
          v61 = v57 + v55 * v41;
          v62 = vcvtq_s32_f32(v60);
          v60.i64[0] = vaddq_s32(v62, vcgtq_f32(vcvtq_f32_s32(v62), v60)).u64[0];
          v63 = v60.i32[1];
          v64 = v60.i32[0];
          v65 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v34, (int8x16_t)v34, 4uLL), v59);
          v66 = (float32x4_t)vbslq_s8(v35, v58, v65);
          v67 = *(float32x4_t *)(*(_QWORD *)&v37 + 16 * v61);
          v68 = vaddq_f32(vsubq_f32(v66, v6), v12);
          v69 = vcvtq_s32_f32(v68);
          v70 = v64 + v63 * v41;
          v68.i64[0] = vaddq_s32(v69, vcgtq_f32(vcvtq_f32_s32(v69), v68)).u64[0];
          v71 = v68.i32[1];
          v72 = v68.i32[0];
          v73 = *(float32x4_t *)(*(_QWORD *)&v37 + 16 * v70);
          v74 = (float32x4_t)vbslq_s8(v35, (int8x16_t)vsubq_f32(v66, v49), v65);
          v75 = vaddq_f32(vsubq_f32(v74, v6), v12);
          v76 = vcvtq_s32_f32(v75);
          v77 = v72 + v71 * v41;
          v75.i64[0] = vaddq_s32(v76, vcgtq_f32(vcvtq_f32_s32(v76), v75)).u64[0];
          v78 = v75.i32[1];
          v79 = v75.i32[0];
          v80 = (float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v34, v74), v65);
          v81 = vaddq_f32(vsubq_f32(v80, v6), v12);
          v82 = *(float32x4_t *)(*(_QWORD *)&v37 + 16 * v77);
          v83 = vcvtq_s32_f32(v81);
          v81.i64[0] = vaddq_s32(v83, vcgtq_f32(vcvtq_f32_s32(v83), v81)).u64[0];
          v84 = v81.i32[1];
          v85 = v79 + v78 * v41;
          v86 = v81.i32[0];
          v87 = (float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v49, v80), v65);
          v88 = *(float32x4_t *)(*(_QWORD *)&v37 + 16 * v85);
          v89 = vaddq_f32(vsubq_f32(v87, v6), v12);
          v90 = vcvtq_s32_f32(v89);
          v89.i64[0] = vaddq_s32(v90, vcgtq_f32(vcvtq_f32_s32(v90), v89)).u64[0];
          v91 = *((float32x4_t *)v15 + 8);
          v92 = *((int8x16_t *)v15 + 9);
          *(int8x8_t *)v81.f32 = vqtbl1_s8((int8x16_t)v32, *(int8x8_t *)v91.f32);
          *(int8x8_t *)&v81.u32[2] = vqtbl1_s8((int8x16_t)v32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v91, (int8x16_t)v91, 8uLL));
          *(int8x8_t *)v91.f32 = vqtbl1_s8((int8x16_t)v32, *(int8x8_t *)v92.i8);
          v93 = v89.i32[1];
          *(int8x8_t *)&v91.u32[2] = vqtbl1_s8((int8x16_t)v32, (int8x8_t)*(_OWORD *)&vextq_s8(v92, v92, 8uLL));
          v94 = *((float32x4_t *)v15 + 10);
          v95 = *((int8x16_t *)v15 + 11);
          LODWORD(v15) = v89.i32[0];
          v96 = (int32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v91, v81));
          v97 = *(float32x4_t *)(*(_QWORD *)&v37 + 16 * (v86 + v84 * v41));
          *(int8x8_t *)v98.f32 = vqtbl1_s8((int8x16_t)v32, *(int8x8_t *)v94.f32);
          *(int8x8_t *)&v98.u32[2] = vqtbl1_s8((int8x16_t)v32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v94, (int8x16_t)v94, 8uLL));
          v91.i64[0] = vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v32), v32)).u64[0];
          *(int8x8_t *)v94.f32 = vqtbl1_s8((int8x16_t)v32, *(int8x8_t *)v95.i8);
          v99 = *(float32x4_t *)(*(_QWORD *)&v37 + 16 * ((int)v15 + v93 * v41));
          *(int8x8_t *)&v94.u32[2] = vqtbl1_s8((int8x16_t)v32, (int8x8_t)*(_OWORD *)&vextq_s8(v95, v95, 8uLL));
          v100 = (int32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgeq_f32(v94, v98));
          v101 = vmulq_lane_f32(vsubq_f32(v73, v50), *(float32x2_t *)v32.f32, 1);
          v102 = vmulq_n_f32(vsubq_f32(v99, v82), v32.f32[0]);
          v103 = vmulq_n_f32(vsubq_f32(v97, v88), v32.f32[0]);
          v104 = vmulq_laneq_f32(vsubq_f32(v88, v50), v32, 2);
          v105 = vmulq_lane_f32(vsubq_f32(v99, v97), *(float32x2_t *)v32.f32, 1);
          v106 = vmulq_lane_f32(vsubq_f32(v82, v88), *(float32x2_t *)v32.f32, 1);
          v107 = (int8x16_t)vaddq_f32(vmulq_laneq_f32(vsubq_f32(v82, v73), v32, 2), vaddq_f32(v101, v102));
          v108 = vmulq_n_f32(vsubq_f32(v56, v50), v32.f32[0]);
          v109 = vmulq_laneq_f32(vsubq_f32(v99, v67), v32, 2);
          v110 = vaddq_f32(vmulq_n_f32(vsubq_f32(v67, v73), v32.f32[0]), v101);
          v111 = (float32x4_t)vdupq_laneq_s32(v100, 2);
          *(int8x16_t *)(*(_QWORD *)&v8 + v13) = vbslq_s8((int8x16_t)vcgtq_f32(v25, v21), (int8x16_t)v14, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), vmulq_laneq_f32(vaddq_f32(v50, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32(v100, 3), v111), v25), (int8x16_t)vaddq_f32(vmulq_laneq_f32(vsubq_f32(v97, v56), v32, 2), vaddq_f32(v108, v105)),
                                                                                   vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32(v111, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v91.f32, 0)), v25), (int8x16_t)vaddq_f32(v110, v109), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32(v96, 3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v100.i8, 1)), v25), (int8x16_t)vaddq_f32(vaddq_f32(v108, vmulq_lane_f32(vsubq_f32(v67, v56), *(float32x2_t *)v32.f32, 1)), v109), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v100.i8, 0), (float32x4_t)vdupq_laneq_s32(v96, 2)), v25), (int8x16_t)vaddq_f32(v104, vaddq_f32(v106, v102)), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v96.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v96.i8, 1)), v25), (int8x16_t)vaddq_f32(v104, vaddq_f32(v103, v105)),
                                                                                           v107)))))),
                                                                  v16,
                                                                  2)));
          v13 += 16;
        }
        while (v11 != v13);
        ++v5;
        *(_QWORD *)&v7 += v9;
        *(_QWORD *)&v8 += v10;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcApply3DLUTTetrahedralFast_basekernel::GetDOD(HgcApply3DLUTTetrahedralFast_basekernel *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 1)
    return 0x8000000080000000;
  if (a3)
    return 0;
  return *(_QWORD *)&a4.var0;
}

uint64_t HgcApply3DLUTTetrahedralFast_basekernel::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, 1u);
    return HGRenderer::GetDOD(a2, Input);
  }
  else if (a3)
  {
    return 0;
  }
  else
  {
    return *(_QWORD *)&a4.var0;
  }
}

void HgcApply3DLUTTetrahedralFast_basekernel::HgcApply3DLUTTetrahedralFast_basekernel(HgcApply3DLUTTetrahedralFast_basekernel *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6545F80;
  v3 = (_OWORD *)operator new();
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  __asm { FMOV            V1.4S, #1.0 }
  v3[4] = 0u;
  v3[5] = _Q1;
  v3[6] = xmmword_1B3050E20;
  v3[7] = xmmword_1B3052100;
  v3[8] = xmmword_1B3553D10;
  v3[9] = xmmword_1B3553D20;
  v3[10] = xmmword_1B3553D30;
  v3[11] = xmmword_1B3553D40;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcApply3DLUTTetrahedralFast_basekernel *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BDDBF8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcApply3DLUTTetrahedralFast_basekernel::~HgcApply3DLUTTetrahedralFast_basekernel(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6545F80;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C408070C27FLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6545F80;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C408070C27FLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6545F80;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C408070C27FLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcApply3DLUTTetrahedralFast_basekernel::SetParameter(HgcApply3DLUTTetrahedralFast_basekernel *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcApply3DLUTTetrahedralFast_basekernel::GetParameter(HgcApply3DLUTTetrahedralFast_basekernel *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcPixelFormatConversion_kV4F_WXYZ_input::GetProgram(HgcPixelFormatConversion_kV4F_WXYZ_input *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000023d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0.yzwx) - hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=7f28c0de:80e0121d:8aa6daeb:92eb6aac\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000022f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0.yzwx - hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=3c877c69:34cadceb:acdc9199:d64abffa\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001fd\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0.yzwx - hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=2fa037b7:8cefdd5b:5f08de08:8c22b023\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4F_WXYZ_input::InitProgramDescriptor(HgcPixelFormatConversion_kV4F_WXYZ_input *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4F_WXYZ_input_hgc_visible", "//Metal1.0     \n//LEN=0000000121\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4F_WXYZ_input_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0.yzwx - hg_Params[0];\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BDE054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BDE084(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BDE07CLL);
}

double HgcPixelFormatConversion_kV4F_WXYZ_input::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x30uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3553C20;
  strcpy(v3, "HgcPixelFormatConversion_kV4F_WXYZ_input [hgc1]");
  return *(double *)"XYZ_input [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_input::BindTexture(HgcPixelFormatConversion_kV4F_WXYZ_input *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_input::Bind(HgcPixelFormatConversion_kV4F_WXYZ_input *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcPixelFormatConversion_kV4F_WXYZ_input *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_input::RenderTile(HgcPixelFormatConversion_kV4F_WXYZ_input *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  int8x16_t *v4;
  float32x4_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int8x16_t *v11;
  float32x4_t *v12;
  unint64_t v13;
  float32x4_t *v14;
  int8x16_t *v15;
  uint64_t v16;
  int8x16_t *v17;
  float32x4_t *v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t *v23;
  int8x16_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (int8x16_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v25 = 0;
        v26 = 16 * v7;
        v27 = 16 * v6;
        v28 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v29 = 0;
          do
          {
            v5[v29 / 0x10] = vsubq_f32((float32x4_t)vextq_s8(v4[v29 / 0x10], v4[v29 / 0x10], 4uLL), *(float32x4_t *)*((_QWORD *)this + 51));
            v29 += 16;
          }
          while (v28 != v29);
          ++v25;
          v4 = (int8x16_t *)((char *)v4 + v26);
          v5 = (float32x4_t *)((char *)v5 + v27);
        }
        while (v25 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = v14;
          v19 = *(float32x4_t *)*((_QWORD *)this + 51);
          v20 = vsubq_f32((float32x4_t)vextq_s8(v4[v16 - 1], v4[v16 - 1], 4uLL), v19);
          v21 = vsubq_f32((float32x4_t)vextq_s8(v4[v16], v4[v16], 4uLL), v19);
          v22 = vsubq_f32((float32x4_t)vextq_s8(v4[v16 + 1], v4[v16 + 1], 4uLL), v19);
          v23 = &v5[v16];
          v23[-2] = vsubq_f32((float32x4_t)vextq_s8(v4[v16 - 2], v4[v16 - 2], 4uLL), v19);
          v23[-1] = v20;
          v13 += 4;
          *v23 = v21;
          v23[1] = v22;
          v16 += 4;
          v15 += 4;
          v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v24 = *v17++;
            *v18++ = vsubq_f32((float32x4_t)vextq_s8(v24, v24, 4uLL), *(float32x4_t *)*((_QWORD *)this + 51));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (float32x4_t *)((char *)v5 + v9);
        v4 = (int8x16_t *)((char *)v4 + v10);
        v11 = (int8x16_t *)((char *)v11 + v10);
        v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_input::GetDOD(HgcPixelFormatConversion_kV4F_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_input::GetROI(HgcPixelFormatConversion_kV4F_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcPixelFormatConversion_kV4F_WXYZ_input::HgcPixelFormatConversion_kV4F_WXYZ_input(HgcPixelFormatConversion_kV4F_WXYZ_input *this)
{
  _QWORD *v2;
  _QWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65461E8;
  v3 = (_QWORD *)operator new();
  *v3 = 0;
  v3[1] = 0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BDE3F0(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4F_WXYZ_input::~HgcPixelFormatConversion_kV4F_WXYZ_input(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65461E8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E65461E8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65461E8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_input::SetParameter(HgcPixelFormatConversion_kV4F_WXYZ_input *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcPixelFormatConversion_kV4F_WXYZ_input::GetParameter(HgcPixelFormatConversion_kV4F_WXYZ_input *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcPixelFormatConversion_kV4S_WXYZ_input::GetProgram(HgcPixelFormatConversion_kV4S_WXYZ_input *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000023d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0.yzwx) - hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=7f28c0de:80e0121d:8aa6daeb:92eb6aac\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000022f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0.yzwx - hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=3c877c69:34cadceb:acdc9199:d64abffa\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001fd\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0.yzwx - hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=2fa037b7:8cefdd5b:5f08de08:8c22b023\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4S_WXYZ_input::InitProgramDescriptor(HgcPixelFormatConversion_kV4S_WXYZ_input *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4S_WXYZ_input_hgc_visible", "//Metal1.0     \n//LEN=0000000121\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4S_WXYZ_input_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0.yzwx - hg_Params[0];\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BDE828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BDE858(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BDE850);
}

double HgcPixelFormatConversion_kV4S_WXYZ_input::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x30uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3553C20;
  strcpy(v3, "HgcPixelFormatConversion_kV4S_WXYZ_input [hgc1]");
  return *(double *)"XYZ_input [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_input::BindTexture(HgcPixelFormatConversion_kV4S_WXYZ_input *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_input::Bind(HgcPixelFormatConversion_kV4S_WXYZ_input *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcPixelFormatConversion_kV4S_WXYZ_input *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_input::RenderTile(HgcPixelFormatConversion_kV4S_WXYZ_input *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  int8x16_t *v4;
  float32x4_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int8x16_t *v11;
  float32x4_t *v12;
  unint64_t v13;
  float32x4_t *v14;
  int8x16_t *v15;
  uint64_t v16;
  int8x16_t *v17;
  float32x4_t *v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t *v23;
  int8x16_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (int8x16_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v25 = 0;
        v26 = 16 * v7;
        v27 = 16 * v6;
        v28 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v29 = 0;
          do
          {
            v5[v29 / 0x10] = vsubq_f32((float32x4_t)vextq_s8(v4[v29 / 0x10], v4[v29 / 0x10], 4uLL), *(float32x4_t *)*((_QWORD *)this + 51));
            v29 += 16;
          }
          while (v28 != v29);
          ++v25;
          v4 = (int8x16_t *)((char *)v4 + v26);
          v5 = (float32x4_t *)((char *)v5 + v27);
        }
        while (v25 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = v14;
          v19 = *(float32x4_t *)*((_QWORD *)this + 51);
          v20 = vsubq_f32((float32x4_t)vextq_s8(v4[v16 - 1], v4[v16 - 1], 4uLL), v19);
          v21 = vsubq_f32((float32x4_t)vextq_s8(v4[v16], v4[v16], 4uLL), v19);
          v22 = vsubq_f32((float32x4_t)vextq_s8(v4[v16 + 1], v4[v16 + 1], 4uLL), v19);
          v23 = &v5[v16];
          v23[-2] = vsubq_f32((float32x4_t)vextq_s8(v4[v16 - 2], v4[v16 - 2], 4uLL), v19);
          v23[-1] = v20;
          v13 += 4;
          *v23 = v21;
          v23[1] = v22;
          v16 += 4;
          v15 += 4;
          v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v24 = *v17++;
            *v18++ = vsubq_f32((float32x4_t)vextq_s8(v24, v24, 4uLL), *(float32x4_t *)*((_QWORD *)this + 51));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (float32x4_t *)((char *)v5 + v9);
        v4 = (int8x16_t *)((char *)v4 + v10);
        v11 = (int8x16_t *)((char *)v11 + v10);
        v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_input::GetDOD(HgcPixelFormatConversion_kV4S_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_input::GetROI(HgcPixelFormatConversion_kV4S_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcPixelFormatConversion_kV4S_WXYZ_input::HgcPixelFormatConversion_kV4S_WXYZ_input(HgcPixelFormatConversion_kV4S_WXYZ_input *this)
{
  _QWORD *v2;
  _QWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6546450;
  v3 = (_QWORD *)operator new();
  *v3 = 0;
  v3[1] = 0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BDEBC4(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4S_WXYZ_input::~HgcPixelFormatConversion_kV4S_WXYZ_input(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6546450;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6546450;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6546450;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_input::SetParameter(HgcPixelFormatConversion_kV4S_WXYZ_input *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcPixelFormatConversion_kV4S_WXYZ_input::GetParameter(HgcPixelFormatConversion_kV4S_WXYZ_input *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcColorGamma_v216_yxzx_collapse::GetProgram(HgcColorGamma_v216_yxzx_collapse *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002a9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = (half3) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    r1.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    output.color0.xyz = float3(r0.yxz);\n"
             "    output.color0.w = float(r1.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8e7771c2:a06a6c11:9daa802a:96046119\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000028d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    r1.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    output.color0.xyz = r0.yxz;\n"
             "    output.color0.w = r1.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=1f020ce8:91e1b790:66920186:95589d9d\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000243\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xyz = texture2D(hg_Texture0, hg_TexCoord0.xy).xyz;\n"
           "    r1.x = texture2D(hg_Texture0, hg_TexCoord1.xy).x;\n"
           "    gl_FragColor.xyz = r0.yxz;\n"
           "    gl_FragColor.w = r1.x;\n"
           "}\n"
           "//MD5=36e2a11e:fad481c4:33936514:6896479c\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcColorGamma_v216_yxzx_collapse::InitProgramDescriptor(HgcColorGamma_v216_yxzx_collapse *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_v216_yxzx_collapse_hgc_visible", "//Metal1.0     \n//LEN=00000001f0\n[[ visible ]] FragmentOut HgcColorGamma_v216_yxzx_collapse_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).xyz;\n"
    "    r1.x = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).x;\n"
    "    output.color0.xyz = r0.yxz;\n"
    "    output.color0.w = r1.x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BDF1C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BDF200(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BDF1F8);
}

char *HgcColorGamma_v216_yxzx_collapse::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D10;
  strcpy(result, "HgcColorGamma_v216_yxzx_collapse [hgc1]");
  return result;
}

uint64_t HgcColorGamma_v216_yxzx_collapse::BindTexture(HgcColorGamma_v216_yxzx_collapse *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  return 0;
}

uint64_t HgcColorGamma_v216_yxzx_collapse::Bind(HgcColorGamma_v216_yxzx_collapse *this, HGHandler *a2)
{
  (*(void (**)(HgcColorGamma_v216_yxzx_collapse *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcColorGamma_v216_yxzx_collapse::RenderTile(HgcColorGamma_v216_yxzx_collapse *this, HGTile *a2)
{
  int v2;
  int v3;
  uint64_t v4;
  int v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int8x16_t *v10;
  uint64_t v11;
  int v12;
  int8x16_t *v13;
  int8x16_t *v14;
  int8x16_t v15;
  int8x16_t v16;
  uint64_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x8_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  uint64_t v26;
  unsigned int v27;
  int8x16_t v28;
  uint64_t v29;
  int8x16_t v30;
  int8x16_t v31;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *(int *)a2;
    v5 = *((_DWORD *)a2 + 2) - v4;
    v6 = (int8x16_t *)*((_QWORD *)a2 + 2);
    v7 = *((_QWORD *)a2 + 10) + 16 * v4;
    v8 = *((int *)a2 + 22);
    v9 = v7 + 64;
    v10 = v6 + 2;
    v11 = 16 * *((int *)a2 + 6);
    while (v5 < 4)
    {
      LODWORD(v26) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += 16 * v8;
      ++v3;
      v9 += 16 * v8;
      v10 = (int8x16_t *)((char *)v10 + v11);
      v6 = (int8x16_t *)((char *)v6 + v11);
      if (v3 == v2)
        return 0;
    }
    v12 = 0;
    v13 = v10;
    v14 = (int8x16_t *)v9;
    do
    {
      v15 = v14[-4];
      v16 = v14[-2];
      v17 = *((_QWORD *)this + 51);
      v18 = *(int8x16_t *)(v17 + 16);
      *(int8x8_t *)v19.i8 = vqtbl1_s8(v15, *(int8x8_t *)v17);
      v20 = (int8x8_t)vextq_s8(*(int8x16_t *)v17, *(int8x16_t *)v17, 8uLL).u64[0];
      v19.u64[1] = (unint64_t)vqtbl1_s8(v15, v20);
      *(int8x8_t *)v15.i8 = vqtbl1_s8(v16, *(int8x8_t *)v17);
      v15.u64[1] = (unint64_t)vqtbl1_s8(v16, v20);
      *(int8x8_t *)v16.i8 = vqtbl1_s8(*v14, *(int8x8_t *)v17);
      v16.u64[1] = (unint64_t)vqtbl1_s8(*v14, v20);
      v21 = v14[2];
      *(int8x8_t *)v22.i8 = vqtbl1_s8(v21, *(int8x8_t *)v17);
      v22.u64[1] = (unint64_t)vqtbl1_s8(v21, v20);
      v23 = vbslq_s8(v18, vextq_s8(v14[-1], v14[-1], 4uLL), v15);
      v24 = vbslq_s8(v18, vextq_s8(v14[1], v14[1], 4uLL), v16);
      v25 = vbslq_s8(v18, vextq_s8(v14[3], v14[3], 4uLL), v22);
      v13[-2] = vbslq_s8(v18, vextq_s8(v14[-3], v14[-3], 4uLL), v19);
      v13[-1] = v23;
      *v13 = v24;
      v13[1] = v25;
      v13 += 4;
      v14 += 8;
      v12 -= 4;
    }
    while (v5 + v12 > 3);
    LODWORD(v26) = -v12;
    if (-v12 >= v5)
      goto LABEL_3;
LABEL_10:
    v27 = 2 * v26;
    v26 = v26;
    do
    {
      v28 = *(int8x16_t *)(v7 + 16 * v27);
      v29 = *((_QWORD *)this + 51);
      *(int8x8_t *)v30.i8 = vqtbl1_s8(v28, *(int8x8_t *)v29);
      v31 = *(int8x16_t *)(v7 + 16 * (v27 + 1));
      v30.u64[1] = (unint64_t)vqtbl1_s8(v28, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v29, *(int8x16_t *)v29, 8uLL));
      v6[v26++] = vbslq_s8(*(int8x16_t *)(v29 + 16), vextq_s8(v31, v31, 4uLL), v30);
      v27 += 2;
    }
    while (v26 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcColorGamma_v216_yxzx_collapse::GetDOD(HgcColorGamma_v216_yxzx_collapse *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  float v9;
  double v10;
  float v11;
  double v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0, 0, 0xFFFFFFFF, 0);
  v8 = HGRectGrow(v6, v5, v7);
  v9 = HGRectFloat(v8);
  v13 = HGRectScale(v9, v10, v11, v12, 0.5);
  v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcColorGamma_v216_yxzx_collapse::GetROI(HgcColorGamma_v216_yxzx_collapse *this, HGRenderer *a2, int a3, HGRect a4)
{
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = HGRectFloat(a4.var0);
  v9 = HGRectScale(v5, v6, v7, v8, 2.0);
  v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  v16 = v15;
  v17 = HGRectMake4i(0, 0, 1u, 0);
  v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcColorGamma_v216_yxzx_collapse::HgcColorGamma_v216_yxzx_collapse(HgcColorGamma_v216_yxzx_collapse *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65466B8;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B3553CA0;
  v3[1] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcColorGamma_v216_yxzx_collapse *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BDF720(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_v216_yxzx_collapse::~HgcColorGamma_v216_yxzx_collapse(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65466B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E65466B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65466B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_v216_yxzx_collapse::SetParameter(HgcColorGamma_v216_yxzx_collapse *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_v216_yxzx_collapse::GetParameter(HgcColorGamma_v216_yxzx_collapse *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcPixelFormatConversion_kV4B10Bit_BE_input::GetProgram(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003c4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(255.0000000, 0.0009775171056, 1024.000000, 1.000000000);\n"
             "    const half4 c1 = half4(4.000000000, 0.01562500000, 0.06250000000, 0.2500000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0.zyxw*c0.xxxx + c0.yyyy;\n"
             "    r0 = floor(r0);\n"
             "    r0 = r0.zyxw*c1;\n"
             "    r1.yz = fract(r0.yz);\n"
             "    r0 = floor(r0);\n"
             "    r2.x = dot(r0.xy, 1.00000h);\n"
             "    r2.yz = r1.yz*c0.zz + r0.zw;\n"
             "    r2.xyz = r2.xyz*c0.yyy;\n"
             "    r2.w = c0.w;\n"
             "    output.color0 = float4(r2);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6362bdc0:22917061:826e61ed:9e40a59e\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003ba\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(255.0000000, 0.0009775171056, 1024.000000, 1.000000000);\n"
             "    const float4 c1 = float4(4.000000000, 0.01562500000, 0.06250000000, 0.2500000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0.zyxw*c0.xxxx + c0.yyyy;\n"
             "    r0 = floor(r0);\n"
             "    r0 = r0.zyxw*c1;\n"
             "    r1.yz = fract(r0.yz);\n"
             "    r0 = floor(r0);\n"
             "    r2.x = dot(r0.xy, 1.00000f);\n"
             "    r2.yz = r1.yz*c0.zz + r0.zw;\n"
             "    r2.xyz = r2.xyz*c0.yyy;\n"
             "    r2.w = c0.w;\n"
             "    output.color0 = r2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=0e872e95:a0ea5bda:b3df1f87:fc314c5e\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000368\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(255.0000000, 0.0009775171056, 1024.000000, 1.000000000);\n"
           "    const mediump vec4 c1 = vec4(4.000000000, 0.01562500000, 0.06250000000, 0.2500000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0.zyxw*c0.xxxx + c0.yyyy;\n"
           "    r0 = floor(r0);\n"
           "    r0 = r0.zyxw*c1;\n"
           "    r1.yz = fract(r0.yz);\n"
           "    r0 = floor(r0);\n"
           "    r2.x = dot(r0.xy, vec2(1.00000));\n"
           "    r2.yz = r1.yz*c0.zz + r0.zw;\n"
           "    r2.xyz = r2.xyz*c0.yyy;\n"
           "    r2.w = c0.w;\n"
           "    gl_FragColor = r2;\n"
           "}\n"
           "//MD5=3ba21b75:19572493:8b20e9c9:500e949a\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4B10Bit_BE_input::InitProgramDescriptor(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4B10Bit_BE_input_hgc_visible", "//Metal1.0     \n//LEN=00000002af\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4B10Bit_BE_input_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(255.0000000, 0.0009775171056, 1024.000000, 1.000000000);\n"
    "    const float4 c1 = float4(4.000000000, 0.01562500000, 0.06250000000, 0.2500000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0.zyxw*c0.xxxx + c0.yyyy;\n"
    "    r0 = floor(r0);\n"
    "    r0 = r0.zyxw*c1;\n"
    "    r1.yz = fract(r0.yz);\n"
    "    r0 = floor(r0);\n"
    "    r2.x = dot(r0.xy, 1.00000f);\n"
    "    r2.yz = r1.yz*c0.zz + r0.zw;\n"
    "    r2.xyz = r2.xyz*c0.yyy;\n"
    "    r2.w = c0.w;\n"
    "    output.color0 = r2;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BDFAC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BDFAF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BDFAE8);
}

double HgcPixelFormatConversion_kV4B10Bit_BE_input::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x38uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B309DA80;
  strcpy(v3, "HgcPixelFormatConversion_kV4B10Bit_BE_input [hgc1]");
  return *(double *)"it_BE_input [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_input::BindTexture(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_input::Bind(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, HGHandler *a2)
{
  (*(void (**)(HgcPixelFormatConversion_kV4B10Bit_BE_input *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_input::RenderTile(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, HGTile *a2, int8x16_t a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int8x16_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  uint64_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x8_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  __int128 v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  int8x16_t v50;
  int8x16_t v51;
  int8x16_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t *v58;
  uint64_t v59;
  int8x16_t v60;
  uint64_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x8_t v64;
  int8x16_t v65;
  float32x4_t v66;
  float32x4_t v67;
  int8x16_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;

  v3 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v6 = *((_QWORD *)a2 + 2);
    v7 = *((_QWORD *)a2 + 10);
    v8 = 16 * *((int *)a2 + 22);
    v9 = 16 * *((int *)a2 + 6);
    a3.i32[0] = 1.0;
    while (v5 < 4)
    {
      LODWORD(v59) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v7 += v8;
      v6 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 32;
    do
    {
      v12 = *(int8x16_t *)(v7 + v11 - 32);
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v14 = *(float32x4_t *)(v7 + v11);
      v15 = *(int8x16_t *)(v7 + v11 + 16);
      v16 = *((_QWORD *)this + 51);
      v17 = *(float32x4_t *)(v16 + 16);
      *(int8x8_t *)v18.f32 = vqtbl1_s8(v12, *(int8x8_t *)v16);
      v19 = (int8x8_t)vextq_s8(*(int8x16_t *)v16, *(int8x16_t *)v16, 8uLL).u64[0];
      *(int8x8_t *)v20.f32 = vqtbl1_s8((int8x16_t)v13, *(int8x8_t *)v16);
      *(int8x8_t *)&v18.u32[2] = vqtbl1_s8(v12, v19);
      *(int8x8_t *)&v20.u32[2] = vqtbl1_s8((int8x16_t)v13, v19);
      *(int8x8_t *)v13.f32 = vqtbl1_s8((int8x16_t)v14, *(int8x8_t *)v16);
      *(int8x8_t *)&v13.u32[2] = vqtbl1_s8((int8x16_t)v14, v19);
      *(int8x8_t *)v14.f32 = vqtbl1_s8(v15, *(int8x8_t *)v16);
      *(int8x8_t *)&v14.u32[2] = vqtbl1_s8(v15, v19);
      v22 = *(float32x4_t *)(v16 + 32);
      v21 = *(int8x16_t *)(v16 + 48);
      v23 = vaddq_f32(v17, vmulq_f32(v18, v22));
      v24 = vaddq_f32(v17, vmulq_f32(v20, v22));
      v25 = vaddq_f32(v17, vmulq_f32(v13, v22));
      v26 = vaddq_f32(v17, vmulq_f32(v14, v22));
      v27 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
      v28 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
      v29 = vcvtq_f32_s32(vcvtq_s32_f32(v25));
      v30 = vcvtq_f32_s32(vcvtq_s32_f32(v26));
      v31 = vsubq_f32(v27, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v27, v23)));
      v32 = vsubq_f32(v28, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v28, v24)));
      v33 = (int8x16_t)vsubq_f32(v29, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v29, v25)));
      v34 = (int8x16_t)vsubq_f32(v30, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v30, v26)));
      *(int8x8_t *)v24.f32 = vqtbl1_s8((int8x16_t)v31, *(int8x8_t *)v16);
      *(int8x8_t *)&v24.u32[2] = vqtbl1_s8((int8x16_t)v31, v19);
      *(int8x8_t *)v31.f32 = vqtbl1_s8((int8x16_t)v32, *(int8x8_t *)v16);
      *(int8x8_t *)&v31.u32[2] = vqtbl1_s8((int8x16_t)v32, v19);
      *(int8x8_t *)v32.f32 = vqtbl1_s8(v33, *(int8x8_t *)v16);
      *(int8x8_t *)v35.f32 = vqtbl1_s8(v34, *(int8x8_t *)v16);
      *(int8x8_t *)&v32.u32[2] = vqtbl1_s8(v33, v19);
      *(int8x8_t *)&v35.u32[2] = vqtbl1_s8(v34, v19);
      v36 = *(float32x4_t *)(v16 + 64);
      v37 = *(_OWORD *)(v16 + 80);
      v38 = vmulq_f32(v24, v36);
      v39 = vmulq_f32(v31, v36);
      v40 = vmulq_f32(v32, v36);
      v41 = vmulq_f32(v36, v35);
      v42 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
      v43 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
      v45 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v46 = vsubq_f32(v42, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v42, v38)));
      v47 = vsubq_f32(v43, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v43, v39)));
      v48 = vsubq_f32(v44, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v44, v40)));
      v49 = vsubq_f32(v45, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v45, v41)));
      v50 = (int8x16_t)vaddq_f32(v49, (float32x4_t)vrev64q_s32((int32x4_t)v49));
      v51 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v49, a3, 4uLL), vmulq_lane_f32(vsubq_f32(v41, v49), *(float32x2_t *)&v37, 1));
      v52 = *(int8x16_t *)(v16 + 96);
      v53 = (float32x4_t)vbslq_s8(v52, v50, v51);
      v54 = vmulq_f32(v17, (float32x4_t)vbslq_s8(v52, (int8x16_t)vaddq_f32(v46, (float32x4_t)vrev64q_s32((int32x4_t)v46)), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v46, a3, 4uLL), vmulq_lane_f32(vsubq_f32(v38, v46), *(float32x2_t *)&v37, 1))));
      v55 = vmulq_f32(v17, (float32x4_t)vbslq_s8(*(int8x16_t *)(v16 + 96), (int8x16_t)vaddq_f32(v47, (float32x4_t)vrev64q_s32((int32x4_t)v47)), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v47, a3, 4uLL), vmulq_lane_f32(vsubq_f32(v39, v47), *(float32x2_t *)&v37, 1))));
      v56 = vmulq_f32(v17, (float32x4_t)vbslq_s8(*(int8x16_t *)(v16 + 96), (int8x16_t)vaddq_f32(v48, (float32x4_t)vrev64q_s32((int32x4_t)v48)), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v48, a3, 4uLL), vmulq_lane_f32(vsubq_f32(v40, v48), *(float32x2_t *)&v37, 1))));
      v54.i32[3] = 1.0;
      v55.i32[3] = 1.0;
      v56.i32[3] = 1.0;
      v57 = vmulq_f32(v17, v53);
      v57.i32[3] = 1.0;
      v58 = (float32x4_t *)(v6 + v11);
      v58[-2] = v54;
      v58[-1] = v55;
      *v58 = v56;
      v58[1] = v57;
      v10 -= 4;
      v11 += 64;
    }
    while (v5 + v10 > 3);
    LODWORD(v59) = -v10;
    if ((int)v59 >= v5)
      goto LABEL_3;
LABEL_10:
    v59 = v59;
    do
    {
      v60 = *(int8x16_t *)(v7 + 16 * v59);
      v61 = *((_QWORD *)this + 51);
      v62 = *(float32x4_t *)(v61 + 16);
      *(int8x8_t *)v63.f32 = vqtbl1_s8(v60, *(int8x8_t *)v61);
      v64 = (int8x8_t)vextq_s8(*(int8x16_t *)v61, *(int8x16_t *)v61, 8uLL).u64[0];
      *(int8x8_t *)&v63.u32[2] = vqtbl1_s8(v60, v64);
      v65 = *(int8x16_t *)(v61 + 48);
      v66 = vaddq_f32(v62, vmulq_f32(v63, *(float32x4_t *)(v61 + 32)));
      v67 = vcvtq_f32_s32(vcvtq_s32_f32(v66));
      v68 = (int8x16_t)vsubq_f32(v67, (float32x4_t)vandq_s8(v65, (int8x16_t)vcgtq_f32(v67, v66)));
      *(int8x8_t *)v69.f32 = vqtbl1_s8(v68, *(int8x8_t *)v61);
      *(int8x8_t *)&v69.u32[2] = vqtbl1_s8(v68, v64);
      v70 = vmulq_f32(*(float32x4_t *)(v61 + 64), v69);
      v71 = vcvtq_f32_s32(vcvtq_s32_f32(v70));
      v72 = vsubq_f32(v71, (float32x4_t)vandq_s8(v65, (int8x16_t)vcgtq_f32(v71, v70)));
      v73 = vmulq_f32(v62, (float32x4_t)vbslq_s8(*(int8x16_t *)(v61 + 96), (int8x16_t)vaddq_f32(v72, (float32x4_t)vrev64q_s32((int32x4_t)v72)), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v72, a3, 4uLL), vmulq_lane_f32(vsubq_f32(v70, v72), *(float32x2_t *)(v61 + 80), 1))));
      v73.i32[3] = 1.0;
      *(float32x4_t *)(v6 + 16 * v59++) = v73;
    }
    while (v59 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_input::GetDOD(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_input::GetROI(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcPixelFormatConversion_kV4B10Bit_BE_input::HgcPixelFormatConversion_kV4B10Bit_BE_input(HgcPixelFormatConversion_kV4B10Bit_BE_input *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6546920;
  v3 = operator new();
  *(_OWORD *)v3 = xmmword_1B35540E0;
  *(int32x4_t *)(v3 + 16) = vdupq_n_s32(0x3A802008u);
  __asm { FMOV            V0.4S, #1.0 }
  *(int32x4_t *)(v3 + 32) = vdupq_n_s32(0x437F0000u);
  *(_OWORD *)(v3 + 48) = _Q0;
  *(_OWORD *)(v3 + 64) = xmmword_1B35540F0;
  *(_OWORD *)(v3 + 80) = xmmword_1B3554100;
  *(_OWORD *)(v3 + 96) = xmmword_1B3050E20;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BE004C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4B10Bit_BE_input::~HgcPixelFormatConversion_kV4B10Bit_BE_input(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6546920;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6546920;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6546920;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_input::SetParameter(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_input::GetParameter(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcColorGamma_chroma_downsample_f1::GetProgram(HgcColorGamma_chroma_downsample_f1 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000035b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.5000000000, 0.000000000, 0.2500000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy);\n"
             "    r0 = r0*c0.xyyx;\n"
             "    r0 = r1*c0.zwwz + r0;\n"
             "    output.color0 = float4(r2)*float4(c0.zwwz) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=2f81be37:9af8fe44:59c646aa:51f8c5ae\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0000:0003:0000:0000:0000:000e:0000:0003:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000032f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.2500000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy);\n"
             "    r0 = r0*c0.xyyx;\n"
             "    r0 = r1*c0.zwwz + r0;\n"
             "    output.color0 = r2*c0.zwwz + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=a66832cf:ae494a89:e4eb13a9:8c28c8fe\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0000:0003:0000:0000:0000:000e:0000:0003:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000300\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(1.000000000, 0.5000000000, 0.000000000, 0.2500000000);\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture0, hg_TexCoord2.xy);\n"
           "    r0 = r0*c0.xyyx;\n"
           "    r0 = r1*c0.zwwz + r0;\n"
           "    gl_FragColor = r2*c0.zwwz + r0;\n"
           "}\n"
           "//MD5=9c3b26ca:5bc9702c:64a3fe16:6dcbafa3\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0000:0003:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
  }
}

void HgcColorGamma_chroma_downsample_f1::InitProgramDescriptor(HgcColorGamma_chroma_downsample_f1 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_chroma_downsample_f1_hgc_visible", "//Metal1.0     \n//LEN=00000002a4\n[[ visible ]] FragmentOut HgcColorGamma_chroma_downsample_f1_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1,\n    float4 texCoord2)\n{\n    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.2500000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, texCoord0.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, texCoord1.xy);\n"
    "    r2 = hg_Texture0.sample(hg_Sampler0, texCoord2.xy);\n"
    "    r0 = r0*c0.xyyx;\n"
    "    r0 = r1*c0.zwwz + r0;\n"
    "    output.color0 = r2*c0.zwwz + r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BE064C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BE068C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BE0684);
}

double HgcColorGamma_chroma_downsample_f1::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x30uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3554140;
  strcpy(v3, "HgcColorGamma_chroma_downsample_f1 [hgc1]");
  return *(double *)"sample_f1 [hgc1]";
}

uint64_t HgcColorGamma_chroma_downsample_f1::BindTexture(HgcColorGamma_chroma_downsample_f1 *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 1.0, 0.0, 0.0);
  HGHandler::TexCoord(a2, 2, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -1.0, 0.0, 0.0);
  return 0;
}

uint64_t HgcColorGamma_chroma_downsample_f1::Bind(HgcColorGamma_chroma_downsample_f1 *this, HGHandler *a2)
{
  (*(void (**)(HgcColorGamma_chroma_downsample_f1 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcColorGamma_chroma_downsample_f1::RenderTile(HgcColorGamma_chroma_downsample_f1 *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t *v11;
  float32x4_t *v12;
  unint64_t v13;
  unint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  float32x4_t *v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t *v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t *v32;
  float32x4_t v33;
  float32x4_t *v34;
  float32x4_t v35;
  float32x4_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v37 = 0;
        v38 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        v39 = 16 * v7;
        v40 = 16 * v6;
        do
        {
          v41 = 0;
          do
          {
            v5[v41 / 0x10] = vaddq_f32(vmulq_f32(v4[v41 / 0x10 - 1], *(float32x4_t *)(*((_QWORD *)this + 51) + 16)), vaddq_f32(vmulq_f32(v4[v41 / 0x10], *(float32x4_t *)*((_QWORD *)this + 51)), vmulq_f32(v4[v41 / 0x10 + 1], *(float32x4_t *)(*((_QWORD *)this + 51) + 16))));
            v41 += 16;
          }
          while (v38 != v41);
          ++v37;
          v4 = (float32x4_t *)((char *)v4 + v39);
          v5 = (float32x4_t *)((char *)v5 + v40);
        }
        while (v37 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v7;
      v10 = 16 * v6;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = 0;
        v15 = v12;
        v16 = v11;
        do
        {
          v17 = v16;
          v18 = v15;
          v19 = v4[v13];
          v20 = v4[v13 + 1];
          v21 = v4[v13 + 2];
          v22 = v4[v13 + 3];
          v14 += 4;
          v23 = (float32x4_t *)*((_QWORD *)this + 51);
          v24 = v23[1];
          v25 = vmulq_f32(v20, *v23);
          v26 = vmulq_f32(v21, *v23);
          v27 = vmulq_f32(v20, v24);
          v28 = vmulq_f32(v21, v24);
          v29 = vaddq_f32(vmulq_f32(v4[v13 - 1], v24), vaddq_f32(vmulq_f32(v19, *v23), v27));
          v30 = vaddq_f32(vmulq_f32(v19, v24), vaddq_f32(v25, v28));
          v31 = vaddq_f32(v28, vaddq_f32(vmulq_f32(v22, *v23), vmulq_f32(v4[v13 + 4], v24)));
          v32 = &v5[v13];
          *v32 = v29;
          v32[1] = v30;
          v32[2] = vaddq_f32(v27, vaddq_f32(v26, vmulq_f32(v22, v24)));
          v32[3] = v31;
          v13 += 4;
          v16 += 4;
          v15 = v18 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v14)
        {
          do
          {
            v33 = v17[-1];
            ++v14;
            v34 = (float32x4_t *)*((_QWORD *)this + 51);
            v35 = vmulq_f32(*v17, *v34);
            v36 = v17[1];
            ++v17;
            *v18++ = vaddq_f32(vmulq_f32(v33, v34[1]), vaddq_f32(v35, vmulq_f32(v36, v34[1])));
          }
          while (v14 < v3);
        }
        ++v8;
        v4 = (float32x4_t *)((char *)v4 + v9);
        v5 = (float32x4_t *)((char *)v5 + v10);
        v11 = (float32x4_t *)((char *)v11 + v9);
        v12 = (float32x4_t *)((char *)v12 + v10);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcColorGamma_chroma_downsample_f1::GetDOD(HgcColorGamma_chroma_downsample_f1 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0xFFFFFFFF, 0, 1u, 0);
  return HGRectGrow(v6, v5, v7);
}

uint64_t HgcColorGamma_chroma_downsample_f1::GetROI(HgcColorGamma_chroma_downsample_f1 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0xFFFFFFFF, 0, 1u, 0);
  return HGRectGrow(v6, v5, v7);
}

void HgcColorGamma_chroma_downsample_f1::HgcColorGamma_chroma_downsample_f1(HgcColorGamma_chroma_downsample_f1 *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6546B88;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B3554150;
  v3[1] = xmmword_1B3554160;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcColorGamma_chroma_downsample_f1 *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BE0B78(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_chroma_downsample_f1::~HgcColorGamma_chroma_downsample_f1(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6546B88;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6546B88;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6546B88;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_chroma_downsample_f1::SetParameter(HgcColorGamma_chroma_downsample_f1 *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_chroma_downsample_f1::GetParameter(HgcColorGamma_chroma_downsample_f1 *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcColorGamma_v210_yxzx_rgba_collapse::GetProgram(HgcColorGamma_v210_yxzx_rgba_collapse *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000009de\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.2500000000, 1.000000000, 6.000000000, 0.5000000000);\n"
             "    const half4 c1 = half4(4.000000000, 1.000000000, 0.000000000, 3.000000000);\n"
             "    const half4 c2 = half4(2.000000000, 0.003910068423, 0.9960899353, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    float4 s0, s1, s2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord0.xy*float2(c0.xy);\n"
             "    s0.xy = floor(s0.xy);\n"
             "    s0.xy = s0.xy*float2(c0.zy) + float2(c0.ww);\n"
             "    s1.xyz = floor(frag._texCoord0.xxx);\n"
             "    s1.xyz = s1.xyz - float3(c1.xxx)*floor(s1.xyz/float3(c1.xxx));\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r0.xyz = (half3) hg_Texture0.sample(hg_Sampler0, s2.xy).xyz;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r1.x = (half) hg_Texture0.sample(hg_Sampler0, s2.xy).x;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r2.xyz = (half3) hg_Texture0.sample(hg_Sampler0, s2.xy).xyz;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r3.x = (half) hg_Texture0.sample(hg_Sampler0, s2.xy).x;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r4.xyz = (half3) hg_Texture0.sample(hg_Sampler0, s2.xy).xyz;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s0.xy = s0.xy + hg_Params[0].xy;\n"
             "    s0.xy = s0.xy*hg_Params[0].zw;\n"
             "    r5.x = (half) hg_Texture0.sample(hg_Sampler0, s0.xy).x;\n"
             "    r6.yz = r2.yx;\n"
             "    r6.x = r1.x;\n"
             "    r2.x = r2.z;\n"
             "    r2.y = r3.x;\n"
             "    r2.z = r4.y;\n"
             "    r4.xy = r4.xz;\n"
             "    r4.z = r5.x;\n"
             "    s2.xyz = s1.xyz - float3(c1.www);\n"
             "    s2.xyz = select(float3(r4.xyz), float3(r2.xyz), s2.xyz < 0.00000h);\n"
             "    s0.xyz = s1.xyz - float3(c2.xxx);\n"
             "    s2.xyz = select(s2.xyz, float3(r6.xyz), s0.xyz < 0.00000h);\n"
             "    s1.xyz = s1.xyz - float3(c1.yyy);\n"
             "    s2.xyz = select(s2.xyz, float3(r0.yxz), s1.xyz < 0.00000h);\n"
             "    s2.xyz = fmax(s2.xyz, float3(c2.yyy));\n"
             "    s2.xyz = fmin(s2.xyz, float3(c2.zzz));\n"
             "    s2.w = float(c1.y);\n"
             "    output.color0 = s2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=1c0e69ec:53ecdd8e:097f183e:5cdfa298\n"
             "//SIG=00400000:00000000:00000000:00000001:0003:0001:000a:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000907\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.2500000000, 1.000000000, 6.000000000, 0.5000000000);\n"
             "    const float4 c1 = float4(4.000000000, 1.000000000, 0.000000000, 3.000000000);\n"
             "    const float4 c2 = float4(2.000000000, 0.003910068423, 0.9960899353, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy*c0.xy;\n"
             "    r0.xy = floor(r0.xy);\n"
             "    r0.xy = r0.xy*c0.zy + c0.ww;\n"
             "    r1.xyz = floor(frag._texCoord0.xxx);\n"
             "    r1.xyz = r1.xyz - c1.xxx*floor(r1.xyz/c1.xxx);\n"
             "    r2.xy = r0.xy + hg_Params[0].xy;\n"
             "    r2.xy = r2.xy*hg_Params[0].zw;\n"
             "    r2.xyz = hg_Texture0.sample(hg_Sampler0, r2.xy).xyz;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r3.xy = r0.xy + hg_Params[0].xy;\n"
             "    r3.xy = r3.xy*hg_Params[0].zw;\n"
             "    r3.x = hg_Texture0.sample(hg_Sampler0, r3.xy).x;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r4.xy = r0.xy + hg_Params[0].xy;\n"
             "    r4.xy = r4.xy*hg_Params[0].zw;\n"
             "    r4.xyz = hg_Texture0.sample(hg_Sampler0, r4.xy).xyz;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r5.xy = r0.xy + hg_Params[0].xy;\n"
             "    r5.xy = r5.xy*hg_Params[0].zw;\n"
             "    r5.x = hg_Texture0.sample(hg_Sampler0, r5.xy).x;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r6.xy = r0.xy + hg_Params[0].xy;\n"
             "    r6.xy = r6.xy*hg_Params[0].zw;\n"
             "    r6.xyz = hg_Texture0.sample(hg_Sampler0, r6.xy).xyz;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r0.xy = r0.xy + hg_Params[0].xy;\n"
             "    r0.xy = r0.xy*hg_Params[0].zw;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, r0.xy).x;\n"
             "    r7.yz = r4.yx;\n"
             "    r7.x = r3.x;\n"
             "    r4.x = r4.z;\n"
             "    r4.y = r5.x;\n"
             "    r4.z = r6.y;\n"
             "    r6.xy = r6.xz;\n"
             "    r6.z = r0.x;\n"
             "    r3.xyz = r1.xyz - c1.www;\n"
             "    r6.xyz = select(r6.xyz, r4.xyz, r3.xyz < 0.00000f);\n"
             "    r5.xyz = r1.xyz - c2.xxx;\n"
             "    r6.xyz = select(r6.xyz, r7.xyz, r5.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz - c1.yyy;\n"
             "    r6.xyz = select(r6.xyz, r2.yxz, r1.xyz < 0.00000f);\n"
             "    r6.xyz = fmax(r6.xyz, c2.yyy);\n"
             "    r6.xyz = fmin(r6.xyz, c2.zzz);\n"
             "    r6.w = c1.y;\n"
             "    output.color0 = r6;\n"
             "    return output;\n"
             "}\n"
             "//MD5=955a98b9:d83ed1c3:5b5e15df:a3665098\n"
             "//SIG=00000000:00000000:00000000:00000000:0003:0001:0008:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000095d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.2500000000, 1.000000000, 6.000000000, 0.5000000000);\n"
           "    const highp vec4 c1 = vec4(4.000000000, 1.000000000, 0.000000000, 3.000000000);\n"
           "    const highp vec4 c2 = vec4(2.000000000, 0.003910068423, 0.9960899353, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy*c0.xy;\n"
           "    r0.xy = floor(r0.xy);\n"
           "    r0.xy = r0.xy*c0.zy + c0.ww;\n"
           "    r1.xyz = floor(hg_TexCoord0.xxx);\n"
           "    r1.xyz = mod(r1.xyz, c1.xxx);\n"
           "    r2.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal0.zw;\n"
           "    r2.xyz = texture2D(hg_Texture0, r2.xy).xyz;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r3.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r3.xy = r3.xy*hg_ProgramLocal0.zw;\n"
           "    r3.x = texture2D(hg_Texture0, r3.xy).x;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r4.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r4.xy = r4.xy*hg_ProgramLocal0.zw;\n"
           "    r4.xyz = texture2D(hg_Texture0, r4.xy).xyz;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r5.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r5.xy = r5.xy*hg_ProgramLocal0.zw;\n"
           "    r5.x = texture2D(hg_Texture0, r5.xy).x;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r6.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r6.xy = r6.xy*hg_ProgramLocal0.zw;\n"
           "    r6.xyz = texture2D(hg_Texture0, r6.xy).xyz;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal0.zw;\n"
           "    r0.x = texture2D(hg_Texture0, r0.xy).x;\n"
           "    r7.yz = r4.yx;\n"
           "    r7.x = r3.x;\n"
           "    r4.x = r4.z;\n"
           "    r4.y = r5.x;\n"
           "    r4.z = r6.y;\n"
           "    r6.xy = r6.xz;\n"
           "    r6.z = r0.x;\n"
           "    r3.xyz = r1.xyz - c1.www;\n"
           "    r6.xyz = vec3(r3.x < 0.00000 ? r4.x : r6.x, r3.y < 0.00000 ? r4.y : r6.y, r3.z < 0.00000 ? r4.z : r6.z);\n"
           "    r5.xyz = r1.xyz - c2.xxx;\n"
           "    r6.xyz = vec3(r5.x < 0.00000 ? r7.x : r6.x, r5.y < 0.00000 ? r7.y : r6.y, r5.z < 0.00000 ? r7.z : r6.z);\n"
           "    r1.xyz = r1.xyz - c1.yyy;\n"
           "    r6.xyz = vec3(r1.x < 0.00000 ? r2.y : r6.x, r1.y < 0.00000 ? r2.x : r6.y, r1.z < 0.00000 ? r2.z : r6.z);\n"
           "    r6.xyz = max(r6.xyz, c2.yyy);\n"
           "    r6.xyz = min(r6.xyz, c2.zzz);\n"
           "    r6.w = c1.y;\n"
           "    gl_FragColor = r6;\n"
           "}\n"
           "//MD5=48f15dc5:4d975e15:d41b2040:0394471d\n"
           "//SIG=00000000:00000000:00000000:00000000:0003:0001:0008:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorGamma_v210_yxzx_rgba_collapse::InitProgramDescriptor(HgcColorGamma_v210_yxzx_rgba_collapse *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_v210_yxzx_rgba_collapse_hgc_visible", "//Metal1.0     \n//LEN=0000000859\n[[ visible ]] FragmentOut HgcColorGamma_v210_yxzx_rgba_collapse_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.2500000000, 1.000000000, 6.000000000, 0.5000000000);\n"
    "    const float4 c1 = float4(4.000000000, 1.000000000, 0.000000000, 3.000000000);\n"
    "    const float4 c2 = float4(2.000000000, 0.003910068423, 0.9960899353, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy*c0.xy;\n"
    "    r0.xy = floor(r0.xy);\n"
    "    r0.xy = r0.xy*c0.zy + c0.ww;\n"
    "    r1.xyz = floor(texCoord0.xxx);\n"
    "    r1.xyz = r1.xyz - c1.xxx*floor(r1.xyz/c1.xxx);\n"
    "    r2.xy = r0.xy + hg_Params[0].xy;\n"
    "    r2.xy = r2.xy*hg_Params[0].zw;\n"
    "    r2.xyz = hg_Texture0.sample(hg_Sampler0, r2.xy).xyz;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r3.xy = r0.xy + hg_Params[0].xy;\n"
    "    r3.xy = r3.xy*hg_Params[0].zw;\n"
    "    r3.x = hg_Texture0.sample(hg_Sampler0, r3.xy).x;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r4.xy = r0.xy + hg_Params[0].xy;\n"
    "    r4.xy = r4.xy*hg_Params[0].zw;\n"
    "    r4.xyz = hg_Texture0.sample(hg_Sampler0, r4.xy).xyz;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r5.xy = r0.xy + hg_Params[0].xy;\n"
    "    r5.xy = r5.xy*hg_Params[0].zw;\n"
    "    r5.x = hg_Texture0.sample(hg_Sampler0, r5.xy).x;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r6.xy = r0.xy + hg_Params[0].xy;\n"
    "    r6.xy = r6.xy*hg_Params[0].zw;\n"
    "    r6.xyz = hg_Texture0.sample(hg_Sampler0, r6.xy).xyz;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r0.xy = r0.xy + hg_Params[0].xy;\n"
    "    r0.xy = r0.xy*hg_Params[0].zw;\n"
    "    r0.x = hg_Texture0.sample(hg_Sampler0, r0.xy).x;\n"
    "    r7.yz = r4.yx;\n"
    "    r7.x = r3.x;\n"
    "    r4.x = r4.z;\n"
    "    r4.y = r5.x;\n"
    "    r4.z = r6.y;\n"
    "    r6.xy = r6.xz;\n"
    "    r6.z = r0.x;\n"
    "    r3.xyz = r1.xyz - c1.www;\n"
    "    r6.xyz = select(r6.xyz, r4.xyz, r3.xyz < 0.00000f);\n"
    "    r5.xyz = r1.xyz - c2.xxx;\n"
    "    r6.xyz = select(r6.xyz, r7.xyz, r5.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz - c1.yyy;\n"
    "    r6.xyz = select(r6.xyz, r2.yxz, r1.xyz < 0.00000f);\n"
    "    r6.xyz = fmax(r6.xyz, c2.yyy);\n"
    "    r6.xyz = fmin(r6.xyz, c2.zzz);\n"
    "    r6.w = c1.y;\n"
    "    output.color0 = r6;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BE1048(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BE1080(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BE1078);
}

double HgcColorGamma_v210_yxzx_rgba_collapse::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x30uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3553DD0;
  strcpy(v3, "HgcColorGamma_v210_yxzx_rgba_collapse [hgc1]");
  return *(double *)"_collapse [hgc1]";
}

uint64_t HgcColorGamma_v210_yxzx_rgba_collapse::BindTexture(HgcColorGamma_v210_yxzx_rgba_collapse *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, _QWORD, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 0, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_collapse::Bind(HgcColorGamma_v210_yxzx_rgba_collapse *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HgcColorGamma_v210_yxzx_rgba_collapse *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_collapse::RenderTile(HgcColorGamma_v210_yxzx_rgba_collapse *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  int v5;
  float32x4_t v6;
  int32x2_t v7;
  uint64_t v8;
  uint64_t v9;
  float32x4_t v10;
  float32x4_t v11;
  uint64_t v12;
  float32x4_t v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int32x2_t v25;
  __int32 v26;
  float32x4_t v27;
  int32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  __int32 v32;
  float32x4_t v33;
  float32x4_t v34;
  int32x4_t v35;
  __int32 v36;
  __int32 v37;
  __int32 v38;
  float32x4_t v39;
  float32x4_t v40;
  int32x4_t v41;
  __int32 v42;
  __int32 v43;
  int8x16_t v44;
  __int32 v45;
  __int32 v46;
  float32x4_t v47;
  int8x16_t v48;
  float32x4_t v49;
  int32x4_t v50;
  __int32 v51;
  __int32 v52;
  __int32 v53;
  float32x4_t v54;
  int64x2_t v55;
  float32x4_t v56;
  int32x4_t v57;
  __int32 v58;
  float32x4_t v59;
  int32x4_t v60;
  int8x16_t v61;
  __int32 v62;
  int8x16_t v63;
  int8x16_t v64;
  float32x4_t v65;
  int8x16_t v66;
  int8x16_t v67;
  float32x4_t v68;
  int8x16_t v69;
  int8x16_t v70;
  float32x4_t v71;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      v7 = a2[2];
      v8 = 16 * a2[3].i32[0];
      v9 = 16 * v4;
      v10.i64[0] = 0x3F0000003F000000;
      v10.i64[1] = 0x3F0000003F000000;
      v11 = v6;
      do
      {
        v12 = 0;
        v13 = v11;
        do
        {
          v14 = *((_QWORD *)this + 51);
          v15 = *(float32x4_t *)(v14 + 16);
          v16 = vmulq_f32(v13, *(float32x4_t *)v14);
          v17 = vcvtq_f32_s32(vcvtq_s32_f32(v16));
          v18 = vmulq_f32(*(float32x4_t *)(v14 + 48), vsubq_f32(v17, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v17, v16))));
          v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 0);
          v20 = vcvtq_f32_s32(vcvtq_s32_f32(v19));
          v21 = vmulq_f32(*(float32x4_t *)(v14 + 64), vsubq_f32(v20, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v20, v19))));
          v22 = vaddq_f32(*(float32x4_t *)(v14 + 32), v18);
          v23 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
          v24 = vsubq_f32(v21, vsubq_f32(v23, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v23, v21))));
          v25 = a2[10];
          v26 = a2[11].i32[0];
          v27 = vaddq_f32(vsubq_f32(v22, v6), v10);
          v28 = vcvtq_s32_f32(v27);
          v29 = vmulq_f32(*(float32x4_t *)(v14 + 80), v24);
          v28.i64[0] = vaddq_s32(v28, vcgtq_f32(vcvtq_f32_s32(v28), v27)).u64[0];
          v30 = *(float32x4_t *)(v14 + 96);
          v31 = *(int8x16_t *)(v14 + 112);
          v32 = v28.i32[1];
          v33 = vaddq_f32(v22, v30);
          v34 = vaddq_f32(vsubq_f32(v33, v6), v10);
          v35 = vcvtq_s32_f32(v34);
          v36 = v28.i32[0];
          v28.i64[0] = vaddq_s32(v35, vcgtq_f32(vcvtq_f32_s32(v35), v34)).u64[0];
          v37 = v28.i32[1];
          v38 = v28.i32[0];
          v39 = vaddq_f32(v30, v33);
          v40 = vaddq_f32(vsubq_f32(v39, v6), v10);
          v41 = vcvtq_s32_f32(v40);
          v42 = v36 + v32 * v26;
          v40.i64[0] = vaddq_s32(v41, vcgtq_f32(vcvtq_f32_s32(v41), v40)).u64[0];
          v43 = v40.i32[1];
          v44 = *(int8x16_t *)(*(_QWORD *)&v25 + 16 * v42);
          v45 = v38 + v37 * v26;
          v46 = v40.i32[0];
          v47 = vaddq_f32(v30, v39);
          v48 = *(int8x16_t *)(*(_QWORD *)&v25 + 16 * v45);
          v49 = vaddq_f32(vsubq_f32(v47, v6), v10);
          v50 = vcvtq_s32_f32(v49);
          v49.i64[0] = vaddq_s32(v50, vcgtq_f32(vcvtq_f32_s32(v50), v49)).u64[0];
          v51 = v46 + v43 * v26;
          v52 = v49.i32[1];
          v53 = v49.i32[0];
          v54 = vaddq_f32(v30, v47);
          v55 = *(int64x2_t *)(*(_QWORD *)&v25 + 16 * v51);
          v56 = vaddq_f32(vsubq_f32(v54, v6), v10);
          v57 = vcvtq_s32_f32(v56);
          v58 = v53 + v52 * v26;
          v56.i64[0] = vaddq_s32(v57, vcgtq_f32(vcvtq_f32_s32(v57), v56)).u64[0];
          v59 = vaddq_f32(vsubq_f32(vaddq_f32(v30, v54), v6), v10);
          v60 = vcvtq_s32_f32(v59);
          v59.i64[0] = vaddq_s32(v60, vcgtq_f32(vcvtq_f32_s32(v60), v59)).u64[0];
          v61 = *(int8x16_t *)(*(_QWORD *)&v25 + 16 * (v56.i32[0] + v56.i32[1] * v26));
          v62 = v59.i32[0] + v59.i32[1] * v26;
          v63 = vbslq_s8(v31, v48, (int8x16_t)vdupq_lane_s64(v55.i64[0], 0));
          v55.i64[0] = vbslq_s8(v31, (int8x16_t)vdupq_laneq_s64(v55, 1), (int8x16_t)vrev64q_s32(*(int32x4_t *)(*(_QWORD *)&v25 + 16 * v58))).u64[0];
          v64 = vextq_s8((int8x16_t)v6, v61, 0xCuLL);
          *(int8x8_t *)v61.i8 = vqtbl1_s8(v61, *(int8x8_t *)(v14 + 128));
          v64.i64[0] = v55.i64[0];
          v65 = *(float32x4_t *)(v14 + 160);
          v66 = (int8x16_t)vcgtq_f32(v65, vsubq_f32(v29, *(float32x4_t *)(v14 + 144)));
          v61.i64[1] = *(_QWORD *)(*(_QWORD *)&v25 + 16 * v62);
          v67 = (int8x16_t)vcgtq_f32(v65, vsubq_f32(v29, *(float32x4_t *)(v14 + 176)));
          v68 = vsubq_f32(v29, v15);
          v69 = *(int8x16_t *)(v14 + 192);
          *(int8x8_t *)v70.i8 = vqtbl1_s8(v44, *(int8x8_t *)v69.i8);
          v70.u64[1] = (unint64_t)vqtbl1_s8(v44, (int8x8_t)*(_OWORD *)&vextq_s8(v69, v69, 8uLL));
          v71 = vminq_f32(vmaxq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v65, v68), v70, vbslq_s8(v67, v63, vbslq_s8(v66, v64, v61))), *(float32x4_t *)(v14 + 208)), *(float32x4_t *)(v14 + 224));
          v71.i32[3] = 1.0;
          *(float32x4_t *)(*(_QWORD *)&v7 + v12) = v71;
          v13 = vaddq_f32(v13, (float32x4_t)xmmword_1B304F230);
          v12 += 16;
        }
        while (v9 != v12);
        v11 = vaddq_f32(v11, (float32x4_t)xmmword_1B304F240);
        ++v5;
        *(_QWORD *)&v7 += v8;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_collapse::GetDOD(HgcColorGamma_v210_yxzx_rgba_collapse *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_collapse::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcColorGamma_v210_yxzx_rgba_collapse::HgcColorGamma_v210_yxzx_rgba_collapse(HgcColorGamma_v210_yxzx_rgba_collapse *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6546DF0;
  v3 = operator new();
  *(_OWORD *)v3 = xmmword_1B35541A0;
  *(_OWORD *)(v3 + 16) = xmmword_1B3051560;
  *(_OWORD *)(v3 + 32) = xmmword_1B3052100;
  *(_OWORD *)(v3 + 48) = xmmword_1B35541B0;
  *(_OWORD *)(v3 + 64) = xmmword_1B3525BB0;
  *(_OWORD *)(v3 + 80) = xmmword_1B3052960;
  *(_OWORD *)(v3 + 96) = xmmword_1B304F230;
  *(_OWORD *)(v3 + 112) = xmmword_1B3050E20;
  *(_OWORD *)(v3 + 128) = xmmword_1B30510C0;
  *(_OWORD *)(v3 + 144) = xmmword_1B3052B60;
  *(_QWORD *)(v3 + 160) = 0;
  *(_QWORD *)(v3 + 168) = 0;
  *(_OWORD *)(v3 + 176) = xmmword_1B3051520;
  *(_OWORD *)(v3 + 192) = xmmword_1B3553CA0;
  *(_OWORD *)(v3 + 208) = xmmword_1B35541C0;
  *(_OWORD *)(v3 + 224) = xmmword_1B35541D0;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcColorGamma_v210_yxzx_rgba_collapse *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BE1624(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_v210_yxzx_rgba_collapse::~HgcColorGamma_v210_yxzx_rgba_collapse(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6546DF0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4019FCA701);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6546DF0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4019FCA701);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6546DF0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4019FCA701);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_v210_yxzx_rgba_collapse::SetParameter(HgcColorGamma_v210_yxzx_rgba_collapse *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_collapse::GetParameter(HgcColorGamma_v210_yxzx_rgba_collapse *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcColorGamma_2vuy_xyxz_collapse::GetProgram(HgcColorGamma_2vuy_xyxz_collapse *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000028e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = (half3) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    output.color0.yzw = float3(r0.yxz);\n"
             "    output.color0.x = (float) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=03a1507a:010149b6:76881db1:e797c2f0\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0001:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000278\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    output.color0.yzw = r0.yxz;\n"
             "    output.color0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b3a548da:cd778fbd:9d5ae4a9:fb81f639\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000022e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0.xyz = texture2D(hg_Texture0, hg_TexCoord0.xy).xyz;\n"
           "    gl_FragColor.yzw = r0.yxz;\n"
           "    gl_FragColor.x = texture2D(hg_Texture0, hg_TexCoord1.xy).x;\n"
           "}\n"
           "//MD5=6dabeac5:cfd7b220:9dd1d489:c803d0b5\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcColorGamma_2vuy_xyxz_collapse::InitProgramDescriptor(HgcColorGamma_2vuy_xyxz_collapse *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_2vuy_xyxz_collapse_hgc_visible", "//Metal1.0     \n//LEN=00000001db\n[[ visible ]] FragmentOut HgcColorGamma_2vuy_xyxz_collapse_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).xyz;\n"
    "    output.color0.yzw = r0.yxz;\n"
    "    output.color0.x = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BE1B8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BE1BC8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BE1BC0);
}

char *HgcColorGamma_2vuy_xyxz_collapse::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D10;
  strcpy(result, "HgcColorGamma_2vuy_xyxz_collapse [hgc1]");
  return result;
}

uint64_t HgcColorGamma_2vuy_xyxz_collapse::BindTexture(HgcColorGamma_2vuy_xyxz_collapse *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  return 0;
}

uint64_t HgcColorGamma_2vuy_xyxz_collapse::Bind(HgcColorGamma_2vuy_xyxz_collapse *this, HGHandler *a2)
{
  (*(void (**)(HgcColorGamma_2vuy_xyxz_collapse *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcColorGamma_2vuy_xyxz_collapse::RenderTile(HgcColorGamma_2vuy_xyxz_collapse *this, HGTile *a2)
{
  int v2;
  int v3;
  uint64_t v4;
  int v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int8x16_t *v10;
  uint64_t v11;
  int v12;
  int8x16_t *v13;
  int8x16_t *v14;
  uint64_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x8_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64_t v28;
  unsigned int v29;
  int8x16_t v30;
  uint64_t v31;
  int8x16_t v32;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *(int *)a2;
    v5 = *((_DWORD *)a2 + 2) - v4;
    v6 = (int8x16_t *)*((_QWORD *)a2 + 2);
    v7 = *((_QWORD *)a2 + 10) + 16 * v4;
    v8 = *((int *)a2 + 22);
    v9 = v7 + 64;
    v10 = v6 + 2;
    v11 = 16 * *((int *)a2 + 6);
    while (v5 < 4)
    {
      LODWORD(v28) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += 16 * v8;
      ++v3;
      v9 += 16 * v8;
      v10 = (int8x16_t *)((char *)v10 + v11);
      v6 = (int8x16_t *)((char *)v6 + v11);
      if (v3 == v2)
        return 0;
    }
    v12 = 0;
    v13 = v10;
    v14 = (int8x16_t *)v9;
    do
    {
      v15 = *((_QWORD *)this + 51);
      v16 = v14[-4];
      *(int8x8_t *)v17.i8 = vqtbl1_s8(v16, *(int8x8_t *)v15);
      v18 = (int8x8_t)vextq_s8(*(int8x16_t *)v15, *(int8x16_t *)v15, 8uLL).u64[0];
      v17.u64[1] = (unint64_t)vqtbl1_s8(v16, v18);
      v19 = v14[-2];
      *(int8x8_t *)v20.i8 = vqtbl1_s8(v19, *(int8x8_t *)v15);
      v20.u64[1] = (unint64_t)vqtbl1_s8(v19, v18);
      *(int8x8_t *)v21.i8 = vqtbl1_s8(*v14, *(int8x8_t *)v15);
      v21.u64[1] = (unint64_t)vqtbl1_s8(*v14, v18);
      v22 = v14[2];
      *(int8x8_t *)v23.i8 = vqtbl1_s8(v22, *(int8x8_t *)v15);
      v23.u64[1] = (unint64_t)vqtbl1_s8(v22, v18);
      v24 = vbslq_s8(*(int8x16_t *)(v15 + 16), v14[-3], v17);
      v25 = vbslq_s8(*(int8x16_t *)(v15 + 16), v14[-1], v20);
      v26 = vbslq_s8(*(int8x16_t *)(v15 + 16), v14[1], v21);
      v27 = vbslq_s8(*(int8x16_t *)(v15 + 16), v14[3], v23);
      v13[-2] = v24;
      v13[-1] = v25;
      *v13 = v26;
      v13[1] = v27;
      v13 += 4;
      v14 += 8;
      v12 -= 4;
    }
    while (v5 + v12 > 3);
    LODWORD(v28) = -v12;
    if (-v12 >= v5)
      goto LABEL_3;
LABEL_10:
    v29 = 2 * v28;
    v28 = v28;
    do
    {
      v30 = *(int8x16_t *)(v7 + 16 * v29);
      v31 = *((_QWORD *)this + 51);
      *(int8x8_t *)v32.i8 = vqtbl1_s8(v30, *(int8x8_t *)v31);
      v32.u64[1] = (unint64_t)vqtbl1_s8(v30, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v31, *(int8x16_t *)v31, 8uLL));
      v6[v28++] = vbslq_s8(*(int8x16_t *)(v31 + 16), *(int8x16_t *)(v7 + 16 * (v29 + 1)), v32);
      v29 += 2;
    }
    while (v28 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcColorGamma_2vuy_xyxz_collapse::GetDOD(HgcColorGamma_2vuy_xyxz_collapse *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  float v9;
  double v10;
  float v11;
  double v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0, 0, 0xFFFFFFFF, 0);
  v8 = HGRectGrow(v6, v5, v7);
  v9 = HGRectFloat(v8);
  v13 = HGRectScale(v9, v10, v11, v12, 0.5);
  v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcColorGamma_2vuy_xyxz_collapse::GetROI(HgcColorGamma_2vuy_xyxz_collapse *this, HGRenderer *a2, int a3, HGRect a4)
{
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = HGRectFloat(a4.var0);
  v9 = HGRectScale(v5, v6, v7, v8, 2.0);
  v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  v16 = v15;
  v17 = HGRectMake4i(0, 0, 1u, 0);
  v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcColorGamma_2vuy_xyxz_collapse::HgcColorGamma_2vuy_xyxz_collapse(HgcColorGamma_2vuy_xyxz_collapse *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6547058;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B3554210;
  v3[1] = xmmword_1B3050E20;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcColorGamma_2vuy_xyxz_collapse *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BE20DC(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_2vuy_xyxz_collapse::~HgcColorGamma_2vuy_xyxz_collapse(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6547058;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6547058;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6547058;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_2vuy_xyxz_collapse::SetParameter(HgcColorGamma_2vuy_xyxz_collapse *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_2vuy_xyxz_collapse::GetParameter(HgcColorGamma_2vuy_xyxz_collapse *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcPixelFormatConversion_kV4S_WXYZ_output::GetProgram(HgcPixelFormatConversion_kV4S_WXYZ_output *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000022e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0.wxyz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cf796c8f:0088fb48:fbecfffa:bebd058b\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000220\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0.wxyz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6820d1f2:902f3939:8ad944e0:7499e717\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0.wxyz;\n"
           "}\n"
           "//MD5=3629bbaf:437df260:e6e61391:b5896e9d\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4S_WXYZ_output::InitProgramDescriptor(HgcPixelFormatConversion_kV4S_WXYZ_output *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4S_WXYZ_output_hgc_visible", "//Metal1.0     \n//LEN=0000000113\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4S_WXYZ_output_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0.wxyz;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BE247C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BE24AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BE24A4);
}

double HgcPixelFormatConversion_kV4S_WXYZ_output::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x38uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3553C60;
  strcpy(v3, "HgcPixelFormatConversion_kV4S_WXYZ_output [hgc1]");
  return *(double *)"YZ_output [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_output::BindTexture(HgcPixelFormatConversion_kV4S_WXYZ_output *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_output::Bind(HgcPixelFormatConversion_kV4S_WXYZ_output *this, HGHandler *a2)
{
  (*(void (**)(HgcPixelFormatConversion_kV4S_WXYZ_output *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_output::RenderTile(HgcPixelFormatConversion_kV4S_WXYZ_output *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  int8x16_t *v4;
  int8x16_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int8x16_t *v11;
  int8x16_t *v12;
  unint64_t v13;
  int8x16_t *v14;
  int8x16_t *v15;
  uint64_t v16;
  int8x16_t *v17;
  int8x16_t *v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t *v22;
  int8x16_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (int8x16_t *)*((_QWORD *)a2 + 10);
    v5 = (int8x16_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v24 = 0;
        v25 = 16 * v7;
        v26 = 16 * v6;
        v27 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v28 = 0;
          do
          {
            v5[v28 / 0x10] = vextq_s8(v4[v28 / 0x10], v4[v28 / 0x10], 0xCuLL);
            v28 += 16;
          }
          while (v27 != v28);
          ++v24;
          v4 = (int8x16_t *)((char *)v4 + v25);
          v5 = (int8x16_t *)((char *)v5 + v26);
        }
        while (v24 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = v14;
          v19 = vextq_s8(v4[v16 - 1], v4[v16 - 1], 0xCuLL);
          v20 = vextq_s8(v4[v16], v4[v16], 0xCuLL);
          v21 = vextq_s8(v4[v16 + 1], v4[v16 + 1], 0xCuLL);
          v22 = &v5[v16];
          v22[-2] = vextq_s8(v4[v16 - 2], v4[v16 - 2], 0xCuLL);
          v22[-1] = v19;
          v13 += 4;
          *v22 = v20;
          v22[1] = v21;
          v16 += 4;
          v15 += 4;
          v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v23 = *v17++;
            *v18++ = vextq_s8(v23, v23, 0xCuLL);
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (int8x16_t *)((char *)v5 + v9);
        v4 = (int8x16_t *)((char *)v4 + v10);
        v11 = (int8x16_t *)((char *)v11 + v10);
        v12 = (int8x16_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_output::GetDOD(HgcPixelFormatConversion_kV4S_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_output::GetROI(HgcPixelFormatConversion_kV4S_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcPixelFormatConversion_kV4S_WXYZ_output::HgcPixelFormatConversion_kV4S_WXYZ_output(HgcPixelFormatConversion_kV4S_WXYZ_output *this)
{
  uint64_t v2;
  _OWORD *v3;

  HGColorMatrix::HGColorMatrix(this);
  *(_QWORD *)v2 = off_1E65472C0;
  *(_DWORD *)(v2 + 504) = 1;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B304F230;
  v3[1] = xmmword_1B304F240;
  v3[2] = xmmword_1B304F250;
  v3[3] = xmmword_1B304EFF0;
  v3[4] = xmmword_1B304F230;
  v3[5] = xmmword_1B304F240;
  v3[6] = xmmword_1B304F250;
  v3[7] = xmmword_1B304EFF0;
  *((_QWORD *)this + 62) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BE27E8(_Unwind_Exception *a1)
{
  HGColorMatrix *v1;

  HGColorMatrix::~HGColorMatrix(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4S_WXYZ_output::~HgcPixelFormatConversion_kV4S_WXYZ_output(HgcPixelFormatConversion_kV4S_WXYZ_output *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65472C0;
  v2 = *((_QWORD *)this + 62);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGColorMatrix::~HGColorMatrix(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E65472C0;
  v2 = *((_QWORD *)this + 62);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGColorMatrix::~HGColorMatrix(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65472C0;
  v2 = *((_QWORD *)this + 62);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGColorMatrix::~HGColorMatrix(this);
  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_output::SetParameter(HgcPixelFormatConversion_kV4S_WXYZ_output *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_output::GetParameter(HgcPixelFormatConversion_kV4S_WXYZ_output *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

HGNode *HgcPixelFormatConversion_kV4S_WXYZ_output::GetOutput(__n128 *this, HGRenderer *a2, __n128 a3, __n128 a4, __n128 a5)
{
  int8x16_t *v5;
  int8x16_t v6;
  __n128 *v7;

  if (this[31].n128_u32[2])
  {
    v5 = (int8x16_t *)this[31].n128_u64[0];
    a4 = (__n128)vextq_s8(v5[5], v5[5], 0xCuLL);
    a5 = (__n128)vextq_s8(v5[6], v5[6], 0xCuLL);
    v6 = vextq_s8(v5[7], v5[7], 0xCuLL);
    *v5 = vextq_s8(v5[4], v5[4], 0xCuLL);
    *(__n128 *)(this[31].n128_u64[0] + 16) = a4;
    *(__n128 *)(this[31].n128_u64[0] + 32) = a5;
    *(int8x16_t *)(this[31].n128_u64[0] + 48) = v6;
    v7 = (__n128 *)this[31].n128_u64[0];
    this[27] = *v7;
    this[28] = v7[1];
    this[29] = v7[2];
    a3 = v7[3];
    this[30] = a3;
    this[31].n128_u32[2] = 0;
  }
  return HGColorMatrix::GetOutput((HGColorMatrix *)this, a2, a3.n128_f64[0], a4.n128_f64[0], (int32x2_t)a5.n128_u64[0]);
}

const char *HgcColorGamma_2vuy_yxzx_collapse::GetProgram(HgcColorGamma_2vuy_yxzx_collapse *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002a9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = (half3) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    r1.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    output.color0.xyz = float3(r0.zxy);\n"
             "    output.color0.w = float(r1.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=137f9951:1ecff4bd:440988b0:a7a24e84\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000028d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    r1.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    output.color0.xyz = r0.zxy;\n"
             "    output.color0.w = r1.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=26871f8e:7dbd704e:68fccc01:ba0d779a\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000243\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xyz = texture2D(hg_Texture0, hg_TexCoord0.xy).xyz;\n"
           "    r1.x = texture2D(hg_Texture0, hg_TexCoord1.xy).x;\n"
           "    gl_FragColor.xyz = r0.zxy;\n"
           "    gl_FragColor.w = r1.x;\n"
           "}\n"
           "//MD5=690e075e:9a04c53e:3eba47dc:e08b8ec4\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcColorGamma_2vuy_yxzx_collapse::InitProgramDescriptor(HgcColorGamma_2vuy_yxzx_collapse *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_2vuy_yxzx_collapse_hgc_visible", "//Metal1.0     \n//LEN=00000001f0\n[[ visible ]] FragmentOut HgcColorGamma_2vuy_yxzx_collapse_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).xyz;\n"
    "    r1.x = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).x;\n"
    "    output.color0.xyz = r0.zxy;\n"
    "    output.color0.w = r1.x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BE2DB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BE2DF4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BE2DECLL);
}

char *HgcColorGamma_2vuy_yxzx_collapse::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D10;
  strcpy(result, "HgcColorGamma_2vuy_yxzx_collapse [hgc1]");
  return result;
}

uint64_t HgcColorGamma_2vuy_yxzx_collapse::BindTexture(HgcColorGamma_2vuy_yxzx_collapse *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  return 0;
}

uint64_t HgcColorGamma_2vuy_yxzx_collapse::Bind(HgcColorGamma_2vuy_yxzx_collapse *this, HGHandler *a2)
{
  (*(void (**)(HgcColorGamma_2vuy_yxzx_collapse *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcColorGamma_2vuy_yxzx_collapse::RenderTile(HgcColorGamma_2vuy_yxzx_collapse *this, HGTile *a2)
{
  int v2;
  int v3;
  uint64_t v4;
  int v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int8x16_t *v10;
  uint64_t v11;
  int v12;
  int8x16_t *v13;
  int8x16_t *v14;
  int8x16_t v15;
  int8x16_t v16;
  uint64_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x8_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  uint64_t v26;
  unsigned int v27;
  int8x16_t v28;
  uint64_t v29;
  int8x16_t v30;
  int8x16_t v31;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *(int *)a2;
    v5 = *((_DWORD *)a2 + 2) - v4;
    v6 = (int8x16_t *)*((_QWORD *)a2 + 2);
    v7 = *((_QWORD *)a2 + 10) + 16 * v4;
    v8 = *((int *)a2 + 22);
    v9 = v7 + 64;
    v10 = v6 + 2;
    v11 = 16 * *((int *)a2 + 6);
    while (v5 < 4)
    {
      LODWORD(v26) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += 16 * v8;
      ++v3;
      v9 += 16 * v8;
      v10 = (int8x16_t *)((char *)v10 + v11);
      v6 = (int8x16_t *)((char *)v6 + v11);
      if (v3 == v2)
        return 0;
    }
    v12 = 0;
    v13 = v10;
    v14 = (int8x16_t *)v9;
    do
    {
      v15 = v14[-4];
      v16 = v14[-2];
      v17 = *((_QWORD *)this + 51);
      v18 = *(int8x16_t *)(v17 + 16);
      *(int8x8_t *)v19.i8 = vqtbl1_s8(v15, *(int8x8_t *)v17);
      v20 = (int8x8_t)vextq_s8(*(int8x16_t *)v17, *(int8x16_t *)v17, 8uLL).u64[0];
      v19.u64[1] = (unint64_t)vqtbl1_s8(v15, v20);
      *(int8x8_t *)v15.i8 = vqtbl1_s8(v16, *(int8x8_t *)v17);
      v15.u64[1] = (unint64_t)vqtbl1_s8(v16, v20);
      *(int8x8_t *)v16.i8 = vqtbl1_s8(*v14, *(int8x8_t *)v17);
      v16.u64[1] = (unint64_t)vqtbl1_s8(*v14, v20);
      v21 = v14[2];
      *(int8x8_t *)v22.i8 = vqtbl1_s8(v21, *(int8x8_t *)v17);
      v22.u64[1] = (unint64_t)vqtbl1_s8(v21, v20);
      v23 = vbslq_s8(v18, vextq_s8(v14[-1], v14[-1], 4uLL), v15);
      v24 = vbslq_s8(v18, vextq_s8(v14[1], v14[1], 4uLL), v16);
      v25 = vbslq_s8(v18, vextq_s8(v14[3], v14[3], 4uLL), v22);
      v13[-2] = vbslq_s8(v18, vextq_s8(v14[-3], v14[-3], 4uLL), v19);
      v13[-1] = v23;
      *v13 = v24;
      v13[1] = v25;
      v13 += 4;
      v14 += 8;
      v12 -= 4;
    }
    while (v5 + v12 > 3);
    LODWORD(v26) = -v12;
    if (-v12 >= v5)
      goto LABEL_3;
LABEL_10:
    v27 = 2 * v26;
    v26 = v26;
    do
    {
      v28 = *(int8x16_t *)(v7 + 16 * v27);
      v29 = *((_QWORD *)this + 51);
      *(int8x8_t *)v30.i8 = vqtbl1_s8(v28, *(int8x8_t *)v29);
      v31 = *(int8x16_t *)(v7 + 16 * (v27 + 1));
      v30.u64[1] = (unint64_t)vqtbl1_s8(v28, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v29, *(int8x16_t *)v29, 8uLL));
      v6[v26++] = vbslq_s8(*(int8x16_t *)(v29 + 16), vextq_s8(v31, v31, 4uLL), v30);
      v27 += 2;
    }
    while (v26 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcColorGamma_2vuy_yxzx_collapse::GetDOD(HgcColorGamma_2vuy_yxzx_collapse *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  float v9;
  double v10;
  float v11;
  double v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0, 0, 0xFFFFFFFF, 0);
  v8 = HGRectGrow(v6, v5, v7);
  v9 = HGRectFloat(v8);
  v13 = HGRectScale(v9, v10, v11, v12, 0.5);
  v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcColorGamma_2vuy_yxzx_collapse::GetROI(HgcColorGamma_2vuy_yxzx_collapse *this, HGRenderer *a2, int a3, HGRect a4)
{
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = HGRectFloat(a4.var0);
  v9 = HGRectScale(v5, v6, v7, v8, 2.0);
  v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  v16 = v15;
  v17 = HGRectMake4i(0, 0, 1u, 0);
  v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcColorGamma_2vuy_yxzx_collapse::HgcColorGamma_2vuy_yxzx_collapse(HgcColorGamma_2vuy_yxzx_collapse *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6547538;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B3052920;
  v3[1] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcColorGamma_2vuy_yxzx_collapse *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BE3314(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_2vuy_yxzx_collapse::~HgcColorGamma_2vuy_yxzx_collapse(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6547538;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6547538;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6547538;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_2vuy_yxzx_collapse::SetParameter(HgcColorGamma_2vuy_yxzx_collapse *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_2vuy_yxzx_collapse::GetParameter(HgcColorGamma_2vuy_yxzx_collapse *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcPremultiplyWhiteToBlack::GetProgram(HgcPremultiplyWhiteToBlack *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002fa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.www - c0.xxx;\n"
             "    r0.xyz = r0.xyz + r1.xyz;\n"
             "    r1.xyz = half3(r0.xyz > c0.yyy);\n"
             "    r0.xyz = r0.xyz*r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6dd76864:48849d5a:13d5e8a8:54ff4049\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.www - c0.xxx;\n"
             "    r0.xyz = r0.xyz + r1.xyz;\n"
             "    r1.xyz = float3(r0.xyz > c0.yyy);\n"
             "    r0.xyz = r0.xyz*r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f31f1670:3fae15ce:30947a54:39732594\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002a0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.www - c0.xxx;\n"
           "    r0.xyz = r0.xyz + r1.xyz;\n"
           "    r1.xyz = vec3(greaterThan(r0.xyz, c0.yyy));\n"
           "    r0.xyz = r0.xyz*r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f5fa399d:5bc239fe:c2d365db:a86b532a\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPremultiplyWhiteToBlack::InitProgramDescriptor(HgcPremultiplyWhiteToBlack *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPremultiplyWhiteToBlack_hgc_visible", "//Metal1.0     \n//LEN=00000001d3\n[[ visible ]] FragmentOut HgcPremultiplyWhiteToBlack_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.www - c0.xxx;\n"
    "    r0.xyz = r0.xyz + r1.xyz;\n"
    "    r1.xyz = float3(r0.xyz > c0.yyy);\n"
    "    r0.xyz = r0.xyz*r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BE36B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BE36E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BE36DCLL);
}

char *HgcPremultiplyWhiteToBlack::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D20;
  strcpy(result, "HgcPremultiplyWhiteToBlack [hgc1]");
  return result;
}

uint64_t HgcPremultiplyWhiteToBlack::BindTexture(HgcPremultiplyWhiteToBlack *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPremultiplyWhiteToBlack::Bind(HgcPremultiplyWhiteToBlack *this, HGHandler *a2)
{
  (*(void (**)(HgcPremultiplyWhiteToBlack *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcPremultiplyWhiteToBlack::RenderTile(HgcPremultiplyWhiteToBlack *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  int8x16_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t *v11;
  int8x16_t *v12;
  unint64_t v13;
  int8x16_t *v14;
  float32x4_t *v15;
  uint64_t v16;
  float32x4_t *v17;
  int8x16_t *v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  uint64_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t *v34;
  float32x4_t v35;
  uint64_t v36;
  int8x16_t v37;
  float32x4_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  float32x4_t v44;
  uint64_t v45;
  int8x16_t v46;
  float32x4_t v47;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (int8x16_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v39 = 0;
        v40 = 16 * v7;
        v41 = 16 * v6;
        v42 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v43 = 0;
          do
          {
            v44 = v4[v43 / 0x10];
            v45 = *((_QWORD *)this + 51);
            v46 = *(int8x16_t *)(v45 + 16);
            v47 = (float32x4_t)vbslq_s8(v46, (int8x16_t)v44, (int8x16_t)vaddq_f32(v44, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 3), *(float32x4_t *)v45)));
            v5[v43 / 0x10] = vbslq_s8(v46, (int8x16_t)v44, (int8x16_t)vmulq_f32((float32x4_t)vandq_s8(*(int8x16_t *)v45, (int8x16_t)vcgtq_f32(v47, *(float32x4_t *)(v45 + 32))), v47));
            v43 += 16;
          }
          while (v42 != v43);
          ++v39;
          v4 = (float32x4_t *)((char *)v4 + v40);
          v5 = (int8x16_t *)((char *)v5 + v41);
        }
        while (v39 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = v14;
          v19 = v4[v16 - 2];
          v20 = v4[v16 - 1];
          v21 = v4[v16];
          v22 = v4[v16 + 1];
          v23 = *((_QWORD *)this + 51);
          v24 = *(int8x16_t *)(v23 + 16);
          v25 = (float32x4_t)vbslq_s8(v24, (int8x16_t)v19, (int8x16_t)vaddq_f32(v19, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3), *(float32x4_t *)v23)));
          v26 = (float32x4_t)vbslq_s8(v24, (int8x16_t)v20, (int8x16_t)vaddq_f32(v20, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 3), *(float32x4_t *)v23)));
          v27 = (float32x4_t)vbslq_s8(v24, (int8x16_t)v21, (int8x16_t)vaddq_f32(v21, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 3), *(float32x4_t *)v23)));
          v28 = (float32x4_t)vbslq_s8(v24, (int8x16_t)v22, (int8x16_t)vaddq_f32(v22, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 3), *(float32x4_t *)v23)));
          v29 = *(float32x4_t *)(v23 + 32);
          v30 = vbslq_s8(v24, (int8x16_t)v19, (int8x16_t)vmulq_f32((float32x4_t)vandq_s8(*(int8x16_t *)v23, (int8x16_t)vcgtq_f32(v25, v29)), v25));
          v31 = vbslq_s8(v24, (int8x16_t)v20, (int8x16_t)vmulq_f32((float32x4_t)vandq_s8(*(int8x16_t *)v23, (int8x16_t)vcgtq_f32(v26, v29)), v26));
          v32 = vbslq_s8(v24, (int8x16_t)v21, (int8x16_t)vmulq_f32((float32x4_t)vandq_s8(*(int8x16_t *)v23, (int8x16_t)vcgtq_f32(v27, v29)), v27));
          v33 = vbslq_s8(v24, (int8x16_t)v22, (int8x16_t)vmulq_f32((float32x4_t)vandq_s8(*(int8x16_t *)v23, (int8x16_t)vcgtq_f32(v28, v29)), v28));
          v34 = &v5[v16];
          v34[-2] = v30;
          v34[-1] = v31;
          v13 += 4;
          *v34 = v32;
          v34[1] = v33;
          v16 += 4;
          v15 += 4;
          v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v35 = *v17++;
            v36 = *((_QWORD *)this + 51);
            v37 = *(int8x16_t *)(v36 + 16);
            v38 = (float32x4_t)vbslq_s8(v37, (int8x16_t)v35, (int8x16_t)vaddq_f32(v35, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 3), *(float32x4_t *)v36)));
            *v18++ = vbslq_s8(v37, (int8x16_t)v35, (int8x16_t)vmulq_f32((float32x4_t)vandq_s8(*(int8x16_t *)v36, (int8x16_t)vcgtq_f32(v38, *(float32x4_t *)(v36 + 32))), v38));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (int8x16_t *)((char *)v5 + v9);
        v4 = (float32x4_t *)((char *)v4 + v10);
        v11 = (float32x4_t *)((char *)v11 + v10);
        v12 = (int8x16_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPremultiplyWhiteToBlack::GetDOD(HgcPremultiplyWhiteToBlack *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcPremultiplyWhiteToBlack::GetROI(HgcPremultiplyWhiteToBlack *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcPremultiplyWhiteToBlack::HgcPremultiplyWhiteToBlack(HgcPremultiplyWhiteToBlack *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65477A0;
  v3 = operator new();
  *(_OWORD *)v3 = xmmword_1B3051560;
  *(_OWORD *)(v3 + 16) = xmmword_1B3050F70;
  *(_QWORD *)(v3 + 32) = 0;
  *(_QWORD *)(v3 + 40) = 0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BE3AC8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPremultiplyWhiteToBlack::~HgcPremultiplyWhiteToBlack(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65477A0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40EED21634);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65477A0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40EED21634);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcPremultiplyWhiteToBlack::SetParameter(HgcPremultiplyWhiteToBlack *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPremultiplyWhiteToBlack::GetParameter(HgcPremultiplyWhiteToBlack *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcApply3DLUTTetrahedralUniform_basekernel::GetProgram(HgcApply3DLUTTetrahedralUniform_basekernel *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return aMetal10Len0000_1241;
    else
      return "//Metal1.0     \n"
             "//LEN=0000000e89\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = hg_Params[1].yyy - c0.xxx;\n"
             "    r1.xyz = r1.xyz*r2.xyz;\n"
             "    r1.xyz = fmax(r1.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
             "    r3.xyz = fract(r1.xyz);\n"
             "    r1.xyz = floor(r1.xyz);\n"
             "    r4.xyz = r1.xyz + c0.xxx;\n"
             "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
             "    r4.xyz = r4.xyz - r1.xyz;\n"
             "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
             "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
             "    r2.y = r1.z;\n"
             "    r2.xy = r2.xy + c0.zz;\n"
             "    r1.xy = r2.xy + hg_Params[3].xy;\n"
             "    r1.xy = r1.xy*hg_Params[3].zw;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r5.xy = r2.xy + hg_Params[3].xy;\n"
             "    r5.xy = r5.xy*hg_Params[3].zw;\n"
             "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r6.xy = r2.xy + hg_Params[3].xy;\n"
             "    r6.xy = r6.xy*hg_Params[3].zw;\n"
             "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
             "    r2.x = r2.x - r4.x;\n"
             "    r7.xy = r2.xy + hg_Params[3].xy;\n"
             "    r7.xy = r7.xy*hg_Params[3].zw;\n"
             "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
             "    r2.y = r2.y + r4.z;\n"
             "    r8.xy = r2.xy + hg_Params[3].xy;\n"
             "    r8.xy = r8.xy*hg_Params[3].zw;\n"
             "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
             "    r2.x = r2.x - r4.y;\n"
             "    r9.xy = r2.xy + hg_Params[3].xy;\n"
             "    r9.xy = r9.xy*hg_Params[3].zw;\n"
             "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r10.xy = r2.xy + hg_Params[3].xy;\n"
             "    r10.xy = r10.xy*hg_Params[3].zw;\n"
             "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r2.xy = r2.xy + hg_Params[3].xy;\n"
             "    r2.xy = r2.xy*hg_Params[3].zw;\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
             "    r4 = float4(r3.xzzy > r3.yxyz);\n"
             "    r11.x = float(r3.y > r3.x);\n"
             "    r12 = float4(r3.yxxz >= r3.xyzy);\n"
             "    r13 = r2 - r8;\n"
             "    r14 = r7 - r1;\n"
             "    r15 = r8 - r7;\n"
             "    r16 = r13*r3.xxxx;\n"
             "    r16 = r14*r3.yyyy + r16;\n"
             "    r15 = r15*r3.zzzz + r16;\n"
             "    r16 = r10 - r9;\n"
             "    r17 = r2 - r10;\n"
             "    r18 = r9 - r1;\n"
             "    r16 = r16*r3.xxxx;\n"
             "    r16 = r17*r3.yyyy + r16;\n"
             "    r16 = r18*r3.zzzz + r16;\n"
             "    r19 = fmin(r4.xxxx, r4.yyyy);\n"
             "    r15 = select(r15, r16, r19 > 0.00000f);\n"
             "    r8 = r8 - r9;\n"
             "    r13 = r13*r3.xxxx;\n"
             "    r13 = r8*r3.yyyy + r13;\n"
             "    r13 = r18*r3.zzzz + r13;\n"
             "    r19 = fmin(r12.xxxx, r4.zzzz);\n"
             "    r15 = select(r15, r13, r19 > 0.00000f);\n"
             "    r16 = r5 - r1;\n"
             "    r9 = r6 - r5;\n"
             "    r2 = r2 - r6;\n"
             "    r8 = r16*r3.xxxx;\n"
             "    r8 = r9*r3.yyyy + r8;\n"
             "    r8 = r2*r3.zzzz + r8;\n"
             "    r4 = fmin(r4.wwww, r12.yyyy);\n"
             "    r15 = select(r15, r8, r4 > 0.00000f);\n"
             "    r6 = r6 - r7;\n"
             "    r6 = r6*r3.xxxx;\n"
             "    r6 = r14*r3.yyyy + r6;\n"
             "    r6 = r2*r3.zzzz + r6;\n"
             "    r11 = fmin(r12.zzzz, r11.xxxx);\n"
             "    r15 = select(r15, r6, r11 > 0.00000f);\n"
             "    r10 = r10 - r5;\n"
             "    r16 = r16*r3.xxxx;\n"
             "    r16 = r17*r3.yyyy + r16;\n"
             "    r16 = r10*r3.zzzz + r16;\n"
             "    r12 = fmin(r12.wwww, r12.zzzz);\n"
             "    r12 = select(r15, r16, r12 > 0.00000f);\n"
             "    r12 = r12 + r1;\n"
             "    r12 = r12*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
             "    output.color0 = select(r12, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a220cc55:c2718b3d:efb1f626:1df26c2c\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:0014:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_462;
  }
}

void HgcApply3DLUTTetrahedralUniform_basekernel::InitProgramDescriptor(HgcApply3DLUTTetrahedralUniform_basekernel *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcApply3DLUTTetrahedralUniform_basekernel_hgc_visible", "//Metal1.0     \n//LEN=0000000d5b\n[[ visible ]] FragmentOut HgcApply3DLUTTetrahedralUniform_basekernel_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = hg_Params[1].yyy - c0.xxx;\n"
    "    r1.xyz = r1.xyz*r2.xyz;\n"
    "    r1.xyz = fmax(r1.xyz, c0.yyy);\n"
    "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
    "    r3.xyz = fract(r1.xyz);\n"
    "    r1.xyz = floor(r1.xyz);\n"
    "    r4.xyz = r1.xyz + c0.xxx;\n"
    "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
    "    r4.xyz = r4.xyz - r1.xyz;\n"
    "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
    "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
    "    r2.y = r1.z;\n"
    "    r2.xy = r2.xy + c0.zz;\n"
    "    r1.xy = r2.xy + hg_Params[3].xy;\n"
    "    r1.xy = r1.xy*hg_Params[3].zw;\n"
    "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r5.xy = r2.xy + hg_Params[3].xy;\n"
    "    r5.xy = r5.xy*hg_Params[3].zw;\n"
    "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r6.xy = r2.xy + hg_Params[3].xy;\n"
    "    r6.xy = r6.xy*hg_Params[3].zw;\n"
    "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
    "    r2.x = r2.x - r4.x;\n"
    "    r7.xy = r2.xy + hg_Params[3].xy;\n"
    "    r7.xy = r7.xy*hg_Params[3].zw;\n"
    "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
    "    r2.y = r2.y + r4.z;\n"
    "    r8.xy = r2.xy + hg_Params[3].xy;\n"
    "    r8.xy = r8.xy*hg_Params[3].zw;\n"
    "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
    "    r2.x = r2.x - r4.y;\n"
    "    r9.xy = r2.xy + hg_Params[3].xy;\n"
    "    r9.xy = r9.xy*hg_Params[3].zw;\n"
    "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r10.xy = r2.xy + hg_Params[3].xy;\n"
    "    r10.xy = r10.xy*hg_Params[3].zw;\n"
    "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r2.xy = r2.xy + hg_Params[3].xy;\n"
    "    r2.xy = r2.xy*hg_Params[3].zw;\n"
    "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
    "    r4 = float4(r3.xzzy > r3.yxyz);\n"
    "    r11.x = float(r3.y > r3.x);\n"
    "    r12 = float4(r3.yxxz >= r3.xyzy);\n"
    "    r13 = r2 - r8;\n"
    "    r14 = r7 - r1;\n"
    "    r15 = r8 - r7;\n"
    "    r16 = r13*r3.xxxx;\n"
    "    r16 = r14*r3.yyyy + r16;\n"
    "    r15 = r15*r3.zzzz + r16;\n"
    "    r16 = r10 - r9;\n"
    "    r17 = r2 - r10;\n"
    "    r18 = r9 - r1;\n"
    "    r16 = r16*r3.xxxx;\n"
    "    r16 = r17*r3.yyyy + r16;\n"
    "    r16 = r18*r3.zzzz + r16;\n"
    "    r19 = fmin(r4.xxxx, r4.yyyy);\n"
    "    r15 = select(r15, r16, r19 > 0.00000f);\n"
    "    r8 = r8 - r9;\n"
    "    r13 = r13*r3.xxxx;\n"
    "    r13 = r8*r3.yyyy + r13;\n"
    "    r13 = r18*r3.zzzz + r13;\n"
    "    r19 = fmin(r12.xxxx, r4.zzzz);\n"
    "    r15 = select(r15, r13, r19 > 0.00000f);\n"
    "    r16 = r5 - r1;\n"
    "    r9 = r6 - r5;\n"
    "    r2 = r2 - r6;\n"
    "    r8 = r16*r3.xxxx;\n"
    "    r8 = r9*r3.yyyy + r8;\n"
    "    r8 = r2*r3.zzzz + r8;\n"
    "    r4 = fmin(r4.wwww, r12.yyyy);\n"
    "    r15 = select(r15, r8, r4 > 0.00000f);\n"
    "    r6 = r6 - r7;\n"
    "    r6 = r6*r3.xxxx;\n"
    "    r6 = r14*r3.yyyy + r6;\n"
    "    r6 = r2*r3.zzzz + r6;\n"
    "    r11 = fmin(r12.zzzz, r11.xxxx);\n"
    "    r15 = select(r15, r6, r11 > 0.00000f);\n"
    "    r10 = r10 - r5;\n"
    "    r16 = r16*r3.xxxx;\n"
    "    r16 = r17*r3.yyyy + r16;\n"
    "    r16 = r10*r3.zzzz + r16;\n"
    "    r12 = fmin(r12.wwww, r12.zzzz);\n"
    "    r12 = select(r15, r16, r12 > 0.00000f);\n"
    "    r12 = r12 + r1;\n"
    "    r12 = r12*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
    "    output.color0 = select(r12, r0, hg_Params[2] < 0.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BE3F50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BE3F88(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BE3F80);
}

double HgcApply3DLUTTetrahedralUniform_basekernel::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x38uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35542B0;
  strcpy(v3, "HgcApply3DLUTTetrahedralUniform_basekernel [hgc1]");
  return *(double *)"basekernel [hgc1]";
}

uint64_t HgcApply3DLUTTetrahedralUniform_basekernel::BindTexture(HgcApply3DLUTTetrahedralUniform_basekernel *this, HGHandler *a2, int a3)
{
  int v4;
  uint64_t result;
  __n128 v6;
  __n128 v7;
  __n128 v8;
  __n128 v9;

  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    {
      v8.n128_u32[0] = 1.0;
      v9.n128_u32[0] = 1.0;
    }
    else
    {
      v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v9.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v6.n128_f32[0] = (float)*((int *)a2 + 60);
    v7.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 3, v6, v7, v8, v9);
    return 0;
  }
  else if (a3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    v4 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
    result = 0;
    if (!v4)
    {
      (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcApply3DLUTTetrahedralUniform_basekernel::Bind(HgcApply3DLUTTetrahedralUniform_basekernel *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HgcApply3DLUTTetrahedralUniform_basekernel *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcApply3DLUTTetrahedralUniform_basekernel::RenderTile(HgcApply3DLUTTetrahedralUniform_basekernel *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  int v5;
  float32x4_t v6;
  int32x2_t v7;
  int32x2_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v12;
  uint64_t v13;
  _OWORD *v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  int32x2_t v28;
  __int32 v29;
  float32x4_t v30;
  float32x4_t v31;
  int32x4_t v32;
  __int32 v33;
  float32x4_t v34;
  __int32 v35;
  float32x4_t v36;
  int32x4_t v37;
  __int32 v38;
  __int32 v39;
  __int32 v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int32x4_t v45;
  __int32 v46;
  __int32 v47;
  __int32 v48;
  int8x16_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  int32x4_t v53;
  __int32 v54;
  __int32 v55;
  __int32 v56;
  int8x16_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  int32x4_t v61;
  __int32 v62;
  float32x4_t v63;
  __int32 v64;
  float32x4_t v65;
  float32x4_t v66;
  __int32 v67;
  int32x4_t v68;
  __int32 v69;
  __int32 v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  int32x4_t v76;
  float32x4_t v77;
  __int32 v78;
  int8x16_t v79;
  int8x16_t v80;
  __int32 v81;
  __int32 v82;
  int32x4_t v83;
  float32x4_t v84;
  int8x16_t v85;
  float32x4_t v86;
  int32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  int8x16_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  int8x16_t v99;
  float32x4_t v100;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      v7 = a2[10];
      v8 = a2[2];
      v9 = 16 * a2[11].i32[0];
      v10 = 16 * a2[3].i32[0];
      v11 = 16 * v4;
      v12.i64[0] = 0x3F0000003F000000;
      v12.i64[1] = 0x3F0000003F000000;
      do
      {
        v13 = 0;
        do
        {
          v14 = (_OWORD *)*((_QWORD *)this + 51);
          v15 = *(float32x4_t *)(*(_QWORD *)&v7 + v13);
          v16 = *((float32x4_t *)v14 + 1);
          v17 = *((float32x4_t *)v14 + 3);
          v18 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1), v17);
          v19 = *((float32x4_t *)v14 + 4);
          v20 = *((int8x16_t *)v14 + 5);
          v21 = vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14, 1), vmulq_n_f32(v15, COERCE_FLOAT(*v14))), v18), v19), v18);
          v22 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
          v23 = vsubq_f32(v22, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v22, v21)));
          v24 = vmulq_f32(v16, v23);
          v25 = vmulq_f32(v16, vsubq_f32(vminq_f32(vaddq_f32(v17, v23), v18), v23));
          v26 = *((int8x16_t *)v14 + 7);
          v27 = vaddq_f32(*((float32x4_t *)v14 + 6), (float32x4_t)vbslq_s8(v20, (int8x16_t)vaddq_f32(v24, (float32x4_t)vrev64q_s32((int32x4_t)v24)), vextq_s8((int8x16_t)v23, (int8x16_t)v23, 4uLL)));
          v28 = a2[12];
          v29 = a2[13].i32[0];
          v30 = vsubq_f32(v21, v23);
          v31 = vaddq_f32(vsubq_f32(v27, v6), v12);
          v32 = vcvtq_s32_f32(v31);
          v31.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
          v33 = v31.i32[1];
          v34 = (float32x4_t)vbslq_s8(v20, (int8x16_t)vaddq_f32(v25, v27), (int8x16_t)v27);
          v35 = v31.i32[0];
          v36 = vaddq_f32(vsubq_f32(v34, v6), v12);
          v37 = vcvtq_s32_f32(v36);
          v36.i64[0] = vaddq_s32(v37, vcgtq_f32(vcvtq_f32_s32(v37), v36)).u64[0];
          v38 = v35 + v33 * v29;
          v39 = v36.i32[1];
          v40 = v36.i32[0];
          v41 = (float32x4_t)vrev64q_s32((int32x4_t)v25);
          v42 = *(float32x4_t *)(*(_QWORD *)&v28 + 16 * v38);
          v43 = (float32x4_t)vbslq_s8(v20, (int8x16_t)vaddq_f32(v41, v34), (int8x16_t)v27);
          v44 = vaddq_f32(vsubq_f32(v43, v6), v12);
          v45 = vcvtq_s32_f32(v44);
          v46 = v40 + v39 * v29;
          v44.i64[0] = vaddq_s32(v45, vcgtq_f32(vcvtq_f32_s32(v45), v44)).u64[0];
          v47 = v44.i32[1];
          v48 = v44.i32[0];
          v49 = (int8x16_t)vsubq_f32(v43, v25);
          v50 = (float32x4_t)vbslq_s8(v20, v49, (int8x16_t)v27);
          v51 = vaddq_f32(vsubq_f32(v50, v6), v12);
          v52 = *(float32x4_t *)(*(_QWORD *)&v28 + 16 * v46);
          v53 = vcvtq_s32_f32(v51);
          v51.i64[0] = vaddq_s32(v53, vcgtq_f32(vcvtq_f32_s32(v53), v51)).u64[0];
          v54 = v51.i32[1];
          v55 = v48 + v47 * v29;
          v56 = v51.i32[0];
          v57 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 4uLL), v50);
          v58 = *(float32x4_t *)(*(_QWORD *)&v28 + 16 * v55);
          v59 = (float32x4_t)vbslq_s8(v20, v49, v57);
          v60 = vaddq_f32(vsubq_f32(v59, v6), v12);
          v61 = vcvtq_s32_f32(v60);
          v60.i64[0] = vaddq_s32(v61, vcgtq_f32(vcvtq_f32_s32(v61), v60)).u64[0];
          v62 = v60.i32[1];
          v63 = *(float32x4_t *)(*(_QWORD *)&v28 + 16 * (v56 + v54 * v29));
          v64 = v60.i32[0];
          v65 = (float32x4_t)vbslq_s8(v20, (int8x16_t)vsubq_f32(v59, v41), v57);
          v66 = vaddq_f32(vsubq_f32(v65, v6), v12);
          v67 = v64 + v62 * v29;
          v68 = vcvtq_s32_f32(v66);
          v66.i64[0] = vaddq_s32(v68, vcgtq_f32(vcvtq_f32_s32(v68), v66)).u64[0];
          v69 = v66.i32[1];
          v70 = v66.i32[0];
          v71 = (float32x4_t)vbslq_s8(v20, (int8x16_t)vaddq_f32(v25, v65), v57);
          v72 = *(float32x4_t *)(*(_QWORD *)&v28 + 16 * v67);
          v73 = vaddq_f32(vsubq_f32(v71, v6), v12);
          v74 = (float32x4_t)vcvtq_s32_f32(v73);
          v73.i64[0] = vaddq_s32((int32x4_t)v74, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v74), v73)).u64[0];
          v75 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v20, (int8x16_t)vaddq_f32(v41, v71), v57), v6), v12);
          v76 = vcvtq_s32_f32(v75);
          v77 = *(float32x4_t *)(*(_QWORD *)&v28 + 16 * (v70 + v69 * v29));
          *(int8x8_t *)v71.f32 = vqtbl1_s8((int8x16_t)v30, *(int8x8_t *)v26.i8);
          *(int8x8_t *)&v71.u32[2] = vqtbl1_s8((int8x16_t)v30, (int8x8_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL));
          v78 = v73.i32[0] + v73.i32[1] * v29;
          v75.i64[0] = vaddq_s32(v76, vcgtq_f32(vcvtq_f32_s32(v76), v75)).u64[0];
          v79 = *((int8x16_t *)v14 + 8);
          v80 = *((int8x16_t *)v14 + 9);
          *(int8x8_t *)v73.f32 = vqtbl1_s8((int8x16_t)v30, *(int8x8_t *)v79.i8);
          v81 = v75.i32[1];
          *(int8x8_t *)&v73.u32[2] = vqtbl1_s8((int8x16_t)v30, (int8x8_t)*(_OWORD *)&vextq_s8(v79, v79, 8uLL));
          v82 = v75.i32[0];
          v83 = (int32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v73, v71));
          v79.i64[0] = vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v30), v30)).u64[0];
          v84 = *(float32x4_t *)(*(_QWORD *)&v28 + 16 * v78);
          *(int8x8_t *)v73.f32 = vqtbl1_s8((int8x16_t)v30, *(int8x8_t *)v80.i8);
          *(int8x8_t *)&v73.u32[2] = vqtbl1_s8((int8x16_t)v30, (int8x8_t)*(_OWORD *)&vextq_s8(v80, v80, 8uLL));
          v85 = *((int8x16_t *)v14 + 10);
          *(int8x8_t *)v74.f32 = vqtbl1_s8((int8x16_t)v30, *(int8x8_t *)v85.i8);
          v86 = *(float32x4_t *)(*(_QWORD *)&v28 + 16 * (v82 + v81 * v29));
          *(int8x8_t *)&v74.u32[2] = vqtbl1_s8((int8x16_t)v30, (int8x8_t)*(_OWORD *)&vextq_s8(v85, v85, 8uLL));
          v87 = (int32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgeq_f32(v74, v73));
          v88 = vmulq_lane_f32(vsubq_f32(v63, v42), *(float32x2_t *)v30.f32, 1);
          v89 = vmulq_n_f32(vsubq_f32(v86, v72), v30.f32[0]);
          v90 = vmulq_n_f32(vsubq_f32(v84, v77), v30.f32[0]);
          v91 = vmulq_laneq_f32(vsubq_f32(v77, v42), v30, 2);
          v92 = vmulq_lane_f32(vsubq_f32(v86, v84), *(float32x2_t *)v30.f32, 1);
          v93 = vmulq_lane_f32(vsubq_f32(v72, v77), *(float32x2_t *)v30.f32, 1);
          v94 = (int8x16_t)vaddq_f32(vmulq_laneq_f32(vsubq_f32(v72, v63), v30, 2), vaddq_f32(v88, v89));
          v95 = vmulq_n_f32(vsubq_f32(v52, v42), v30.f32[0]);
          v96 = vaddq_f32(v95, vmulq_lane_f32(vsubq_f32(v58, v52), *(float32x2_t *)v30.f32, 1));
          v97 = vmulq_laneq_f32(vsubq_f32(v86, v58), v30, 2);
          v98 = vaddq_f32(vmulq_n_f32(vsubq_f32(v58, v63), v30.f32[0]), v88);
          v99 = vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v83.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v83.i8, 1)), v19), (int8x16_t)vaddq_f32(v91, vaddq_f32(v90, v92)), v94);
          v100 = (float32x4_t)vdupq_laneq_s32(v87, 2);
          *(int8x16_t *)(*(_QWORD *)&v8 + v13) = vbslq_s8((int8x16_t)vcgtq_f32(v19, *((float32x4_t *)v14 + 2)), (int8x16_t)v15, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v14, 3), vmulq_laneq_f32(vaddq_f32(v42, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32(v87, 3), v100), v19), (int8x16_t)vaddq_f32(vmulq_laneq_f32(vsubq_f32(v84, v52), v30, 2), vaddq_f32(v95, v92)),
                                                                                   vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32(v100, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v79.i8, 0)), v19), (int8x16_t)vaddq_f32(v98, v97), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32(v83, 3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v87.i8, 1)), v19), (int8x16_t)vaddq_f32(v96, v97), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v87.i8, 0), (float32x4_t)vdupq_laneq_s32(v83, 2)), v19), (int8x16_t)vaddq_f32(v91, vaddq_f32(v93, v89)), v99))))), *(float32x4_t *)v14, 2)));
          v13 += 16;
        }
        while (v11 != v13);
        ++v5;
        *(_QWORD *)&v7 += v9;
        *(_QWORD *)&v8 += v10;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcApply3DLUTTetrahedralUniform_basekernel::GetDOD(HgcApply3DLUTTetrahedralUniform_basekernel *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 1)
    return 0x8000000080000000;
  if (a3)
    return 0;
  return *(_QWORD *)&a4.var0;
}

uint64_t HgcApply3DLUTTetrahedralUniform_basekernel::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, 1u);
    return HGRenderer::GetDOD(a2, Input);
  }
  else if (a3)
  {
    return 0;
  }
  else
  {
    return *(_QWORD *)&a4.var0;
  }
}

void HgcApply3DLUTTetrahedralUniform_basekernel::HgcApply3DLUTTetrahedralUniform_basekernel(HgcApply3DLUTTetrahedralUniform_basekernel *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6547A08;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  __asm { FMOV            V1.4S, #1.0 }
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = _Q1;
  *(_QWORD *)(v3 + 64) = 0;
  *(_QWORD *)(v3 + 72) = 0;
  *(_OWORD *)(v3 + 80) = xmmword_1B3050E20;
  *(_OWORD *)(v3 + 96) = xmmword_1B3052100;
  *(_OWORD *)(v3 + 112) = xmmword_1B3553D10;
  *(_OWORD *)(v3 + 128) = xmmword_1B3553D20;
  *(_OWORD *)(v3 + 144) = xmmword_1B3553D30;
  *(_OWORD *)(v3 + 160) = xmmword_1B3553D40;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcApply3DLUTTetrahedralUniform_basekernel *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BE4778(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcApply3DLUTTetrahedralUniform_basekernel::~HgcApply3DLUTTetrahedralUniform_basekernel(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6547A08;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40C3A7E6FCLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6547A08;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40C3A7E6FCLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6547A08;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40C3A7E6FCLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcApply3DLUTTetrahedralUniform_basekernel::SetParameter(HgcApply3DLUTTetrahedralUniform_basekernel *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcApply3DLUTTetrahedralUniform_basekernel::GetParameter(HgcApply3DLUTTetrahedralUniform_basekernel *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcToneParamCurve3::GetProgram(HgcToneParamCurve3 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000369\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = half3(hg_Params[1].xyz)*r0.xyz + half3(hg_Params[2].xyz);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xyz));\n"
             "    r2.xyz = r0.xyz - half3(hg_Params[4].xyz);\n"
             "    r3.xyz = r0.xyz*half3(hg_Params[3].xyz);\n"
             "    output.color0.xyz = select(float3(r1.xyz), float3(r3.xyz), float3(r2.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a08c8d94:38f96d5c:26c0e933:55620f24\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0005:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000321\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
             "    r2.xyz = r0.xyz - hg_Params[4].xyz;\n"
             "    r3.xyz = r0.xyz*hg_Params[3].xyz;\n"
             "    output.color0.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=41552887:797b0b83:44ffd324:adfe9f8c\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0005:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003cd\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "uniform mediump vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = hg_ProgramLocal1.xyz*r0.xyz + hg_ProgramLocal2.xyz;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xyz);\n"
           "    r2.xyz = r0.xyz - hg_ProgramLocal4.xyz;\n"
           "    r3.xyz = r0.xyz*hg_ProgramLocal3.xyz;\n"
           "    gl_FragColor.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z"
           " : r1.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=1974bb9c:fd223adc:1fc4ae62:4edb9b94\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0005:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve3::InitProgramDescriptor(HgcToneParamCurve3 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve3_hgc_visible", "//Metal1.0     \n//LEN=00000001fd\n[[ visible ]] FragmentOut HgcToneParamCurve3_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
    "    r2.xyz = r0.xyz - hg_Params[4].xyz;\n"
    "    r3.xyz = r0.xyz*hg_Params[3].xyz;\n"
    "    output.color0.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BE4BD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BE4C04(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BE4BFCLL);
}

double HgcToneParamCurve3::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcToneParamCurve3 [hgc1]");
  return *(double *)"ramCurve3 [hgc1]";
}

uint64_t HgcToneParamCurve3::BindTexture(HgcToneParamCurve3 *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve3::Bind(HgcToneParamCurve3 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HgcToneParamCurve3 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcToneParamCurve3::RenderTile(HgcToneParamCurve3 *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int32x4_t v58;
  int32x4_t v59;
  float32x4_t v60;
  int8x16_t v61;
  int8x16_t v62;
  int8x16_t *v63;
  int v64;
  uint64_t v65;
  float32x4_t v66;
  uint64_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v64 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v12 = *(float32x4_t *)(v6 + v10 - 16);
      v11 = *(float32x4_t *)(v6 + v10);
      v13 = *((_QWORD *)this + 51);
      v14 = *(float32x4_t *)(v13 + 16);
      v15 = *(float32x4_t *)(v13 + 32);
      v16 = *(float32x4_t *)(v13 + 48);
      v17 = vaddq_f32(v15, vmulq_f32(v12, v14));
      v18 = vaddq_f32(v15, vmulq_f32(v11, v14));
      v20 = *(float32x4_t *)(v13 + 64);
      v19 = *(int8x16_t *)(v13 + 80);
      v21 = *(float32x4_t *)(v13 + 96);
      v22 = *(float32x4_t *)(v13 + 112);
      v23 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v17), (int8x16_t)v21);
      v24 = *(int8x16_t *)(v13 + 128);
      v25 = *(float32x4_t *)(v13 + 144);
      v26 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v18), (int8x16_t)v21);
      v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v18)));
      v28 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v17))), v25);
      v29 = *(float32x4_t *)(v13 + 160);
      v30 = *(float32x4_t *)(v13 + 176);
      v31 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v23, v29));
      v32 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v26, v29));
      v33 = vaddq_f32(v28, v31);
      v34 = vaddq_f32(vsubq_f32(v27, v25), v32);
      v35 = vsubq_f32(vsubq_f32(v23, v21), vmulq_f32(vmulq_f32(v30, v31), v23));
      v36 = vsubq_f32(vsubq_f32(v26, v21), vmulq_f32(vmulq_f32(v30, v32), v26));
      v37 = *(float32x4_t *)(v13 + 192);
      v38 = *(float32x4_t *)(v13 + 208);
      v39 = vaddq_f32(v37, vmulq_f32(v38, v35));
      v40 = vaddq_f32(v37, vmulq_f32(v38, v36));
      v41 = *(float32x4_t *)(v13 + 224);
      v42 = *(float32x4_t *)(v13 + 240);
      v43 = vmulq_f32(*(float32x4_t *)v13, vaddq_f32(v34, vmulq_f32(v36, vaddq_f32(vaddq_f32(v41, vmulq_f32(v36, v42)), vmulq_f32(vmulq_f32(v36, v36), v40)))));
      v44 = *(float32x4_t *)(v13 + 256);
      v45 = *(float32x4_t *)(v13 + 272);
      v46 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v13, vaddq_f32(v33, vmulq_f32(v35, vaddq_f32(vaddq_f32(v41, vmulq_f32(v35, v42)), vmulq_f32(vmulq_f32(v35, v35), v39))))), v44);
      v47 = vmaxq_f32(v43, v44);
      v48 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
      v49 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      v50 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v48, v46)));
      v51 = vsubq_f32(v49, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v49, v47)));
      v52 = vsubq_f32(v46, v50);
      v53 = vsubq_f32(v47, v51);
      v54 = *(float32x4_t *)(v13 + 288);
      v55 = *(float32x4_t *)(v13 + 304);
      v56 = vmulq_f32(v53, vaddq_f32(v55, vmulq_f32(v53, vaddq_f32(v45, vmulq_f32(v54, v53)))));
      v57 = vaddq_f32(v21, vmulq_f32(v52, vaddq_f32(v55, vmulq_f32(v52, vaddq_f32(v45, vmulq_f32(v54, v52))))));
      v58 = vcvtq_s32_f32(v51);
      v59 = *(int32x4_t *)(v13 + 320);
      v60 = *(float32x4_t *)(v13 + 336);
      v61 = (int8x16_t)vmulq_f32(v57, (float32x4_t)vshlq_n_s32(vaddq_s32(v59, vcvtq_s32_f32(v50)), 0x17uLL));
      v62 = *(int8x16_t *)(v13 + 352);
      v63 = (int8x16_t *)(v5 + v10);
      v63[-1] = vbslq_s8(v62, (int8x16_t)v12, vbslq_s8((int8x16_t)vcgtq_f32(v60, vsubq_f32(v12, v20)), (int8x16_t)vmulq_f32(v12, v16), v61));
      *v63 = vbslq_s8(v62, (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32(v60, vsubq_f32(v11, v20)), (int8x16_t)vmulq_f32(v11, v16), (int8x16_t)vmulq_f32(vaddq_f32(v21, v56), (float32x4_t)vshlq_n_s32(vaddq_s32(v59, v58), 0x17uLL))));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v64 = -v9;
    if (v64 >= v4)
      goto LABEL_3;
LABEL_10:
    v65 = 16 * v64;
    v66 = *(float32x4_t *)(v6 + v65);
    v67 = *((_QWORD *)this + 51);
    v68 = vaddq_f32(*(float32x4_t *)(v67 + 32), vmulq_f32(v66, *(float32x4_t *)(v67 + 16)));
    v69 = *(float32x4_t *)(v67 + 96);
    v70 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v67 + 80), (int8x16_t)v68), (int8x16_t)v69);
    v71 = (float32x4_t)vandq_s8((int8x16_t)v69, (int8x16_t)vcgtq_f32(v70, *(float32x4_t *)(v67 + 160)));
    v72 = vsubq_f32(vsubq_f32(v70, v69), vmulq_f32(vmulq_f32(*(float32x4_t *)(v67 + 176), v71), v70));
    v73 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v67, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v68, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v67 + 128), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v67 + 112), v68))), *(float32x4_t *)(v67 + 144)), v71), vmulq_f32(v72, vaddq_f32(vaddq_f32(*(float32x4_t *)(v67 + 224), vmulq_f32(v72, *(float32x4_t *)(v67 + 240))), vmulq_f32(vmulq_f32(v72, v72), vaddq_f32(*(float32x4_t *)(v67 + 192), vmulq_f32(*(float32x4_t *)(v67 + 208), v72))))))),
            *(float32x4_t *)(v67 + 256));
    v74 = vcvtq_f32_s32(vcvtq_s32_f32(v73));
    v75 = vsubq_f32(v74, (float32x4_t)vandq_s8((int8x16_t)v69, (int8x16_t)vcgtq_f32(v74, v73)));
    v76 = vsubq_f32(v73, v75);
    *(int8x16_t *)(v5 + v65) = vbslq_s8(*(int8x16_t *)(v67 + 352), (int8x16_t)v66, vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(v67 + 336), vsubq_f32(v66, *(float32x4_t *)(v67 + 64))), (int8x16_t)vmulq_f32(v66, *(float32x4_t *)(v67 + 48)), (int8x16_t)vmulq_f32(vaddq_f32(v69, vmulq_f32(v76, vaddq_f32(*(float32x4_t *)(v67 + 304), vmulq_f32(v76, vaddq_f32(*(float32x4_t *)(v67 + 272), vmulq_f32(*(float32x4_t *)(v67 + 288), v76)))))),
                                                (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v67 + 320), vcvtq_s32_f32(v75)), 0x17uLL))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcToneParamCurve3::GetDOD(HgcToneParamCurve3 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcToneParamCurve3::GetROI(HgcToneParamCurve3 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcToneParamCurve3::HgcToneParamCurve3(HgcToneParamCurve3 *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6547C70;
  v3 = operator new();
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051600;
  *(_OWORD *)(v3 + 96) = xmmword_1B3051560;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051610;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051620;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051630;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051640;
  *(_OWORD *)(v3 + 176) = xmmword_1B3051510;
  *(_OWORD *)(v3 + 192) = xmmword_1B3051650;
  *(_OWORD *)(v3 + 208) = xmmword_1B3051660;
  *(_OWORD *)(v3 + 224) = xmmword_1B3051670;
  *(_OWORD *)(v3 + 240) = xmmword_1B3051680;
  *(_OWORD *)(v3 + 256) = xmmword_1B3051690;
  *(_OWORD *)(v3 + 272) = xmmword_1B30516A0;
  *(_OWORD *)(v3 + 288) = xmmword_1B30516B0;
  *(_OWORD *)(v3 + 304) = xmmword_1B30516C0;
  *(_OWORD *)(v3 + 320) = xmmword_1B30516D0;
  *(_QWORD *)(v3 + 336) = 0;
  *(_QWORD *)(v3 + 344) = 0;
  *(_OWORD *)(v3 + 352) = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BE52B0(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve3::~HgcToneParamCurve3(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6547C70;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C409BD2D9E4);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6547C70;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C409BD2D9E4);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve3::SetParameter(HgcToneParamCurve3 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 4)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcToneParamCurve3::GetParameter(HgcToneParamCurve3 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 4)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcPixelFormatConversion_kV4S_BE_WXYZ_input::GetProgram(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
    return "//Metal1.0     \n"
           "//LEN=000000032e\n"
           "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
           "    const constant float4* hg_Params [[ buffer(0) ]], \n"
           "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
           "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    const float4 c0 = float4(65535.00000, 0.003906250000, 256.0000000, 1.525902189e-05);\n"
           "    float4 r0, r1;\n"
           "    FragmentOut output;\n"
           "\n"
           "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
           "    r0 = r0*c0.xxxx;\n"
           "    r0 = floor(r0);\n"
           "    r0 = r0*c0.yyyy;\n"
           "    r1 = fract(r0);\n"
           "    r1 = r1*c0.zzzz;\n"
           "    r1 = floor(r1);\n"
           "    r0 = floor(r0);\n"
           "    r1 = c0.zzzz*r1 + r0;\n"
           "    output.color0 = r1.yzwx*c0.wwww;\n"
           "    return output;\n"
           "}\n"
           "//MD5=0b7535b4:5e0e2440:c1eacd8a:64887f82\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  if (Target <= 0x6060F || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
    return 0;
  return "//GLfs2.0      \n"
         "//LEN=00000002d3\n"
         "#ifndef GL_ES\n"
         "#define lowp\n"
         "#define mediump\n"
         "#define highp\n"
         "#endif\n"
         "#define defaultp mediump\n"
         "uniform defaultp sampler2D hg_Texture0;\n"
         "varying highp vec4 hg_TexCoord0;\n"
         "void main()\n"
         "{\n"
         "    const mediump vec4 c0 = vec4(65535.00000, 0.003906250000, 256.0000000, 1.525902189e-05);\n"
         "    mediump vec4 r0, r1;\n"
         "\n"
         "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
         "    r0 = r0*c0.xxxx;\n"
         "    r0 = floor(r0);\n"
         "    r0 = r0*c0.yyyy;\n"
         "    r1 = fract(r0);\n"
         "    r1 = r1*c0.zzzz;\n"
         "    r1 = floor(r1);\n"
         "    r0 = floor(r0);\n"
         "    r1 = c0.zzzz*r1 + r0;\n"
         "    gl_FragColor = r1.yzwx*c0.wwww;\n"
         "}\n"
         "//MD5=f4968c87:51150e17:f7500ea5:7d3e7928\n"
         "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
}

void HgcPixelFormatConversion_kV4S_BE_WXYZ_input::InitProgramDescriptor(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4S_BE_WXYZ_input_hgc_visible", "//Metal1.0     \n//LEN=0000000223\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4S_BE_WXYZ_input_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(65535.00000, 0.003906250000, 256.0000000, 1.525902189e-05);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0*c0.xxxx;\n"
    "    r0 = floor(r0);\n"
    "    r0 = r0*c0.yyyy;\n"
    "    r1 = fract(r0);\n"
    "    r1 = r1*c0.zzzz;\n"
    "    r1 = floor(r1);\n"
    "    r0 = floor(r0);\n"
    "    r1 = c0.zzzz*r1 + r0;\n"
    "    output.color0 = r1.yzwx*c0.wwww;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BE56A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BE56D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BE56C8);
}

double HgcPixelFormatConversion_kV4S_BE_WXYZ_input::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x38uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B309DA80;
  strcpy(v3, "HgcPixelFormatConversion_kV4S_BE_WXYZ_input [hgc1]");
  return *(double *)"_WXYZ_input [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_input::BindTexture(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_input::Bind(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, HGHandler *a2)
{
  (*(void (**)(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_input::RenderTile(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t *v11;
  float32x4_t *v12;
  unint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  uint64_t v16;
  float32x4_t *v17;
  float32x4_t *v18;
  uint64_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  int8x16_t v53;
  int8x16_t v54;
  int8x16_t v55;
  int8x16_t v56;
  float32x4_t v57;
  float32x4_t *v58;
  float32x4_t v59;
  uint64_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  int8x16_t v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  int8x16_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int8x16_t v86;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v71 = 0;
        v72 = 16 * v7;
        v73 = 16 * v6;
        v74 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v75 = 0;
          do
          {
            v76 = *((_QWORD *)this + 51);
            v77 = *(int8x16_t *)(v76 + 16);
            v78 = vmulq_f32(v4[v75 / 0x10], *(float32x4_t *)v76);
            v79 = vcvtq_f32_s32(vcvtq_s32_f32(v78));
            v80 = *(float32x4_t *)(v76 + 48);
            v81 = vmulq_f32(*(float32x4_t *)(v76 + 32), vsubq_f32(v79, (float32x4_t)vandq_s8(v77, (int8x16_t)vcgtq_f32(v79, v78))));
            v82 = vcvtq_f32_s32(vcvtq_s32_f32(v81));
            v83 = vsubq_f32(v82, (float32x4_t)vandq_s8(v77, (int8x16_t)vcgtq_f32(v82, v81)));
            v84 = vmulq_f32(v80, vsubq_f32(v81, v83));
            v85 = vcvtq_f32_s32(vcvtq_s32_f32(v84));
            v86 = (int8x16_t)vaddq_f32(v83, vmulq_f32(v80, vsubq_f32(v85, (float32x4_t)vandq_s8(v77, (int8x16_t)vcgtq_f32(v85, v84)))));
            v5[v75 / 0x10] = vmulq_f32(*(float32x4_t *)(v76 + 64), (float32x4_t)vextq_s8(v86, v86, 4uLL));
            v75 += 16;
          }
          while (v74 != v75);
          ++v71;
          v4 = (float32x4_t *)((char *)v4 + v72);
          v5 = (float32x4_t *)((char *)v5 + v73);
        }
        while (v71 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = v14;
          v19 = *((_QWORD *)this + 51);
          v20 = *(int8x16_t *)(v19 + 16);
          v21 = vmulq_f32(v4[v16 - 2], *(float32x4_t *)v19);
          v22 = vmulq_f32(v4[v16 - 1], *(float32x4_t *)v19);
          v23 = vmulq_f32(v4[v16], *(float32x4_t *)v19);
          v24 = vmulq_f32(v4[v16 + 1], *(float32x4_t *)v19);
          v25 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
          v26 = vcvtq_f32_s32(vcvtq_s32_f32(v22));
          v27 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
          v28 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
          v29 = vsubq_f32(v25, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v25, v21)));
          v30 = vsubq_f32(v26, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v26, v22)));
          v31 = *(float32x4_t *)(v19 + 32);
          v32 = *(float32x4_t *)(v19 + 48);
          v33 = vmulq_f32(v31, v29);
          v34 = vmulq_f32(v31, v30);
          v35 = vmulq_f32(v31, vsubq_f32(v27, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v27, v23))));
          v36 = vmulq_f32(v31, vsubq_f32(v28, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v28, v24))));
          v37 = vcvtq_f32_s32(vcvtq_s32_f32(v33));
          v38 = vcvtq_f32_s32(vcvtq_s32_f32(v34));
          v39 = vcvtq_f32_s32(vcvtq_s32_f32(v35));
          v40 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
          v41 = vsubq_f32(v37, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v37, v33)));
          v42 = vsubq_f32(v38, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v38, v34)));
          v43 = vsubq_f32(v39, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v39, v35)));
          v44 = vsubq_f32(v40, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v40, v36)));
          v45 = vmulq_f32(v32, vsubq_f32(v33, v41));
          v46 = vmulq_f32(v32, vsubq_f32(v34, v42));
          v47 = vmulq_f32(v32, vsubq_f32(v35, v43));
          v48 = vmulq_f32(v32, vsubq_f32(v36, v44));
          v49 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
          v50 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
          v51 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
          v52 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
          v53 = (int8x16_t)vaddq_f32(v41, vmulq_f32(v32, vsubq_f32(v49, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v49, v45)))));
          v54 = (int8x16_t)vaddq_f32(v42, vmulq_f32(v32, vsubq_f32(v50, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v50, v46)))));
          v55 = (int8x16_t)vaddq_f32(v43, vmulq_f32(v32, vsubq_f32(v51, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v51, v47)))));
          v56 = (int8x16_t)vaddq_f32(v44, vmulq_f32(v32, vsubq_f32(v52, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v52, v48)))));
          v57 = *(float32x4_t *)(v19 + 64);
          v58 = &v5[v16];
          v13 += 4;
          v58[-2] = vmulq_f32(v57, (float32x4_t)vextq_s8(v53, v53, 4uLL));
          v58[-1] = vmulq_f32(v57, (float32x4_t)vextq_s8(v54, v54, 4uLL));
          *v58 = vmulq_f32(v57, (float32x4_t)vextq_s8(v55, v55, 4uLL));
          v58[1] = vmulq_f32(v57, (float32x4_t)vextq_s8(v56, v56, 4uLL));
          v16 += 4;
          v15 += 4;
          v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v59 = *v17++;
            v60 = *((_QWORD *)this + 51);
            v61 = *(int8x16_t *)(v60 + 16);
            v62 = vmulq_f32(v59, *(float32x4_t *)v60);
            v63 = vcvtq_f32_s32(vcvtq_s32_f32(v62));
            v64 = *(float32x4_t *)(v60 + 48);
            v65 = vmulq_f32(*(float32x4_t *)(v60 + 32), vsubq_f32(v63, (float32x4_t)vandq_s8(v61, (int8x16_t)vcgtq_f32(v63, v62))));
            v66 = vcvtq_f32_s32(vcvtq_s32_f32(v65));
            v67 = vsubq_f32(v66, (float32x4_t)vandq_s8(v61, (int8x16_t)vcgtq_f32(v66, v65)));
            v68 = vmulq_f32(v64, vsubq_f32(v65, v67));
            v69 = vcvtq_f32_s32(vcvtq_s32_f32(v68));
            v70 = (int8x16_t)vaddq_f32(v67, vmulq_f32(v64, vsubq_f32(v69, (float32x4_t)vandq_s8(v61, (int8x16_t)vcgtq_f32(v69, v68)))));
            *v18++ = vmulq_f32(*(float32x4_t *)(v60 + 64), (float32x4_t)vextq_s8(v70, v70, 4uLL));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (float32x4_t *)((char *)v5 + v9);
        v4 = (float32x4_t *)((char *)v4 + v10);
        v11 = (float32x4_t *)((char *)v11 + v10);
        v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_input::GetDOD(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_input::GetROI(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcPixelFormatConversion_kV4S_BE_WXYZ_input::HgcPixelFormatConversion_kV4S_BE_WXYZ_input(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6547ED8;
  v3 = operator new();
  __asm { FMOV            V1.4S, #1.0 }
  *(int32x4_t *)v3 = vdupq_n_s32(0x477FFF00u);
  *(_OWORD *)(v3 + 16) = _Q1;
  *(int32x4_t *)(v3 + 32) = vdupq_n_s32(0x3B800000u);
  *(int32x4_t *)(v3 + 48) = vdupq_n_s32(0x43800000u);
  *(int32x4_t *)(v3 + 64) = vdupq_n_s32(0x37800080u);
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BE5C54(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4S_BE_WXYZ_input::~HgcPixelFormatConversion_kV4S_BE_WXYZ_input(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6547ED8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6547ED8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6547ED8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_input::SetParameter(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_input::GetParameter(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcPixelFormatConversion_kV4F_WXYZ_output::GetProgram(HgcPixelFormatConversion_kV4F_WXYZ_output *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000022e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0.wxyz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cf796c8f:0088fb48:fbecfffa:bebd058b\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000220\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0.wxyz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6820d1f2:902f3939:8ad944e0:7499e717\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0.wxyz;\n"
           "}\n"
           "//MD5=3629bbaf:437df260:e6e61391:b5896e9d\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4F_WXYZ_output::InitProgramDescriptor(HgcPixelFormatConversion_kV4F_WXYZ_output *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4F_WXYZ_output_hgc_visible", "//Metal1.0     \n//LEN=0000000113\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4F_WXYZ_output_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0.wxyz;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BE5FF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BE6024(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BE601CLL);
}

double HgcPixelFormatConversion_kV4F_WXYZ_output::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x38uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3553C60;
  strcpy(v3, "HgcPixelFormatConversion_kV4F_WXYZ_output [hgc1]");
  return *(double *)"YZ_output [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_output::BindTexture(HgcPixelFormatConversion_kV4F_WXYZ_output *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_output::Bind(HgcPixelFormatConversion_kV4F_WXYZ_output *this, HGHandler *a2)
{
  (*(void (**)(HgcPixelFormatConversion_kV4F_WXYZ_output *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_output::RenderTile(HgcPixelFormatConversion_kV4F_WXYZ_output *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  int8x16_t *v4;
  int8x16_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int8x16_t *v11;
  int8x16_t *v12;
  unint64_t v13;
  int8x16_t *v14;
  int8x16_t *v15;
  uint64_t v16;
  int8x16_t *v17;
  int8x16_t *v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t *v22;
  int8x16_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (int8x16_t *)*((_QWORD *)a2 + 10);
    v5 = (int8x16_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v24 = 0;
        v25 = 16 * v7;
        v26 = 16 * v6;
        v27 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v28 = 0;
          do
          {
            v5[v28 / 0x10] = vextq_s8(v4[v28 / 0x10], v4[v28 / 0x10], 0xCuLL);
            v28 += 16;
          }
          while (v27 != v28);
          ++v24;
          v4 = (int8x16_t *)((char *)v4 + v25);
          v5 = (int8x16_t *)((char *)v5 + v26);
        }
        while (v24 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = v14;
          v19 = vextq_s8(v4[v16 - 1], v4[v16 - 1], 0xCuLL);
          v20 = vextq_s8(v4[v16], v4[v16], 0xCuLL);
          v21 = vextq_s8(v4[v16 + 1], v4[v16 + 1], 0xCuLL);
          v22 = &v5[v16];
          v22[-2] = vextq_s8(v4[v16 - 2], v4[v16 - 2], 0xCuLL);
          v22[-1] = v19;
          v13 += 4;
          *v22 = v20;
          v22[1] = v21;
          v16 += 4;
          v15 += 4;
          v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v23 = *v17++;
            *v18++ = vextq_s8(v23, v23, 0xCuLL);
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (int8x16_t *)((char *)v5 + v9);
        v4 = (int8x16_t *)((char *)v4 + v10);
        v11 = (int8x16_t *)((char *)v11 + v10);
        v12 = (int8x16_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_output::GetDOD(HgcPixelFormatConversion_kV4F_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_output::GetROI(HgcPixelFormatConversion_kV4F_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcPixelFormatConversion_kV4F_WXYZ_output::HgcPixelFormatConversion_kV4F_WXYZ_output(HgcPixelFormatConversion_kV4F_WXYZ_output *this)
{
  uint64_t v2;
  _OWORD *v3;

  HGColorMatrix::HGColorMatrix(this);
  *(_QWORD *)v2 = off_1E6548140;
  *(_DWORD *)(v2 + 504) = 1;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B304F230;
  v3[1] = xmmword_1B304F240;
  v3[2] = xmmword_1B304F250;
  v3[3] = xmmword_1B304EFF0;
  v3[4] = xmmword_1B304F230;
  v3[5] = xmmword_1B304F240;
  v3[6] = xmmword_1B304F250;
  v3[7] = xmmword_1B304EFF0;
  *((_QWORD *)this + 62) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BE6360(_Unwind_Exception *a1)
{
  HGColorMatrix *v1;

  HGColorMatrix::~HGColorMatrix(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4F_WXYZ_output::~HgcPixelFormatConversion_kV4F_WXYZ_output(HgcPixelFormatConversion_kV4F_WXYZ_output *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6548140;
  v2 = *((_QWORD *)this + 62);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGColorMatrix::~HGColorMatrix(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6548140;
  v2 = *((_QWORD *)this + 62);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGColorMatrix::~HGColorMatrix(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6548140;
  v2 = *((_QWORD *)this + 62);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGColorMatrix::~HGColorMatrix(this);
  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_output::SetParameter(HgcPixelFormatConversion_kV4F_WXYZ_output *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_output::GetParameter(HgcPixelFormatConversion_kV4F_WXYZ_output *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

HGNode *HgcPixelFormatConversion_kV4F_WXYZ_output::GetOutput(__n128 *this, HGRenderer *a2, __n128 a3, __n128 a4, __n128 a5)
{
  int8x16_t *v5;
  int8x16_t v6;
  __n128 *v7;

  if (this[31].n128_u32[2])
  {
    v5 = (int8x16_t *)this[31].n128_u64[0];
    a4 = (__n128)vextq_s8(v5[5], v5[5], 0xCuLL);
    a5 = (__n128)vextq_s8(v5[6], v5[6], 0xCuLL);
    v6 = vextq_s8(v5[7], v5[7], 0xCuLL);
    *v5 = vextq_s8(v5[4], v5[4], 0xCuLL);
    *(__n128 *)(this[31].n128_u64[0] + 16) = a4;
    *(__n128 *)(this[31].n128_u64[0] + 32) = a5;
    *(int8x16_t *)(this[31].n128_u64[0] + 48) = v6;
    v7 = (__n128 *)this[31].n128_u64[0];
    this[27] = *v7;
    this[28] = v7[1];
    this[29] = v7[2];
    a3 = v7[3];
    this[30] = a3;
    this[31].n128_u32[2] = 0;
  }
  return HGColorMatrix::GetOutput((HGColorMatrix *)this, a2, a3.n128_f64[0], a4.n128_f64[0], (int32x2_t)a5.n128_u64[0]);
}

const char *HgcColorGamma_bias::GetProgram(HgcColorGamma_bias *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000245\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0)*hg_Params[1] + hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=fa49cb7d:1e053eea:12e2489c:1692af72\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0002:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000237\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0*hg_Params[1] + hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=ad9db7bc:ac24aee5:0faf9a1f:d9021699\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0002:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000231\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0*hg_ProgramLocal1 + hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=bfef74a1:370b9177:d2ba98d4:b569923b\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0002:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorGamma_bias::InitProgramDescriptor(HgcColorGamma_bias *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_bias_hgc_visible", "//Metal1.0     \n//LEN=0000000113\n[[ visible ]] FragmentOut HgcColorGamma_bias_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0*hg_Params[1] + hg_Params[0];\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BE6768(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BE6798(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BE6790);
}

double HgcColorGamma_bias::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcColorGamma_bias [hgc1]");
  return *(double *)"amma_bias [hgc1]";
}

uint64_t HgcColorGamma_bias::BindTexture(HgcColorGamma_bias *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcColorGamma_bias::Bind(HgcColorGamma_bias *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcColorGamma_bias *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcColorGamma_bias::RenderTile(HgcColorGamma_bias *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t *v11;
  float32x4_t *v12;
  unint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  uint64_t v16;
  float32x4_t *v17;
  float32x4_t *v18;
  float32x4_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t *v25;
  float32x4_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v27 = 0;
        v28 = 16 * v7;
        v29 = 16 * v6;
        v30 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v31 = 0;
          do
          {
            v5[v31 / 0x10] = vaddq_f32(*(float32x4_t *)*((_QWORD *)this + 51), vmulq_f32(v4[v31 / 0x10], *(float32x4_t *)(*((_QWORD *)this + 51) + 16)));
            v31 += 16;
          }
          while (v30 != v31);
          ++v27;
          v4 = (float32x4_t *)((char *)v4 + v28);
          v5 = (float32x4_t *)((char *)v5 + v29);
        }
        while (v27 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = v14;
          v19 = (float32x4_t *)*((_QWORD *)this + 51);
          v20 = v19[1];
          v21 = vaddq_f32(*v19, vmulq_f32(v4[v16 - 2], v20));
          v22 = vaddq_f32(*v19, vmulq_f32(v4[v16 - 1], v20));
          v23 = vaddq_f32(*v19, vmulq_f32(v4[v16], v20));
          v24 = vaddq_f32(*v19, vmulq_f32(v4[v16 + 1], v20));
          v25 = &v5[v16];
          v25[-2] = v21;
          v25[-1] = v22;
          v13 += 4;
          *v25 = v23;
          v25[1] = v24;
          v16 += 4;
          v15 += 4;
          v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v26 = *v17++;
            *v18++ = vaddq_f32(*(float32x4_t *)*((_QWORD *)this + 51), vmulq_f32(v26, *(float32x4_t *)(*((_QWORD *)this + 51) + 16)));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (float32x4_t *)((char *)v5 + v9);
        v4 = (float32x4_t *)((char *)v4 + v10);
        v11 = (float32x4_t *)((char *)v11 + v10);
        v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcColorGamma_bias::GetDOD(HgcColorGamma_bias *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcColorGamma_bias::GetROI(HgcColorGamma_bias *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcColorGamma_bias::HgcColorGamma_bias(HgcColorGamma_bias *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65483B8;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BE6B28(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_bias::~HgcColorGamma_bias(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65483B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E65483B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65483B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_bias::SetParameter(HgcColorGamma_bias *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcColorGamma_bias::GetParameter(HgcColorGamma_bias *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcColorGamma_bias_clamp::GetProgram(HgcColorGamma_bias_clamp *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000274\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0*half4(hg_Params[1]) + half4(hg_Params[0]);\n"
             "    output.color0 = fmax(float4(r0), hg_Params[2]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=948bba88:2cd0d942:4e7bd5c2:de20170e\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0003:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000258\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0*hg_Params[1] + hg_Params[0];\n"
             "    output.color0 = fmax(r0, hg_Params[2]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=61fc2441:8cd63a5e:fe3bbe94:65cb2e74\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0003:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000027d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "uniform defaultp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0*hg_ProgramLocal1 + hg_ProgramLocal0;\n"
           "    gl_FragColor = max(r0, hg_ProgramLocal2);\n"
           "}\n"
           "//MD5=18efcb7d:7d440686:c0833abc:66ba06e3\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0003:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorGamma_bias_clamp::InitProgramDescriptor(HgcColorGamma_bias_clamp *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_bias_clamp_hgc_visible", "//Metal1.0     \n//LEN=000000013a\n[[ visible ]] FragmentOut HgcColorGamma_bias_clamp_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0*hg_Params[1] + hg_Params[0];\n"
    "    output.color0 = fmax(r0, hg_Params[2]);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BE6F84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BE6FB4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BE6FACLL);
}

double HgcColorGamma_bias_clamp::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A60;
  strcpy(v3, "HgcColorGamma_bias_clamp [hgc1]");
  return *(double *)"ias_clamp [hgc1]";
}

uint64_t HgcColorGamma_bias_clamp::BindTexture(HgcColorGamma_bias_clamp *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcColorGamma_bias_clamp::Bind(HgcColorGamma_bias_clamp *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HgcColorGamma_bias_clamp *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcColorGamma_bias_clamp::RenderTile(HgcColorGamma_bias_clamp *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t *v11;
  float32x4_t *v12;
  unint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  uint64_t v16;
  float32x4_t *v17;
  float32x4_t *v18;
  float32x4_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t *v26;
  float32x4_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v28 = 0;
        v29 = 16 * v7;
        v30 = 16 * v6;
        v31 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v32 = 0;
          do
          {
            v5[v32 / 0x10] = vmaxq_f32(vaddq_f32(*(float32x4_t *)*((_QWORD *)this + 51), vmulq_f32(v4[v32 / 0x10], *(float32x4_t *)(*((_QWORD *)this + 51) + 16))), *(float32x4_t *)(*((_QWORD *)this + 51) + 32));
            v32 += 16;
          }
          while (v31 != v32);
          ++v28;
          v4 = (float32x4_t *)((char *)v4 + v29);
          v5 = (float32x4_t *)((char *)v5 + v30);
        }
        while (v28 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = v14;
          v19 = (float32x4_t *)*((_QWORD *)this + 51);
          v20 = v19[1];
          v21 = v19[2];
          v22 = vmaxq_f32(vaddq_f32(*v19, vmulq_f32(v4[v16 - 2], v20)), v21);
          v23 = vmaxq_f32(vaddq_f32(*v19, vmulq_f32(v4[v16 - 1], v20)), v21);
          v24 = vmaxq_f32(vaddq_f32(*v19, vmulq_f32(v4[v16], v20)), v21);
          v25 = vmaxq_f32(vaddq_f32(*v19, vmulq_f32(v4[v16 + 1], v20)), v21);
          v26 = &v5[v16];
          v26[-2] = v22;
          v26[-1] = v23;
          v13 += 4;
          *v26 = v24;
          v26[1] = v25;
          v16 += 4;
          v15 += 4;
          v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v27 = *v17++;
            *v18++ = vmaxq_f32(vaddq_f32(*(float32x4_t *)*((_QWORD *)this + 51), vmulq_f32(v27, *(float32x4_t *)(*((_QWORD *)this + 51) + 16))), *(float32x4_t *)(*((_QWORD *)this + 51) + 32));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (float32x4_t *)((char *)v5 + v9);
        v4 = (float32x4_t *)((char *)v4 + v10);
        v11 = (float32x4_t *)((char *)v11 + v10);
        v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcColorGamma_bias_clamp::GetDOD(HgcColorGamma_bias_clamp *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcColorGamma_bias_clamp::GetROI(HgcColorGamma_bias_clamp *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcColorGamma_bias_clamp::HgcColorGamma_bias_clamp(HgcColorGamma_bias_clamp *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6548620;
  v3 = (_OWORD *)operator new();
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BE738C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_bias_clamp::~HgcColorGamma_bias_clamp(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6548620;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40FA0F61DDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6548620;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40FA0F61DDLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_bias_clamp::SetParameter(HgcColorGamma_bias_clamp *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  float *v7;
  uint64_t result;
  float *v9;
  uint64_t v10;

  switch((int)a2)
  {
    case 0:
      v7 = (float *)*((_QWORD *)this + 51);
      if (*v7 == a3.n128_f32[0] && v7[1] == a4 && v7[2] == a5 && v7[3] == a6)
        goto LABEL_19;
      *v7 = a3.n128_f32[0];
      v7[1] = a4;
      v7[2] = a5;
      v7[3] = a6;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      result = 1;
      break;
    case 1:
      v9 = (float *)*((_QWORD *)this + 51);
      if (v9[4] == a3.n128_f32[0] && v9[5] == a4 && v9[6] == a5 && v9[7] == a6)
        goto LABEL_19;
      v9[4] = a3.n128_f32[0];
      v9[5] = a4;
      v9[6] = a5;
      v9[7] = a6;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      result = 1;
      break;
    case 2:
      v10 = *((_QWORD *)this + 51);
      if (*(float *)(v10 + 32) == a3.n128_f32[0]
        && *(float *)(v10 + 36) == a4
        && *(float *)(v10 + 40) == a5
        && *(float *)(v10 + 44) == a6)
      {
LABEL_19:
        result = 0;
      }
      else
      {
        *(_DWORD *)(v10 + 32) = a3.n128_u32[0];
        *(float *)(v10 + 36) = a4;
        *(float *)(v10 + 40) = a5;
        *(float *)(v10 + 44) = a6;
        HGNode::ClearBits((HGNode *)this, a2, a7);
        result = 1;
      }
      break;
    case 3:
      a3.n128_f32[1] = a4;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      *(__n128 *)(*((_QWORD *)this + 51) + 48) = a3;
      result = 0;
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

float HgcColorGamma_bias_clamp::GetParameter(HgcColorGamma_bias_clamp *this, int a2, float *a3)
{
  float *v3;
  float result;
  float *v5;
  float *v6;
  float *v7;

  switch(a2)
  {
    case 0:
      v3 = (float *)*((_QWORD *)this + 51);
      *a3 = *v3;
      a3[1] = v3[1];
      a3[2] = v3[2];
      result = v3[3];
      a3[3] = result;
      break;
    case 1:
      v5 = (float *)*((_QWORD *)this + 51);
      *a3 = v5[4];
      a3[1] = v5[5];
      a3[2] = v5[6];
      result = v5[7];
      a3[3] = result;
      break;
    case 2:
      v6 = (float *)*((_QWORD *)this + 51);
      *a3 = v6[8];
      a3[1] = v6[9];
      a3[2] = v6[10];
      result = v6[11];
      a3[3] = result;
      break;
    case 3:
      v7 = (float *)*((_QWORD *)this + 51);
      *a3 = v7[12];
      a3[1] = v7[13];
      a3[2] = v7[14];
      result = v7[15];
      a3[3] = result;
      break;
    default:
      return result;
  }
  return result;
}

const char *HgcST2084_EOTF::GetProgram(HgcST2084_EOTF *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000404\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = clamp(r0.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[0].yyy));\n"
             "    r1.xyz = r0.xyz - half3(hg_Params[1].xxx);\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[1].zzz) + half3(hg_Params[1].yyy);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[0].xxx));\n"
             "    output.color0.xyz = float3(r0.xyz)*hg_Params[1].www;\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c1c59994:6a4309cd:322adf23:26162d23\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003ce\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = clamp(r0.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
             "    r1.xyz = r0.xyz - hg_Params[1].xxx;\n"
             "    r0.xyz = r0.xyz*hg_Params[1].zzz + hg_Params[1].yyy;\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[0].xxx);\n"
             "    output.color0.xyz = r0.xyz*hg_Params[1].www;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=dfda7509:99458374:6e062eb7:63abe617\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003e1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = clamp(r0.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal0.yyy);\n"
           "    r1.xyz = r0.xyz - hg_ProgramLocal1.xxx;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal1.zzz + hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r0.xyz = r1.xyz/r0.xyz;\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal0.xxx);\n"
           "    gl_FragColor.xyz = r0.xyz*hg_ProgramLocal1.www;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=6997d0cc:8e8a000b:d380b926:8b993188\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcST2084_EOTF::InitProgramDescriptor(HgcST2084_EOTF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcST2084_EOTF_hgc_visible", "//Metal1.0     \n//LEN=00000002a6\n[[ visible ]] FragmentOut HgcST2084_EOTF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = clamp(r0.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
    "    r1.xyz = r0.xyz - hg_Params[1].xxx;\n"
    "    r0.xyz = r0.xyz*hg_Params[1].zzz + hg_Params[1].yyy;\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r0.xyz = r1.xyz/r0.xyz;\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[0].xxx);\n"
    "    output.color0.xyz = r0.xyz*hg_Params[1].www;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BE7908(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BE7938(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BE7930);
}

void HgcST2084_EOTF::shaderDescription(char *a1@<X8>)
{
  a1[23] = 21;
  strcpy(a1, "HgcST2084_EOTF [hgc1]");
}

uint64_t HgcST2084_EOTF::BindTexture(HgcST2084_EOTF *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcST2084_EOTF::Bind(HgcST2084_EOTF *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcST2084_EOTF *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcST2084_EOTF::RenderTile(HgcST2084_EOTF *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  _OWORD *v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  int8x16_t v50;
  int32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int8x16_t v57;
  int8x16_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  int8x16_t *v93;
  int v94;
  uint64_t v95;
  _OWORD *v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  int8x16_t v100;
  float32x4_t v101;
  float32x4_t v102;
  int8x16_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  int32x4_t v123;
  int8x16_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v94 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v11 = (_OWORD *)*((_QWORD *)this + 51);
      v13 = *((float32x4_t *)v11 + 2);
      v12 = *((float32x4_t *)v11 + 3);
      v14 = vminq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v10 - 16), v13), v12);
      v15 = vminq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v10), v13), v12);
      v16 = *((int8x16_t *)v11 + 4);
      v17 = *((float32x4_t *)v11 + 5);
      v18 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v14), (int8x16_t)v12);
      v19 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v15), (int8x16_t)v12);
      v20 = *((int8x16_t *)v11 + 6);
      v21 = *((float32x4_t *)v11 + 7);
      v23 = *((float32x4_t *)v11 + 8);
      v22 = *((float32x4_t *)v11 + 9);
      v24 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v18, v23));
      v25 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v19, v23));
      v26 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v14, 0x17uLL)), (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v17, v14))), v21), v24);
      v27 = vsubq_f32(vsubq_f32(v18, v12), vmulq_f32(vmulq_f32(v22, v24), v18));
      v28 = vsubq_f32(vsubq_f32(v19, v12), vmulq_f32(vmulq_f32(v22, v25), v19));
      v29 = *((float32x4_t *)v11 + 10);
      v30 = *((float32x4_t *)v11 + 11);
      v31 = *((float32x4_t *)v11 + 12);
      v32 = *((float32x4_t *)v11 + 13);
      v33 = vaddq_f32(v26, vmulq_f32(v27, vaddq_f32(vaddq_f32(v31, vmulq_f32(v27, v32)), vmulq_f32(vmulq_f32(v27, v27), vaddq_f32(v29, vmulq_f32(v30, v27))))));
      v34 = *((float32x4_t *)v11 + 1);
      v35 = vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v15, 0x17uLL)), (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v17, v15))), v21), v25), vmulq_f32(v28, vaddq_f32(vaddq_f32(v31, vmulq_f32(v28, v32)), vmulq_f32(vmulq_f32(v28, v28), vaddq_f32(v29, vmulq_f32(v30, v28)))))), *(float32x2_t *)v11, 1);
      v37 = *((float32x4_t *)v11 + 14);
      v36 = *((float32x4_t *)v11 + 15);
      v38 = vmaxq_f32(vmulq_lane_f32(v33, *(float32x2_t *)v11, 1), v37);
      v39 = vmaxq_f32(v35, v37);
      v40 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
      v41 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v42 = vsubq_f32(v40, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v40, v38)));
      v43 = vsubq_f32(v41, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v41, v39)));
      v44 = vsubq_f32(v38, v42);
      v45 = vsubq_f32(v39, v43);
      v47 = *((float32x4_t *)v11 + 16);
      v46 = *((float32x4_t *)v11 + 17);
      v48 = vmulq_f32(v45, vaddq_f32(v46, vmulq_f32(v45, vaddq_f32(v36, vmulq_f32(v47, v45)))));
      v49 = vaddq_f32(v12, vmulq_f32(v44, vaddq_f32(v46, vmulq_f32(v44, vaddq_f32(v36, vmulq_f32(v47, v44))))));
      v51 = *((int32x4_t *)v11 + 18);
      v50 = *((int8x16_t *)v11 + 19);
      v52 = (float32x4_t)vbslq_s8(v50, (int8x16_t)v14, (int8x16_t)vmulq_f32(v49, (float32x4_t)vshlq_n_s32(vaddq_s32(v51, vcvtq_s32_f32(v42)), 0x17uLL)));
      v53 = (float32x4_t)vbslq_s8(v50, (int8x16_t)v15, (int8x16_t)vmulq_f32(vaddq_f32(v12, v48), (float32x4_t)vshlq_n_s32(vaddq_s32(v51, vcvtq_s32_f32(v43)), 0x17uLL)));
      v54 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1);
      v55 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 0);
      v56 = vsubq_f32(v52, v55);
      v57 = (int8x16_t)vaddq_f32(v54, vmulq_laneq_f32(v52, v34, 2));
      v58 = (int8x16_t)vaddq_f32(v54, vmulq_laneq_f32(v53, v34, 2));
      v59 = vsubq_f32(v53, v55);
      v60 = (float32x4_t)vbslq_s8(v50, (int8x16_t)v14, v57);
      v61 = (float32x4_t)vbslq_s8(v50, (int8x16_t)v15, v58);
      v62 = vmaxq_f32(v56, v13);
      v63 = vmaxq_f32(v59, v13);
      v64 = *((float32x4_t *)v11 + 20);
      v65 = *((float32x4_t *)v11 + 21);
      v66 = vmaxq_f32(vmulq_f32(vrecpeq_f32(v60), v64), v65);
      v67 = vmaxq_f32(vmulq_f32(vrecpeq_f32(v61), v64), v65);
      v68 = *((float32x4_t *)v11 + 22);
      v69 = vminq_f32(v66, v68);
      v70 = vminq_f32(v67, v68);
      v71 = (float32x4_t)vbslq_s8(v50, (int8x16_t)v14, (int8x16_t)vmulq_f32(v62, vmulq_f32(v69, vrecpsq_f32(v60, v69))));
      v72 = (float32x4_t)vbslq_s8(v50, (int8x16_t)v15, (int8x16_t)vmulq_f32(v63, vmulq_f32(v70, vrecpsq_f32(v61, v70))));
      v73 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v71, v16), (int8x16_t)v12);
      v74 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v72, v16), (int8x16_t)v12);
      v75 = (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v17, v71));
      v76 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v72, 0x17uLL)), (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v17, v72)));
      v77 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v71, 0x17uLL)), v75), v21);
      v78 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v73, v23));
      v79 = vsubq_f32(v76, v21);
      v80 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v74, v23));
      v81 = vaddq_f32(v77, v78);
      v82 = vsubq_f32(vsubq_f32(v73, v12), vmulq_f32(vmulq_f32(v22, v78), v73));
      v83 = vsubq_f32(vsubq_f32(v74, v12), vmulq_f32(vmulq_f32(v22, v80), v74));
      v84 = vaddq_f32(vaddq_f32(v79, v80), vmulq_f32(v83, vaddq_f32(vaddq_f32(v31, vmulq_f32(v32, v83)), vmulq_f32(vmulq_f32(v83, v83), vaddq_f32(v29, vmulq_f32(v30, v83))))));
      v85 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v81, vmulq_f32(v82, vaddq_f32(vaddq_f32(v31, vmulq_f32(v32, v82)), vmulq_f32(vmulq_f32(v82, v82), vaddq_f32(v29, vmulq_f32(v30, v82)))))), COERCE_FLOAT(*v11)), v37);
      v86 = vmaxq_f32(vmulq_n_f32(v84, COERCE_FLOAT(*v11)), v37);
      v87 = vcvtq_f32_s32(vcvtq_s32_f32(v85));
      v88 = vcvtq_f32_s32(vcvtq_s32_f32(v86));
      v89 = vsubq_f32(v87, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v87, v85)));
      v90 = vsubq_f32(v88, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v88, v86)));
      v91 = vsubq_f32(v85, v89);
      v92 = vsubq_f32(v86, v90);
      v93 = (int8x16_t *)(v5 + v10);
      v93[-1] = vbslq_s8(v50, (int8x16_t)v14, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v50, (int8x16_t)v14, (int8x16_t)vmulq_f32(vaddq_f32(v12, vmulq_f32(v91, vaddq_f32(v46, vmulq_f32(v91, vaddq_f32(v36, vmulq_f32(v47, v91)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v89), v51), 0x17uLL))), v34, 3));
      *v93 = vbslq_s8(v50, (int8x16_t)v15, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v50, (int8x16_t)v15, (int8x16_t)vmulq_f32(vaddq_f32(v12, vmulq_f32(v92, vaddq_f32(v46, vmulq_f32(v92, vaddq_f32(v36, vmulq_f32(v47, v92)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v90), v51), 0x17uLL))), v34, 3));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v94 = -v9;
    if (v94 >= v4)
      goto LABEL_3;
LABEL_10:
    v95 = 16 * v94;
    v96 = (_OWORD *)*((_QWORD *)this + 51);
    v98 = *((float32x4_t *)v96 + 2);
    v97 = *((float32x4_t *)v96 + 3);
    v99 = vminq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v95), v98), v97);
    v100 = *((int8x16_t *)v96 + 4);
    v101 = *((float32x4_t *)v96 + 5);
    v102 = (float32x4_t)vorrq_s8(vandq_s8(v100, (int8x16_t)v99), (int8x16_t)v97);
    v103 = *((int8x16_t *)v96 + 6);
    v104 = *((float32x4_t *)v96 + 7);
    v105 = *((float32x4_t *)v96 + 8);
    v106 = *((float32x4_t *)v96 + 9);
    v107 = (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v102, v105));
    v108 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v99, 0x17uLL)), (float32x4_t)vandq_s8(v103, (int8x16_t)vcgtq_f32(v101, v99))), v104), v107);
    v109 = vsubq_f32(vsubq_f32(v102, v97), vmulq_f32(vmulq_f32(v106, v107), v102));
    v110 = *((float32x4_t *)v96 + 10);
    v111 = *((float32x4_t *)v96 + 11);
    v112 = *((float32x4_t *)v96 + 12);
    v113 = *((float32x4_t *)v96 + 13);
    v114 = *((float32x4_t *)v96 + 1);
    v115 = *((float32x4_t *)v96 + 14);
    v116 = *((float32x4_t *)v96 + 15);
    v117 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v108, vmulq_f32(v109, vaddq_f32(vaddq_f32(v112, vmulq_f32(v109, v113)), vmulq_f32(vmulq_f32(v109, v109), vaddq_f32(v110, vmulq_f32(v111, v109)))))), *(float32x2_t *)v96, 1), v115);
    v118 = vcvtq_f32_s32(vcvtq_s32_f32(v117));
    v119 = vsubq_f32(v118, (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v118, v117)));
    v120 = vsubq_f32(v117, v119);
    v121 = *((float32x4_t *)v96 + 16);
    v122 = *((float32x4_t *)v96 + 17);
    v123 = *((int32x4_t *)v96 + 18);
    v124 = *((int8x16_t *)v96 + 19);
    v125 = (float32x4_t)vbslq_s8(v124, (int8x16_t)v99, (int8x16_t)vmulq_f32(vaddq_f32(v97, vmulq_f32(v120, vaddq_f32(v122, vmulq_f32(v120, vaddq_f32(v116, vmulq_f32(v121, v120)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v123, vcvtq_s32_f32(v119)), 0x17uLL)));
    v126 = vsubq_f32(v125, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114.f32, 0));
    v127 = (float32x4_t)vbslq_s8(v124, (int8x16_t)v99, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114.f32, 1), vmulq_laneq_f32(v125, v114, 2)));
    v128 = vmaxq_f32(v126, v98);
    v129 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v127), *((float32x4_t *)v96 + 20)), *((float32x4_t *)v96 + 21)), *((float32x4_t *)v96 + 22));
    v130 = (float32x4_t)vbslq_s8(v124, (int8x16_t)v99, (int8x16_t)vmulq_f32(v128, vmulq_f32(v129, vrecpsq_f32(v127, v129))));
    v131 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v130, v100), (int8x16_t)v97);
    v132 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v130, 0x17uLL)), (float32x4_t)vandq_s8(v103, (int8x16_t)vcgtq_f32(v101, v130))), v104);
    v133 = (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v131, v105));
    v134 = vsubq_f32(vsubq_f32(v131, v97), vmulq_f32(vmulq_f32(v106, v133), v131));
    v135 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(v132, v133), vmulq_f32(v134, vaddq_f32(vaddq_f32(v112, vmulq_f32(v113, v134)), vmulq_f32(vmulq_f32(v134, v134), vaddq_f32(v110, vmulq_f32(v111, v134)))))), COERCE_FLOAT(*v96)), v115);
    v136 = vcvtq_f32_s32(vcvtq_s32_f32(v135));
    v137 = vsubq_f32(v136, (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v136, v135)));
    v138 = vsubq_f32(v135, v137);
    *(int8x16_t *)(v5 + v95) = vbslq_s8(v124, (int8x16_t)v99, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v124, (int8x16_t)v99, (int8x16_t)vmulq_f32(vaddq_f32(v97, vmulq_f32(v138, vaddq_f32(v122, vmulq_f32(v138, vaddq_f32(v116, vmulq_f32(v121, v138)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v137),
                                                                                           v123),
                                                                                         0x17uLL))),
                                              v114,
                                              3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcST2084_EOTF::GetDOD(HgcST2084_EOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcST2084_EOTF::GetROI(HgcST2084_EOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcST2084_EOTF::HgcST2084_EOTF(HgcST2084_EOTF *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6548888;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = xmmword_1B30536D0;
  *(_OWORD *)(v3 + 48) = xmmword_1B3525D80;
  *(_OWORD *)(v3 + 64) = xmmword_1B3051600;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051610;
  *(_OWORD *)(v3 + 96) = xmmword_1B3051620;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051630;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051640;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051510;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051650;
  *(_OWORD *)(v3 + 176) = xmmword_1B3051660;
  *(_OWORD *)(v3 + 192) = xmmword_1B3051670;
  *(_OWORD *)(v3 + 208) = xmmword_1B3051680;
  *(_OWORD *)(v3 + 224) = xmmword_1B3051690;
  *(_OWORD *)(v3 + 240) = xmmword_1B30516A0;
  *(_OWORD *)(v3 + 256) = xmmword_1B30516B0;
  *(_OWORD *)(v3 + 272) = xmmword_1B30516C0;
  *(_OWORD *)(v3 + 288) = xmmword_1B30516D0;
  *(_OWORD *)(v3 + 304) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 320) = xmmword_1B3051BC0;
  *(_OWORD *)(v3 + 336) = xmmword_1B3052320;
  *(int32x4_t *)(v3 + 352) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BE822C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcST2084_EOTF::~HgcST2084_EOTF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6548888;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C409BD2D9E4);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6548888;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C409BD2D9E4);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcST2084_EOTF::SetParameter(HgcST2084_EOTF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcST2084_EOTF::GetParameter(HgcST2084_EOTF *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcST2084_InverseEOTF::GetProgram(HgcST2084_InverseEOTF *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003ae\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r0.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz*half3(hg_Params[1].zzz) + c0.yyy;\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[1].yyy) + half3(hg_Params[1].xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    output.color0.xyz = pow(float3(r0.xyz), hg_Params[0].yyy);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=2444afad:3db4a253:10709704:a6232534\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000037f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r0.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz*hg_Params[1].zzz + c0.yyy;\n"
             "    r1.xyz = r1.xyz*hg_Params[1].yyy + hg_Params[1].xxx;\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    output.color0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=81f92e6d:ccf1bbeb:6804da4c:060ade07\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000384\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r0.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz*hg_ProgramLocal1.zzz + c0.yyy;\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal1.yyy + hg_ProgramLocal1.xxx;\n"
           "    r0.xyz = r1.xyz/r0.xyz;\n"
           "    gl_FragColor.xyz = pow(r0.xyz, hg_ProgramLocal0.yyy);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=1cee2dfd:bd24937f:dc7ace33:9840809d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcST2084_InverseEOTF::InitProgramDescriptor(HgcST2084_InverseEOTF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcST2084_InverseEOTF_hgc_visible", "//Metal1.0     \n//LEN=000000025e\n[[ visible ]] FragmentOut HgcST2084_InverseEOTF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r0.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = r1.xyz*hg_Params[1].zzz + c0.yyy;\n"
    "    r1.xyz = r1.xyz*hg_Params[1].yyy + hg_Params[1].xxx;\n"
    "    r0.xyz = r1.xyz/r0.xyz;\n"
    "    output.color0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BE8640(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BE8670(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BE8668);
}

double HgcST2084_InverseEOTF::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552E10;
  strcpy(v3, "HgcST2084_InverseEOTF [hgc1]");
  return *(double *)"verseEOTF [hgc1]";
}

uint64_t HgcST2084_InverseEOTF::BindTexture(HgcST2084_InverseEOTF *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcST2084_InverseEOTF::Bind(HgcST2084_InverseEOTF *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcST2084_InverseEOTF *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcST2084_InverseEOTF::RenderTile(HgcST2084_InverseEOTF *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x2_t *v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  int8x16_t *v90;
  int v91;
  uint64_t v92;
  float32x4_t v93;
  float32x2_t *v94;
  int8x16_t v95;
  float32x4_t v96;
  float32x4_t v97;
  int8x16_t v98;
  float32x4_t v99;
  float32x4_t v100;
  int8x16_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  int32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v91 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v12 = *(float32x4_t *)(v6 + v10 - 16);
      v11 = *(float32x4_t *)(v6 + v10);
      v13 = (float32x2_t *)*((_QWORD *)this + 51);
      v15 = *(float32x4_t *)v13[4].f32;
      v14 = *(int8x16_t *)v13[6].f32;
      v16 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v12, (int8x16_t)vmaxq_f32(v12, v15));
      v17 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v11, (int8x16_t)vmaxq_f32(v11, v15));
      v19 = *(int8x16_t *)v13[8].f32;
      v18 = *(float32x4_t *)v13[10].f32;
      v20 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v16, v19), (int8x16_t)v18);
      v21 = *(float32x4_t *)v13[12].f32;
      v22 = *(int8x16_t *)v13[14].f32;
      v23 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v17, v19), (int8x16_t)v18);
      v24 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v21, v16)));
      v25 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v21, v17)));
      v26 = *(float32x4_t *)v13[16].f32;
      v27 = *(float32x4_t *)v13[18].f32;
      v28 = vsubq_f32(v24, v26);
      v29 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v20, v27));
      v30 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v23, v27));
      v32 = *(float32x4_t *)v13[20].f32;
      v31 = *(float32x4_t *)v13[22].f32;
      v33 = vsubq_f32(v25, v26);
      v34 = vmulq_f32(vmulq_f32(v32, v29), v20);
      v35 = vaddq_f32(v28, v29);
      v36 = vsubq_f32(vsubq_f32(v20, v18), v34);
      v37 = vsubq_f32(vsubq_f32(v23, v18), vmulq_f32(vmulq_f32(v32, v30), v23));
      v39 = *(float32x4_t *)v13[24].f32;
      v38 = *(float32x4_t *)v13[26].f32;
      v41 = *(float32x4_t *)v13[28].f32;
      v40 = *(float32x4_t *)v13[30].f32;
      v42 = vaddq_f32(v33, v30);
      v43 = *(float32x4_t *)v13[2].f32;
      v44 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v35, vmulq_f32(v36, vaddq_f32(vaddq_f32(v38, vmulq_f32(v36, v41)), vmulq_f32(vmulq_f32(v36, v36), vaddq_f32(v31, vmulq_f32(v39, v36)))))), COERCE_FLOAT(*(_OWORD *)v13->f32)), v40);
      v45 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v42, vmulq_f32(v37, vaddq_f32(vaddq_f32(v38, vmulq_f32(v37, v41)), vmulq_f32(vmulq_f32(v37, v37), vaddq_f32(v31, vmulq_f32(v39, v37)))))), COERCE_FLOAT(*(_OWORD *)v13->f32)), v40);
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      v48 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v46, v44)));
      v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v47, v45)));
      v50 = vsubq_f32(v44, v48);
      v51 = vsubq_f32(v45, v49);
      v52 = *(float32x4_t *)v13[32].f32;
      v53 = *(float32x4_t *)v13[34].f32;
      v55 = *(float32x4_t *)v13[36].f32;
      v54 = *(int32x4_t *)v13[38].f32;
      v56 = vmulq_f32(vaddq_f32(v18, vmulq_f32(v50, vaddq_f32(v55, vmulq_f32(v50, vaddq_f32(v52, vmulq_f32(v53, v50)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v54, vcvtq_s32_f32(v48)), 0x17uLL));
      v57 = vmulq_f32(vaddq_f32(v18, vmulq_f32(v51, vaddq_f32(v55, vmulq_f32(v51, vaddq_f32(v52, vmulq_f32(v53, v51)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v54, vcvtq_s32_f32(v49)), 0x17uLL));
      v58 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v12, (int8x16_t)vaddq_f32(v18, vmulq_laneq_f32(v56, v43, 2)));
      v59 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v11, (int8x16_t)vaddq_f32(v18, vmulq_laneq_f32(v57, v43, 2)));
      v60 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v43.f32, 0);
      v61 = vaddq_f32(v60, vmulq_lane_f32(v56, *(float32x2_t *)v43.f32, 1));
      v62 = *(float32x4_t *)v13[40].f32;
      v63 = *(float32x4_t *)v13[42].f32;
      v64 = vaddq_f32(v60, vmulq_lane_f32(v57, *(float32x2_t *)v43.f32, 1));
      v65 = *(float32x4_t *)v13[44].f32;
      v66 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v58), v62), v63), v65);
      v67 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v59), v62), v63), v65);
      v68 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v12, (int8x16_t)vmulq_f32(v61, vmulq_f32(v66, vrecpsq_f32(v58, v66))));
      v69 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v11, (int8x16_t)vmulq_f32(v64, vmulq_f32(v67, vrecpsq_f32(v59, v67))));
      v70 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v68, v19), (int8x16_t)v18);
      v71 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v69, v19), (int8x16_t)v18);
      v72 = (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v21, v68));
      v73 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v69, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v21, v69)));
      v74 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v68, 0x17uLL)), v72), v26);
      v75 = vsubq_f32(v73, v26);
      v76 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v70, v27));
      v77 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v71, v27));
      v78 = vaddq_f32(v74, v76);
      v79 = vsubq_f32(vsubq_f32(v70, v18), vmulq_f32(vmulq_f32(v32, v76), v70));
      v80 = vsubq_f32(vsubq_f32(v71, v18), vmulq_f32(vmulq_f32(v32, v77), v71));
      v81 = vaddq_f32(vaddq_f32(v75, v77), vmulq_f32(v80, vaddq_f32(vaddq_f32(v38, vmulq_f32(v41, v80)), vmulq_f32(vmulq_f32(v80, v80), vaddq_f32(v31, vmulq_f32(v39, v80))))));
      v82 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v78, vmulq_f32(v79, vaddq_f32(vaddq_f32(v38, vmulq_f32(v41, v79)), vmulq_f32(vmulq_f32(v79, v79), vaddq_f32(v31, vmulq_f32(v39, v79)))))), *v13, 1), v40);
      v83 = vmaxq_f32(vmulq_lane_f32(v81, *v13, 1), v40);
      v84 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
      v85 = vcvtq_f32_s32(vcvtq_s32_f32(v83));
      v86 = vsubq_f32(v84, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v84, v82)));
      v87 = vsubq_f32(v85, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v85, v83)));
      v88 = vsubq_f32(v82, v86);
      v89 = vsubq_f32(v83, v87);
      v90 = (int8x16_t *)(v5 + v10);
      v90[-1] = vbslq_s8(v14, (int8x16_t)v12, (int8x16_t)vmulq_f32(vaddq_f32(v18, vmulq_f32(v88, vaddq_f32(v55, vmulq_f32(v88, vaddq_f32(v52, vmulq_f32(v53, v88)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v86), v54), 0x17uLL)));
      *v90 = vbslq_s8(v14, (int8x16_t)v11, (int8x16_t)vmulq_f32(vaddq_f32(v18, vmulq_f32(v89, vaddq_f32(v55, vmulq_f32(v89, vaddq_f32(v52, vmulq_f32(v53, v89)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v87), v54), 0x17uLL)));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v91 = -v9;
    if (v91 >= v4)
      goto LABEL_3;
LABEL_10:
    v92 = 16 * v91;
    v93 = *(float32x4_t *)(v6 + v92);
    v94 = (float32x2_t *)*((_QWORD *)this + 51);
    v95 = *(int8x16_t *)v94[6].f32;
    v96 = (float32x4_t)vbslq_s8(v95, (int8x16_t)v93, (int8x16_t)vmaxq_f32(v93, *(float32x4_t *)v94[4].f32));
    v98 = *(int8x16_t *)v94[8].f32;
    v97 = *(float32x4_t *)v94[10].f32;
    v99 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v96, v98), (int8x16_t)v97);
    v100 = *(float32x4_t *)v94[12].f32;
    v101 = *(int8x16_t *)v94[14].f32;
    v102 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v96, 0x17uLL)), (float32x4_t)vandq_s8(v101, (int8x16_t)vcgtq_f32(v100, v96)));
    v103 = *(float32x4_t *)v94[16].f32;
    v104 = *(float32x4_t *)v94[18].f32;
    v105 = (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v99, v104));
    v106 = vaddq_f32(vsubq_f32(v102, v103), v105);
    v107 = *(float32x4_t *)v94[20].f32;
    v108 = *(float32x4_t *)v94[22].f32;
    v109 = vsubq_f32(vsubq_f32(v99, v97), vmulq_f32(vmulq_f32(v107, v105), v99));
    v111 = *(float32x4_t *)v94[24].f32;
    v110 = *(float32x4_t *)v94[26].f32;
    v112 = *(float32x4_t *)v94[28].f32;
    v113 = *(float32x4_t *)v94[30].f32;
    v114 = *(float32x4_t *)v94[2].f32;
    v115 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v106, vmulq_f32(v109, vaddq_f32(vaddq_f32(v110, vmulq_f32(v109, v112)), vmulq_f32(vmulq_f32(v109, v109), vaddq_f32(v108, vmulq_f32(v111, v109)))))), COERCE_FLOAT(*(_OWORD *)v94->f32)), v113);
    v116 = vcvtq_f32_s32(vcvtq_s32_f32(v115));
    v117 = vsubq_f32(v116, (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v116, v115)));
    v118 = vsubq_f32(v115, v117);
    v119 = *(float32x4_t *)v94[32].f32;
    v120 = *(float32x4_t *)v94[34].f32;
    v121 = *(float32x4_t *)v94[36].f32;
    v122 = *(int32x4_t *)v94[38].f32;
    v123 = vmulq_f32(vaddq_f32(v97, vmulq_f32(v118, vaddq_f32(v121, vmulq_f32(v118, vaddq_f32(v119, vmulq_f32(v120, v118)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v122, vcvtq_s32_f32(v117)), 0x17uLL));
    v124 = (float32x4_t)vbslq_s8(v95, (int8x16_t)v93, (int8x16_t)vaddq_f32(v97, vmulq_laneq_f32(v123, v114, 2)));
    v125 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114.f32, 0), vmulq_lane_f32(v123, *(float32x2_t *)v114.f32, 1));
    v126 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v124), *(float32x4_t *)v94[40].f32), *(float32x4_t *)v94[42].f32), *(float32x4_t *)v94[44].f32);
    v127 = (float32x4_t)vbslq_s8(v95, (int8x16_t)v93, (int8x16_t)vmulq_f32(vmulq_f32(v126, vrecpsq_f32(v124, v126)), v125));
    v128 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v127, v98), (int8x16_t)v97);
    v129 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v127, 0x17uLL)), (float32x4_t)vandq_s8(v101, (int8x16_t)vcgtq_f32(v100, v127))), v103);
    v130 = (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v128, v104));
    v131 = vsubq_f32(vsubq_f32(v128, v97), vmulq_f32(vmulq_f32(v107, v130), v128));
    v132 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(vaddq_f32(v129, v130), vmulq_f32(v131, vaddq_f32(vaddq_f32(v110, vmulq_f32(v112, v131)), vmulq_f32(vmulq_f32(v131, v131), vaddq_f32(v108, vmulq_f32(v111, v131)))))), *v94, 1), v113);
    v133 = vcvtq_f32_s32(vcvtq_s32_f32(v132));
    v134 = vsubq_f32(v133, (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v133, v132)));
    v135 = vsubq_f32(v132, v134);
    *(int8x16_t *)(v5 + v92) = vbslq_s8(v95, (int8x16_t)v93, (int8x16_t)vmulq_f32(vaddq_f32(v97, vmulq_f32(v135, vaddq_f32(v121, vmulq_f32(v135, vaddq_f32(v119, vmulq_f32(v120, v135)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v134), v122), 0x17uLL)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcST2084_InverseEOTF::GetDOD(HgcST2084_InverseEOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcST2084_InverseEOTF::GetROI(HgcST2084_InverseEOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcST2084_InverseEOTF::HgcST2084_InverseEOTF(HgcST2084_InverseEOTF *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6548AF0;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = xmmword_1B30536D0;
  *(_OWORD *)(v3 + 48) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 64) = xmmword_1B3051600;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051560;
  *(_OWORD *)(v3 + 96) = xmmword_1B3051610;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051620;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051630;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051640;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051510;
  *(_OWORD *)(v3 + 176) = xmmword_1B3051650;
  *(_OWORD *)(v3 + 192) = xmmword_1B3051660;
  *(_OWORD *)(v3 + 208) = xmmword_1B3051670;
  *(_OWORD *)(v3 + 224) = xmmword_1B3051680;
  *(_OWORD *)(v3 + 240) = xmmword_1B3051690;
  *(_OWORD *)(v3 + 256) = xmmword_1B30516A0;
  *(_OWORD *)(v3 + 272) = xmmword_1B30516B0;
  *(_OWORD *)(v3 + 288) = xmmword_1B30516C0;
  *(_OWORD *)(v3 + 304) = xmmword_1B30516D0;
  *(_OWORD *)(v3 + 320) = xmmword_1B3051BC0;
  *(_OWORD *)(v3 + 336) = xmmword_1B3052320;
  *(int32x4_t *)(v3 + 352) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BE8F68(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcST2084_InverseEOTF::~HgcST2084_InverseEOTF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6548AF0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C409BD2D9E4);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6548AF0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C409BD2D9E4);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcST2084_InverseEOTF::SetParameter(HgcST2084_InverseEOTF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcST2084_InverseEOTF::GetParameter(HgcST2084_InverseEOTF *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_PQ_OOTF::GetProgram(HgcBT2100_PQ_OOTF *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003fc\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[0].zzz);\n"
             "    r0.xyz = pow(r1.xyz, half3(hg_Params[1].xxx));\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = half3(half3(hg_Params[0].www) < r1.xyz);\n"
             "    r0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000h);\n"
             "    output.color0.xyz = pow(float3(r0.xyz), hg_Params[1].yyy);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=497acd98:5770f8f6:3d0f2d43:8aa16af4\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003c7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz*hg_Params[0].zzz;\n"
             "    r0.xyz = pow(r1.xyz, hg_Params[1].xxx);\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r1.xyz = float3(hg_Params[0].www < r1.xyz);\n"
             "    r0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
             "    output.color0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ba549f37:722664fb:6e7f959f:a25bfb26\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000040e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal0.zzz;\n"
           "    r0.xyz = pow(r1.xyz, hg_ProgramLocal1.xxx);\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = vec3(lessThan(hg_ProgramLocal0.www, r1.xyz));\n"
           "    r0.xyz = vec3(-r1.x < 0.00000 ? r0.x : r2.x, -r1.y < 0.00000 ? r0.y : r2.y, -r1.z < 0.00000 ? r0.z : r2.z"
           ");\n"
           "    gl_FragColor.xyz = pow(r0.xyz, hg_ProgramLocal1.yyy);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=16c6aa6a:26df20c3:449175b2:08fdb222\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_PQ_OOTF::InitProgramDescriptor(HgcBT2100_PQ_OOTF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_PQ_OOTF_hgc_visible", "//Metal1.0     \n//LEN=00000002a2\n[[ visible ]] FragmentOut HgcBT2100_PQ_OOTF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r2.xyz = r1.xyz*hg_Params[0].zzz;\n"
    "    r0.xyz = pow(r1.xyz, hg_Params[1].xxx);\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r1.xyz = float3(hg_Params[0].www < r1.xyz);\n"
    "    r0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
    "    output.color0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BE937C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BE93AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BE93A4);
}

char *HgcBT2100_PQ_OOTF::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3525EE0;
  strcpy(result, "HgcBT2100_PQ_OOTF [hgc1]");
  return result;
}

uint64_t HgcBT2100_PQ_OOTF::BindTexture(HgcBT2100_PQ_OOTF *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_PQ_OOTF::Bind(HgcBT2100_PQ_OOTF *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcBT2100_PQ_OOTF *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBT2100_PQ_OOTF::RenderTile(HgcBT2100_PQ_OOTF *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  _OWORD *v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  __int128 v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int8x16_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  int8x16_t v52;
  float32x4_t v53;
  float32x4_t v54;
  int8x16_t v55;
  int32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  int8x16_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int8x16_t *v83;
  int v84;
  uint64_t v85;
  float32x4_t v86;
  _OWORD *v87;
  float32x4_t v88;
  int8x16_t v89;
  float32x4_t v90;
  __int128 v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  int8x16_t v114;
  int32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v84 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v12 = *(float32x4_t *)(v6 + v10 - 16);
      v11 = *(float32x4_t *)(v6 + v10);
      v13 = (_OWORD *)*((_QWORD *)this + 51);
      v14 = *((float32x4_t *)v13 + 2);
      v15 = *((int8x16_t *)v13 + 3);
      v16 = vmaxq_f32(v12, v14);
      v17 = vmaxq_f32(v11, v14);
      v18 = *((float32x4_t *)v13 + 4);
      v19 = *((float32x4_t *)v13 + 5);
      v20 = (float32x4_t)vorrq_s8(vandq_s8(v15, (int8x16_t)v16), (int8x16_t)v18);
      v21 = (float32x4_t)vorrq_s8(vandq_s8(v15, (int8x16_t)v17), (int8x16_t)v18);
      v22 = *((int8x16_t *)v13 + 6);
      v23 = *((float32x4_t *)v13 + 7);
      v25 = *((float32x4_t *)v13 + 8);
      v24 = *((float32x4_t *)v13 + 9);
      v26 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v20, v25));
      v27 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v21, v25));
      v28 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v19, v16))), v23), v26);
      v29 = vsubq_f32(vsubq_f32(v20, v18), vmulq_f32(vmulq_f32(v24, v26), v20));
      v30 = vsubq_f32(vsubq_f32(v21, v18), vmulq_f32(vmulq_f32(v24, v27), v21));
      v31 = *((float32x4_t *)v13 + 10);
      v32 = *((float32x4_t *)v13 + 11);
      v33 = *((float32x4_t *)v13 + 12);
      v34 = *((float32x4_t *)v13 + 13);
      v35 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v19, v17))), v23), v27), vmulq_f32(v30, vaddq_f32(vaddq_f32(v33, vmulq_f32(v30, v34)), vmulq_f32(vmulq_f32(v30, v30), vaddq_f32(v31, vmulq_f32(v32, v30))))));
      v36 = v13[1];
      v37 = vmulq_n_f32(vaddq_f32(v28, vmulq_f32(v29, vaddq_f32(vaddq_f32(v33, vmulq_f32(v29, v34)), vmulq_f32(vmulq_f32(v29, v29), vaddq_f32(v31, vmulq_f32(v32, v29)))))), *(float *)&v36);
      v38 = vmulq_n_f32(v35, *(float *)&v36);
      v40 = *((float32x4_t *)v13 + 14);
      v39 = *((float32x4_t *)v13 + 15);
      v41 = vmaxq_f32(v37, v40);
      v42 = vmaxq_f32(v38, v40);
      v43 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
      v45 = (int8x16_t)vmulq_laneq_f32(v16, *(float32x4_t *)v13, 2);
      v46 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v43, v41)));
      v47 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v44, v42)));
      v48 = vsubq_f32(v41, v46);
      v49 = vsubq_f32(v42, v47);
      v51 = *((float32x4_t *)v13 + 16);
      v50 = *((float32x4_t *)v13 + 17);
      v52 = (int8x16_t)vmulq_laneq_f32(v17, *(float32x4_t *)v13, 2);
      v53 = vmulq_f32(v49, vaddq_f32(v50, vmulq_f32(v49, vaddq_f32(v39, vmulq_f32(v51, v49)))));
      v54 = vaddq_f32(v18, vmulq_f32(v48, vaddq_f32(v50, vmulq_f32(v48, vaddq_f32(v39, vmulq_f32(v51, v48))))));
      v56 = *((int32x4_t *)v13 + 18);
      v55 = *((int8x16_t *)v13 + 19);
      v57 = (float32x4_t)vbslq_s8(v55, (int8x16_t)v11, (int8x16_t)vmulq_f32(vaddq_f32(v18, v53), (float32x4_t)vshlq_n_s32(vaddq_s32(v56, vcvtq_s32_f32(v47)), 0x17uLL)));
      v58 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 1);
      v59 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v13, 3);
      v60 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v16, v59)), v14);
      v61 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v17, v59)), v14);
      v62 = (float32x4_t)vbslq_s8(v55, (int8x16_t)v12, vbslq_s8(v60, vbslq_s8(v55, (int8x16_t)v12, (int8x16_t)vaddq_f32(v58, vmulq_n_f32((float32x4_t)vbslq_s8(v55, (int8x16_t)v12, (int8x16_t)vmulq_f32(v54, (float32x4_t)vshlq_n_s32(vaddq_s32(v56, vcvtq_s32_f32(v46)),
                                                                                         0x17uLL))),
                                              COERCE_FLOAT(*v13)))),
                             v45));
      v63 = (float32x4_t)vbslq_s8(v55, (int8x16_t)v11, vbslq_s8(v61, vbslq_s8(v55, (int8x16_t)v11, (int8x16_t)vaddq_f32(v58, vmulq_n_f32(v57, COERCE_FLOAT(*v13)))), v52));
      v64 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v62, v15), (int8x16_t)v18);
      v65 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v63, v15), (int8x16_t)v18);
      v66 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v63, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v19, v63)));
      v67 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v62, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v19, v62))), v23);
      v68 = vsubq_f32(v66, v23);
      v69 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v64, v25));
      v70 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v65, v25));
      v71 = vaddq_f32(v67, v69);
      v72 = vsubq_f32(vsubq_f32(v64, v18), vmulq_f32(vmulq_f32(v24, v69), v64));
      v73 = vsubq_f32(vsubq_f32(v65, v18), vmulq_f32(vmulq_f32(v24, v70), v65));
      v74 = vaddq_f32(vaddq_f32(v68, v70), vmulq_f32(v73, vaddq_f32(vaddq_f32(v33, vmulq_f32(v34, v73)), vmulq_f32(vmulq_f32(v73, v73), vaddq_f32(v31, vmulq_f32(v32, v73))))));
      v75 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v71, vmulq_f32(v72, vaddq_f32(vaddq_f32(v33, vmulq_f32(v34, v72)), vmulq_f32(vmulq_f32(v72, v72), vaddq_f32(v31, vmulq_f32(v32, v72)))))), *(float32x2_t *)&v36, 1), v40);
      v76 = vmaxq_f32(vmulq_lane_f32(v74, *(float32x2_t *)&v36, 1), v40);
      v77 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v76));
      v79 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v77, v75)));
      v80 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v78, v76)));
      v81 = vsubq_f32(v75, v79);
      v82 = vsubq_f32(v76, v80);
      v83 = (int8x16_t *)(v5 + v10);
      v83[-1] = vbslq_s8(v55, (int8x16_t)v12, (int8x16_t)vmulq_f32(vaddq_f32(v18, vmulq_f32(v81, vaddq_f32(v50, vmulq_f32(v81, vaddq_f32(v39, vmulq_f32(v51, v81)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v79), v56), 0x17uLL)));
      *v83 = vbslq_s8(v55, (int8x16_t)v11, (int8x16_t)vmulq_f32(vaddq_f32(v18, vmulq_f32(v82, vaddq_f32(v50, vmulq_f32(v82, vaddq_f32(v39, vmulq_f32(v51, v82)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v80), v56), 0x17uLL)));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v84 = -v9;
    if (v84 >= v4)
      goto LABEL_3;
LABEL_10:
    v85 = 16 * v84;
    v86 = *(float32x4_t *)(v6 + v85);
    v87 = (_OWORD *)*((_QWORD *)this + 51);
    v88 = *((float32x4_t *)v87 + 2);
    v89 = *((int8x16_t *)v87 + 3);
    v90 = vmaxq_f32(v86, v88);
    v91 = v87[1];
    v92 = *((float32x4_t *)v87 + 4);
    v93 = *((float32x4_t *)v87 + 5);
    v94 = (float32x4_t)vorrq_s8(vandq_s8(v89, (int8x16_t)v90), (int8x16_t)v92);
    v95 = *((int8x16_t *)v87 + 6);
    v96 = *((float32x4_t *)v87 + 7);
    v97 = *((float32x4_t *)v87 + 8);
    v98 = *((float32x4_t *)v87 + 9);
    v99 = (float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v94, v97));
    v100 = vsubq_f32(vsubq_f32(v94, v92), vmulq_f32(vmulq_f32(v98, v99), v94));
    v101 = *((float32x4_t *)v87 + 10);
    v102 = *((float32x4_t *)v87 + 11);
    v103 = *((float32x4_t *)v87 + 12);
    v104 = *((float32x4_t *)v87 + 13);
    v105 = vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v90, 0x17uLL)), (float32x4_t)vandq_s8(v95, (int8x16_t)vcgtq_f32(v93, v90))), v96), v99), vmulq_f32(v100, vaddq_f32(vaddq_f32(v103, vmulq_f32(v100, v104)), vmulq_f32(vmulq_f32(v100, v100), vaddq_f32(v101, vmulq_f32(v102, v100)))))), *(float *)&v91);
    v106 = *((float32x4_t *)v87 + 14);
    v107 = *((float32x4_t *)v87 + 15);
    v108 = vmaxq_f32(v105, v106);
    v109 = vcvtq_f32_s32(vcvtq_s32_f32(v108));
    v110 = vsubq_f32(v109, (float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v109, v108)));
    v111 = vsubq_f32(v108, v110);
    v112 = *((float32x4_t *)v87 + 16);
    v113 = *((float32x4_t *)v87 + 17);
    v115 = *((int32x4_t *)v87 + 18);
    v114 = *((int8x16_t *)v87 + 19);
    v116 = (float32x4_t)vbslq_s8(v114, (int8x16_t)v86, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v90, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v87, 3))), v88), vbslq_s8(v114, (int8x16_t)v86, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v87, 1), vmulq_n_f32((float32x4_t)vbslq_s8(v114, (int8x16_t)v86,
                                                            (int8x16_t)vmulq_f32(vaddq_f32(v92, vmulq_f32(v111, vaddq_f32(v113, vmulq_f32(v111, vaddq_f32(v107, vmulq_f32(v112, v111)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v115, vcvtq_s32_f32(v110)), 0x17uLL))), COERCE_FLOAT(*v87)))), (int8x16_t)vmulq_laneq_f32(v90, *(float32x4_t *)v87, 2)));
    v117 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v116, v89), (int8x16_t)v92);
    v118 = (float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v117, v97));
    v119 = vsubq_f32(vsubq_f32(v117, v92), vmulq_f32(vmulq_f32(v98, v118), v117));
    v120 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v116, 0x17uLL)), (float32x4_t)vandq_s8(v95, (int8x16_t)vcgtq_f32(v93, v116))), v96), v118), vmulq_f32(v119, vaddq_f32(vaddq_f32(v103, vmulq_f32(v104, v119)), vmulq_f32(vmulq_f32(v119, v119), vaddq_f32(v101, vmulq_f32(v102, v119)))))), *(float32x2_t *)&v91, 1), v106);
    v121 = vcvtq_f32_s32(vcvtq_s32_f32(v120));
    v122 = vsubq_f32(v121, (float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v121, v120)));
    v123 = vsubq_f32(v120, v122);
    *(int8x16_t *)(v5 + v85) = vbslq_s8(v114, (int8x16_t)v86, (int8x16_t)vmulq_f32(vaddq_f32(v92, vmulq_f32(v123, vaddq_f32(v113, vmulq_f32(v123, vaddq_f32(v107, vmulq_f32(v112, v123)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v122), v115), 0x17uLL)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2100_PQ_OOTF::GetDOD(HgcBT2100_PQ_OOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBT2100_PQ_OOTF::GetROI(HgcBT2100_PQ_OOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBT2100_PQ_OOTF::HgcBT2100_PQ_OOTF(HgcBT2100_PQ_OOTF *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6548D58;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = 0u;
  v3[3] = xmmword_1B3051600;
  v3[4] = xmmword_1B3051560;
  v3[5] = xmmword_1B3051610;
  v3[6] = xmmword_1B3051620;
  v3[7] = xmmword_1B3051630;
  v3[8] = xmmword_1B3051640;
  v3[9] = xmmword_1B3051510;
  v3[10] = xmmword_1B3051650;
  v3[11] = xmmword_1B3051660;
  v3[12] = xmmword_1B3051670;
  v3[13] = xmmword_1B3051680;
  v3[14] = xmmword_1B3051690;
  v3[15] = xmmword_1B30516A0;
  v3[16] = xmmword_1B30516B0;
  v3[17] = xmmword_1B30516C0;
  v3[18] = xmmword_1B30516D0;
  v3[19] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BE9C3C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_PQ_OOTF::~HgcBT2100_PQ_OOTF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6548D58;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B2834900);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6548D58;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B2834900);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_PQ_OOTF::SetParameter(HgcBT2100_PQ_OOTF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_PQ_OOTF::GetParameter(HgcBT2100_PQ_OOTF *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_PQ_OOTF_qtApprox::GetProgram(HgcBT2100_PQ_OOTF_qtApprox *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000338\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xxx);\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[0].yyy));\n"
             "    output.color0.xyz = float3(r0.xyz)*hg_Params[0].zzz;\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=56795360:c329840e:57b872f7:276b1e06\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000317\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xxx;\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
             "    output.color0.xyz = r0.xyz*hg_Params[0].zzz;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=cd043c2b:d3f1596d:4cb96176:dc8cdb49\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002ed\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xxx;\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal0.yyy);\n"
           "    gl_FragColor.xyz = r0.xyz*hg_ProgramLocal0.zzz;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=37349320:63679db7:9c06dc59:4d215346\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_PQ_OOTF_qtApprox::InitProgramDescriptor(HgcBT2100_PQ_OOTF_qtApprox *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_PQ_OOTF_qtApprox_hgc_visible", "//Metal1.0     \n//LEN=00000001fb\n[[ visible ]] FragmentOut HgcBT2100_PQ_OOTF_qtApprox_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xxx;\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
    "    output.color0.xyz = r0.xyz*hg_Params[0].zzz;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BEA050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BEA080(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BEA078);
}

char *HgcBT2100_PQ_OOTF_qtApprox::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D20;
  strcpy(result, "HgcBT2100_PQ_OOTF_qtApprox [hgc1]");
  return result;
}

uint64_t HgcBT2100_PQ_OOTF_qtApprox::BindTexture(HgcBT2100_PQ_OOTF_qtApprox *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_PQ_OOTF_qtApprox::Bind(HgcBT2100_PQ_OOTF_qtApprox *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcBT2100_PQ_OOTF_qtApprox *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBT2100_PQ_OOTF_qtApprox::RenderTile(HgcBT2100_PQ_OOTF_qtApprox *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  _OWORD *v13;
  float32x4_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  int32x4_t v56;
  int32x4_t v57;
  int8x16_t v58;
  int8x16_t v59;
  int8x16_t *v60;
  int v61;
  uint64_t v62;
  float32x4_t v63;
  uint64_t v64;
  int8x16_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v61 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v12 = *(float32x4_t *)(v6 + v10 - 16);
      v11 = *(float32x4_t *)(v6 + v10);
      v13 = (_OWORD *)*((_QWORD *)this + 51);
      v14 = *((float32x4_t *)v13 + 1);
      v15 = (int8x16_t)vmaxq_f32(v12, v14);
      v16 = (int8x16_t)vmaxq_f32(v11, v14);
      v17 = *((int8x16_t *)v13 + 2);
      v18 = *((int8x16_t *)v13 + 3);
      v19 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v12, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v12, v15), COERCE_FLOAT(*v13)));
      v20 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v11, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v11, v16), COERCE_FLOAT(*v13)));
      v21 = *((float32x4_t *)v13 + 4);
      v22 = *((float32x4_t *)v13 + 5);
      v23 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v19, v18), (int8x16_t)v21);
      v24 = *((int8x16_t *)v13 + 6);
      v25 = *((float32x4_t *)v13 + 7);
      v26 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v20, v18), (int8x16_t)v21);
      v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v20)));
      v28 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v19))), v25);
      v29 = *((float32x4_t *)v13 + 8);
      v30 = *((float32x4_t *)v13 + 9);
      v31 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v23, v29));
      v32 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v26, v29));
      v33 = vaddq_f32(v28, v31);
      v34 = vsubq_f32(vsubq_f32(v23, v21), vmulq_f32(vmulq_f32(v30, v31), v23));
      v35 = vsubq_f32(vsubq_f32(v26, v21), vmulq_f32(vmulq_f32(v30, v32), v26));
      v36 = *((float32x4_t *)v13 + 10);
      v37 = *((float32x4_t *)v13 + 11);
      v38 = *((float32x4_t *)v13 + 12);
      v39 = *((float32x4_t *)v13 + 13);
      v40 = vaddq_f32(vaddq_f32(vsubq_f32(v27, v25), v32), vmulq_f32(v35, vaddq_f32(vaddq_f32(v38, vmulq_f32(v39, v35)), vmulq_f32(vmulq_f32(v35, v35), vaddq_f32(v36, vmulq_f32(v37, v35))))));
      v41 = vmulq_lane_f32(vaddq_f32(v33, vmulq_f32(v34, vaddq_f32(vaddq_f32(v38, vmulq_f32(v39, v34)), vmulq_f32(vmulq_f32(v34, v34), vaddq_f32(v36, vmulq_f32(v37, v34)))))), *(float32x2_t *)v13, 1);
      v42 = *((float32x4_t *)v13 + 14);
      v43 = *((float32x4_t *)v13 + 15);
      v44 = vmaxq_f32(v41, v42);
      v45 = vmaxq_f32(vmulq_lane_f32(v40, *(float32x2_t *)v13, 1), v42);
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      v48 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v46, v44)));
      v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v47, v45)));
      v50 = vsubq_f32(v44, v48);
      v51 = vsubq_f32(v45, v49);
      v52 = *((float32x4_t *)v13 + 16);
      v53 = *((float32x4_t *)v13 + 17);
      v54 = vmulq_f32(v51, vaddq_f32(v53, vmulq_f32(v51, vaddq_f32(v43, vmulq_f32(v52, v51)))));
      v55 = vaddq_f32(v21, vmulq_f32(v50, vaddq_f32(v53, vmulq_f32(v50, vaddq_f32(v43, vmulq_f32(v52, v50))))));
      v56 = vcvtq_s32_f32(v49);
      v57 = *((int32x4_t *)v13 + 18);
      v58 = (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v11, (int8x16_t)vmulq_f32(vaddq_f32(v21, v54), (float32x4_t)vshlq_n_s32(vaddq_s32(v57, v56), 0x17uLL))), *(float32x4_t *)v13, 2);
      v59 = vbslq_s8(v17, (int8x16_t)v12, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v12, (int8x16_t)vmulq_f32(v55, (float32x4_t)vshlq_n_s32(vaddq_s32(v57, vcvtq_s32_f32(v48)), 0x17uLL))), *(float32x4_t *)v13, 2));
      v60 = (int8x16_t *)(v5 + v10);
      v60[-1] = v59;
      *v60 = vbslq_s8(v17, (int8x16_t)v11, v58);
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v61 = -v9;
    if (v61 >= v4)
      goto LABEL_3;
LABEL_10:
    v62 = 16 * v61;
    v63 = *(float32x4_t *)(v6 + v62);
    v64 = *((_QWORD *)this + 51);
    v65 = *(int8x16_t *)(v64 + 32);
    v66 = (float32x4_t)vbslq_s8(v65, (int8x16_t)v63, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v65, (int8x16_t)v63, (int8x16_t)vmaxq_f32(v63, *(float32x4_t *)(v64 + 16))), COERCE_FLOAT(*(_OWORD *)v64)));
    v67 = *(float32x4_t *)(v64 + 64);
    v68 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v66, *(int8x16_t *)(v64 + 48)), (int8x16_t)v67);
    v69 = (float32x4_t)vandq_s8((int8x16_t)v67, (int8x16_t)vcgtq_f32(v68, *(float32x4_t *)(v64 + 128)));
    v70 = vsubq_f32(vsubq_f32(v68, v67), vmulq_f32(vmulq_f32(*(float32x4_t *)(v64 + 144), v69), v68));
    v71 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v66, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v64 + 96), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v64 + 80), v66))), *(float32x4_t *)(v64 + 112)), v69), vmulq_f32(v70, vaddq_f32(vaddq_f32(*(float32x4_t *)(v64 + 192), vmulq_f32(*(float32x4_t *)(v64 + 208), v70)), vmulq_f32(vmulq_f32(v70, v70), vaddq_f32(*(float32x4_t *)(v64 + 160), vmulq_f32(*(float32x4_t *)(v64 + 176), v70)))))), *(float32x2_t *)v64,
              1),
            *(float32x4_t *)(v64 + 224));
    v72 = vcvtq_f32_s32(vcvtq_s32_f32(v71));
    v73 = vsubq_f32(v72, (float32x4_t)vandq_s8((int8x16_t)v67, (int8x16_t)vcgtq_f32(v72, v71)));
    v74 = vsubq_f32(v71, v73);
    *(int8x16_t *)(v5 + v62) = vbslq_s8(v65, (int8x16_t)v63, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v65, (int8x16_t)v63, (int8x16_t)vmulq_f32(vaddq_f32(v67, vmulq_f32(v74, vaddq_f32(*(float32x4_t *)(v64 + 272), vmulq_f32(v74, vaddq_f32(*(float32x4_t *)(v64 + 240), vmulq_f32(*(float32x4_t *)(v64 + 256),
                                                                                      v74)))))),
                                                                          (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v64 + 288), vcvtq_s32_f32(v73)), 0x17uLL))), *(float32x4_t *)v64, 2));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2100_PQ_OOTF_qtApprox::GetDOD(HgcBT2100_PQ_OOTF_qtApprox *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBT2100_PQ_OOTF_qtApprox::GetROI(HgcBT2100_PQ_OOTF_qtApprox *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBT2100_PQ_OOTF_qtApprox::HgcBT2100_PQ_OOTF_qtApprox(HgcBT2100_PQ_OOTF_qtApprox *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6548FC0;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_OWORD *)(v3 + 16) = xmmword_1B30536D0;
  *(_OWORD *)(v3 + 32) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 48) = xmmword_1B3051600;
  *(_OWORD *)(v3 + 64) = xmmword_1B3051560;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051610;
  *(_OWORD *)(v3 + 96) = xmmword_1B3051620;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051630;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051640;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051510;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051650;
  *(_OWORD *)(v3 + 176) = xmmword_1B3051660;
  *(_OWORD *)(v3 + 192) = xmmword_1B3051670;
  *(_OWORD *)(v3 + 208) = xmmword_1B3051680;
  *(_OWORD *)(v3 + 224) = xmmword_1B3051690;
  *(_OWORD *)(v3 + 240) = xmmword_1B30516A0;
  *(_OWORD *)(v3 + 256) = xmmword_1B30516B0;
  *(_OWORD *)(v3 + 272) = xmmword_1B30516C0;
  *(_OWORD *)(v3 + 288) = xmmword_1B30516D0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BEA698(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_PQ_OOTF_qtApprox::~HgcBT2100_PQ_OOTF_qtApprox(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6548FC0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40FDACBBE0);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6548FC0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40FDACBBE0);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_PQ_OOTF_qtApprox::SetParameter(HgcBT2100_PQ_OOTF_qtApprox *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcBT2100_PQ_OOTF_qtApprox::GetParameter(HgcBT2100_PQ_OOTF_qtApprox *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcBT2100_PQ_InverseOOTF::GetProgram(HgcBT2100_PQ_InverseOOTF *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000413\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r0.xyz, half3(hg_Params[1].xxx));\n"
             "    r0.xyz = r1.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[0].zzz);\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[1].yyy));\n"
             "    r1.xyz = half3(half3(hg_Params[0].www) < r1.xyz);\n"
             "    output.color0.xyz = select(float3(r2.xyz), float3(r0.xyz), -float3(r1.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a5d8e794:3395fdf7:d7923219:174ddda5\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003c7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r0.xyz, hg_Params[1].xxx);\n"
             "    r0.xyz = r1.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = r1.xyz*hg_Params[0].zzz;\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
             "    r1.xyz = float3(hg_Params[0].www < r1.xyz);\n"
             "    output.color0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2f1f52de:ad2f008b:df44194e:84e296bb\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000403\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r0.xyz, hg_ProgramLocal1.xxx);\n"
           "    r0.xyz = r1.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal0.zzz;\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal1.yyy);\n"
           "    r1.xyz = vec3(lessThan(hg_ProgramLocal0.www, r1.xyz));\n"
           "    gl_FragColor.xyz = vec3(-r1.x < 0.00000 ? r0.x : r2.x, -r1.y < 0.00000 ? r0.y : r2.y, -r1.z < 0.00000 ? r"
           "0.z : r2.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=b9a478a9:481ead68:896d40e0:012e2e2e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_PQ_InverseOOTF::InitProgramDescriptor(HgcBT2100_PQ_InverseOOTF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_PQ_InverseOOTF_hgc_visible", "//Metal1.0     \n//LEN=00000002a9\n[[ visible ]] FragmentOut HgcBT2100_PQ_InverseOOTF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r0.xyz, hg_Params[1].xxx);\n"
    "    r0.xyz = r1.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = r1.xyz*hg_Params[0].zzz;\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
    "    r1.xyz = float3(hg_Params[0].www < r1.xyz);\n"
    "    output.color0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BEAA88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BEAAB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BEAAB0);
}

double HgcBT2100_PQ_InverseOOTF::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A60;
  strcpy(v3, "HgcBT2100_PQ_InverseOOTF [hgc1]");
  return *(double *)"verseOOTF [hgc1]";
}

uint64_t HgcBT2100_PQ_InverseOOTF::BindTexture(HgcBT2100_PQ_InverseOOTF *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_PQ_InverseOOTF::Bind(HgcBT2100_PQ_InverseOOTF *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcBT2100_PQ_InverseOOTF *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBT2100_PQ_InverseOOTF::RenderTile(HgcBT2100_PQ_InverseOOTF *this, HGTile *a2)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float32x4_t v10;
  _OWORD *v11;
  float32x4_t v12;
  int8x16_t v13;
  __int128 v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
  {
    v3 = 0;
    v4 = *((_QWORD *)a2 + 10);
    v5 = 16 * *((int *)a2 + 22);
    v6 = *((_QWORD *)a2 + 2);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    do
    {
      v9 = 0;
      do
      {
        v10 = *(float32x4_t *)(v4 + v9);
        v11 = (_OWORD *)*((_QWORD *)this + 51);
        v12 = *((float32x4_t *)v11 + 2);
        v13 = *((int8x16_t *)v11 + 3);
        v14 = v11[1];
        v15 = *((float32x4_t *)v11 + 4);
        v16 = *((int8x16_t *)v11 + 5);
        v17 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v14, 0), v12)), v12), (int8x16_t)v15, vbslq_s8(v13, (int8x16_t)v10, (int8x16_t)vmaxq_f32(v10, v12)));
        v18 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v17, v16), (int8x16_t)v15);
        v19 = *((float32x4_t *)v11 + 6);
        v20 = *((int8x16_t *)v11 + 7);
        v21 = *((float32x4_t *)v11 + 8);
        v22 = *((float32x4_t *)v11 + 9);
        v23 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v18, v22));
        v24 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v19, v17))), v21), v23);
        v25 = *((float32x4_t *)v11 + 10);
        v26 = *((float32x4_t *)v11 + 11);
        v27 = vsubq_f32(vsubq_f32(v18, v15), vmulq_f32(vmulq_f32(v25, v23), v18));
        v28 = vmulq_f32(v27, v27);
        v29 = *((float32x4_t *)v11 + 12);
        v30 = *((float32x4_t *)v11 + 13);
        v31 = *((float32x4_t *)v11 + 14);
        v32 = *((float32x4_t *)v11 + 15);
        v33 = *((float32x4_t *)v11 + 16);
        v34 = *((float32x4_t *)v11 + 17);
        v35 = vmulq_n_f32(vaddq_f32(v24, vmulq_f32(v27, vaddq_f32(v34, vmulq_f32(v27, vaddq_f32(vaddq_f32(v32, vmulq_f32(v27, v33)), vmulq_f32(v28, vaddq_f32(vaddq_f32(v26, vmulq_f32(v29, v27)), vmulq_f32(v28, vaddq_f32(v30, vmulq_f32(v31, v27)))))))))), *(float *)&v14);
        v36 = *((float32x4_t *)v11 + 18);
        v37 = *((float32x4_t *)v11 + 19);
        v38 = vmaxq_f32(v35, v36);
        v39 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
        v40 = vsubq_f32(v39, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v39, v38)));
        v41 = vsubq_f32(v38, v40);
        v42 = *((float32x4_t *)v11 + 20);
        v43 = *((float32x4_t *)v11 + 21);
        v44 = *((float32x4_t *)v11 + 22);
        v45 = *((float32x4_t *)v11 + 23);
        v46 = *((int32x4_t *)v11 + 24);
        v47 = vmulq_f32(vaddq_f32(v15, vmulq_f32(v41, vaddq_f32(v45, vmulq_f32(v41, vaddq_f32(vaddq_f32(v43, vmulq_f32(v44, v41)), vmulq_f32(vmulq_f32(v41, v41), vaddq_f32(v37, vmulq_f32(v42, v41)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v46, vcvtq_s32_f32(v40)), 0x17uLL));
        v48 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v14, 1), v12)), v12), (int8x16_t)v15, vbslq_s8(v13, (int8x16_t)v10, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11, 1), vmulq_n_f32(v47, COERCE_FLOAT(*v11)))));
        v49 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v48, v16), (int8x16_t)v15);
        v50 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v48, 0x17uLL)), (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v19, v48))), v21);
        v51 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v49, v22));
        v52 = vaddq_f32(v50, v51);
        v53 = vsubq_f32(vsubq_f32(v49, v15), vmulq_f32(vmulq_f32(v25, v51), v49));
        v54 = vmulq_f32(v53, v53);
        v55 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v52, vmulq_f32(v53, vaddq_f32(v34, vmulq_f32(v53, vaddq_f32(vaddq_f32(v32, vmulq_f32(v33, v53)), vmulq_f32(v54, vaddq_f32(vaddq_f32(v26, vmulq_f32(v29, v53)), vmulq_f32(v54, vaddq_f32(v30, vmulq_f32(v31, v53)))))))))), *(float32x2_t *)&v14, 1), v36);
        v56 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
        v57 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v56, v55)));
        v58 = vsubq_f32(v55, v57);
        *(int8x16_t *)(v6 + v9) = vbslq_s8(v13, (int8x16_t)v10, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v47, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v11, 3))), v12), vbslq_s8(v13, (int8x16_t)v10, (int8x16_t)vmulq_f32(vaddq_f32(v15, vmulq_f32(
                                                         v58,
                                                         vaddq_f32(v45, vmulq_f32(v58, vaddq_f32(vaddq_f32(v43, vmulq_f32(v44, v58)), vmulq_f32(vmulq_f32(v58, v58), vaddq_f32(v37, vmulq_f32(v42, v58)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v57), v46), 0x17uLL))), (int8x16_t)vmulq_laneq_f32(v47, *(float32x4_t *)v11, 2)));
        v9 += 16;
      }
      while (v8 != v9);
      ++v3;
      v4 += v5;
      v6 += v7;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcBT2100_PQ_InverseOOTF::GetDOD(HgcBT2100_PQ_InverseOOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBT2100_PQ_InverseOOTF::GetROI(HgcBT2100_PQ_InverseOOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBT2100_PQ_InverseOOTF::HgcBT2100_PQ_InverseOOTF(HgcBT2100_PQ_InverseOOTF *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6549228;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B30536D0;
  v3[3] = xmmword_1B3050F70;
  v3[4] = xmmword_1B3051560;
  v3[5] = xmmword_1B3051600;
  v3[6] = xmmword_1B3051610;
  v3[7] = xmmword_1B3051620;
  v3[8] = xmmword_1B3051630;
  v3[9] = xmmword_1B3051640;
  v3[10] = xmmword_1B3051510;
  v3[11] = xmmword_1B3525860;
  v3[12] = xmmword_1B3525870;
  v3[13] = xmmword_1B3525880;
  v3[14] = xmmword_1B3525890;
  v3[15] = xmmword_1B35258A0;
  v3[16] = xmmword_1B35258B0;
  v3[17] = xmmword_1B35258C0;
  v3[18] = xmmword_1B3051690;
  v3[19] = xmmword_1B35258D0;
  v3[20] = xmmword_1B35258E0;
  v3[21] = xmmword_1B35258F0;
  v3[22] = xmmword_1B3525900;
  v3[23] = xmmword_1B3525910;
  v3[24] = xmmword_1B30516D0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BEB09C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_PQ_InverseOOTF::~HgcBT2100_PQ_InverseOOTF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6549228;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C402BC884A0);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6549228;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C402BC884A0);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_PQ_InverseOOTF::SetParameter(HgcBT2100_PQ_InverseOOTF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_PQ_InverseOOTF::GetParameter(HgcBT2100_PQ_InverseOOTF *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_PQ_OETF::GetProgram(HgcBT2100_PQ_OETF *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004c8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[0].zzz);\n"
             "    r0.xyz = pow(r1.xyz, half3(hg_Params[1].xxx));\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = half3(half3(hg_Params[0].www) < r1.xyz);\n"
             "    r0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000h);\n"
             "    r1.xyz = pow(r0.xyz, half3(hg_Params[1].yyy));\n"
             "    r0.xyz = r1.xyz*half3(hg_Params[2].zzz) + c0.yyy;\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[2].yyy) + half3(hg_Params[2].xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    output.color0.xyz = pow(float3(r0.xyz), hg_Params[1].zzz);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d5425b59:33d8338b:91a6001c:97c5c49c\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000477\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz*hg_Params[0].zzz;\n"
             "    r0.xyz = pow(r1.xyz, hg_Params[1].xxx);\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r1.xyz = float3(hg_Params[0].www < r1.xyz);\n"
             "    r0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
             "    r1.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
             "    r0.xyz = r1.xyz*hg_Params[2].zzz + c0.yyy;\n"
             "    r1.xyz = r1.xyz*hg_Params[2].yyy + hg_Params[2].xxx;\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    output.color0.xyz = pow(r0.xyz, hg_Params[1].zzz);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=67636bc1:21de775e:88d8bf75:0b21046f\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004e8\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal0.zzz;\n"
           "    r0.xyz = pow(r1.xyz, hg_ProgramLocal1.xxx);\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = vec3(lessThan(hg_ProgramLocal0.www, r1.xyz));\n"
           "    r0.xyz = vec3(-r1.x < 0.00000 ? r0.x : r2.x, -r1.y < 0.00000 ? r0.y : r2.y, -r1.z < 0.00000 ? r0.z : r2.z"
           ");\n"
           "    r1.xyz = pow(r0.xyz, hg_ProgramLocal1.yyy);\n"
           "    r0.xyz = r1.xyz*hg_ProgramLocal2.zzz + c0.yyy;\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal2.yyy + hg_ProgramLocal2.xxx;\n"
           "    r0.xyz = r1.xyz/r0.xyz;\n"
           "    gl_FragColor.xyz = pow(r0.xyz, hg_ProgramLocal1.zzz);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=95633a79:b3a4b859:c6f0cae4:5db01d33\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_PQ_OETF::InitProgramDescriptor(HgcBT2100_PQ_OETF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_PQ_OETF_hgc_visible", "//Metal1.0     \n//LEN=0000000352\n[[ visible ]] FragmentOut HgcBT2100_PQ_OETF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r2.xyz = r1.xyz*hg_Params[0].zzz;\n"
    "    r0.xyz = pow(r1.xyz, hg_Params[1].xxx);\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r1.xyz = float3(hg_Params[0].www < r1.xyz);\n"
    "    r0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
    "    r1.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
    "    r0.xyz = r1.xyz*hg_Params[2].zzz + c0.yyy;\n"
    "    r1.xyz = r1.xyz*hg_Params[2].yyy + hg_Params[2].xxx;\n"
    "    r0.xyz = r1.xyz/r0.xyz;\n"
    "    output.color0.xyz = pow(r0.xyz, hg_Params[1].zzz);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BEB4B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BEB4E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BEB4D8);
}

char *HgcBT2100_PQ_OETF::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3525EE0;
  strcpy(result, "HgcBT2100_PQ_OETF [hgc1]");
  return result;
}

uint64_t HgcBT2100_PQ_OETF::BindTexture(HgcBT2100_PQ_OETF *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_PQ_OETF::Bind(HgcBT2100_PQ_OETF *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HgcBT2100_PQ_OETF *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBT2100_PQ_OETF::RenderTile(HgcBT2100_PQ_OETF *this, HGTile *a2)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float32x4_t v10;
  _OWORD *v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  int32x4_t v48;
  int8x16_t v49;
  int32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
  {
    v3 = 0;
    v4 = *((_QWORD *)a2 + 10);
    v5 = 16 * *((int *)a2 + 22);
    v6 = *((_QWORD *)a2 + 2);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    do
    {
      v9 = 0;
      do
      {
        v10 = *(float32x4_t *)(v4 + v9);
        v11 = (_OWORD *)*((_QWORD *)this + 51);
        v12 = *((float32x4_t *)v11 + 1);
        v14 = *((float32x4_t *)v11 + 2);
        v13 = *((float32x4_t *)v11 + 3);
        v15 = *((float32x4_t *)v11 + 4);
        v16 = *((int8x16_t *)v11 + 5);
        v17 = vmaxq_f32(v10, v13);
        v18 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 0), v13)), v13), (int8x16_t)v15, (int8x16_t)v17);
        v19 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v18), (int8x16_t)v15);
        v20 = *((float32x4_t *)v11 + 6);
        v21 = *((int8x16_t *)v11 + 7);
        v22 = *((float32x4_t *)v11 + 8);
        v23 = *((float32x4_t *)v11 + 9);
        v24 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v19, v23));
        v25 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v20, v18))), v22);
        v27 = *((float32x4_t *)v11 + 10);
        v26 = *((float32x4_t *)v11 + 11);
        v28 = vsubq_f32(vsubq_f32(v19, v15), vmulq_f32(vmulq_f32(v27, v24), v19));
        v29 = vmulq_f32(v28, v28);
        v31 = *((float32x4_t *)v11 + 12);
        v30 = *((float32x4_t *)v11 + 13);
        v33 = *((float32x4_t *)v11 + 14);
        v32 = *((float32x4_t *)v11 + 15);
        v35 = *((float32x4_t *)v11 + 16);
        v34 = *((float32x4_t *)v11 + 17);
        v36 = vmulq_n_f32(vaddq_f32(vaddq_f32(v25, v24), vmulq_f32(v28, vaddq_f32(v34, vmulq_f32(v28, vaddq_f32(vaddq_f32(v32, vmulq_f32(v35, v28)), vmulq_f32(v29, vaddq_f32(vaddq_f32(v26, vmulq_f32(v31, v28)), vmulq_f32(v29, vaddq_f32(v30, vmulq_f32(v33, v28)))))))))), v12.f32[0]);
        v38 = *((float32x4_t *)v11 + 18);
        v37 = *((float32x4_t *)v11 + 19);
        v39 = vmaxq_f32(v36, v38);
        v40 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
        v41 = vsubq_f32(v40, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v40, v39)));
        v42 = vsubq_f32(v39, v41);
        v44 = *((float32x4_t *)v11 + 20);
        v43 = *((float32x4_t *)v11 + 21);
        v46 = *((float32x4_t *)v11 + 22);
        v45 = *((float32x4_t *)v11 + 23);
        v47 = vaddq_f32(v15, vmulq_f32(v42, vaddq_f32(v45, vmulq_f32(v42, vaddq_f32(vaddq_f32(v43, vmulq_f32(v46, v42)), vmulq_f32(vmulq_f32(v42, v42), vaddq_f32(v37, vmulq_f32(v44, v42))))))));
        v48 = vcvtq_s32_f32(v41);
        v50 = *((int32x4_t *)v11 + 24);
        v49 = *((int8x16_t *)v11 + 25);
        v51 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1), v13)), v13), (int8x16_t)v15, vbslq_s8(v49, (int8x16_t)v10, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v17,
                                                                          (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v11, 3))), v13), vbslq_s8(v49, (int8x16_t)v10, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11, 1), vmulq_n_f32((float32x4_t)vbslq_s8(v49, (int8x16_t)v10, (int8x16_t)vmulq_f32(v47, (float32x4_t)vshlq_n_s32(vaddq_s32(v50, v48), 0x17uLL))), COERCE_FLOAT(*v11)))), (int8x16_t)vmulq_laneq_f32(v17, *(float32x4_t *)v11, 2))));
        v52 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v51, v16), (int8x16_t)v15);
        v53 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v52, v23));
        v54 = vsubq_f32(vsubq_f32(v52, v15), vmulq_f32(vmulq_f32(v27, v53), v52));
        v55 = vmulq_f32(v54, v54);
        v56 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v51, 0x17uLL)), (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v20, v51))), v22), v53), vmulq_f32(v54, vaddq_f32(v34, vmulq_f32(v54, vaddq_f32(vaddq_f32(v32, vmulq_f32(v35, v54)), vmulq_f32(v55,
                              vaddq_f32(vaddq_f32(v26, vmulq_f32(v31, v54)), vmulq_f32(v55, vaddq_f32(v30, vmulq_f32(v33, v54)))))))))), *(float32x2_t *)v12.f32, 1), v38);
        v57 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
        v58 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v57, v56)));
        v59 = vsubq_f32(v56, v58);
        v60 = vmulq_f32(vaddq_f32(v15, vmulq_f32(v59, vaddq_f32(v45, vmulq_f32(v59, vaddq_f32(vaddq_f32(v43, vmulq_f32(v46, v59)), vmulq_f32(vmulq_f32(v59, v59), vaddq_f32(v37, vmulq_f32(v44, v59)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v58), v50), 0x17uLL));
        v61 = (float32x4_t)vbslq_s8(v49, (int8x16_t)v10, (int8x16_t)vaddq_f32(v15, vmulq_laneq_f32(v60, v14, 2)));
        v62 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 0);
        v63 = vmulq_lane_f32(v60, *(float32x2_t *)v14.f32, 1);
        v64 = *((float32x4_t *)v11 + 26);
        v65 = *((float32x4_t *)v11 + 27);
        v66 = vminq_f32(vmaxq_f32(vrecpeq_f32(v61), v64), v65);
        v67 = vminq_f32(vmaxq_f32(vmulq_f32(v66, vrecpsq_f32(v61, v66)), v64), v65);
        v68 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), v13)), v13), (int8x16_t)v15, vbslq_s8(v49, (int8x16_t)v10, (int8x16_t)vmulq_f32(vmulq_f32(v67, vrecpsq_f32(v61, v67)), vaddq_f32(v62, v63))));
        v69 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v68, v16), (int8x16_t)v15);
        v70 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v69, v23));
        v71 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v68, 0x17uLL)), (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v20, v68))), v22);
        v72 = vsubq_f32(vsubq_f32(v69, v15), vmulq_f32(vmulq_f32(v27, v70), v69));
        v73 = vmulq_f32(v72, v72);
        v74 = vmaxq_f32(vmulq_laneq_f32(vaddq_f32(vaddq_f32(v71, v70), vmulq_f32(v72, vaddq_f32(v34, vmulq_f32(v72, vaddq_f32(vaddq_f32(v32, vmulq_f32(v35, v72)), vmulq_f32(v73, vaddq_f32(vaddq_f32(v26, vmulq_f32(v31, v72)), vmulq_f32(v73, vaddq_f32(v30, vmulq_f32(v33, v72)))))))))), v12, 2), v38);
        v75 = vcvtq_f32_s32(vcvtq_s32_f32(v74));
        v76 = vsubq_f32(v75, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v75, v74)));
        v77 = vsubq_f32(v74, v76);
        *(int8x16_t *)(v6 + v9) = vbslq_s8(v49, (int8x16_t)v10, (int8x16_t)vmulq_f32(vaddq_f32(v15, vmulq_f32(v77, vaddq_f32(v45, vmulq_f32(v77, vaddq_f32(vaddq_f32(v43, vmulq_f32(v46, v77)), vmulq_f32(vmulq_f32(v77, v77), vaddq_f32(v37, vmulq_f32(v44, v77)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v76), v50), 0x17uLL)));
        v9 += 16;
      }
      while (v8 != v9);
      ++v3;
      v4 += v5;
      v6 += v7;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcBT2100_PQ_OETF::GetDOD(HgcBT2100_PQ_OETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBT2100_PQ_OETF::GetROI(HgcBT2100_PQ_OETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBT2100_PQ_OETF::HgcBT2100_PQ_OETF(HgcBT2100_PQ_OETF *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6549490;
  v3 = operator new();
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 64) = xmmword_1B3051560;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051600;
  *(_OWORD *)(v3 + 96) = xmmword_1B3051610;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051620;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051630;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051640;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051510;
  *(_OWORD *)(v3 + 176) = xmmword_1B3525860;
  *(_OWORD *)(v3 + 192) = xmmword_1B3525870;
  *(_OWORD *)(v3 + 208) = xmmword_1B3525880;
  *(_OWORD *)(v3 + 224) = xmmword_1B3525890;
  *(_OWORD *)(v3 + 240) = xmmword_1B35258A0;
  *(_OWORD *)(v3 + 256) = xmmword_1B35258B0;
  *(_OWORD *)(v3 + 272) = xmmword_1B35258C0;
  *(_OWORD *)(v3 + 288) = xmmword_1B3051690;
  *(_OWORD *)(v3 + 304) = xmmword_1B35258D0;
  *(_OWORD *)(v3 + 320) = xmmword_1B35258E0;
  *(_OWORD *)(v3 + 336) = xmmword_1B35258F0;
  *(_OWORD *)(v3 + 352) = xmmword_1B3525900;
  *(_OWORD *)(v3 + 368) = xmmword_1B3525910;
  *(_OWORD *)(v3 + 384) = xmmword_1B30516D0;
  *(_OWORD *)(v3 + 400) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 416) = xmmword_1B3052320;
  *(int32x4_t *)(v3 + 432) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BEBC24(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_PQ_OETF::~HgcBT2100_PQ_OETF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6549490;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40502CBA4ALL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6549490;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40502CBA4ALL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_PQ_OETF::SetParameter(HgcBT2100_PQ_OETF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_PQ_OETF::GetParameter(HgcBT2100_PQ_OETF *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_PQ_OETF_qtApprox::GetProgram(HgcBT2100_PQ_OETF_qtApprox *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003ae\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r0.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz*half3(hg_Params[1].zzz) + c0.yyy;\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[1].yyy) + half3(hg_Params[1].xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    output.color0.xyz = pow(float3(r0.xyz), hg_Params[0].yyy);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=2444afad:3db4a253:10709704:a6232534\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000037f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r0.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz*hg_Params[1].zzz + c0.yyy;\n"
             "    r1.xyz = r1.xyz*hg_Params[1].yyy + hg_Params[1].xxx;\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    output.color0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=81f92e6d:ccf1bbeb:6804da4c:060ade07\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000379\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r0.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz*hg_ProgramLocal1.zzz + c0.yyy;\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal1.yyy + hg_ProgramLocal1.xxx;\n"
           "    r0.xyz = r1.xyz/r0.xyz;\n"
           "    gl_FragColor.xyz = pow(r0.xyz, hg_ProgramLocal0.yyy);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=5ec190f3:0ef06f06:f7c965f7:c1522525\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_PQ_OETF_qtApprox::InitProgramDescriptor(HgcBT2100_PQ_OETF_qtApprox *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_PQ_OETF_qtApprox_hgc_visible", "//Metal1.0     \n//LEN=0000000263\n[[ visible ]] FragmentOut HgcBT2100_PQ_OETF_qtApprox_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r0.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = r1.xyz*hg_Params[1].zzz + c0.yyy;\n"
    "    r1.xyz = r1.xyz*hg_Params[1].yyy + hg_Params[1].xxx;\n"
    "    r0.xyz = r1.xyz/r0.xyz;\n"
    "    output.color0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BEC038(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BEC068(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BEC060);
}

char *HgcBT2100_PQ_OETF_qtApprox::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D20;
  strcpy(result, "HgcBT2100_PQ_OETF_qtApprox [hgc1]");
  return result;
}

uint64_t HgcBT2100_PQ_OETF_qtApprox::BindTexture(HgcBT2100_PQ_OETF_qtApprox *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_PQ_OETF_qtApprox::Bind(HgcBT2100_PQ_OETF_qtApprox *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcBT2100_PQ_OETF_qtApprox *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBT2100_PQ_OETF_qtApprox::RenderTile(HgcBT2100_PQ_OETF_qtApprox *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  _OWORD *v11;
  float32x4_t v12;
  int8x16_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int32x4_t v57;
  int32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int8x16_t v62;
  int8x16_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int8x16_t v75;
  int8x16_t v76;
  int8x16_t v77;
  int8x16_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  int8x16_t v99;
  int8x16_t *v100;
  int v101;
  uint64_t v102;
  float32x4_t v103;
  _OWORD *v104;
  int8x16_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  int8x16_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  int8x16_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  int32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v101 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v11 = (_OWORD *)*((_QWORD *)this + 51);
      v12 = *((float32x4_t *)v11 + 2);
      v13 = *((int8x16_t *)v11 + 3);
      v14 = *(float32x4_t *)(v6 + v10);
      v15 = *((float32x4_t *)v11 + 1);
      v158 = v12;
      v16 = *((float32x4_t *)v11 + 4);
      v17 = *((int8x16_t *)v11 + 5);
      v18 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11, 0), v158)), v158);
      v19 = (float32x4_t)vbslq_s8(v18, (int8x16_t)v16, vbslq_s8(v13, *(int8x16_t *)(v6 + v10 - 16), (int8x16_t)vmaxq_f32(*(float32x4_t *)(v6 + v10 - 16), v12)));
      v20 = (float32x4_t)vbslq_s8(v18, (int8x16_t)v16, vbslq_s8(v13, (int8x16_t)v14, (int8x16_t)vmaxq_f32(v14, v12)));
      v21 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v19, v17), (int8x16_t)v16);
      v23 = *((float32x4_t *)v11 + 6);
      v22 = *((int8x16_t *)v11 + 7);
      v24 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v20, v17), (int8x16_t)v16);
      v26 = *((float32x4_t *)v11 + 8);
      v25 = *((float32x4_t *)v11 + 9);
      v27 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v21, v25));
      v28 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v24, v25));
      v29 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v23, v19))), v26), v27);
      v30 = *((float32x4_t *)v11 + 10);
      v160 = *((float32x4_t *)v11 + 11);
      v31 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v23, v20))), v26), v28);
      v32 = vsubq_f32(vsubq_f32(v21, v16), vmulq_f32(vmulq_f32(v30, v27), v21));
      v33 = vsubq_f32(vsubq_f32(v24, v16), vmulq_f32(vmulq_f32(v30, v28), v24));
      v34 = vmulq_f32(v32, v32);
      v35 = vmulq_f32(v33, v33);
      v37 = *((float32x4_t *)v11 + 12);
      v36 = *((float32x4_t *)v11 + 13);
      v39 = *((float32x4_t *)v11 + 14);
      v38 = *((float32x4_t *)v11 + 15);
      v41 = *((float32x4_t *)v11 + 16);
      v40 = *((float32x4_t *)v11 + 17);
      v42 = vaddq_f32(v31, vmulq_f32(v33, vaddq_f32(v40, vmulq_f32(v33, vaddq_f32(vaddq_f32(v38, vmulq_f32(v33, v41)), vmulq_f32(v35, vaddq_f32(vaddq_f32(v160, vmulq_f32(v37, v33)), vmulq_f32(v35, vaddq_f32(v36, vmulq_f32(v39, v33))))))))));
      v43 = *((float32x4_t *)v11 + 18);
      v159 = *((float32x4_t *)v11 + 19);
      v44 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v29, vmulq_f32(v32, vaddq_f32(v40, vmulq_f32(v32, vaddq_f32(vaddq_f32(v38, vmulq_f32(v32, v41)), vmulq_f32(v34, vaddq_f32(vaddq_f32(v160, vmulq_f32(v37, v32)), vmulq_f32(v34, vaddq_f32(v36, vmulq_f32(v39, v32)))))))))), COERCE_FLOAT(*v11)), v43);
      v45 = vmaxq_f32(vmulq_n_f32(v42, COERCE_FLOAT(*v11)), v43);
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      v48 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v46, v44)));
      v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v47, v45)));
      v50 = vsubq_f32(v44, v48);
      v51 = vsubq_f32(v45, v49);
      v53 = *((float32x4_t *)v11 + 20);
      v52 = *((float32x4_t *)v11 + 21);
      v55 = *((float32x4_t *)v11 + 22);
      v54 = *((float32x4_t *)v11 + 23);
      v56 = vmulq_f32(v51, vaddq_f32(v54, vmulq_f32(v51, vaddq_f32(vaddq_f32(v52, vmulq_f32(v55, v51)), vmulq_f32(vmulq_f32(v51, v51), vaddq_f32(v159, vmulq_f32(v53, v51)))))));
      v57 = vcvtq_s32_f32(v48);
      v58 = *((int32x4_t *)v11 + 24);
      v59 = *((float32x4_t *)v11 + 25);
      v60 = vmulq_f32(vaddq_f32(v16, vmulq_f32(v50, vaddq_f32(v54, vmulq_f32(v50, vaddq_f32(vaddq_f32(v52, vmulq_f32(v50, v55)), vmulq_f32(vmulq_f32(v50, v50), vaddq_f32(v159, vmulq_f32(v53, v50)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v58, v57), 0x17uLL));
      v61 = vmulq_f32(vaddq_f32(v16, v56), (float32x4_t)vshlq_n_s32(vaddq_s32(v58, vcvtq_s32_f32(v49)), 0x17uLL));
      v62 = *(int8x16_t *)(v6 + v10 - 16);
      v63 = v13;
      v64 = (float32x4_t)vbslq_s8(v13, v62, (int8x16_t)vaddq_f32(v16, vmulq_laneq_f32(v60, v15, 2)));
      v65 = *((float32x4_t *)v11 + 26);
      v66 = vminq_f32(vmaxq_f32(vrecpeq_f32(v64), v59), v65);
      v67 = vmulq_f32(v66, vrecpsq_f32(v64, v66));
      v68 = (float32x4_t)vbslq_s8(v13, (int8x16_t)v14, (int8x16_t)vaddq_f32(v16, vmulq_laneq_f32(v61, v15, 2)));
      v69 = vminq_f32(vmaxq_f32(vrecpeq_f32(v68), v59), v65);
      v70 = vmulq_lane_f32(v60, *(float32x2_t *)v15.f32, 1);
      v71 = vmulq_lane_f32(v61, *(float32x2_t *)v15.f32, 1);
      v72 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 0);
      v73 = vminq_f32(vmaxq_f32(v67, v59), v65);
      v74 = vminq_f32(vmaxq_f32(vmulq_f32(v69, vrecpsq_f32(v68, v69)), v59), v65);
      v75 = (int8x16_t)vmulq_f32(vaddq_f32(v72, v71), vmulq_f32(v74, vrecpsq_f32(v68, v74)));
      v76 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11, 1), v158)), v158);
      v77 = vbslq_s8(v63, v62, (int8x16_t)vmulq_f32(vaddq_f32(v72, v70), vmulq_f32(v73, vrecpsq_f32(v64, v73))));
      v78 = *((int8x16_t *)v11 + 3);
      v79 = (float32x4_t)vbslq_s8(v76, (int8x16_t)v16, v77);
      v80 = (float32x4_t)vbslq_s8(v76, (int8x16_t)v16, vbslq_s8(v63, *(int8x16_t *)(v6 + v10), v75));
      v81 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v79, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v23, v79)));
      v82 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v79, v17), (int8x16_t)v16);
      v83 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v80, v17), (int8x16_t)v16);
      v84 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v82, v25));
      v85 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v83, v25));
      v86 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v80, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v23, v80))), v26), v85);
      v87 = vsubq_f32(vsubq_f32(v82, v16), vmulq_f32(vmulq_f32(v30, v84), v82));
      v88 = vsubq_f32(vsubq_f32(v83, v16), vmulq_f32(vmulq_f32(v30, v85), v83));
      v89 = vmulq_f32(v87, v87);
      v90 = vmulq_f32(v88, v88);
      v91 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(v81, v26), v84), vmulq_f32(v87, vaddq_f32(v40, vmulq_f32(v87, vaddq_f32(vaddq_f32(v38, vmulq_f32(v41, v87)), vmulq_f32(v89, vaddq_f32(vaddq_f32(v160, vmulq_f32(v37, v87)), vmulq_f32(v89, vaddq_f32(v36, vmulq_f32(v39, v87)))))))))), *(float32x2_t *)v11, 1), v43);
      v92 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v86, vmulq_f32(v88, vaddq_f32(v40, vmulq_f32(v88, vaddq_f32(vaddq_f32(v38, vmulq_f32(v41, v88)), vmulq_f32(v90, vaddq_f32(vaddq_f32(v160, vmulq_f32(v37, v88)), vmulq_f32(v90, vaddq_f32(v36, vmulq_f32(v39, v88)))))))))), *(float32x2_t *)v11, 1), v43);
      v93 = vcvtq_f32_s32(vcvtq_s32_f32(v91));
      v94 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
      v95 = vsubq_f32(v93, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v93, v91)));
      v96 = vsubq_f32(v94, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v94, v92)));
      v97 = vsubq_f32(v91, v95);
      v98 = vsubq_f32(v92, v96);
      v99 = vbslq_s8(v78, *(int8x16_t *)(v6 + v10), (int8x16_t)vmulq_f32(vaddq_f32(v16, vmulq_f32(v98, vaddq_f32(v54, vmulq_f32(v98, vaddq_f32(vaddq_f32(v52, vmulq_f32(v55, v98)), vmulq_f32(vmulq_f32(v98, v98), vaddq_f32(v159, vmulq_f32(v53, v98)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v96), v58), 0x17uLL)));
      v100 = (int8x16_t *)(v5 + v10);
      v100[-1] = vbslq_s8(v78, v62, (int8x16_t)vmulq_f32(vaddq_f32(v16, vmulq_f32(v97, vaddq_f32(v54, vmulq_f32(v97, vaddq_f32(vaddq_f32(v52, vmulq_f32(v55, v97)), vmulq_f32(vmulq_f32(v97, v97), vaddq_f32(v159, vmulq_f32(v53, v97)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v95), v58), 0x17uLL)));
      *v100 = v99;
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v101 = -v9;
    if (v101 >= v4)
      goto LABEL_3;
LABEL_10:
    v102 = 16 * v101;
    v103 = *(float32x4_t *)(v6 + v102);
    v104 = (_OWORD *)*((_QWORD *)this + 51);
    v106 = *((float32x4_t *)v104 + 2);
    v105 = *((int8x16_t *)v104 + 3);
    v107 = *((float32x4_t *)v104 + 1);
    v108 = *((float32x4_t *)v104 + 4);
    v109 = *((int8x16_t *)v104 + 5);
    v110 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v108, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v104, 0), v106)), v106), (int8x16_t)v108, vbslq_s8(v105, (int8x16_t)v103, (int8x16_t)vmaxq_f32(v103, v106)));
    v111 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v110, v109), (int8x16_t)v108);
    v112 = *((float32x4_t *)v104 + 6);
    v113 = *((int8x16_t *)v104 + 7);
    v114 = *((float32x4_t *)v104 + 8);
    v115 = *((float32x4_t *)v104 + 9);
    v116 = (float32x4_t)vandq_s8((int8x16_t)v108, (int8x16_t)vcgtq_f32(v111, v115));
    v117 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v110, 0x17uLL)), (float32x4_t)vandq_s8(v113, (int8x16_t)vcgtq_f32(v112, v110))), v114), v116);
    v118 = *((float32x4_t *)v104 + 10);
    v119 = *((float32x4_t *)v104 + 11);
    v120 = vsubq_f32(vsubq_f32(v111, v108), vmulq_f32(vmulq_f32(v118, v116), v111));
    v121 = vmulq_f32(v120, v120);
    v122 = *((float32x4_t *)v104 + 12);
    v123 = *((float32x4_t *)v104 + 13);
    v124 = *((float32x4_t *)v104 + 14);
    v125 = *((float32x4_t *)v104 + 15);
    v126 = *((float32x4_t *)v104 + 16);
    v127 = *((float32x4_t *)v104 + 17);
    v128 = vmulq_n_f32(vaddq_f32(v117, vmulq_f32(v120, vaddq_f32(v127, vmulq_f32(v120, vaddq_f32(vaddq_f32(v125, vmulq_f32(v120, v126)), vmulq_f32(v121, vaddq_f32(vaddq_f32(v119, vmulq_f32(v122, v120)), vmulq_f32(v121, vaddq_f32(v123, vmulq_f32(v124, v120)))))))))), COERCE_FLOAT(*v104));
    v129 = *((float32x4_t *)v104 + 18);
    v130 = *((float32x4_t *)v104 + 19);
    v131 = vmaxq_f32(v128, v129);
    v132 = vcvtq_f32_s32(vcvtq_s32_f32(v131));
    v133 = vsubq_f32(v132, (float32x4_t)vandq_s8((int8x16_t)v108, (int8x16_t)vcgtq_f32(v132, v131)));
    v134 = vsubq_f32(v131, v133);
    v135 = *((float32x4_t *)v104 + 20);
    v136 = *((float32x4_t *)v104 + 21);
    v137 = *((float32x4_t *)v104 + 22);
    v138 = *((float32x4_t *)v104 + 23);
    v140 = *((int32x4_t *)v104 + 24);
    v139 = *((float32x4_t *)v104 + 25);
    v141 = vmulq_f32(vaddq_f32(v108, vmulq_f32(v134, vaddq_f32(v138, vmulq_f32(v134, vaddq_f32(vaddq_f32(v136, vmulq_f32(v137, v134)), vmulq_f32(vmulq_f32(v134, v134), vaddq_f32(v130, vmulq_f32(v135, v134)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v140, vcvtq_s32_f32(v133)), 0x17uLL));
    v142 = (float32x4_t)vbslq_s8(v105, (int8x16_t)v103, (int8x16_t)vaddq_f32(v108, vmulq_laneq_f32(v141, v107, 2)));
    v143 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v107.f32, 0), vmulq_lane_f32(v141, *(float32x2_t *)v107.f32, 1));
    v144 = *((float32x4_t *)v104 + 26);
    v145 = vminq_f32(vmaxq_f32(vrecpeq_f32(v142), v139), v144);
    v146 = vminq_f32(vmaxq_f32(vmulq_f32(v145, vrecpsq_f32(v142, v145)), v139), v144);
    v147 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v108, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v104, 1), v106)), v106), (int8x16_t)v108, vbslq_s8(v105, (int8x16_t)v103, (int8x16_t)vmulq_f32(v143, vmulq_f32(v146, vrecpsq_f32(v142, v146)))));
    v148 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v147, v109), (int8x16_t)v108);
    v149 = (float32x4_t)vandq_s8((int8x16_t)v108, (int8x16_t)vcgtq_f32(v148, v115));
    v150 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v147, 0x17uLL)), (float32x4_t)vandq_s8(v113, (int8x16_t)vcgtq_f32(v112, v147))), v114), v149);
    v151 = vsubq_f32(vsubq_f32(v148, v108), vmulq_f32(vmulq_f32(v118, v149), v148));
    v152 = vmulq_f32(v151, v151);
    v153 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v150, vmulq_f32(v151, vaddq_f32(v127, vmulq_f32(v151, vaddq_f32(vaddq_f32(v125, vmulq_f32(v126, v151)), vmulq_f32(v152, vaddq_f32(vaddq_f32(v119, vmulq_f32(v122, v151)), vmulq_f32(v152, vaddq_f32(v123, vmulq_f32(v124, v151)))))))))), *(float32x2_t *)v104, 1), v129);
    v154 = vcvtq_f32_s32(vcvtq_s32_f32(v153));
    v155 = vsubq_f32(v154, (float32x4_t)vandq_s8((int8x16_t)v108, (int8x16_t)vcgtq_f32(v154, v153)));
    v156 = vsubq_f32(v153, v155);
    *(int8x16_t *)(v5 + v102) = vbslq_s8(v105, (int8x16_t)v103, (int8x16_t)vmulq_f32(vaddq_f32(v108, vmulq_f32(v156, vaddq_f32(v138, vmulq_f32(v156, vaddq_f32(vaddq_f32(v136, vmulq_f32(v137, v156)), vmulq_f32(vmulq_f32(v156, v156), vaddq_f32(v130, vmulq_f32(v135, v156)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v155), v140), 0x17uLL)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2100_PQ_OETF_qtApprox::GetDOD(HgcBT2100_PQ_OETF_qtApprox *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBT2100_PQ_OETF_qtApprox::GetROI(HgcBT2100_PQ_OETF_qtApprox *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBT2100_PQ_OETF_qtApprox::HgcBT2100_PQ_OETF_qtApprox(HgcBT2100_PQ_OETF_qtApprox *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65496F8;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = xmmword_1B30536D0;
  *(_OWORD *)(v3 + 48) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 64) = xmmword_1B3051560;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051600;
  *(_OWORD *)(v3 + 96) = xmmword_1B3051610;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051620;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051630;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051640;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051510;
  *(_OWORD *)(v3 + 176) = xmmword_1B3525860;
  *(_OWORD *)(v3 + 192) = xmmword_1B3525870;
  *(_OWORD *)(v3 + 208) = xmmword_1B3525880;
  *(_OWORD *)(v3 + 224) = xmmword_1B3525890;
  *(_OWORD *)(v3 + 240) = xmmword_1B35258A0;
  *(_OWORD *)(v3 + 256) = xmmword_1B35258B0;
  *(_OWORD *)(v3 + 272) = xmmword_1B35258C0;
  *(_OWORD *)(v3 + 288) = xmmword_1B3051690;
  *(_OWORD *)(v3 + 304) = xmmword_1B35258D0;
  *(_OWORD *)(v3 + 320) = xmmword_1B35258E0;
  *(_OWORD *)(v3 + 336) = xmmword_1B35258F0;
  *(_OWORD *)(v3 + 352) = xmmword_1B3525900;
  *(_OWORD *)(v3 + 368) = xmmword_1B3525910;
  *(_OWORD *)(v3 + 384) = xmmword_1B30516D0;
  *(_OWORD *)(v3 + 400) = xmmword_1B3052320;
  *(int32x4_t *)(v3 + 416) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BECB74(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_PQ_OETF_qtApprox::~HgcBT2100_PQ_OETF_qtApprox(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65496F8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4003455651);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65496F8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4003455651);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_PQ_OETF_qtApprox::SetParameter(HgcBT2100_PQ_OETF_qtApprox *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_PQ_OETF_qtApprox::GetParameter(HgcBT2100_PQ_OETF_qtApprox *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_PQ_InverseOETF::GetProgram(HgcBT2100_PQ_InverseOETF *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000508\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = clamp(r0.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[1].yyy));\n"
             "    r1.xyz = r0.xyz - half3(hg_Params[0].xxx);\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].zzz) + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    r1.xyz = pow(r0.xyz, half3(hg_Params[1].xxx));\n"
             "    r0.xyz = r1.xyz*half3(hg_Params[2].xxx) + half3(hg_Params[2].yyy);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[2].zzz);\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[1].zzz));\n"
             "    r1.xyz = half3(half3(hg_Params[2].www) < r1.xyz);\n"
             "    output.color0.xyz = select(float3(r2.xyz), float3(r0.xyz), -float3(r1.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1b378797:123e3885:5939c817:bd9b6770\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004a0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = clamp(r0.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
             "    r1.xyz = r0.xyz - hg_Params[0].xxx;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].zzz + hg_Params[0].yyy;\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    r1.xyz = pow(r0.xyz, hg_Params[1].xxx);\n"
             "    r0.xyz = r1.xyz*hg_Params[2].xxx + hg_Params[2].yyy;\n"
             "    r2.xyz = r1.xyz*hg_Params[2].zzz;\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[1].zzz);\n"
             "    r1.xyz = float3(hg_Params[2].www < r1.xyz);\n"
             "    output.color0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=a07f4f72:4373c56a:f9551245:ece12833\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000051b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = clamp(r0.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal1.yyy);\n"
           "    r1.xyz = r0.xyz - hg_ProgramLocal0.xxx;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.zzz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r0.xyz = r1.xyz/r0.xyz;\n"
           "    r1.xyz = pow(r0.xyz, hg_ProgramLocal1.xxx);\n"
           "    r0.xyz = r1.xyz*hg_ProgramLocal2.xxx + hg_ProgramLocal2.yyy;\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal2.zzz;\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal1.zzz);\n"
           "    r1.xyz = vec3(lessThan(hg_ProgramLocal2.www, r1.xyz));\n"
           "    gl_FragColor.xyz = vec3(-r1.x < 0.00000 ? r0.x : r2.x, -r1.y < 0.00000 ? r0.y : r2.y, -r1.z < 0.00000 ? r"
           "0.z : r2.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=4c6efd1c:68a5dad6:d015ee40:c1eec704\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_PQ_InverseOETF::InitProgramDescriptor(HgcBT2100_PQ_InverseOETF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_PQ_InverseOETF_hgc_visible", "//Metal1.0     \n//LEN=0000000382\n[[ visible ]] FragmentOut HgcBT2100_PQ_InverseOETF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = clamp(r0.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
    "    r1.xyz = r0.xyz - hg_Params[0].xxx;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].zzz + hg_Params[0].yyy;\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r0.xyz = r1.xyz/r0.xyz;\n"
    "    r1.xyz = pow(r0.xyz, hg_Params[1].xxx);\n"
    "    r0.xyz = r1.xyz*hg_Params[2].xxx + hg_Params[2].yyy;\n"
    "    r2.xyz = r1.xyz*hg_Params[2].zzz;\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[1].zzz);\n"
    "    r1.xyz = float3(hg_Params[2].www < r1.xyz);\n"
    "    output.color0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BECF88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BECFB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BECFB0);
}

double HgcBT2100_PQ_InverseOETF::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A60;
  strcpy(v3, "HgcBT2100_PQ_InverseOETF [hgc1]");
  return *(double *)"verseOETF [hgc1]";
}

uint64_t HgcBT2100_PQ_InverseOETF::BindTexture(HgcBT2100_PQ_InverseOETF *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_PQ_InverseOETF::Bind(HgcBT2100_PQ_InverseOETF *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HgcBT2100_PQ_InverseOETF *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBT2100_PQ_InverseOETF::RenderTile(HgcBT2100_PQ_InverseOETF *this, HGTile *a2)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  int8x16_t v16;
  float32x4_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int32x4_t v47;
  int32x4_t v48;
  int8x16_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
  {
    v3 = 0;
    v4 = *((_QWORD *)a2 + 10);
    v5 = 16 * *((int *)a2 + 22);
    v6 = *((_QWORD *)a2 + 2);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    do
    {
      v9 = 0;
      do
      {
        v10 = *((_QWORD *)this + 51);
        v11 = *(float32x4_t *)(v10 + 16);
        v13 = *(float32x4_t *)(v10 + 32);
        v12 = *(float32x4_t *)(v10 + 48);
        v14 = *(float32x4_t *)(v10 + 64);
        v15 = *(int8x16_t *)(v10 + 80);
        v16 = (int8x16_t)vminq_f32(vmaxq_f32(*(float32x4_t *)(v4 + v9), v12), v14);
        v17 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1), v12)), v12), (int8x16_t)v14, v16);
        v19 = *(float32x4_t *)(v10 + 96);
        v18 = *(int8x16_t *)(v10 + 112);
        v20 = (float32x4_t)vorrq_s8(vandq_s8(v15, (int8x16_t)v17), (int8x16_t)v14);
        v21 = *(float32x4_t *)(v10 + 128);
        v22 = *(float32x4_t *)(v10 + 144);
        v23 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v18, (int8x16_t)vcgtq_f32(v19, v17)));
        v24 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v20, v22));
        v26 = *(float32x4_t *)(v10 + 160);
        v25 = *(float32x4_t *)(v10 + 176);
        v27 = vsubq_f32(vsubq_f32(v20, v14), vmulq_f32(vmulq_f32(v26, v24), v20));
        v29 = *(float32x4_t *)(v10 + 192);
        v28 = *(float32x4_t *)(v10 + 208);
        v30 = vmulq_f32(v27, v27);
        v32 = *(float32x4_t *)(v10 + 224);
        v31 = *(float32x4_t *)(v10 + 240);
        v34 = *(float32x4_t *)(v10 + 256);
        v33 = *(float32x4_t *)(v10 + 272);
        v35 = vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(v23, v21), v24), vmulq_f32(v27, vaddq_f32(v33, vmulq_f32(v27, vaddq_f32(vaddq_f32(v31, vmulq_f32(v34, v27)), vmulq_f32(v30, vaddq_f32(vaddq_f32(v25, vmulq_f32(v29, v27)), vmulq_f32(v30, vaddq_f32(v28, vmulq_f32(v32, v27)))))))))), *(float32x2_t *)v11.f32, 1);
        v37 = *(float32x4_t *)(v10 + 288);
        v36 = *(float32x4_t *)(v10 + 304);
        v38 = vmaxq_f32(v35, v37);
        v39 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
        v40 = vsubq_f32(v39, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v39, v38)));
        v41 = vsubq_f32(v38, v40);
        v42 = *(float32x4_t *)(v10 + 320);
        v43 = *(float32x4_t *)(v10 + 336);
        v44 = *(float32x4_t *)(v10 + 352);
        v45 = *(float32x4_t *)(v10 + 368);
        v46 = vmulq_f32(v41, vaddq_f32(v45, vmulq_f32(v41, vaddq_f32(vaddq_f32(v43, vmulq_f32(v44, v41)), vmulq_f32(vmulq_f32(v41, v41), vaddq_f32(v36, vmulq_f32(v42, v41)))))));
        v47 = vcvtq_s32_f32(v40);
        v48 = *(int32x4_t *)(v10 + 384);
        v49 = *(int8x16_t *)(v10 + 400);
        v50 = (float32x4_t)vbslq_s8(v49, v16, (int8x16_t)vmulq_f32(vaddq_f32(v14, v46), (float32x4_t)vshlq_n_s32(vaddq_s32(v48, v47), 0x17uLL)));
        v51 = (float32x4_t)vbslq_s8(v49, v16, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10, 1), vmulq_laneq_f32(v50, *(float32x4_t *)v10, 2)));
        v52 = *(float32x4_t *)(v10 + 416);
        v53 = *(float32x4_t *)(v10 + 432);
        v54 = vminq_f32(vmaxq_f32(vrecpeq_f32(v51), v52), v53);
        v55 = vminq_f32(vmaxq_f32(vmulq_f32(v54, vrecpsq_f32(v51, v54)), v52), v53);
        v56 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 0), v12)), v12), (int8x16_t)v14, vbslq_s8(v49, v16, (int8x16_t)vmulq_f32(vmaxq_f32(vsubq_f32(v50, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10, 0)), v12), vmulq_f32(v55, vrecpsq_f32(v51, v55)))));
        v57 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v56, v15), (int8x16_t)v14);
        v58 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v57, v22));
        v59 = vsubq_f32(vsubq_f32(v57, v14), vmulq_f32(vmulq_f32(v26, v58), v57));
        v60 = vmulq_f32(v59, v59);
        v61 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v56, 0x17uLL)), (float32x4_t)vandq_s8(v18, (int8x16_t)vcgtq_f32(v19, v56))), v21), v58), vmulq_f32(v59, vaddq_f32(v33, vmulq_f32(v59, vaddq_f32(vaddq_f32(v31, vmulq_f32(v34, v59)), vmulq_f32(v60,
                              vaddq_f32(vaddq_f32(v25, vmulq_f32(v29, v59)), vmulq_f32(v60, vaddq_f32(v28, vmulq_f32(v32, v59)))))))))), v11.f32[0]), v37);
        v62 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
        v63 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v62, v61)));
        v64 = vsubq_f32(v61, v63);
        v65 = vmulq_f32(vaddq_f32(v14, vmulq_f32(v64, vaddq_f32(v45, vmulq_f32(v64, vaddq_f32(vaddq_f32(v43, vmulq_f32(v44, v64)), vmulq_f32(vmulq_f32(v64, v64), vaddq_f32(v36, vmulq_f32(v42, v64)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v63), v48), 0x17uLL));
        v66 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vceqq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), v12)), v12), (int8x16_t)v14, vbslq_s8(v49, v16, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1), vmulq_n_f32(v65, v13.f32[0]))));
        v67 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v66, v15), (int8x16_t)v14);
        v68 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v66, 0x17uLL)), (float32x4_t)vandq_s8(v18, (int8x16_t)vcgtq_f32(v19, v66))), v21);
        v69 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v67, v22));
        v70 = vsubq_f32(vsubq_f32(v67, v14), vmulq_f32(vmulq_f32(v26, v69), v67));
        v71 = vmulq_f32(v70, v70);
        v72 = vmaxq_f32(vmulq_laneq_f32(vaddq_f32(vaddq_f32(v68, v69), vmulq_f32(v70, vaddq_f32(v33, vmulq_f32(v70, vaddq_f32(vaddq_f32(v31, vmulq_f32(v34, v70)), vmulq_f32(v71, vaddq_f32(vaddq_f32(v25, vmulq_f32(v29, v70)), vmulq_f32(v71, vaddq_f32(v28, vmulq_f32(v32, v70)))))))))), v11, 2), v37);
        v73 = vcvtq_f32_s32(vcvtq_s32_f32(v72));
        v74 = vsubq_f32(v73, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v73, v72)));
        v75 = vsubq_f32(v72, v74);
        *(int8x16_t *)(v6 + v9) = vbslq_s8(v49, v16, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v65, (float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3))), v12), vbslq_s8(v49, v16, (int8x16_t)vmulq_f32(vaddq_f32(v14, vmulq_f32(
                                                         v75,
                                                         vaddq_f32(v45, vmulq_f32(v75, vaddq_f32(vaddq_f32(v43, vmulq_f32(v44, v75)), vmulq_f32(vmulq_f32(v75, v75), vaddq_f32(v36, vmulq_f32(v42, v75)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v74), v48), 0x17uLL))), (int8x16_t)vmulq_laneq_f32(v65, v13, 2)));
        v9 += 16;
      }
      while (v8 != v9);
      ++v3;
      v4 += v5;
      v6 += v7;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcBT2100_PQ_InverseOETF::GetDOD(HgcBT2100_PQ_InverseOETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBT2100_PQ_InverseOETF::GetROI(HgcBT2100_PQ_InverseOETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBT2100_PQ_InverseOETF::HgcBT2100_PQ_InverseOETF(HgcBT2100_PQ_InverseOETF *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6549960;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = xmmword_1B30536D0;
  *(_OWORD *)(v3 + 64) = xmmword_1B3525D80;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051600;
  *(_OWORD *)(v3 + 96) = xmmword_1B3051610;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051620;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051630;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051640;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051510;
  *(_OWORD *)(v3 + 176) = xmmword_1B3525860;
  *(_OWORD *)(v3 + 192) = xmmword_1B3525870;
  *(_OWORD *)(v3 + 208) = xmmword_1B3525880;
  *(_OWORD *)(v3 + 224) = xmmword_1B3525890;
  *(_OWORD *)(v3 + 240) = xmmword_1B35258A0;
  *(_OWORD *)(v3 + 256) = xmmword_1B35258B0;
  *(_OWORD *)(v3 + 272) = xmmword_1B35258C0;
  *(_OWORD *)(v3 + 288) = xmmword_1B3051690;
  *(_OWORD *)(v3 + 304) = xmmword_1B35258D0;
  *(_OWORD *)(v3 + 320) = xmmword_1B35258E0;
  *(_OWORD *)(v3 + 336) = xmmword_1B35258F0;
  *(_OWORD *)(v3 + 352) = xmmword_1B3525900;
  *(_OWORD *)(v3 + 368) = xmmword_1B3525910;
  *(_OWORD *)(v3 + 384) = xmmword_1B30516D0;
  *(_OWORD *)(v3 + 400) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 416) = xmmword_1B3052320;
  *(int32x4_t *)(v3 + 432) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BED70C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_PQ_InverseOETF::~HgcBT2100_PQ_InverseOETF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6549960;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40502CBA4ALL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6549960;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40502CBA4ALL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_PQ_InverseOETF::SetParameter(HgcBT2100_PQ_InverseOETF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_PQ_InverseOETF::GetParameter(HgcBT2100_PQ_InverseOETF *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_PQ_InverseOETF_qtApprox::GetProgram(HgcBT2100_PQ_InverseOETF_qtApprox *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000404\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = clamp(r0.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[1].yyy));\n"
             "    r1.xyz = r0.xyz - half3(hg_Params[0].xxx);\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].zzz) + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[1].xxx));\n"
             "    output.color0.xyz = float3(r0.xyz)*hg_Params[1].zzz;\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c51a250f:d66e2ef0:88aa222a:e56ce852\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003ce\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = clamp(r0.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
             "    r1.xyz = r0.xyz - hg_Params[0].xxx;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].zzz + hg_Params[0].yyy;\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[1].xxx);\n"
             "    output.color0.xyz = r0.xyz*hg_Params[1].zzz;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f22f319c:ea07886b:9fc4354b:118627e0\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d6\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = clamp(r0.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal1.yyy);\n"
           "    r1.xyz = r0.xyz - hg_ProgramLocal0.xxx;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.zzz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r0.xyz = r1.xyz/r0.xyz;\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal1.xxx);\n"
           "    gl_FragColor.xyz = r0.xyz*hg_ProgramLocal1.zzz;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=5e7cd0eb:313d5ea6:0c763ff4:65122675\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_PQ_InverseOETF_qtApprox::InitProgramDescriptor(HgcBT2100_PQ_InverseOETF_qtApprox *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_PQ_InverseOETF_qtApprox_hgc_visible", "//Metal1.0     \n//LEN=00000002b9\n[[ visible ]] FragmentOut HgcBT2100_PQ_InverseOETF_qtApprox_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = clamp(r0.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
    "    r1.xyz = r0.xyz - hg_Params[0].xxx;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].zzz + hg_Params[0].yyy;\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r0.xyz = r1.xyz/r0.xyz;\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[1].xxx);\n"
    "    output.color0.xyz = r0.xyz*hg_Params[1].zzz;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BEDB20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BEDB50(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BEDB48);
}

char *HgcBT2100_PQ_InverseOETF_qtApprox::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x30uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A90;
  strcpy(result, "HgcBT2100_PQ_InverseOETF_qtApprox [hgc1]");
  return result;
}

uint64_t HgcBT2100_PQ_InverseOETF_qtApprox::BindTexture(HgcBT2100_PQ_InverseOETF_qtApprox *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_PQ_InverseOETF_qtApprox::Bind(HgcBT2100_PQ_InverseOETF_qtApprox *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcBT2100_PQ_InverseOETF_qtApprox *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBT2100_PQ_InverseOETF_qtApprox::RenderTile(HgcBT2100_PQ_InverseOETF_qtApprox *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  int8x16_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int32x4_t v58;
  float32x4_t v59;
  int8x16_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x16_t v64;
  int8x16_t v65;
  float32x4_t v66;
  float32x4_t v67;
  int8x16_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  int8x16_t v79;
  int8x16_t v80;
  int8x16_t v81;
  int8x16_t v82;
  int8x16_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  int8x16_t *v107;
  int v108;
  uint64_t v109;
  uint64_t v110;
  float32x4_t v111;
  float32x4_t v112;
  int8x16_t v113;
  float32x4_t v114;
  float32x4_t v115;
  int8x16_t v116;
  float32x4_t v117;
  float32x4_t v118;
  int8x16_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  int32x4_t v144;
  float32x4_t v145;
  int8x16_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v163;
  int8x16_t v164;
  float32x4_t v165;
  float32x4_t v166;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v108 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v11 = *((_QWORD *)this + 51);
      v13 = *(float32x4_t *)(v11 + 32);
      v12 = *(float32x4_t *)(v11 + 48);
      v14 = (int8x16_t)vminq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v10 - 16), v13), v12);
      v15 = *(float32x4_t *)(v11 + 16);
      v16 = (int8x16_t)vminq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v10), v13), v12);
      v165 = v13;
      v17 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1), v13)), v13);
      v18 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v12, v14);
      v19 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v12, v16);
      v20 = *(int8x16_t *)(v11 + 64);
      v21 = *(float32x4_t *)(v11 + 80);
      v22 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v18), (int8x16_t)v12);
      v23 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v19), (int8x16_t)v12);
      v24 = *(int8x16_t *)(v11 + 96);
      v163 = *(float32x4_t *)(v11 + 112);
      v164 = v20;
      v25 = *(float32x4_t *)(v11 + 128);
      v166 = *(float32x4_t *)(v11 + 144);
      v26 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v22, v25));
      v27 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v23, v25));
      v28 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v18))), v163), v26);
      v29 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v19))), v163), v27);
      v30 = vmulq_f32(vmulq_f32(v166, v27), v23);
      v31 = vsubq_f32(vsubq_f32(v22, v12), vmulq_f32(vmulq_f32(v166, v26), v22));
      v32 = vsubq_f32(vsubq_f32(v23, v12), v30);
      v33 = vmulq_f32(v31, v31);
      v34 = vmulq_f32(v32, v32);
      v36 = *(float32x4_t *)(v11 + 160);
      v35 = *(float32x4_t *)(v11 + 176);
      v37 = *(float32x4_t *)(v11 + 192);
      v38 = *(float32x4_t *)(v11 + 208);
      v39 = *(float32x4_t *)(v11 + 224);
      v40 = *(float32x4_t *)(v11 + 240);
      v41 = vaddq_f32(vaddq_f32(v39, vmulq_f32(v40, v32)), vmulq_f32(v34, vaddq_f32(vaddq_f32(v36, vmulq_f32(v35, v32)), vmulq_f32(v34, vaddq_f32(v37, vmulq_f32(v38, v32))))));
      v42 = vmulq_f32(v31, vaddq_f32(vaddq_f32(v39, vmulq_f32(v40, v31)), vmulq_f32(v33, vaddq_f32(vaddq_f32(v36, vmulq_f32(v35, v31)), vmulq_f32(v33, vaddq_f32(v37, vmulq_f32(v38, v31)))))));
      v44 = *(float32x4_t *)(v11 + 256);
      v43 = *(float32x4_t *)(v11 + 272);
      v45 = v15;
      v46 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v28, vmulq_f32(v31, vaddq_f32(v44, v42))), *(float32x2_t *)v15.f32, 1), v43);
      v47 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v29, vmulq_f32(v32, vaddq_f32(v44, vmulq_f32(v32, v41)))), *(float32x2_t *)v15.f32, 1), v43);
      v48 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
      v49 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      v50 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v48, v46)));
      v51 = vsubq_f32(v49, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v49, v47)));
      v52 = vsubq_f32(v46, v50);
      v53 = vsubq_f32(v47, v51);
      v54 = *(float32x4_t *)(v11 + 288);
      v55 = *(float32x4_t *)(v11 + 304);
      v57 = *(float32x4_t *)(v11 + 320);
      v56 = *(float32x4_t *)(v11 + 336);
      v59 = *(float32x4_t *)(v11 + 352);
      v58 = *(int32x4_t *)(v11 + 368);
      v60 = (int8x16_t)vmulq_f32(vaddq_f32(v12, vmulq_f32(v52, vaddq_f32(v59, vmulq_f32(v52, vaddq_f32(vaddq_f32(v57, vmulq_f32(v52, v56)), vmulq_f32(vmulq_f32(v52, v52), vaddq_f32(v54, vmulq_f32(v55, v52)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v58, vcvtq_s32_f32(v50)), 0x17uLL));
      v61 = (int8x16_t)vmulq_f32(vaddq_f32(v12, vmulq_f32(v53, vaddq_f32(v59, vmulq_f32(v53, vaddq_f32(vaddq_f32(v57, vmulq_f32(v56, v53)), vmulq_f32(vmulq_f32(v53, v53), vaddq_f32(v54, vmulq_f32(v55, v53)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v58, vcvtq_s32_f32(v51)), 0x17uLL));
      v62 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11, 1);
      v64 = *(int8x16_t *)(v11 + 384);
      v63 = *(float32x4_t *)(v11 + 400);
      v65 = v14;
      v66 = (float32x4_t)vbslq_s8(v64, v14, v60);
      v67 = (float32x4_t)vbslq_s8(v64, v16, v61);
      v68 = (int8x16_t)vaddq_f32(v62, vmulq_laneq_f32(v67, *(float32x4_t *)v11, 2));
      v69 = (float32x4_t)vbslq_s8(v64, v14, (int8x16_t)vaddq_f32(v62, vmulq_laneq_f32(v66, *(float32x4_t *)v11, 2)));
      v70 = *(float32x4_t *)(v11 + 416);
      v71 = vminq_f32(vmaxq_f32(vrecpeq_f32(v69), v63), v70);
      v72 = vmulq_f32(v71, vrecpsq_f32(v69, v71));
      v73 = (float32x4_t)vbslq_s8(v64, v16, v68);
      v74 = vminq_f32(vmaxq_f32(vrecpeq_f32(v73), v63), v70);
      v75 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11, 0);
      v76 = vminq_f32(vmaxq_f32(v72, v63), v70);
      v77 = vminq_f32(vmaxq_f32(vmulq_f32(v74, vrecpsq_f32(v73, v74)), v63), v70);
      v78 = vmulq_f32(v77, vrecpsq_f32(v73, v77));
      v79 = (int8x16_t)vmulq_f32(vmaxq_f32(vsubq_f32(v66, v75), v165), vmulq_f32(v76, vrecpsq_f32(v69, v76)));
      v80 = (int8x16_t)vmulq_f32(vmaxq_f32(vsubq_f32(v67, v75), v165), v78);
      v81 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 0), v165)), v165);
      v82 = v65;
      v83 = v16;
      v84 = (float32x4_t)vbslq_s8(v81, (int8x16_t)v12, vbslq_s8(v64, v65, v79));
      v85 = (float32x4_t)vbslq_s8(v81, (int8x16_t)v12, vbslq_s8(v64, v16, v80));
      v86 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v84, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v84)));
      v87 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v84, v164), (int8x16_t)v12);
      v88 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v85, v164), (int8x16_t)v12);
      v89 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v87, v25));
      v90 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v88, v25));
      v91 = vaddq_f32(vsubq_f32(v86, v163), v89);
      v92 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v85, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v85))), v163), v90);
      v93 = vsubq_f32(vsubq_f32(v87, v12), vmulq_f32(vmulq_f32(v166, v89), v87));
      v94 = vsubq_f32(vsubq_f32(v88, v12), vmulq_f32(vmulq_f32(v166, v90), v88));
      v95 = vaddq_f32(v36, vmulq_f32(v35, v94));
      v96 = vmulq_f32(v93, v93);
      v97 = vaddq_f32(vaddq_f32(v36, vmulq_f32(v35, v93)), vmulq_f32(v96, vaddq_f32(v37, vmulq_f32(v38, v93))));
      v98 = vmulq_f32(v94, v94);
      v99 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v91, vmulq_f32(v93, vaddq_f32(v44, vmulq_f32(v93, vaddq_f32(vaddq_f32(v39, vmulq_f32(v40, v93)), vmulq_f32(v96, v97)))))), v45.f32[0]), v43);
      v100 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v92, vmulq_f32(v94, vaddq_f32(v44, vmulq_f32(v94, vaddq_f32(vaddq_f32(v39, vmulq_f32(v40, v94)), vmulq_f32(v98, vaddq_f32(v95, vmulq_f32(v98, vaddq_f32(v37, vmulq_f32(v38, v94)))))))))), v45.f32[0]), v43);
      v101 = vcvtq_f32_s32(vcvtq_s32_f32(v99));
      v102 = vcvtq_f32_s32(vcvtq_s32_f32(v100));
      v103 = vsubq_f32(v101, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v101, v99)));
      v104 = vsubq_f32(v102, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v102, v100)));
      v105 = vsubq_f32(v99, v103);
      v106 = vsubq_f32(v100, v104);
      v107 = (int8x16_t *)(v5 + v10);
      v107[-1] = vbslq_s8(v64, v82, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v64, v82, (int8x16_t)vmulq_f32(vaddq_f32(v12, vmulq_f32(v105, vaddq_f32(v59, vmulq_f32(v105, vaddq_f32(vaddq_f32(v57, vmulq_f32(v56, v105)), vmulq_f32(vmulq_f32(v105, v105),
                                                                        vaddq_f32(v54, vmulq_f32(v55, v105)))))))),
                                                            (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v103), v58), 0x17uLL))), v45, 2));
      *v107 = vbslq_s8(v64, v83, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v64, v83, (int8x16_t)vmulq_f32(vaddq_f32(v12, vmulq_f32(v106, vaddq_f32(v59, vmulq_f32(v106, vaddq_f32(vaddq_f32(v57, vmulq_f32(v56, v106)), vmulq_f32(vmulq_f32(v106, v106),
                                                                     vaddq_f32(v54, vmulq_f32(v55, v106)))))))),
                                                         (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v104), v58), 0x17uLL))), v45, 2));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v108 = -v9;
    if (v108 >= v4)
      goto LABEL_3;
LABEL_10:
    v109 = 16 * v108;
    v110 = *((_QWORD *)this + 51);
    v112 = *(float32x4_t *)(v110 + 32);
    v111 = *(float32x4_t *)(v110 + 48);
    v113 = (int8x16_t)vminq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v109), v112), v111);
    v114 = *(float32x4_t *)(v110 + 16);
    v115 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114.f32, 1), v112)), v112), (int8x16_t)v111, v113);
    v116 = *(int8x16_t *)(v110 + 64);
    v117 = *(float32x4_t *)(v110 + 80);
    v118 = (float32x4_t)vorrq_s8(vandq_s8(v116, (int8x16_t)v115), (int8x16_t)v111);
    v119 = *(int8x16_t *)(v110 + 96);
    v120 = *(float32x4_t *)(v110 + 112);
    v121 = *(float32x4_t *)(v110 + 128);
    v122 = *(float32x4_t *)(v110 + 144);
    v123 = (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v118, v121));
    v124 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v115, 0x17uLL)), (float32x4_t)vandq_s8(v119, (int8x16_t)vcgtq_f32(v117, v115))), v120), v123);
    v125 = vsubq_f32(vsubq_f32(v118, v111), vmulq_f32(vmulq_f32(v122, v123), v118));
    v126 = vmulq_f32(v125, v125);
    v127 = *(float32x4_t *)(v110 + 160);
    v128 = *(float32x4_t *)(v110 + 176);
    v129 = *(float32x4_t *)(v110 + 192);
    v130 = *(float32x4_t *)(v110 + 208);
    v131 = *(float32x4_t *)(v110 + 224);
    v132 = *(float32x4_t *)(v110 + 240);
    v133 = *(float32x4_t *)(v110 + 256);
    v134 = *(float32x4_t *)(v110 + 272);
    v135 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v124, vmulq_f32(v125, vaddq_f32(v133, vmulq_f32(v125, vaddq_f32(vaddq_f32(v131, vmulq_f32(v132, v125)), vmulq_f32(v126, vaddq_f32(vaddq_f32(v127, vmulq_f32(v128, v125)), vmulq_f32(v126, vaddq_f32(v129, vmulq_f32(v130, v125)))))))))), *(float32x2_t *)v114.f32, 1), v134);
    v136 = vcvtq_f32_s32(vcvtq_s32_f32(v135));
    v137 = vsubq_f32(v136, (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v136, v135)));
    v138 = vsubq_f32(v135, v137);
    v139 = *(float32x4_t *)(v110 + 288);
    v140 = *(float32x4_t *)(v110 + 304);
    v141 = *(float32x4_t *)(v110 + 320);
    v142 = *(float32x4_t *)(v110 + 336);
    v143 = *(float32x4_t *)(v110 + 352);
    v144 = *(int32x4_t *)(v110 + 368);
    v146 = *(int8x16_t *)(v110 + 384);
    v145 = *(float32x4_t *)(v110 + 400);
    v147 = (float32x4_t)vbslq_s8(v146, v113, (int8x16_t)vmulq_f32(vaddq_f32(v111, vmulq_f32(v138, vaddq_f32(v143, vmulq_f32(v138, vaddq_f32(vaddq_f32(v141, vmulq_f32(v142, v138)), vmulq_f32(vmulq_f32(v138, v138), vaddq_f32(v139, vmulq_f32(v140, v138)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v144, vcvtq_s32_f32(v137)), 0x17uLL)));
    v148 = (float32x4_t)vbslq_s8(v146, v113, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v110, 1), vmulq_laneq_f32(v147, *(float32x4_t *)v110, 2)));
    v149 = *(float32x4_t *)(v110 + 416);
    v150 = vminq_f32(vmaxq_f32(vrecpeq_f32(v148), v145), v149);
    v151 = vminq_f32(vmaxq_f32(vmulq_f32(v150, vrecpsq_f32(v148, v150)), v145), v149);
    v152 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114.f32, 0), v112)), v112), (int8x16_t)v111, vbslq_s8(v146, v113, (int8x16_t)vmulq_f32(vmaxq_f32(vsubq_f32(v147, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v110, 0)), v112), vmulq_f32(v151, vrecpsq_f32(v148, v151)))));
    v153 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v152, v116), (int8x16_t)v111);
    v154 = (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v153, v121));
    v155 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v152, 0x17uLL)), (float32x4_t)vandq_s8(v119, (int8x16_t)vcgtq_f32(v117, v152))), v120), v154);
    v156 = vsubq_f32(vsubq_f32(v153, v111), vmulq_f32(vmulq_f32(v122, v154), v153));
    v157 = vmulq_f32(v156, v156);
    v158 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v155, vmulq_f32(v156, vaddq_f32(v133, vmulq_f32(v156, vaddq_f32(vaddq_f32(v131, vmulq_f32(v132, v156)), vmulq_f32(v157, vaddq_f32(vaddq_f32(v127, vmulq_f32(v128, v156)), vmulq_f32(v157, vaddq_f32(v129, vmulq_f32(v130, v156)))))))))), v114.f32[0]), v134);
    v159 = vcvtq_f32_s32(vcvtq_s32_f32(v158));
    v160 = vsubq_f32(v159, (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v159, v158)));
    v161 = vsubq_f32(v158, v160);
    *(int8x16_t *)(v5 + v109) = vbslq_s8(v146, v113, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v146, v113, (int8x16_t)vmulq_f32(vaddq_f32(v111, vmulq_f32(v161, vaddq_f32(v143, vmulq_f32(v161, vaddq_f32(vaddq_f32(v141, vmulq_f32(v142, v161)),
                                                                                     vmulq_f32(vmulq_f32(v161, v161), vaddq_f32(v139, vmulq_f32(v140, v161)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v160), v144), 0x17uLL))), v114, 2));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2100_PQ_InverseOETF_qtApprox::GetDOD(HgcBT2100_PQ_InverseOETF_qtApprox *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBT2100_PQ_InverseOETF_qtApprox::GetROI(HgcBT2100_PQ_InverseOETF_qtApprox *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBT2100_PQ_InverseOETF_qtApprox::HgcBT2100_PQ_InverseOETF_qtApprox(HgcBT2100_PQ_InverseOETF_qtApprox *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6549BC8;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = xmmword_1B30536D0;
  *(_OWORD *)(v3 + 48) = xmmword_1B3525D80;
  *(_OWORD *)(v3 + 64) = xmmword_1B3051600;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051610;
  *(_OWORD *)(v3 + 96) = xmmword_1B3051620;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051630;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051640;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051510;
  *(_OWORD *)(v3 + 160) = xmmword_1B3525860;
  *(_OWORD *)(v3 + 176) = xmmword_1B3525870;
  *(_OWORD *)(v3 + 192) = xmmword_1B3525880;
  *(_OWORD *)(v3 + 208) = xmmword_1B3525890;
  *(_OWORD *)(v3 + 224) = xmmword_1B35258A0;
  *(_OWORD *)(v3 + 240) = xmmword_1B35258B0;
  *(_OWORD *)(v3 + 256) = xmmword_1B35258C0;
  *(_OWORD *)(v3 + 272) = xmmword_1B3051690;
  *(_OWORD *)(v3 + 288) = xmmword_1B35258D0;
  *(_OWORD *)(v3 + 304) = xmmword_1B35258E0;
  *(_OWORD *)(v3 + 320) = xmmword_1B35258F0;
  *(_OWORD *)(v3 + 336) = xmmword_1B3525900;
  *(_OWORD *)(v3 + 352) = xmmword_1B3525910;
  *(_OWORD *)(v3 + 368) = xmmword_1B30516D0;
  *(_OWORD *)(v3 + 384) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 400) = xmmword_1B3052320;
  *(int32x4_t *)(v3 + 416) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BEE678(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_PQ_InverseOETF_qtApprox::~HgcBT2100_PQ_InverseOETF_qtApprox(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6549BC8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4003455651);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6549BC8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4003455651);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_PQ_InverseOETF_qtApprox::SetParameter(HgcBT2100_PQ_InverseOETF_qtApprox *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_PQ_InverseOETF_qtApprox::GetParameter(HgcBT2100_PQ_InverseOETF_qtApprox *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_HLG_OETF::GetProgram(HgcBT2100_HLG_OETF *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000470\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = fmax(r0.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].zzz);\n"
             "    r1.x = sqrt(r1.x);\n"
             "    r1.z = sqrt(r1.z);\n"
             "    r1.y = sqrt(r1.y);\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = log2(r2.xyz);\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[1].yyy) + half3(hg_Params[1].www);\n"
             "    r0.xyz = half3(half3(hg_Params[0].xxx) < r0.xyz);\n"
             "    output.color0.xyz = select(float3(r1.xyz), float3(r2.xyz), -float3(r0.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a246f9f9:66d6029c:84c9338d:ea089985\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000424\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = fmax(r0.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz - hg_Params[1].zzz;\n"
             "    r1.x = sqrt(r1.x);\n"
             "    r1.z = sqrt(r1.z);\n"
             "    r1.y = sqrt(r1.y);\n"
             "    r1.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = log2(r2.xyz);\n"
             "    r2.xyz = r2.xyz*hg_Params[1].yyy + hg_Params[1].www;\n"
             "    r0.xyz = float3(hg_Params[0].xxx < r0.xyz);\n"
             "    output.color0.xyz = select(r1.xyz, r2.xyz, -r0.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5c824207:76fd8e2e:0a00acd2:9472bca2\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000046a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r2.xyz = max(r0.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.zzz;\n"
           "    r1.x = sqrt(r1.x);\n"
           "    r1.z = sqrt(r1.z);\n"
           "    r1.y = sqrt(r1.y);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = log2(r2.xyz);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal1.yyy + hg_ProgramLocal1.www;\n"
           "    r0.xyz = vec3(lessThan(hg_ProgramLocal0.xxx, r0.xyz));\n"
           "    gl_FragColor.xyz = vec3(-r0.x < 0.00000 ? r2.x : r1.x, -r0.y < 0.00000 ? r2.y : r1.y, -r0.z < 0.00000 ? r"
           "2.z : r1.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=56011197:b8fa2ca6:c303b796:50fed9e5\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_HLG_OETF::InitProgramDescriptor(HgcBT2100_HLG_OETF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_HLG_OETF_hgc_visible", "//Metal1.0     \n//LEN=0000000300\n[[ visible ]] FragmentOut HgcBT2100_HLG_OETF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r2.xyz = fmax(r0.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz - hg_Params[1].zzz;\n"
    "    r1.x = sqrt(r1.x);\n"
    "    r1.z = sqrt(r1.z);\n"
    "    r1.y = sqrt(r1.y);\n"
    "    r1.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r2.xyz = log2(r2.xyz);\n"
    "    r2.xyz = r2.xyz*hg_Params[1].yyy + hg_Params[1].www;\n"
    "    r0.xyz = float3(hg_Params[0].xxx < r0.xyz);\n"
    "    output.color0.xyz = select(r1.xyz, r2.xyz, -r0.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BEEA8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BEEABC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BEEAB4);
}

double HgcBT2100_HLG_OETF::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcBT2100_HLG_OETF [hgc1]");
  return *(double *)"_HLG_OETF [hgc1]";
}

uint64_t HgcBT2100_HLG_OETF::BindTexture(HgcBT2100_HLG_OETF *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_HLG_OETF::Bind(HgcBT2100_HLG_OETF *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcBT2100_HLG_OETF *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBT2100_HLG_OETF::RenderTile(HgcBT2100_HLG_OETF *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  int32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int8x16_t v59;
  int8x16_t v60;
  int8x16_t *v61;
  int v62;
  uint64_t v63;
  float32x4_t v64;
  uint64_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int8x16_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v62 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v12 = *(float32x4_t *)(v6 + v10 - 16);
      v11 = *(float32x4_t *)(v6 + v10);
      v13 = *((_QWORD *)this + 51);
      v14 = *(float32x4_t *)(v13 + 32);
      v15 = *(float32x4_t *)(v13 + 48);
      v16 = vmaxq_f32(v12, v14);
      v17 = vmaxq_f32(v11, v14);
      v18 = *(int32x4_t *)(v13 + 16);
      v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 0);
      v20 = (float32x4_t)vdupq_laneq_s32(v18, 2);
      v21 = vsubq_f32(vmaxq_f32(v12, v19), v20);
      v22 = *(float32x4_t *)(v13 + 64);
      v23 = vminq_f32(vmulq_f32(vrsqrteq_f32(v16), v15), v22);
      v24 = vminq_f32(vmulq_f32(vrsqrteq_f32(v17), v15), v22);
      v25 = (int8x16_t)vmulq_f32(v17, vminq_f32(vmulq_f32(v24, vrsqrtsq_f32(vmulq_f32(v17, v24), v24)), v22));
      v26 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v13 + 80), (int8x16_t)vmulq_f32(v16, vminq_f32(vmulq_f32(v23, vrsqrtsq_f32(vmulq_f32(v16, v23), v23)), v22)), (int8x16_t)v16);
      v27 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v13 + 80), v25, (int8x16_t)v17);
      v28 = vminq_f32(vmulq_f32(v22, vrsqrteq_f32(v26)), v15);
      v29 = vminq_f32(vmulq_f32(v22, vrsqrteq_f32(v27)), v15);
      v30 = vsubq_f32(vmaxq_f32(v11, v19), v20);
      v26.i64[1] = vmulq_f32(vminq_f32(vmulq_f32(v28, vrsqrtsq_f32(vmulq_f32(v28, v26), v28)), v15), v26).i64[1];
      v27.i64[1] = vmulq_f32(vminq_f32(vmulq_f32(v29, vrsqrtsq_f32(vmulq_f32(v29, v27), v29)), v15), v27).i64[1];
      v31 = *(int8x16_t *)(v13 + 96);
      v32 = *(int8x16_t *)(v13 + 112);
      v33 = *(float32x4_t *)(v13 + 128);
      v34 = *(float32x4_t *)(v13 + 144);
      v35 = (float32x4_t)vorrq_s8(vandq_s8(v32, (int8x16_t)v21), (int8x16_t)v33);
      v36 = (float32x4_t)vorrq_s8(vandq_s8(v32, (int8x16_t)v30), (int8x16_t)v33);
      v37 = *(int8x16_t *)(v13 + 160);
      v38 = *(float32x4_t *)(v13 + 176);
      v39 = vminq_f32(vmulq_f32(v22, vrsqrteq_f32(v26)), v15);
      v40 = vminq_f32(vmulq_f32(v22, vrsqrteq_f32(v27)), v15);
      v41 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v37, (int8x16_t)vcgtq_f32(v34, v21))), v38);
      v42 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v37, (int8x16_t)vcgtq_f32(v34, v30))), v38);
      v43 = *(float32x4_t *)(v13 + 192);
      v44 = *(float32x4_t *)(v13 + 208);
      v45 = (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v35, v43));
      v46 = (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v36, v43));
      v47 = vaddq_f32(v42, v46);
      v48 = vsubq_f32(vsubq_f32(v35, v33), vmulq_f32(vmulq_f32(v44, v45), v35));
      v49 = vsubq_f32(vsubq_f32(v36, v33), vmulq_f32(vmulq_f32(v44, v46), v36));
      v50 = *(float32x4_t *)(v13 + 224);
      v51 = *(float32x4_t *)(v13 + 240);
      v52 = vaddq_f32(v50, vmulq_f32(v51, v48));
      v53 = vaddq_f32(v50, vmulq_f32(v51, v49));
      v54 = *(float32x4_t *)(v13 + 256);
      v55 = *(float32x4_t *)(v13 + 272);
      v56 = (float32x4_t)vbslq_s8(v31, (int8x16_t)vmulq_f32(v26, vminq_f32(vmulq_f32(v39, vrsqrtsq_f32(vmulq_f32(v26, v39), v39)), v15)), (int8x16_t)v26);
      v57 = (float32x4_t)vdupq_laneq_s32(v18, 3);
      v58 = (float32x4_t)vbslq_s8(v31, (int8x16_t)vmulq_f32(v27, vminq_f32(vmulq_f32(v40, vrsqrtsq_f32(vmulq_f32(v27, v40), v40)), v15)), (int8x16_t)v27);
      v59 = (int8x16_t)vaddq_f32(v57, vmulq_lane_f32(vaddq_f32(v47, vmulq_f32(v49, vaddq_f32(vaddq_f32(v54, vmulq_f32(v49, v55)), vmulq_f32(vmulq_f32(v49, v49), v53)))), *(float32x2_t *)v18.i8, 1));
      v60 = *(int8x16_t *)(v13 + 288);
      v61 = (int8x16_t *)(v5 + v10);
      v61[-1] = vbslq_s8(v60, (int8x16_t)v12, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v60, (int8x16_t)v12, vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v12, v19))), v14), (int8x16_t)vaddq_f32(v57, vmulq_lane_f32(vaddq_f32(vaddq_f32(v41, v45), vmulq_f32(v48, vaddq_f32(vaddq_f32(v54, vmulq_f32(v48, v55)), vmulq_f32(vmulq_f32(v48, v48), v52)))),
                                   *(float32x2_t *)v18.i8,
                                   1)),
                    (int8x16_t)vmulq_n_f32(v56, *(float *)v18.i32)));
      *v61 = vbslq_s8(v60, (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v60, (int8x16_t)v11, vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v11, v19))), v14), v59, (int8x16_t)vmulq_n_f32(v58, *(float *)v18.i32)));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v62 = -v9;
    if (v62 >= v4)
      goto LABEL_3;
LABEL_10:
    v63 = 16 * v62;
    v64 = *(float32x4_t *)(v6 + v63);
    v65 = *((_QWORD *)this + 51);
    v66 = *(float32x4_t *)(v65 + 32);
    v67 = *(float32x4_t *)(v65 + 48);
    v68 = vmaxq_f32(v64, v66);
    v69 = *(int32x4_t *)(v65 + 16);
    v70 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v65, 0);
    v71 = *(float32x4_t *)(v65 + 64);
    v72 = vminq_f32(vmulq_f32(vrsqrteq_f32(v68), v67), v71);
    v73 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v65 + 80), (int8x16_t)vmulq_f32(v68, vminq_f32(vmulq_f32(v72, vrsqrtsq_f32(vmulq_f32(v68, v72), v72)), v71)), (int8x16_t)v68);
    v74 = vminq_f32(vmulq_f32(v71, vrsqrteq_f32(v73)), v67);
    v73.i64[1] = vmulq_f32(vminq_f32(vmulq_f32(v74, vrsqrtsq_f32(vmulq_f32(v74, v73), v74)), v67), v73).i64[1];
    v75 = vsubq_f32(vmaxq_f32(v64, v70), (float32x4_t)vdupq_laneq_s32(v69, 2));
    v76 = vminq_f32(vmulq_f32(v71, vrsqrteq_f32(v73)), v67);
    v77 = (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v65 + 96), (int8x16_t)vmulq_f32(v73, vminq_f32(vmulq_f32(v76, vrsqrtsq_f32(vmulq_f32(v76, v73), v76)), v67)), (int8x16_t)v73), *(float *)v69.i32);
    v78 = *(float32x4_t *)(v65 + 128);
    v79 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v65 + 112), (int8x16_t)v75), (int8x16_t)v78);
    v80 = (float32x4_t)vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v79, *(float32x4_t *)(v65 + 192)));
    v81 = vsubq_f32(vsubq_f32(v79, v78), vmulq_f32(vmulq_f32(*(float32x4_t *)(v65 + 208), v80), v79));
    *(int8x16_t *)(v5 + v63) = vbslq_s8(*(int8x16_t *)(v65 + 288), (int8x16_t)v64, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v65 + 288), (int8x16_t)v64, vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v64, v70))), v66), (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(v69, 3), vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v75, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v65 + 160),
                                                                         (int8x16_t)vcgtq_f32(*(float32x4_t *)(v65 + 144), v75))), *(float32x4_t *)(v65 + 176)), v80), vmulq_f32(v81, vaddq_f32(vaddq_f32(*(float32x4_t *)(v65 + 256), vmulq_f32(v81, *(float32x4_t *)(v65 + 272))), vmulq_f32(vmulq_f32(v81, v81), vaddq_f32(*(float32x4_t *)(v65 + 224), vmulq_f32(*(float32x4_t *)(v65 + 240), v81)))))), *(float32x2_t *)v69.i8, 1)), v77));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2100_HLG_OETF::GetDOD(HgcBT2100_HLG_OETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBT2100_HLG_OETF::GetROI(HgcBT2100_HLG_OETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBT2100_HLG_OETF::HgcBT2100_HLG_OETF(HgcBT2100_HLG_OETF *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6549E30;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = 0u;
  v3[3] = xmmword_1B3554480;
  v3[4] = xmmword_1B3554490;
  v3[5] = xmmword_1B3050E20;
  v3[6] = xmmword_1B3050FF0;
  v3[7] = xmmword_1B3051600;
  v3[8] = xmmword_1B3051560;
  v3[9] = xmmword_1B3051610;
  v3[10] = xmmword_1B3051620;
  v3[11] = xmmword_1B3051630;
  v3[12] = xmmword_1B3051640;
  v3[13] = xmmword_1B3051510;
  v3[14] = xmmword_1B3051650;
  v3[15] = xmmword_1B3051660;
  v3[16] = xmmword_1B3051670;
  v3[17] = xmmword_1B3051680;
  v3[18] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BEF1B0(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_HLG_OETF::~HgcBT2100_HLG_OETF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6549E30;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40FDACBBE0);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6549E30;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40FDACBBE0);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_HLG_OETF::SetParameter(HgcBT2100_HLG_OETF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_HLG_OETF::GetParameter(HgcBT2100_HLG_OETF *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_HLG_InverseOETF::GetProgram(HgcBT2100_HLG_InverseOETF *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000459\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.004999999888, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz*half3(hg_Params[1].xxx) + half3(hg_Params[1].yyy);\n"
             "    r2.xyz = r1.xyz*r1.xyz;\n"
             "    r1.w = half(r0.w >= c0.y);\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].yyy);\n"
             "    r0.xyz = exp2(r0.xyz);\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[1].zzz) + half3(hg_Params[1].www);\n"
             "    r1.xyz = half3(half3(hg_Params[0].xxx) < r1.xyz);\n"
             "    output.color0.xyz = select(float3(r2.xyz), float3(r0.xyz), -float3(r1.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r1.w)*float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0e64def9:549efc1e:2c24ba50:d3e12153\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000407\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.004999999888, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
             "    r2.xyz = r1.xyz*r1.xyz;\n"
             "    r1.w = float(r0.w >= c0.y);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].yyy;\n"
             "    r0.xyz = exp2(r0.xyz);\n"
             "    r0.xyz = r0.xyz*hg_Params[1].zzz + hg_Params[1].www;\n"
             "    r1.xyz = float3(hg_Params[0].xxx < r1.xyz);\n"
             "    output.color0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
             "    output.color0.w = r1.w*r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9d3926b3:95147086:aed26591:6ed500f8\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000044e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.004999999888, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r0.xyz = r1.xyz*hg_ProgramLocal1.xxx + hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = r1.xyz*r1.xyz;\n"
           "    r1.w = float(r0.w >= c0.y);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.yyy;\n"
           "    r0.xyz = exp2(r0.xyz);\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal1.zzz + hg_ProgramLocal1.www;\n"
           "    r1.xyz = vec3(lessThan(hg_ProgramLocal0.xxx, r1.xyz));\n"
           "    gl_FragColor.xyz = vec3(-r1.x < 0.00000 ? r0.x : r2.x, -r1.y < 0.00000 ? r0.y : r2.y, -r1.z < 0.00000 ? r"
           "0.z : r2.z);\n"
           "    gl_FragColor.w = r1.w*r0.w;\n"
           "}\n"
           "//MD5=b0b6d9ae:948ec756:c093cb52:9ea2171d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_HLG_InverseOETF::InitProgramDescriptor(HgcBT2100_HLG_InverseOETF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_HLG_InverseOETF_hgc_visible", "//Metal1.0     \n//LEN=00000002ea\n[[ visible ]] FragmentOut HgcBT2100_HLG_InverseOETF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.004999999888, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r0.xyz = r1.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
    "    r2.xyz = r1.xyz*r1.xyz;\n"
    "    r1.w = float(r0.w >= c0.y);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].yyy;\n"
    "    r0.xyz = exp2(r0.xyz);\n"
    "    r0.xyz = r0.xyz*hg_Params[1].zzz + hg_Params[1].www;\n"
    "    r1.xyz = float3(hg_Params[0].xxx < r1.xyz);\n"
    "    output.color0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
    "    output.color0.w = r1.w*r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BEF5C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BEF5F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BEF5ECLL);
}

char *HgcBT2100_HLG_InverseOETF::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552EC0;
  strcpy(result, "HgcBT2100_HLG_InverseOETF [hgc1]");
  return result;
}

uint64_t HgcBT2100_HLG_InverseOETF::BindTexture(HgcBT2100_HLG_InverseOETF *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_HLG_InverseOETF::Bind(HgcBT2100_HLG_InverseOETF *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcBT2100_HLG_InverseOETF *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBT2100_HLG_InverseOETF::RenderTile(HgcBT2100_HLG_InverseOETF *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  int32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int8x16_t v46;
  float32x4_t v47;
  float32x4_t v48;
  int8x16_t *v49;
  int8x16_t v50;
  int v51;
  uint64_t v52;
  float32x4_t v53;
  uint64_t v54;
  float32x4_t v55;
  int8x16_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int8x16_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v51 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v11 = *(float32x4_t *)(v6 + v10 - 16);
      v12 = *(float32x4_t *)(v6 + v10);
      v13 = *((_QWORD *)this + 51);
      v14 = *(float32x4_t *)(v13 + 16);
      v15 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1);
      v17 = *(float32x4_t *)(v13 + 32);
      v16 = *(int8x16_t *)(v13 + 48);
      v18 = vmaxq_f32(v11, v17);
      v19 = vmaxq_f32(v12, v17);
      v20 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v11, (int8x16_t)vaddq_f32(v15, vmulq_n_f32(v18, v14.f32[0])));
      v21 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v12, (int8x16_t)vaddq_f32(v15, vmulq_n_f32(v19, v14.f32[0])));
      v22 = *(float32x4_t *)(v13 + 64);
      v23 = *(float32x4_t *)(v13 + 80);
      v24 = (int8x16_t)vcgeq_f32(v21, v17);
      v25 = vandq_s8((int8x16_t)v22, (int8x16_t)vcgeq_f32(v20, v17));
      v26 = vmaxq_f32(v20, v22);
      v27 = vmaxq_f32(v21, v22);
      v28 = vcvtq_f32_s32(vcvtq_s32_f32(v26));
      v29 = vcvtq_f32_s32(vcvtq_s32_f32(v27));
      v30 = vsubq_f32(v28, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v28, v26)));
      v31 = vsubq_f32(v29, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v29, v27)));
      v32 = vsubq_f32(v26, v30);
      v33 = vsubq_f32(v27, v31);
      v34 = *(float32x4_t *)(v13 + 96);
      v35 = *(float32x4_t *)(v13 + 112);
      v36 = vandq_s8((int8x16_t)v22, v24);
      v37 = vaddq_f32(v34, vmulq_f32(v35, v32));
      v38 = vaddq_f32(v34, vmulq_f32(v35, v33));
      v39 = *(float32x4_t *)(v13 + 128);
      v40 = *(int32x4_t *)(v13 + 144);
      v41 = (int8x16_t)vmulq_f32(vaddq_f32(v23, vmulq_f32(v32, vaddq_f32(v39, vmulq_f32(v32, v37)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v40, vcvtq_s32_f32(v30)), 0x17uLL));
      v42 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3);
      v43 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v11, (int8x16_t)vaddq_f32(v42, vmulq_laneq_f32((float32x4_t)vbslq_s8(v16, (int8x16_t)v11, v41), v14, 2)));
      v44 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 0);
      v45 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v12, (int8x16_t)vaddq_f32(v42, vmulq_laneq_f32((float32x4_t)vbslq_s8(v16, (int8x16_t)v12, (int8x16_t)vmulq_f32(vaddq_f32(v23, vmulq_f32(v33, vaddq_f32(v39, vmulq_f32(v33, v38)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v40, vcvtq_s32_f32(v31)), 0x17uLL))), v14, 2)));
      v46 = vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v16, v36, (int8x16_t)v19), v44));
      v47 = (float32x4_t)vbslq_s8(v16, v25, vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v16, v25, (int8x16_t)v18), v44)));
      v48 = (float32x4_t)vbslq_s8(v16, v36, v46);
      v49 = (int8x16_t *)(v5 + v10);
      v50 = vbslq_s8(v16, (int8x16_t)vmulq_f32(v48, v45), vbslq_s8((int8x16_t)vcgtq_f32(v48, v17), (int8x16_t)v45, (int8x16_t)vmulq_lane_f32(vmulq_f32(v19, v19), *(float32x2_t *)v13, 1)));
      v49[-1] = vbslq_s8(v16, (int8x16_t)vmulq_f32(v47, v43), vbslq_s8((int8x16_t)vcgtq_f32(v47, v17), (int8x16_t)v43, (int8x16_t)vmulq_lane_f32(vmulq_f32(v18, v18), *(float32x2_t *)v13, 1)));
      *v49 = v50;
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v51 = -v9;
    if (v51 >= v4)
      goto LABEL_3;
LABEL_10:
    v52 = 16 * v51;
    v53 = *(float32x4_t *)(v6 + v52);
    v54 = *((_QWORD *)this + 51);
    v55 = *(float32x4_t *)(v54 + 32);
    v56 = *(int8x16_t *)(v54 + 48);
    v57 = vmaxq_f32(v53, v55);
    v58 = *(float32x4_t *)(v54 + 16);
    v59 = (float32x4_t)vbslq_s8(v56, (int8x16_t)v53, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.f32, 1), vmulq_n_f32(v57, v58.f32[0])));
    v60 = *(float32x4_t *)(v54 + 64);
    v61 = *(float32x4_t *)(v54 + 80);
    v62 = vandq_s8((int8x16_t)v60, (int8x16_t)vcgeq_f32(v59, v55));
    v63 = vmaxq_f32(v59, v60);
    v64 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
    v65 = vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v61, (int8x16_t)vcgtq_f32(v64, v63)));
    v66 = vsubq_f32(v63, v65);
    v67 = vmulq_f32(v57, v57);
    v68 = (float32x4_t)vbslq_s8(v56, (int8x16_t)v53, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 3), vmulq_laneq_f32((float32x4_t)vbslq_s8(v56, (int8x16_t)v53, (int8x16_t)vmulq_f32(vaddq_f32(v61, vmulq_f32(v66, vaddq_f32(*(float32x4_t *)(v54 + 128), vmulq_f32(v66, vaddq_f32(*(float32x4_t *)(v54 + 96),
                                                                              vmulq_f32(*(float32x4_t *)(v54 + 112), v66)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v54 + 144), vcvtq_s32_f32(v65)), 0x17uLL))), v58, 2)));
    v69 = (float32x4_t)vbslq_s8(v56, v62, vandq_s8((int8x16_t)v61, (int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v56, v62, (int8x16_t)v57), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54, 0))));
    *(int8x16_t *)(v5 + v52) = vbslq_s8(v56, (int8x16_t)vmulq_f32(v69, v68), vbslq_s8((int8x16_t)vcgtq_f32(v69, v55), (int8x16_t)v68, (int8x16_t)vmulq_lane_f32(v67, *(float32x2_t *)v54, 1)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2100_HLG_InverseOETF::GetDOD(HgcBT2100_HLG_InverseOETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBT2100_HLG_InverseOETF::GetROI(HgcBT2100_HLG_InverseOETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBT2100_HLG_InverseOETF::HgcBT2100_HLG_InverseOETF(HgcBT2100_HLG_InverseOETF *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E654A098;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B35544C0;
  v3[3] = xmmword_1B3050F70;
  v3[4] = xmmword_1B35544D0;
  v3[5] = xmmword_1B3051560;
  v3[6] = xmmword_1B30516A0;
  v3[7] = xmmword_1B30516B0;
  v3[8] = xmmword_1B30516C0;
  v3[9] = xmmword_1B30516D0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BEFB24(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_HLG_InverseOETF::~HgcBT2100_HLG_InverseOETF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E654A098;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B8406A4ELL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E654A098;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B8406A4ELL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_HLG_InverseOETF::SetParameter(HgcBT2100_HLG_InverseOETF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_HLG_InverseOETF::GetParameter(HgcBT2100_HLG_InverseOETF *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_HLG_OOTF_InverseOOTF::GetProgram(HgcBT2100_HLG_OOTF_InverseOOTF *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000389\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = dot(r0.xyz, half3(hg_Params[0].xyz));\n"
             "    r1.y = half(c0.y < r1.x);\n"
             "    r1.x = pow(r1.x, half(hg_Params[1].x));\n"
             "    r1.x = select(c0.y, r1.x, -r1.y < 0.00000h);\n"
             "    r1.x = r1.x*half(hg_Params[1].y);\n"
             "    output.color0.xyz = float3(r0.xyz)*float3(r1.xxx);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=518f3182:06a5d829:280589ce:1e93e94a\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000035c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = dot(r0.xyz, hg_Params[0].xyz);\n"
             "    r1.y = float(c0.y < r1.x);\n"
             "    r1.x = pow(r1.x, hg_Params[1].x);\n"
             "    r1.x = select(c0.y, r1.x, -r1.y < 0.00000f);\n"
             "    r1.x = r1.x*hg_Params[1].y;\n"
             "    output.color0.xyz = r0.xyz*r1.xxx;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=c18f2b64:8869268a:5dc9c39b:c72920aa\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000353\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = dot(r0.xyz, hg_ProgramLocal0.xyz);\n"
           "    r1.y = float(c0.y < r1.x);\n"
           "    r1.x = pow(r1.x, hg_ProgramLocal1.x);\n"
           "    r1.x = -r1.y < 0.00000 ? r1.x : c0.y;\n"
           "    r1.x = r1.x*hg_ProgramLocal1.y;\n"
           "    gl_FragColor.xyz = r0.xyz*r1.xxx;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=e6fecf5f:0e29aa5b:51d59bfe:b6c20fae\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_HLG_OOTF_InverseOOTF::InitProgramDescriptor(HgcBT2100_HLG_OOTF_InverseOOTF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_HLG_OOTF_InverseOOTF_hgc_visible", "//Metal1.0     \n//LEN=0000000244\n[[ visible ]] FragmentOut HgcBT2100_HLG_OOTF_InverseOOTF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = dot(r0.xyz, hg_Params[0].xyz);\n"
    "    r1.y = float(c0.y < r1.x);\n"
    "    r1.x = pow(r1.x, hg_Params[1].x);\n"
    "    r1.x = select(c0.y, r1.x, -r1.y < 0.00000f);\n"
    "    r1.x = r1.x*hg_Params[1].y;\n"
    "    output.color0.xyz = r0.xyz*r1.xxx;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BEFF38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BEFF68(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BEFF60);
}

char *HgcBT2100_HLG_OOTF_InverseOOTF::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A20;
  strcpy(result, "HgcBT2100_HLG_OOTF_InverseOOTF [hgc1]");
  return result;
}

uint64_t HgcBT2100_HLG_OOTF_InverseOOTF::BindTexture(HgcBT2100_HLG_OOTF_InverseOOTF *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_HLG_OOTF_InverseOOTF::Bind(HgcBT2100_HLG_OOTF_InverseOOTF *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcBT2100_HLG_OOTF_InverseOOTF *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBT2100_HLG_OOTF_InverseOOTF::RenderTile(HgcBT2100_HLG_OOTF_InverseOOTF *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int32x4_t v17;
  int32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int32x4_t v59;
  float32x4_t v60;
  int32x4_t v61;
  float32x4_t v62;
  int32x4_t v63;
  int32x4_t v64;
  int8x16_t v65;
  int8x16_t v66;
  int8x16_t *v67;
  int v68;
  uint64_t v69;
  float32x4_t v70;
  uint64_t v71;
  float32x4_t v72;
  float32x4_t v73;
  int32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int8x16_t v77;
  int8x16_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int32x4_t v89;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v68 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v11 = *(float32x4_t *)(v6 + v10 - 16);
      v12 = *(float32x4_t *)(v6 + v10);
      v13 = *((_QWORD *)this + 51);
      v14 = *(float32x4_t *)(v13 + 16);
      v15 = vmulq_f32(v11, *(float32x4_t *)v13);
      v16 = vmulq_f32(v12, *(float32x4_t *)v13);
      v17 = (int32x4_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)v15, 8uLL), vaddq_f32(v15, (float32x4_t)vrev64q_s32((int32x4_t)v15)));
      v18 = (int32x4_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v16, (int8x16_t)v16, 8uLL), vaddq_f32(v16, (float32x4_t)vrev64q_s32((int32x4_t)v16)));
      v19 = *(float32x4_t *)(v13 + 32);
      v20 = *(float32x4_t *)(v13 + 48);
      v21 = vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v17), v19));
      v22 = vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v18), v19));
      v23 = *(int8x16_t *)(v13 + 64);
      v24 = *(int8x16_t *)(v13 + 80);
      v25 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v17, v21);
      v26 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v18, v22);
      v27 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v25, v24), (int8x16_t)v20);
      v28 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v26, v24), (int8x16_t)v20);
      v29 = *(int8x16_t *)(v13 + 96);
      v30 = *(float32x4_t *)(v13 + 112);
      v31 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v25, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v19, v25)));
      v32 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v19, v26)));
      v33 = *(float32x4_t *)(v13 + 128);
      v34 = *(float32x4_t *)(v13 + 144);
      v35 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v27, v33));
      v36 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v28, v33));
      v37 = vaddq_f32(vsubq_f32(v31, v30), v35);
      v38 = vsubq_f32(vsubq_f32(v27, v20), vmulq_f32(vmulq_f32(v34, v35), v27));
      v39 = vsubq_f32(vsubq_f32(v28, v20), vmulq_f32(vmulq_f32(v34, v36), v28));
      v40 = *(float32x4_t *)(v13 + 160);
      v41 = *(float32x4_t *)(v13 + 176);
      v42 = *(float32x4_t *)(v13 + 192);
      v43 = *(float32x4_t *)(v13 + 208);
      v44 = vmulq_f32(v14, vaddq_f32(vaddq_f32(vsubq_f32(v32, v30), v36), vmulq_f32(v39, vaddq_f32(vaddq_f32(v42, vmulq_f32(v43, v39)), vmulq_f32(vmulq_f32(v39, v39), vaddq_f32(v40, vmulq_f32(v41, v39)))))));
      v45 = *(float32x4_t *)(v13 + 224);
      v46 = *(float32x4_t *)(v13 + 240);
      v47 = vmaxq_f32(vmulq_f32(v14, vaddq_f32(v37, vmulq_f32(v38, vaddq_f32(vaddq_f32(v42, vmulq_f32(v43, v38)), vmulq_f32(vmulq_f32(v38, v38), vaddq_f32(v40, vmulq_f32(v41, v38))))))), v45);
      v48 = vmaxq_f32(v44, v45);
      v49 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      v50 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
      v51 = vsubq_f32(v49, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v49, v47)));
      v52 = vsubq_f32(v50, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v50, v48)));
      v53 = vsubq_f32(v47, v51);
      v54 = vsubq_f32(v48, v52);
      v55 = *(float32x4_t *)(v13 + 256);
      v56 = *(float32x4_t *)(v13 + 272);
      v57 = vmulq_f32(v54, vaddq_f32(v56, vmulq_f32(v54, vaddq_f32(v46, vmulq_f32(v55, v54)))));
      v58 = vaddq_f32(v20, vmulq_f32(v53, vaddq_f32(v56, vmulq_f32(v53, vaddq_f32(v46, vmulq_f32(v55, v53))))));
      v59 = vcvtq_s32_f32(v52);
      v60 = vaddq_f32(v20, v57);
      v61 = *(int32x4_t *)(v13 + 288);
      v62 = *(float32x4_t *)(v13 + 304);
      v63 = (int32x4_t)vbslq_s8(v23, (int8x16_t)vmulq_f32(v58, (float32x4_t)vshlq_n_s32(vaddq_s32(v61, vcvtq_s32_f32(v51)), 0x17uLL)), v21);
      v64 = (int32x4_t)vbslq_s8(v23, (int8x16_t)vmulq_f32(v60, (float32x4_t)vshlq_n_s32(vaddq_s32(v61, v59), 0x17uLL)), v22);
      v63.i32[0] = vmulq_lane_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v63), v62), (int8x16_t)v63, (int8x16_t)v62), *(float32x2_t *)v14.f32, 1).u32[0];
      v65 = (int8x16_t)vmulq_n_f32(v12, vmulq_lane_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v64), v62), (int8x16_t)v64, (int8x16_t)v62), *(float32x2_t *)v14.f32, 1).f32[0]);
      v66 = *(int8x16_t *)(v13 + 320);
      v67 = (int8x16_t *)(v5 + v10);
      v67[-1] = vbslq_s8(v66, (int8x16_t)v11, (int8x16_t)vmulq_n_f32(v11, *(float *)v63.i32));
      *v67 = vbslq_s8(v66, (int8x16_t)v12, v65);
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v68 = -v9;
    if (v68 >= v4)
      goto LABEL_3;
LABEL_10:
    v69 = 16 * v68;
    v70 = *(float32x4_t *)(v6 + v69);
    v71 = *((_QWORD *)this + 51);
    v72 = *(float32x4_t *)(v71 + 16);
    v73 = vmulq_f32(v70, *(float32x4_t *)v71);
    v74 = (int32x4_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v73, (int8x16_t)v73, 8uLL), vaddq_f32(v73, (float32x4_t)vrev64q_s32((int32x4_t)v73)));
    v75 = *(float32x4_t *)(v71 + 32);
    v76 = *(float32x4_t *)(v71 + 48);
    v77 = vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v74), v75));
    v78 = *(int8x16_t *)(v71 + 64);
    v79 = (float32x4_t)vbslq_s8(v78, (int8x16_t)v74, v77);
    v80 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v79, *(int8x16_t *)(v71 + 80)), (int8x16_t)v76);
    v81 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v79, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v71 + 96), (int8x16_t)vcgtq_f32(v75, v79))), *(float32x4_t *)(v71 + 112));
    v82 = (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v80, *(float32x4_t *)(v71 + 128)));
    v83 = vaddq_f32(v81, v82);
    v84 = vsubq_f32(vsubq_f32(v80, v76), vmulq_f32(vmulq_f32(*(float32x4_t *)(v71 + 144), v82), v80));
    v85 = vmaxq_f32(vmulq_f32(v72, vaddq_f32(v83, vmulq_f32(v84, vaddq_f32(vaddq_f32(*(float32x4_t *)(v71 + 192), vmulq_f32(*(float32x4_t *)(v71 + 208), v84)), vmulq_f32(vmulq_f32(v84, v84), vaddq_f32(*(float32x4_t *)(v71 + 160), vmulq_f32(*(float32x4_t *)(v71 + 176), v84))))))), *(float32x4_t *)(v71 + 224));
    v86 = vcvtq_f32_s32(vcvtq_s32_f32(v85));
    v87 = vsubq_f32(v86, (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v86, v85)));
    v88 = vsubq_f32(v85, v87);
    v89 = (int32x4_t)vbslq_s8(v78, (int8x16_t)vmulq_f32(vaddq_f32(v76, vmulq_f32(v88, vaddq_f32(*(float32x4_t *)(v71 + 272), vmulq_f32(v88, vaddq_f32(*(float32x4_t *)(v71 + 240), vmulq_f32(*(float32x4_t *)(v71 + 256), v88)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v71 + 288), vcvtq_s32_f32(v87)), 0x17uLL)), v77);
    *(int8x16_t *)(v5 + v69) = vbslq_s8(*(int8x16_t *)(v71 + 320), (int8x16_t)v70, (int8x16_t)vmulq_n_f32(v70, vmulq_lane_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v89), *(float32x4_t *)(v71 + 304)), (int8x16_t)v89, *(int8x16_t *)(v71 + 304)), *(float32x2_t *)v72.f32, 1).f32[0]));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2100_HLG_OOTF_InverseOOTF::GetDOD(HgcBT2100_HLG_OOTF_InverseOOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBT2100_HLG_OOTF_InverseOOTF::GetROI(HgcBT2100_HLG_OOTF_InverseOOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBT2100_HLG_OOTF_InverseOOTF::HgcBT2100_HLG_OOTF_InverseOOTF(HgcBT2100_HLG_OOTF_InverseOOTF *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E654A300;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = xmmword_1B3051840;
  *(_OWORD *)(v3 + 48) = xmmword_1B30520F0;
  *(_OWORD *)(v3 + 64) = xmmword_1B3050E20;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051830;
  *(_OWORD *)(v3 + 96) = xmmword_1B3051850;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051860;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051870;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051880;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051890;
  *(_OWORD *)(v3 + 176) = xmmword_1B30518A0;
  *(_OWORD *)(v3 + 192) = xmmword_1B30518B0;
  *(_OWORD *)(v3 + 208) = xmmword_1B30518C0;
  *(_OWORD *)(v3 + 224) = xmmword_1B30518D0;
  *(_OWORD *)(v3 + 240) = xmmword_1B30518E0;
  *(_OWORD *)(v3 + 256) = xmmword_1B30518F0;
  *(_OWORD *)(v3 + 272) = xmmword_1B3051900;
  *(_OWORD *)(v3 + 288) = xmmword_1B3051910;
  *(_QWORD *)(v3 + 304) = 0;
  *(_QWORD *)(v3 + 312) = 0;
  *(_OWORD *)(v3 + 320) = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BF061C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_HLG_OOTF_InverseOOTF::~HgcBT2100_HLG_OOTF_InverseOOTF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E654A300;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4055B0EC01);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E654A300;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4055B0EC01);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_HLG_OOTF_InverseOOTF::SetParameter(HgcBT2100_HLG_OOTF_InverseOOTF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_HLG_OOTF_InverseOOTF::GetParameter(HgcBT2100_HLG_OOTF_InverseOOTF *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcLogVideo_encode::GetProgram(HgcLogVideo_encode *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003ea\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, half3(hg_Params[1].zzz));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = r0.xyz*half3(hg_Params[1].xxx) + half3(hg_Params[1].yyy);\n"
             "    r1.xyz = log2(r1.xyz);\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].zzz) + half3(hg_Params[0].www);\n"
             "    r0.xyz = half3(half3(hg_Params[1].zzz) < r0.xyz);\n"
             "    output.color0.xyz = select(float3(r2.xyz), float3(r1.xyz), -float3(r0.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=673f7309:ded9e39a:b9dc90f8:646914fe\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000038e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, hg_Params[1].zzz);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = r0.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
             "    r1.xyz = log2(r1.xyz);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].zzz + hg_Params[0].www;\n"
             "    r0.xyz = float3(hg_Params[1].zzz < r0.xyz);\n"
             "    output.color0.xyz = select(r2.xyz, r1.xyz, -r0.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=946613bc:8b4d9cc6:754ac3fe:09391315\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, hg_ProgramLocal1.zzz);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = r0.xyz*hg_ProgramLocal1.xxx + hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = log2(r1.xyz);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.zzz + hg_ProgramLocal0.www;\n"
           "    r0.xyz = vec3(lessThan(hg_ProgramLocal1.zzz, r0.xyz));\n"
           "    gl_FragColor.xyz = vec3(-r0.x < 0.00000 ? r1.x : r2.x, -r0.y < 0.00000 ? r1.y : r2.y, -r0.z < 0.00000 ? r"
           "1.z : r2.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=c36f7dfa:e07ee2fc:60dd5881:8caa6da6\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcLogVideo_encode::InitProgramDescriptor(HgcLogVideo_encode *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcLogVideo_encode_hgc_visible", "//Metal1.0     \n//LEN=000000026a\n[[ visible ]] FragmentOut HgcLogVideo_encode_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, hg_Params[1].zzz);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = r0.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
    "    r1.xyz = log2(r1.xyz);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].zzz + hg_Params[0].www;\n"
    "    r0.xyz = float3(hg_Params[1].zzz < r0.xyz);\n"
    "    output.color0.xyz = select(r2.xyz, r1.xyz, -r0.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BF0A30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BF0A60(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BF0A58);
}

double HgcLogVideo_encode::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcLogVideo_encode [hgc1]");
  return *(double *)"eo_encode [hgc1]";
}

uint64_t HgcLogVideo_encode::BindTexture(HgcLogVideo_encode *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcLogVideo_encode::Bind(HgcLogVideo_encode *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcLogVideo_encode *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcLogVideo_encode::RenderTile(HgcLogVideo_encode *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  _OWORD *v13;
  int32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int8x16_t v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  int8x16_t v52;
  int8x16_t v53;
  float32x4_t v54;
  float32x4_t v55;
  int8x16_t v56;
  int8x16_t *v57;
  int v58;
  uint64_t v59;
  float32x4_t v60;
  _OWORD *v61;
  int32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v58 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v12 = *(float32x4_t *)(v6 + v10 - 16);
      v11 = *(float32x4_t *)(v6 + v10);
      v13 = (_OWORD *)*((_QWORD *)this + 51);
      v14 = *((int32x4_t *)v13 + 1);
      v15 = (float32x4_t)vdupq_laneq_s32(v14, 2);
      v16 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 1);
      v17 = vaddq_f32(v16, vmulq_n_f32(vmaxq_f32(v12, v15), COERCE_FLOAT(*v13)));
      v18 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.i8, 1);
      v19 = vaddq_f32(v16, vmulq_n_f32(vmaxq_f32(v11, v15), COERCE_FLOAT(*v13)));
      v20 = (int8x16_t)vaddq_f32(v18, vmulq_n_f32(v12, *(float *)v14.i32));
      v21 = vmulq_n_f32(v11, *(float *)v14.i32);
      v23 = *((int8x16_t *)v13 + 2);
      v22 = *((float32x4_t *)v13 + 3);
      v24 = (float32x4_t)vorrq_s8(vandq_s8(v23, (int8x16_t)v17), (int8x16_t)v22);
      v25 = *((float32x4_t *)v13 + 4);
      v26 = *((int8x16_t *)v13 + 5);
      v27 = (float32x4_t)vorrq_s8(vandq_s8(v23, (int8x16_t)v19), (int8x16_t)v22);
      v28 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v25, v17)));
      v29 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v25, v19)));
      v30 = *((float32x4_t *)v13 + 6);
      v31 = *((float32x4_t *)v13 + 7);
      v32 = vsubq_f32(v28, v30);
      v33 = vsubq_f32(v29, v30);
      v34 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v24, v31));
      v35 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v27, v31));
      v36 = *((float32x4_t *)v13 + 8);
      v37 = *((float32x4_t *)v13 + 9);
      v38 = vaddq_f32(v33, v35);
      v39 = vsubq_f32(vsubq_f32(v24, v22), vmulq_f32(vmulq_f32(v36, v34), v24));
      v40 = vsubq_f32(vsubq_f32(v27, v22), vmulq_f32(vmulq_f32(v36, v35), v27));
      v41 = *((float32x4_t *)v13 + 10);
      v42 = *((float32x4_t *)v13 + 11);
      v43 = vaddq_f32(v37, vmulq_f32(v41, v39));
      v44 = vaddq_f32(v37, vmulq_f32(v41, v40));
      v45 = *((float32x4_t *)v13 + 12);
      v46 = *((int8x16_t *)v13 + 13);
      v47 = (int8x16_t)vaddq_f32(v18, v21);
      v48 = vaddq_f32(vaddq_f32(v32, v34), vmulq_f32(v39, vaddq_f32(vaddq_f32(v42, vmulq_f32(v45, v39)), vmulq_f32(vmulq_f32(v39, v39), v43))));
      v49 = vmulq_f32(v40, vaddq_f32(vaddq_f32(v42, vmulq_f32(v45, v40)), vmulq_f32(vmulq_f32(v40, v40), v44)));
      v50 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v13, 3);
      v51 = vmulq_laneq_f32(vaddq_f32(v38, v49), *(float32x4_t *)v13, 2);
      v52 = (int8x16_t)vcgtq_f32(v12, v15);
      v53 = vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v11, v15));
      v54 = (float32x4_t)vbslq_s8(v46, (int8x16_t)v12, vandq_s8((int8x16_t)v22, v52));
      v55 = *((float32x4_t *)v13 + 14);
      v56 = vbslq_s8(v46, (int8x16_t)v12, vbslq_s8((int8x16_t)vcgtq_f32(v54, v55), (int8x16_t)vaddq_f32(v50, vmulq_laneq_f32(v48, *(float32x4_t *)v13, 2)), v20));
      v57 = (int8x16_t *)(v5 + v10);
      v57[-1] = v56;
      *v57 = vbslq_s8(v46, (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v46, (int8x16_t)v11, v53), v55), (int8x16_t)vaddq_f32(v50, v51), v47));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v58 = -v9;
    if (v58 >= v4)
      goto LABEL_3;
LABEL_10:
    v59 = 16 * v58;
    v60 = *(float32x4_t *)(v6 + v59);
    v61 = (_OWORD *)*((_QWORD *)this + 51);
    v62 = *((int32x4_t *)v61 + 1);
    v63 = (float32x4_t)vdupq_laneq_s32(v62, 2);
    v64 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v61, 1), vmulq_n_f32(vmaxq_f32(v60, v63), COERCE_FLOAT(*v61)));
    v65 = *((float32x4_t *)v61 + 3);
    v66 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)v61 + 2), (int8x16_t)v64), (int8x16_t)v65);
    v67 = (float32x4_t)vandq_s8((int8x16_t)v65, (int8x16_t)vcgtq_f32(v66, *((float32x4_t *)v61 + 7)));
    v68 = vsubq_f32(vsubq_f32(v66, v65), vmulq_f32(vmulq_f32(*((float32x4_t *)v61 + 8), v67), v66));
    *(int8x16_t *)(v5 + v59) = vbslq_s8(*((int8x16_t *)v61 + 13), (int8x16_t)v60, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)v61 + 13), (int8x16_t)v60, vandq_s8((int8x16_t)v65, (int8x16_t)vcgtq_f32(v60, v63))), *((float32x4_t *)v61 + 14)), (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v61, 3), vmulq_laneq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v64, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)v61 + 5),
                                                                         (int8x16_t)vcgtq_f32(*((float32x4_t *)v61 + 4), v64))), *((float32x4_t *)v61 + 6)), v67), vmulq_f32(v68, vaddq_f32(vaddq_f32(*((float32x4_t *)v61 + 11), vmulq_f32(*((float32x4_t *)v61 + 12), v68)), vmulq_f32(vmulq_f32(v68, v68), vaddq_f32(*((float32x4_t *)v61 + 9), vmulq_f32(*((float32x4_t *)v61 + 10), v68)))))), *(float32x4_t *)v61, 2)), (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v62.i8, 1),
                                                vmulq_n_f32(v60, *(float *)v62.i32))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcLogVideo_encode::GetDOD(HgcLogVideo_encode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcLogVideo_encode::GetROI(HgcLogVideo_encode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcLogVideo_encode::HgcLogVideo_encode(HgcLogVideo_encode *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E654A568;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = xmmword_1B3051600;
  *(_OWORD *)(v3 + 48) = xmmword_1B3051560;
  *(_OWORD *)(v3 + 64) = xmmword_1B3051610;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051620;
  *(_OWORD *)(v3 + 96) = xmmword_1B3051630;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051640;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051510;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051650;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051660;
  *(_OWORD *)(v3 + 176) = xmmword_1B3051670;
  *(_OWORD *)(v3 + 192) = xmmword_1B3051680;
  *(_OWORD *)(v3 + 208) = xmmword_1B3050F70;
  *(_QWORD *)(v3 + 224) = 0;
  *(_QWORD *)(v3 + 232) = 0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BF0FE4(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcLogVideo_encode::~HgcLogVideo_encode(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E654A568;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4019FCA701);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E654A568;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4019FCA701);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcLogVideo_encode::SetParameter(HgcLogVideo_encode *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcLogVideo_encode::GetParameter(HgcLogVideo_encode *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcLogVideo_decode::GetProgram(HgcLogVideo_decode *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003b6\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*half3(hg_Params[0].zzz) + half3(hg_Params[0].www);\n"
             "    r2.xyz = r0.xyz*half3(hg_Params[1].xxx) + half3(hg_Params[1].yyy);\n"
             "    r1.xyz = exp2(r1.xyz);\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r0.xyz = half3(half3(hg_Params[1].zzz) < r0.xyz);\n"
             "    output.color0.xyz = select(float3(r2.xyz), float3(r1.xyz), -float3(r0.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=89281f2e:27643c8f:eb416052:f572fac4\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000361\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*hg_Params[0].zzz + hg_Params[0].www;\n"
             "    r2.xyz = r0.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
             "    r1.xyz = exp2(r1.xyz);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r0.xyz = float3(hg_Params[1].zzz < r0.xyz);\n"
             "    output.color0.xyz = select(r2.xyz, r1.xyz, -r0.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6fc31554:61839044:78b681d8:1e3d981b\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003a9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz*hg_ProgramLocal0.zzz + hg_ProgramLocal0.www;\n"
           "    r2.xyz = r0.xyz*hg_ProgramLocal1.xxx + hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = exp2(r1.xyz);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r0.xyz = vec3(lessThan(hg_ProgramLocal1.zzz, r0.xyz));\n"
           "    gl_FragColor.xyz = vec3(-r0.x < 0.00000 ? r1.x : r2.x, -r0.y < 0.00000 ? r1.y : r2.y, -r0.z < 0.00000 ? r"
           "1.z : r2.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=0d96987c:05a426f8:85bbe0c4:660414d1\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcLogVideo_decode::InitProgramDescriptor(HgcLogVideo_decode *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcLogVideo_decode_hgc_visible", "//Metal1.0     \n//LEN=000000023d\n[[ visible ]] FragmentOut HgcLogVideo_decode_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz*hg_Params[0].zzz + hg_Params[0].www;\n"
    "    r2.xyz = r0.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
    "    r1.xyz = exp2(r1.xyz);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r0.xyz = float3(hg_Params[1].zzz < r0.xyz);\n"
    "    output.color0.xyz = select(r2.xyz, r1.xyz, -r0.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BF13F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BF1428(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BF1420);
}

double HgcLogVideo_decode::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcLogVideo_decode [hgc1]");
  return *(double *)"eo_decode [hgc1]";
}

uint64_t HgcLogVideo_decode::BindTexture(HgcLogVideo_decode *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcLogVideo_decode::Bind(HgcLogVideo_decode *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcLogVideo_decode *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcLogVideo_decode::RenderTile(HgcLogVideo_decode *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  _OWORD *v13;
  int32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  int8x16_t v41;
  int8x16_t v42;
  int8x16_t v43;
  int8x16_t v44;
  float32x4_t v45;
  int8x16_t *v46;
  int v47;
  uint64_t v48;
  float32x4_t v49;
  _OWORD *v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v47 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v12 = *(float32x4_t *)(v6 + v10 - 16);
      v11 = *(float32x4_t *)(v6 + v10);
      v13 = (_OWORD *)*((_QWORD *)this + 51);
      v14 = *((int32x4_t *)v13 + 1);
      v15 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v13, 3);
      v16 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.i8, 1);
      v17 = (int8x16_t)vaddq_f32(v16, vmulq_n_f32(v12, *(float *)v14.i32));
      v18 = (int8x16_t)vaddq_f32(v16, vmulq_n_f32(v11, *(float *)v14.i32));
      v19 = *((float32x4_t *)v13 + 2);
      v20 = *((float32x4_t *)v13 + 3);
      v21 = vmaxq_f32(vaddq_f32(v15, vmulq_laneq_f32(v12, *(float32x4_t *)v13, 2)), v19);
      v22 = vmaxq_f32(vaddq_f32(v15, vmulq_laneq_f32(v11, *(float32x4_t *)v13, 2)), v19);
      v23 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
      v24 = vcvtq_f32_s32(vcvtq_s32_f32(v22));
      v25 = vsubq_f32(v23, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v23, v21)));
      v26 = vsubq_f32(v24, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v24, v22)));
      v27 = vsubq_f32(v21, v25);
      v28 = vsubq_f32(v22, v26);
      v29 = *((float32x4_t *)v13 + 4);
      v30 = *((float32x4_t *)v13 + 5);
      v31 = vaddq_f32(v29, vmulq_f32(v30, v27));
      v32 = vaddq_f32(v29, vmulq_f32(v30, v28));
      v33 = vmulq_f32(v27, v31);
      v34 = *((float32x4_t *)v13 + 6);
      v35 = *((int32x4_t *)v13 + 7);
      v36 = vmulq_f32(vaddq_f32(v20, vmulq_f32(v27, vaddq_f32(v34, v33))), (float32x4_t)vshlq_n_s32(vaddq_s32(v35, vcvtq_s32_f32(v25)), 0x17uLL));
      v37 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 1);
      v38 = vmulq_n_f32(vmulq_f32(vaddq_f32(v20, vmulq_f32(v28, vaddq_f32(v34, vmulq_f32(v28, v32)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v35, vcvtq_s32_f32(v26)), 0x17uLL)), COERCE_FLOAT(*v13));
      v39 = (int8x16_t)vaddq_f32(v37, vmulq_n_f32(v36, COERCE_FLOAT(*v13)));
      v40 = (float32x4_t)vdupq_laneq_s32(v14, 2);
      v41 = vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v12, v40));
      v42 = (int8x16_t)vaddq_f32(v37, v38);
      v43 = vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v11, v40));
      v44 = *((int8x16_t *)v13 + 8);
      v45 = *((float32x4_t *)v13 + 9);
      v46 = (int8x16_t *)(v5 + v10);
      v46[-1] = vbslq_s8(v44, (int8x16_t)v12, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v44, (int8x16_t)v12, v41), v45), v39, v17));
      *v46 = vbslq_s8(v44, (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v44, (int8x16_t)v11, v43), v45), v42, v18));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v47 = -v9;
    if (v47 >= v4)
      goto LABEL_3;
LABEL_10:
    v48 = 16 * v47;
    v49 = *(float32x4_t *)(v6 + v48);
    v50 = (_OWORD *)*((_QWORD *)this + 51);
    v51 = *((float32x4_t *)v50 + 3);
    v52 = vmaxq_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v50, 3), vmulq_laneq_f32(v49, *(float32x4_t *)v50, 2)), *((float32x4_t *)v50 + 2));
    v53 = vcvtq_f32_s32(vcvtq_s32_f32(v52));
    v54 = vsubq_f32(v53, (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v53, v52)));
    v55 = vsubq_f32(v52, v54);
    *(int8x16_t *)(v5 + v48) = vbslq_s8(*((int8x16_t *)v50 + 8), (int8x16_t)v49, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)v50 + 8), (int8x16_t)v49, vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v49, (float32x4_t)vdupq_laneq_s32(*((int32x4_t *)v50 + 1), 2)))), *((float32x4_t *)v50 + 9)), (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50, 1), vmulq_n_f32(vmulq_f32(
                                                    vaddq_f32(v51, vmulq_f32(v55, vaddq_f32(*((float32x4_t *)v50 + 6), vmulq_f32(v55, vaddq_f32(*((float32x4_t *)v50 + 4), vmulq_f32(*((float32x4_t *)v50 + 5), v55)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)v50 + 7), vcvtq_s32_f32(v54)), 0x17uLL)), COERCE_FLOAT(*v50))), (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)v50[1], 1), vmulq_n_f32(v49, COERCE_FLOAT(v50[1])))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcLogVideo_decode::GetDOD(HgcLogVideo_decode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcLogVideo_decode::GetROI(HgcLogVideo_decode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcLogVideo_decode::HgcLogVideo_decode(HgcLogVideo_decode *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E654A7D0;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = xmmword_1B3051690;
  *(_OWORD *)(v3 + 48) = xmmword_1B3051560;
  *(_OWORD *)(v3 + 64) = xmmword_1B30516A0;
  *(_OWORD *)(v3 + 80) = xmmword_1B30516B0;
  *(_OWORD *)(v3 + 96) = xmmword_1B30516C0;
  *(_OWORD *)(v3 + 112) = xmmword_1B30516D0;
  *(_OWORD *)(v3 + 128) = xmmword_1B3050F70;
  *(_QWORD *)(v3 + 144) = 0;
  *(_QWORD *)(v3 + 152) = 0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BF1900(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcLogVideo_decode::~HgcLogVideo_decode(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E654A7D0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B8406A4ELL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E654A7D0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B8406A4ELL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcLogVideo_decode::SetParameter(HgcLogVideo_decode *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcLogVideo_decode::GetParameter(HgcLogVideo_decode *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcSony709_800_MLUT::GetProgram(HgcSony709_800_MLUT *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000056b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[0].xxx);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[2].xxx);\n"
             "    r3.xyz = r0.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].www));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[1].yyy) + half3(hg_Params[1].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[2].zzz) + c0.yyy;\n"
             "    r1.xyz = r1.xyz - r3.xyz;\n"
             "    r5.xyz = half3(r0.xyz >= half3(hg_Params[0].yyy));\n"
             "    r5.xyz = r5.xyz*r1.xyz + r3.xyz;\n"
             "    r4.xyz = half3(hg_Params[1].www)/r4.xyz;\n"
             "    r2.xyz = pow(r2.xyz, r4.xyz);\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[2].yyy) + -r5.xyz;\n"
             "    r0.xyz = half3(r0.xyz >= half3(hg_Params[0].zzz));\n"
             "    output.color0.xyz = float3(r0.xyz)*float3(r2.xyz) + float3(r5.xyz);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=7b171a2a:157267ef:87e4d2e2:1035cfc2\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0006:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004fd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = r0.xyz + hg_Params[0].xxx;\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz*hg_Params[2].xxx;\n"
             "    r3.xyz = r0.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].www);\n"
             "    r1.xyz = r1.xyz*hg_Params[1].yyy + hg_Params[1].zzz;\n"
             "    r4.xyz = r2.xyz*hg_Params[2].zzz + c0.yyy;\n"
             "    r1.xyz = r1.xyz - r3.xyz;\n"
             "    r5.xyz = float3(r0.xyz >= hg_Params[0].yyy);\n"
             "    r5.xyz = r5.xyz*r1.xyz + r3.xyz;\n"
             "    r4.xyz = hg_Params[1].www/r4.xyz;\n"
             "    r2.xyz = pow(r2.xyz, r4.xyz);\n"
             "    r2.xyz = r2.xyz*hg_Params[2].yyy + -r5.xyz;\n"
             "    r0.xyz = float3(r0.xyz >= hg_Params[0].zzz);\n"
             "    output.color0.xyz = r0.xyz*r2.xyz + r5.xyz;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=33f92460:9b78ada8:8b346e0c:2f6489c6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0006:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000055d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal0.xxx;\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal2.xxx;\n"
           "    r3.xyz = r0.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.www);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal1.yyy + hg_ProgramLocal1.zzz;\n"
           "    r4.xyz = r2.xyz*hg_ProgramLocal2.zzz + c0.yyy;\n"
           "    r1.xyz = r1.xyz - r3.xyz;\n"
           "    r5.xyz = vec3(greaterThanEqual(r0.xyz, hg_ProgramLocal0.yyy));\n"
           "    r5.xyz = r5.xyz*r1.xyz + r3.xyz;\n"
           "    r4.xyz = hg_ProgramLocal1.www/r4.xyz;\n"
           "    r2.xyz = pow(r2.xyz, r4.xyz);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal2.yyy + -r5.xyz;\n"
           "    r0.xyz = vec3(greaterThanEqual(r0.xyz, hg_ProgramLocal0.zzz));\n"
           "    gl_FragColor.xyz = r0.xyz*r2.xyz + r5.xyz;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=c888713c:7accba57:13c6ff48:9a1ff1c4\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0006:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcSony709_800_MLUT::InitProgramDescriptor(HgcSony709_800_MLUT *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcSony709_800_MLUT_hgc_visible", "//Metal1.0     \n//LEN=00000003da\n[[ visible ]] FragmentOut HgcSony709_800_MLUT_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = r0.xyz + hg_Params[0].xxx;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r2.xyz = r1.xyz*hg_Params[2].xxx;\n"
    "    r3.xyz = r0.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].www);\n"
    "    r1.xyz = r1.xyz*hg_Params[1].yyy + hg_Params[1].zzz;\n"
    "    r4.xyz = r2.xyz*hg_Params[2].zzz + c0.yyy;\n"
    "    r1.xyz = r1.xyz - r3.xyz;\n"
    "    r5.xyz = float3(r0.xyz >= hg_Params[0].yyy);\n"
    "    r5.xyz = r5.xyz*r1.xyz + r3.xyz;\n"
    "    r4.xyz = hg_Params[1].www/r4.xyz;\n"
    "    r2.xyz = pow(r2.xyz, r4.xyz);\n"
    "    r2.xyz = r2.xyz*hg_Params[2].yyy + -r5.xyz;\n"
    "    r0.xyz = float3(r0.xyz >= hg_Params[0].zzz);\n"
    "    output.color0.xyz = r0.xyz*r2.xyz + r5.xyz;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BF1D14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BF1D44(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BF1D3CLL);
}

double HgcSony709_800_MLUT::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3554550;
  strcpy(v3, "HgcSony709_800_MLUT [hgc1]");
  return *(double *)"_800_MLUT [hgc1]";
}

uint64_t HgcSony709_800_MLUT::BindTexture(HgcSony709_800_MLUT *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcSony709_800_MLUT::Bind(HgcSony709_800_MLUT *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HgcSony709_800_MLUT *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcSony709_800_MLUT::RenderTile(HgcSony709_800_MLUT *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  int32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  int8x16_t *v110;
  int v111;
  uint64_t v112;
  float32x4_t v113;
  uint64_t v114;
  float32x4_t v115;
  int8x16_t v116;
  float32x4_t v117;
  float32x4_t v118;
  int8x16_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  int8x16_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  int32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v111 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v11 = *(float32x4_t *)(v6 + v10 - 16);
      v12 = *(float32x4_t *)(v6 + v10);
      v13 = *((_QWORD *)this + 51);
      v14 = *(float32x4_t *)(v13 + 16);
      v15 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 0);
      v17 = *(float32x4_t *)(v13 + 32);
      v16 = *(int8x16_t *)(v13 + 48);
      v18 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v11, (int8x16_t)vaddq_f32(v11, v15));
      v19 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v12, (int8x16_t)vaddq_f32(v12, v15));
      v20 = *(float32x4_t *)(v13 + 64);
      v21 = *(int8x16_t *)(v13 + 80);
      v22 = vmaxq_f32(v18, v20);
      v23 = vmaxq_f32(v19, v20);
      v24 = vmulq_n_f32(v22, v17.f32[0]);
      v25 = vmulq_n_f32(v23, v17.f32[0]);
      v26 = *(float32x4_t *)(v13 + 96);
      v27 = *(float32x4_t *)(v13 + 112);
      v28 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v22), (int8x16_t)v26);
      v30 = *(int8x16_t *)(v13 + 128);
      v29 = *(float32x4_t *)(v13 + 144);
      v31 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v23), (int8x16_t)v26);
      v32 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(v30, (int8x16_t)vcgtq_f32(v27, v23))), v29);
      v34 = *(float32x4_t *)(v13 + 160);
      v33 = *(float32x4_t *)(v13 + 176);
      v35 = (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v28, v34));
      v36 = (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v31, v34));
      v37 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v22, 0x17uLL)), (float32x4_t)vandq_s8(v30, (int8x16_t)vcgtq_f32(v27, v22))), v29), v35);
      v38 = vmulq_f32(v33, v35);
      v39 = vmulq_f32(vmulq_f32(v33, v36), v31);
      v40 = vaddq_f32(v32, v36);
      v41 = vsubq_f32(v31, v26);
      v42 = vsubq_f32(vsubq_f32(v28, v26), vmulq_f32(v38, v28));
      v43 = vsubq_f32(v41, v39);
      v44 = *(float32x4_t *)(v13 + 192);
      v45 = *(float32x4_t *)(v13 + 208);
      v46 = *(float32x4_t *)(v13 + 224);
      v47 = *(float32x4_t *)(v13 + 240);
      v48 = vaddq_f32(v37, vmulq_f32(v42, vaddq_f32(vaddq_f32(v46, vmulq_f32(v42, v47)), vmulq_f32(vmulq_f32(v42, v42), vaddq_f32(v44, vmulq_f32(v45, v42))))));
      v49 = vaddq_f32(v26, vmulq_laneq_f32(v24, v17, 2));
      v50 = vaddq_f32(v26, vmulq_laneq_f32(v25, v17, 2));
      v51 = vaddq_f32(v40, vmulq_f32(v43, vaddq_f32(vaddq_f32(v46, vmulq_f32(v43, v47)), vmulq_f32(vmulq_f32(v43, v43), vaddq_f32(v44, vmulq_f32(v45, v43))))));
      v52 = *(float32x4_t *)(v13 + 336);
      v53 = vmulq_f32(vrecpeq_f32(v49), v52);
      v54 = vmulq_f32(vrecpeq_f32(v50), v52);
      v55 = *(float32x4_t *)(v13 + 352);
      v56 = *(float32x4_t *)(v13 + 368);
      v57 = vminq_f32(vmaxq_f32(v53, v55), v56);
      v58 = vminq_f32(vmaxq_f32(v54, v55), v56);
      v59 = vmulq_laneq_f32(v51, v14, 3);
      v60 = vmulq_f32(v57, vrecpsq_f32(v49, v57));
      v61 = *(float32x4_t *)(v13 + 256);
      v62 = *(float32x4_t *)(v13 + 272);
      v63 = vmaxq_f32(vmulq_laneq_f32(v48, v14, 3), v61);
      v64 = vmulq_f32(v58, vrecpsq_f32(v50, v58));
      v65 = (float32x4_t)vandq_s8(v30, (int8x16_t)vcgtq_f32(v27, v24));
      v66 = (float32x4_t)vandq_s8(v30, (int8x16_t)vcgtq_f32(v27, v25));
      v67 = vmaxq_f32(v59, v61);
      v68 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v24), (int8x16_t)v26);
      v69 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v25), (int8x16_t)v26);
      v70 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x17uLL)), v65), v29);
      v71 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v25, 0x17uLL)), v66), v29);
      v72 = (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v68, v34));
      v73 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
      v74 = (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v69, v34));
      v75 = vaddq_f32(v70, v72);
      v76 = vaddq_f32(v71, v74);
      v77 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
      v78 = vsubq_f32(vsubq_f32(v68, v26), vmulq_f32(vmulq_f32(v33, v72), v68));
      v79 = vsubq_f32(vsubq_f32(v69, v26), vmulq_f32(vmulq_f32(v33, v74), v69));
      v80 = vsubq_f32(v73, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v73, v63)));
      v81 = vaddq_f32(v44, vmulq_f32(v45, v78));
      v82 = vaddq_f32(v44, vmulq_f32(v45, v79));
      v84 = *(float32x4_t *)(v13 + 288);
      v83 = *(float32x4_t *)(v13 + 304);
      v85 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v77, v67)));
      v86 = vsubq_f32(v63, v80);
      v87 = vsubq_f32(v67, v85);
      v88 = vaddq_f32(v75, vmulq_f32(v78, vaddq_f32(vaddq_f32(v46, vmulq_f32(v78, v47)), vmulq_f32(vmulq_f32(v78, v78), v81))));
      v89 = vmulq_f32(v87, vaddq_f32(v83, vmulq_f32(v87, vaddq_f32(v62, vmulq_f32(v84, v87)))));
      v90 = *(int32x4_t *)(v13 + 320);
      v91 = vmulq_f32(vaddq_f32(v26, v89), (float32x4_t)vshlq_n_s32(vaddq_s32(v90, vcvtq_s32_f32(v85)), 0x17uLL));
      v92 = vmulq_n_f32(v18, v14.f32[0]);
      v93 = vaddq_f32(v76, vmulq_f32(v79, vaddq_f32(vaddq_f32(v46, vmulq_f32(v79, v47)), vmulq_f32(vmulq_f32(v79, v79), v82))));
      v94 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2);
      v95 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 1);
      v96 = vaddq_f32(v94, vmulq_lane_f32(vmulq_f32(vaddq_f32(v26, vmulq_f32(v86, vaddq_f32(v83, vmulq_f32(v86, vaddq_f32(v62, vmulq_f32(v84, v86)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v90, vcvtq_s32_f32(v80)), 0x17uLL)), *(float32x2_t *)v14.f32, 1));
      v97 = vmaxq_f32(vmulq_f32(v88, vmulq_laneq_f32(v60, v14, 3)), v61);
      v98 = vmaxq_f32(vmulq_f32(v93, vmulq_laneq_f32(v64, v14, 3)), v61);
      v99 = vaddq_f32(v94, vmulq_lane_f32(v91, *(float32x2_t *)v14.f32, 1));
      v100 = vcvtq_f32_s32(vcvtq_s32_f32(v97));
      v101 = vcvtq_f32_s32(vcvtq_s32_f32(v98));
      v102 = vsubq_f32(v100, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v100, v97)));
      v103 = vsubq_f32(v101, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v101, v98)));
      v104 = vmulq_n_f32(v19, v14.f32[0]);
      v105 = vsubq_f32(v97, v102);
      v106 = vsubq_f32(v98, v103);
      v107 = vaddq_f32(v92, vmulq_f32((float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgeq_f32(v18, v95)), vsubq_f32(v96, v92)));
      v108 = vaddq_f32(v104, vmulq_f32((float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgeq_f32(v19, v95)), vsubq_f32(v99, v104)));
      v109 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v13, 2);
      v110 = (int8x16_t *)(v5 + v10);
      v110[-1] = vbslq_s8(v16, (int8x16_t)v11, (int8x16_t)vaddq_f32(v107, vmulq_f32(vsubq_f32(vmulq_lane_f32(vmulq_f32(vaddq_f32(v26, vmulq_f32(v105, vaddq_f32(v83, vmulq_f32(v105, vaddq_f32(v62, vmulq_f32(v84, v105)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v102), v90), 0x17uLL)), *(float32x2_t *)v17.f32, 1), v107), (float32x4_t)vbslq_s8(v16,
                                                 (int8x16_t)v11,
                                                 vandq_s8((int8x16_t)v26, (int8x16_t)vcgeq_f32(v18, v109))))));
      *v110 = vbslq_s8(v16, (int8x16_t)v12, (int8x16_t)vaddq_f32(v108, vmulq_f32(vsubq_f32(vmulq_lane_f32(vmulq_f32(vaddq_f32(v26, vmulq_f32(v106, vaddq_f32(v83, vmulq_f32(v106, vaddq_f32(v62, vmulq_f32(v84, v106)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v103), v90), 0x17uLL)), *(float32x2_t *)v17.f32, 1), v108), (float32x4_t)vbslq_s8(v16,
                                              (int8x16_t)v12,
                                              vandq_s8((int8x16_t)v26, (int8x16_t)vcgeq_f32(v19, v109))))));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v111 = -v9;
    if (v111 >= v4)
      goto LABEL_3;
LABEL_10:
    v112 = 16 * v111;
    v113 = *(float32x4_t *)(v6 + v112);
    v114 = *((_QWORD *)this + 51);
    v115 = *(float32x4_t *)(v114 + 16);
    v117 = *(float32x4_t *)(v114 + 32);
    v116 = *(int8x16_t *)(v114 + 48);
    v118 = (float32x4_t)vbslq_s8(v116, (int8x16_t)v113, (int8x16_t)vaddq_f32(v113, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114, 0)));
    v119 = *(int8x16_t *)(v114 + 80);
    v120 = vmaxq_f32(v118, *(float32x4_t *)(v114 + 64));
    v121 = vmulq_n_f32(v120, v117.f32[0]);
    v122 = vmulq_n_f32(v118, v115.f32[0]);
    v123 = *(float32x4_t *)(v114 + 96);
    v124 = *(float32x4_t *)(v114 + 112);
    v125 = (float32x4_t)vorrq_s8(vandq_s8(v119, (int8x16_t)v120), (int8x16_t)v123);
    v126 = *(int8x16_t *)(v114 + 128);
    v127 = *(float32x4_t *)(v114 + 144);
    v128 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v120, 0x17uLL)), (float32x4_t)vandq_s8(v126, (int8x16_t)vcgtq_f32(v124, v120))), v127);
    v129 = *(float32x4_t *)(v114 + 160);
    v130 = *(float32x4_t *)(v114 + 176);
    v131 = (float32x4_t)vandq_s8((int8x16_t)v123, (int8x16_t)vcgtq_f32(v125, v129));
    v132 = vaddq_f32(v128, v131);
    v133 = vsubq_f32(vsubq_f32(v125, v123), vmulq_f32(vmulq_f32(v130, v131), v125));
    v134 = *(float32x4_t *)(v114 + 192);
    v135 = *(float32x4_t *)(v114 + 208);
    v136 = *(float32x4_t *)(v114 + 224);
    v137 = *(float32x4_t *)(v114 + 240);
    v138 = vmulq_laneq_f32(vaddq_f32(v132, vmulq_f32(v133, vaddq_f32(vaddq_f32(v136, vmulq_f32(v133, v137)), vmulq_f32(vmulq_f32(v133, v133), vaddq_f32(v134, vmulq_f32(v135, v133)))))), v115, 3);
    v139 = *(float32x4_t *)(v114 + 256);
    v140 = *(float32x4_t *)(v114 + 272);
    v141 = vmaxq_f32(v138, v139);
    v142 = vcvtq_f32_s32(vcvtq_s32_f32(v141));
    v143 = vsubq_f32(v142, (float32x4_t)vandq_s8((int8x16_t)v123, (int8x16_t)vcgtq_f32(v142, v141)));
    v144 = vsubq_f32(v141, v143);
    v146 = *(float32x4_t *)(v114 + 288);
    v145 = *(float32x4_t *)(v114 + 304);
    v147 = *(int32x4_t *)(v114 + 320);
    v148 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v115, 2), vmulq_lane_f32(vmulq_f32(vaddq_f32(v123, vmulq_f32(v144, vaddq_f32(v145, vmulq_f32(v144, vaddq_f32(v140, vmulq_f32(v146, v144)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v147, vcvtq_s32_f32(v143)), 0x17uLL)), *(float32x2_t *)v115.f32, 1));
    v149 = vaddq_f32(v123, vmulq_laneq_f32(v121, v117, 2));
    v150 = vaddq_f32(v122, vmulq_f32((float32x4_t)vandq_s8((int8x16_t)v123, (int8x16_t)vcgeq_f32(v118, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114, 1))), vsubq_f32(v148, v122)));
    v151 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v149), *(float32x4_t *)(v114 + 336)), *(float32x4_t *)(v114 + 352)), *(float32x4_t *)(v114 + 368));
    v152 = (float32x4_t)vorrq_s8(vandq_s8(v119, (int8x16_t)v121), (int8x16_t)v123);
    v153 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v121, 0x17uLL)), (float32x4_t)vandq_s8(v126, (int8x16_t)vcgtq_f32(v124, v121))), v127);
    v154 = (float32x4_t)vandq_s8((int8x16_t)v123, (int8x16_t)vcgtq_f32(v152, v129));
    v155 = vsubq_f32(vsubq_f32(v152, v123), vmulq_f32(vmulq_f32(v130, v154), v152));
    v156 = vmaxq_f32(vmulq_f32(vaddq_f32(vaddq_f32(v153, v154), vmulq_f32(v155, vaddq_f32(vaddq_f32(v136, vmulq_f32(v155, v137)), vmulq_f32(vmulq_f32(v155, v155), vaddq_f32(v134, vmulq_f32(v135, v155)))))), vmulq_laneq_f32(vmulq_f32(v151, vrecpsq_f32(v149, v151)), v115, 3)), v139);
    v157 = vcvtq_f32_s32(vcvtq_s32_f32(v156));
    v158 = vsubq_f32(v157, (float32x4_t)vandq_s8((int8x16_t)v123, (int8x16_t)vcgtq_f32(v157, v156)));
    v159 = vsubq_f32(v156, v158);
    *(int8x16_t *)(v5 + v112) = vbslq_s8(v116, (int8x16_t)v113, (int8x16_t)vaddq_f32(v150, vmulq_f32(vsubq_f32(vmulq_lane_f32(vmulq_f32(vaddq_f32(v123, vmulq_f32(v159, vaddq_f32(v145, vmulq_f32(v159, vaddq_f32(v140, vmulq_f32(v146, v159)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v158), v147), 0x17uLL)), *(float32x2_t *)v117.f32,
                                                     1),
                                                   v150),
                                                 (float32x4_t)vbslq_s8(v116, (int8x16_t)v113, vandq_s8((int8x16_t)v123, (int8x16_t)vcgeq_f32(v118, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v114, 2)))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcSony709_800_MLUT::GetDOD(HgcSony709_800_MLUT *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcSony709_800_MLUT::GetROI(HgcSony709_800_MLUT *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcSony709_800_MLUT::HgcSony709_800_MLUT(HgcSony709_800_MLUT *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E654AA38;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = xmmword_1B3050F70;
  *(_QWORD *)(v3 + 64) = 0;
  *(_QWORD *)(v3 + 72) = 0;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051600;
  *(_OWORD *)(v3 + 96) = xmmword_1B3051560;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051610;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051620;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051630;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051640;
  *(_OWORD *)(v3 + 176) = xmmword_1B3051510;
  *(_OWORD *)(v3 + 192) = xmmword_1B3051650;
  *(_OWORD *)(v3 + 208) = xmmword_1B3051660;
  *(_OWORD *)(v3 + 224) = xmmword_1B3051670;
  *(_OWORD *)(v3 + 240) = xmmword_1B3051680;
  *(_OWORD *)(v3 + 256) = xmmword_1B3051690;
  *(_OWORD *)(v3 + 272) = xmmword_1B30516A0;
  *(_OWORD *)(v3 + 288) = xmmword_1B30516B0;
  *(_OWORD *)(v3 + 304) = xmmword_1B30516C0;
  *(_OWORD *)(v3 + 320) = xmmword_1B30516D0;
  *(_OWORD *)(v3 + 336) = xmmword_1B3051BC0;
  *(_OWORD *)(v3 + 352) = xmmword_1B3052320;
  *(int32x4_t *)(v3 + 368) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BF2704(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcSony709_800_MLUT::~HgcSony709_800_MLUT(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E654AA38;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C400F47AF14);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E654AA38;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C400F47AF14);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcSony709_800_MLUT::SetParameter(HgcSony709_800_MLUT *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcSony709_800_MLUT::GetParameter(HgcSony709_800_MLUT *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcCanonLog_encode::GetProgram(HgcCanonLog_encode *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003cf\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz)*half3(hg_Params[0].zzz);\n"
             "    r2.xyz = half3(r0.xyz < c0.xxx);\n"
             "    r0.xyz = half3(c0.xxx < r0.xyz);\n"
             "    r0.xyz = r0.xyz - r2.xyz;\n"
             "    r1.xyz = r1.xyz + c0.yyy;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xxx);\n"
             "    r1.xyz = log2(r1.xyz);\n"
             "    output.color0.xyz = float3(r0.xyz)*float3(r1.xyz) + hg_Params[0].yyy;\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=3cb30ea7:184d1a1c:e362e55b:bc915a63\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003a8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz)*hg_Params[0].zzz;\n"
             "    r2.xyz = float3(r0.xyz < c0.xxx);\n"
             "    r0.xyz = float3(c0.xxx < r0.xyz);\n"
             "    r0.xyz = r0.xyz - r2.xyz;\n"
             "    r1.xyz = r1.xyz + c0.yyy;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xxx;\n"
             "    r1.xyz = log2(r1.xyz);\n"
             "    output.color0.xyz = r0.xyz*r1.xyz + hg_Params[0].yyy;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=24f0a63e:b72cd12f:57b86ae8:8b63bce0\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000038c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = abs(r0.xyz)*hg_ProgramLocal0.zzz;\n"
           "    r2.xyz = vec3(lessThan(r0.xyz, c0.xxx));\n"
           "    r0.xyz = vec3(lessThan(c0.xxx, r0.xyz));\n"
           "    r0.xyz = r0.xyz - r2.xyz;\n"
           "    r1.xyz = r1.xyz + c0.yyy;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xxx;\n"
           "    r1.xyz = log2(r1.xyz);\n"
           "    gl_FragColor.xyz = r0.xyz*r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=7914ca2c:7a3f0945:4a5f2d4f:23b380ff\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcCanonLog_encode::InitProgramDescriptor(HgcCanonLog_encode *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcCanonLog_encode_hgc_visible", "//Metal1.0     \n//LEN=0000000284\n[[ visible ]] FragmentOut HgcCanonLog_encode_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fabs(r0.xyz)*hg_Params[0].zzz;\n"
    "    r2.xyz = float3(r0.xyz < c0.xxx);\n"
    "    r0.xyz = float3(c0.xxx < r0.xyz);\n"
    "    r0.xyz = r0.xyz - r2.xyz;\n"
    "    r1.xyz = r1.xyz + c0.yyy;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xxx;\n"
    "    r1.xyz = log2(r1.xyz);\n"
    "    output.color0.xyz = r0.xyz*r1.xyz + hg_Params[0].yyy;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BF2B18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BF2B48(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BF2B40);
}

double HgcCanonLog_encode::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcCanonLog_encode [hgc1]");
  return *(double *)"og_encode [hgc1]";
}

uint64_t HgcCanonLog_encode::BindTexture(HgcCanonLog_encode *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcCanonLog_encode::Bind(HgcCanonLog_encode *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcCanonLog_encode *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcCanonLog_encode::RenderTile(HgcCanonLog_encode *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  _OWORD *v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int8x16_t *v46;
  int v47;
  uint64_t v48;
  float32x4_t v49;
  _OWORD *v50;
  float32x4_t v51;
  int8x16_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v47 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v12 = *(float32x4_t *)(v6 + v10 - 16);
      v11 = *(float32x4_t *)(v6 + v10);
      v13 = (_OWORD *)*((_QWORD *)this + 51);
      v14 = *((float32x4_t *)v13 + 1);
      v16 = *((float32x4_t *)v13 + 2);
      v15 = *((int8x16_t *)v13 + 3);
      v17 = vaddq_f32(vmulq_laneq_f32(vabsq_f32(v12), *(float32x4_t *)v13, 2), v16);
      v18 = vaddq_f32(vmulq_laneq_f32(vabsq_f32(v11), *(float32x4_t *)v13, 2), v16);
      v19 = (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vsubq_f32((float32x4_t)vbslq_s8(v15, (int8x16_t)v12, vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v12, v14))), (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v14, v12)))), COERCE_FLOAT(*v13));
      v20 = *((int8x16_t *)v13 + 4);
      v21 = *((float32x4_t *)v13 + 5);
      v22 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v17), (int8x16_t)v16);
      v23 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v18), (int8x16_t)v16);
      v24 = *((int8x16_t *)v13 + 6);
      v25 = *((float32x4_t *)v13 + 7);
      v26 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v11, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v15, (int8x16_t)v11, (int8x16_t)vsubq_f32((float32x4_t)vbslq_s8(v15, (int8x16_t)v11, vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v11, v14))), (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v14, v11)))), COERCE_FLOAT(*v13)));
      v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v18)));
      v28 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v17))), v25);
      v29 = *((float32x4_t *)v13 + 8);
      v30 = *((float32x4_t *)v13 + 9);
      v31 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v22, v29));
      v32 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v23, v29));
      v33 = vaddq_f32(v28, v31);
      v34 = vaddq_f32(vsubq_f32(v27, v25), v32);
      v35 = vmulq_f32(vmulq_f32(v30, v32), v23);
      v36 = vsubq_f32(v23, v16);
      v37 = vsubq_f32(vsubq_f32(v22, v16), vmulq_f32(vmulq_f32(v30, v31), v22));
      v38 = vsubq_f32(v36, v35);
      v39 = *((float32x4_t *)v13 + 10);
      v40 = *((float32x4_t *)v13 + 11);
      v41 = vaddq_f32(v39, vmulq_f32(v40, v37));
      v42 = vaddq_f32(v39, vmulq_f32(v40, v38));
      v43 = *((float32x4_t *)v13 + 12);
      v44 = *((float32x4_t *)v13 + 13);
      v45 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 1);
      v46 = (int8x16_t *)(v5 + v10);
      v46[-1] = vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vaddq_f32(v45, vmulq_f32(vaddq_f32(v33, vmulq_f32(v37, vaddq_f32(vaddq_f32(v43, vmulq_f32(v37, v44)), vmulq_f32(vmulq_f32(v37, v37), v41)))), (float32x4_t)vbslq_s8(v15, (int8x16_t)v12, v19))));
      *v46 = vbslq_s8(v15, (int8x16_t)v11, (int8x16_t)vaddq_f32(v45, vmulq_f32(vaddq_f32(v34, vmulq_f32(v38, vaddq_f32(vaddq_f32(v43, vmulq_f32(v38, v44)), vmulq_f32(vmulq_f32(v38, v38), v42)))), v26)));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v47 = -v9;
    if (v47 >= v4)
      goto LABEL_3;
LABEL_10:
    v48 = 16 * v47;
    v49 = *(float32x4_t *)(v6 + v48);
    v50 = (_OWORD *)*((_QWORD *)this + 51);
    v51 = *((float32x4_t *)v50 + 2);
    v52 = *((int8x16_t *)v50 + 3);
    v53 = vaddq_f32(vmulq_laneq_f32(vabsq_f32(v49), *(float32x4_t *)v50, 2), v51);
    v54 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)v50 + 4), (int8x16_t)v53), (int8x16_t)v51);
    v55 = (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v54, *((float32x4_t *)v50 + 8)));
    v56 = vsubq_f32(vsubq_f32(v54, v51), vmulq_f32(vmulq_f32(*((float32x4_t *)v50 + 9), v55), v54));
    *(int8x16_t *)(v5 + v48) = vbslq_s8(v52, (int8x16_t)v49, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50, 1), vmulq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v53, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)v50 + 6), (int8x16_t)vcgtq_f32(*((float32x4_t *)v50 + 5), v53))), *((float32x4_t *)v50 + 7)), v55), vmulq_f32(v56,
                                                    vaddq_f32(vaddq_f32(*((float32x4_t *)v50 + 12), vmulq_f32(v56, *((float32x4_t *)v50 + 13))), vmulq_f32(vmulq_f32(v56, v56), vaddq_f32(*((float32x4_t *)v50 + 10), vmulq_f32(*((float32x4_t *)v50 + 11), v56)))))), (float32x4_t)vbslq_s8(v52, (int8x16_t)v49, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v52, (int8x16_t)v49, (int8x16_t)vsubq_f32((float32x4_t)vbslq_s8(v52, (int8x16_t)v49, vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v49, *((float32x4_t *)v50 + 1)))), (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(*((float32x4_t *)v50 + 1), v49)))), COERCE_FLOAT(*v50))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcCanonLog_encode::GetDOD(HgcCanonLog_encode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcCanonLog_encode::GetROI(HgcCanonLog_encode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcCanonLog_encode::HgcCanonLog_encode(HgcCanonLog_encode *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E654ACA0;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3051560;
  v3[3] = xmmword_1B3050F70;
  v3[4] = xmmword_1B3051600;
  v3[5] = xmmword_1B3051610;
  v3[6] = xmmword_1B3051620;
  v3[7] = xmmword_1B3051630;
  v3[8] = xmmword_1B3051640;
  v3[9] = xmmword_1B3051510;
  v3[10] = xmmword_1B3051650;
  v3[11] = xmmword_1B3051660;
  v3[12] = xmmword_1B3051670;
  v3[13] = xmmword_1B3051680;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BF309C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcCanonLog_encode::~HgcCanonLog_encode(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E654ACA0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C405DF52C91);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E654ACA0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C405DF52C91);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcCanonLog_encode::SetParameter(HgcCanonLog_encode *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcCanonLog_encode::GetParameter(HgcCanonLog_encode *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcNikonLog_encode::GetProgram(HgcNikonLog_encode *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, half3(hg_Params[0].www));\n"
             "    r2.xyz = r0.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].zzz));\n"
             "    r1.xyz = log2(r1.xyz);\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[1].xxx) + half3(hg_Params[1].yyy);\n"
             "    r0.xyz = half3(r0.xyz >= half3(hg_Params[0].www));\n"
             "    output.color0.xyz = select(float3(r2.xyz), float3(r1.xyz), -float3(r0.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=3f8ec093:0799bfad:07283387:be79b09a\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003f7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, hg_Params[0].www);\n"
             "    r2.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].zzz);\n"
             "    r1.xyz = log2(r1.xyz);\n"
             "    r1.xyz = r1.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
             "    r0.xyz = float3(r0.xyz >= hg_Params[0].www);\n"
             "    output.color0.xyz = select(r2.xyz, r1.xyz, -r0.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9edade93:85582fd4:1e848f4f:c25d5331\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000448\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, hg_ProgramLocal0.www);\n"
           "    r2.xyz = r0.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = max(r2.xyz, c0.xxx);\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.zzz);\n"
           "    r1.xyz = log2(r1.xyz);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal1.xxx + hg_ProgramLocal1.yyy;\n"
           "    r0.xyz = vec3(greaterThanEqual(r0.xyz, hg_ProgramLocal0.www));\n"
           "    gl_FragColor.xyz = vec3(-r0.x < 0.00000 ? r1.x : r2.x, -r0.y < 0.00000 ? r1.y : r2.y, -r0.z < 0.00000 ? r"
           "1.z : r2.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=07c9b4e2:ac369c2c:083b433b:0792297e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcNikonLog_encode::InitProgramDescriptor(HgcNikonLog_encode *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcNikonLog_encode_hgc_visible", "//Metal1.0     \n//LEN=00000002d3\n[[ visible ]] FragmentOut HgcNikonLog_encode_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, hg_Params[0].www);\n"
    "    r2.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].zzz);\n"
    "    r1.xyz = log2(r1.xyz);\n"
    "    r1.xyz = r1.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
    "    r0.xyz = float3(r0.xyz >= hg_Params[0].www);\n"
    "    output.color0.xyz = select(r2.xyz, r1.xyz, -r0.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BF348C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BF34BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BF34B4);
}

double HgcNikonLog_encode::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcNikonLog_encode [hgc1]");
  return *(double *)"og_encode [hgc1]";
}

uint64_t HgcNikonLog_encode::BindTexture(HgcNikonLog_encode *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcNikonLog_encode::Bind(HgcNikonLog_encode *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcNikonLog_encode *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcNikonLog_encode::RenderTile(HgcNikonLog_encode *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  _OWORD *v13;
  __int128 v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  int32x4_t v55;
  int8x16_t v56;
  int32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int8x16_t *v73;
  int v74;
  uint64_t v75;
  float32x4_t v76;
  _OWORD *v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  int8x16_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  int8x16_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v74 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v11 = *(float32x4_t *)(v6 + v10 - 16);
      v12 = *(float32x4_t *)(v6 + v10);
      v13 = (_OWORD *)*((_QWORD *)this + 51);
      v14 = v13[1];
      v15 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v13, 3);
      v16 = vmaxq_f32(v11, v15);
      v17 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 1);
      v18 = vmaxq_f32(v12, v15);
      v19 = vaddq_f32(v17, vmulq_n_f32(v11, COERCE_FLOAT(*v13)));
      v20 = vaddq_f32(v17, vmulq_n_f32(v12, COERCE_FLOAT(*v13)));
      v21 = *((float32x4_t *)v13 + 2);
      v22 = *((int8x16_t *)v13 + 3);
      v23 = vmaxq_f32(v19, v21);
      v24 = vmaxq_f32(v20, v21);
      v25 = *((float32x4_t *)v13 + 4);
      v26 = *((float32x4_t *)v13 + 5);
      v27 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v23), (int8x16_t)v25);
      v28 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v24), (int8x16_t)v25);
      v29 = *((int8x16_t *)v13 + 6);
      v30 = *((float32x4_t *)v13 + 7);
      v31 = *((float32x4_t *)v13 + 8);
      v32 = *((float32x4_t *)v13 + 9);
      v33 = (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vcgtq_f32(v27, v31));
      v34 = (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vcgtq_f32(v28, v31));
      v35 = vsubq_f32(vsubq_f32(v27, v25), vmulq_f32(vmulq_f32(v32, v33), v27));
      v36 = vsubq_f32(vsubq_f32(v28, v25), vmulq_f32(vmulq_f32(v32, v34), v28));
      v37 = *((float32x4_t *)v13 + 10);
      v38 = *((float32x4_t *)v13 + 11);
      v39 = *((float32x4_t *)v13 + 12);
      v40 = *((float32x4_t *)v13 + 13);
      v41 = vmulq_laneq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v26, v23))), v30), v33), vmulq_f32(v35, vaddq_f32(vaddq_f32(v39, vmulq_f32(v35, v40)), vmulq_f32(vmulq_f32(v35, v35), vaddq_f32(v37, vmulq_f32(v38, v35)))))), *(float32x4_t *)v13, 2);
      v42 = vmulq_laneq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v26, v24))), v30), v34), vmulq_f32(v36, vaddq_f32(vaddq_f32(v39, vmulq_f32(v36, v40)), vmulq_f32(vmulq_f32(v36, v36), vaddq_f32(v37, vmulq_f32(v38, v36)))))), *(float32x4_t *)v13, 2);
      v43 = *((float32x4_t *)v13 + 14);
      v44 = *((float32x4_t *)v13 + 15);
      v45 = vmaxq_f32(v41, v43);
      v46 = vmaxq_f32(v42, v43);
      v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      v48 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
      v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vcgtq_f32(v47, v45)));
      v50 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vcgtq_f32(v48, v46)));
      v51 = vsubq_f32(v45, v49);
      v52 = *((float32x4_t *)v13 + 16);
      v53 = *((float32x4_t *)v13 + 17);
      v54 = vsubq_f32(v46, v50);
      v55 = *((int32x4_t *)v13 + 18);
      v56 = *((int8x16_t *)v13 + 19);
      v57 = vaddq_s32(v55, vcvtq_s32_f32(v50));
      v58 = (float32x4_t)vshlq_n_s32(vaddq_s32(v55, vcvtq_s32_f32(v49)), 0x17uLL);
      v59 = (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v26, v16));
      v60 = (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v26, v18));
      v61 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v16), (int8x16_t)v25);
      v62 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v18), (int8x16_t)v25);
      v63 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), v59), v30);
      v64 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), v60), v30);
      v65 = (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vcgtq_f32(v61, v31));
      v66 = (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vcgtq_f32(v62, v31));
      v67 = vaddq_f32(v64, v66);
      v68 = vmulq_f32(v32, v66);
      v69 = vsubq_f32(vsubq_f32(v61, v25), vmulq_f32(vmulq_f32(v32, v65), v61));
      v70 = vsubq_f32(vsubq_f32(v62, v25), vmulq_f32(v68, v62));
      v71 = vaddq_f32(v67, vmulq_f32(v70, vaddq_f32(vaddq_f32(v39, vmulq_f32(v70, v40)), vmulq_f32(vmulq_f32(v70, v70), vaddq_f32(v37, vmulq_f32(v38, v70))))));
      v72 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v14, 1);
      v73 = (int8x16_t *)(v5 + v10);
      v73[-1] = vbslq_s8(v56, (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v56, (int8x16_t)v11, vandq_s8((int8x16_t)v25, (int8x16_t)vcgeq_f32(v11, v15))), v21), (int8x16_t)vaddq_f32(v72, vmulq_n_f32(vaddq_f32(vaddq_f32(v63, v65), vmulq_f32(v69, vaddq_f32(vaddq_f32(v39, vmulq_f32(v69, v40)), vmulq_f32(vmulq_f32(v69, v69), vaddq_f32(v37, vmulq_f32(v38, v69)))))),
                                   *(float *)&v14)),
                    (int8x16_t)vmulq_f32(vaddq_f32(v25, vmulq_f32(v51, vaddq_f32(v53, vmulq_f32(v51, vaddq_f32(v44, vmulq_f32(v52, v51)))))), v58)));
      *v73 = vbslq_s8(v56, (int8x16_t)v12, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v56, (int8x16_t)v12, vandq_s8((int8x16_t)v25, (int8x16_t)vcgeq_f32(v12, v15))), v21), (int8x16_t)vaddq_f32(v72, vmulq_n_f32(v71, *(float *)&v14)), (int8x16_t)vmulq_f32(vaddq_f32(v25, vmulq_f32(v54, vaddq_f32(v53, vmulq_f32(v54, vaddq_f32(v44, vmulq_f32(v52, v54)))))), (float32x4_t)vshlq_n_s32(v57, 0x17uLL))));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v74 = -v9;
    if (v74 >= v4)
      goto LABEL_3;
LABEL_10:
    v75 = 16 * v74;
    v76 = *(float32x4_t *)(v6 + v75);
    v77 = (_OWORD *)*((_QWORD *)this + 51);
    v78 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v77, 3);
    v79 = vmaxq_f32(v76, v78);
    v80 = *((float32x4_t *)v77 + 2);
    v81 = *((int8x16_t *)v77 + 3);
    v82 = vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v77, 1), vmulq_n_f32(v76, COERCE_FLOAT(*v77))), v80);
    v83 = *((float32x4_t *)v77 + 4);
    v84 = *((float32x4_t *)v77 + 5);
    v85 = (float32x4_t)vorrq_s8(vandq_s8(v81, (int8x16_t)v82), (int8x16_t)v83);
    v86 = *((int8x16_t *)v77 + 6);
    v87 = *((float32x4_t *)v77 + 7);
    v88 = *((float32x4_t *)v77 + 8);
    v89 = *((float32x4_t *)v77 + 9);
    v90 = (float32x4_t)vandq_s8((int8x16_t)v83, (int8x16_t)vcgtq_f32(v85, v88));
    v91 = vsubq_f32(vsubq_f32(v85, v83), vmulq_f32(vmulq_f32(v89, v90), v85));
    v92 = *((float32x4_t *)v77 + 10);
    v93 = *((float32x4_t *)v77 + 11);
    v94 = *((float32x4_t *)v77 + 12);
    v95 = *((float32x4_t *)v77 + 13);
    v96 = vmaxq_f32(vmulq_laneq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v82, 0x17uLL)), (float32x4_t)vandq_s8(v86, (int8x16_t)vcgtq_f32(v84, v82))), v87), v90), vmulq_f32(v91, vaddq_f32(vaddq_f32(v94, vmulq_f32(v91, v95)), vmulq_f32(vmulq_f32(v91, v91), vaddq_f32(v92, vmulq_f32(v93, v91)))))), *(float32x4_t *)v77, 2), *((float32x4_t *)v77 + 14));
    v97 = vcvtq_f32_s32(vcvtq_s32_f32(v96));
    v98 = vsubq_f32(v97, (float32x4_t)vandq_s8((int8x16_t)v83, (int8x16_t)vcgtq_f32(v97, v96)));
    v99 = vsubq_f32(v96, v98);
    v100 = (int8x16_t)vmulq_f32(vaddq_f32(v83, vmulq_f32(v99, vaddq_f32(*((float32x4_t *)v77 + 17), vmulq_f32(v99, vaddq_f32(*((float32x4_t *)v77 + 15), vmulq_f32(*((float32x4_t *)v77 + 16), v99)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)v77 + 18), vcvtq_s32_f32(v98)), 0x17uLL));
    v101 = (float32x4_t)vorrq_s8(vandq_s8(v81, (int8x16_t)v79), (int8x16_t)v83);
    v102 = (float32x4_t)vandq_s8((int8x16_t)v83, (int8x16_t)vcgtq_f32(v101, v88));
    v103 = vsubq_f32(vsubq_f32(v101, v83), vmulq_f32(vmulq_f32(v89, v102), v101));
    *(int8x16_t *)(v5 + v75) = vbslq_s8(*((int8x16_t *)v77 + 19), (int8x16_t)v76, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)v77 + 19), (int8x16_t)v76, vandq_s8((int8x16_t)v83, (int8x16_t)vcgeq_f32(v76, v78))), v80), (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)v77[1], 1), vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v79, 0x17uLL)), (float32x4_t)vandq_s8(v86, (int8x16_t)vcgtq_f32(v84, v79))), v87),
                                                      v102),
                                                    vmulq_f32(v103, vaddq_f32(vaddq_f32(v94, vmulq_f32(v103, v95)), vmulq_f32(vmulq_f32(v103, v103), vaddq_f32(v92, vmulq_f32(v93, v103)))))), COERCE_FLOAT(v77[1]))), v100));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcNikonLog_encode::GetDOD(HgcNikonLog_encode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcNikonLog_encode::GetROI(HgcNikonLog_encode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcNikonLog_encode::HgcNikonLog_encode(HgcNikonLog_encode *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E654AF08;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = 0u;
  v3[3] = xmmword_1B3051600;
  v3[4] = xmmword_1B3051560;
  v3[5] = xmmword_1B3051610;
  v3[6] = xmmword_1B3051620;
  v3[7] = xmmword_1B3051630;
  v3[8] = xmmword_1B3051640;
  v3[9] = xmmword_1B3051510;
  v3[10] = xmmword_1B3051650;
  v3[11] = xmmword_1B3051660;
  v3[12] = xmmword_1B3051670;
  v3[13] = xmmword_1B3051680;
  v3[14] = xmmword_1B3051690;
  v3[15] = xmmword_1B30516A0;
  v3[16] = xmmword_1B30516B0;
  v3[17] = xmmword_1B30516C0;
  v3[18] = xmmword_1B30516D0;
  v3[19] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BF3C78(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcNikonLog_encode::~HgcNikonLog_encode(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E654AF08;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B2834900);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E654AF08;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B2834900);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcNikonLog_encode::SetParameter(HgcNikonLog_encode *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcNikonLog_encode::GetParameter(HgcNikonLog_encode *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

void sub_1B2BF47F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29164](v1, MEMORY[0x1E0DE4E10]);
  _Unwind_Resume(a1);
}

BOOL FxIsSupportedNCLCValue_Private(int a1)
{
  _BOOL4 v1;

  v1 = ((1 << SBYTE1(a1)) & 0x52102) != 0 && a1 == 0;
  if (BYTE1(a1) > 0x12u)
    v1 = 0;
  if (((1 << SBYTE2(a1)) & 0x1202) == 0)
    v1 = 0;
  return BYTE2(a1) <= 0xCu && v1;
}

uint64_t FxIsDebugFlagOn()
{
  double Current;
  const __CFString *v1;
  void *v2;
  const void *v3;

  Current = CFAbsoluteTimeGetCurrent();
  if (Current - *(double *)&FxIsDebugFlagOn_lastCheckTicks > 1.0)
  {
    v1 = (const __CFString *)*MEMORY[0x1E0C9B248];
    if ((FxIsDebugFlagOn_addedSuitePrefs & 1) == 0)
    {
      FxIsDebugFlagOn_addedSuitePrefs = 1;
      CFPreferencesAddSuitePreferencesToApp(v1, CFSTR("com.apple.FxPlug"));
    }
    v2 = (void *)CFPreferencesCopyAppValue(CFSTR("DEBUG"), v1);
    if (v2)
    {
      v3 = v2;
      FxIsDebugFlagOn_result = objc_msgSend(v2, "isEqual:", CFSTR("YES"));
      CFRelease(v3);
    }
    else
    {
      FxIsDebugFlagOn_result = 0;
    }
    FxIsDebugFlagOn_lastCheckTicks = *(_QWORD *)&Current;
  }
  return FxIsDebugFlagOn_result;
}

void FxDebugLog(NSString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (FxIsDebugFlagOn())
    NSLogv(a1, &a9);
}

uint64_t FxDebugAssert(uint64_t a1, NSString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if ((a1 & 1) == 0 && FxIsDebugFlagOn())
    NSLogv(a2, &a9);
  return a1;
}

void MyDataProviderReleaser(id a1)
{
  if (a1)

}

BOOL __gl_vertLeq(uint64_t a1, uint64_t a2)
{
  double v2;
  double v3;

  v2 = *(double *)(a1 + 56);
  v3 = *(double *)(a2 + 56);
  if (v2 < v3)
    return 1;
  if (v2 == v3)
    return *(double *)(a1 + 64) <= *(double *)(a2 + 64);
  return 0;
}

double __gl_edgeEval(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double result;
  uint64_t v10;
  uint64_t v11;

  v3 = *(double *)(a1 + 56);
  v4 = *(double *)(a2 + 56);
  if (v3 >= v4 && (v3 != v4 || *(double *)(a1 + 64) > *(double *)(a2 + 64))
    || (v5 = *(double *)(a3 + 56), v4 >= v5) && (v4 != v5 || *(double *)(a2 + 64) > *(double *)(a3 + 64)))
  {
    __gl_edgeEval_cold_1();
  }
  v6 = v4 - v3;
  v7 = v5 - v4;
  v8 = v4 - v3 + v7;
  result = 0.0;
  if (v8 > 0.0)
  {
    if (v6 >= v7)
      v10 = a3;
    else
      v10 = a1;
    if (v6 >= v7)
      v11 = a1;
    else
      v11 = a3;
    if (v6 < v7)
      v7 = v6;
    return *(double *)(a2 + 64) - *(double *)(v10 + 64) + v7 / v8 * (*(double *)(v10 + 64) - *(double *)(v11 + 64));
  }
  return result;
}

double __gl_edgeSign(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double result;

  v3 = *(double *)(a1 + 56);
  v4 = *(double *)(a2 + 56);
  if (v3 >= v4 && (v3 != v4 || *(double *)(a1 + 64) > *(double *)(a2 + 64))
    || (v5 = *(double *)(a3 + 56), v4 >= v5) && (v4 != v5 || *(double *)(a2 + 64) > *(double *)(a3 + 64)))
  {
    __gl_edgeSign_cold_1();
  }
  v6 = v4 - v3;
  v7 = v5 - v4;
  result = 0.0;
  if (v6 + v7 > 0.0)
    return v6 * (*(double *)(a2 + 64) - *(double *)(a3 + 64)) + v7 * (*(double *)(a2 + 64) - *(double *)(a1 + 64));
  return result;
}

double __gl_transEval(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double result;
  uint64_t v10;
  uint64_t v11;

  v3 = *(double *)(a1 + 64);
  v4 = *(double *)(a2 + 64);
  if (v3 >= v4 && (v3 != v4 || *(double *)(a1 + 56) > *(double *)(a2 + 56))
    || (v5 = *(double *)(a3 + 64), v4 >= v5) && (v4 != v5 || *(double *)(a2 + 56) > *(double *)(a3 + 56)))
  {
    __gl_transEval_cold_1();
  }
  v6 = v4 - v3;
  v7 = v5 - v4;
  v8 = v4 - v3 + v7;
  result = 0.0;
  if (v8 > 0.0)
  {
    if (v6 >= v7)
      v10 = a3;
    else
      v10 = a1;
    if (v6 >= v7)
      v11 = a1;
    else
      v11 = a3;
    if (v6 < v7)
      v7 = v6;
    return *(double *)(a2 + 56) - *(double *)(v10 + 56) + v7 / v8 * (*(double *)(v10 + 56) - *(double *)(v11 + 56));
  }
  return result;
}

double __gl_transSign(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double result;

  v3 = *(double *)(a1 + 64);
  v4 = *(double *)(a2 + 64);
  if (v3 >= v4 && (v3 != v4 || *(double *)(a1 + 56) > *(double *)(a2 + 56))
    || (v5 = *(double *)(a3 + 64), v4 >= v5) && (v4 != v5 || *(double *)(a2 + 56) > *(double *)(a3 + 56)))
  {
    __gl_transSign_cold_1();
  }
  v6 = v4 - v3;
  v7 = v5 - v4;
  result = 0.0;
  if (v6 + v7 > 0.0)
    return v6 * (*(double *)(a2 + 56) - *(double *)(a3 + 56)) + v7 * (*(double *)(a2 + 56) - *(double *)(a1 + 56));
  return result;
}

void __gl_edgeIntersect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double v7;
  double v8;
  uint64_t v9;
  double v10;
  double v11;
  uint64_t v12;
  double v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  uint64_t v33;
  double v34;
  double v35;
  uint64_t v36;
  double v37;
  uint64_t v38;
  uint64_t v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;

  v7 = *(double *)(a1 + 56);
  v8 = *(double *)(a2 + 56);
  if (v7 < v8 || v7 == v8 && *(double *)(a1 + 64) <= *(double *)(a2 + 64))
  {
    v9 = a2;
    a2 = a1;
  }
  else
  {
    v9 = a1;
  }
  v10 = *(double *)(a3 + 56);
  v11 = *(double *)(a4 + 56);
  if (v10 < v11 || v10 == v11 && *(double *)(a3 + 64) <= *(double *)(a4 + 64))
  {
    v11 = *(double *)(a3 + 56);
    v12 = a4;
    a4 = a3;
  }
  else
  {
    v12 = a3;
  }
  v13 = *(double *)(a2 + 56);
  if (v13 < v11 || v13 == v11 && *(double *)(a2 + 64) <= *(double *)(a4 + 64))
  {
    v13 = v11;
    v14 = v12;
    v15 = a4;
    v12 = v9;
    a4 = a2;
  }
  else
  {
    v14 = v9;
    v15 = a2;
  }
  v16 = *(double *)(v12 + 56);
  if (v13 >= v16 && (v13 != v16 || *(double *)(v15 + 64) > *(double *)(v12 + 64)))
  {
    v17 = v13 + v16;
LABEL_49:
    v29 = v17 * 0.5;
    goto LABEL_50;
  }
  v18 = *(double *)(v14 + 56);
  if (v16 < v18 || v16 == v18 && *(double *)(v12 + 64) <= *(double *)(v14 + 64))
  {
    v26 = __gl_edgeEval(a4, v15, v12);
    v27 = __gl_edgeEval(v15, v12, v14);
    if (v26 + v27 >= 0.0)
      v28 = v27;
    else
      v28 = -v27;
    if (v26 + v27 >= 0.0)
      v22 = v26;
    else
      v22 = -v26;
    v23 = 0.0;
    if (v22 < 0.0)
      v22 = 0.0;
    if (v28 >= 0.0)
      v23 = v28;
    v24 = *(double *)(v15 + 56);
    if (v22 > v23)
    {
      v25 = *(double *)(v12 + 56);
      goto LABEL_44;
    }
    v30 = *(double *)(v12 + 56);
LABEL_47:
    if (v23 != 0.0)
    {
      v29 = v24 + v22 / (v22 + v23) * (v30 - v24);
      goto LABEL_50;
    }
    v17 = v24 + v30;
    goto LABEL_49;
  }
  v19 = __gl_edgeSign(a4, v15, v12);
  v20 = __gl_edgeSign(a4, v14, v12);
  v21 = -v20;
  if (v19 - v20 >= 0.0)
  {
    v22 = v19;
  }
  else
  {
    v21 = v20;
    v22 = -v19;
  }
  v23 = 0.0;
  if (v22 < 0.0)
    v22 = 0.0;
  if (v21 >= 0.0)
    v23 = v21;
  v24 = *(double *)(v15 + 56);
  if (v22 <= v23)
  {
    v30 = *(double *)(v14 + 56);
    goto LABEL_47;
  }
  v25 = *(double *)(v14 + 56);
LABEL_44:
  v29 = v25 + v23 / (v22 + v23) * (v24 - v25);
LABEL_50:
  *(double *)(a5 + 56) = v29;
  v31 = *(double *)(a4 + 64);
  v32 = *(double *)(v12 + 64);
  if (v31 < v32 || v31 == v32 && *(double *)(a4 + 56) <= *(double *)(v12 + 56))
  {
    v33 = v12;
    v12 = a4;
  }
  else
  {
    v33 = a4;
  }
  v34 = *(double *)(v15 + 64);
  v35 = *(double *)(v14 + 64);
  if (v34 < v35 || v34 == v35 && *(double *)(v15 + 56) <= *(double *)(v14 + 56))
  {
    v35 = *(double *)(v15 + 64);
    v36 = v14;
    v14 = v15;
  }
  else
  {
    v36 = v15;
  }
  v37 = *(double *)(v12 + 64);
  if (v37 < v35 || v37 == v35 && *(double *)(v12 + 56) <= *(double *)(v14 + 56))
  {
    v37 = v35;
    v38 = v36;
    v39 = v14;
    v36 = v33;
    v14 = v12;
  }
  else
  {
    v38 = v33;
    v39 = v12;
  }
  v40 = *(double *)(v36 + 64);
  if (v37 >= v40 && (v37 != v40 || *(double *)(v39 + 56) > *(double *)(v36 + 56)))
  {
    v41 = v37 + v40;
LABEL_99:
    v53 = v41 * 0.5;
    goto LABEL_100;
  }
  v42 = *(double *)(v38 + 64);
  if (v40 < v42 || v40 == v42 && *(double *)(v36 + 56) <= *(double *)(v38 + 56))
  {
    v50 = __gl_transEval(v14, v39, v36);
    v51 = __gl_transEval(v39, v36, v38);
    if (v50 + v51 >= 0.0)
      v52 = v51;
    else
      v52 = -v51;
    if (v50 + v51 >= 0.0)
      v46 = v50;
    else
      v46 = -v50;
    v47 = 0.0;
    if (v46 < 0.0)
      v46 = 0.0;
    if (v52 >= 0.0)
      v47 = v52;
    v48 = *(double *)(v39 + 64);
    if (v46 > v47)
    {
      v49 = *(double *)(v36 + 64);
      goto LABEL_93;
    }
    v54 = *(double *)(v36 + 64);
LABEL_97:
    if (v47 != 0.0)
    {
      v53 = v48 + v46 / (v46 + v47) * (v54 - v48);
      goto LABEL_100;
    }
    v41 = v48 + v54;
    goto LABEL_99;
  }
  v43 = __gl_transSign(v14, v39, v36);
  v44 = __gl_transSign(v14, v38, v36);
  v45 = -v44;
  if (v43 - v44 >= 0.0)
  {
    v46 = v43;
  }
  else
  {
    v45 = v44;
    v46 = -v43;
  }
  v47 = 0.0;
  if (v46 < 0.0)
    v46 = 0.0;
  if (v45 >= 0.0)
    v47 = v45;
  v48 = *(double *)(v39 + 64);
  if (v46 <= v47)
  {
    v54 = *(double *)(v38 + 64);
    goto LABEL_97;
  }
  v49 = *(double *)(v38 + 64);
LABEL_93:
  v53 = v49 + v47 / (v46 + v47) * (v48 - v49);
LABEL_100:
  *(double *)(a5 + 64) = v53;
}

void __gl_edgeEval_cold_1()
{
  __assert_rtn("__gl_edgeEval", "geom.c", 63, "VertLeq( u, v) && VertLeq( v, w)");
}

void __gl_edgeSign_cold_1()
{
  __assert_rtn("__gl_edgeSign", "geom.c", 87, "VertLeq( u, v) && VertLeq( v, w)");
}

void __gl_transEval_cold_1()
{
  __assert_rtn("__gl_transEval", "geom.c", 118, "TransLeq( u, v) && TransLeq( v, w)");
}

void __gl_transSign_cold_1()
{
  __assert_rtn("__gl_transSign", "geom.c", 142, "TransLeq( u, v) && TransLeq( v, w)");
}

uint64_t __gl_meshTessellateMonoRegion(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  double v4;
  uint64_t v5;
  double v6;
  _QWORD *v7;
  uint64_t v8;
  double v9;
  uint64_t v10;
  double v11;
  _QWORD *v12;
  uint64_t v13;
  double v14;
  uint64_t v15;
  double v16;
  uint64_t result;
  _QWORD *v18;
  uint64_t v19;
  double v20;
  uint64_t v21;
  double v22;
  _QWORD *v23;

  v1 = *(_QWORD **)(a1 + 16);
  v2 = v1[3];
  if ((_QWORD *)v2 == v1 || *(_QWORD **)(v2 + 24) == v1)
    __gl_meshTessellateMonoRegion_cold_1();
  while (1)
  {
    v3 = *(_QWORD *)(v1[1] + 32);
    v4 = *(double *)(v3 + 56);
    v5 = v1[4];
    v6 = *(double *)(v5 + 56);
    if (v4 >= v6 && (v4 != v6 || *(double *)(v3 + 64) > *(double *)(v5 + 64)))
      break;
    v1 = *(_QWORD **)(v1[2] + 8);
  }
  while (v6 < v4 || v6 == v4 && *(double *)(v5 + 64) <= *(double *)(v3 + 64))
  {
    v1 = (_QWORD *)v1[3];
    v5 = v1[4];
    v6 = *(double *)(v5 + 56);
    v3 = *(_QWORD *)(v1[1] + 32);
    v4 = *(double *)(v3 + 56);
  }
  v7 = *(_QWORD **)(v1[2] + 8);
  while ((_QWORD *)v1[3] != v7)
  {
    v8 = *(_QWORD *)(v1[1] + 32);
    v9 = *(double *)(v8 + 56);
    v10 = v7[4];
    v11 = *(double *)(v10 + 56);
    if (v9 < v11 || v9 == v11 && *(double *)(v8 + 64) <= *(double *)(v10 + 64))
    {
      while (1)
      {
        v18 = (_QWORD *)v7[3];
        if (v18 == v1)
          break;
        v19 = *(_QWORD *)(v18[1] + 32);
        v20 = *(double *)(v19 + 56);
        v21 = v18[4];
        v22 = *(double *)(v21 + 56);
        if (v20 >= v22 && (v20 != v22 || *(double *)(v19 + 64) > *(double *)(v21 + 64)))
        {
          if (__gl_edgeSign(v7[4], *(_QWORD *)(v7[1] + 32), v19) > 0.0)
            break;
          v18 = (_QWORD *)v7[3];
        }
        result = (uint64_t)__gl_meshConnect(v18, v7);
        if (!result)
          return result;
        v7 = *(_QWORD **)(result + 8);
      }
      v7 = *(_QWORD **)(v7[2] + 8);
    }
    else
    {
      while ((_QWORD *)v7[3] != v1)
      {
        v12 = *(_QWORD **)(v1[2] + 8);
        v13 = v12[4];
        v14 = *(double *)(v13 + 56);
        v15 = *(_QWORD *)(v12[1] + 32);
        v16 = *(double *)(v15 + 56);
        if (v14 >= v16 && (v14 != v16 || *(double *)(v13 + 64) > *(double *)(v15 + 64)))
        {
          if (__gl_edgeSign(*(_QWORD *)(v1[1] + 32), v1[4], v13) < 0.0)
            break;
          v12 = *(_QWORD **)(v1[2] + 8);
        }
        result = (uint64_t)__gl_meshConnect(v1, v12);
        if (!result)
          return result;
        v1 = *(_QWORD **)(result + 8);
      }
      v1 = (_QWORD *)v1[3];
    }
  }
  v23 = (_QWORD *)v7[3];
  if (v23 == v1)
    __gl_meshTessellateMonoRegion_cold_2();
  while ((_QWORD *)v23[3] != v1)
  {
    result = (uint64_t)__gl_meshConnect(v23, v7);
    if (!result)
      return result;
    v7 = *(_QWORD **)(result + 8);
    v23 = (_QWORD *)v7[3];
  }
  return 1;
}

uint64_t __gl_meshTessellateInterior(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = a1 + 80;
  v1 = *(_QWORD *)(a1 + 80);
  if (v1 == v2)
    return 1;
  while (1)
  {
    v3 = *(_QWORD *)v1;
    if (*(_BYTE *)(v1 + 41))
    {
      result = __gl_meshTessellateMonoRegion(v1);
      if (!(_DWORD)result)
        break;
    }
    v1 = v3;
    if (v3 == v2)
      return 1;
  }
  return result;
}

uint64_t __gl_meshDiscardExterior(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;

  v2 = a1 + 80;
  result = *(_QWORD *)(a1 + 80);
  if (result != v2)
  {
    do
    {
      v3 = *(_QWORD *)result;
      if (!*(_BYTE *)(result + 41))
        __gl_meshZapFace((uint64_t *)result);
      result = v3;
    }
    while (v3 != v2);
  }
  return result;
}

uint64_t __gl_meshSetWindingNumber(uint64_t a1, int a2, int a3)
{
  uint64_t *v3;
  uint64_t *v4;
  int v7;
  uint64_t *v8;
  uint64_t result;
  int v10;

  v4 = (uint64_t *)(a1 + 128);
  v3 = *(uint64_t **)(a1 + 128);
  if (v3 != v4)
  {
    v7 = -a2;
    do
    {
      v8 = (uint64_t *)*v3;
      if (*(unsigned __int8 *)(*(_QWORD *)(v3[1] + 40) + 41) == *(unsigned __int8 *)(v3[5] + 41))
      {
        if (a3)
        {
          result = __gl_meshDelete(v3);
          if (!(_DWORD)result)
            return result;
          goto LABEL_12;
        }
        v10 = 0;
      }
      else if (*(_BYTE *)(v3[5] + 41))
      {
        v10 = a2;
      }
      else
      {
        v10 = v7;
      }
      *((_DWORD *)v3 + 14) = v10;
LABEL_12:
      v3 = v8;
    }
    while (v8 != v4);
  }
  return 1;
}

void __gl_meshTessellateMonoRegion_cold_1()
{
  __assert_rtn("__gl_meshTessellateMonoRegion", "tessmono.c", 84, "up->Lnext != up && up->Lnext->Lnext != up");
}

void __gl_meshTessellateMonoRegion_cold_2()
{
  __assert_rtn("__gl_meshTessellateMonoRegion", "tessmono.c", 120, "lo->Lnext != up");
}

uint64_t __gl_computeInterior(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t result;
  uint64_t *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t Min;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  _BYTE *v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  *(_BYTE *)(a1 + 116) = 0;
  v2 = *(_QWORD *)(a1 + 16);
  v5 = *(_QWORD **)(v2 + 128);
  v4 = (_QWORD *)(v2 + 128);
  v3 = v5;
  if (v5 != v4)
  {
    while (1)
    {
      v7 = (_QWORD *)v3[3];
      v6 = v3[4];
      v8 = (_QWORD *)*v3;
      v9 = *(_QWORD *)(v3[1] + 32);
      if (*(double *)(v6 + 56) == *(double *)(v9 + 56)
        && *(double *)(v6 + 64) == *(double *)(v9 + 64)
        && (_QWORD *)v7[3] != v3)
      {
        SpliceMergeVertices(a1, (_QWORD *)v3[3], v3);
        if (!__gl_meshDelete(v3))
          break;
        v3 = v7;
        v7 = (_QWORD *)v7[3];
      }
      if ((_QWORD *)v7[3] == v3)
      {
        if (v7 != v3)
        {
          if (v7 == v8 || v7 == (_QWORD *)v8[1])
            v8 = (_QWORD *)*v8;
          if (!__gl_meshDelete(v7))
            break;
        }
        if (v3 == v8 || v3 == (_QWORD *)v8[1])
          v8 = (_QWORD *)*v8;
        if (!__gl_meshDelete(v3))
          break;
      }
      v3 = v8;
      if (v8 == v4)
        goto LABEL_18;
    }
LABEL_52:
    longjmp((int *)(a1 + 3464), 1);
  }
LABEL_18:
  result = (uint64_t)__gl_pqSortNewPriorityQ(__gl_vertLeq);
  *(_QWORD *)(a1 + 128) = result;
  if (result)
  {
    v11 = (uint64_t *)result;
    v12 = *(_QWORD **)(a1 + 16);
    v13 = v12;
    while (1)
    {
      v13 = (_QWORD *)*v13;
      if (v13 == v12)
        break;
      v14 = __gl_pqSortInsert((uint64_t)v11, (uint64_t)v13);
      v13[9] = v14;
      if (v14 == 0x7FFFFFFFFFFFFFFFLL)
        goto LABEL_46;
    }
    if (__gl_pqSortInit(v11))
    {
      v15 = __gl_dictListNewDict(a1, (uint64_t)EdgeLeq);
      *(_QWORD *)(a1 + 120) = v15;
      if (!v15)
        goto LABEL_52;
      AddSentinel(a1, -4.0e150);
      AddSentinel(a1, 4.0e150);
      Min = __gl_pqSortExtractMin(*(_QWORD *)(a1 + 128));
      if (Min)
      {
        v17 = Min;
        do
        {
          while (1)
          {
            v18 = __gl_pqSortMinimum(*(_QWORD **)(a1 + 128));
            if (!v18
              || *(double *)(v18 + 56) != *(double *)(v17 + 56)
              || *(double *)(v18 + 64) != *(double *)(v17 + 64))
            {
              break;
            }
            v19 = __gl_pqSortExtractMin(*(_QWORD *)(a1 + 128));
            SpliceMergeVertices(a1, *(_QWORD **)(v17 + 16), *(_QWORD **)(v19 + 16));
          }
          SweepEvent(a1, v17);
          v17 = __gl_pqSortExtractMin(*(_QWORD *)(a1 + 128));
        }
        while (v17);
      }
      v20 = 0;
      v21 = **(_BYTE ***)(*(_QWORD *)(a1 + 120) + 8);
      *(_QWORD *)(a1 + 136) = *(_QWORD *)(*(_QWORD *)v21 + 32);
      do
      {
        if (!v21[21])
        {
          if (!v21[23])
            __gl_computeInterior_cold_1();
          if (v20)
            __gl_computeInterior_cold_4();
          v20 = 1;
        }
        if (*((_DWORD *)v21 + 4))
          __gl_computeInterior_cold_3();
        DeleteRegion(a1, v21);
        v22 = *(_QWORD *)(a1 + 120);
        v21 = **(_BYTE ***)(v22 + 8);
      }
      while (v21);
      __gl_dictListDeleteDict((_QWORD *)v22);
      __gl_pqSortDeletePriorityQ(*(void ****)(a1 + 128));
      v23 = *(_QWORD **)(a1 + 16);
      v24 = v23 + 10;
      v25 = (_QWORD *)v23[10];
      if (v25 == v23 + 10)
      {
LABEL_45:
        __gl_meshCheckMesh(v23);
        return 1;
      }
      else
      {
        while (1)
        {
          v26 = v25[2];
          v27 = *(_QWORD *)(v26 + 24);
          if (v27 == v26)
            __gl_computeInterior_cold_2();
          v25 = (_QWORD *)*v25;
          if (*(_QWORD *)(v27 + 24) == v26)
          {
            v29 = *(_QWORD *)(v26 + 8);
            v28 = *(_QWORD *)(v26 + 16);
            *(_DWORD *)(v28 + 56) += *(_DWORD *)(v26 + 56);
            *(_DWORD *)(*(_QWORD *)(v28 + 8) + 56) += *(_DWORD *)(v29 + 56);
            result = __gl_meshDelete((_QWORD *)v26);
            if (!(_DWORD)result)
              break;
          }
          if (v25 == v24)
          {
            v23 = *(_QWORD **)(a1 + 16);
            goto LABEL_45;
          }
        }
      }
    }
    else
    {
LABEL_46:
      __gl_pqSortDeletePriorityQ(*(void ****)(a1 + 128));
      result = 0;
      *(_QWORD *)(a1 + 128) = 0;
    }
  }
  return result;
}

uint64_t SpliceMergeVertices(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  __int128 v9;
  _QWORD v10[5];

  v10[4] = *MEMORY[0x1E0C80C00];
  v10[2] = 0;
  v10[3] = 0;
  v9 = xmmword_1B3052100;
  v6 = a2[4];
  v7 = *(_QWORD *)(a3[4] + 24);
  v10[0] = *(_QWORD *)(v6 + 24);
  v10[1] = v7;
  CallCombine(a1, v6, v10, (uint64_t)&v9, 0);
  result = __gl_meshSplice(a2, a3);
  if (!(_DWORD)result)
    longjmp((int *)(a1 + 3464), 1);
  return result;
}

void SweepEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t **v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  _QWORD ***v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _BYTE *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  double v29;
  uint64_t *v30;
  _QWORD ***v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  double v35;
  uint64_t v36;
  double v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  uint64_t v41;
  double v42;
  uint64_t v43;
  double v44;
  _QWORD *v45;
  _QWORD *v46;
  _QWORD *v47;
  unsigned int v48;
  _QWORD v49[3];

  *(_QWORD *)(a1 + 136) = a2;
  v4 = *(_QWORD *)(a2 + 16);
  v5 = v4;
  do
  {
    v6 = *(_QWORD **)(v5 + 48);
    if (v6)
    {
      v17 = TopLeftRegion(v6);
      if (!v17)
        goto LABEL_50;
      v18 = v17;
      v19 = *(_QWORD ****)(v17[1] + 16);
      v20 = **v19;
      v21 = FinishLeftRegions(a1, *v19, 0);
      v22 = (_QWORD *)v21[2];
      if (v22 == v20)
      {
        v23 = v21;
        v24 = (_QWORD *)*v18;
        v25 = **(_BYTE ***)(v18[1] + 16);
        v26 = *(_QWORD *)v25;
        if (*(_QWORD *)(*(_QWORD *)(*v18 + 8) + 32) != *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8) + 32))
          CheckForIntersect(a1, v18);
        v27 = v24[4];
        v28 = *(_QWORD *)(a1 + 136);
        v29 = *(double *)(v28 + 56);
        if (*(double *)(v27 + 56) == v29 && *(double *)(v27 + 64) == *(double *)(v28 + 64))
        {
          if (!__gl_meshSplice(*(_QWORD **)(v20[1] + 24), v24))
            goto LABEL_50;
          v30 = TopLeftRegion(v18);
          if (!v30)
            goto LABEL_50;
          v18 = v30;
          v31 = *(_QWORD ****)(v30[1] + 16);
          v20 = **v31;
          FinishLeftRegions(a1, *v31, v25);
          v32 = 0;
          v28 = *(_QWORD *)(a1 + 136);
          v29 = *(double *)(v28 + 56);
        }
        else
        {
          v32 = 1;
        }
        v41 = *(_QWORD *)(v26 + 32);
        v42 = *(double *)(v41 + 56);
        if (v42 == v29 && *(double *)(v41 + 64) == *(double *)(v28 + 64))
        {
          if (!__gl_meshSplice(v23, *(_QWORD **)(*(_QWORD *)(v26 + 8) + 24)))
            goto LABEL_50;
          v23 = FinishLeftRegions(a1, (_QWORD **)v25, 0);
        }
        else if ((v32 & 1) != 0)
        {
          v43 = v24[4];
          v44 = *(double *)(v43 + 56);
          if (v42 < v44 || v42 == v44 && *(double *)(v41 + 64) <= *(double *)(v43 + 64))
            v24 = *(_QWORD **)(*(_QWORD *)(v26 + 8) + 24);
          v45 = __gl_meshConnect(*(_QWORD **)(v23[2] + 8), v24);
          if (!v45)
            goto LABEL_50;
          v46 = v45;
          AddRightEdges(a1, (uint64_t)v18, v45, (_QWORD *)v45[2], v45[2], 0);
          *(_BYTE *)(*(_QWORD *)(v46[1] + 48) + 23) = 1;
          WalkDirtyRegions(a1, v18);
          return;
        }
        v22 = (_QWORD *)v23[2];
      }
      AddRightEdges(a1, (uint64_t)v18, v22, v20, (uint64_t)v20, 1);
      return;
    }
    v5 = *(_QWORD *)(v5 + 16);
  }
  while (v5 != v4);
  v49[1] = 0;
  v49[2] = 0;
  v49[0] = *(_QWORD *)(v4 + 8);
  v7 = (uint64_t **)__gl_dictListSearch(*(_QWORD *)(a1 + 120), (uint64_t)v49);
  v8 = *v7;
  v9 = **v7;
  v10 = **(uint64_t ***)((*v7)[1] + 16);
  v11 = *v10;
  if (__gl_edgeSign(*(_QWORD *)(*(_QWORD *)(v9 + 8) + 32), a2, *(_QWORD *)(v9 + 32)) == 0.0)
  {
    v12 = *v8;
    v13 = *(_QWORD *)(*v8 + 32);
    v14 = *(double *)(a2 + 56);
    if (*(double *)(v13 + 56) == v14 && *(double *)(v13 + 64) == *(double *)(a2 + 64))
      SweepEvent_cold_1();
    v15 = *(_QWORD *)(v12 + 8);
    v16 = *(_QWORD *)(v15 + 32);
    if (*(double *)(v16 + 56) == v14 && *(double *)(v16 + 64) == *(double *)(a2 + 64))
      SweepEvent_cold_2();
    if (!__gl_meshSplitEdge(v15))
      goto LABEL_50;
    if (!*((_BYTE *)v8 + 23))
      goto LABEL_13;
    if (!__gl_meshDelete(*(_QWORD **)(v12 + 16)))
      goto LABEL_50;
    *((_BYTE *)v8 + 23) = 0;
LABEL_13:
    if (!__gl_meshSplice(*(_QWORD **)(a2 + 16), (_QWORD *)v12))
LABEL_50:
      longjmp((int *)(a1 + 3464), 1);
LABEL_52:
    SweepEvent(a1, a2);
  }
  else
  {
    v33 = *(_QWORD *)(v11 + 8);
    v34 = *(_QWORD *)(v33 + 32);
    v35 = *(double *)(v34 + 56);
    v36 = *(_QWORD *)(*(_QWORD *)(v9 + 8) + 32);
    v37 = *(double *)(v36 + 56);
    v38 = (uint64_t)v8;
    if (v35 >= v37)
    {
      if (v35 != v37 || (v38 = (uint64_t)v8, *(double *)(v34 + 64) > *(double *)(v36 + 64)))
        v38 = (uint64_t)v10;
    }
    if (*((_BYTE *)v8 + 20) || *(_BYTE *)(v38 + 23))
    {
      if ((uint64_t *)v38 == v8)
      {
        v40 = __gl_meshConnect(*(_QWORD **)(*(_QWORD *)(a2 + 16) + 8), *(_QWORD **)(v9 + 24));
        if (!v40)
          goto LABEL_50;
      }
      else
      {
        v39 = __gl_meshConnect(*(_QWORD **)(*(_QWORD *)(v33 + 16) + 8), *(_QWORD **)(a2 + 16));
        if (!v39)
          goto LABEL_50;
        v40 = (_QWORD *)v39[1];
      }
      if (*(_BYTE *)(v38 + 23))
      {
        if (!FixUpperEdge(v38, (uint64_t)v40))
          goto LABEL_50;
      }
      else
      {
        v47 = AddRegionBelow(a1, (uint64_t)v8, (uint64_t)v40);
        v48 = *(_DWORD *)(*v47 + 56) + *(_DWORD *)(**(_QWORD **)(v47[1] + 8) + 16);
        *((_DWORD *)v47 + 4) = v48;
        *((_BYTE *)v47 + 20) = IsWindingInside(a1, v48);
      }
      goto LABEL_52;
    }
    AddRightEdges(a1, (uint64_t)v8, *(_QWORD **)(a2 + 16), *(_QWORD **)(a2 + 16), 0, 1);
  }
}

BOOL EdgeLeq(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  double v17;
  double v18;

  v3 = *(_QWORD *)(a1 + 136);
  v4 = *a2;
  v5 = *a3;
  v6 = *(_QWORD *)(*(_QWORD *)(*a2 + 8) + 32);
  v7 = *(_QWORD *)(*(_QWORD *)(*a3 + 8) + 32);
  if (v6 == v3)
  {
    if (v7 == v3)
    {
      v16 = *(_QWORD *)(v4 + 32);
      v17 = *(double *)(v16 + 56);
      v11 = *(_QWORD *)(v5 + 32);
      v18 = *(double *)(v11 + 56);
      if (v17 >= v18 && (v17 != v18 || *(double *)(v16 + 64) > *(double *)(v11 + 64)))
      {
        v6 = v3;
        v14 = *(_QWORD *)(v5 + 32);
        v8 = *(_QWORD *)(v4 + 32);
        goto LABEL_7;
      }
      v12 = v3;
      v13 = *(_QWORD *)(v4 + 32);
    }
    else
    {
      v11 = *(_QWORD *)(v5 + 32);
      v12 = v7;
      v13 = v3;
    }
    return __gl_edgeSign(v12, v13, v11) <= 0.0;
  }
  v8 = *(_QWORD *)(v4 + 32);
  if (v7 != v3)
  {
    v9 = __gl_edgeEval(v6, v3, v8);
    v10 = v9 < __gl_edgeEval(*(_QWORD *)(*(_QWORD *)(v5 + 8) + 32), v3, *(_QWORD *)(v5 + 32));
    return !v10;
  }
  v14 = v3;
LABEL_7:
  v10 = __gl_edgeSign(v6, v14, v8) < 0.0;
  return !v10;
}

_QWORD *AddSentinel(uint64_t a1, double a2)
{
  void *v4;
  uint64_t v5;
  _QWORD *Edge;
  uint64_t v7;
  uint64_t v8;
  _QWORD *result;

  v4 = malloc_type_malloc(0x18uLL, 0x102004062D53EE8uLL);
  if (!v4)
    goto LABEL_4;
  v5 = (uint64_t)v4;
  Edge = __gl_meshMakeEdge(*(_QWORD *)(a1 + 16));
  if (!Edge)
    goto LABEL_4;
  v7 = Edge[4];
  *(_QWORD *)(v7 + 56) = 0x5F338D352E5096AFLL;
  *(double *)(v7 + 64) = a2;
  v8 = *(_QWORD *)(Edge[1] + 32);
  *(_QWORD *)(v8 + 56) = 0xDF338D352E5096AFLL;
  *(double *)(v8 + 64) = a2;
  *(_QWORD *)(a1 + 136) = v8;
  *(_QWORD *)v5 = Edge;
  *(_DWORD *)(v5 + 16) = 0;
  *(_DWORD *)(v5 + 20) = 256;
  result = __gl_dictListInsertBefore(*(_QWORD *)(a1 + 120), *(_QWORD **)(a1 + 120), v5);
  *(_QWORD *)(v5 + 8) = result;
  if (!result)
LABEL_4:
    longjmp((int *)(a1 + 3464), 1);
  return result;
}

uint64_t CallCombine(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, int a5)
{
  _QWORD *v8;
  uint64_t (*v9)();
  uint64_t result;
  uint64_t (*v11)();
  __int128 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a2 + 24) = 0;
  v8 = (_QWORD *)(a2 + 24);
  v12 = *(_OWORD *)(a2 + 32);
  v13 = *(_QWORD *)(a2 + 48);
  v9 = *(uint64_t (**)())(a1 + 3456);
  if (v9 == __gl_noCombineData)
    result = (*(uint64_t (**)(__int128 *, _QWORD *, uint64_t, _QWORD *))(a1 + 144))(&v12, a3, a4, v8);
  else
    result = ((uint64_t (*)(__int128 *, _QWORD *, uint64_t, _QWORD *, _QWORD))v9)(&v12, a3, a4, v8, *(_QWORD *)(a1 + 3656));
  if (!*v8)
  {
    if (a5)
    {
      if (!*(_BYTE *)(a1 + 116))
      {
        v11 = *(uint64_t (**)())(a1 + 3448);
        if (v11 == __gl_noErrorData)
          result = (*(uint64_t (**)(uint64_t))(a1 + 24))(100156);
        else
          result = ((uint64_t (*)(uint64_t, _QWORD))v11)(100156, *(_QWORD *)(a1 + 3656));
        *(_BYTE *)(a1 + 116) = 1;
      }
    }
    else
    {
      *v8 = *a3;
    }
  }
  return result;
}

_QWORD *TopLeftRegion(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;

  v1 = a1;
  do
    v1 = **(_QWORD ***)(v1[1] + 8);
  while (*(_QWORD *)(*v1 + 32) == *(_QWORD *)(*a1 + 32));
  if (*((_BYTE *)v1 + 23))
  {
    v2 = __gl_meshConnect(*(_QWORD **)(***(_QWORD ***)(v1[1] + 16) + 8), *(_QWORD **)(*v1 + 24));
    if (v2 && FixUpperEdge((uint64_t)v1, (uint64_t)v2))
      return **(_QWORD ***)(v1[1] + 8);
    else
      return 0;
  }
  return v1;
}

_QWORD *FinishLeftRegions(uint64_t a1, _QWORD **a2, _BYTE *a3)
{
  _QWORD *v3;
  _BYTE *v5;
  _BYTE *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v3 = *a2;
  if (a2 != (_QWORD **)a3)
  {
    v5 = a2;
    do
    {
      v5[23] = 0;
      v7 = **(_BYTE ***)(*((_QWORD *)v5 + 1) + 16);
      v8 = *(_QWORD **)v7;
      if (*(_QWORD *)(*(_QWORD *)v7 + 32) != v3[4])
      {
        if (!v7[23])
        {
          v12 = v3[5];
          *(_BYTE *)(v12 + 41) = v5[20];
          *(_QWORD *)(v12 + 16) = v3;
          DeleteRegion(a1, v5);
          return v3;
        }
        v9 = __gl_meshConnect(*(_QWORD **)(v3[2] + 8), (_QWORD *)v8[1]);
        if (!v9 || (v8 = v9, !FixUpperEdge((uint64_t)v7, (uint64_t)v9)))
LABEL_14:
          longjmp((int *)(a1 + 3464), 1);
      }
      if ((_QWORD *)v3[2] != v8
        && (!__gl_meshSplice(*(_QWORD **)(v8[1] + 24), v8) || !__gl_meshSplice(v3, v8)))
      {
        goto LABEL_14;
      }
      v10 = *(_QWORD *)v5;
      v11 = *(_QWORD *)(*(_QWORD *)v5 + 40);
      *(_BYTE *)(v11 + 41) = v5[20];
      *(_QWORD *)(v11 + 16) = v10;
      DeleteRegion(a1, v5);
      v3 = *(_QWORD **)v7;
      v5 = v7;
    }
    while (v7 != a3);
  }
  return v3;
}

void AddRightEdges(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, uint64_t a5, int a6)
{
  uint64_t v12;
  double v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  _DWORD *v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;

  do
  {
    v12 = a3[4];
    v13 = *(double *)(v12 + 56);
    v14 = a3[1];
    v15 = *(_QWORD *)(v14 + 32);
    v16 = *(double *)(v15 + 56);
    if (v13 >= v16 && (v13 != v16 || *(double *)(v12 + 64) > *(double *)(v15 + 64)))
      AddRightEdges_cold_2();
    AddRegionBelow(a1, a2, v14);
    a3 = (_QWORD *)a3[2];
  }
  while (a3 != a4);
  v17 = **(_DWORD ***)(*(_QWORD *)(a2 + 8) + 16);
  v18 = *(_QWORD *)(*(_QWORD *)v17 + 8);
  if (!a5)
    a5 = *(_QWORD *)(v18 + 16);
  if (*(_QWORD *)(v18 + 32) == *(_QWORD *)(a5 + 32))
  {
    v19 = 0;
    do
    {
      v20 = a2;
      v21 = a5;
      a2 = (uint64_t)v17;
      a5 = v18;
      if (*(_QWORD *)(v18 + 16) != v21
        && (!__gl_meshSplice(*(_QWORD **)(*(_QWORD *)(v18 + 8) + 24), (_QWORD *)v18)
         || !__gl_meshSplice(*(_QWORD **)(*(_QWORD *)(v21 + 8) + 24), (_QWORD *)a5))
        || (v22 = *(_DWORD *)(v20 + 16) - *(_DWORD *)(a5 + 56),
            *(_DWORD *)(a2 + 16) = v22,
            *(_BYTE *)(a2 + 20) = IsWindingInside(a1, v22),
            *(_BYTE *)(v20 + 22) = 1,
            (v19 & 1) != 0)
        && CheckForRightSplice(a1, (_BYTE *)v20)
        && (*(_DWORD *)(a5 + 56) += *(_DWORD *)(v21 + 56),
            *(_DWORD *)(*(_QWORD *)(a5 + 8) + 56) += *(_DWORD *)(*(_QWORD *)(v21 + 8) + 56),
            DeleteRegion(a1, (_BYTE *)v20),
            !__gl_meshDelete((_QWORD *)v21)))
      {
        longjmp((int *)(a1 + 3464), 1);
      }
      v17 = **(_DWORD ***)(*(_QWORD *)(a2 + 8) + 16);
      v18 = *(_QWORD *)(*(_QWORD *)v17 + 8);
      v19 = 1;
    }
    while (*(_QWORD *)(v18 + 32) == *(_QWORD *)(a5 + 32));
  }
  *(_BYTE *)(a2 + 22) = 1;
  if (*(_DWORD *)(a2 + 16) - *(_DWORD *)(v18 + 56) != v17[4])
    AddRightEdges_cold_1();
  if (a6)
    WalkDirtyRegions(a1, (uint64_t *)a2);
}

uint64_t FixUpperEdge(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (!*(_BYTE *)(a1 + 23))
    FixUpperEdge_cold_1();
  result = __gl_meshDelete(*(_QWORD **)a1);
  if ((_DWORD)result)
  {
    *(_BYTE *)(a1 + 23) = 0;
    *(_QWORD *)a1 = a2;
    result = 1;
    *(_QWORD *)(a2 + 48) = a1;
  }
  return result;
}

_QWORD *AddRegionBelow(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;

  v6 = malloc_type_malloc(0x18uLL, 0x102004062D53EE8uLL);
  if (!v6
    || (v7 = v6,
        *v6 = a3,
        v8 = __gl_dictListInsertBefore(*(_QWORD *)(a1 + 120), *(_QWORD **)(a2 + 8), (uint64_t)v6),
        (v7[1] = v8) == 0))
  {
    longjmp((int *)(a1 + 3464), 1);
  }
  *((_BYTE *)v7 + 23) = 0;
  *(_WORD *)((char *)v7 + 21) = 0;
  *(_QWORD *)(a3 + 48) = v7;
  return v7;
}

uint64_t IsWindingInside(uint64_t a1, unsigned int a2)
{
  uint64_t result;

  switch(*(_DWORD *)(a1 + 112))
  {
    case 0x18722:
      result = a2 & 1;
      break;
    case 0x18723:
      result = a2 != 0;
      break;
    case 0x18724:
      result = (int)a2 > 0;
      break;
    case 0x18725:
      result = a2 >> 31;
      break;
    case 0x18726:
      result = a2 - 2 < 0xFFFFFFFD;
      break;
    default:
      IsWindingInside_cold_1();
  }
  return result;
}

void DeleteRegion(uint64_t a1, _BYTE *a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)a2;
  if (a2[23] && *(_DWORD *)(v3 + 56))
    DeleteRegion_cold_1();
  *(_QWORD *)(v3 + 48) = 0;
  __gl_dictListDelete(*(_QWORD *)(a1 + 120), *((_QWORD **)a2 + 1));
  free(a2);
}

uint64_t CheckForIntersect(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  uint64_t v32;
  double v33;
  double v34;
  double v35;
  uint64_t v36;
  _BOOL4 v37;
  double v38;
  uint64_t v39;
  double v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  _QWORD *v50;
  uint64_t **v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  uint64_t v56;
  _QWORD *v57;
  _OWORD v58[5];
  _BYTE v59[8];
  uint64_t v60;
  _QWORD v61[5];

  v61[4] = *MEMORY[0x1E0C80C00];
  v4 = *a2;
  v5 = **(_BYTE ***)(a2[1] + 16);
  v6 = *(_QWORD *)v5;
  v7 = *(_QWORD *)(*a2 + 32);
  v8 = *(_QWORD *)(*(_QWORD *)v5 + 32);
  v9 = *(_QWORD *)(*(_QWORD *)(*a2 + 8) + 32);
  v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v5 + 8) + 32);
  memset(v58, 0, sizeof(v58));
  if (*(double *)(v10 + 56) == *(double *)(v9 + 56) && *(double *)(v10 + 64) == *(double *)(v9 + 64))
    CheckForIntersect_cold_1();
  if (__gl_edgeSign(v9, *(_QWORD *)(a1 + 136), v7) > 0.0)
    CheckForIntersect_cold_2();
  if (__gl_edgeSign(v10, *(_QWORD *)(a1 + 136), v8) < 0.0)
    CheckForIntersect_cold_3();
  v11 = *(_QWORD *)(a1 + 136);
  if (v7 == v11 || v8 == v11)
    CheckForIntersect_cold_9();
  if (*((_BYTE *)a2 + 23) || v5[23])
    CheckForIntersect_cold_8();
  if (v7 == v8)
    return 0;
  v12 = *(double *)(v7 + 64);
  if (v12 > *(double *)(v9 + 64))
    v13 = *(double *)(v9 + 64);
  else
    v13 = *(double *)(v7 + 64);
  v14 = *(double *)(v8 + 64);
  v15 = *(double *)(v10 + 64);
  if (v14 >= v15)
    v15 = *(double *)(v8 + 64);
  if (v13 > v15)
    return 0;
  v16 = *(double *)(v7 + 56);
  v17 = *(double *)(v8 + 56);
  if (v16 >= v17 && (v12 > v14 || v16 != v17))
  {
    if (__gl_edgeSign(v9, v8, v7) < 0.0)
      return 0;
LABEL_24:
    __gl_edgeIntersect(v9, v7, v10, v8, (uint64_t)v58);
    v19 = *(double *)(v7 + 64);
    v20 = *(double *)(v9 + 64);
    if (v19 > v20)
      v21 = *(double *)(v9 + 64);
    else
      v21 = *(double *)(v7 + 64);
    v22 = *(double *)&v58[4];
    if (v21 > *(double *)&v58[4])
      CheckForIntersect_cold_4();
    v23 = *(double *)(v8 + 64);
    v24 = *(double *)(v10 + 64);
    if (v23 >= v24)
      v24 = *(double *)(v8 + 64);
    if (*(double *)&v58[4] > v24)
      CheckForIntersect_cold_5();
    v25 = *(double *)(v10 + 56);
    v26 = *(double *)(v9 + 56);
    if (v25 > v26)
      v27 = *(double *)(v9 + 56);
    else
      v27 = *(double *)(v10 + 56);
    v28 = *((double *)&v58[3] + 1);
    if (v27 > *((double *)&v58[3] + 1))
      CheckForIntersect_cold_6();
    v29 = *(double *)(v8 + 56);
    v30 = *(double *)(v7 + 56);
    if (v29 < v30)
      v31 = *(double *)(v7 + 56);
    else
      v31 = *(double *)(v8 + 56);
    if (*((double *)&v58[3] + 1) > v31)
      CheckForIntersect_cold_7();
    v32 = *(_QWORD *)(a1 + 136);
    v33 = *(double *)(v32 + 56);
    if (*((double *)&v58[3] + 1) >= v33)
    {
      if (*((double *)&v58[3] + 1) != v33 || (v34 = *(double *)(v32 + 64), *(double *)&v58[4] > v34))
      {
LABEL_44:
        v35 = v30;
        v36 = v7;
        if (v30 >= v29)
        {
          v37 = v30 != v29;
          if (v19 > v23)
            v37 = 1;
          if (v37)
            v35 = v29;
          else
            v35 = v30;
          if (v37)
            v36 = v8;
          else
            v36 = v7;
        }
        if (v35 >= v28)
        {
          if (v35 != v28)
            goto LABEL_58;
          v38 = *(double *)(v36 + 64);
          if (v38 > v22)
            goto LABEL_58;
        }
        else
        {
          v38 = *(double *)(v36 + 64);
        }
        *((double *)&v58[3] + 1) = v35;
        *(double *)&v58[4] = v38;
        v22 = v38;
        v28 = v35;
LABEL_58:
        if (v28 == v30 && v22 == v19 || v28 == v29 && v22 == *(double *)(v8 + 64))
        {
          CheckForRightSplice(a1, a2);
          return 0;
        }
        v41 = *(double *)(v32 + 56);
        if (v26 != v41 || v20 != *(double *)(v32 + 64))
        {
          if (__gl_edgeSign(v9, v32, (uint64_t)v58) >= 0.0)
            goto LABEL_77;
          v25 = *(double *)(v10 + 56);
          v32 = *(_QWORD *)(a1 + 136);
          v41 = *(double *)(v32 + 56);
        }
        if (v25 == v41 && *(double *)(v10 + 64) == *(double *)(v32 + 64) || __gl_edgeSign(v10, v32, (uint64_t)v58) > 0.0)
        {
          if (__gl_meshSplitEdge(*(_QWORD *)(v4 + 8))
            && __gl_meshSplitEdge(*(_QWORD *)(v6 + 8))
            && __gl_meshSplice(*(_QWORD **)(*(_QWORD *)(v6 + 8) + 24), (_QWORD *)v4))
          {
            v42 = *(_QWORD *)(v4 + 32);
            *(_OWORD *)(v42 + 56) = *(_OWORD *)((char *)&v58[3] + 8);
            v43 = __gl_pqSortInsert(*(_QWORD *)(a1 + 128), v42);
            v44 = *(_QWORD *)(v4 + 32);
            *(_QWORD *)(v44 + 72) = v43;
            if (v43 != 0x7FFFFFFFFFFFFFFFLL)
            {
              v45 = *(_QWORD *)(v9 + 24);
              v61[0] = *(_QWORD *)(v7 + 24);
              v61[1] = v45;
              v46 = *(_QWORD *)(v10 + 24);
              v61[2] = *(_QWORD *)(v8 + 24);
              v61[3] = v46;
              *(_QWORD *)(v44 + 40) = 0;
              *(_QWORD *)(v44 + 48) = 0;
              *(_QWORD *)(v44 + 32) = 0;
              VertexWeights((double *)v44, (double *)v7, (double *)v9, (uint64_t)v59);
              VertexWeights((double *)v44, (double *)v8, (double *)v10, (uint64_t)&v60);
              CallCombine(a1, v44, v61, (uint64_t)v59, 1);
              v39 = 0;
              v5[22] = 1;
              *((_BYTE *)a2 + 22) = 1;
              *(_BYTE *)(**(_QWORD **)(a2[1] + 8) + 22) = 1;
              return v39;
            }
            __gl_pqSortDeletePriorityQ(*(void ****)(a1 + 128));
            *(_QWORD *)(a1 + 128) = 0;
          }
          goto LABEL_106;
        }
LABEL_77:
        v47 = *(_QWORD *)(a1 + 136);
        if (v10 == v47)
        {
          if (!__gl_meshSplitEdge(*(_QWORD *)(v4 + 8)))
            goto LABEL_106;
          if (!__gl_meshSplice(*(_QWORD **)(v6 + 8), (_QWORD *)v4))
            goto LABEL_106;
          v49 = TopLeftRegion(a2);
          if (!v49)
            goto LABEL_106;
          v50 = v49;
          v51 = *(uint64_t ***)(v49[1] + 16);
          v52 = **v51;
          FinishLeftRegions(a1, (_QWORD **)*v51, v5);
          v53 = *(_QWORD *)(*(_QWORD *)(v52 + 8) + 24);
          v39 = 1;
          v54 = a1;
          v55 = v50;
          v56 = v52;
        }
        else
        {
          if (v9 != v47)
          {
            if (__gl_edgeSign(v9, v47, (uint64_t)v58) >= 0.0)
            {
              *((_BYTE *)a2 + 22) = 1;
              *(_BYTE *)(**(_QWORD **)(a2[1] + 8) + 22) = 1;
              if (!__gl_meshSplitEdge(*(_QWORD *)(v4 + 8)))
                goto LABEL_106;
              v48 = *(_QWORD *)(a1 + 136);
              *(_OWORD *)(*(_QWORD *)(v4 + 32) + 56) = *(_OWORD *)(v48 + 56);
            }
            else
            {
              v48 = *(_QWORD *)(a1 + 136);
            }
            if (__gl_edgeSign(v10, v48, (uint64_t)v58) > 0.0)
              return 0;
            v5[22] = 1;
            *((_BYTE *)a2 + 22) = 1;
            if (__gl_meshSplitEdge(*(_QWORD *)(v6 + 8)))
            {
              v39 = 0;
              *(_OWORD *)(*(_QWORD *)(v6 + 32) + 56) = *(_OWORD *)(*(_QWORD *)(a1 + 136) + 56);
              return v39;
            }
LABEL_106:
            longjmp((int *)(a1 + 3464), 1);
          }
          if (!__gl_meshSplitEdge(*(_QWORD *)(v6 + 8))
            || !__gl_meshSplice(*(_QWORD **)(v4 + 24), *(_QWORD **)(*(_QWORD *)(v6 + 8) + 24)))
          {
            goto LABEL_106;
          }
          v57 = a2;
          do
            v57 = **(_QWORD ***)(v57[1] + 8);
          while (*(_QWORD *)(*(_QWORD *)(*v57 + 8) + 32) == *(_QWORD *)(*(_QWORD *)(*a2 + 8) + 32));
          v52 = *(_QWORD *)(*(_QWORD *)(***(_QWORD ***)(v57[1] + 16) + 8) + 16);
          *a2 = *(_QWORD *)(*(_QWORD *)(v6 + 8) + 24);
          v53 = FinishLeftRegions(a1, (_QWORD **)a2, 0)[2];
          v56 = *(_QWORD *)(*(_QWORD *)(v4 + 8) + 16);
          v39 = 1;
          v54 = a1;
          v55 = v57;
        }
        AddRightEdges(v54, v55, v53, v56, v52, 1);
        return v39;
      }
    }
    else
    {
      v34 = *(double *)(v32 + 64);
    }
    *((_QWORD *)&v58[3] + 1) = *(_QWORD *)(v32 + 56);
    *(double *)&v58[4] = v34;
    v22 = v34;
    v28 = v33;
    goto LABEL_44;
  }
  if (__gl_edgeSign(v10, v7, v8) <= 0.0)
    goto LABEL_24;
  return 0;
}

void WalkDirtyRegions(uint64_t a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  double v13;
  double v14;
  double v15;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t **v21;
  uint64_t **v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;

  v2 = a2;
  v4 = **(uint64_t ***)(a2[1] + 16);
  while (1)
  {
    if (*((_BYTE *)v4 + 22))
    {
      do
      {
        v5 = v4;
        v4 = **(uint64_t ***)(v4[1] + 16);
      }
      while (*((_BYTE *)v4 + 22));
    }
    else
    {
      v5 = v2;
    }
    if (*((_BYTE *)v5 + 22))
    {
      v2 = v5;
      v5 = v4;
      goto LABEL_10;
    }
    v2 = **(uint64_t ***)(v5[1] + 8);
    if (!v2 || !*((_BYTE *)v2 + 22))
      break;
LABEL_10:
    *((_BYTE *)v2 + 22) = 0;
    v6 = *v2;
    v7 = *v5;
    v8 = *(_QWORD *)(*(_QWORD *)(*v2 + 8) + 32);
    if (v8 == *(_QWORD *)(*(_QWORD *)(*v5 + 8) + 32))
      goto LABEL_32;
    v9 = **(_BYTE ***)(v2[1] + 16);
    v10 = *(_QWORD *)v9;
    v11 = *(double *)(v8 + 56);
    v12 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 8) + 32);
    v13 = *(double *)(v12 + 56);
    if (v11 == v13)
    {
      v14 = *(double *)(v8 + 64);
      v15 = *(double *)(v12 + 64);
      if (v14 == v15)
        WalkDirtyRegions_cold_1();
      if (v11 < v13 || v14 <= v15)
      {
LABEL_17:
        if (__gl_edgeSign(*(_QWORD *)(*(_QWORD *)(*v2 + 8) + 32), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 8) + 32), *(_QWORD *)(v6 + 32)) < 0.0)goto LABEL_32;
        *((_BYTE *)v2 + 22) = 1;
        *(_BYTE *)(**(_QWORD **)(v2[1] + 8) + 22) = 1;
        v17 = __gl_meshSplitEdge(v6);
        if (!v17)
          goto LABEL_51;
        v18 = v17;
        if (!__gl_meshSplice(*(_QWORD **)(v10 + 8), v17))
          goto LABEL_51;
        goto LABEL_26;
      }
    }
    else if (v11 < v13)
    {
      goto LABEL_17;
    }
    if (__gl_edgeSign(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 8) + 32), v8, *(_QWORD *)(v10 + 32)) > 0.0)
      goto LABEL_32;
    v9[22] = 1;
    *((_BYTE *)v2 + 22) = 1;
    v19 = __gl_meshSplitEdge(v10);
    if (!v19 || (v20 = v19, !__gl_meshSplice(*(_QWORD **)(v6 + 24), *(_QWORD **)(v10 + 8))))
LABEL_51:
      longjmp((int *)(a1 + 3464), 1);
    v18 = (_QWORD *)v20[1];
LABEL_26:
    *(_BYTE *)(v18[5] + 41) = *((_BYTE *)v2 + 20);
    if (*((_BYTE *)v5 + 23))
    {
      DeleteRegion(a1, v5);
      if (!__gl_meshDelete((_QWORD *)v7))
        goto LABEL_51;
      v21 = *(uint64_t ***)(v2[1] + 16);
      v4 = *v21;
      v7 = **v21;
      goto LABEL_33;
    }
    if (*((_BYTE *)v2 + 23))
    {
      DeleteRegion(a1, v2);
      if (!__gl_meshDelete((_QWORD *)v6))
        goto LABEL_51;
      v22 = *(uint64_t ***)(v5[1] + 8);
      v2 = *v22;
      v6 = **v22;
    }
LABEL_32:
    v4 = v5;
LABEL_33:
    if (*(_QWORD *)(v6 + 32) != *(_QWORD *)(v7 + 32))
    {
      v23 = *(_QWORD *)(*(_QWORD *)(v6 + 8) + 32);
      v24 = *(_QWORD *)(*(_QWORD *)(v7 + 8) + 32);
      if (v23 == v24
        || *((_BYTE *)v2 + 23)
        || *((_BYTE *)v4 + 23)
        || ((v25 = *(_QWORD *)(a1 + 136), v23 != v25) ? (v26 = v24 == v25) : (v26 = 1), !v26))
      {
        CheckForRightSplice(a1, v2);
      }
      else if (CheckForIntersect(a1, v2))
      {
        return;
      }
    }
    if (*(_QWORD *)(v6 + 32) == *(_QWORD *)(v7 + 32))
    {
      v27 = *(_QWORD *)(v6 + 8);
      v28 = *(_QWORD *)(v7 + 8);
      if (*(_QWORD *)(v27 + 32) == *(_QWORD *)(v28 + 32))
      {
        *(_DWORD *)(v7 + 56) += *(_DWORD *)(v6 + 56);
        *(_DWORD *)(v28 + 56) += *(_DWORD *)(v27 + 56);
        DeleteRegion(a1, v2);
        if (!__gl_meshDelete((_QWORD *)v6))
          goto LABEL_51;
        v2 = **(uint64_t ***)(v4[1] + 8);
      }
    }
  }
}

uint64_t CheckForRightSplice(uint64_t a1, _BYTE *a2)
{
  _QWORD *v4;
  _BYTE *v5;
  uint64_t v6;
  uint64_t v7;
  double v8;
  uint64_t v9;
  double v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;

  v4 = *(_QWORD **)a2;
  v5 = **(_BYTE ***)(*((_QWORD *)a2 + 1) + 16);
  v6 = *(_QWORD *)v5;
  v7 = *(_QWORD *)(*(_QWORD *)a2 + 32);
  v8 = *(double *)(v7 + 56);
  v9 = *(_QWORD *)(*(_QWORD *)v5 + 32);
  v10 = *(double *)(v9 + 56);
  if (v8 >= v10 && (v8 != v10 || *(double *)(v7 + 64) > *(double *)(v9 + 64)))
  {
    if (__gl_edgeSign(*(_QWORD *)(v4[1] + 32), *(_QWORD *)(*(_QWORD *)v5 + 32), v7) >= 0.0)
    {
      a2[22] = 1;
      *(_BYTE *)(**(_QWORD **)(*((_QWORD *)a2 + 1) + 8) + 22) = 1;
      if (!__gl_meshSplitEdge(v4[1]) || !__gl_meshSplice(*(_QWORD **)(*(_QWORD *)(v6 + 8) + 24), v4))
        goto LABEL_18;
      return 1;
    }
    return 0;
  }
  if (__gl_edgeSign(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 32), *(_QWORD *)(*(_QWORD *)a2 + 32), v9) > 0.0)
    return 0;
  v12 = v4[4];
  v13 = *(_QWORD *)(v6 + 32);
  if (*(double *)(v12 + 56) == *(double *)(v13 + 56) && *(double *)(v12 + 64) == *(double *)(v13 + 64))
  {
    if (v12 != v13)
    {
      __gl_pqSortDelete(*(uint64_t **)(a1 + 128), *(_QWORD *)(v12 + 72));
      SpliceMergeVertices(a1, *(_QWORD **)(*(_QWORD *)(v6 + 8) + 24), v4);
    }
    return 1;
  }
  if (!__gl_meshSplitEdge(*(_QWORD *)(v6 + 8))
    || !__gl_meshSplice(v4, *(_QWORD **)(*(_QWORD *)(v6 + 8) + 24)))
  {
LABEL_18:
    longjmp((int *)(a1 + 3464), 1);
  }
  result = 1;
  v5[22] = 1;
  a2[22] = 1;
  return result;
}

double VertexWeights(double *a1, double *a2, double *a3, uint64_t a4)
{
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  float v13;
  double v14;
  double v15;
  double result;

  v5 = a1[6];
  v4 = a1[7];
  v6 = a2[7] - v4;
  if (v6 < 0.0)
    v6 = -v6;
  v7 = a1[8];
  v8 = a2[8] - v7;
  if (v8 < 0.0)
    v8 = -v8;
  v9 = a3[7] - v4;
  if (v9 < 0.0)
    v9 = -v9;
  v10 = a3[8] - v7;
  if (v10 < 0.0)
    v10 = -v10;
  v11 = v6 + v8;
  v12 = v11 + v9 + v10;
  v13 = (v9 + v10) * 0.5 / v12;
  *(float *)&v11 = v11 * 0.5 / v12;
  *(float *)a4 = v13;
  *(_DWORD *)(a4 + 4) = LODWORD(v11);
  v14 = *(float *)&v11;
  v15 = a1[5];
  a1[4] = a1[4] + a2[4] * v13 + a3[4] * v14;
  a1[5] = v15 + a2[5] * v13 + a3[5] * v14;
  result = v5 + a2[6] * v13 + a3[6] * v14;
  a1[6] = result;
  return result;
}

void __gl_computeInterior_cold_1()
{
  __assert_rtn("DoneEdgeDict", "sweep.c", 1184, "reg->fixUpperEdge");
}

void __gl_computeInterior_cold_2()
{
  __assert_rtn("RemoveDegenerateFaces", "sweep.c", 1286, "e->Lnext != e");
}

void __gl_computeInterior_cold_3()
{
  __assert_rtn("DoneEdgeDict", "sweep.c", 1187, "reg->windingNumber == 0");
}

void __gl_computeInterior_cold_4()
{
  __assert_rtn("DoneEdgeDict", "sweep.c", 1185, "++fixedEdges == 1");
}

void SweepEvent_cold_1()
{
  __assert_rtn("ConnectLeftDegenerate", "sweep.c", 953, "TOLERANCE_NONZERO");
}

void SweepEvent_cold_2()
{
  __assert_rtn("ConnectLeftDegenerate", "sweep.c", 974, "TOLERANCE_NONZERO");
}

void AddRightEdges_cold_1()
{
  __assert_rtn("AddRightEdges", "sweep.c", 399, "regPrev->windingNumber - e->winding == reg->windingNumber");
}

void AddRightEdges_cold_2()
{
  __assert_rtn("AddRightEdges", "sweep.c", 357, "VertLeq( e->Org, e->Dst)");
}

void FixUpperEdge_cold_1()
{
  __assert_rtn("FixUpperEdge", "sweep.c", 167, "reg->fixUpperEdge");
}

void IsWindingInside_cold_1()
{
  __assert_rtn("IsWindingInside", "sweep.c", 249, "FALSE");
}

void DeleteRegion_cold_1()
{
  __assert_rtn("DeleteRegion", "sweep.c", 154, "reg->eUp->winding == 0");
}

void CheckForIntersect_cold_1()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 624, "! VertEq( dstLo, dstUp)");
}

void CheckForIntersect_cold_2()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 625, "EdgeSign( dstUp, tess->event, orgUp) <= 0");
}

void CheckForIntersect_cold_3()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 626, "EdgeSign( dstLo, tess->event, orgLo) >= 0");
}

void CheckForIntersect_cold_4()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 647, "MIN( orgUp->t, dstUp->t) <= isect.t");
}

void CheckForIntersect_cold_5()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 648, "isect.t <= MAX( orgLo->t, dstLo->t)");
}

void CheckForIntersect_cold_6()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 649, "MIN( dstLo->s, dstUp->s) <= isect.s");
}

void CheckForIntersect_cold_7()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 650, "isect.s <= MAX( orgLo->s, orgUp->s)");
}

void CheckForIntersect_cold_8()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 628, "! regUp->fixUpperEdge && ! regLo->fixUpperEdge");
}

void CheckForIntersect_cold_9()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 627, "orgUp != tess->event && orgLo != tess->event");
}

void WalkDirtyRegions_cold_1()
{
  __assert_rtn("CheckForLeftSplice", "sweep.c", 577, "! VertEq( eUp->Dst, eLo->Dst)");
}

_QWORD *__gl_dictListNewDict(uint64_t a1, uint64_t a2)
{
  _QWORD *result;

  result = malloc_type_malloc(0x28uLL, 0xA0040D423F0E8uLL);
  if (result)
  {
    *result = 0;
    result[1] = result;
    result[2] = result;
    result[3] = a1;
    result[4] = a2;
  }
  return result;
}

void __gl_dictListDeleteDict(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[1];
  if (v2 != a1)
  {
    do
    {
      v3 = (_QWORD *)v2[1];
      free(v2);
      v2 = v3;
    }
    while (v3 != a1);
  }
  free(a1);
}

_QWORD *__gl_dictListInsertBefore(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;
  uint64_t v7;

  do
    a2 = (_QWORD *)a2[2];
  while (*a2 && !(*(unsigned int (**)(_QWORD, _QWORD, uint64_t))(a1 + 32))(*(_QWORD *)(a1 + 24), *a2, a3));
  result = malloc_type_malloc(0x18uLL, 0xA00409BE6959DuLL);
  if (result)
  {
    v7 = a2[1];
    *result = a3;
    result[1] = v7;
    *(_QWORD *)(a2[1] + 16) = result;
    result[2] = a2;
    a2[1] = result;
  }
  return result;
}

void __gl_dictListDelete(int a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = a2[1];
  *(_QWORD *)(v2 + 16) = a2[2];
  *(_QWORD *)(a2[2] + 8) = v2;
  free(a2);
}

_QWORD *__gl_dictListSearch(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;

  v4 = (_QWORD *)a1;
  do
    v4 = (_QWORD *)v4[1];
  while (*v4 && !(*(unsigned int (**)(_QWORD, uint64_t))(a1 + 32))(*(_QWORD *)(a1 + 24), a2));
  return v4;
}

_QWORD *__gl_meshMakeEdge(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *result;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;

  v2 = malloc_type_malloc(0x50uLL, 0x10A004024993A61uLL);
  v3 = malloc_type_malloc(0x50uLL, 0x10A004024993A61uLL);
  v4 = malloc_type_malloc(0x30uLL, 0x10A0040FE2E6FF0uLL);
  v5 = v4;
  if (!v2 || !v3 || !v4)
  {
    if (v2)
      free(v2);
    if (v3)
      free(v3);
    if (!v5)
      return 0;
    goto LABEL_19;
  }
  result = MakeEdge(a1 + 128);
  if (!result)
  {
    free(v2);
    free(v3);
LABEL_19:
    free(v5);
    return 0;
  }
  v7 = *(_QWORD **)(a1 + 8);
  *v7 = v2;
  v2[1] = v7;
  v2[2] = result;
  v2[3] = 0;
  v8 = result;
  do
  {
    v8[4] = v2;
    v8 = (_QWORD *)v8[2];
  }
  while (v8 != result);
  v9 = result[1];
  *v2 = v3;
  *v3 = a1;
  v3[1] = v2;
  *(_QWORD *)(a1 + 8) = v3;
  v3[2] = v9;
  v3[3] = 0;
  v10 = v9;
  do
  {
    *(_QWORD *)(v10 + 32) = v3;
    v10 = *(_QWORD *)(v10 + 16);
  }
  while (v10 != v9);
  v11 = *(_QWORD **)(a1 + 88);
  *v11 = v5;
  *v5 = a1 + 80;
  v5[1] = v11;
  *(_QWORD *)(a1 + 88) = v5;
  v5[2] = result;
  v5[3] = 0;
  v5[4] = 0;
  *((_BYTE *)v5 + 40) = 0;
  *((_BYTE *)v5 + 41) = *(_BYTE *)(a1 + 121);
  v12 = result;
  do
  {
    v12[5] = v5;
    v12 = (_QWORD *)v12[3];
  }
  while (v12 != result);
  return result;
}

_QWORD *MakeEdge(unint64_t a1)
{
  _QWORD *result;
  unint64_t v3;
  uint64_t *v4;
  uint64_t v5;

  result = malloc_type_malloc(0x80uLL, 0x1020040E084476EuLL);
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 8);
    if (v3 >= a1)
      v3 = a1;
    v4 = *(uint64_t **)(v3 + 8);
    v5 = *v4;
    result[8] = *v4;
    **(_QWORD **)(v5 + 8) = result;
    *result = v3;
    *v4 = (uint64_t)(result + 8);
    result[1] = result + 8;
    result[2] = result;
    result[3] = result + 8;
    result[4] = 0;
    result[5] = 0;
    result[6] = 0;
    *((_DWORD *)result + 14) = 0;
    result[9] = result;
    result[10] = result + 8;
    result[11] = result;
    result[12] = 0;
    result[13] = 0;
    result[14] = 0;
    *((_DWORD *)result + 30) = 0;
  }
  return result;
}

uint64_t __gl_meshSplice(_QWORD *a1, _QWORD *a2)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t *v23;
  _QWORD *v24;

  if (a1 == a2)
    return 1;
  v4 = (uint64_t *)a2[4];
  v5 = (uint64_t *)a1[4];
  if (v4 != v5)
  {
    v6 = v4[2];
    v7 = v6;
    do
    {
      *(_QWORD *)(v7 + 32) = v5;
      v7 = *(_QWORD *)(v7 + 16);
    }
    while (v7 != v6);
    v9 = *v4;
    v8 = (_QWORD *)v4[1];
    *(_QWORD *)(v9 + 8) = v8;
    *v8 = v9;
    free(v4);
  }
  v10 = (uint64_t *)a2[5];
  v11 = (uint64_t *)a1[5];
  if (v10 != v11)
  {
    v12 = v10[2];
    v13 = v12;
    do
    {
      *(_QWORD *)(v13 + 40) = v11;
      v13 = *(_QWORD *)(v13 + 24);
    }
    while (v13 != v12);
    v15 = *v10;
    v14 = (_QWORD *)v10[1];
    *(_QWORD *)(v15 + 8) = v14;
    *v14 = v15;
    free(v10);
  }
  v16 = a2[2];
  v17 = a1[2];
  *(_QWORD *)(*(_QWORD *)(v16 + 8) + 24) = a1;
  *(_QWORD *)(*(_QWORD *)(v17 + 8) + 24) = a2;
  a2[2] = v17;
  a1[2] = v16;
  if (v4 == v5)
  {
    result = (uint64_t)malloc_type_malloc(0x50uLL, 0x10A004024993A61uLL);
    if (!result)
      return result;
    v19 = a1[4];
    v20 = *(uint64_t **)(v19 + 8);
    *v20 = result;
    *(_QWORD *)result = v19;
    *(_QWORD *)(result + 8) = v20;
    *(_QWORD *)(v19 + 8) = result;
    *(_QWORD *)(result + 16) = a2;
    *(_QWORD *)(result + 24) = 0;
    v21 = a2;
    do
    {
      v21[4] = result;
      v21 = (_QWORD *)v21[2];
    }
    while (v21 != a2);
    *(_QWORD *)(a1[4] + 16) = a1;
  }
  if (v10 == v11)
  {
    result = (uint64_t)malloc_type_malloc(0x30uLL, 0x10A0040FE2E6FF0uLL);
    if (!result)
      return result;
    v22 = a1[5];
    v23 = *(uint64_t **)(v22 + 8);
    *v23 = result;
    *(_QWORD *)result = v22;
    *(_QWORD *)(result + 8) = v23;
    *(_QWORD *)(v22 + 8) = result;
    *(_QWORD *)(result + 24) = 0;
    *(_QWORD *)(result + 32) = 0;
    *(_QWORD *)(result + 16) = a2;
    *(_BYTE *)(result + 40) = 0;
    *(_BYTE *)(result + 41) = *(_BYTE *)(v22 + 41);
    v24 = a2;
    do
    {
      v24[5] = result;
      v24 = (_QWORD *)v24[3];
    }
    while (v24 != a2);
    *(_QWORD *)(a1[5] + 16) = a1;
  }
  return 1;
}

uint64_t __gl_meshDelete(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v2 = (_QWORD *)a1[1];
  v3 = (uint64_t *)a1[5];
  v4 = (uint64_t *)v2[5];
  if (v3 != v4)
  {
    v5 = v3[2];
    v6 = v5;
    do
    {
      *(_QWORD *)(v6 + 40) = v4;
      v6 = *(_QWORD *)(v6 + 24);
    }
    while (v6 != v5);
    v8 = *v3;
    v7 = (_QWORD *)v3[1];
    *(_QWORD *)(v8 + 8) = v7;
    *v7 = v8;
    free(v3);
  }
  v9 = (_QWORD *)a1[2];
  if (v9 == a1)
  {
    v17 = (uint64_t *)a1[4];
    v18 = v17[2];
    v19 = v18;
    do
    {
      *(_QWORD *)(v19 + 32) = 0;
      v19 = *(_QWORD *)(v19 + 16);
    }
    while (v19 != v18);
    v21 = *v17;
    v20 = (_QWORD *)v17[1];
    *(_QWORD *)(v21 + 8) = v20;
    *v20 = v21;
    free(v17);
  }
  else
  {
    v10 = a1[1];
    v11 = *(_QWORD *)(v10 + 24);
    *(_QWORD *)(*(_QWORD *)(v10 + 40) + 16) = v11;
    *(_QWORD *)(a1[4] + 16) = v9;
    v12 = *(_QWORD *)(v11 + 16);
    *(_QWORD *)(v9[1] + 24) = v11;
    *(_QWORD *)(*(_QWORD *)(v12 + 8) + 24) = a1;
    a1[2] = v12;
    *(_QWORD *)(v11 + 16) = v9;
    if (v3 == v4)
    {
      result = (uint64_t)malloc_type_malloc(0x30uLL, 0x10A0040FE2E6FF0uLL);
      if (!result)
        return result;
      v14 = a1[5];
      v15 = *(uint64_t **)(v14 + 8);
      *v15 = result;
      *(_QWORD *)result = v14;
      *(_QWORD *)(result + 8) = v15;
      *(_QWORD *)(v14 + 8) = result;
      *(_QWORD *)(result + 24) = 0;
      *(_QWORD *)(result + 32) = 0;
      *(_QWORD *)(result + 16) = a1;
      *(_BYTE *)(result + 40) = 0;
      *(_BYTE *)(result + 41) = *(_BYTE *)(v14 + 41);
      v16 = a1;
      do
      {
        v16[5] = result;
        v16 = (_QWORD *)v16[3];
      }
      while (v16 != a1);
    }
  }
  v22 = (_QWORD *)v2[2];
  if (v22 == v2)
  {
    v25 = (uint64_t *)v2[4];
    v26 = v25[2];
    v27 = v26;
    do
    {
      *(_QWORD *)(v27 + 32) = 0;
      v27 = *(_QWORD *)(v27 + 16);
    }
    while (v27 != v26);
    v29 = *v25;
    v28 = (_QWORD *)v25[1];
    *(_QWORD *)(v29 + 8) = v28;
    *v28 = v29;
    free(v25);
    v30 = (uint64_t *)v2[5];
    v31 = v30[2];
    v32 = v31;
    do
    {
      *(_QWORD *)(v32 + 40) = 0;
      v32 = *(_QWORD *)(v32 + 24);
    }
    while (v32 != v31);
    v34 = *v30;
    v33 = (_QWORD *)v30[1];
    *(_QWORD *)(v34 + 8) = v33;
    *v33 = v34;
    free(v30);
  }
  else
  {
    v23 = *(_QWORD *)(v2[1] + 24);
    *(_QWORD *)(a1[5] + 16) = v23;
    *(_QWORD *)(v2[4] + 16) = v22;
    v24 = *(_QWORD *)(v23 + 16);
    *(_QWORD *)(v22[1] + 24) = v23;
    *(_QWORD *)(*(_QWORD *)(v24 + 8) + 24) = v2;
    v2[2] = v24;
    *(_QWORD *)(v23 + 16) = v22;
  }
  if (a1[1] >= (unint64_t)a1)
    v35 = a1;
  else
    v35 = (uint64_t *)a1[1];
  v36 = *v35;
  v37 = *(_QWORD *)v35[1];
  **(_QWORD **)(*v35 + 8) = v37;
  **(_QWORD **)(v37 + 8) = v36;
  free(v35);
  return 1;
}

_QWORD *__gl_meshAddEdgeVertex(_QWORD *a1)
{
  _QWORD *Edge;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;

  Edge = MakeEdge((unint64_t)a1);
  v3 = Edge;
  if (Edge)
  {
    v4 = a1[3];
    v6 = Edge[1];
    v5 = Edge[2];
    v7 = *(_QWORD *)(v4 + 16);
    *(_QWORD *)(*(_QWORD *)(v5 + 8) + 24) = v4;
    *(_QWORD *)(*(_QWORD *)(v7 + 8) + 24) = Edge;
    Edge[2] = v7;
    *(_QWORD *)(v4 + 16) = v5;
    Edge[4] = *(_QWORD *)(a1[1] + 32);
    v8 = malloc_type_malloc(0x50uLL, 0x10A004024993A61uLL);
    if (v8)
    {
      v9 = v3[4];
      v10 = *(_QWORD **)(v9 + 8);
      *v10 = v8;
      *v8 = v9;
      v8[1] = v10;
      *(_QWORD *)(v9 + 8) = v8;
      v8[2] = v6;
      v8[3] = 0;
      v11 = v6;
      do
      {
        *(_QWORD *)(v11 + 32) = v8;
        v11 = *(_QWORD *)(v11 + 16);
      }
      while (v11 != v6);
      v12 = a1[5];
      *(_QWORD *)(v6 + 40) = v12;
      v3[5] = v12;
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

_QWORD *__gl_meshSplitEdge(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  result = __gl_meshAddEdgeVertex((_QWORD *)a1);
  if (result)
  {
    result = (_QWORD *)result[1];
    v3 = *(_QWORD *)(a1 + 8);
    v4 = *(_QWORD *)(v3 + 16);
    v5 = *(_QWORD *)(*(_QWORD *)(v3 + 8) + 24);
    v6 = *(_QWORD *)(v5 + 16);
    *(_QWORD *)(*(_QWORD *)(v4 + 8) + 24) = v5;
    *(_QWORD *)(*(_QWORD *)(v6 + 8) + 24) = v3;
    *(_QWORD *)(v3 + 16) = v6;
    *(_QWORD *)(v5 + 16) = v4;
    v7 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(*(_QWORD *)(v7 + 8) + 24) = result;
    v9 = result[1];
    v8 = result[2];
    *(_QWORD *)(*(_QWORD *)(v8 + 8) + 24) = v3;
    *(_QWORD *)(v3 + 16) = v8;
    result[2] = v7;
    *(_QWORD *)(v3 + 32) = result[4];
    *(_QWORD *)(*(_QWORD *)(v9 + 32) + 16) = v9;
    *(_QWORD *)(v9 + 40) = *(_QWORD *)(v3 + 40);
    *((_DWORD *)result + 14) = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(v9 + 56) = *(_DWORD *)(v3 + 56);
  }
  return result;
}

_QWORD *__gl_meshConnect(_QWORD *a1, _QWORD *a2)
{
  _QWORD *Edge;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;

  Edge = MakeEdge((unint64_t)a1);
  v5 = Edge;
  if (Edge)
  {
    v6 = (_QWORD *)Edge[1];
    v7 = (uint64_t *)a2[5];
    v8 = (uint64_t *)a1[5];
    if (v7 == v8)
    {
      v13 = a2[5];
    }
    else
    {
      v9 = v7[2];
      v10 = v9;
      do
      {
        *(_QWORD *)(v10 + 40) = v8;
        v10 = *(_QWORD *)(v10 + 24);
      }
      while (v10 != v9);
      v12 = *v7;
      v11 = (_QWORD *)v7[1];
      *(_QWORD *)(v12 + 8) = v11;
      *v11 = v12;
      free(v7);
      v13 = a1[5];
    }
    v14 = a1[3];
    v15 = v5[2];
    v16 = *(_QWORD *)(v14 + 16);
    *(_QWORD *)(*(_QWORD *)(v15 + 8) + 24) = v14;
    *(_QWORD *)(*(_QWORD *)(v16 + 8) + 24) = v5;
    v5[2] = v16;
    *(_QWORD *)(v14 + 16) = v15;
    v17 = v6[2];
    v18 = a2[2];
    *(_QWORD *)(*(_QWORD *)(v17 + 8) + 24) = a2;
    *(_QWORD *)(*(_QWORD *)(v18 + 8) + 24) = v6;
    v6[2] = v18;
    a2[2] = v17;
    v5[4] = *(_QWORD *)(a1[1] + 32);
    v6[4] = a2[4];
    v6[5] = v13;
    v5[5] = v13;
    *(_QWORD *)(a1[5] + 16) = v6;
    if (v7 == v8)
    {
      v19 = malloc_type_malloc(0x30uLL, 0x10A0040FE2E6FF0uLL);
      if (v19)
      {
        v20 = a1[5];
        v21 = *(_QWORD **)(v20 + 8);
        *v21 = v19;
        *v19 = v20;
        v19[1] = v21;
        *(_QWORD *)(v20 + 8) = v19;
        v19[3] = 0;
        v19[4] = 0;
        v19[2] = v5;
        *((_BYTE *)v19 + 40) = 0;
        *((_BYTE *)v19 + 41) = *(_BYTE *)(v20 + 41);
        v22 = v5;
        do
        {
          v22[5] = v19;
          v22 = (_QWORD *)v22[3];
        }
        while (v22 != v5);
      }
      else
      {
        return 0;
      }
    }
  }
  return v5;
}

void __gl_meshZapFace(uint64_t *a1)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  _QWORD *v26;
  uint64_t v27;

  v2 = (uint64_t *)a1[2];
  v3 = (uint64_t *)v2[3];
  do
  {
    v4 = (uint64_t *)v3[3];
    v3[5] = 0;
    v5 = (uint64_t *)v3[1];
    if (!v5[5])
    {
      v6 = (uint64_t *)v3[2];
      v7 = (uint64_t *)v3[4];
      if (v6 == v3)
      {
        v10 = v7[2];
        v11 = v10;
        do
        {
          *(_QWORD *)(v11 + 32) = 0;
          v11 = *(_QWORD *)(v11 + 16);
        }
        while (v11 != v10);
        v13 = *v7;
        v12 = (_QWORD *)v7[1];
        *(_QWORD *)(v13 + 8) = v12;
        *v12 = v13;
        free(v7);
        v5 = (uint64_t *)v3[1];
      }
      else
      {
        v7[2] = (uint64_t)v6;
        v8 = v5[3];
        v9 = *(_QWORD *)(v8 + 16);
        *(_QWORD *)(v6[1] + 24) = v8;
        *(_QWORD *)(*(_QWORD *)(v9 + 8) + 24) = v3;
        v3[2] = v9;
        *(_QWORD *)(v8 + 16) = v6;
      }
      v14 = (uint64_t *)v5[2];
      v15 = (uint64_t *)v5[4];
      if (v14 == v5)
      {
        v18 = v15[2];
        v19 = v18;
        do
        {
          *(_QWORD *)(v19 + 32) = 0;
          v19 = *(_QWORD *)(v19 + 16);
        }
        while (v19 != v18);
        v21 = *v15;
        v20 = (_QWORD *)v15[1];
        *(_QWORD *)(v21 + 8) = v20;
        *v20 = v21;
        free(v15);
        v5 = (uint64_t *)v3[1];
      }
      else
      {
        v15[2] = (uint64_t)v14;
        v16 = *(_QWORD *)(v5[1] + 24);
        v17 = *(_QWORD *)(v16 + 16);
        *(_QWORD *)(v14[1] + 24) = v16;
        *(_QWORD *)(*(_QWORD *)(v17 + 8) + 24) = v5;
        v5[2] = v17;
        *(_QWORD *)(v16 + 16) = v14;
      }
      if (v5 >= v3)
        v22 = v3;
      else
        v22 = v5;
      v23 = *v22;
      v24 = *(_QWORD *)v22[1];
      **(_QWORD **)(*v22 + 8) = v24;
      **(_QWORD **)(v24 + 8) = v23;
      free(v22);
    }
    v25 = v3 == v2;
    v3 = v4;
  }
  while (!v25);
  v27 = *a1;
  v26 = (_QWORD *)a1[1];
  *(_QWORD *)(v27 + 8) = v26;
  *v26 = v27;
  free(a1);
}

double __gl_meshNewMesh()
{
  char *v0;
  double result;

  v0 = (char *)malloc_type_malloc(0x100uLL, 0x10A0040185A6F1AuLL);
  if (v0)
  {
    *(_QWORD *)v0 = v0;
    *((_QWORD *)v0 + 1) = v0;
    *((_QWORD *)v0 + 2) = 0;
    *((_QWORD *)v0 + 3) = 0;
    *((_QWORD *)v0 + 10) = v0 + 80;
    *((_QWORD *)v0 + 11) = v0 + 80;
    *((_QWORD *)v0 + 13) = 0;
    *((_QWORD *)v0 + 14) = 0;
    *((_QWORD *)v0 + 12) = 0;
    *((_WORD *)v0 + 60) = 0;
    *((_QWORD *)v0 + 16) = v0 + 128;
    *((_QWORD *)v0 + 17) = v0 + 192;
    result = 0.0;
    *((_OWORD *)v0 + 9) = 0u;
    *((_OWORD *)v0 + 10) = 0u;
    *(_OWORD *)(v0 + 172) = 0u;
    *((_QWORD *)v0 + 24) = v0 + 192;
    *((_QWORD *)v0 + 25) = v0 + 128;
    *(_OWORD *)(v0 + 236) = 0u;
    *((_OWORD *)v0 + 13) = 0u;
    *((_OWORD *)v0 + 14) = 0u;
  }
  return result;
}

void __gl_meshDeleteMesh(void **a1)
{
  char *v2;
  char *v3;
  char *v4;
  void **v5;
  void **v6;
  void **v7;
  void **v8;

  v3 = (char *)(a1 + 10);
  v2 = (char *)a1[10];
  if (v2 != v3)
  {
    do
    {
      v4 = *(char **)v2;
      free(v2);
      v2 = v4;
    }
    while (v4 != v3);
  }
  v5 = (void **)*a1;
  if (*a1 != a1)
  {
    do
    {
      v6 = (void **)*v5;
      free(v5);
      v5 = v6;
    }
    while (v6 != a1);
  }
  v7 = (void **)a1[16];
  if (v7 != a1 + 16)
  {
    do
    {
      v8 = (void **)*v7;
      free(v7);
      v7 = v8;
    }
    while (v8 != a1 + 16);
  }
  free(a1);
}

_QWORD *__gl_meshCheckMesh(_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  BOOL v20;

  v1 = (_QWORD *)result[10];
  v2 = result + 10;
  while (v1 != result + 10)
  {
    v3 = v2;
    v2 = v1;
    if ((_QWORD *)v1[1] != v3)
      __gl_meshCheckMesh_cold_22();
    v4 = (_QWORD *)v1[2];
    do
    {
      v5 = v4[1];
      if ((_QWORD *)v5 == v4)
        __gl_meshCheckMesh_cold_17();
      if (*(_QWORD **)(v5 + 8) != v4)
        __gl_meshCheckMesh_cold_21();
      v6 = v4[3];
      if (*(_QWORD **)(*(_QWORD *)(v6 + 16) + 8) != v4)
        __gl_meshCheckMesh_cold_20();
      if (*(_QWORD **)(*(_QWORD *)(v4[2] + 8) + 24) != v4)
        __gl_meshCheckMesh_cold_19();
      if ((_QWORD *)v4[5] != v1)
        __gl_meshCheckMesh_cold_18();
      v4 = (_QWORD *)v4[3];
    }
    while (v6 != v1[2]);
    v1 = (_QWORD *)*v1;
  }
  if ((_QWORD *)result[11] != v2 || result[12] || result[13])
    __gl_meshCheckMesh_cold_16();
  v7 = (_QWORD *)*result;
  v8 = result;
  if ((_QWORD *)*result != result)
  {
    v8 = result;
    do
    {
      v9 = v8;
      v8 = v7;
      if ((_QWORD *)v7[1] != v9)
        __gl_meshCheckMesh_cold_15();
      v10 = v7[2];
      v11 = *(_QWORD *)(v10 + 8);
      v12 = (_QWORD *)v8[2];
      do
      {
        if ((_QWORD *)v11 == v12)
          __gl_meshCheckMesh_cold_10();
        if (*(_QWORD **)(v11 + 8) != v12)
          __gl_meshCheckMesh_cold_14();
        if (*(_QWORD **)(*(_QWORD *)(v12[3] + 16) + 8) != v12)
          __gl_meshCheckMesh_cold_13();
        v13 = v12[2];
        v11 = *(_QWORD *)(v13 + 8);
        if (*(_QWORD **)(v11 + 24) != v12)
          __gl_meshCheckMesh_cold_12();
        if ((_QWORD *)v12[4] != v8)
          __gl_meshCheckMesh_cold_11();
        v12 = (_QWORD *)v12[2];
      }
      while (v13 != v10);
      v7 = (_QWORD *)*v8;
    }
    while ((_QWORD *)*v8 != result);
  }
  if ((_QWORD *)result[1] != v8 || result[2] || result[3])
    __gl_meshCheckMesh_cold_9();
  v14 = result + 16;
  v15 = result + 16;
  while (1)
  {
    v17 = v15;
    v15 = (_QWORD *)*v15;
    v16 = v17[1];
    if (v15 == v14)
      break;
    v18 = (_QWORD *)v15[1];
    if (*v18 != v16)
      __gl_meshCheckMesh_cold_8();
    if (v18 == v15)
      __gl_meshCheckMesh_cold_2();
    if ((_QWORD *)v18[1] != v15)
      __gl_meshCheckMesh_cold_7();
    if (!v15[4])
      __gl_meshCheckMesh_cold_3();
    if (!v18[4])
      __gl_meshCheckMesh_cold_4();
    if (*(_QWORD **)(*(_QWORD *)(v15[3] + 16) + 8) != v15)
      __gl_meshCheckMesh_cold_6();
    if (*(_QWORD **)(*(_QWORD *)(v15[2] + 8) + 24) != v15)
      __gl_meshCheckMesh_cold_5();
  }
  v19 = (_QWORD *)result[17];
  v20 = *v19 == v16 && v19 == result + 24;
  if (!v20 || (_QWORD *)v19[1] != v14 || result[20] || v19[4] || result[21] || v19[5])
    __gl_meshCheckMesh_cold_1();
  return result;
}

void __gl_meshCheckMesh_cold_1()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 800, "e->Sym->next == ePrev->Sym && e->Sym == &mesh->eHeadSym && e->Sym->Sym == e && e->Org == NULL && e->Dst == NULL && e->Lface == NULL && e->Rface == NULL");
}

void __gl_meshCheckMesh_cold_2()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 789, "e->Sym != e");
}

void __gl_meshCheckMesh_cold_3()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 791, "e->Org != NULL");
}

void __gl_meshCheckMesh_cold_4()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 792, "e->Dst != NULL");
}

void __gl_meshCheckMesh_cold_5()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 794, "e->Onext->Sym->Lnext == e");
}

void __gl_meshCheckMesh_cold_6()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 793, "e->Lnext->Onext->Sym == e");
}

void __gl_meshCheckMesh_cold_7()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 790, "e->Sym->Sym == e");
}

void __gl_meshCheckMesh_cold_8()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 788, "e->Sym->next == ePrev->Sym");
}

void __gl_meshCheckMesh_cold_9()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 782, "v->prev == vPrev && v->anEdge == NULL && v->data == NULL");
}

void __gl_meshCheckMesh_cold_10()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 774, "e->Sym != e");
}

void __gl_meshCheckMesh_cold_11()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 778, "e->Org == v");
}

void __gl_meshCheckMesh_cold_12()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 777, "e->Onext->Sym->Lnext == e");
}

void __gl_meshCheckMesh_cold_13()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 776, "e->Lnext->Onext->Sym == e");
}

void __gl_meshCheckMesh_cold_14()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 775, "e->Sym->Sym == e");
}

void __gl_meshCheckMesh_cold_15()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 771, "v->prev == vPrev");
}

void __gl_meshCheckMesh_cold_16()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 765, "f->prev == fPrev && f->anEdge == NULL && f->data == NULL");
}

void __gl_meshCheckMesh_cold_17()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 757, "e->Sym != e");
}

void __gl_meshCheckMesh_cold_18()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 761, "e->Lface == f");
}

void __gl_meshCheckMesh_cold_19()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 760, "e->Onext->Sym->Lnext == e");
}

void __gl_meshCheckMesh_cold_20()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 759, "e->Lnext->Onext->Sym == e");
}

void __gl_meshCheckMesh_cold_21()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 758, "e->Sym->Sym == e");
}

void __gl_meshCheckMesh_cold_22()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 754, "f->prev == fPrev");
}

void **__gl_pqHeapNewPriorityQ(void *a1)
{
  void **v2;
  void **v3;
  void *v4;
  void *v5;

  v2 = (void **)malloc_type_malloc(0x38uLL, 0x10A0040AA9CE83FuLL);
  v3 = v2;
  if (v2)
  {
    *((_OWORD *)v2 + 1) = xmmword_1B3554690;
    v4 = malloc_type_malloc(0x108uLL, 0x100004000313F17uLL);
    *v3 = v4;
    if (v4)
    {
      v5 = malloc_type_malloc(0x210uLL, 0x1080040FC6463CFuLL);
      v3[1] = v5;
      if (v5)
      {
        *((_DWORD *)v3 + 10) = 0;
        v3[4] = 0;
        v3[6] = a1;
        *((_QWORD *)*v3 + 1) = 1;
        *((_QWORD *)v5 + 2) = 0;
        return v3;
      }
      free(*v3);
    }
    free(v3);
    return 0;
  }
  return v3;
}

void __gl_pqHeapDeletePriorityQ(void **a1)
{
  free(a1[1]);
  free(*a1);
  free(a1);
}

uint64_t *FloatDown(uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  uint64_t v11;
  double v12;
  uint64_t v13;
  double v14;
  uint64_t v15;
  double v16;

  v2 = *result;
  v3 = result[1];
  v4 = *(_QWORD *)(*result + 8 * a2);
  v5 = result[2];
  v6 = result[3];
  v7 = v3 + 16 * v4;
  while (1)
  {
    v8 = 2 * a2;
    if (2 * a2 < v5)
    {
      v9 = *(_QWORD *)(v3 + 16 * *(_QWORD *)(v2 + 8 * (v8 | 1)));
      v10 = *(double *)(v9 + 56);
      v11 = *(_QWORD *)(v3 + 16 * *(_QWORD *)(v2 + 16 * a2));
      v12 = *(double *)(v11 + 56);
      if (v10 < v12 || v10 == v12 && *(double *)(v9 + 64) <= *(double *)(v11 + 64))
        v8 |= 1uLL;
    }
    if (v8 > v6)
      FloatDown_cold_1();
    if (v8 > v5)
      break;
    v13 = *(_QWORD *)(v2 + 8 * v8);
    v14 = *(double *)(*(_QWORD *)v7 + 56);
    v15 = *(_QWORD *)(v3 + 16 * v13);
    v16 = *(double *)(v15 + 56);
    if (v14 < v16 || v14 == v16 && *(double *)(*(_QWORD *)v7 + 64) <= *(double *)(v15 + 64))
      break;
    *(_QWORD *)(v2 + 8 * a2) = v13;
    *(_QWORD *)(v3 + 16 * v13 + 8) = a2;
    a2 = v8;
  }
  *(_QWORD *)(v2 + 8 * a2) = v4;
  *(_QWORD *)(v3 + 16 * v4 + 8) = a2;
  return result;
}

uint64_t __gl_pqHeapInsert(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;

  v4 = *(_QWORD *)(a1 + 24);
  v5 = *(_QWORD *)(a1 + 16) + 1;
  *(_QWORD *)(a1 + 16) = v5;
  if (v4 >= 2 * v5)
    goto LABEL_4;
  v6 = *(void **)a1;
  v7 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 24) = 2 * v4;
  v8 = malloc_type_realloc(v6, (16 * v4) | 8, 0x6EA5B48uLL);
  *(_QWORD *)a1 = v8;
  if (!v8)
  {
    *(_QWORD *)a1 = v6;
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  v9 = malloc_type_realloc(*(void **)(a1 + 8), 16 * *(_QWORD *)(a1 + 24) + 16, 0xCE5AD38BuLL);
  *(_QWORD *)(a1 + 8) = v9;
  if (!v9)
  {
    *(_QWORD *)(a1 + 8) = v7;
    return 0x7FFFFFFFFFFFFFFFLL;
  }
LABEL_4:
  v10 = *(_QWORD *)(a1 + 32);
  v11 = *(_QWORD *)(a1 + 8);
  v12 = v5;
  if (v10)
  {
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(v11 + 16 * v10 + 8);
    v12 = v10;
  }
  *(_QWORD *)(*(_QWORD *)a1 + 8 * v5) = v12;
  v13 = (_QWORD *)(v11 + 16 * v12);
  *v13 = a2;
  v13[1] = v5;
  if (*(_DWORD *)(a1 + 40))
    FloatUp((uint64_t *)a1, v5);
  if (v12 == 0x7FFFFFFFFFFFFFFFLL)
    __gl_pqHeapInsert_cold_1();
  return v12;
}

uint64_t *FloatUp(uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  BOOL v11;

  v2 = *result;
  v3 = result[1];
  v4 = *(_QWORD *)(*result + 8 * a2);
  if ((unint64_t)a2 >= 2)
  {
    v6 = *(_QWORD *)(v3 + 16 * v4);
    v7 = *(double *)(v6 + 56);
    while (1)
    {
      v5 = a2 >> 1;
      v8 = *(_QWORD *)(v2 + 8 * (a2 >> 1));
      v9 = *(_QWORD *)(v3 + 16 * v8);
      v10 = *(double *)(v9 + 56);
      if (v10 < v7 || v10 == v7 && *(double *)(v9 + 64) <= *(double *)(v6 + 64))
        break;
      *(_QWORD *)(v2 + 8 * a2) = v8;
      *(_QWORD *)(v3 + 16 * v8 + 8) = a2;
      v11 = (unint64_t)a2 >= 4;
      a2 >>= 1;
      if (!v11)
        goto LABEL_3;
    }
  }
  v5 = a2;
LABEL_3:
  *(_QWORD *)(v2 + 8 * v5) = v4;
  *(_QWORD *)(v3 + 16 * v4 + 8) = v5;
  return result;
}

uint64_t __gl_pqHeapExtractMin(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v1 = *a1;
  v2 = a1[1];
  v3 = *(_QWORD *)(*a1 + 8);
  v4 = (uint64_t *)(v2 + 16 * v3);
  v5 = *v4;
  v6 = a1[2];
  if (v6 >= 1)
  {
    v7 = *(_QWORD *)(v1 + 8 * v6);
    *(_QWORD *)(v1 + 8) = v7;
    *(_QWORD *)(v2 + 16 * v7 + 8) = 1;
    v8 = a1[4];
    *v4 = 0;
    v4[1] = v8;
    a1[4] = v3;
    a1[2] = v6 - 1;
    if (v6 != 1)
      FloatDown(a1, 1);
  }
  return v5;
}

uint64_t *__gl_pqHeapDelete(uint64_t *result, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  double v13;

  if (a2 < 1 || (v3 = result, result[3] < a2) || (v4 = result[1], v5 = (_QWORD *)(v4 + 16 * a2), !*v5))
    __gl_pqHeapDelete_cold_1();
  v6 = v5[1];
  v7 = *result;
  v8 = result[2];
  v9 = *(_QWORD *)(*result + 8 * v8);
  *(_QWORD *)(*result + 8 * v6) = v9;
  *(_QWORD *)(v4 + 16 * v9 + 8) = v6;
  result[2] = v8 - 1;
  if (v6 < v8)
  {
    if (v6 < 2
      || (v10 = *(_QWORD *)(v4 + 16 * *(_QWORD *)(v7 + ((4 * v6) & 0xFFFFFFFFFFFFFFF8))),
          v11 = *(double *)(v10 + 56),
          v12 = *(_QWORD *)(v4 + 16 * v9),
          v13 = *(double *)(v12 + 56),
          v11 < v13)
      || v11 == v13 && *(double *)(v10 + 64) <= *(double *)(v12 + 64))
    {
      result = FloatDown(result, v6);
    }
    else
    {
      result = FloatUp(result, v6);
    }
  }
  *v5 = 0;
  v5[1] = v3[4];
  v3[4] = a2;
  return result;
}

char *__gl_pqSortNewPriorityQ(void *a1)
{
  char *v2;
  void **v3;
  void *v4;

  v2 = (char *)malloc_type_malloc(0x38uLL, 0x10A004025C1D612uLL);
  if (v2)
  {
    v3 = __gl_pqHeapNewPriorityQ(a1);
    *(_QWORD *)v2 = v3;
    if (v3)
    {
      v4 = malloc_type_malloc(0x100uLL, 0x80040B8603338uLL);
      *((_QWORD *)v2 + 1) = v4;
      if (v4)
      {
        *(_OWORD *)(v2 + 24) = xmmword_1B3554690;
        *((_DWORD *)v2 + 10) = 0;
        *((_QWORD *)v2 + 6) = a1;
        return v2;
      }
      __gl_pqHeapDeletePriorityQ(*(void ***)v2);
    }
    free(v2);
    return 0;
  }
  return v2;
}

void __gl_pqSortDeletePriorityQ(void ***a1)
{
  void **v2;
  void **v3;
  void **v4;

  if (!a1)
    __gl_pqSortDeletePriorityQ_cold_1();
  v2 = *a1;
  if (v2)
    __gl_pqHeapDeletePriorityQ(v2);
  v3 = a1[2];
  if (v3)
    free(v3);
  v4 = a1[1];
  if (v4)
    free(v4);
  free(a1);
}

uint64_t __gl_pqSortInit(uint64_t *a1)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  _QWORD **v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  char *v14;
  _QWORD *v15;
  uint64_t v16;
  double v17;
  char *v18;
  uint64_t *v19;
  uint64_t v20;
  double v21;
  char *v22;
  uint64_t *v23;
  _QWORD *v24;
  uint64_t v25;
  double v26;
  _QWORD *v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  _QWORD *i;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  double v35;
  uint64_t *v36;
  uint64_t *v37;
  uint64_t v38;
  double v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  double v47;
  double v48;
  uint64_t *v49;
  uint64_t v50;
  _QWORD v52[2];
  _QWORD v53[99];

  v53[98] = *MEMORY[0x1E0C80C00];
  v2 = malloc_type_malloc(8 * a1[3] + 8, 0x54C8DA60uLL);
  a1[2] = (uint64_t)v2;
  if (!v2)
    return 0;
  v3 = a1[3];
  v4 = (unint64_t)&v2[v3 - 1];
  if ((unint64_t)v2 <= v4)
  {
    v5 = a1[1];
    v6 = v2;
    do
    {
      *v6++ = v5;
      v5 += 8;
    }
    while ((unint64_t)v6 <= v4);
  }
  v7 = v53;
  v52[0] = v2;
  v52[1] = &v2[v3 - 1];
  v8 = 2016473283;
  v9 = (_QWORD **)v52;
  do
  {
    v10 = *v9;
    v11 = *(v7 - 1);
    v7 = v9;
    if (v11 > (unint64_t)(*v9 + 10))
    {
      do
      {
        v8 = 1539415821 * v8 + 1;
        v12 = v8 % (((uint64_t)(v11 - (_QWORD)v10) >> 3) + 1);
        v13 = (uint64_t *)v10[v12];
        v10[v12] = *v10;
        *v10 = v13;
        v14 = (char *)(v10 - 1);
        v15 = (_QWORD *)(v11 + 8);
        do
        {
          v16 = *v13;
          v17 = *(double *)(*v13 + 56);
          v18 = v14 + 8;
          v19 = (uint64_t *)*((_QWORD *)v14 + 1);
          v20 = *v19;
          v21 = *(double *)(*v19 + 56);
          if (v21 >= v17)
          {
            v14 += 8;
            while (1)
            {
              v18 = v14;
              if (v21 == v17 && *(double *)(v20 + 64) <= *(double *)(v16 + 64))
                break;
              v14 += 8;
              v19 = (uint64_t *)*((_QWORD *)v18 + 1);
              v20 = *v19;
              v21 = *(double *)(*v19 + 56);
              v22 = v18;
              if (v21 < v17)
                goto LABEL_17;
            }
            v22 = v14 - 8;
          }
          else
          {
            v22 = v14;
          }
          v14 = v18;
LABEL_17:
          v24 = v15 - 1;
          v23 = (uint64_t *)*(v15 - 1);
          v25 = *v23;
          v26 = *(double *)(*v23 + 56);
          if (v17 >= v26)
          {
            --v15;
            while (1)
            {
              v24 = v15;
              if (v17 == v26 && *(double *)(v16 + 64) <= *(double *)(v25 + 64))
                break;
              --v15;
              v23 = (uint64_t *)*(v24 - 1);
              v25 = *v23;
              v26 = *(double *)(*v23 + 56);
              v27 = v24;
              if (v17 < v26)
                goto LABEL_26;
            }
            v27 = v15 + 1;
          }
          else
          {
            v27 = v15;
          }
          v15 = v24;
LABEL_26:
          *(_QWORD *)v14 = v23;
          *v15 = v19;
        }
        while (v14 < (char *)v15);
        v28 = *(_QWORD *)v14;
        *(_QWORD *)v14 = v19;
        *v15 = v28;
        if (v14 - (char *)v10 >= (uint64_t)(v11 - (_QWORD)v15))
          v29 = v10;
        else
          v29 = v27;
        if (v14 - (char *)v10 >= (uint64_t)(v11 - (_QWORD)v15))
          v30 = (unint64_t)v22;
        else
          v30 = v11;
        if (v14 - (char *)v10 >= (uint64_t)(v11 - (_QWORD)v15))
          v10 = v27;
        else
          v11 = (unint64_t)v22;
        *v7 = v29;
        v7[1] = v30;
        v7 += 2;
      }
      while (v11 > (unint64_t)(v10 + 10));
    }
    for (i = v10 + 1; (unint64_t)i <= v11; ++i)
    {
      v32 = *i;
      v33 = i;
      if (i > v10)
      {
        v34 = i;
        v33 = i;
        while (1)
        {
          v35 = *(double *)(*(_QWORD *)v32 + 56);
          v37 = (uint64_t *)*--v33;
          v36 = v37;
          v38 = *v37;
          v39 = *(double *)(*v37 + 56);
          if (v35 < v39 || v35 == v39 && *(double *)(*(_QWORD *)v32 + 64) <= *(double *)(v38 + 64))
            break;
          *v34 = v36;
          v34 = v33;
          if (v33 <= v10)
            goto LABEL_47;
        }
        v33 = v34;
      }
LABEL_47:
      *v33 = v32;
    }
    v9 = (_QWORD **)(v7 - 2);
  }
  while (v7 - 2 >= v52);
  a1[4] = v3;
  v40 = 1;
  *((_DWORD *)a1 + 10) = 1;
  v41 = *a1;
  v42 = *(_QWORD *)(*a1 + 16);
  if (v42 >= 1)
  {
    do
      FloatDown((uint64_t *)v41, v42);
    while ((unint64_t)v42-- > 1);
  }
  *(_DWORD *)(v41 + 40) = 1;
  v44 = a1[2];
  v45 = v44 + 8 * a1[3] - 8;
  if (v44 < v45)
  {
    v46 = **(_QWORD **)v44;
    v47 = *(double *)(v46 + 56);
    do
    {
      v48 = v47;
      v49 = *(uint64_t **)(v44 + 8);
      v44 += 8;
      v50 = *v49;
      v47 = *(double *)(*v49 + 56);
      if (v47 >= v48 && (v47 != v48 || *(double *)(v50 + 64) > *(double *)(v46 + 64)))
        __gl_pqSortInit_cold_1();
      v46 = v50;
    }
    while (v44 < v45);
    return 1;
  }
  return v40;
}

uint64_t __gl_pqSortInsert(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t v6;
  void *v7;
  _QWORD *v8;

  if (*(_DWORD *)(a1 + 40))
    return __gl_pqHeapInsert(*(_QWORD *)a1, a2);
  v6 = *(_QWORD *)(a1 + 24);
  v5 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 24) = v6 + 1;
  v7 = *(void **)(a1 + 8);
  if (v6 + 1 < v5)
  {
    v8 = *(_QWORD **)(a1 + 8);
LABEL_6:
    v8[v6] = a2;
    return ~v6;
  }
  *(_QWORD *)(a1 + 32) = 2 * v5;
  v8 = malloc_type_realloc(v7, 16 * v5, 0xA18345C8uLL);
  *(_QWORD *)(a1 + 8) = v8;
  if (v8)
    goto LABEL_6;
  *(_QWORD *)(a1 + 8) = v7;
  return 0x7FFFFFFFFFFFFFFFLL;
}

uint64_t __gl_pqSortExtractMin(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  double v5;
  double v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v1 = *(_QWORD *)(a1 + 24);
  if (!v1)
    return __gl_pqHeapExtractMin(*(uint64_t **)a1);
  v2 = *(_QWORD *)(a1 + 16);
  v3 = **(_QWORD **)(v2 + 8 * v1 - 8);
  if (*(_QWORD *)(*(_QWORD *)a1 + 16))
  {
    v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8) + 16 * *(_QWORD *)(**(_QWORD **)a1 + 8));
    v5 = *(double *)(v4 + 56);
    v6 = *(double *)(v3 + 56);
    if (v5 < v6 || v5 == v6 && *(double *)(v4 + 64) <= *(double *)(v3 + 64))
      return __gl_pqHeapExtractMin(*(uint64_t **)a1);
  }
  if (v1 >= 1)
    v7 = 1;
  else
    v7 = *(_QWORD *)(a1 + 24);
  v8 = v7 - 1;
  v9 = v2 - 16;
  while (v1 >= 2)
  {
    v10 = v1 - 1;
    if (**(_QWORD **)(v9 + 8 * v1--))
      goto LABEL_16;
  }
  v10 = v8;
LABEL_16:
  *(_QWORD *)(a1 + 24) = v10;
  return v3;
}

uint64_t __gl_pqSortMinimum(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  double v4;
  double v5;

  v1 = a1[3];
  if (!v1)
    return *(_QWORD *)(*(_QWORD *)(*a1 + 8) + 16 * *(_QWORD *)(*(_QWORD *)*a1 + 8));
  v2 = **(_QWORD **)(a1[2] + 8 * v1 - 8);
  if (!*(_QWORD *)(*a1 + 16))
    return v2;
  result = *(_QWORD *)(*(_QWORD *)(*a1 + 8) + 16 * *(_QWORD *)(*(_QWORD *)*a1 + 8));
  v4 = *(double *)(result + 56);
  v5 = *(double *)(v2 + 56);
  if (v4 >= v5 && (v4 != v5 || *(double *)(result + 64) > *(double *)(v2 + 64)))
    return v2;
  return result;
}

uint64_t *__gl_pqSortDelete(uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;

  if ((a2 & 0x8000000000000000) == 0)
    return __gl_pqHeapDelete((uint64_t *)*result, a2);
  v2 = ~a2;
  if (result[4] <= ~a2 || (v3 = result[1], !*(_QWORD *)(v3 + 8 * v2)))
    __gl_pqSortDelete_cold_1();
  *(_QWORD *)(v3 + 8 * v2) = 0;
  v4 = result[3];
  v6 = __OFSUB__(v4, 1);
  v5 = v4 - 1 < 0;
  v7 = v4 - 1;
  if (v5 == v6)
  {
    v8 = result[2];
    do
    {
      if (**(_QWORD **)(v8 + 8 * v7))
        break;
      result[3] = v7;
      v9 = v7-- + 1;
    }
    while (v9 > 1);
  }
  return result;
}

void FloatDown_cold_1()
{
  __assert_rtn("FloatDown", "priorityq-heap.c", 110, "child <= pq->max");
}

void __gl_pqHeapInsert_cold_1()
{
  __assert_rtn("__gl_pqHeapInsert", "priorityq-heap.c", 205, "free != LONG_MAX");
}

void __gl_pqHeapDelete_cold_1()
{
  __assert_rtn("__gl_pqHeapDelete", "priorityq-heap.c", 239, "hCurr >= 1 && hCurr <= pq->max && h[hCurr].key != NULL");
}

void __gl_pqSortDeletePriorityQ_cold_1()
{
  __assert_rtn("__gl_pqSortDeletePriorityQ", "priorityq.c", 80, "pq != NULL");
}

void __gl_pqSortInit_cold_1()
{
  __assert_rtn("__gl_pqSortInit", "priorityq.c", 166, "LEQ( **(i+1), **i)");
}

void __gl_pqSortDelete_cold_1()
{
  __assert_rtn("__gl_pqSortDelete", "priorityq.c", 257, "curr < pq->max && pq->keys[curr] != NULL");
}

double __gl_projectPolygon(uint64_t a1)
{
  double *v1;
  double v2;
  double v3;
  double v4;
  _BOOL4 v5;
  _BOOL4 v6;
  double *v7;
  double *v8;
  uint64_t i;
  double v10;
  double v11;
  double v12;
  double v13;
  uint64_t v14;
  double *v15;
  double *v16;
  BOOL v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double *v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  uint64_t v34;
  double v35;
  double v36;
  double *v37;
  uint64_t v38;
  unsigned int v39;
  double v40;
  signed int v41;
  unsigned int v42;
  uint64_t v43;
  BOOL v44;
  double v45;
  double result;
  double *v47;
  double v48;
  double v49;
  double v50;
  double *v51;
  uint64_t v52;
  _QWORD *v53;
  double v54;
  double v55;
  double v56;
  _QWORD v57[3];
  _QWORD v58[3];
  double v59[3];
  int64x2_t v60;
  double v61;
  int64x2_t v62;
  double v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v1 = *(double **)(a1 + 16);
  v2 = *(double *)(a1 + 32);
  v3 = *(double *)(a1 + 40);
  v54 = v2;
  v55 = v3;
  v4 = *(double *)(a1 + 48);
  v56 = v4;
  v5 = v2 == 0.0;
  if (v3 != 0.0)
    v5 = 0;
  v6 = v4 == 0.0 && v5;
  v7 = *(double **)v1;
  if (v6)
  {
    memset(v58, 0, sizeof(v58));
    memset(v57, 0, sizeof(v57));
    v63 = -2.0e150;
    v62 = vdupq_n_s64(0xDF238D352E5096AFLL);
    v61 = 2.0e150;
    v60 = vdupq_n_s64(0x5F238D352E5096AFuLL);
    if (v7 == v1)
    {
      v11 = -4.0e150;
      v12 = -4.0e150;
      v13 = -4.0e150;
    }
    else
    {
      v8 = v7;
      do
      {
        for (i = 0; i != 3; ++i)
        {
          v10 = v8[i + 4];
          if (v10 < *(double *)&v60.i64[i])
          {
            *(double *)&v60.i64[i] = v10;
            v57[i] = v8;
          }
          if (v10 > *(double *)&v62.i64[i])
          {
            *(double *)&v62.i64[i] = v10;
            v58[i] = v8;
          }
        }
        v8 = *(double **)v8;
      }
      while (v8 != v1);
      v11 = *(double *)&v62.i64[1] - *(double *)&v60.i64[1];
      v12 = *(double *)v62.i64 - *(double *)v60.i64;
      v13 = v63 - v61;
    }
    v14 = 2;
    if (v13 <= *(double *)((unint64_t)&v62 | (8 * (v11 > v12)))
              - *(double *)((unint64_t)&v60 & 0xFFFFFFFFFFFFFFF7 | (8 * (v11 > v12))))
      v14 = v11 > v12;
    if (*(double *)&v60.i64[v14] >= *(double *)&v62.i64[v14])
    {
      v37 = &v56;
      v54 = 0.0;
      v55 = 0.0;
LABEL_43:
      *v37 = 1.0;
      v2 = v54;
      v3 = v55;
      v4 = v56;
      goto LABEL_44;
    }
    v15 = (double *)v57[v14];
    v16 = (double *)v58[v14];
    if (v15)
      v17 = v16 == 0;
    else
      v17 = 1;
    if (!v17)
    {
      v18 = v16[4];
      v19 = v16[5];
      v20 = v15[4] - v18;
      v21 = v15[5] - v19;
      v59[0] = v20;
      v59[1] = v21;
      v22 = v16[6];
      v23 = v15[6] - v22;
      if (v7 == v1)
        goto LABEL_31;
      v24 = 0.0;
      v25 = v7;
      do
      {
        v26 = v25[4] - v18;
        v27 = v25[5] - v19;
        v28 = v25[6] - v22;
        v29 = v21 * v28 - v23 * v27;
        v30 = v23 * v26 - v20 * v28;
        v31 = v20 * v27 - v21 * v26;
        if (v31 * v31 + v29 * v29 + v30 * v30 > v24)
        {
          v4 = v31;
          v3 = v30;
          v2 = v29;
          v24 = v31 * v31 + v29 * v29 + v30 * v30;
        }
        v25 = *(double **)v25;
      }
      while (v25 != v1);
      v54 = v2;
      v55 = v3;
      v56 = v4;
      if (v24 <= 0.0)
      {
LABEL_31:
        v32 = -v21;
        if (v21 >= 0.0)
          v32 = v21;
        v33 = -v20;
        if (v20 >= 0.0)
          v33 = v20;
        v34 = v32 > v33;
        v35 = -v23;
        if (v23 >= 0.0)
          v35 = v23;
        v54 = 0.0;
        v55 = 0.0;
        v56 = 0.0;
        v36 = v59[v34];
        if (v36 < 0.0)
          v36 = -v36;
        if (v35 > v36)
          v34 = 2;
        v37 = &v54 + v34;
        goto LABEL_43;
      }
    }
  }
LABEL_44:
  v38 = a1 + 56;
  if (v3 < 0.0)
    v3 = -v3;
  if (v2 < 0.0)
    v2 = -v2;
  v39 = v3 > v2;
  if (v4 < 0.0)
    v4 = -v4;
  v40 = *(&v54 + (v3 > v2));
  if (v40 < 0.0)
    v40 = -v40;
  if (v4 > v40)
    v39 = 2;
  *(_QWORD *)(v38 + 8 * v39) = 0;
  if (v39 == 2)
    v41 = 0;
  else
    v41 = v39 + 1;
  *(_QWORD *)(v38 + 8 * v41) = 0x3FF0000000000000;
  v42 = (v39 + 2) % 3;
  *(_QWORD *)(v38 + 8 * v42) = 0;
  v43 = a1 + 80;
  *(_QWORD *)(a1 + 80 + 8 * v39) = 0;
  v44 = *(&v54 + v39) <= 0.0;
  v45 = -0.0;
  if (*(&v54 + v39) <= 0.0)
    v45 = 0.0;
  *(double *)(v43 + 8 * v41) = v45;
  result = -1.0;
  if (!v44)
    result = 1.0;
  *(double *)(v43 + 8 * v42) = result;
  if (v7 != v1)
  {
    v47 = v7;
    do
    {
      v48 = v47[4];
      v49 = v47[5];
      v50 = v47[6];
      v47[7] = v48 * *(double *)(a1 + 56) + v49 * *(double *)(a1 + 64) + v50 * *(double *)(a1 + 72);
      result = v48 * *(double *)(a1 + 80) + v49 * *(double *)(a1 + 88) + v50 * *(double *)(a1 + 96);
      v47[8] = result;
      v47 = *(double **)v47;
    }
    while (v47 != v1);
  }
  if (v6)
  {
    v51 = (double *)*((_QWORD *)v1 + 10);
    if (v51 != v1 + 10)
    {
      result = 0.0;
      do
      {
        v52 = *((_QWORD *)v51 + 2);
        if (*(int *)(v52 + 56) >= 1)
        {
          v53 = (_QWORD *)*((_QWORD *)v51 + 2);
          do
          {
            result = result
                   + (*(double *)(v53[4] + 56) - *(double *)(*(_QWORD *)(v53[1] + 32) + 56))
                   * (*(double *)(v53[4] + 64) + *(double *)(*(_QWORD *)(v53[1] + 32) + 64));
            v53 = (_QWORD *)v53[3];
          }
          while (v53 != (_QWORD *)v52);
        }
        v51 = *(double **)v51;
      }
      while (v51 != v1 + 10);
      if (result < 0.0)
      {
        while (v7 != v1)
        {
          v7[8] = -v7[8];
          v7 = *(double **)v7;
        }
        *(float64x2_t *)(a1 + 80) = vnegq_f64(*(float64x2_t *)(a1 + 80));
        result = -*(double *)(a1 + 96);
        *(double *)(a1 + 96) = result;
      }
    }
  }
  return result;
}

GLUtesselator *gluNewTess(void)
{
  GLUtesselator *result;

  if (!TXParagraphStyleFolder_Factory::version((TXParagraphStyleFolder_Factory *)0x80))
    return 0;
  result = (GLUtesselator *)malloc_type_malloc(0xE50uLL, 0x10A004023E6F836uLL);
  if (result)
  {
    *(_DWORD *)result = 0;
    *((_QWORD *)result + 13) = 0;
    *((_QWORD *)result + 5) = 0;
    *((_QWORD *)result + 6) = 0;
    *((_DWORD *)result + 28) = 100130;
    *((_QWORD *)result + 21) = noBegin;
    *((_QWORD *)result + 22) = noEdgeFlag;
    *((_QWORD *)result + 23) = noVertex;
    *((_QWORD *)result + 24) = noEnd;
    *((_QWORD *)result + 3) = noError;
    *((_QWORD *)result + 4) = 0;
    *((_QWORD *)result + 18) = noCombine;
    *((_QWORD *)result + 25) = noMesh;
    *((_QWORD *)result + 427) = __gl_noBeginData;
    *((_QWORD *)result + 428) = __gl_noEdgeFlagData;
    *((_QWORD *)result + 429) = __gl_noVertexData;
    *((_QWORD *)result + 430) = __gl_noEndData;
    *((_WORD *)result + 76) = 0;
    *((_QWORD *)result + 431) = __gl_noErrorData;
    *((_QWORD *)result + 432) = __gl_noCombineData;
    *((_QWORD *)result + 457) = 0;
  }
  return result;
}

void gluDeleteTess(GLUtesselator *tess)
{
  if (*(_DWORD *)tess)
    GotoState((uint64_t)tess, 0);
  free(tess);
}

void GotoState(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  _QWORD *v5;
  uint64_t (*v6)();
  uint64_t (*v7)();
  uint64_t (*v8)();
  uint64_t (*v9)();
  void **v10;

  v2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 != a2)
  {
    v5 = (_QWORD *)(a1 + 8);
    do
    {
      if (v2 >= a2)
      {
        if (v2 == 1)
        {
          v9 = *(uint64_t (**)())(a1 + 3448);
          if (v9 == __gl_noErrorData)
            (*(void (**)(uint64_t))(a1 + 24))(100153);
          else
            ((void (*)(uint64_t, _QWORD))v9)(100153, *(_QWORD *)(a1 + 3656));
          v10 = *(void ***)(a1 + 16);
          if (v10)
            __gl_meshDeleteMesh(v10);
          v2 = 0;
          *(_DWORD *)a1 = 0;
          *v5 = 0;
          v5[1] = 0;
        }
        else if (v2 == 2)
        {
          v7 = *(uint64_t (**)())(a1 + 3448);
          if (v7 == __gl_noErrorData)
            (*(void (**)(uint64_t))(a1 + 24))(100154);
          else
            ((void (*)(uint64_t, _QWORD))v7)(100154, *(_QWORD *)(a1 + 3656));
          if (*(_DWORD *)a1 != 2)
            GotoState(a1, 2);
          v2 = 1;
          *(_DWORD *)a1 = 1;
        }
      }
      else if (v2 == 1)
      {
        v8 = *(uint64_t (**)())(a1 + 3448);
        if (v8 == __gl_noErrorData)
          (*(void (**)(uint64_t))(a1 + 24))(100152);
        else
          ((void (*)(uint64_t, _QWORD))v8)(100152, *(_QWORD *)(a1 + 3656));
        gluTessBeginContour((GLUtesselator *)a1);
        v2 = *(_DWORD *)a1;
      }
      else if (!v2)
      {
        v6 = *(uint64_t (**)())(a1 + 3448);
        if (v6 == __gl_noErrorData)
          (*(void (**)(uint64_t))(a1 + 24))(100151);
        else
          ((void (*)(uint64_t, _QWORD))v6)(100151, *(_QWORD *)(a1 + 3656));
        if (*(_DWORD *)a1)
          GotoState(a1, 0);
        v2 = 1;
        *(_DWORD *)a1 = 1;
        *(_DWORD *)(a1 + 212) = 0;
        *(_BYTE *)(a1 + 208) = 0;
        *(_QWORD *)(a1 + 16) = 0;
        *(_QWORD *)(a1 + 3656) = 0;
      }
    }
    while (v2 != a2);
  }
}

void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble data)
{
  unsigned int v3;
  uint64_t (*v4)();
  uint64_t (*v5)();

  switch(which)
  {
    case 0x1872Cu:
      v3 = data;
      if ((double)data != data)
      {
LABEL_8:
        v4 = (uint64_t (*)())*((_QWORD *)tess + 431);
        if (v4 == __gl_noErrorData)
          (*((void (**)(uint64_t))tess + 3))(100901);
        else
          ((void (*)(uint64_t, _QWORD))v4)(100901, *((_QWORD *)tess + 457));
        return;
      }
      if (v3 - 100130 <= 4)
      {
        *((_DWORD *)tess + 28) = v3;
        return;
      }
LABEL_15:
      *((_BYTE *)tess + 153) = data != 0.0;
      return;
    case 0x1872Du:
      goto LABEL_15;
    case 0x1872Eu:
      if (data >= 0.0 && data <= 1.0)
      {
        *((GLdouble *)tess + 13) = data;
        return;
      }
      goto LABEL_8;
  }
  v5 = (uint64_t (*)())*((_QWORD *)tess + 431);
  if (v5 == __gl_noErrorData)
    (*((void (**)(uint64_t, GLdouble))tess + 3))(100900, data);
  else
    ((void (*)(uint64_t, _QWORD, double))v5)(100900, *((_QWORD *)tess + 457), data);
}

void gluTessCallback(GLUtesselator *tess, GLenum which, GLvoid (*CallBackFunc)(void))
{
  GLvoid (*v3)(void);
  uint64_t (*v4)();
  GLvoid (*v5)(void);
  GLvoid (*v6)(void);
  GLvoid (*v7)(void);
  GLvoid (*v8)(void);
  BOOL v9;
  GLvoid (*v10)(void);
  GLvoid (*v11)(void);
  GLvoid (*v12)(void);
  GLvoid (*v13)(void);
  GLvoid (*v14)(void);
  GLvoid (*v15)(void);
  char v16;
  GLvoid (*v17)(void);
  GLvoid (*v18)(void);

  switch(which)
  {
    case 0x18704u:
      v3 = (GLvoid (*)(void))noBegin;
      if (CallBackFunc)
        v3 = CallBackFunc;
      *((_QWORD *)tess + 21) = v3;
      break;
    case 0x18705u:
      v5 = (GLvoid (*)(void))noVertex;
      if (CallBackFunc)
        v5 = CallBackFunc;
      *((_QWORD *)tess + 23) = v5;
      break;
    case 0x18706u:
      v6 = (GLvoid (*)(void))noEnd;
      if (CallBackFunc)
        v6 = CallBackFunc;
      *((_QWORD *)tess + 24) = v6;
      break;
    case 0x18707u:
      v7 = (GLvoid (*)(void))noError;
      if (CallBackFunc)
        v7 = CallBackFunc;
      *((_QWORD *)tess + 3) = v7;
      break;
    case 0x18708u:
      v8 = (GLvoid (*)(void))noEdgeFlag;
      v9 = CallBackFunc == 0;
      if (CallBackFunc)
        v8 = CallBackFunc;
      *((_QWORD *)tess + 22) = v8;
      goto LABEL_37;
    case 0x18709u:
      v10 = (GLvoid (*)(void))noCombine;
      if (CallBackFunc)
        v10 = CallBackFunc;
      *((_QWORD *)tess + 18) = v10;
      break;
    case 0x1870Au:
      v11 = (GLvoid (*)(void))__gl_noBeginData;
      if (CallBackFunc)
        v11 = CallBackFunc;
      *((_QWORD *)tess + 427) = v11;
      break;
    case 0x1870Bu:
      v12 = (GLvoid (*)(void))__gl_noVertexData;
      if (CallBackFunc)
        v12 = CallBackFunc;
      *((_QWORD *)tess + 429) = v12;
      break;
    case 0x1870Cu:
      v13 = (GLvoid (*)(void))__gl_noEndData;
      if (CallBackFunc)
        v13 = CallBackFunc;
      *((_QWORD *)tess + 430) = v13;
      break;
    case 0x1870Du:
      v14 = (GLvoid (*)(void))__gl_noErrorData;
      if (CallBackFunc)
        v14 = CallBackFunc;
      *((_QWORD *)tess + 431) = v14;
      break;
    case 0x1870Eu:
      v15 = (GLvoid (*)(void))__gl_noEdgeFlagData;
      v9 = CallBackFunc == 0;
      if (CallBackFunc)
        v15 = CallBackFunc;
      *((_QWORD *)tess + 428) = v15;
LABEL_37:
      v16 = !v9;
      *((_BYTE *)tess + 152) = v16;
      break;
    case 0x1870Fu:
      v17 = (GLvoid (*)(void))__gl_noCombineData;
      if (CallBackFunc)
        v17 = CallBackFunc;
      *((_QWORD *)tess + 432) = v17;
      break;
    case 0x18710u:
      v18 = (GLvoid (*)(void))noMesh;
      if (CallBackFunc)
        v18 = CallBackFunc;
      *((_QWORD *)tess + 25) = v18;
      break;
    default:
      v4 = (uint64_t (*)())*((_QWORD *)tess + 431);
      if (v4 == __gl_noErrorData)
        (*((void (**)(uint64_t))tess + 3))(100900);
      else
        ((void (*)(uint64_t, _QWORD))v4)(100900, *((_QWORD *)tess + 457));
      break;
  }
}

void gluTessVertex(GLUtesselator *tess, GLdouble *location, GLvoid *data)
{
  __n128 v3;
  __n128 v4;
  int v8;
  uint64_t v9;
  int v10;
  double v11;
  double v12;
  BOOL v13;
  uint64_t (*v14)();
  uint64_t v15;
  char *v16;
  int v17;
  uint64_t (*v18)();
  __int128 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)tess != 2)
    GotoState((uint64_t)tess, 2u);
  if (*((_BYTE *)tess + 208))
  {
    EmptyCache((uint64_t)tess);
    if (!v8)
      goto LABEL_28;
    *((_QWORD *)tess + 1) = 0;
  }
  v9 = 0;
  v10 = 0;
  v3.n128_u64[0] = 0xDF138D352E5096AFLL;
  v4.n128_u64[0] = 0x5F138D352E5096AFLL;
  do
  {
    v11 = location[v9];
    if (v11 >= -1.0e150)
      v12 = location[v9];
    else
      v12 = -1.0e150;
    if (v12 <= 1.0e150)
    {
      v13 = v11 < -1.0e150;
    }
    else
    {
      v12 = 1.0e150;
      v13 = 1;
    }
    if (v13)
      v10 = 1;
    *(double *)((char *)&v19 + v9 * 8) = v12;
    ++v9;
  }
  while (v9 != 3);
  if (v10)
  {
    v14 = (uint64_t (*)())*((_QWORD *)tess + 431);
    if (v14 == __gl_noErrorData)
      (*((void (**)(uint64_t, __n128, __n128))tess + 3))(100155, v3, v4);
    else
      ((void (*)(uint64_t, _QWORD, __n128, __n128))v14)(100155, *((_QWORD *)tess + 457), v3, v4);
  }
  if (*((_QWORD *)tess + 2))
    goto LABEL_33;
  v15 = *((int *)tess + 53);
  if ((int)v15 <= 99)
  {
    v16 = (char *)tess + 32 * v15;
    *((_QWORD *)v16 + 30) = data;
    *(_OWORD *)(v16 + 216) = v19;
    *((_QWORD *)v16 + 29) = v20;
    *((_DWORD *)tess + 53) = v15 + 1;
    return;
  }
  EmptyCache((uint64_t)tess);
  if (v17)
  {
LABEL_33:
    if (AddVertex((uint64_t)tess, &v19, (uint64_t)data))
      return;
  }
LABEL_28:
  v18 = (uint64_t (*)())*((_QWORD *)tess + 431);
  if (v18 == __gl_noErrorData)
    (*((void (**)(uint64_t))tess + 3))(100902);
  else
    ((void (*)(uint64_t, _QWORD))v18)(100902, *((_QWORD *)tess + 457));
}

void EmptyCache(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  unint64_t v5;

  __gl_meshNewMesh();
  *(_QWORD *)(a1 + 16) = v2;
  if (v2)
  {
    v3 = *(int *)(a1 + 212);
    if ((int)v3 < 1)
    {
LABEL_6:
      *(_DWORD *)(a1 + 212) = 0;
      *(_BYTE *)(a1 + 208) = 0;
    }
    else
    {
      v4 = (_QWORD *)(a1 + 216);
      v5 = a1 + 216 + 32 * v3;
      while (AddVertex(a1, v4, v4[3]))
      {
        v4 += 4;
        if ((unint64_t)v4 >= v5)
          goto LABEL_6;
      }
    }
  }
}

uint64_t AddVertex(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  _QWORD *v9;

  v6 = *(_QWORD *)(a1 + 8);
  if (v6)
  {
    result = (uint64_t)__gl_meshSplitEdge(*(_QWORD *)(a1 + 8));
    if (!result)
      return result;
    v8 = *(_QWORD *)(v6 + 24);
    goto LABEL_6;
  }
  result = (uint64_t)__gl_meshMakeEdge(*(_QWORD *)(a1 + 16));
  if (result)
  {
    v8 = result;
    result = __gl_meshSplice((_QWORD *)result, *(_QWORD **)(result + 8));
    if ((_DWORD)result)
    {
LABEL_6:
      v9 = *(_QWORD **)(v8 + 32);
      v9[3] = a3;
      v9[4] = *a2;
      v9[5] = a2[1];
      v9[6] = a2[2];
      result = 1;
      *(_DWORD *)(v8 + 56) = 1;
      *(_DWORD *)(*(_QWORD *)(v8 + 8) + 56) = -1;
      *(_QWORD *)(a1 + 8) = v8;
    }
  }
  return result;
}

void gluTessBeginPolygon(GLUtesselator *tess, GLvoid *data)
{
  if (*(_DWORD *)tess)
    GotoState((uint64_t)tess, 0);
  *(_DWORD *)tess = 1;
  *((_DWORD *)tess + 53) = 0;
  *((_BYTE *)tess + 208) = 0;
  *((_QWORD *)tess + 2) = 0;
  *((_QWORD *)tess + 457) = data;
}

void gluTessBeginContour(GLUtesselator *tess)
{
  if (*(_DWORD *)tess != 1)
    GotoState(tess, 1);
  *(_DWORD *)tess = 2;
  *((_QWORD *)tess + 1) = 0;
  if (*((int *)tess + 53) >= 1)
    *((_BYTE *)tess + 208) = 1;
}

void gluTessEndContour(GLUtesselator *tess)
{
  if (*(_DWORD *)tess != 2)
    GotoState((uint64_t)tess, 2u);
  *(_DWORD *)tess = 1;
}

void gluTessEndPolygon(GLUtesselator *tess)
{
  int *v2;
  uint64_t (*v3)();
  int v4;
  void **v5;
  int v6;

  v2 = (int *)((char *)tess + 3464);
  if (!setjmp((int *)tess + 866))
  {
    if (*(_DWORD *)tess != 1)
      GotoState((uint64_t)tess, 1u);
    *(_DWORD *)tess = 0;
    if (*((_QWORD *)tess + 2))
      goto LABEL_37;
    if (!*((_BYTE *)tess + 152)
      && *((uint64_t (**)())tess + 25) == noMesh
      && __gl_renderCache((uint64_t)tess))
    {
      goto LABEL_31;
    }
    EmptyCache((uint64_t)tess);
    if (v4)
    {
LABEL_37:
      __gl_projectPolygon((uint64_t)tess);
      if (__gl_computeInterior((uint64_t)tess))
      {
        v5 = (void **)*((_QWORD *)tess + 2);
        if (*((_BYTE *)tess + 116))
          goto LABEL_12;
        if (*((_BYTE *)tess + 153))
          v6 = __gl_meshSetWindingNumber(*((_QWORD *)tess + 2), 1, 1);
        else
          v6 = __gl_meshTessellateInterior(*((_QWORD *)tess + 2));
        if (v6)
        {
          __gl_meshCheckMesh(v5);
          if (*((uint64_t (**)())tess + 21) != noBegin
            || *((uint64_t (**)())tess + 24) != noEnd
            || *((uint64_t (**)())tess + 23) != noVertex
            || *((uint64_t (**)())tess + 22) != noEdgeFlag
            || *((uint64_t (**)())tess + 427) != __gl_noBeginData
            || *((uint64_t (**)())tess + 430) != __gl_noEndData
            || *((uint64_t (**)())tess + 429) != __gl_noVertexData
            || *((uint64_t (**)())tess + 428) != __gl_noEdgeFlagData)
          {
            if (*((_BYTE *)tess + 153))
              __gl_renderBoundary((uint64_t)tess, (uint64_t)v5);
            else
              __gl_renderMesh((uint64_t)tess, (uint64_t)v5);
          }
          if (*((uint64_t (**)())tess + 25) != noMesh)
          {
            __gl_meshDiscardExterior((uint64_t)v5);
            (*((void (**)(void **))tess + 25))(v5);
            *((_QWORD *)tess + 2) = 0;
LABEL_31:
            *((_QWORD *)tess + 457) = 0;
            return;
          }
LABEL_12:
          __gl_meshDeleteMesh(v5);
          *((_QWORD *)tess + 457) = 0;
          *((_QWORD *)tess + 2) = 0;
          return;
        }
      }
    }
    longjmp(v2, 1);
  }
  v3 = (uint64_t (*)())*((_QWORD *)tess + 431);
  if (v3 == __gl_noErrorData)
    (*((void (**)(uint64_t))tess + 3))(100902);
  else
    ((void (*)(uint64_t, _QWORD))v3)(100902, *((_QWORD *)tess + 457));
}

uint64_t __gl_renderMesh(uint64_t result, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t (*v9)(uint64_t, uint64_t, uint64_t);
  uint64_t (*v10)(uint64_t, uint64_t, uint64_t);
  BOOL v11;
  _QWORD *v12;
  uint64_t (*v13)(uint64_t, uint64_t, uint64_t);
  uint64_t v14;
  uint64_t (*v15)();
  int v16;
  _QWORD *v17;
  int v18;
  int v19;
  uint64_t (*v20)();
  uint64_t (*v21)();
  uint64_t v22;
  uint64_t (*v23)();
  uint64_t v24;
  _QWORD *v25;
  uint64_t (*v26)(uint64_t, uint64_t, uint64_t);

  *(_QWORD *)(result + 160) = 0;
  v2 = (uint64_t *)(a2 + 80);
  v3 = *(uint64_t **)(a2 + 80);
  if (v3 != (uint64_t *)(a2 + 80))
  {
    v4 = result;
    v5 = *(uint64_t **)(a2 + 80);
    do
    {
      *((_BYTE *)v5 + 40) = 0;
      v5 = (uint64_t *)*v5;
    }
    while (v5 != v2);
    if (v3 != v2)
    {
      do
      {
        if (*((_BYTE *)v3 + 41) && !*((_BYTE *)v3 + 40))
        {
          v6 = (_QWORD *)v3[2];
          if (*(_BYTE *)(v4 + 152))
          {
            result = RenderTriangle(v4, (uint64_t)v6, 1);
          }
          else
          {
            MaximumFan(v3[2], (uint64_t)&v24);
            if (v24 <= 1)
              v7 = 1;
            else
              v7 = v24;
            if (v24 <= 1)
              v8 = v6;
            else
              v8 = v25;
            if (v24 <= 1)
              v9 = RenderTriangle;
            else
              v9 = v26;
            MaximumFan(v6[3], (uint64_t)&v24);
            if (v24 > v7)
            {
              v7 = v24;
              v8 = v25;
              v9 = v26;
            }
            MaximumFan(*(_QWORD *)(v6[2] + 8), (uint64_t)&v24);
            if (v24 > v7)
            {
              v7 = v24;
              v8 = v25;
              v9 = v26;
            }
            MaximumStrip(v6, (uint64_t)&v24);
            if (v24 <= v7)
            {
              v10 = v9;
            }
            else
            {
              v7 = v24;
              v8 = v25;
              v10 = v26;
            }
            MaximumStrip((_QWORD *)v6[3], (uint64_t)&v24);
            v11 = v24 <= v7;
            if (v24 <= v7)
            {
              v12 = v8;
            }
            else
            {
              v7 = v24;
              v12 = v25;
            }
            if (v11)
              v13 = v10;
            else
              v13 = v26;
            MaximumStrip(*(_QWORD **)(v6[2] + 8), (uint64_t)&v24);
            if (v24 <= v7)
              result = v13(v4, (uint64_t)v12, v7);
            else
              result = v26(v4, (uint64_t)v25, v24);
          }
          if (!*((_BYTE *)v3 + 40))
            __gl_renderMesh_cold_1();
        }
        v3 = (uint64_t *)*v3;
      }
      while (v3 != v2);
      v14 = *(_QWORD *)(v4 + 160);
      if (v14)
      {
        v15 = *(uint64_t (**)())(v4 + 3416);
        if (v15 == __gl_noBeginData)
          (*(void (**)(uint64_t))(v4 + 168))(4);
        else
          ((void (*)(uint64_t, _QWORD))v15)(4, *(_QWORD *)(v4 + 3656));
        v16 = -1;
        do
        {
          v17 = *(_QWORD **)(v14 + 16);
          do
          {
            if (*(_BYTE *)(v4 + 152))
            {
              v18 = *(unsigned __int8 *)(*(_QWORD *)(v17[1] + 40) + 41);
              v19 = *(_BYTE *)(*(_QWORD *)(v17[1] + 40) + 41) == 0;
              if (v16 != v19)
              {
                v20 = *(uint64_t (**)())(v4 + 3424);
                if (v20 == __gl_noEdgeFlagData)
                  (*(void (**)(BOOL))(v4 + 176))(v18 == 0);
                else
                  ((void (*)(BOOL, _QWORD))v20)(v18 == 0, *(_QWORD *)(v4 + 3656));
                v16 = v19;
              }
            }
            v21 = *(uint64_t (**)())(v4 + 3432);
            if (v21 == __gl_noVertexData)
              v22 = (*(uint64_t (**)(_QWORD))(v4 + 184))(*(_QWORD *)(v17[4] + 24));
            else
              v22 = ((uint64_t (*)(_QWORD, _QWORD))v21)(*(_QWORD *)(v17[4] + 24), *(_QWORD *)(v4 + 3656));
            v17 = (_QWORD *)v17[3];
          }
          while (v17 != *(_QWORD **)(v14 + 16));
          v14 = *(_QWORD *)(v14 + 32);
        }
        while (v14);
        v23 = *(uint64_t (**)())(v4 + 3440);
        if (v23 == __gl_noEndData)
          result = (*(uint64_t (**)(uint64_t))(v4 + 192))(v22);
        else
          result = ((uint64_t (*)(_QWORD))v23)(*(_QWORD *)(v4 + 3656));
        *(_QWORD *)(v4 + 160) = 0;
      }
    }
  }
  return result;
}

uint64_t __gl_renderBoundary(uint64_t result, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t (*v5)();
  uint64_t v6;
  uint64_t (*v7)();
  uint64_t v8;
  uint64_t (*v9)();

  v2 = (uint64_t *)(a2 + 80);
  v3 = *(uint64_t **)(a2 + 80);
  if (v3 != (uint64_t *)(a2 + 80))
  {
    v4 = result;
    do
    {
      if (*((_BYTE *)v3 + 41))
      {
        v5 = *(uint64_t (**)())(v4 + 3416);
        if (v5 == __gl_noBeginData)
          (*(void (**)(uint64_t))(v4 + 168))(2);
        else
          ((void (*)(uint64_t, _QWORD))v5)(2, *(_QWORD *)(v4 + 3656));
        v6 = v3[2];
        do
        {
          v7 = *(uint64_t (**)())(v4 + 3432);
          if (v7 == __gl_noVertexData)
            v8 = (*(uint64_t (**)(_QWORD))(v4 + 184))(*(_QWORD *)(*(_QWORD *)(v6 + 32) + 24));
          else
            v8 = ((uint64_t (*)(_QWORD, _QWORD))v7)(*(_QWORD *)(*(_QWORD *)(v6 + 32) + 24), *(_QWORD *)(v4 + 3656));
          v6 = *(_QWORD *)(v6 + 24);
        }
        while (v6 != v3[2]);
        v9 = *(uint64_t (**)())(v4 + 3440);
        if (v9 == __gl_noEndData)
          result = (*(uint64_t (**)(uint64_t))(v4 + 192))(v8);
        else
          result = ((uint64_t (*)(_QWORD))v9)(*(_QWORD *)(v4 + 3656));
      }
      v3 = (uint64_t *)*v3;
    }
    while (v3 != v2);
  }
  return result;
}

uint64_t __gl_renderCache(uint64_t a1)
{
  uint64_t v1;
  double v3;
  double v4;
  int v5;
  int v6;
  int v7;
  uint64_t (*v9)();
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t (*v15)();
  uint64_t v16;
  unint64_t v17;
  unint64_t j;
  uint64_t (*v19)();
  unint64_t i;
  uint64_t (*v21)();
  uint64_t (*v22)();
  double v23[4];

  v23[3] = *(double *)MEMORY[0x1E0C80C00];
  v1 = *(int *)(a1 + 212);
  if ((int)v1 >= 3)
  {
    v3 = *(double *)(a1 + 40);
    v23[0] = *(double *)(a1 + 32);
    v23[1] = v3;
    v4 = *(double *)(a1 + 48);
    v23[2] = v4;
    if (v23[0] == 0.0 && v3 == 0.0 && v4 == 0.0)
      ComputeNormal(a1, v23, 0);
    v5 = ComputeNormal(a1, v23, 1);
    if (v5 == 2)
      return 0;
    v6 = v5;
    if (v5)
    {
      v7 = *(_DWORD *)(a1 + 112);
      if (v7 != 100134)
      {
        if (v7 != 100133)
        {
          if (v7 == 100132 && v5 < 0)
            return 1;
LABEL_15:
          v9 = *(uint64_t (**)())(a1 + 3416);
          if (v9 == __gl_noBeginData)
          {
            if (v1 >= 4)
              v12 = 6;
            else
              v12 = 4;
            if (*(_BYTE *)(a1 + 153))
              v13 = 2;
            else
              v13 = v12;
            (*(void (**)(uint64_t))(a1 + 168))(v13);
          }
          else
          {
            if (v1 >= 4)
              v10 = 6;
            else
              v10 = 4;
            if (*(_BYTE *)(a1 + 153))
              v11 = 2;
            else
              v11 = v10;
            ((void (*)(uint64_t, _QWORD))v9)(v11, *(_QWORD *)(a1 + 3656));
          }
          v14 = a1 + 216;
          v15 = *(uint64_t (**)())(a1 + 3432);
          if (v15 == __gl_noVertexData)
            v16 = (*(uint64_t (**)(_QWORD))(a1 + 184))(*(_QWORD *)(a1 + 240));
          else
            v16 = ((uint64_t (*)(_QWORD, _QWORD))v15)(*(_QWORD *)(a1 + 240), *(_QWORD *)(a1 + 3656));
          v17 = v14 + 32 * v1;
          if (v6 <= 0)
          {
            for (i = v17 - 32; i > v14; i -= 32)
            {
              v21 = *(uint64_t (**)())(a1 + 3432);
              if (v21 == __gl_noVertexData)
                v16 = (*(uint64_t (**)(_QWORD))(a1 + 184))(*(_QWORD *)(i + 24));
              else
                v16 = ((uint64_t (*)(_QWORD, _QWORD))v21)(*(_QWORD *)(i + 24), *(_QWORD *)(a1 + 3656));
            }
          }
          else
          {
            for (j = a1 + 248; j < v17; j += 32)
            {
              v19 = *(uint64_t (**)())(a1 + 3432);
              if (v19 == __gl_noVertexData)
                v16 = (*(uint64_t (**)(_QWORD))(a1 + 184))(*(_QWORD *)(j + 24));
              else
                v16 = ((uint64_t (*)(_QWORD, _QWORD))v19)(*(_QWORD *)(j + 24), *(_QWORD *)(a1 + 3656));
            }
          }
          v22 = *(uint64_t (**)())(a1 + 3440);
          if (v22 == __gl_noEndData)
            (*(void (**)(uint64_t))(a1 + 192))(v16);
          else
            ((void (*)(_QWORD))v22)(*(_QWORD *)(a1 + 3656));
          return 1;
        }
        if (v5 <= 0)
          goto LABEL_15;
      }
    }
  }
  return 1;
}

uint64_t ComputeNormal(uint64_t a1, double *a2, int a3)
{
  unint64_t v3;
  double *v4;
  uint64_t v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;

  v3 = a1 + 32 * *(int *)(a1 + 212) + 216;
  if (!a3)
  {
    *a2 = 0.0;
    a2[1] = 0.0;
    a2[2] = 0.0;
  }
  v4 = (double *)(a1 + 280);
  if (a1 + 280 < v3)
  {
    v5 = 0;
    v6 = *(double *)(a1 + 264) - *(double *)(a1 + 232);
    v7 = *(double *)(a1 + 256) - *(double *)(a1 + 224);
    v8 = *(double *)(a1 + 248) - *(double *)(a1 + 216);
    v9 = *a2;
    v10 = a2[1];
    v11 = a2[2];
    while (1)
    {
      v12 = v7;
      v13 = v6;
      v7 = v4[1] - *(double *)(a1 + 224);
      v6 = v4[2] - *(double *)(a1 + 232);
      v14 = v8 * v6;
      v15 = v8 * v7;
      v8 = *v4 - *(double *)(a1 + 216);
      v16 = v12 * v6 - v13 * v7;
      v17 = v13 * v8 - v14;
      v18 = v15 - v12 * v8;
      v19 = v18 * v11 + v9 * v16 + v10 * v17;
      if (a3)
      {
        if (v19 != 0.0)
        {
          if (v19 <= 0.0)
          {
            if ((int)v5 > 0)
              return 2;
            v5 = 0xFFFFFFFFLL;
          }
          else
          {
            if ((v5 & 0x80000000) != 0)
              return 2;
            v5 = 1;
          }
        }
      }
      else
      {
        if (v19 < 0.0)
        {
          v9 = v9 - v16;
          v10 = v10 - v17;
          *a2 = v9;
          a2[1] = v10;
          v11 = v11 - v18;
        }
        else
        {
          v9 = v9 + v16;
          v10 = v10 + v17;
          *a2 = v9;
          a2[1] = v10;
          v11 = v18 + v11;
        }
        a2[2] = v11;
      }
      v4 += 4;
      if ((unint64_t)v4 >= v3)
        return v5;
    }
  }
  return 0;
}

uint64_t RenderTriangle(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (a3 != 1)
    RenderTriangle_cold_1();
  v3 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(v3 + 32) = *(_QWORD *)(result + 160);
  *(_QWORD *)(result + 160) = v3;
  *(_BYTE *)(v3 + 40) = 1;
  return result;
}

uint64_t MaximumFan@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *(_OWORD *)a2 = xmmword_1E654B168;
  *(_QWORD *)(a2 + 16) = RenderFan;
  v2 = *(_QWORD *)(result + 40);
  if (*(_BYTE *)(v2 + 41))
  {
    v3 = 0;
    v4 = 0;
    v5 = result;
    while (1)
    {
      v6 = v2;
      if (*(_BYTE *)(v2 + 40))
        break;
      *(_QWORD *)(v2 + 32) = v3;
      *(_BYTE *)(v2 + 40) = 1;
      *(_QWORD *)a2 = ++v4;
      v5 = *(_QWORD *)(v5 + 16);
      v2 = *(_QWORD *)(v5 + 40);
      v3 = v6;
      if (!*(_BYTE *)(v2 + 41))
        goto LABEL_8;
    }
    v6 = v3;
  }
  else
  {
    v4 = 0;
    v6 = 0;
  }
LABEL_8:
  v7 = *(_QWORD *)(result + 8);
  v8 = *(_QWORD *)(v7 + 40);
  if (*(_BYTE *)(v8 + 41) && !*(_BYTE *)(v8 + 40))
  {
    while (1)
    {
      v9 = v8;
      *(_QWORD *)(v8 + 32) = v6;
      *(_BYTE *)(v8 + 40) = 1;
      result = *(_QWORD *)(v7 + 24);
      v7 = *(_QWORD *)(result + 8);
      v8 = *(_QWORD *)(v7 + 40);
      if (!*(_BYTE *)(v8 + 41))
        break;
      ++v4;
      v6 = v9;
      if (*(_BYTE *)(v8 + 40))
      {
        *(_QWORD *)a2 = v4;
        goto LABEL_11;
      }
    }
    *(_QWORD *)a2 = v4 + 1;
    *(_QWORD *)(a2 + 8) = result;
    goto LABEL_12;
  }
  v9 = v6;
LABEL_11:
  for (*(_QWORD *)(a2 + 8) = result; v9; v9 = *(_QWORD *)(v9 + 32))
LABEL_12:
    *(_BYTE *)(v9 + 40) = 0;
  return result;
}

_QWORD *MaximumStrip@<X0>(_QWORD *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;

  *(_OWORD *)a2 = xmmword_1E654B180;
  *(_QWORD *)(a2 + 16) = RenderStrip;
  v2 = result[5];
  if (*(_BYTE *)(v2 + 41))
  {
    v3 = 0;
    v4 = 0;
    v5 = result;
    while (!*(_BYTE *)(v2 + 40))
    {
      *(_QWORD *)(v2 + 32) = v3;
      *(_BYTE *)(v2 + 40) = 1;
      v5 = *(_QWORD **)(v5[3] + 8);
      v3 = v5[5];
      if (!*(_BYTE *)(v3 + 41) || *(_BYTE *)(v3 + 40))
      {
        ++v4;
        v3 = v2;
        break;
      }
      *(_QWORD *)(v3 + 32) = v2;
      *(_BYTE *)(v3 + 40) = 1;
      v4 += 2;
      v5 = (_QWORD *)v5[2];
      v2 = v5[5];
      if (!*(_BYTE *)(v2 + 41))
        break;
    }
  }
  else
  {
    v4 = 0;
    v3 = 0;
    v5 = result;
  }
  v6 = result[1];
  v7 = *(_QWORD *)(v6 + 40);
  if (*(_BYTE *)(v7 + 41) && !*(_BYTE *)(v7 + 40))
  {
    v10 = 1;
    while (1)
    {
      v8 = v10;
      *(_QWORD *)(v7 + 32) = v3;
      *(_BYTE *)(v7 + 40) = 1;
      result = *(_QWORD **)(v6 + 24);
      v11 = result[1];
      v3 = *(_QWORD *)(v11 + 40);
      if (!*(_BYTE *)(v3 + 41) || *(_BYTE *)(v3 + 40))
        break;
      *(_QWORD *)(v3 + 32) = v7;
      *(_BYTE *)(v3 + 40) = 1;
      result = *(_QWORD **)(*(_QWORD *)(v11 + 16) + 8);
      v6 = result[1];
      v7 = *(_QWORD *)(v6 + 40);
      if (*(_BYTE *)(v7 + 41))
      {
        v10 += 2;
        if (!*(_BYTE *)(v7 + 40))
          continue;
      }
      ++v8;
      goto LABEL_13;
    }
    v3 = v7;
  }
  else
  {
    v8 = 0;
  }
LABEL_13:
  *(_QWORD *)a2 = v8 + v4;
  if ((v4 & 1) != 0)
  {
    if ((v8 & 1) == 0)
      goto LABEL_18;
    *(_QWORD *)a2 = v8 + v4 - 1;
    v9 = result + 2;
  }
  else
  {
    v9 = v5 + 1;
  }
  result = (_QWORD *)*v9;
LABEL_18:
  for (*(_QWORD *)(a2 + 8) = result; v3; v3 = *(_QWORD *)(v3 + 32))
    *(_BYTE *)(v3 + 40) = 0;
  return result;
}

uint64_t RenderFan(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t (*v6)();
  uint64_t (*v7)();
  uint64_t (*v8)();
  uint64_t i;
  uint64_t (*v10)();
  uint64_t (*v11)();

  v6 = *(uint64_t (**)())(a1 + 3416);
  if (v6 == __gl_noBeginData)
    (*(void (**)(uint64_t))(a1 + 168))(6);
  else
    ((void (*)(uint64_t, _QWORD))v6)(6, *(_QWORD *)(a1 + 3656));
  v7 = *(uint64_t (**)())(a1 + 3432);
  if (v7 == __gl_noVertexData)
    (*(void (**)(_QWORD))(a1 + 184))(*(_QWORD *)(a2[4] + 24));
  else
    ((void (*)(_QWORD, _QWORD))v7)(*(_QWORD *)(a2[4] + 24), *(_QWORD *)(a1 + 3656));
  v8 = *(uint64_t (**)())(a1 + 3432);
  if (v8 == __gl_noVertexData)
    (*(void (**)(_QWORD))(a1 + 184))(*(_QWORD *)(*(_QWORD *)(a2[1] + 32) + 24));
  else
    ((void (*)(_QWORD, _QWORD))v8)(*(_QWORD *)(*(_QWORD *)(a2[1] + 32) + 24), *(_QWORD *)(a1 + 3656));
  for (i = a2[5]; *(_BYTE *)(i + 41); --a3)
  {
    if (*(_BYTE *)(i + 40))
      break;
    *(_BYTE *)(i + 40) = 1;
    a2 = (_QWORD *)a2[2];
    v10 = *(uint64_t (**)())(a1 + 3432);
    if (v10 == __gl_noVertexData)
      (*(void (**)(_QWORD))(a1 + 184))(*(_QWORD *)(*(_QWORD *)(a2[1] + 32) + 24));
    else
      ((void (*)(_QWORD, _QWORD))v10)(*(_QWORD *)(*(_QWORD *)(a2[1] + 32) + 24), *(_QWORD *)(a1 + 3656));
    i = a2[5];
  }
  if (a3)
    RenderFan_cold_1();
  v11 = *(uint64_t (**)())(a1 + 3440);
  if (v11 == __gl_noEndData)
    return (*(uint64_t (**)(void))(a1 + 192))();
  else
    return ((uint64_t (*)(_QWORD))v11)(*(_QWORD *)(a1 + 3656));
}

uint64_t RenderStrip(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t (*v6)();
  uint64_t (*v7)();
  uint64_t (*v8)();
  uint64_t v9;
  _QWORD *v10;
  uint64_t (*v11)();
  uint64_t v12;
  uint64_t (*v13)();
  uint64_t (*v14)();

  v6 = *(uint64_t (**)())(a1 + 3416);
  if (v6 == __gl_noBeginData)
    (*(void (**)(uint64_t))(a1 + 168))(5);
  else
    ((void (*)(uint64_t, _QWORD))v6)(5, *(_QWORD *)(a1 + 3656));
  v7 = *(uint64_t (**)())(a1 + 3432);
  if (v7 == __gl_noVertexData)
    (*(void (**)(_QWORD))(a1 + 184))(*(_QWORD *)(a2[4] + 24));
  else
    ((void (*)(_QWORD, _QWORD))v7)(*(_QWORD *)(a2[4] + 24), *(_QWORD *)(a1 + 3656));
  v8 = *(uint64_t (**)())(a1 + 3432);
  if (v8 == __gl_noVertexData)
    (*(void (**)(_QWORD))(a1 + 184))(*(_QWORD *)(*(_QWORD *)(a2[1] + 32) + 24));
  else
    ((void (*)(_QWORD, _QWORD))v8)(*(_QWORD *)(*(_QWORD *)(a2[1] + 32) + 24), *(_QWORD *)(a1 + 3656));
  v9 = a2[5];
  if (*(_BYTE *)(v9 + 41))
  {
    while (!*(_BYTE *)(v9 + 40))
    {
      *(_BYTE *)(v9 + 40) = 1;
      v10 = *(_QWORD **)(a2[3] + 8);
      v11 = *(uint64_t (**)())(a1 + 3432);
      if (v11 == __gl_noVertexData)
        (*(void (**)(_QWORD))(a1 + 184))(*(_QWORD *)(v10[4] + 24));
      else
        ((void (*)(_QWORD, _QWORD))v11)(*(_QWORD *)(v10[4] + 24), *(_QWORD *)(a1 + 3656));
      v12 = v10[5];
      if (!*(_BYTE *)(v12 + 41) || *(_BYTE *)(v12 + 40))
      {
        --a3;
        break;
      }
      *(_BYTE *)(v12 + 40) = 1;
      a2 = (_QWORD *)v10[2];
      v13 = *(uint64_t (**)())(a1 + 3432);
      if (v13 == __gl_noVertexData)
        (*(void (**)(_QWORD))(a1 + 184))(*(_QWORD *)(*(_QWORD *)(a2[1] + 32) + 24));
      else
        ((void (*)(_QWORD, _QWORD))v13)(*(_QWORD *)(*(_QWORD *)(a2[1] + 32) + 24), *(_QWORD *)(a1 + 3656));
      v9 = a2[5];
      a3 -= 2;
      if (!*(_BYTE *)(v9 + 41))
        break;
    }
  }
  if (a3)
    RenderStrip_cold_1();
  v14 = *(uint64_t (**)())(a1 + 3440);
  if (v14 == __gl_noEndData)
    return (*(uint64_t (**)(void))(a1 + 192))();
  else
    return ((uint64_t (*)(_QWORD))v14)(*(_QWORD *)(a1 + 3656));
}

void __gl_renderMesh_cold_1()
{
  __assert_rtn("__gl_renderMesh", "render.c", 98, "f->marked");
}

void RenderTriangle_cold_1()
{
  __assert_rtn("RenderTriangle", "render.c", 241, "size == 1");
}

void RenderFan_cold_1()
{
  __assert_rtn("RenderFan", "render.c", 298, "size == 0");
}

void RenderStrip_cold_1()
{
  __assert_rtn("RenderStrip", "render.c", 326, "size == 0");
}

double PGLInit(ProGL::Private *a1)
{
  unsigned int v1;
  ProGL::Private *inited;
  ProGL::Private *v3;
  ProGL::Private *v4;
  ProGL::Private *v5;
  ProGL::Private *v6;
  ProGL::Private *v7;
  PCMutex *v8;
  ProGL::Private *v9;
  ProGL::Private *v10;
  ProGL::Private *v11;
  double result;

  do
  if (!v1)
  {
    inited = (ProGL::Private *)ProGL::Private::initContextSharing(a1);
    ProGL::Private::initShareGroup(inited);
    ProGL::Private::initContext(v3);
    ProGL::Private::initPerThreadContext(v4);
    v6 = (ProGL::Private *)ProGL::Private::initContextInfo(v5);
    v7 = ProGL::Private::initAuxiliaryContexts(v6);
    v8 = ProGL::Private::initDeleteObjects(v7);
    v9 = (ProGL::Private *)ProGL::Private::initProgram((ProGL::Private *)v8);
    ProGL::Private::initTextureHandle(v9);
    v11 = (ProGL::Private *)ProGL::Private::initTexturePool(v10);
    return ProGL::Private::initLazyTexture(v11);
  }
  return result;
}

void PGLCleanup(ProGL::Private *a1)
{
  unsigned int v1;
  unsigned int v2;
  ProGL::Private *v3;
  ProGL::Private *v4;
  ProGL::Private *v5;
  ProGL::Private *v6;
  const PCString *v7;
  OZChannelBase *v8;
  ProGL::Private *v9;
  ProGL::Private *v10;
  OZChannelBase *v11;
  const PCString *v12;
  ProGL::Private *v13;
  ProGL::Private *v14;

  do
  {
    v2 = v1 - 1;
  }
  if (!v2)
  {
    v3 = (ProGL::Private *)ProGL::Private::cleanUpLazyTexture(a1);
    v4 = (ProGL::Private *)ProGL::Private::cleanUpTexturePool(v3);
    v5 = (ProGL::Private *)ProGL::Private::cleanUpTextureHandle(v4);
    v6 = (ProGL::Private *)ProGL::Private::cleanUpProgram(v5);
    v8 = ProGL::Private::cleanUpDeleteObjects(v6, v7);
    v9 = (ProGL::Private *)ProGL::Private::cleanUpAuxiliaryContexts((ProGL::Private *)v8);
    v10 = (ProGL::Private *)ProGL::Private::cleanUpContextInfo(v9);
    v11 = (OZChannelBase *)ProGL::Private::cleanUpPerThreadContext(v10);
    v13 = (ProGL::Private *)OZChannelBase::setRangeName(v11, v12);
    v14 = (ProGL::Private *)ProGL::Private::cleanUpShareGroup(v13);
    ProGL::Private::cleanUpContextSharing(v14);
  }
}

ProGL::Init *ProGL::Init::Init(ProGL::Init *this)
{
  PGLInit(this);
  return this;
}

void ProGL::Init::~Init(ProGL::Init *this)
{
  PGLCleanup(this);
}

BOOL ProGL::SharedPerThreadAuxiliaryMap::Key::operator<(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  if (*(_QWORD *)a1 < *(_QWORD *)a2)
    return 1;
  if (*(_QWORD *)a1 > *(_QWORD *)a2)
    return 0;
  v4 = (_QWORD *)(a1 + 8);
  v5 = (_QWORD *)(a2 + 8);
  if (ProGL::operator<((_QWORD *)(a1 + 8), (_QWORD *)(a2 + 8)))
    return 1;
  return !ProGL::operator>(v4, v5) && *(_DWORD *)(a1 + 16) < *(_DWORD *)(a2 + 16);
}

ProGL::SharedPerThreadAuxiliaryMap *ProGL::SharedPerThreadAuxiliaryMap::SharedPerThreadAuxiliaryMap(ProGL::SharedPerThreadAuxiliaryMap *this, unsigned int a2)
{
  uint64_t v4;

  *(_DWORD *)this = 0;
  v4 = operator new();
  *(_QWORD *)v4 = 0;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  *(_QWORD *)(v4 + 40) = 0;
  *(_QWORD *)(v4 + 24) = v4 + 32;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_QWORD *)(v4 + 80) = 0;
  *(_QWORD *)(v4 + 88) = -1;
  *(_QWORD *)(v4 + 96) = a2;
  *(_QWORD *)(v4 + 104) = 0;
  *((_QWORD *)this + 1) = v4;
  return this;
}

void sub_1B2C02FDC(_Unwind_Exception *a1)
{
  PCSpinLock *v1;

  PCSpinLock::~PCSpinLock(v1);
  _Unwind_Resume(a1);
}

void ProGL::SharedPerThreadAuxiliaryMap::get(ProGL::SharedPerThreadAuxiliaryMap *this@<X0>, os_unfair_lock_s **a2@<X1>, int a3@<W2>, ProGL::ContextHandle *a4@<X8>)
{
  PCSpinLock::lock((os_unfair_lock_t)this);
  ProGL::Private::AuxiliaryContextMap<ProGL::SharedPerThreadAuxiliaryMap::Key>::get((uint64_t *)this + 1, a2, a3, a4);
  if (this)
    PCSpinLock::unlock((os_unfair_lock_t)this);
}

void sub_1B2C03058(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void ProGL::Private::AuxiliaryContextMap<ProGL::SharedPerThreadAuxiliaryMap::Key>::get(uint64_t *a1@<X0>, os_unfair_lock_s **a2@<X1>, int a3@<W2>, ProGL::ContextHandle *a4@<X8>)
{
  const ProGL::ContextHandle *v8;
  uint64_t v9[2];
  char v10;
  pthread_t v11;
  PCSharedCount v12;
  int v13;

  v11 = pthread_self();
  ProGL::ContextHandle::getShareGroup(a2, &v12);
  v13 = a3;
  v10 = 0;
  PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::findValue((_QWORD *)*a1, (uint64_t)&v11, &v10, a4);
  if (!v10)
  {
    ProGL::makeEAGLContext(a2, v8, v9);
    ProGL::ContextHandle::operator=(a4, v9);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v9);
    ProGL::ContextHandle::setVirtualScreen(a4);
    PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::addValue(*a1, (uint64_t)&v11, (uint64_t *)a4, 0);
  }
}

void sub_1B2C03120(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ProGL::ContextHandle *v9;

  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a9);
  ProGL::ContextHandle::~ContextHandle(v9);
  _Unwind_Resume(a1);
}

ProGL::SharedPerThreadAuxiliaryMap *ProGL::Private::initAuxiliaryContexts(ProGL::Private *this)
{
  _QWORD *v1;
  uint64_t v2;
  ProGL::SharedPerThreadAuxiliaryMap *v3;
  ProGL::SharedPerThreadAuxiliaryMap *result;

  v1 = (_QWORD *)operator new();
  v2 = operator new();
  *(_QWORD *)v2 = 0;
  *(_QWORD *)(v2 + 8) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 24) = v2 + 32;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_QWORD *)(v2 + 80) = 0;
  *(_OWORD *)(v2 + 88) = xmmword_1B3054210;
  *(_QWORD *)(v2 + 104) = 0;
  *v1 = v2;
  v3 = (ProGL::SharedPerThreadAuxiliaryMap *)operator new();
  result = ProGL::SharedPerThreadAuxiliaryMap::SharedPerThreadAuxiliaryMap(v3, 0x28u);
  return result;
}

void sub_1B2C031FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1020C40D5A9D86FLL);
  _Unwind_Resume(a1);
}

uint64_t ProGL::Private::cleanUpAuxiliaryContexts(ProGL::Private *this)
{
  uint64_t result;
  uint64_t *v2;
  PCSpinLock *v3;

  {
    result = MEMORY[0x1B5E29170](v2, 0x20C4093837F09);
  }
  {
    PCSpinLock::~PCSpinLock(v3);
    result = MEMORY[0x1B5E29170]();
  }
  return result;
}

uint64_t *PCCache<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::~PCCache(uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1 + 32;
  std::__tree<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedAuxiliaryMap::Key,std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>>>::destroy(*a1 + 24, *(_QWORD **)v2);
  *(_QWORD *)(v2 - 8) = v2;
  *(_QWORD *)v2 = 0;
  *(_QWORD *)(v2 + 8) = 0;
  *(_QWORD *)(v2 + 24) = *(_QWORD *)(v2 + 16);
  *(_QWORD *)(v2 + 48) = 0;
  std::unique_ptr<PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>>::reset[abi:ne180100](a1, 0);
  return a1;
}

void std::__tree<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedAuxiliaryMap::Key,std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedAuxiliaryMap::Key,std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedAuxiliaryMap::Key,std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>>>::destroy(a1, a2[1]);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(a2 + 6));
    operator delete(a2);
  }
}

uint64_t std::unique_ptr<PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::~PCCacheImpl(result);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

uint64_t PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::~PCCacheImpl(uint64_t a1)
{
  void *v2;
  std::__shared_weak_count *v3;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
  std::__tree<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedAuxiliaryMap::Key,std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>>>::destroy(a1 + 24, *(_QWORD **)(a1 + 32));
  v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  return a1;
}

uint64_t *PCCache<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::~PCCache(uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1 + 32;
  std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::destroy(*a1 + 24, *(_QWORD **)v2);
  *(_QWORD *)(v2 - 8) = v2;
  *(_QWORD *)v2 = 0;
  *(_QWORD *)(v2 + 8) = 0;
  *(_QWORD *)(v2 + 24) = *(_QWORD *)(v2 + 16);
  *(_QWORD *)(v2 + 48) = 0;
  std::unique_ptr<PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>>::reset[abi:ne180100](a1, 0);
  return a1;
}

void std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::destroy(a1, a2[1]);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(a2 + 7));
    operator delete(a2);
  }
}

uint64_t std::unique_ptr<PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::~PCCacheImpl(result);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

uint64_t PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::~PCCacheImpl(uint64_t a1)
{
  void *v2;
  std::__shared_weak_count *v3;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
  std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::destroy(a1 + 24, *(_QWORD **)(a1 + 32));
  v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  return a1;
}

_QWORD *PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::findValue@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *result;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;

  result = std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::find<ProGL::SharedPerThreadAuxiliaryMap::Key>((uint64_t)(a1 + 3), a2);
  v12 = result;
  if (a1 + 4 == result)
  {
    *a3 = 0;
    *a4 = 0;
    a4[1] = 0;
  }
  else
  {
    v8 = result[8];
    *a4 = result[7];
    a4[1] = v8;
    if (v8)
    {
      v9 = (unint64_t *)(v8 + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v11 = a1[9] + 1;
    a1[9] = v11;
    result[10] = v11;
    result = PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::bubble(a1 + 6, (uint64_t)&v12);
    *a3 = 1;
  }
  return result;
}

void sub_1B2C03584(_Unwind_Exception *a1)
{
  ProGL::ContextHandle *v1;

  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::find<ProGL::SharedPerThreadAuxiliaryMap::Key>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  _BOOL4 v6;
  _QWORD *v7;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = (_QWORD *)(a1 + 8);
  do
  {
    v6 = ProGL::SharedPerThreadAuxiliaryMap::Key::operator<((uint64_t)(v3 + 4), a2);
    v7 = v3 + 1;
    if (!v6)
    {
      v7 = v3;
      v5 = v3;
    }
    v3 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v5 == v2 || ProGL::SharedPerThreadAuxiliaryMap::Key::operator<(a2, (uint64_t)(v5 + 4)))
    return v2;
  return v5;
}

void PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::addValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unsigned __int8 v15;
  unint64_t v16;
  uint64_t *v17;
  ProGL::ContextHandle *v18;
  uint64_t **v19;
  uint64_t *v20;
  uint64_t v21;
  int v22;
  _QWORD v23[2];
  __int128 v24;
  uint64_t v25;
  uint64_t v26[2];
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  _QWORD *v31;

  if (*(_QWORD *)(a1 + 88) >= a4 || *(_QWORD *)(a1 + 104))
  {
    v8 = std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::find<ProGL::SharedPerThreadAuxiliaryMap::Key>(a1 + 24, a2);
    v31 = v8;
    if ((_QWORD *)(a1 + 32) == v8)
    {
      v9 = *(_QWORD *)(a1 + 72) + 1;
      *(_QWORD *)(a1 + 72) = v9;
      v10 = a3[1];
      v27 = *a3;
      v28 = v10;
      if (v10)
      {
        v11 = (unint64_t *)(v10 + 8);
        do
          v12 = __ldxr(v11);
        while (__stxr(v12 + 1, v11));
      }
      *(_QWORD *)&v29 = a4;
      *((_QWORD *)&v29 + 1) = v9;
      v30 = 0;
      v20 = *(uint64_t **)a2;
      ProGL::ShareGroup::ShareGroup(&v21, (_QWORD *)(a2 + 8));
      v22 = *(_DWORD *)(a2 + 16);
      v23[0] = v27;
      v23[1] = v28;
      if (v28)
      {
        v13 = (unint64_t *)(v28 + 8);
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }
      v24 = v29;
      v25 = v30;
      v26[0] = (uint64_t)std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::__emplace_unique_key_args<ProGL::SharedPerThreadAuxiliaryMap::Key,std::pair<ProGL::SharedPerThreadAuxiliaryMap::Key const,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>((uint64_t **)(a1 + 24), (uint64_t)&v20, (uint64_t)&v20);
      v26[1] = v15;
      ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v23);
      PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::add((void **)(a1 + 48), v26);
      v16 = *(_QWORD *)(a1 + 80) + a4;
      *(_QWORD *)(a1 + 80) = v16;
      if (!*(_QWORD *)(a1 + 104))
      {
        while (v16 > *(_QWORD *)(a1 + 88) || *(_QWORD *)(a1 + 40) > *(_QWORD *)(a1 + 96))
        {
          v19 = *(uint64_t ***)(a1 + 48);
          if (v19 == *(uint64_t ***)(a1 + 56))
            break;
          v20 = *v19;
          PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::remove((uint64_t *)(a1 + 48), (uint64_t)&v20);
          v17 = v20;
          v18 = (ProGL::ContextHandle *)(v20 + 7);
          *(_QWORD *)(a1 + 80) -= v20[9];
          std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 24), v17);
          ProGL::ContextHandle::~ContextHandle(v18);
          operator delete(v17);
          v16 = *(_QWORD *)(a1 + 80);
        }
      }
      ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v27);
    }
    else
    {
      ProGL::ContextHandle::operator=(v8 + 7, a3);
      PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::update(a1, (uint64_t)&v31, a4);
    }
  }
}

void sub_1B2C037F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  _Unwind_Resume(a1);
}

void PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::update(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t **v11;
  uint64_t *v12;
  ProGL::ContextHandle *v13;
  uint64_t *v14;

  v6 = *(_QWORD *)(a1 + 72) + 1;
  *(_QWORD *)(a1 + 72) = v6;
  *(_QWORD *)(*(_QWORD *)a2 + 80) = v6;
  v7 = (uint64_t *)(a1 + 48);
  PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::bubble((uint64_t *)(a1 + 48), a2);
  v8 = *(_QWORD *)a2;
  v9 = a3 - *(_QWORD *)(*(_QWORD *)a2 + 72);
  if (v9)
  {
    v10 = v9 + *(_QWORD *)(a1 + 80);
    *(_QWORD *)(a1 + 80) = v10;
    *(_QWORD *)(v8 + 72) = a3;
    if (!*(_QWORD *)(a1 + 104))
    {
      while (v10 > *(_QWORD *)(a1 + 88) || *(_QWORD *)(a1 + 40) > *(_QWORD *)(a1 + 96))
      {
        v11 = *(uint64_t ***)(a1 + 48);
        if (v11 == *(uint64_t ***)(a1 + 56))
          break;
        v14 = *v11;
        PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::remove(v7, (uint64_t)&v14);
        v12 = v14;
        v13 = (ProGL::ContextHandle *)(v14 + 7);
        *(_QWORD *)(a1 + 80) -= v14[9];
        std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 24), v12);
        ProGL::ContextHandle::~ContextHandle(v13);
        operator delete(v12);
        v10 = *(_QWORD *)(a1 + 80);
      }
    }
  }
}

uint64_t *std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::__emplace_unique_key_args<ProGL::SharedPerThreadAuxiliaryMap::Key,std::pair<ProGL::SharedPerThreadAuxiliaryMap::Key const,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t *v9[3];
  uint64_t v10;

  v5 = (uint64_t **)std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::__find_equal<ProGL::SharedPerThreadAuxiliaryMap::Key>((uint64_t)a1, &v10, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = v5;
    std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::__construct_node<std::pair<ProGL::SharedPerThreadAuxiliaryMap::Key const,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>((uint64_t)a1, a3, (uint64_t)v9);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v10, v7, v9[0]);
    v6 = v9[0];
    v9[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,void *>>>>::reset[abi:ne180100]((uint64_t *)v9, 0);
  }
  return v6;
}

_QWORD *std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::__find_equal<ProGL::SharedPerThreadAuxiliaryMap::Key>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v7;
  uint64_t v8;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v7 = v4;
        v8 = (uint64_t)(v4 + 4);
        if (!ProGL::SharedPerThreadAuxiliaryMap::Key::operator<(a3, (uint64_t)(v4 + 4)))
          break;
        v4 = (_QWORD *)*v7;
        v5 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (!ProGL::SharedPerThreadAuxiliaryMap::Key::operator<(v8, a3))
        break;
      v5 = v7 + 1;
      v4 = (_QWORD *)v7[1];
    }
    while (v4);
  }
  else
  {
    v7 = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::__construct_node<std::pair<ProGL::SharedPerThreadAuxiliaryMap::Key const,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  void *v6;
  uint64_t result;

  v5 = a1 + 8;
  v6 = operator new(0x60uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = std::pair<ProGL::SharedPerThreadAuxiliaryMap::Key const,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>::pair[abi:ne180100]((uint64_t)v6 + 32, a2);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1B2C03A94(_Unwind_Exception *a1)
{
  uint64_t *v1;

  std::unique_ptr<std::__tree_node<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t std::pair<ProGL::SharedPerThreadAuxiliaryMap::Key const,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>::pair[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v7;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  ProGL::ShareGroup::ShareGroup((_QWORD *)(a1 + 8), (_QWORD *)(a2 + 8));
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v7;
  return a1;
}

void std::unique_ptr<std::__tree_node<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,void *>>>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    if (*((_BYTE *)a1 + 16))
      ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(v2 + 56));
    operator delete((void *)v2);
  }
}

void *ProGL::ShareGroup::findGroup@<X0>(void *this@<X0>, _QWORD *a2@<X8>)
{
  if (this)
    this = (void *)objc_msgSend(this, "sharegroup");
  *a2 = this;
  return this;
}

_QWORD *ProGL::ShareGroup::ShareGroup(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

uint64_t (*ProGL::ShareGroup::operator void (ProGL::ShareGroup::*)(void)(_QWORD *a1))(ProGL::ShareGroup *__hidden this)
{
  if (*a1)
    return ProGL::ShareGroup::dummyFunc;
  else
    return 0;
}

BOOL ProGL::operator==(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2;
}

BOOL ProGL::operator<(_QWORD *a1, _QWORD *a2)
{
  BOOL v2;

  if (*a2)
    v2 = *a1 >= *a2;
  else
    v2 = 1;
  return !v2;
}

BOOL ProGL::operator>(_QWORD *a1, _QWORD *a2)
{
  BOOL v2;

  if (*a1)
    v2 = *a2 >= *a1;
  else
    v2 = 1;
  return !v2;
}

void ProGL::masterShareGroup(uint64_t *a1@<X8>)
{
  uint64_t v3;
  void *v4;
  uint64_t (*v5)(ProGL::ShareGroup *__hidden);
  void *p_p;
  _QWORD *v7;
  void *__p;
  char v9;
  _QWORD v10[11];
  char v11;
  uint64_t v12;

  {
  }
  else
  {
    v4 = (void *)PGLMasterEAGLContext();
    if (v4)
      v3 = objc_msgSend(v4, "sharegroup");
    else
      v3 = 0;
    v5 = ProGL::ShareGroup::dummyFunc;
    if (!v3)
      v5 = 0;
    if (!v5)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v10);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"ProGL::masterShareGroup(): ", 27);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"Master share group is 0 because there is no master CGLContextObj.\n", 66);
      std::stringbuf::str();
      if (v9 >= 0)
        p_p = &__p;
      else
        p_p = __p;
      NSLog(CFSTR("%s"), p_p);
      if (v9 < 0)
        operator delete(__p);
      v10[0] = *MEMORY[0x1E0DE4F60];
      *(_QWORD *)((char *)v10 + *(_QWORD *)(v10[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
      v10[1] = MEMORY[0x1E0DE4FB8] + 16;
      if (v11 < 0)
        operator delete((void *)v10[9]);
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      MEMORY[0x1B5E290BC](&v12);
    }
    v7 = (_QWORD *)operator new();
    *v7 = v3;
  }
  *a1 = v3;
}

void sub_1B2C03D6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0)
    operator delete(__p);
  std::ostringstream::~ostringstream((uint64_t)&a17);
  _Unwind_Resume(a1);
}

void ProGL::Private::initShareGroup(ProGL::Private *this)
{
  uint64_t v1;

  ProGL::masterShareGroup(&v1);
}

uint64_t ProGL::Private::cleanUpShareGroup(ProGL::Private *this)
{
  uint64_t result;

  return result;
}

ProGL::GL_Wrap *ProGL::GL_Wrap::GL_Wrap(ProGL::GL_Wrap *this)
{
  uint64_t v3[2];

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  ProGL::getCurrentContext(v3);
  ProGL::ContextHandle::operator=(this, v3);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v3);
  *((_BYTE *)this + 16) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_BYTE *)this + 32) = 1;
  return this;
}

void sub_1B2C03E50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ProGL::ContextHandle *v9;

  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a9);
  ProGL::ContextHandle::~ContextHandle(v9);
  _Unwind_Resume(a1);
}

ProGL::GL_Wrap *ProGL::GL_Wrap::GL_Wrap(ProGL::GL_Wrap *this, const ProGL::GL_Wrap *a2)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  ProGL::ContextHandle::operator=(this, (uint64_t *)a2);
  *((_BYTE *)this + 16) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_BYTE *)this + 32) = *((_BYTE *)a2 + 32);
  return this;
}

void sub_1B2C03EB0(_Unwind_Exception *a1)
{
  ProGL::ContextHandle *v1;

  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

ProGL::GL_Wrap *ProGL::GL_Wrap::GL_Wrap(ProGL::GL_Wrap *this, const ProGL::ContextHandle *a2)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  ProGL::ContextHandle::operator=(this, (uint64_t *)a2);
  *((_BYTE *)this + 16) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_BYTE *)this + 32) = 1;
  return this;
}

void sub_1B2C03EFC(_Unwind_Exception *a1)
{
  ProGL::ContextHandle *v1;

  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

void ProGL::GL_Wrap::~GL_Wrap(ProGL::GL_Wrap *this)
{
  ProGL::MatrixState *v2;

  v2 = (ProGL::MatrixState *)*((_QWORD *)this + 3);
  if (v2)
  {
    ProGL::MatrixState::~MatrixState(v2);
    MEMORY[0x1B5E29170]();
  }
  ProGL::ContextHandle::~ContextHandle(this);
}

void ProGL::GL_Wrap::getIntegerv(ProGL::GL_Wrap *this, GLenum pname, GLint *params)
{
  glGetIntegerv(pname, params);
}

_QWORD *ProGL::GL::getPGLContextHandle@<X0>(_QWORD *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = this[1];
  *a2 = *this;
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

_DWORD *ProGL::Private::TextureParameters::resetDefaultsForTarget(_DWORD *this)
{
  int v1;
  int v2;
  int v3;
  int v4;

  v1 = this[4];
  if (v1 == 9986)
  {
    this[22] &= ~4u;
  }
  else if (!v1)
  {
    this[4] = 9986;
  }
  v2 = this[5];
  if (v2 == 10497)
  {
    this[22] &= ~0x10u;
  }
  else if (!v2)
  {
    this[5] = 10497;
  }
  v3 = this[6];
  if (v3 == 10497)
  {
    this[22] &= ~0x20u;
  }
  else if (!v3)
  {
    this[6] = 10497;
  }
  v4 = this[7];
  if (v4 == 10497)
  {
    this[22] &= ~0x40u;
  }
  else if (!v4)
  {
    this[7] = 10497;
  }
  return this;
}

double ProGL::Private::TextureParameters::reset(ProGL::Private::TextureParameters *this)
{
  double result;

  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 9729;
  *(_QWORD *)((char *)this + 36) = 0xC47A00003F800000;
  *((_DWORD *)this + 11) = 1148846080;
  *((_QWORD *)this + 6) = 0x3E800000000;
  *((_DWORD *)this + 14) = 0;
  *(_QWORD *)&result = 6409;
  *(_OWORD *)((char *)this + 60) = xmmword_1B3554710;
  *((_DWORD *)this + 19) = 1065353216;
  *((_QWORD *)this + 10) = 0;
  *((_DWORD *)this + 22) = 1;
  return result;
}

void ProGL::Private::TextureParameters::bind(ProGL::Private::TextureParameters *this, GLuint a2, ProGL::GL *a3, GLenum target)
{
  int v6;

  if (!*((_BYTE *)this + 84))
  {
    glBindTexture(target, a2);
    *((_BYTE *)this + 84) = 1;
    v6 = *((_DWORD *)this + 22);
    if (v6)
    {
      if ((v6 & 1) != 0)
      {
        ProGL::Private::TextureParameters::resetDefaultsForTarget(this);
        v6 = *((_DWORD *)this + 22);
        if ((v6 & 4) == 0)
        {
LABEL_5:
          if ((v6 & 8) == 0)
            goto LABEL_6;
          goto LABEL_12;
        }
      }
      else if ((v6 & 4) == 0)
      {
        goto LABEL_5;
      }
      glTexParameteri(target, 0x2801u, *((_DWORD *)this + 4));
      v6 = *((_DWORD *)this + 22);
      if ((v6 & 8) == 0)
      {
LABEL_6:
        if ((v6 & 0x10) == 0)
        {
LABEL_8:
          *((_DWORD *)this + 22) = 0;
          return;
        }
LABEL_7:
        glTexParameteri(target, 0x2802u, *((_DWORD *)this + 5));
        goto LABEL_8;
      }
LABEL_12:
      glTexParameteri(target, 0x2800u, *((_DWORD *)this + 8));
      if ((*((_DWORD *)this + 22) & 0x10) == 0)
        goto LABEL_8;
      goto LABEL_7;
    }
  }
}

uint64_t ProGL::Private::TextureParameters::isBound(ProGL::Private::TextureParameters *this)
{
  return *((unsigned __int8 *)this + 84);
}

void ProGL::Private::TextureParameters::unbind(ProGL::Private::TextureParameters *this, ProGL::GL *a2, GLenum target)
{
  if (*((_BYTE *)this + 84))
  {
    glBindTexture(target, 0);
    *((_BYTE *)this + 84) = 0;
  }
}

void ProGL::Private::TextureParameters::setMinFilter(ProGL::Private::TextureParameters *this, ProGL::GL *a2, GLenum target, GLint param)
{
  if (*((_DWORD *)this + 4) != param)
  {
    *((_DWORD *)this + 4) = param;
    if (*((_BYTE *)this + 84))
      glTexParameteri(target, 0x2801u, param);
    else
      *((_DWORD *)this + 22) |= 4u;
  }
}

void ProGL::Private::TextureParameters::setMagFilter(ProGL::Private::TextureParameters *this, ProGL::GL *a2, GLenum target, GLint param)
{
  if (*((_DWORD *)this + 8) != param)
  {
    *((_DWORD *)this + 8) = param;
    if (*((_BYTE *)this + 84))
      glTexParameteri(target, 0x2800u, param);
    else
      *((_DWORD *)this + 22) |= 8u;
  }
}

void ProGL::Private::TextureParameters::setWrapS(ProGL::Private::TextureParameters *this, ProGL::GL *a2, GLenum target, GLint param)
{
  if (*((_DWORD *)this + 5) != param)
  {
    *((_DWORD *)this + 5) = param;
    if (*((_BYTE *)this + 84))
      glTexParameteri(target, 0x2802u, param);
    else
      *((_DWORD *)this + 22) |= 0x10u;
  }
}

void ProGL::Private::TextureParameters::setWrapT(ProGL::Private::TextureParameters *this, ProGL::GL *a2, GLenum target, GLint param)
{
  if (*((_DWORD *)this + 6) != param)
  {
    *((_DWORD *)this + 6) = param;
    if (*((_BYTE *)this + 84))
      glTexParameteri(target, 0x2803u, param);
    else
      *((_DWORD *)this + 22) |= 0x20u;
  }
}

uint64_t ProGL::Private::TextureParameters::getGenerateMipmap(ProGL::Private::TextureParameters *this)
{
  return *((unsigned __int8 *)this + 72);
}

void ProGL::Private::TextureParameters::setMaxAnisotropy(GLfloat *this, ProGL::GL *a2, GLenum target, GLfloat a4)
{
  if (this[19] != a4)
  {
    this[19] = a4;
    if (*((_BYTE *)this + 84))
      glTexParameterf(target, 0x84FEu, a4);
    else
      *((_DWORD *)this + 22) |= 0x20000u;
  }
}

void ProGL::Private::deleteTextures(ProGL::Private::TextureImpl **this, ProGL::Private::TextureImpl **a2, ProGL::Private::TextureImpl **a3)
{
  _QWORD *v5;
  _QWORD *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  __int128 v10;

  if (this != a2)
  {
    v5 = (_QWORD *)operator new();
    *v5 = &off_1E654B1A8;
    v5[2] = 0;
    v5[3] = 0;
    v5[1] = 0;
    std::vector<TXTabStop *>::__init_with_size[abi:ne180100]<TXTabStop **,TXTabStop **>(v5 + 1, this, (uint64_t)a2, a2 - this);
    *(_QWORD *)&v10 = v5;
    v6 = (_QWORD *)operator new();
    *v6 = &off_1E654B1E8;
    v6[1] = 0;
    v6[2] = 0;
    v6[3] = v5;
    *((_QWORD *)&v10 + 1) = v6;
    ProGL::postDeletionInstruction(&v10);
    v7 = (std::__shared_weak_count *)*((_QWORD *)&v10 + 1);
    if (*((_QWORD *)&v10 + 1))
    {
      v8 = (unint64_t *)(*((_QWORD *)&v10 + 1) + 8);
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void sub_1B2C04380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::DeleteTextureInst::~DeleteTextureInst(OZChannelBase *this, const PCString *a2)
{
  void **var1;

  this->var0 = (void **)&off_1E654B1A8;
  var1 = (void **)this->var1;
  if (var1)
  {
    this->var2 = var1;
    operator delete(var1);
  }
  OZChannelBase::setRangeName(this, a2);
}

{
  void **var1;

  this->var0 = (void **)&off_1E654B1A8;
  var1 = (void **)this->var1;
  if (var1)
  {
    this->var2 = var1;
    operator delete(var1);
  }
  OZChannelBase::setRangeName(this, a2);
  JUMPOUT(0x1B5E29170);
}

void `anonymous namespace'::DeleteTextureInst::execute(_anonymous_namespace_::DeleteTextureInst *this)
{
  uint64_t *v1;
  HGPixelBufferObj **v2;
  const ProGL::ContextHandle *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  uint64_t *v6;
  const ProGL::ContextHandle *v7;
  unsigned int AlphaOperation;
  unsigned int v9;
  std::vector<unsigned int>::pointer end;
  unsigned int *v11;
  std::vector<unsigned int>::pointer begin;
  int64_t v13;
  unint64_t v14;
  int64_t v15;
  unint64_t v16;
  char *v17;
  unsigned int *v18;
  unsigned int v19;
  HGPixelBufferObj **v20;
  HGPixelBufferObj **v21;
  HGPixelBufferObj *v22;
  unsigned int v23;
  unsigned int v24;
  std::vector<unsigned int>::pointer v25;
  unsigned int *v26;
  std::vector<unsigned int>::pointer v27;
  int64_t v28;
  unint64_t v29;
  int64_t v30;
  unint64_t v31;
  char *v32;
  unsigned int *v33;
  unsigned int v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  GLuint textures[2];
  std::vector<unsigned int> v38;
  os_unfair_lock_s *v39[2];

  v1 = (uint64_t *)*((_QWORD *)this + 1);
  v2 = (HGPixelBufferObj **)*((_QWORD *)this + 2);
  if ((char *)v2 - (char *)v1 == 8)
  {
    ProGL::Private::TextureImpl::getContext(*v1, v39);
    v3 = (const ProGL::ContextHandle *)HGPixelBufferObj::format((HGPixelBufferObj *)*v1);
    ProGL::getDeletionContext(v39, v3, (ProGL::ContextHandle *)&v38);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v39);
    ProGL::CurrentContextSentry::CurrentContextSentry((ProGL::CurrentContextSentry *)v39, (const ProGL::ContextHandle *)&v38);
    textures[0] = HGGLBlendingInfo::GetAlphaOperation((HGGLBlendingInfo *)*v1);
    glDeleteTextures(1, textures);
    v4 = *v1;
    if (*v1)
    {
      std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v4 + 248);
      PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v4 + 208));
      std::__tree<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>>>::destroy(v4 + 176, *(_QWORD **)(v4 + 184));
      ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(v4 + 24));
      PCSpinLock::~PCSpinLock((PCSpinLock *)(v4 + 16));
      v5 = *(std::__shared_weak_count **)(v4 + 8);
      if (v5)
        std::__shared_weak_count::__release_weak(v5);
      MEMORY[0x1B5E29170](v4, 0x1020C40A7E6A51ELL);
    }
    ProGL::CurrentContextSentry::~CurrentContextSentry((ProGL::CurrentContextSentry *)v39);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v38);
  }
  else
  {
    memset(&v38, 0, sizeof(v38));
    std::vector<unsigned int>::reserve(&v38, ((char *)v2 - (char *)v1) >> 3);
    if (v1 != (uint64_t *)v2)
    {
      v6 = v1;
      do
      {
        ProGL::Private::TextureImpl::getContext(*v6, textures);
        v7 = (const ProGL::ContextHandle *)HGPixelBufferObj::format((HGPixelBufferObj *)*v6);
        ProGL::getDeletionContext((os_unfair_lock_s **)textures, v7, (ProGL::ContextHandle *)v39);
        ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)textures);
        v38.__end_ = v38.__begin_;
        AlphaOperation = HGGLBlendingInfo::GetAlphaOperation((HGGLBlendingInfo *)*v6);
        v9 = AlphaOperation;
        end = v38.__end_;
        if (v38.__end_ >= v38.__end_cap_.__value_)
        {
          begin = v38.__begin_;
          v13 = v38.__end_ - v38.__begin_;
          v14 = v13 + 1;
          if ((unint64_t)(v13 + 1) >> 62)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v15 = (char *)v38.__end_cap_.__value_ - (char *)v38.__begin_;
          if (((char *)v38.__end_cap_.__value_ - (char *)v38.__begin_) >> 1 > v14)
            v14 = v15 >> 1;
          if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL)
            v16 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v16 = v14;
          if (v16)
          {
            v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)&v38.__end_cap_, v16);
            begin = v38.__begin_;
            end = v38.__end_;
          }
          else
          {
            v17 = 0;
          }
          v18 = (unsigned int *)&v17[4 * v13];
          *v18 = v9;
          v11 = v18 + 1;
          while (end != begin)
          {
            v19 = *--end;
            *--v18 = v19;
          }
          v38.__begin_ = v18;
          v38.__end_ = v11;
          v38.__end_cap_.__value_ = (unsigned int *)&v17[4 * v16];
          if (begin)
            operator delete(begin);
        }
        else
        {
          *v38.__end_ = AlphaOperation;
          v11 = end + 1;
        }
        v38.__end_ = v11;
        v20 = (HGPixelBufferObj **)(v6 + 1);
        *(_QWORD *)textures = *v6;
        v21 = v2;
        if (v6 + 1 != (uint64_t *)v2)
        {
          v21 = v2;
          while (2)
          {
            {
              if (++v20 == v21)
                goto LABEL_35;
            }
            do
            {
              if (--v21 == v20)
              {
                v21 = v20;
                goto LABEL_35;
              }
            }
            v22 = *v20;
            *v20++ = *v21;
            *v21 = v22;
            if (v21 != v20)
              continue;
            break;
          }
        }
LABEL_35:
        if (v6 != (uint64_t *)v21)
        {
          do
          {
            v23 = HGGLBlendingInfo::GetAlphaOperation((HGGLBlendingInfo *)*v6);
            v24 = v23;
            v25 = v38.__end_;
            if (v38.__end_ >= v38.__end_cap_.__value_)
            {
              v27 = v38.__begin_;
              v28 = v38.__end_ - v38.__begin_;
              v29 = v28 + 1;
              if ((unint64_t)(v28 + 1) >> 62)
                std::vector<double>::__throw_length_error[abi:ne180100]();
              v30 = (char *)v38.__end_cap_.__value_ - (char *)v38.__begin_;
              if (((char *)v38.__end_cap_.__value_ - (char *)v38.__begin_) >> 1 > v29)
                v29 = v30 >> 1;
              if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFFCLL)
                v31 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v31 = v29;
              if (v31)
              {
                v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)&v38.__end_cap_, v31);
                v27 = v38.__begin_;
                v25 = v38.__end_;
              }
              else
              {
                v32 = 0;
              }
              v33 = (unsigned int *)&v32[4 * v28];
              *v33 = v24;
              v26 = v33 + 1;
              while (v25 != v27)
              {
                v34 = *--v25;
                *--v33 = v34;
              }
              v38.__begin_ = v33;
              v38.__end_ = v26;
              v38.__end_cap_.__value_ = (unsigned int *)&v32[4 * v31];
              if (v27)
                operator delete(v27);
            }
            else
            {
              *v38.__end_ = v23;
              v26 = v25 + 1;
            }
            v38.__end_ = v26;
            ++v6;
          }
          while (v6 != (uint64_t *)v21);
          v6 = (uint64_t *)v21;
        }
        ProGL::CurrentContextSentry::CurrentContextSentry((ProGL::CurrentContextSentry *)textures, (const ProGL::ContextHandle *)v39);
        glDeleteTextures((unint64_t)((char *)v38.__end_ - (char *)v38.__begin_) >> 2, v38.__begin_);
        ProGL::CurrentContextSentry::~CurrentContextSentry((ProGL::CurrentContextSentry *)textures);
        ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v39);
      }
      while (v6 != (uint64_t *)v2);
      do
      {
        v35 = *v1;
        if (*v1)
        {
          std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v35 + 248);
          PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v35 + 208));
          std::__tree<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>>>::destroy(v35 + 176, *(_QWORD **)(v35 + 184));
          ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(v35 + 24));
          PCSpinLock::~PCSpinLock((PCSpinLock *)(v35 + 16));
          v36 = *(std::__shared_weak_count **)(v35 + 8);
          if (v36)
            std::__shared_weak_count::__release_weak(v36);
          MEMORY[0x1B5E29170](v35, 0x1020C40A7E6A51ELL);
        }
        ++v1;
      }
      while (v1 != (uint64_t *)v2);
    }
    if (v38.__begin_)
    {
      v38.__end_ = v38.__begin_;
      operator delete(v38.__begin_);
    }
  }
}

void sub_1B2C0486C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, char a15)
{
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&__p);
  _Unwind_Resume(a1);
}

void std::vector<unsigned int>::reserve(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  std::__compressed_pair<unsigned int *> *p_end_cap;
  unsigned int *value;
  int64_t v5;
  char *v6;
  unsigned int *v7;
  uint64_t v8;
  unsigned int *v9;
  std::vector<unsigned int>::pointer begin;
  unsigned int *end;
  unsigned int *v12;
  unsigned int v13;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (__n > value - this->__begin_)
  {
    if (__n >> 62)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v5 = (char *)this->__end_ - (char *)this->__begin_;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)p_end_cap, __n);
    v7 = (unsigned int *)&v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    v9 = (unsigned int *)&v6[4 * v8];
    begin = this->__begin_;
    end = this->__end_;
    v12 = v7;
    if (end != this->__begin_)
    {
      v12 = v7;
      do
      {
        v13 = *--end;
        *--v12 = v13;
      }
      while (end != begin);
    }
    this->__begin_ = v12;
    this->__end_ = v7;
    this->__end_cap_.__value_ = v9;
    if (begin)
      operator delete(begin);
  }
}

BOOL `anonymous namespace'::SameShareGroup::operator()(uint64_t *a1, HGPixelBufferObj *a2)
{
  const ProGL::ContextHandle *v4;
  int v5;
  _BOOL8 v6;
  os_unfair_lock_s *v8[2];
  os_unfair_lock_s *v9[2];

  ProGL::Private::TextureImpl::getContext(*a1, v9);
  ProGL::Private::TextureImpl::getContext((uint64_t)a2, v8);
  if (ProGL::areContextsShared(v9, v8, v4))
  {
    v5 = HGPixelBufferObj::format((HGPixelBufferObj *)*a1);
    v6 = v5 == HGPixelBufferObj::format(a2);
  }
  else
  {
    v6 = 0;
  }
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v8);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v9);
  return v6;
}

void sub_1B2C04A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<`anonymous namespace'::DeleteTextureInst *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,`anonymous namespace'::DeleteTextureInst>,std::allocator<`anonymous namespace'::DeleteTextureInst>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

uint64_t std::__shared_ptr_pointer<`anonymous namespace'::DeleteTextureInst *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,`anonymous namespace'::DeleteTextureInst>,std::allocator<`anonymous namespace'::DeleteTextureInst>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<`anonymous namespace'::DeleteTextureInst *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,`anonymous namespace'::DeleteTextureInst>,std::allocator<`anonymous namespace'::DeleteTextureInst>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

double ProGL::Private::initLazyTexture(ProGL::Private *this)
{
  _OWORD *v1;
  double result;

  v1 = (_OWORD *)operator new();
  result = 0.0;
  *v1 = 0u;
  v1[1] = 0u;
  v1[2] = 0u;
  return result;
}

uint64_t ProGL::Private::cleanUpLazyTexture(ProGL::Private *this)
{
  uint64_t result;

  {
    result = MEMORY[0x1B5E29170]();
  }
  return result;
}

ProGL::TextureDescription *ProGL::TextureDescription::TextureDescription(ProGL::TextureDescription *this, const ProGL::ContextHandle *a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v3 = *((_QWORD *)a2 + 1);
  *(_QWORD *)this = *(_QWORD *)a2;
  *((_QWORD *)this + 1) = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  *((_DWORD *)this + 4) = ProGL::ContextHandle::getVirtualScreen(this);
  *(_QWORD *)((char *)this + 20) = 0;
  *(_QWORD *)((char *)this + 36) = 0;
  *(_QWORD *)((char *)this + 28) = 0;
  return this;
}

void sub_1B2C04B90(_Unwind_Exception *a1)
{
  ProGL::ContextHandle *v1;

  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

ProGL::TextureDescription *ProGL::TextureDescription::TextureDescription(ProGL::TextureDescription *this, int a2, int a3, int a4, int a5, const ProGL::ContextHandle *a6)
{
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;

  v11 = *((_QWORD *)a6 + 1);
  *(_QWORD *)this = *(_QWORD *)a6;
  *((_QWORD *)this + 1) = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  *((_DWORD *)this + 4) = ProGL::ContextHandle::getVirtualScreen(this);
  *((_DWORD *)this + 5) = a2;
  *((_DWORD *)this + 6) = a3;
  *(_QWORD *)((char *)this + 28) = 0x100000001;
  *((_DWORD *)this + 9) = a4;
  *((_DWORD *)this + 10) = a5;
  return this;
}

void sub_1B2C04C24(_Unwind_Exception *a1)
{
  ProGL::ContextHandle *v1;

  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

ProGL::TextureDescription *ProGL::TextureDescription::TextureDescription(ProGL::TextureDescription *this, int a2, int a3, int a4, int a5, int a6, const ProGL::ContextHandle *a7)
{
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  v13 = *((_QWORD *)a7 + 1);
  *(_QWORD *)this = *(_QWORD *)a7;
  *((_QWORD *)this + 1) = v13;
  if (v13)
  {
    v14 = (unint64_t *)(v13 + 8);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  *((_DWORD *)this + 4) = ProGL::ContextHandle::getVirtualScreen(this);
  *((_DWORD *)this + 5) = a2;
  *((_DWORD *)this + 6) = a3;
  *((_DWORD *)this + 7) = a4;
  *((_DWORD *)this + 8) = 1;
  *((_DWORD *)this + 9) = a5;
  *((_DWORD *)this + 10) = a6;
  return this;
}

void sub_1B2C04CBC(_Unwind_Exception *a1)
{
  ProGL::ContextHandle *v1;

  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

void ProGL::TextureDescription::reset(ProGL::TextureDescription *this)
{
  _OWORD v2[3];

  memset(v2, 0, sizeof(v2));
  ProGL::ContextHandle::operator=(this, (uint64_t *)v2);
  *((_OWORD *)this + 1) = v2[1];
  *(_OWORD *)((char *)this + 28) = *(_OWORD *)((char *)&v2[1] + 12);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v2);
}

void sub_1B2C04D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a9);
  _Unwind_Resume(a1);
}

void ProGL::Private::TextureHelper::makeTexture(uint64_t *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;

  v2 = *a1;
  v3 = (std::__shared_weak_count *)a1[1];
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
    *a2 = v2;
    a2[1] = v3;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  else
  {
    *a2 = v2;
    a2[1] = 0;
  }
}

double ProGL::Private::initTextureHandle(ProGL::Private *this)
{
  PCMutex *v1;
  _QWORD *v2;
  uint64_t v3;
  _OWORD *v4;
  double result;

  v1 = (PCMutex *)operator new();
  PCMutex::PCMutex(v1);
  v2 = (_QWORD *)operator new();
  v2[2] = 0;
  v2[1] = 0;
  *v2 = v2 + 1;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_QWORD *)(v3 + 8) = v3 + 16;
  v4 = (_OWORD *)operator new();
  result = 0.0;
  *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  return result;
}

void sub_1B2C04E88(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1081C4076DFA842);
  _Unwind_Resume(a1);
}

uint64_t ProGL::Private::cleanUpTextureHandle(ProGL::Private *this)
{
  uint64_t v1;
  PCSpinLock *v2;
  uint64_t result;

  {
    MEMORY[0x1B5E29170](v1, 0x1020C4062D53EE8);
  }
  {
    PCSpinLock::~PCSpinLock(v2);
    MEMORY[0x1B5E29170]();
  }
  {
    result = MEMORY[0x1B5E29170]();
  }
  return result;
}

void (*ProGL::TextureHandle::operator void (ProGL::TextureHandle::*)(void)(void (**a1)(_anonymous_namespace_ **this)))(_anonymous_namespace_ **this)
{
  void (*result)(_anonymous_namespace_ **);

  result = *a1;
  if (result)
  {
    if (HGGLBlendingInfo::GetAlphaOperation((HGGLBlendingInfo *)result))
      return ProGL::TextureHandle::detach;
    else
      return 0;
  }
  return result;
}

void ProGL::TextureHandle::detach(_anonymous_namespace_ **this)
{
  _anonymous_namespace_ *v2;
  ProGL::Private::TextureImpl *v3;
  void ***Serializer;

  v2 = *this;
  if (v2)
  {
    Serializer = OZChannelBase::getSerializer((OZChannelBase *)v2);
    PCSpinLock::lock((os_unfair_lock_t)Serializer);
    ProGL::Private::TextureImpl::detach(*this);
    PCSpinLock::unlock((os_unfair_lock_t)Serializer);
  }
}

void sub_1B2C05004(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

HGGLBlendingInfo *ProGL::TextureHandle::getName(HGGLBlendingInfo **this)
{
  HGGLBlendingInfo *result;

  result = *this;
  if (result)
    return (HGGLBlendingInfo *)HGGLBlendingInfo::GetAlphaOperation(result);
  return result;
}

uint64_t ProGL::TextureHandle::getContext@<X0>(ProGL::TextureHandle *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = *(_QWORD *)this;
  if (result)
    return ProGL::Private::TextureImpl::getContext(result, a2);
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void ProGL::TextureHandle::setPooled(OZChannelBase **this, char a2)
{
  OZChannelBase *v3;
  void ***Serializer;

  v3 = *this;
  if (v3)
  {
    Serializer = OZChannelBase::getSerializer(v3);
    PCSpinLock::lock((os_unfair_lock_t)Serializer);
    ProGL::Private::TextureImpl::setPooled((uint64_t)*this, a2);
    PCSpinLock::unlock((os_unfair_lock_t)Serializer);
  }
}

void sub_1B2C0509C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

ProGL::Private::TextureImpl *ProGL::TextureHandle::getSize(ProGL::Private::TextureImpl **this)
{
  ProGL::Private::TextureImpl *result;

  result = *this;
  if (result)
    return (ProGL::Private::TextureImpl *)ProGL::Private::TextureImpl::getSize(result);
  return result;
}

ProGL::Private::TextureImpl *ProGL::TextureHandle::getTarget(ProGL::Private::TextureImpl **this)
{
  ProGL::Private::TextureImpl *result;

  result = *this;
  if (result)
    return (ProGL::Private::TextureImpl *)ProGL::Private::TextureImpl::getTarget(result);
  return result;
}

ProGL::Private::TextureImpl *ProGL::TextureHandle::getWidth(ProGL::Private::TextureImpl **this)
{
  ProGL::Private::TextureImpl *result;

  result = *this;
  if (result)
    return (ProGL::Private::TextureImpl *)ProGL::Private::TextureImpl::getWidth(result);
  return result;
}

ProGL::Private::TextureImpl *ProGL::TextureHandle::getHeight(ProGL::Private::TextureImpl **this)
{
  ProGL::Private::TextureImpl *result;

  result = *this;
  if (result)
    return (ProGL::Private::TextureImpl *)ProGL::Private::TextureImpl::getHeight(result);
  return result;
}

ProGL::Private::TextureImpl *ProGL::TextureHandle::getBorder(ProGL::Private::TextureImpl **this)
{
  ProGL::Private::TextureImpl *result;

  result = *this;
  if (result)
    return (ProGL::Private::TextureImpl *)ProGL::Private::TextureImpl::getBorder(result);
  return result;
}

ProGL::Private::TextureImpl *ProGL::TextureHandle::getActualInternalFormat(ProGL::Private::TextureImpl **this)
{
  ProGL::Private::TextureImpl *result;

  result = *this;
  if (result)
    return (ProGL::Private::TextureImpl *)ProGL::Private::TextureImpl::getActualInternalFormat(result);
  return result;
}

uint64_t `anonymous namespace'::removeTexture(_anonymous_namespace_ *this, ProGL::Private::TextureImpl *a2)
{
  uint64_t result;
  int AlphaOperation;
  PCMutex *v5;
  os_unfair_lock_s *v6;
  char v7;
  PCSharedCount v8;
  int v9;
  uint64_t v10;

  result = HGGLBlendingInfo::GetAlphaOperation(this);
  if ((_DWORD)result)
  {
    AlphaOperation = HGGLBlendingInfo::GetAlphaOperation(this);
    ProGL::Private::TextureImpl::getContext((uint64_t)this, &v6);
    ProGL::ContextHandle::getShareGroup(&v6, &v8);
    v9 = AlphaOperation;
    ProGL::ShareGroup::ShareGroup(&v10, &v8);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v6);
    v7 = 1;
    if (v5)
      return PCMutex::unlock(v5);
  }
  return result;
}

void sub_1B2C051B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

void ProGL::TextureHandle::bind(OZChannelBase **this, ProGL::GL *a2, GLenum a3)
{
  void ***Serializer;

  Serializer = OZChannelBase::getSerializer(*this);
  PCSpinLock::lock((os_unfair_lock_t)Serializer);
  ProGL::Private::TextureImpl::bind((ProGL::Private::TextureImpl *)*this, a2, a3);
  PCSpinLock::unlock((os_unfair_lock_t)Serializer);
}

void sub_1B2C05240(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void ProGL::TextureHandle::unbind(OZChannelBase **this, ProGL::GL *a2)
{
  void ***Serializer;

  Serializer = OZChannelBase::getSerializer(*this);
  PCSpinLock::lock((os_unfair_lock_t)Serializer);
  ProGL::Private::TextureImpl::unbind((ProGL::Private::TextureImpl *)*this, a2);
  PCSpinLock::unlock((os_unfair_lock_t)Serializer);
}

void sub_1B2C052B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

uint64_t ProGL::TextureHandle::isBound(ProGL::Private::TextureImpl **this)
{
  ProGL::Private::TextureImpl *v2;
  uint64_t isBound;
  void ***Serializer;

  v2 = *this;
  if (!v2)
    return 0;
  Serializer = OZChannelBase::getSerializer((OZChannelBase *)v2);
  PCSpinLock::lock((os_unfair_lock_t)Serializer);
  isBound = ProGL::Private::TextureImpl::isBound(*this);
  PCSpinLock::unlock((os_unfair_lock_t)Serializer);
  return isBound;
}

void sub_1B2C05324(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void ProGL::TextureHandle::texParameter(OZChannelBase **this, ProGL::GL *a2, GLenum a3, GLint a4)
{
  void ***Serializer;

  Serializer = OZChannelBase::getSerializer(*this);
  PCSpinLock::lock((os_unfair_lock_t)Serializer);
  ProGL::Private::TextureImpl::texParameter((ProGL::Private::TextureImpl *)*this, a2, a3, a4);
  PCSpinLock::unlock((os_unfair_lock_t)Serializer);
}

void sub_1B2C053AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void ProGL::TextureHandle::texImage2D(OZChannelBase **this, ProGL::GL *a2, GLenum a3, GLint a4, GLint a5, GLsizei a6, GLsizei a7, GLint a8, GLenum a9, GLenum a10, GLvoid *a11)
{
  void ***Serializer;

  Serializer = OZChannelBase::getSerializer(*this);
  PCSpinLock::lock((os_unfair_lock_t)Serializer);
  ProGL::Private::TextureImpl::texImage2D((ProGL::Private::TextureImpl *)*this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
  PCSpinLock::unlock((os_unfair_lock_t)Serializer);
}

void sub_1B2C0546C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void ProGL::createTexture(ProGL *this@<X0>, _QWORD *a2@<X8>)
{
  ProGL::Private::TextureImpl *v5;
  ProGL::Private::TextureImpl *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _anonymous_namespace_ *v10;
  std::__shared_weak_count *v11;

  v5 = (ProGL::Private::TextureImpl *)operator new();
  ProGL::Private::TextureImpl::TextureImpl(v5, this);
  ProGL::Private::TextureHelper::makeTexture((uint64_t *)&v10, a2);
  v7 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_1B2C0552C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1020C40A7E6A51ELL);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::makeImplPtr(_anonymous_namespace_ *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v5;

  *a2 = this;
  v5 = (_QWORD *)operator new();
  *v5 = &off_1E654B260;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = this;
  a2[1] = v5;
  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a2, this, (uint64_t)this);
}

void sub_1B2C055BC(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  __cxa_rethrow();
}

void sub_1B2C055D0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t *`anonymous namespace'::addTexture(_anonymous_namespace_ *this, ProGL::Private::TextureImpl *a2)
{
  int AlphaOperation;
  PCMutex *v4;
  uint64_t **v5;
  uint64_t *result;
  os_unfair_lock_s *v7;
  _QWORD v8[2];
  PCSharedCount v9;
  char v10;
  int v11;
  uint64_t v12;

  AlphaOperation = HGGLBlendingInfo::GetAlphaOperation(this);
  ProGL::Private::TextureImpl::getContext((uint64_t)this, &v7);
  ProGL::ContextHandle::getShareGroup(&v7, &v9);
  v11 = AlphaOperation;
  ProGL::ShareGroup::ShareGroup(&v12, &v9);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v7);
  v10 = 1;
  LODWORD(v7) = v11;
  ProGL::ShareGroup::ShareGroup(v8, &v12);
  v8[1] = this;
  result = std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__emplace_unique_key_args<std::pair<unsigned int,ProGL::ShareGroup>,std::pair<std::pair<unsigned int,ProGL::ShareGroup> const,ProGL::Private::TextureImpl *>>(v5, (unsigned int *)&v7, (uint64_t)&v7);
  if (v4)
    return (uint64_t *)PCMutex::unlock(v4);
  return result;
}

void sub_1B2C056B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

void ProGL::createExternallyOwnedTexture(ProGL::ContextHandle *a1@<X0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, int a5@<W4>, int a6@<W5>, _QWORD *a7@<X6>, _QWORD *a8@<X8>)
{
  _anonymous_namespace_ *v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;

  v16 = (_anonymous_namespace_ *)operator new();
  ProGL::Private::TextureImpl::TextureImpl((uint64_t)v16, a2, a3, a5, a6, 0, 0, a4, a1, a7);
  ProGL::Private::TextureHelper::makeTexture(&v20, a8);
  v17 = v21;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
}

void sub_1B2C057CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ProGL::findTextureInPool(ProGL *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(ProGL::ContextHandle *);
  BOOL v11;
  int v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(ProGL::ContextHandle *);
  BOOL v17;
  int v18;
  PCMutex *v19;
  uint64_t *v20;
  uint64_t *v21;
  ProGL::Private::TextureImpl *v22;
  unint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  unint64_t v27;
  _QWORD **v28;
  _QWORD *v29;
  BOOL v30;
  char *v31;
  char *v32;
  char *v33;
  std::__shared_weak_count *v34;
  unint64_t *p_shared_owners;
  unint64_t v36;
  _anonymous_namespace_ *v37;
  std::__shared_weak_count *v38;
  PCMutex *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _OWORD v43[2];
  uint64_t *v44;

  v4 = *(_QWORD *)this;
  v5 = *((_QWORD *)this + 1);
  v41 = *(_QWORD *)this;
  v42 = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
    v43[0] = *((_OWORD *)this + 1);
    *(_OWORD *)((char *)v43 + 12) = *(_OWORD *)((char *)this + 28);
    v39 = (PCMutex *)v4;
    v40 = v5;
    do
      v8 = __ldxr(v6);
    while (__stxr(v8 + 1, v6));
  }
  else
  {
    v43[0] = *((_OWORD *)this + 1);
    *(_OWORD *)((char *)v43 + 12) = *(_OWORD *)((char *)this + 28);
    v39 = (PCMutex *)v4;
    v40 = 0;
  }
  v10 = ProGL::ContextHandle::operator void (ProGL::ContextHandle::*)(void)const(&v39);
  if (v9)
    v11 = (v9 & 1 | (unint64_t)v10) == 0;
  else
    v11 = 1;
  v12 = v11;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v39);
  if (!v10 && v12)
  {
    ProGL::getCurrentContext(&v39);
    ProGL::ContextHandle::operator=(&v41, (uint64_t *)&v39);
    LODWORD(v43[0]) = ProGL::ContextHandle::getVirtualScreen((ProGL::ContextHandle *)&v41);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v39);
  }
  v39 = (PCMutex *)v41;
  v40 = v42;
  if (v42)
  {
    v13 = (unint64_t *)(v42 + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v16 = ProGL::ContextHandle::operator void (ProGL::ContextHandle::*)(void)const(&v39);
  if (v15)
    v17 = (v15 & 1 | (unint64_t)v16) == 0;
  else
    v17 = 1;
  v18 = v17;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v39);
  if (!v16 && v18)
  {
    *a2 = 0;
    a2[1] = 0;
    goto LABEL_43;
  }
  LOBYTE(v40) = 1;
  v21 = v20;
  {
    v30 = 0;
    *a2 = 0;
    a2[1] = 0;
    if (!v19)
      goto LABEL_43;
    goto LABEL_41;
  }
  ProGL::Private::TextureHelper::makeTexture((uint64_t *)&v37, a2);
  v44 = v21;
  v25 = (_QWORD *)(v24 + 8 * (v23 >> 9));
  {
    v26 = 0;
    v29 = 0;
  }
  else
  {
    v28 = (_QWORD **)(v24 + 8 * (v27 >> 9));
    v29 = &(*v28)[v27 & 0x1FF];
  }
  v31 = (char *)std::__find_segment_if[abi:ne180100]<std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,std::__find_segment<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>,std::__identity>(v25, v26, v28, v29, &v44);
  v33 = v32;
  v34 = v38;
  if (v38)
  {
    p_shared_owners = (unint64_t *)&v38->__shared_owners_;
    do
      v36 = __ldaxr(p_shared_owners);
    while (__stlxr(v36 - 1, p_shared_owners));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v19 = v39;
  v30 = (_BYTE)v40 == 0;
  if (v39)
  {
LABEL_41:
    if (!v30)
      PCMutex::unlock(v19);
  }
LABEL_43:
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v41);
}

void sub_1B2C05AC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va1);
  _Unwind_Resume(a1);
}

_QWORD *std::multimap<ProGL::TextureDescription,ProGL::Private::TextureImpl *,`anonymous namespace'::CompareTextureDescription,std::allocator<std::pair<ProGL::TextureDescription const,ProGL::Private::TextureImpl *>>>::find[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  int v6;
  _QWORD *v7;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = (_QWORD *)(a1 + 8);
  do
  {
    v7 = v3 + 1;
    if (!v6)
    {
      v7 = v3;
      v5 = v3;
    }
    v3 = (_QWORD *)*v7;
  }
  while (*v7);
    return v2;
  return v5;
}

void ProGL::createTextureFromPool(ProGL *this@<X0>, ProGL::GL *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t (*v10)(ProGL::ContextHandle *);
  uint64_t v11;
  BOOL v12;
  char v13;
  uint64_t v14;
  uint64_t (*v15)(ProGL::ContextHandle *);
  BOOL v16;
  int v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t (*v22)(ProGL::ContextHandle *);
  BOOL v23;
  int v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  int AlphaOperation;
  void (*v35)(_anonymous_namespace_ **);
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  __int128 v39;
  _OWORD v40[2];
  __int128 v41;

  v7 = *((_QWORD *)a2 + 1);
  *(_QWORD *)&v39 = *(_QWORD *)a2;
  *((_QWORD *)&v39 + 1) = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = ProGL::ContextHandle::operator void (ProGL::ContextHandle::*)(void)const(&v39);
  if (v11)
    v12 = (v11 & 1 | (unint64_t)v10) == 0;
  else
    v12 = 1;
  v13 = v12;
  if (v10 || (v13 & 1) == 0)
  {
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v39);
  }
  else
  {
    ProGL::GL::getPGLContextHandle(this, &v41);
    v15 = ProGL::ContextHandle::operator void (ProGL::ContextHandle::*)(void)const(&v41);
    if (v14)
      v16 = (v14 & 1 | (unint64_t)v15) == 0;
    else
      v16 = 1;
    v17 = v16;
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v41);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v39);
    if (!v15 && v17)
    {
      *(_QWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = 0;
      return;
    }
  }
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  v18 = *((_QWORD *)a2 + 1);
  *(_QWORD *)&v39 = *(_QWORD *)a2;
  *((_QWORD *)&v39 + 1) = v18;
  if (v18)
  {
    v19 = (unint64_t *)(v18 + 8);
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  v22 = ProGL::ContextHandle::operator void (ProGL::ContextHandle::*)(void)const(&v39);
  if (v21)
    v23 = (v21 & 1 | (unint64_t)v22) == 0;
  else
    v23 = 1;
  v24 = v23;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v39);
  if (v22 || !v24)
  {
    ProGL::findTextureInPool(a2, &v39);
    std::shared_ptr<TXTextObject>::operator=[abi:ne180100](a3, &v39);
    v31 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
    if (*((_QWORD *)&v39 + 1))
    {
      v32 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
  }
  else
  {
    v25 = *((_QWORD *)a2 + 1);
    *(_QWORD *)&v39 = *(_QWORD *)a2;
    *((_QWORD *)&v39 + 1) = v25;
    if (v25)
    {
      v26 = (unint64_t *)(v25 + 8);
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
    }
    v40[0] = *((_OWORD *)a2 + 1);
    *(_OWORD *)((char *)v40 + 12) = *(_OWORD *)((char *)a2 + 28);
    ProGL::GL::getPGLContextHandle(this, &v41);
    ProGL::ContextHandle::operator=(&v39, (uint64_t *)&v41);
    LODWORD(v40[0]) = ProGL::ContextHandle::getVirtualScreen((ProGL::ContextHandle *)&v39);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v41);
    ProGL::findTextureInPool((ProGL *)&v39, &v41);
    std::shared_ptr<TXTextObject>::operator=[abi:ne180100](a3, &v41);
    v28 = (std::__shared_weak_count *)*((_QWORD *)&v41 + 1);
    if (*((_QWORD *)&v41 + 1))
    {
      v29 = (unint64_t *)(*((_QWORD *)&v41 + 1) + 8);
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v39);
  }
  if (*(_QWORD *)a3)
  {
    AlphaOperation = HGGLBlendingInfo::GetAlphaOperation(*(HGGLBlendingInfo **)a3);
    v35 = ProGL::TextureHandle::detach;
    if (!AlphaOperation)
      v35 = 0;
  }
  else
  {
    v35 = 0;
  }
  if (!v35)
  {
    ProGL::createTexture(this, &v39);
    std::shared_ptr<TXTextObject>::operator=[abi:ne180100](a3, &v39);
    v36 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
    if (*((_QWORD *)&v39 + 1))
    {
      v37 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
    ProGL::TextureHandle::setPooled((OZChannelBase **)a3, 1);
  }
}

void sub_1B2C05E78(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::evictIfNecessary(uint64_t a1, uint64_t a2, ProGL::Private::TextureImpl **a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t **v10;
  uint64_t v11;
  ProGL::Private::TextureImpl *v12;
  ProGL::Private::TextureImpl **v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  ProGL::Private::TextureImpl **v18;
  ProGL::Private::TextureImpl **v19;
  ProGL::Private::TextureImpl *v20;
  ProGL::Private::TextureImpl **__p;
  ProGL::Private::TextureImpl **v22;
  ProGL::Private::TextureImpl **v23;

  {
    return;
  }
  __p = 0;
  v22 = 0;
  v23 = 0;
  while (1)
  {
    {
      goto LABEL_7;
    }
      break;
LABEL_7:
    v6 = (char *)(v5 + 8 * (v4 >> 9));
    v7 = *(_QWORD *)v6 + 8 * (v4 & 0x1FF);
      v8 = 0;
    else
      v8 = v7;
    if (v8 == *(_QWORD *)v6)
    {
      v9 = *((_QWORD *)v6 - 1);
      v6 -= 8;
      v8 = v9 + 4096;
    }
    v11 = *(_QWORD *)(v8 - 8);
    v10 = (uint64_t **)(v8 - 8);
    v12 = *(ProGL::Private::TextureImpl **)(v11 + 80);
    if (v22 >= v23)
    {
      v14 = v22 - __p;
      if ((unint64_t)(v14 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v15 = ((char *)v23 - (char *)__p) >> 2;
      if (v15 <= v14 + 1)
        v15 = v14 + 1;
      if ((unint64_t)((char *)v23 - (char *)__p) >= 0x7FFFFFFFFFFFFFF8)
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v16 = v15;
      if (v16)
        v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v23, v16);
      else
        v17 = 0;
      v18 = (ProGL::Private::TextureImpl **)&v17[8 * v14];
      *v18 = v12;
      v13 = v18 + 1;
      v19 = v22;
      if (v22 != __p)
      {
        do
        {
          v20 = *--v19;
          *--v18 = v20;
        }
        while (v19 != __p);
        v19 = __p;
      }
      __p = v18;
      v23 = (ProGL::Private::TextureImpl **)&v17[8 * v16];
      if (v19)
        operator delete(v19);
    }
    else
    {
      *v22 = v12;
      v13 = v22 + 1;
    }
    v22 = v13;
  }
  ProGL::Private::deleteTextures(__p, v22, a3);
  if (__p)
    operator delete(__p);
}

void sub_1B2C060D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ProGL::clearTexturePool(ProGL *this)
{
  PCMutex *v1;
  _anonymous_namespace_ *v2;

  if (v1)
    PCMutex::unlock(v1);
}

void sub_1B2C0614C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::evictEverything(_anonymous_namespace_ *this)
{
  unint64_t v1;
  ProGL::Private::TextureImpl **v2;
  ProGL::Private::TextureImpl **v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  void **v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *__p;
  ProGL::Private::TextureImpl **v18;

  if (v1)
  {
    std::vector<ProGL::Private::TextureImpl *>::vector(&__p, v1);
    v3 = (ProGL::Private::TextureImpl **)__p;
    {
      do
      {
        *v3++ = (ProGL::Private::TextureImpl *)v5[10];
        v6 = (_QWORD *)v5[1];
        if (v6)
        {
          do
          {
            v7 = v6;
            v6 = (_QWORD *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            v7 = (_QWORD *)v5[2];
            v8 = *v7 == (_QWORD)v5;
            v5 = v7;
          }
          while (!v8);
        }
        v5 = v7;
      }
      while (v7 != (_QWORD *)v4);
      v3 = (ProGL::Private::TextureImpl **)__p;
    }
    ProGL::Private::deleteTextures(v3, v18, v2);
    *v9 = v10;
    v9[2] = 0;
    *v10 = 0;
    v14 = v13 - (_QWORD)v12;
    if (v14 >= 0x11)
    {
      do
      {
        operator delete(*v12);
        v15 = v11[2];
        v12 = (void **)(v11[1] + 8);
        v11[1] = v12;
        v14 = v15 - (_QWORD)v12;
      }
      while (v14 > 0x10);
    }
    if (v14 >> 3 == 1)
    {
      v16 = 256;
    }
    else
    {
      if (v14 >> 3 != 2)
        goto LABEL_17;
      v16 = 512;
    }
    v11[4] = v16;
LABEL_17:
    if (__p)
    {
      v18 = (ProGL::Private::TextureImpl **)__p;
      operator delete(__p);
    }
  }
}

void sub_1B2C06294(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ProGL::Private::initTexturePool(ProGL::Private *this)
{
  PCMutex *v1;
  _QWORD *v2;
  ProGL *v3;
  uint64_t result;

  v1 = (PCMutex *)operator new();
  PCMutex::PCMutex(v1);
  v2 = (_QWORD *)operator new();
  v2[2] = 0;
  v2[1] = 0;
  *v2 = v2 + 1;
  v3 = (ProGL *)operator new();
  *(_OWORD *)v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  result = ProGL::getMaxNumberOfTexturesPerShareGroup(v3);
  return result;
}

void sub_1B2C06388(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1081C4076DFA842);
  _Unwind_Resume(a1);
}

uint64_t ProGL::Private::cleanUpTexturePool(ProGL::Private *this)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v3;

  ProGL::clearTexturePool(this);
  {
    MEMORY[0x1B5E29170](v1, 0x1020C4062D53EE8);
  }
  {
    result = MEMORY[0x1B5E29170](v3, 0x1080C40BE8D5F09);
  }
  return result;
}

CGColorSpace **ProGL::TextureHandle::setColorSpace(CGColorSpace **this, CGColorSpace **a2)
{
  if (*this)
    return PCCFRef<CGColorSpace *>::operator=((CGColorSpace **)*this + 26, a2);
  return this;
}

CGColorSpace **ProGL::TextureHandle::getColorSpace@<X0>(CGColorSpace **this@<X0>, _QWORD *a2@<X8>)
{
  CGColorSpace *v3;
  uint64_t v4;
  CGColorSpace *v5;

  *a2 = 0;
  v3 = *this;
  if (*this)
  {
    v4 = *((_QWORD *)v3 + 26);
    if (v4)
      PCCFRefTraits<CGColorSpace *>::retain(*((CGColorSpaceRef *)v3 + 26));
    *a2 = v4;
    v5 = 0;
    return PCCFRef<CGColorSpace *>::~PCCFRef(&v5);
  }
  return this;
}

void sub_1B2C064A0(_Unwind_Exception *a1)
{
  CGColorSpace **v1;

  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

__n128 ProGL::TextureHandle::setTextureCoords(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  __n128 result;

  v2 = *a1;
  if (*a1)
  {
    result = *(__n128 *)a2;
    *(_OWORD *)(v2 + 232) = *(_OWORD *)(a2 + 16);
    *(__n128 *)(v2 + 216) = result;
  }
  return result;
}

__n128 ProGL::TextureHandle::getTextureCoords@<Q0>(ProGL::TextureHandle *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result;
  uint64_t v7;
  __n128 v8;

  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  a2[1] = result;
  v7 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    result = *(__n128 *)(v7 + 216);
    v8 = *(__n128 *)(v7 + 232);
    *a2 = result;
    a2[1] = v8;
  }
  return result;
}

void std::__tree<std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>,std::__map_value_compare<std::pair<unsigned int,ProGL::Private::TextureImpl *>,std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>,std::less<std::pair<unsigned int,ProGL::Private::TextureImpl *>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>,std::__map_value_compare<std::pair<unsigned int,ProGL::Private::TextureImpl *>,std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>,std::less<std::pair<unsigned int,ProGL::Private::TextureImpl *>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>,std::__map_value_compare<std::pair<unsigned int,ProGL::Private::TextureImpl *>,std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>,std::less<std::pair<unsigned int,ProGL::Private::TextureImpl *>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>>>::destroy(a1, a2[1]);
    ProGL::Private::Any::~Any((ProGL::Private::Any *)(a2 + 6));
    operator delete(a2);
  }
}

uint64_t std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__erase_unique<std::pair<unsigned int,ProGL::ShareGroup>>(uint64_t **a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t *v4;

  v3 = std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::find<std::pair<unsigned int,ProGL::ShareGroup>>((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3)
    return 0;
  v4 = v3;
  std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer(a1, v3);
  operator delete(v4);
  return 1;
}

uint64_t *std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::find<std::pair<unsigned int,ProGL::ShareGroup>>(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  unsigned int v6;

  v3 = (uint64_t *)(a1 + 8);
  v4 = std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__lower_bound<std::pair<unsigned int,ProGL::ShareGroup>>(a1, (unsigned int *)a2, *(uint64_t **)(a1 + 8), (uint64_t *)(a1 + 8));
  if (v3 == v4)
    return v3;
  v5 = v4;
  v6 = *((_DWORD *)v4 + 8);
  if (*(_DWORD *)a2 < v6 || v6 >= *(_DWORD *)a2 && ProGL::operator<((_QWORD *)(a2 + 8), v4 + 5))
    return v3;
  return v5;
}

uint64_t *std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__lower_bound<std::pair<unsigned int,ProGL::ShareGroup>>(uint64_t a1, unsigned int *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *v5;
  _QWORD *v7;
  unsigned int v8;

  if (a3)
  {
    v5 = a3;
    v7 = a2 + 2;
    do
    {
      v8 = *((_DWORD *)v5 + 8);
      if (v8 >= *a2)
      {
        if (*a2 >= v8)
        {
          if (ProGL::operator<(v5 + 5, v7))
            ++v5;
          else
            a4 = v5;
        }
        else
        {
          a4 = v5;
        }
      }
      else
      {
        ++v5;
      }
      v5 = (uint64_t *)*v5;
    }
    while (v5);
  }
  return a4;
}

void `anonymous namespace'::TextureImplDelete::operator()(uint64_t a1)
{
  ProGL::Private::TextureImpl *v2;
  ProGL::Private::TextureImpl **v3;
  PCMutex *v4;
  uint64_t v5;
  const PCString *v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  char v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  uint64_t Description;
  ProGL::Private::TextureImpl *v14;
  ProGL::Private::TextureImpl *v15;
  unint64_t *v16;
  unint64_t v17;
  __int128 v18;
  char *v19;
  uint64_t **v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t *v24;
  uint64_t **v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t Size;
  uint64_t v30;
  ProGL::Private::TextureImpl **v31;
  ProGL::Private::TextureImpl *v32;
  ProGL::Private::TextureImpl *v33[2];
  _BYTE v34[28];
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char v38;
  uint64_t v39[2];
  char v40;

  v32 = (ProGL::Private::TextureImpl *)a1;
  if (ProGL::Private::TextureImpl::isExternallyOwned((ProGL::Private::TextureImpl *)a1))
  {
    goto LABEL_10;
  }
  if (!HGGLBlendingInfo::GetAlphaOperation((HGGLBlendingInfo *)a1))
  {
LABEL_10:
    if (a1)
    {
      std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](a1 + 248);
      PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(a1 + 208));
      std::__tree<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>>>::destroy(a1 + 176, *(_QWORD **)(a1 + 184));
      ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(a1 + 24));
      PCSpinLock::~PCSpinLock((PCSpinLock *)(a1 + 16));
      v11 = *(std::__shared_weak_count **)(a1 + 8);
      if (v11)
        std::__shared_weak_count::__release_weak(v11);
      JUMPOUT(0x1B5E29170);
    }
    return;
  }
  if (!ProGL::Private::TextureImpl::wantsPooling((ProGL::Private::TextureImpl *)a1)
    || !ProGL::Private::TextureImpl::getSize((ProGL::Private::TextureImpl *)a1))
  {
    goto LABEL_32;
  }
  v38 = 1;
        v8 = ProGL::Private::TextureImpl::getDescription((ProGL::Private::TextureImpl *)a1),
  {
    OZChannelBase::setRangeName((OZChannelBase *)a1, v6);
    Description = ProGL::Private::TextureImpl::getDescription((ProGL::Private::TextureImpl *)a1);
    v15 = *(ProGL::Private::TextureImpl **)Description;
    v14 = *(ProGL::Private::TextureImpl **)(Description + 8);
    v33[0] = *(ProGL::Private::TextureImpl **)Description;
    v33[1] = v14;
    if (v14)
    {
      v16 = (unint64_t *)((char *)v14 + 8);
      do
        v17 = __ldxr(v16);
      while (__stxr(v17 + 1, v16));
    }
    v18 = *(_OWORD *)(Description + 16);
    *(_OWORD *)&v34[12] = *(_OWORD *)(Description + 28);
    *(_OWORD *)v34 = v18;
    v35 = a1;
    v19 = (char *)operator new(0x58uLL);
    v20 = (uint64_t **)(v12 + 8);
    v39[0] = (uint64_t)v19;
    v39[1] = v12 + 8;
    *((_QWORD *)v19 + 4) = v15;
    v21 = (uint64_t)(v19 + 32);
    *((_QWORD *)v19 + 5) = v14;
    if (v14)
    {
      v22 = (unint64_t *)((char *)v14 + 8);
      do
        v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }
    *(_OWORD *)(v19 + 60) = *(_OWORD *)&v34[12];
    *((_OWORD *)v19 + 3) = *(_OWORD *)v34;
    *((_QWORD *)v19 + 10) = a1;
    v40 = 1;
    while (1)
    {
      v24 = *v20;
      v25 = v20;
      if (!*v20)
        break;
      while (1)
      {
        v20 = (uint64_t **)v24;
          break;
        v24 = v20[1];
        if (!v24)
        {
          v25 = v20 + 1;
          goto LABEL_25;
        }
      }
    }
LABEL_25:
    v26 = (uint64_t *)v39[0];
    *(_QWORD *)v39[0] = 0;
    v26[1] = 0;
    v26[2] = (uint64_t)v20;
    *v25 = v26;
    v27 = **(_QWORD **)v12;
    if (v27)
    {
      *(_QWORD *)v12 = v27;
      v26 = *v25;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v12 + 8), v26);
    ++*(_QWORD *)(v12 + 16);
    v28 = v39[0];
    v39[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *>>>>::reset[abi:ne180100](v39, 0);
    v36 = v28;
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v33);
    Size = ProGL::Private::TextureImpl::getSize((ProGL::Private::TextureImpl *)a1);
    v4 = (PCMutex *)v37;
    v9 = v38 == 0;
    v10 = 1;
  }
  else
  {
    v9 = 0;
    v10 = 0;
  }
  if (v4 && !v9)
    PCMutex::unlock(v4);
  if ((v10 & 1) == 0)
LABEL_32:
    ProGL::Private::deleteTextures(&v32, v33, v3);
}

void sub_1B2C06988(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<ProGL::Private::TextureImpl *,`anonymous namespace'::TextureImplDelete,std::allocator<ProGL::Private::TextureImpl>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

void std::__shared_ptr_pointer<ProGL::Private::TextureImpl *,`anonymous namespace'::TextureImplDelete,std::allocator<ProGL::Private::TextureImpl>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<ProGL::Private::TextureImpl *,`anonymous namespace'::TextureImplDelete,std::allocator<ProGL::Private::TextureImpl>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

void ProGL::Private::AnyMap_Template<std::pair<unsigned int,ProGL::Private::TextureImpl *>,PCSpinLock>::remove_if<ProGL::Private::PerContextAnyMap<ProGL::Private::TextureImpl *,PCSpinLock>::ContextPred>(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  BOOL v7;
  uint64_t *v8;

  PCSpinLock::lock((os_unfair_lock_t)a1);
  v4 = *(uint64_t **)(a1 + 8);
  if (v4 == (uint64_t *)(a1 + 16))
    goto LABEL_17;
  do
  {
    v5 = (uint64_t *)v4[1];
    if (v4[5] == a2)
    {
      v8 = v4;
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = (uint64_t *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (uint64_t *)v8[2];
          v7 = *v6 == (_QWORD)v8;
          v8 = v6;
        }
        while (!v7);
      }
      std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 8), v4);
      ProGL::Private::Any::~Any((ProGL::Private::Any *)(v4 + 6));
      operator delete(v4);
    }
    else if (v5)
    {
      do
      {
        v6 = v5;
        v5 = (uint64_t *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        v6 = (uint64_t *)v4[2];
        v7 = *v6 == (_QWORD)v4;
        v4 = v6;
      }
      while (!v7);
    }
    v4 = v6;
  }
  while (v6 != (uint64_t *)(a1 + 16));
  if (a1)
LABEL_17:
    PCSpinLock::unlock((os_unfair_lock_t)a1);
}

void std::deque<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>::push_front(uint64_t a1, _QWORD *a2)
{
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = *(_QWORD *)(a1 + 32);
  if (!v4)
  {
    std::deque<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>::__add_front_capacity((void **)a1);
    v4 = *(_QWORD *)(a1 + 32);
  }
  v5 = *(_QWORD *)(a1 + 8);
  v6 = (_QWORD *)(v5 + 8 * (v4 >> 9));
  if (*(_QWORD *)(a1 + 16) == v5)
    v7 = 0;
  else
    v7 = *v6 + 8 * (v4 & 0x1FF);
  if (v7 == *v6)
    v7 = *(v6 - 1) + 4096;
  *(_QWORD *)(v7 - 8) = *a2;
  v8 = *(_QWORD *)(a1 + 40) + 1;
  *(_QWORD *)(a1 + 32) = v4 - 1;
  *(_QWORD *)(a1 + 40) = v8;
}

uint64_t `anonymous namespace'::CompareTextureDescription::operator()(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;
  os_unfair_lock_s *v18;
  unint64_t *p_os_unfair_lock_opaque;
  unint64_t v20;
  os_unfair_lock_s *v21;
  unint64_t *v22;
  unint64_t v23;
  _BOOL8 v24;
  os_unfair_lock_s *v25[2];
  PCSharedCount v26;
  os_unfair_lock_s *v27[2];
  PCSharedCount v28;

  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(a2 + 24);
  if (v2 < v3)
    return 1;
  if (v2 > v3)
    return 0;
  v5 = *(_DWORD *)(a1 + 28);
  v6 = *(_DWORD *)(a2 + 28);
  if (v5 < v6)
    return 1;
  if (v5 > v6)
    return 0;
  v7 = *(_DWORD *)(a1 + 32);
  v8 = *(_DWORD *)(a2 + 32);
  if (v7 < v8)
    return 1;
  if (v7 > v8)
    return 0;
  v9 = *(_DWORD *)(a1 + 36);
  v10 = *(_DWORD *)(a2 + 36);
  if (v9 < v10)
    return 1;
  if (v9 > v10)
    return 0;
  v11 = *(_DWORD *)(a1 + 40);
  v12 = *(_DWORD *)(a2 + 40);
  if (v11 < v12)
    return 1;
  if (v11 > v12)
    return 0;
  v13 = *(_DWORD *)(a1 + 20);
  v14 = *(_DWORD *)(a2 + 20);
  if (v13 < v14)
    return 1;
  if (v13 > v14)
    return 0;
  v15 = *(_DWORD *)(a1 + 16);
  v16 = *(_DWORD *)(a2 + 16);
  if (v15 < v16)
    return 1;
  if (v15 > v16)
    return 0;
  v18 = *(os_unfair_lock_s **)(a1 + 8);
  v27[0] = *(os_unfair_lock_s **)a1;
  v27[1] = v18;
  if (v18)
  {
    p_os_unfair_lock_opaque = (unint64_t *)&v18[2]._os_unfair_lock_opaque;
    do
      v20 = __ldxr(p_os_unfair_lock_opaque);
    while (__stxr(v20 + 1, p_os_unfair_lock_opaque));
  }
  ProGL::ContextHandle::getShareGroup(v27, &v28);
  v21 = *(os_unfair_lock_s **)(a2 + 8);
  v25[0] = *(os_unfair_lock_s **)a2;
  v25[1] = v21;
  if (v21)
  {
    v22 = (unint64_t *)&v21[2]._os_unfair_lock_opaque;
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }
  ProGL::ContextHandle::getShareGroup(v25, &v26);
  v24 = ProGL::operator<(&v28, &v26);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v25);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v27);
  return v24;
}

void sub_1B2C06CF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *>>>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    if (*((_BYTE *)a1 + 16))
      ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(v2 + 32));
    operator delete((void *)v2);
  }
}

void std::deque<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>::__add_front_capacity(void **a1)
{
  _BYTE *v2;
  _BYTE *v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  int64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  int64_t v21;
  char *v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  char *v33;
  _QWORD *v34;
  uint64_t v35;
  void *v36;
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  void *v41;
  void *__p;
  char *v43;
  char *v44;
  char *v45;
  _QWORD *v46;

  v2 = a1[1];
  v3 = a1[2];
  v4 = v3 - v2;
  if (v3 == v2)
    v5 = 0;
  else
    v5 = ((v3 - v2) << 6) - 1;
  v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(_QWORD)a1[5]] < 0x200)
  {
    v7 = (uint64_t)(a1 + 3);
    v8 = a1[3];
    v9 = *a1;
    v10 = v8 - (_BYTE *)*a1;
    if (v4 >= v10)
    {
      if (v8 == v9)
        v11 = 1;
      else
        v11 = v10 >> 2;
      v46 = a1 + 3;
      __p = std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v7, v11);
      v43 = (char *)__p;
      v44 = (char *)__p;
      v45 = (char *)__p + 8 * v12;
      v41 = operator new(0x1000uLL);
      std::__split_buffer<unsigned long *>::push_back(&__p, &v41);
      v13 = (char *)a1[1];
      v14 = v44;
      if (v13 == a1[2])
      {
        v33 = (char *)a1[1];
      }
      else
      {
        do
        {
          if (v14 == v45)
          {
            v15 = v43 - (_BYTE *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p)
                v23 = 1;
              else
                v23 = (v14 - (_BYTE *)__p) >> 2;
              v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v46, v23);
              v26 = v43;
              v14 = &v24[8 * (v23 >> 2)];
              v27 = v44 - v43;
              if (v44 != v43)
              {
                v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8)];
                v28 = 8 * (v27 >> 3);
                v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  v30 = *(_QWORD *)v26;
                  v26 += 8;
                  *(_QWORD *)v29 = v30;
                  v29 += 8;
                  v28 -= 8;
                }
                while (v28);
              }
              v31 = __p;
              __p = v24;
              v43 = &v24[8 * (v23 >> 2)];
              v44 = v14;
              v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                v14 = v44;
              }
            }
            else
            {
              v16 = v15 >> 3;
              v17 = v15 >> 3 < -1;
              v18 = (v15 >> 3) + 2;
              if (v17)
                v19 = v18;
              else
                v19 = v16 + 1;
              v20 = &v43[-8 * (v19 >> 1)];
              v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                v14 = v43;
              }
              v22 = &v14[-8 * (v19 >> 1)];
              v14 = &v20[v21];
              v43 = v22;
              v44 = &v20[v21];
            }
          }
          v32 = *(_QWORD *)v13;
          v13 += 8;
          *(_QWORD *)v14 = v32;
          v14 = v44 + 8;
          v44 += 8;
        }
        while (v13 != a1[2]);
        v33 = (char *)a1[1];
      }
      v36 = *a1;
      v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      __p = v36;
      v43 = v33;
      v38 = (char *)a1[3];
      v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      v44 = v13;
      v45 = v38;
      if (v14 - v37 == 8)
        v40 = 256;
      else
        v40 = (uint64_t)a1[4] + 512;
      a1[4] = (void *)v40;
      if (v13 != v33)
        v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8];
      if (v36)
        operator delete(v36);
    }
    else
    {
      if (v2 == v9)
      {
        __p = operator new(0x1000uLL);
        std::__split_buffer<unsigned long *>::push_back(a1, &__p);
        v34 = a1[2];
        __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }
      else
      {
        __p = operator new(0x1000uLL);
      }
      std::__split_buffer<unsigned long *>::push_front((uint64_t)a1, &__p);
      if ((_BYTE *)a1[2] - (_BYTE *)a1[1] == 8)
        v35 = 256;
      else
        v35 = (uint64_t)a1[4] + 512;
      a1[4] = (void *)v35;
    }
  }
  else
  {
    a1[4] = v6 + 512;
    __p = (void *)*((_QWORD *)v3 - 1);
    a1[2] = v3 - 8;
    std::__split_buffer<unsigned long *>::push_front((uint64_t)a1, &__p);
  }
}

void sub_1B2C0701C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  void *v12;

  operator delete(v12);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__emplace_unique_key_args<std::pair<unsigned int,ProGL::ShareGroup>,std::pair<std::pair<unsigned int,ProGL::ShareGroup> const,ProGL::Private::TextureImpl *>>(uint64_t **a1, unsigned int *a2, uint64_t a3)
{
  uint64_t **v5;
  uint64_t *result;
  uint64_t *v7;
  uint64_t v8;

  v5 = (uint64_t **)std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__find_equal<std::pair<unsigned int,ProGL::ShareGroup>>((uint64_t)a1, &v8, a2);
  result = *v5;
  if (!*v5)
  {
    std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__construct_node<std::pair<std::pair<unsigned int,ProGL::ShareGroup> const,ProGL::Private::TextureImpl *>>((uint64_t)a1, a3, (uint64_t)&v7);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v8, v5, v7);
    return v7;
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__find_equal<std::pair<unsigned int,ProGL::ShareGroup>>(uint64_t a1, _QWORD *a2, unsigned int *a3)
{
  uint64_t *v4;
  uint64_t *v5;
  _QWORD *v7;
  uint64_t *v8;
  unsigned int v9;
  unsigned int v10;

  v5 = (uint64_t *)(a1 + 8);
  v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    v7 = a3 + 2;
    while (1)
    {
      while (1)
      {
        v8 = v4;
        v9 = *a3;
        v10 = *((_DWORD *)v4 + 8);
        if (*a3 >= v10)
          break;
LABEL_6:
        v4 = (uint64_t *)*v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_15;
      }
      if (v10 >= v9)
      {
        if (ProGL::operator<(v7, v8 + 5))
          goto LABEL_6;
        v10 = *((_DWORD *)v8 + 8);
        v9 = *a3;
      }
      if (v10 < v9 || v9 >= v10 && ProGL::operator<(v8 + 5, v7))
      {
        v5 = v8 + 1;
        v4 = (uint64_t *)v8[1];
        if (v4)
          continue;
      }
      goto LABEL_15;
    }
  }
  v8 = (uint64_t *)(a1 + 8);
LABEL_15:
  *a2 = v8;
  return v5;
}

_QWORD *std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__construct_node<std::pair<std::pair<unsigned int,ProGL::ShareGroup> const,ProGL::Private::TextureImpl *>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _DWORD *v6;
  _QWORD *result;

  v5 = a1 + 8;
  v6 = operator new(0x38uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v6[8] = *(_DWORD *)a2;
  result = ProGL::ShareGroup::ShareGroup((_QWORD *)v6 + 5, (_QWORD *)(a2 + 8));
  *((_QWORD *)v6 + 6) = *(_QWORD *)(a2 + 16);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1B2C07208(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;

  *v1 = 0;
  operator delete(v2);
  _Unwind_Resume(a1);
}

_QWORD *std::deque<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>::erase(int64x2_t *a1, char *a2, char *a3)
{
  uint64_t v4;
  char *v5;
  char *v6;
  unint64_t v7;
  char **v8;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char **v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char **v21;
  char *v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char **v26;
  char *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char **v32;
  char *v33;
  __n128 v34[2];

  v4 = a1->i64[1];
  v5 = (char *)(v4 + 8 * ((unint64_t)a1[2].i64[0] >> 9));
  if (a1[1].i64[0] == v4)
    v6 = 0;
  else
    v6 = (char *)(*(_QWORD *)v5 + 8 * (a1[2].i64[0] & 0x1FF));
  v32 = (char **)(v4 + 8 * ((unint64_t)a1[2].i64[0] >> 9));
  v33 = v6;
  if (v6 == a3)
    v7 = 0;
  else
    v7 = ((uint64_t)&a3[-*(_QWORD *)a2] >> 3) + ((a2 - v5) << 6) - ((uint64_t)&v6[-*(_QWORD *)v5] >> 3);
  v8 = (char **)std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>::operator+[abi:ne180100]((uint64_t)&v32, v7);
  v10 = (unint64_t)v8;
  v11 = (unint64_t)v9;
  v12 = a1[2].i64[1];
  if (v7 <= (unint64_t)(v12 - 1) >> 1)
  {
    v18 = v9 - *v8;
    v19 = v18 >> 3;
    if (v18 < -7)
    {
      v28 = 510 - v19;
      v21 = &v8[-(v28 >> 9)];
      v22 = &(*v21)[8 * (~(_WORD)v28 & 0x1FF)];
    }
    else
    {
      v20 = v19 + 1;
      v21 = &v8[v20 >> 9];
      v22 = &(*v21)[8 * (v20 & 0x1FF)];
    }
    std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,0>(v32, v33, v8, v9, v21, v22, v34);
    a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_1B304F0B0);
    std::deque<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)a1, 1);
  }
  else
  {
    v13 = v9 - *v8;
    v14 = v13 >> 3;
    if (v13 < -7)
    {
      v23 = 510 - v14;
      v16 = &v8[-(v23 >> 9)];
      v17 = &(*v16)[8 * (~(_WORD)v23 & 0x1FF)];
    }
    else
    {
      v15 = v14 + 1;
      v16 = &v8[v15 >> 9];
      v17 = &(*v16)[8 * (v15 & 0x1FF)];
    }
    v24 = a1[2].i64[0] + v12;
    v25 = a1->i64[1];
    v26 = (char **)(v25 + 8 * (v24 >> 9));
    if (a1[1].i64[0] == v25)
      v27 = 0;
    else
      v27 = &(*v26)[8 * (v24 & 0x1FF)];
    v34[0].n128_u64[0] = v10;
    v34[0].n128_u64[1] = v11;
    std::__for_each_segment[abi:ne180100]<std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>>>(v16, v17, v26, v27, (uint64_t)v34);
    --a1[2].i64[1];
    std::deque<unsigned long>::__maybe_remove_back_spare[abi:ne180100](a1, 1);
  }
  v29 = a1->i64[1];
  if (a1[1].i64[0] == v29)
    v30 = 0;
  else
    v30 = *(_QWORD *)(v29 + 8 * ((unint64_t)a1[2].i64[0] >> 9)) + 8 * (a1[2].i64[0] & 0x1FF);
  v34[0].n128_u64[0] = v29 + 8 * ((unint64_t)a1[2].i64[0] >> 9);
  v34[0].n128_u64[1] = v30;
  return std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>::operator+[abi:ne180100]((uint64_t)v34, v7);
}

void std::multimap<ProGL::TextureDescription,ProGL::Private::TextureImpl *,`anonymous namespace'::CompareTextureDescription,std::allocator<std::pair<ProGL::TextureDescription const,ProGL::Private::TextureImpl *>>>::erase[abi:ne180100](uint64_t **a1, uint64_t *a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  BOOL v6;
  uint64_t *v7;

  v3 = (uint64_t *)a2[1];
  if (v3)
  {
    do
    {
      v4 = v3;
      v3 = (uint64_t *)*v3;
    }
    while (v3);
  }
  else
  {
    v5 = a2;
    do
    {
      v4 = (uint64_t *)v5[2];
      v6 = *v4 == (_QWORD)v5;
      v5 = v4;
    }
    while (!v6);
  }
  if (*a1 == a2)
    *a1 = v4;
  v7 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v7, a2);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(a2 + 4));
  operator delete(a2);
}

_QWORD *std::__find_segment_if[abi:ne180100]<std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,std::__find_segment<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>,std::__identity>(_QWORD *result, _QWORD *a2, _QWORD **a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;

  if (result == a3)
  {
    if (a2 != a4)
    {
      while (*a2 != *a5)
      {
        if (++a2 == a4)
        {
          a2 = a4;
          break;
        }
      }
    }
    if (result && (_QWORD *)(*result + 4096) == a2)
      ++result;
  }
  else
  {
    v5 = *result + 4096;
    if ((_QWORD *)v5 == a2)
      goto LABEL_14;
    while (*a2 != *a5)
    {
      if (++a2 == (_QWORD *)v5)
        goto LABEL_14;
    }
    if (a2 == (_QWORD *)v5)
    {
LABEL_14:
      v6 = result + 1;
      if (result + 1 == a3)
      {
        v8 = result;
      }
      else
      {
        do
        {
          v7 = 0;
          v8 = v6;
          v9 = *v6;
          do
          {
            if (*(_QWORD *)(v9 + v7) == *a5)
              return v8;
            v7 += 8;
          }
          while (v7 != 4096);
          v6 = v8 + 1;
        }
        while (v8 + 1 != a3);
      }
      if (*a3 == a4)
      {
        return a3;
      }
      else
      {
        v10 = *a3;
        while (*v10 != *a5)
        {
          if (++v10 == a4)
          {
            v10 = a4;
            break;
          }
        }
        result = a3;
        if (*a3 + 512 == v10)
          return v8 + 2;
      }
    }
  }
  return result;
}

_QWORD *std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>::operator+[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  uint64_t v4;

  result = *(_QWORD **)a1;
  if (a2)
  {
    v4 = a2 + ((uint64_t)(*(_QWORD *)(a1 + 8) - *result) >> 3);
    if (v4 < 1)
      result -= (unint64_t)(511 - v4) >> 9;
    else
      result += (unint64_t)v4 >> 9;
  }
  return result;
}

uint64_t std::deque<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>::__maybe_remove_front_spare[abi:ne180100](uint64_t a1, int a2)
{
  unint64_t v2;
  int v4;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2 < 0x200)
    a2 = 1;
  if (v2 < 0x400)
    v4 = a2;
  else
    v4 = 0;
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(_QWORD *)(a1 + 8) += 8;
    *(_QWORD *)(a1 + 32) -= 512;
  }
  return v4 ^ 1u;
}

__n128 std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,0>@<Q0>(char **a1@<X1>, char *a2@<X2>, char **a3@<X3>, char *a4@<X4>, _QWORD *a5@<X5>, char *a6@<X6>, __n128 *a7@<X8>)
{
  char *v12;
  char **v13;
  char *v14;
  _QWORD *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  __n128 result;
  uint64_t v21;
  __n128 v22;

  if (a1 == a3)
  {
    v19 = a2;
    v18 = a4;
    v15 = a5;
    v16 = a6;
  }
  else
  {
    v13 = a3 - 1;
    v12 = *a3;
    v14 = a4;
    v15 = a5;
    v16 = a6;
    while (1)
    {
      std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> **,long,512l>,0>(v12, v14, v15, v16, &v21);
      v16 = (char *)v22.n128_u64[1];
      v15 = (_QWORD *)v22.n128_u64[0];
      if (v13 == a1)
        break;
      v17 = *v13--;
      v12 = v17;
      v14 = v17 + 4096;
    }
    v18 = *a1 + 4096;
    v19 = a2;
  }
  std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> **,long,512l>,0>(v19, v18, v15, v16, &v21);
  result = v22;
  a7->n128_u64[0] = (unint64_t)a3;
  a7->n128_u64[1] = (unint64_t)a4;
  a7[1] = result;
  return result;
}

void *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> **,long,512l>,0>@<X0>(char *a1@<X1>, char *a2@<X2>, _QWORD *a3@<X3>, char *a4@<X4>, _QWORD *a5@<X8>)
{
  _QWORD *v6;
  char *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  void *result;
  uint64_t v15;
  char *v16;

  v6 = a3;
  if (a1 == a2)
  {
    v9 = a1;
  }
  else
  {
    v9 = a2;
    v10 = *a3;
    v11 = a2;
    while (1)
    {
      v12 = (uint64_t)&a4[-v10];
      if ((v11 - a1) >> 3 >= v12 >> 3)
        v13 = v12 >> 3;
      else
        v13 = (v11 - a1) >> 3;
      v11 -= 8 * v13;
      a4 -= 8 * v13;
      if (v13)
        result = memmove(a4, v11, 8 * v13);
      if (v11 == a1)
        break;
      v15 = *--v6;
      v10 = v15;
      a4 = (char *)(v15 + 4096);
    }
    if ((char *)(*v6 + 4096) == a4)
    {
      v16 = (char *)v6[1];
      ++v6;
      a4 = v16;
    }
  }
  *a5 = v9;
  a5[1] = v6;
  a5[2] = a4;
  return result;
}

double std::__for_each_segment[abi:ne180100]<std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>>>(char **a1, char *__src, char **a3, char *a4, uint64_t a5)
{
  char **v8;
  char *v9;
  char *v10;
  void **v11;
  char *v12;
  double result;
  char *v14;
  __int128 v15;

  if (a1 == a3)
  {
    v11 = *(void ***)a5;
    v12 = *(char **)(a5 + 8);
    v10 = __src;
  }
  else
  {
    v8 = a1 + 1;
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> **,long,512l>,0>(__src, *(char **)(a5 + 8), *a1 + 4096, *(void ***)a5, &v14);
    for (*(_OWORD *)a5 = v15; v8 != a3; *(_OWORD *)a5 = v15)
    {
      v9 = *v8++;
      std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> **,long,512l>,0>(v9, *(char **)(a5 + 8), v9 + 4096, *(void ***)a5, &v14);
    }
    v10 = *a3;
    v11 = *(void ***)a5;
    v12 = *(char **)(a5 + 8);
  }
  std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> **,long,512l>,0>(v10, v12, a4, v11, &v14);
  result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

char *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> **,long,512l>,0>@<X0>(char *__src@<X0>, char *__dst@<X3>, char *a3@<X1>, void **a4@<X2>, char **a5@<X8>)
{
  void **v6;
  char *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;

  v6 = a4;
  if (__src != a3)
  {
    v9 = __src;
    v6 = a4 + 1;
    v10 = (char *)*a4;
    while (1)
    {
      v11 = v10 - __dst + 4096;
      v12 = (a3 - v9) >> 3 >= v11 >> 3 ? v11 >> 3 : (a3 - v9) >> 3;
      if (v12)
        __src = (char *)memmove(__dst, v9, 8 * v12);
      v9 += 8 * v12;
      if (v9 == a3)
        break;
      v13 = (char *)*v6++;
      v10 = v13;
      __dst = v13;
    }
    __dst += 8 * v12;
    if ((char *)*(v6 - 1) + 4096 == __dst)
      __dst = (char *)*v6;
    else
      --v6;
  }
  *a5 = a3;
  a5[1] = (char *)v6;
  a5[2] = __dst;
  return __src;
}

_QWORD *std::vector<ProGL::Private::TextureImpl *>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<double>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1B2C07A14(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__tree<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__map_value_compare<ProGL::TextureDescription,std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,`anonymous namespace'::CompareTextureDescription,true>,std::allocator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(a1 + 4));
    operator delete(a1);
  }
}

ProGL::Private::TextureImpl *ProGL::Private::TextureImpl::TextureImpl(ProGL::Private::TextureImpl *this, ProGL::GL *a2)
{
  _QWORD v9[2];

  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  ProGL::GL::getPGLContextHandle(a2, v9);
  ProGL::TextureDescription::TextureDescription((ProGL::Private::TextureImpl *)((char *)this + 24), (const ProGL::ContextHandle *)v9);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v9);
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_QWORD *)this + 13) = 0x260100000000;
  *((_QWORD *)this + 14) = 0xC47A00003F800000;
  *((_DWORD *)this + 30) = 1148846080;
  *(_QWORD *)((char *)this + 124) = 0x3E800000000;
  *((_DWORD *)this + 33) = 0;
  *((_QWORD *)this + 17) = 6409;
  *((_DWORD *)this + 36) = 515;
  *((_BYTE *)this + 148) = 0;
  *((_DWORD *)this + 38) = 1065353216;
  *((_BYTE *)this + 160) = 0;
  *((_DWORD *)this + 41) = 1;
  *((_BYTE *)this + 168) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 22) = (char *)this + 184;
  *((_QWORD *)this + 24) = 0;
  *((_WORD *)this + 100) = 0;
  *((_BYTE *)this + 202) = 0;
  *((_QWORD *)this + 31) = 0;
  *(_QWORD *)((char *)this + 212) = 0;
  *(_QWORD *)((char *)this + 204) = 0;
  *((_DWORD *)this + 57) = 0;
  *(_QWORD *)((char *)this + 220) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)((char *)this + 232) = _Q0;
  *((_QWORD *)this + 32) = 0;
  glGenTextures(1, (GLuint *)this + 5);
  return this;
}

void sub_1B2C07B98(_Unwind_Exception *a1)
{
  uint64_t v1;
  PCSpinLock *v2;
  ProGL::ContextHandle *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v8;

  v6 = v4;
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v5);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v1 + 208));
  std::__tree<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>>>::destroy(v6, *(_QWORD **)(v1 + 184));
  ProGL::ContextHandle::~ContextHandle(v3);
  PCSpinLock::~PCSpinLock(v2);
  v8 = *(std::__shared_weak_count **)(v1 + 8);
  if (v8)
    std::__shared_weak_count::__release_weak(v8);
  _Unwind_Resume(a1);
}

uint64_t ProGL::Private::TextureImpl::TextureImpl(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, ProGL::ContextHandle *a9, _QWORD *a10)
{
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = a2;
  ProGL::TextureDescription::TextureDescription((ProGL::TextureDescription *)(a1 + 24), a9);
  *(_QWORD *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_QWORD *)(a1 + 104) = 0x260100000000;
  *(_QWORD *)(a1 + 112) = 0xC47A00003F800000;
  *(_DWORD *)(a1 + 120) = 1148846080;
  *(_QWORD *)(a1 + 124) = 0x3E800000000;
  *(_DWORD *)(a1 + 132) = 0;
  *(_QWORD *)(a1 + 136) = 6409;
  *(_DWORD *)(a1 + 144) = 515;
  *(_BYTE *)(a1 + 148) = 0;
  *(_DWORD *)(a1 + 152) = 1065353216;
  *(_BYTE *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 164) = 1;
  *(_BYTE *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 176) = a1 + 184;
  *(_WORD *)(a1 + 200) = 0;
  *(_BYTE *)(a1 + 202) = 0;
  *(_QWORD *)(a1 + 212) = 0;
  *(_QWORD *)(a1 + 204) = 0;
  *(_DWORD *)(a1 + 228) = 0;
  *(_QWORD *)(a1 + 220) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 232) = _Q0;
  v22 = a10[1];
  *(_QWORD *)(a1 + 248) = *a10;
  *(_QWORD *)(a1 + 256) = v22;
  if (v22)
  {
    v23 = (unint64_t *)(v22 + 8);
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  *(_DWORD *)(a1 + 44) = a3;
  *(_DWORD *)(a1 + 48) = a4;
  *(_DWORD *)(a1 + 52) = a5;
  *(_DWORD *)(a1 + 56) = a6;
  *(_DWORD *)(a1 + 60) = a7;
  *(_DWORD *)(a1 + 64) = a8;
  *(_DWORD *)(a1 + 72) = a8;
  return a1;
}

{
  return ProGL::Private::TextureImpl::TextureImpl(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

void sub_1B2C07D28(_Unwind_Exception *a1)
{
  uint64_t v1;
  std::__shared_weak_count *v3;

  PCSpinLock::~PCSpinLock((PCSpinLock *)(v1 + 16));
  v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  _Unwind_Resume(a1);
}

uint64_t ProGL::Private::TextureImpl::getContext@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 32);
  *a2 = *(_QWORD *)(this + 24);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

BOOL ProGL::Private::TextureImpl::isExternallyOwned(ProGL::Private::TextureImpl *this)
{
  return *((_QWORD *)this + 31) != 0;
}

uint64_t ProGL::Private::TextureImpl::getTarget(ProGL::Private::TextureImpl *this)
{
  return *((unsigned int *)this + 11);
}

uint64_t ProGL::Private::TextureImpl::getWidth(ProGL::Private::TextureImpl *this)
{
  return *((unsigned int *)this + 12);
}

uint64_t ProGL::Private::TextureImpl::getHeight(ProGL::Private::TextureImpl *this)
{
  return *((unsigned int *)this + 13);
}

uint64_t ProGL::Private::TextureImpl::getBorder(ProGL::Private::TextureImpl *this)
{
  return *((unsigned int *)this + 15);
}

uint64_t ProGL::Private::TextureImpl::getActualInternalFormat(ProGL::Private::TextureImpl *this)
{
  return *((unsigned int *)this + 18);
}

unint64_t ProGL::Private::TextureImpl::getSize(ProGL::Private::TextureImpl *this)
{
  uint64_t v1;
  unsigned int v2;
  uint64_t v3;
  unint64_t v4;

  v1 = *((int *)this + 51);
  if (!(_DWORD)v1)
  {
    v2 = *((_DWORD *)this + 13);
    if (v2 <= 0x80)
      v2 = 128;
    v3 = 6;
    if (*((_DWORD *)this + 11) != 34067)
      v3 = 1;
    v4 = ((*((int *)this + 12) + 127) & 0xFFFFFFFFFFFFFF80) * (int)v2 * *((int *)this + 14) * v3;
    if (*((_BYTE *)this + 201)
      || ProGL::Private::TextureParameters::getGenerateMipmap((ProGL::Private::TextureImpl *)((char *)this + 76)))
    {
      return 16 * v4 / 3;
    }
    else
    {
      return 4 * v4;
    }
  }
  return v1;
}

uint64_t ProGL::Private::TextureImpl::wantsPooling(ProGL::Private::TextureImpl *this)
{
  return *((unsigned __int8 *)this + 200);
}

uint64_t ProGL::Private::TextureImpl::setPooled(uint64_t this, char a2)
{
  if (!*(_QWORD *)(this + 248))
    *(_BYTE *)(this + 200) = a2;
  return this;
}

uint64_t ProGL::Private::TextureImpl::getDescription(ProGL::Private::TextureImpl *this)
{
  return (uint64_t)this + 24;
}

void ProGL::Private::TextureImpl::detach(ProGL::Private::TextureImpl *this)
{
  _QWORD *v2;
  _QWORD *v3;

  if (*((_DWORD *)this + 5))
  {
    *((_DWORD *)this + 5) = 0;
    ProGL::TextureDescription::reset((ProGL::Private::TextureImpl *)((char *)this + 24));
    *((_DWORD *)this + 18) = 0;
    ProGL::Private::TextureParameters::reset((ProGL::Private::TextureImpl *)((char *)this + 76));
    *((_BYTE *)this + 168) = 0;
    *((_BYTE *)this + 200) = 0;
    if (!*((_QWORD *)this + 31))
    {
      v3 = (_QWORD *)*((_QWORD *)this + 23);
      v2 = (_QWORD *)((char *)this + 184);
      std::__tree<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>>>::destroy((uint64_t)(v2 - 1), v3);
      *(v2 - 1) = v2;
      *v2 = 0;
      v2[1] = 0;
    }
  }
}

void ProGL::Private::TextureImpl::bind(ProGL::Private::TextureImpl *this, ProGL::GL *a2, GLenum target)
{
  ProGL::Private::TextureParameters::bind((ProGL::Private::TextureImpl *)((char *)this + 76), *((_DWORD *)this + 5), a2, target);
  *((_DWORD *)this + 11) = target;
}

void ProGL::Private::TextureImpl::unbind(ProGL::Private::TextureImpl *this, ProGL::GL *a2)
{
  ProGL::Private::TextureParameters::unbind((ProGL::Private::TextureImpl *)((char *)this + 76), a2, *((_DWORD *)this + 11));
}

uint64_t ProGL::Private::TextureImpl::isBound(ProGL::Private::TextureImpl *this)
{
  return ProGL::Private::TextureParameters::isBound((ProGL::Private::TextureImpl *)((char *)this + 76));
}

void ProGL::Private::TextureImpl::texParameter(ProGL::Private::TextureImpl *this, ProGL::GL *a2, GLenum a3, GLint param)
{
  _QWORD *v7;
  int v8;
  uint64_t *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  const char *v15;
  uint64_t v16;
  char v17;

  switch(a3)
  {
    case 0x2800u:
      ProGL::Private::TextureParameters::setMagFilter((ProGL::Private::TextureImpl *)((char *)this + 76), a2, *((_DWORD *)this + 11), param);
      break;
    case 0x2801u:
      ProGL::Private::TextureParameters::setMinFilter((ProGL::Private::TextureImpl *)((char *)this + 76), a2, *((_DWORD *)this + 11), param);
      break;
    case 0x2802u:
      ProGL::Private::TextureParameters::setWrapS((ProGL::Private::TextureImpl *)((char *)this + 76), a2, *((_DWORD *)this + 11), param);
      break;
    case 0x2803u:
      ProGL::Private::TextureParameters::setWrapT((ProGL::Private::TextureImpl *)((char *)this + 76), a2, *((_DWORD *)this + 11), param);
      break;
    default:
      if (a3 == 34046)
      {
        ProGL::Private::TextureParameters::setMaxAnisotropy((GLfloat *)this + 19, a2, *((_DWORD *)this + 11), (float)param);
      }
      else
      {
        v7 = (_QWORD *)MEMORY[0x1E0DE4A60];
        v8 = *(_DWORD *)(MEMORY[0x1E0DE4A60] + *(_QWORD *)(*MEMORY[0x1E0DE4A60] - 24) + 8);
        v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)"ProGL::TextureHandle::texParameter(): unknown parameter passed (", 64);
        v10 = *v9;
        *(_DWORD *)((char *)v9 + *(_QWORD *)(*v9 - 24) + 8) = *(_DWORD *)((_BYTE *)v9 + *(_QWORD *)(*v9 - 24) + 8) & 0xFFFFFFB5 | 8;
        *(_DWORD *)((char *)v9 + *(_QWORD *)(v10 - 24) + 8) |= 0x4000u;
        v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"0x", 2);
        v17 = 48;
        v12 = std::operator<<[abi:ne180100]<std::char_traits<char>>(v11, &v17);
        *(_QWORD *)((char *)v12 + *(_QWORD *)(*v12 - 24) + 24) = 4;
        v13 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"), not saved in parameter state, ", 33);
        if (ProGL::Private::TextureParameters::isBound((ProGL::Private::TextureImpl *)((char *)this + 76)))
        {
          glTexParameteri(*((_DWORD *)this + 11), a3, param);
          v14 = (_QWORD *)MEMORY[0x1E0DE4A60];
          v15 = "just passed on to OpenGL.\n";
          v16 = 26;
        }
        else
        {
          v14 = (_QWORD *)MEMORY[0x1E0DE4A60];
          v15 = "just discarded.\n";
          v16 = 16;
        }
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)v15, v16);
        *(_DWORD *)((char *)v7 + *(_QWORD *)(*v7 - 24) + 8) = v8;
      }
      break;
  }
}

void ProGL::Private::TextureImpl::texImage2D(ProGL::Private::TextureImpl *this, ProGL::GL *a2, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum a9, GLenum a10, GLvoid *pixels)
{
  GLenum v18;
  _QWORD v19[2];

  if (!*((_QWORD *)this + 31))
  {
    if (target - 34069 >= 6)
      v18 = target;
    else
      v18 = 34067;
    glTexImage2D(target, level, internalformat, width, height, border, a9, a10, pixels);
    *((_DWORD *)this + 11) = v18;
    ProGL::GL::getPGLContextHandle(a2, v19);
    *((_DWORD *)this + 10) = ProGL::ContextHandle::getVirtualScreen((ProGL::ContextHandle *)v19);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v19);
    *((_DWORD *)this + 12) = width;
    *((_DWORD *)this + 13) = height;
    *((_DWORD *)this + 14) = 1;
    *((_DWORD *)this + 15) = border;
    *((_DWORD *)this + 16) = internalformat;
    *((_DWORD *)this + 18) = internalformat;
    if (level)
      *((_BYTE *)this + 201) = 1;
  }
}

void sub_1B2C08220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  _Unwind_Resume(a1);
}

uint64_t ProGL::getMaxNumberOfTexturesPerShareGroup(ProGL *this)
{
  return 100000;
}

uint64_t ProGL::Private::ProgramHelper::getProgramContext@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 24);
  *a2 = *(_QWORD *)(result + 16);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

ProGL::Private::VariableBase *ProGL::Private::VariableBase::VariableBase(ProGL::Private::VariableBase *this, ProGL::Program *a2)
{
  *(_QWORD *)this = &off_1E654B2C0;
  *((_QWORD *)this + 1) = a2;
  ProGL::Private::VariableList::add((ProGL::Program *)((char *)a2 + 168), this);
  return this;
}

void ProGL::Private::VariableBase::~VariableBase(ProGL::Private::VariableBase *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_1E654B2C0;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    ProGL::Private::VariableList::remove((ProGL::Private::VariableList *)(v1 + 168), this);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_1E654B2C0;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    ProGL::Private::VariableList::remove((ProGL::Private::VariableList *)(v1 + 168), this);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_1E654B2C0;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    ProGL::Private::VariableList::remove((ProGL::Private::VariableList *)(v1 + 168), this);
  JUMPOUT(0x1B5E29170);
}

uint64_t ProGL::Private::VariableBase::prepare(ProGL::Private::VariableBase *this, ProGL::GL *a2)
{
  return 1;
}

uint64_t ProGL::Private::VariableBase::isValidIn(ProGL::Private::VariableBase *this)
{
  return 1;
}

void ProGL::Private::VariableBase::getString(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void ProGL::Private::VariableList::add(ProGL::Private::VariableList *this, ProGL::Private::VariableBase *a2)
{
  uint64_t v4;
  ProGL::Private::VariableBase **v5;
  ProGL::Private::VariableBase **v6;
  char *v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  _QWORD *v20;
  char *v21;

  v4 = *(_QWORD *)this;
  v5 = (ProGL::Private::VariableBase **)*((_QWORD *)this + 1);
  v6 = *(ProGL::Private::VariableBase ***)this;
  if (*(ProGL::Private::VariableBase ***)this != v5)
  {
    while (*v6 != a2)
    {
      if (++v6 == v5)
      {
        v6 = (ProGL::Private::VariableBase **)*((_QWORD *)this + 1);
        break;
      }
    }
  }
  if (v6 == v5)
  {
    v7 = (char *)this + 16;
    v8 = *((_QWORD *)this + 2);
    if ((unint64_t)v5 >= v8)
    {
      v10 = ((uint64_t)v5 - v4) >> 3;
      if ((unint64_t)(v10 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v11 = v8 - v4;
      v12 = v11 >> 2;
      if (v11 >> 2 <= (unint64_t)(v10 + 1))
        v12 = v10 + 1;
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
        v13 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v13 = v12;
      if (v13)
        v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v7, v13);
      else
        v14 = 0;
      v15 = &v14[8 * v10];
      v16 = &v14[8 * v13];
      *(_QWORD *)v15 = a2;
      v9 = v15 + 8;
      v18 = *(char **)this;
      v17 = (char *)*((_QWORD *)this + 1);
      if (v17 != *(char **)this)
      {
        do
        {
          v19 = *((_QWORD *)v17 - 1);
          v17 -= 8;
          *((_QWORD *)v15 - 1) = v19;
          v15 -= 8;
        }
        while (v17 != v18);
        v17 = *(char **)this;
      }
      *(_QWORD *)this = v15;
      *((_QWORD *)this + 1) = v9;
      *((_QWORD *)this + 2) = v16;
      if (v17)
        operator delete(v17);
    }
    else
    {
      *v5 = a2;
      v9 = v5 + 1;
    }
    v21 = (char *)*((_QWORD *)this + 4);
    v20 = (_QWORD *)((char *)this + 32);
    *(v20 - 3) = v9;
    std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy((uint64_t)(v20 - 1), v21);
    *(v20 - 1) = v20;
    *v20 = 0;
    v20[1] = 0;
  }
}

void ProGL::Private::VariableList::remove(ProGL::Private::VariableList *this, ProGL::Private::VariableBase *a2)
{
  ProGL::Private::VariableBase **v3;
  ProGL::Private::VariableBase **v4;
  int64_t v5;
  _QWORD *v6;
  char *v7;

  v4 = *(ProGL::Private::VariableBase ***)this;
  v3 = (ProGL::Private::VariableBase **)*((_QWORD *)this + 1);
  if (*(ProGL::Private::VariableBase ***)this != v3)
  {
    while (*v4 != a2)
    {
      if (++v4 == v3)
      {
        v4 = (ProGL::Private::VariableBase **)*((_QWORD *)this + 1);
        break;
      }
    }
  }
  if (v4 != v3)
  {
    v5 = (char *)v3 - (char *)(v4 + 1);
    if (v3 != v4 + 1)
      memmove(v4, v4 + 1, (char *)v3 - (char *)(v4 + 1));
    v7 = (char *)*((_QWORD *)this + 4);
    v6 = (_QWORD *)((char *)this + 32);
    *(v6 - 3) = (char *)v4 + v5;
    std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy((uint64_t)(v6 - 1), v7);
    *(v6 - 1) = v6;
    *v6 = 0;
    v6[1] = 0;
  }
}

uint64_t **ProGL::Private::VariableList::getString(uint64_t **this, uint64_t a2)
{
  unsigned int v4;
  unsigned int *v5;

  v4 = a2;
  ProGL::Private::VariableList::makeSortedString((ProGL::Private::VariableList *)this, a2);
  v5 = &v4;
  return std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(this + 3, &v4, (uint64_t)&std::piecewise_construct, &v5)+ 5;
}

void ProGL::Private::VariableList::makeSortedString(ProGL::Private::VariableList *this, uint64_t a2)
{
  char *v3;
  uint64_t **v4;
  uint64_t **v5;
  unsigned int v6;
  BOOL v7;
  char **v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  _QWORD *v20;
  _QWORD *v21;
  char *v22;
  __int128 v23;
  int64x2_t v24;
  _OWORD *v25;
  std::string::size_type v26;
  std::__shared_weak_count *size;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  const void ***v31;
  unint64_t v32;
  uint64_t v33;
  const std::string::value_type ***v34;
  const std::string::value_type ***v35;
  int v36;
  const std::string::value_type *v37;
  std::string::size_type v38;
  std::string v39;
  __int128 v40;
  char *v41;
  void **v42;
  std::string __p;
  char **v44;

  v4 = (uint64_t **)((char *)this + 32);
  v3 = (char *)*((_QWORD *)this + 4);
  if (!v3)
    goto LABEL_12;
  v5 = (uint64_t **)((char *)this + 32);
  do
  {
    v6 = *((_DWORD *)v3 + 8);
    v7 = v6 >= a2;
    if (v6 >= a2)
      v8 = (char **)v3;
    else
      v8 = (char **)(v3 + 8);
    if (v7)
      v5 = (uint64_t **)v3;
    v3 = *v8;
  }
  while (*v8);
  if (v5 == v4 || *((_DWORD *)v5 + 8) > a2)
  {
LABEL_12:
    v40 = 0uLL;
    v41 = 0;
    v9 = *(_QWORD **)this;
    v10 = (_QWORD *)*((_QWORD *)this + 1);
    if (*(_QWORD **)this == v10)
    {
      v31 = 0;
      v30 = 0;
    }
    else
    {
      do
      {
        if ((*(unsigned int (**)(_QWORD, uint64_t))(*(_QWORD *)*v9 + 32))(*v9, a2))
        {
          v11 = operator new();
          (*(void (**)(_QWORD))(*(_QWORD *)*v9 + 40))(*v9);
          std::shared_ptr<std::string>::shared_ptr[abi:ne180100]<std::string,void>(&v39, v11);
          v12 = *((_QWORD *)&v40 + 1);
          if (*((_QWORD *)&v40 + 1) >= (unint64_t)v41)
          {
            v13 = (uint64_t)(*((_QWORD *)&v40 + 1) - v40) >> 4;
            v14 = v13 + 1;
            if ((unint64_t)(v13 + 1) >> 60)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v15 = (uint64_t)&v41[-v40];
            if ((uint64_t)&v41[-v40] >> 3 > v14)
              v14 = v15 >> 3;
            if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF0)
              v16 = 0xFFFFFFFFFFFFFFFLL;
            else
              v16 = v14;
            v44 = &v41;
            v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&v41, v16);
            v19 = &v17[16 * v13];
            *(_OWORD *)v19 = *(_OWORD *)&v39.__r_.__value_.__l.__data_;
            *(_OWORD *)&v39.__r_.__value_.__l.__data_ = 0uLL;
            v20 = (_QWORD *)*((_QWORD *)&v40 + 1);
            v21 = (_QWORD *)v40;
            if (*((_QWORD *)&v40 + 1) == (_QWORD)v40)
            {
              v24 = vdupq_n_s64(*((unint64_t *)&v40 + 1));
              v22 = &v17[16 * v13];
            }
            else
            {
              v22 = &v17[16 * v13];
              do
              {
                v23 = *((_OWORD *)v20 - 1);
                v20 -= 2;
                *((_OWORD *)v22 - 1) = v23;
                v22 -= 16;
                *v20 = 0;
                v20[1] = 0;
              }
              while (v20 != v21);
              v24 = (int64x2_t)v40;
            }
            v25 = v19 + 16;
            *(_QWORD *)&v40 = v22;
            *((_QWORD *)&v40 + 1) = v19 + 16;
            *(int64x2_t *)&__p.__r_.__value_.__l.__data_ = v24;
            v26 = (std::string::size_type)v41;
            v41 = &v17[16 * v18];
            __p.__r_.__value_.__r.__words[2] = v26;
            v42 = (void **)v24.i64[0];
            std::__split_buffer<std::shared_ptr<TXTextObject>>::~__split_buffer((uint64_t)&v42);
            size = (std::__shared_weak_count *)v39.__r_.__value_.__l.__size_;
            *((_QWORD *)&v40 + 1) = v25;
            if (v39.__r_.__value_.__l.__size_)
            {
              v28 = (unint64_t *)(v39.__r_.__value_.__l.__size_ + 8);
              do
                v29 = __ldaxr(v28);
              while (__stlxr(v29 - 1, v28));
              if (!v29)
              {
                ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
                std::__shared_weak_count::__release_weak(size);
              }
            }
          }
          else
          {
            **((_OWORD **)&v40 + 1) = *(_OWORD *)&v39.__r_.__value_.__l.__data_;
            *((_QWORD *)&v40 + 1) = v12 + 16;
          }
        }
        ++v9;
      }
      while (v9 != v10);
      v31 = (const void ***)*((_QWORD *)&v40 + 1);
      v30 = v40;
    }
    v32 = 126 - 2 * __clz(((uint64_t)v31 - v30) >> 4);
    if (v31 == (const void ***)v30)
      v33 = 0;
    else
      v33 = v32;
    memset(&v39, 0, sizeof(v39));
    v35 = (const std::string::value_type ***)*((_QWORD *)&v40 + 1);
    v34 = (const std::string::value_type ***)v40;
    if ((_QWORD)v40 == *((_QWORD *)&v40 + 1))
    {
      LODWORD(v42) = a2;
    }
    else
    {
      do
      {
        v36 = *((char *)*v34 + 23);
        if (v36 >= 0)
          v37 = (const std::string::value_type *)*v34;
        else
          v37 = **v34;
        if (v36 >= 0)
          v38 = *((unsigned __int8 *)*v34 + 23);
        else
          v38 = (std::string::size_type)(*v34)[1];
        std::string::append(&v39, v37, v38);
        v34 += 2;
      }
      while (v34 != v35);
      LODWORD(v42) = a2;
      if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, v39.__r_.__value_.__l.__data_, v39.__r_.__value_.__l.__size_);
LABEL_50:
        std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,std::string>>(v4 - 1, (unsigned int *)&v42, (uint64_t)&v42);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v39.__r_.__value_.__l.__data_);
        v42 = (void **)&v40;
        std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__destroy_vector::operator()[abi:ne180100](&v42);
        return;
      }
    }
    __p = v39;
    goto LABEL_50;
  }
}

void sub_1B2C08888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a14 < 0)
    operator delete(__p);
  __p = &a16;
  std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

double ProGL::Program::Program(ProGL::Program *this)
{
  double result;

  *(_QWORD *)this = &off_1E654B300;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 26) = 0;
  *((_QWORD *)this + 25) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = (char *)this + 200;
  *((_BYTE *)this + 216) = 1;
  return result;
}

void ProGL::Program::~Program(ProGL::Program *this)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  void *v13;
  __int128 v14;

  *(_QWORD *)this = &off_1E654B300;
  if (*((_DWORD *)this + 2))
  {
    v2 = operator new();
    v3 = v2;
    v4 = *((_DWORD *)this + 2);
    v5 = *((_DWORD *)this + 8);
    *(_QWORD *)v2 = &off_1E654B350;
    *(_DWORD *)(v2 + 8) = v4;
    v6 = *((_QWORD *)this + 3);
    *(_QWORD *)(v2 + 16) = *((_QWORD *)this + 2);
    *(_QWORD *)(v2 + 24) = v6;
    if (v6)
    {
      v7 = (unint64_t *)(v6 + 8);
      do
        v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
    }
    *(_DWORD *)(v2 + 32) = v5;
    *(_QWORD *)&v14 = v2;
    v9 = (_QWORD *)operator new();
    *v9 = &off_1E654B408;
    v9[1] = 0;
    v9[2] = 0;
    v9[3] = v3;
    *((_QWORD *)&v14 + 1) = v9;
    ProGL::postDeletionInstruction(&v14);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v14 + 1);
    if (*((_QWORD *)&v14 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v14 + 1) + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
  std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy((uint64_t)this + 192, *((char **)this + 25));
  v13 = (void *)*((_QWORD *)this + 21);
  if (v13)
  {
    *((_QWORD *)this + 22) = v13;
    operator delete(v13);
  }
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)this + 152);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)this + 136);
  if (*((char *)this + 135) < 0)
    operator delete(*((void **)this + 14));
  if (*((char *)this + 111) < 0)
    operator delete(*((void **)this + 11));
  if (*((char *)this + 87) < 0)
    operator delete(*((void **)this + 8));
  if (*((char *)this + 63) < 0)
    operator delete(*((void **)this + 5));
  ProGL::ContextHandle::~ContextHandle((ProGL::Program *)((char *)this + 16));
}

{
  ProGL::Program::~Program(this);
  JUMPOUT(0x1B5E29170);
}

void sub_1B2C08AE4(void *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  __clang_call_terminate(a1);
}

void ProGL::Program::setFragmentSource(ProGL::Program *this, const char *a2)
{
  JUMPOUT(0x1B5E28D80);
}

void ProGL::Program::setFragmentSource()
{
  JUMPOUT(0x1B5E28D80);
}

uint64_t ProGL::Program::build(ProGL::Program *this, ProGL::GL *a2)
{
  uint64_t v4;
  uint64_t **String;
  __int128 v6;
  std::string *v7;
  std::string::size_type size;
  int v9;
  const std::string::value_type *v10;
  std::string::size_type v11;
  int v12;
  const std::string::value_type *v13;
  std::string::size_type v14;
  std::string *v15;
  ProGL::Private::Shader **v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  BOOL v20;
  _QWORD *v21;
  uint64_t RootChannel;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t **v27;
  __int128 v28;
  std::string *v29;
  std::string::size_type v30;
  int v31;
  const std::string::value_type *v32;
  std::string::size_type v33;
  int v34;
  const std::string::value_type *v35;
  std::string::size_type v36;
  std::string *v37;
  ProGL::Private::Shader **v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  BOOL v42;
  _QWORD *v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  GLuint Program;
  HGRenderQueue *v50;
  GLuint DebugQueueVerboseMask;
  HGRenderQueue *v52;
  GLuint v53;
  GLuint v54;
  _QWORD *v55;
  _QWORD *v56;
  _QWORD *v57;
  char v58;
  _QWORD *v59;
  std::string *v60;
  std::string::size_type v61;
  _QWORD *v62;
  GLuint v63;
  _QWORD *v64;
  size_t v65;
  _QWORD *v66;
  __int128 v68;
  std::string v69;
  std::string v70;

  if (*((char *)this + 87) < 0)
    v4 = *((_QWORD *)this + 9);
  else
    v4 = *((unsigned __int8 *)this + 87);
  if (v4)
  {
    String = ProGL::Private::VariableList::getString((uint64_t **)this + 21, 35633);
    if (*((char *)String + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v70, (const std::string::value_type *)*String, (std::string::size_type)String[1]);
    }
    else
    {
      v6 = *(_OWORD *)String;
      v70.__r_.__value_.__r.__words[2] = (std::string::size_type)String[2];
      *(_OWORD *)&v70.__r_.__value_.__l.__data_ = v6;
    }
    memset(&v69, 0, sizeof(v69));
    std::string::operator=(&v69, (const std::string *)((char *)this + 40));
    if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v7 = &v70;
    else
      v7 = (std::string *)v70.__r_.__value_.__r.__words[0];
    if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v70.__r_.__value_.__r.__words[2]);
    else
      size = v70.__r_.__value_.__l.__size_;
    std::string::append(&v69, (const std::string::value_type *)v7, size);
    v9 = *((char *)this + 135);
    if (v9 >= 0)
      v10 = (char *)this + 112;
    else
      v10 = (const std::string::value_type *)*((_QWORD *)this + 14);
    if (v9 >= 0)
      v11 = *((unsigned __int8 *)this + 135);
    else
      v11 = *((_QWORD *)this + 15);
    std::string::append(&v69, v10, v11);
    v12 = *((char *)this + 87);
    if (v12 >= 0)
      v13 = (char *)this + 64;
    else
      v13 = (const std::string::value_type *)*((_QWORD *)this + 8);
    if (v12 >= 0)
      v14 = *((unsigned __int8 *)this + 87);
    else
      v14 = *((_QWORD *)this + 9);
    std::string::append(&v69, v13, v14);
    if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = &v69;
    else
      v15 = (std::string *)v69.__r_.__value_.__r.__words[0];
    v16 = (ProGL::Private::Shader **)((char *)this + 136);
    std::shared_ptr<TXTextObject>::operator=[abi:ne180100]((uint64_t)this + 136, &v68);
    v17 = (std::__shared_weak_count *)*((_QWORD *)&v68 + 1);
    if (*((_QWORD *)&v68 + 1))
    {
      v18 = (unint64_t *)(*((_QWORD *)&v68 + 1) + 8);
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
    v20 = ProGL::Private::Shader::good(*v16);
    if (!v20)
    {
      v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A50], (uint64_t)"Error compiling vertex shader. log is:\n", 39);
      RootChannel = OZStyle::getRootChannel(*v16);
      v23 = *(char *)(RootChannel + 23);
      if (v23 >= 0)
        v24 = RootChannel;
      else
        v24 = *(_QWORD *)RootChannel;
      if (v23 >= 0)
        v25 = *(unsigned __int8 *)(RootChannel + 23);
      else
        v25 = *(_QWORD *)(RootChannel + 8);
      v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, v24, v25);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"\n", 1);
    }
    if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v69.__r_.__value_.__l.__data_);
    if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v70.__r_.__value_.__l.__data_);
      if (!v20)
        goto LABEL_120;
    }
    else if (!v20)
    {
      goto LABEL_120;
    }
  }
  else
  {
    std::shared_ptr<OZFontFace>::reset[abi:ne180100]((_QWORD *)this + 17);
  }
  if ((*((char *)this + 111) & 0x80000000) == 0)
  {
    if (*((_BYTE *)this + 111))
      goto LABEL_51;
LABEL_54:
    std::shared_ptr<OZFontFace>::reset[abi:ne180100]((_QWORD *)this + 19);
    goto LABEL_96;
  }
  if (!*((_QWORD *)this + 12))
    goto LABEL_54;
LABEL_51:
  v27 = ProGL::Private::VariableList::getString((uint64_t **)this + 21, 35632);
  if (*((char *)v27 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v70, (const std::string::value_type *)*v27, (std::string::size_type)v27[1]);
  }
  else
  {
    v28 = *(_OWORD *)v27;
    v70.__r_.__value_.__r.__words[2] = (std::string::size_type)v27[2];
    *(_OWORD *)&v70.__r_.__value_.__l.__data_ = v28;
  }
  memset(&v69, 0, sizeof(v69));
  std::string::operator=(&v69, (const std::string *)((char *)this + 40));
  if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v29 = &v70;
  else
    v29 = (std::string *)v70.__r_.__value_.__r.__words[0];
  if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v30 = HIBYTE(v70.__r_.__value_.__r.__words[2]);
  else
    v30 = v70.__r_.__value_.__l.__size_;
  std::string::append(&v69, (const std::string::value_type *)v29, v30);
  v31 = *((char *)this + 135);
  if (v31 >= 0)
    v32 = (char *)this + 112;
  else
    v32 = (const std::string::value_type *)*((_QWORD *)this + 14);
  if (v31 >= 0)
    v33 = *((unsigned __int8 *)this + 135);
  else
    v33 = *((_QWORD *)this + 15);
  std::string::append(&v69, v32, v33);
  v34 = *((char *)this + 111);
  if (v34 >= 0)
    v35 = (char *)this + 88;
  else
    v35 = (const std::string::value_type *)*((_QWORD *)this + 11);
  if (v34 >= 0)
    v36 = *((unsigned __int8 *)this + 111);
  else
    v36 = *((_QWORD *)this + 12);
  std::string::append(&v69, v35, v36);
  if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v37 = &v69;
  else
    v37 = (std::string *)v69.__r_.__value_.__r.__words[0];
  v38 = (ProGL::Private::Shader **)((char *)this + 152);
  std::shared_ptr<TXTextObject>::operator=[abi:ne180100]((uint64_t)this + 152, &v68);
  v39 = (std::__shared_weak_count *)*((_QWORD *)&v68 + 1);
  if (*((_QWORD *)&v68 + 1))
  {
    v40 = (unint64_t *)(*((_QWORD *)&v68 + 1) + 8);
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  v42 = ProGL::Private::Shader::good(*v38);
  if (!v42)
  {
    v43 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A50], (uint64_t)"Error compiling fragment shader. log is:\n", 41);
    v44 = OZStyle::getRootChannel(*v38);
    v45 = *(char *)(v44 + 23);
    if (v45 >= 0)
      v46 = v44;
    else
      v46 = *(_QWORD *)v44;
    if (v45 >= 0)
      v47 = *(unsigned __int8 *)(v44 + 23);
    else
      v47 = *(_QWORD *)(v44 + 8);
    v48 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v43, v46, v47);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v48, (uint64_t)"\n", 1);
  }
  if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v69.__r_.__value_.__l.__data_);
  if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v70.__r_.__value_.__l.__data_);
    if (v42)
      goto LABEL_96;
LABEL_120:
    v58 = 0;
    return v58 & 1;
  }
  if (!v42)
    goto LABEL_120;
LABEL_96:
  ProGL::GL::getPGLContextHandle(a2, &v70);
  ProGL::ContextHandle::operator=((_QWORD *)this + 2, (uint64_t *)&v70);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v70);
  *((_DWORD *)this + 8) = ProGL::ContextHandle::getVirtualScreen((ProGL::Program *)((char *)this + 16));
  Program = glCreateProgram();
  *((_DWORD *)this + 2) = Program;
  v50 = (HGRenderQueue *)*((_QWORD *)this + 17);
  if (v50)
  {
    DebugQueueVerboseMask = HGRenderQueue::GetDebugQueueVerboseMask(v50);
    glAttachShader(Program, DebugQueueVerboseMask);
    Program = *((_DWORD *)this + 2);
  }
  v52 = (HGRenderQueue *)*((_QWORD *)this + 19);
  if (v52)
  {
    v53 = HGRenderQueue::GetDebugQueueVerboseMask(v52);
    glAttachShader(Program, v53);
    Program = *((_DWORD *)this + 2);
  }
  glLinkProgram(Program);
  v54 = *((_DWORD *)this + 2);
  LODWORD(v70.__r_.__value_.__l.__data_) = 0;
  glGetProgramiv(v54, 0x8B82u, (GLint *)&v70);
  if (!LODWORD(v70.__r_.__value_.__l.__data_))
  {
    v63 = *((_DWORD *)this + 2);
    LODWORD(v70.__r_.__value_.__l.__data_) = 0;
    glGetProgramiv(v63, 0x8B84u, (GLint *)&v70);
    LODWORD(v69.__r_.__value_.__l.__data_) = v70.__r_.__value_.__l.__data_;
    if (SLODWORD(v70.__r_.__value_.__l.__data_) < 2)
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A50], (uint64_t)"Error linking program object; error unknown.",
        44);
    }
    else
    {
      std::vector<char>::vector((std::vector<char> *)&v70, LODWORD(v70.__r_.__value_.__l.__data_));
      glGetProgramInfoLog(*((_DWORD *)this + 2), LODWORD(v70.__r_.__value_.__r.__words[1]) - LODWORD(v70.__r_.__value_.__l.__data_), (GLsizei *)&v69, v70.__r_.__value_.__l.__data_);
      v64 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A50], (uint64_t)"Error linking program object. log is:\n", 38);
      v65 = strlen(v70.__r_.__value_.__l.__data_);
      v66 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v64, (uint64_t)v70.__r_.__value_.__l.__data_, v65);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v66, (uint64_t)"\n", 1);
      if (v70.__r_.__value_.__r.__words[0])
      {
        v70.__r_.__value_.__l.__size_ = v70.__r_.__value_.__r.__words[0];
        operator delete(v70.__r_.__value_.__l.__data_);
      }
    }
    goto LABEL_120;
  }
  v55 = (_QWORD *)*((_QWORD *)this + 21);
  v56 = (_QWORD *)*((_QWORD *)this + 22);
  if (v55 == v56)
  {
    v58 = 1;
  }
  else
  {
    v57 = (_QWORD *)MEMORY[0x1E0DE4A50];
    v58 = 1;
    do
    {
      if (((*(uint64_t (**)(_QWORD, ProGL::GL *))(*(_QWORD *)*v55 + 16))(*v55, a2) & 1) == 0)
      {
        v59 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)"Error setting up program variable: ", 35);
        (*(void (**)(std::string *__return_ptr))(*(_QWORD *)*v55 + 40))(&v70);
        if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v60 = &v70;
        else
          v60 = (std::string *)v70.__r_.__value_.__r.__words[0];
        if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v61 = HIBYTE(v70.__r_.__value_.__r.__words[2]);
        else
          v61 = v70.__r_.__value_.__l.__size_;
        v62 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)v60, v61);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v62, (uint64_t)"\n", 1);
        if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v70.__r_.__value_.__l.__data_);
        v58 = 0;
      }
      ++v55;
    }
    while (v55 != v56);
  }
  return v58 & 1;
}

void sub_1B2C09168(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ProGL::Program::use(ProGL::Program *this, ProGL::GL *a2)
{
  if (*((_BYTE *)this + 216))
    glUseProgram(*((_DWORD *)this + 2));
}

void ProGL::Program::unuse(ProGL::Program *this, ProGL::GL *a2)
{
  if (*((_BYTE *)this + 216))
    glUseProgram(0);
}

uint64_t ProGL::Private::ProgramHandleImpl::ProgramHandleImpl(uint64_t result, _QWORD *a2, int a3)
{
  int v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  *(_DWORD *)result = 0;
  if (a3 <= 1)
    v3 = 1;
  else
    v3 = a3;
  *(_DWORD *)(result + 8) = v3;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_QWORD *)(result + 40) = 0;
  *(_QWORD *)(result + 16) = result + 24;
  v4 = a2[1];
  *(_QWORD *)(result + 48) = *a2;
  *(_QWORD *)(result + 56) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return result;
}

uint64_t ProGL::Private::ProgramHandleImpl::prepareProgram(os_unfair_lock_s *this, ProGL::GL *a2, int a3)
{
  unint64_t *v6;
  unint64_t v7;
  os_unfair_lock_s *v8;
  os_unfair_lock_s *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  int *v15;
  __int128 v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  BOOL v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  __int128 v32;
  __int128 v33;
  unint64_t v34[2];
  unint64_t v35;
  unint64_t v36;
  os_unfair_lock_t v37;

  v37 = this;
  PCSpinLock::lock(this);
  ProGL::GL::getPGLContextHandle(a2, &v35);
  v34[0] = v35;
  v34[1] = v36;
  if (v36)
  {
    v6 = (unint64_t *)(v36 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = this + 4;
  v9 = (os_unfair_lock_s *)std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::find<ProGL::Private::ProgramHandleImpl::ContextKey>((uint64_t)&this[4], (ProGL::ContextHandle *)v34);
  v10 = (char *)&this[6];
  if (&this[6] == v9)
  {
    v33 = 0uLL;
LABEL_11:
    (***(void (****)(__int128 *__return_ptr))&this[12]._os_unfair_lock_opaque)(&v32);
    v15 = (int *)&this[2];
    v16 = v32;
    v32 = 0uLL;
    v17 = (std::__shared_weak_count *)*((_QWORD *)&v33 + 1);
    v33 = v16;
    if (v17)
    {
      p_shared_owners = (unint64_t *)&v17->__shared_owners_;
      do
        v19 = __ldaxr(p_shared_owners);
      while (__stlxr(v19 - 1, p_shared_owners));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
    v20 = (std::__shared_weak_count *)*((_QWORD *)&v32 + 1);
    if (*((_QWORD *)&v32 + 1))
    {
      v21 = (unint64_t *)(*((_QWORD *)&v32 + 1) + 8);
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::add(v15, v34, (uint64_t *)&v33);
    v12 = v33;
    goto LABEL_22;
  }
  ++*(_QWORD *)&v9[16]._os_unfair_lock_opaque;
  v12 = *(_QWORD *)&v9[12]._os_unfair_lock_opaque;
  v11 = *(_QWORD *)&v9[14]._os_unfair_lock_opaque;
  *(_QWORD *)&v33 = v12;
  *((_QWORD *)&v33 + 1) = v11;
  if (v11)
  {
    v13 = (unint64_t *)(v11 + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  if (!v12)
    goto LABEL_11;
LABEL_22:
  if (*(_BYTE *)(v12 + 216))
  {
    if (*(_DWORD *)(v12 + 8))
    {
      v23 = 1;
    }
    else
    {
      v23 = ProGL::Program::build((ProGL::Program *)v12, a2);
      *(_BYTE *)(v12 + 216) = v23;
      if (!(_DWORD)v23)
        goto LABEL_39;
    }
    if (a3)
    {
      (*(void (**)(_QWORD, ProGL::GL *))(*(_QWORD *)v33 + 16))(v33, a2);
      v24 = *(char **)&v8->_os_unfair_lock_opaque;
      if (*(char **)&v8->_os_unfair_lock_opaque != v10)
      {
        while (*((_QWORD *)v24 + 6) != (_QWORD)v33)
        {
          v25 = (char *)*((_QWORD *)v24 + 1);
          if (v25)
          {
            do
            {
              v26 = v25;
              v25 = *(char **)v25;
            }
            while (v25);
          }
          else
          {
            do
            {
              v26 = (char *)*((_QWORD *)v24 + 2);
              v27 = *(_QWORD *)v26 == (_QWORD)v24;
              v24 = v26;
            }
            while (!v27);
          }
          v24 = v26;
          if (v26 == v10)
            goto LABEL_38;
        }
        v24[72] = 0;
      }
LABEL_38:
      v23 = 1;
    }
  }
  else
  {
    v23 = 0;
  }
LABEL_39:
  v28 = (std::__shared_weak_count *)*((_QWORD *)&v33 + 1);
  if (*((_QWORD *)&v33 + 1))
  {
    v29 = (unint64_t *)(*((_QWORD *)&v33 + 1) + 8);
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v34);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v35);
  if (v37)
    PCSpinLock::unlock(v37);
  return v23;
}

void sub_1B2C094B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;
  uint64_t v11;
  va_list va2;

  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v9 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)va);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va1);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)(v3 - 56));
  _Unwind_Resume(a1);
}

void ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::add(int *a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  BOOL v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  char v22;
  char v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  __n128 v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  char v32;

  v6 = (uint64_t **)(a1 + 2);
  if (*((_QWORD *)a1 + 3) >= (unint64_t)*a1)
  {
    v7 = (uint64_t *)(a1 + 4);
    do
    {
      v8 = *v6;
      if (*v6 == v7)
        break;
      v9 = (uint64_t *)(a1 + 4);
      do
      {
        if (*((_BYTE *)v8 + 72))
        {
          v10 = v8;
          if (v9 != v7)
          {
            if (v8[8] >= (unint64_t)v9[8])
              v10 = v9;
            else
              v10 = v8;
          }
        }
        else
        {
          v10 = v9;
        }
        v11 = (uint64_t *)v8[1];
        if (v11)
        {
          do
          {
            v12 = v11;
            v11 = (uint64_t *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            v12 = (uint64_t *)v8[2];
            v13 = *v12 == (_QWORD)v8;
            v8 = v12;
          }
          while (!v13);
        }
        v9 = v10;
        v8 = v12;
      }
      while (v12 != v7);
      if (v10 == v7)
        break;
      std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::erase(v6, v10);
    }
    while (*((_QWORD *)a1 + 3) >= (unint64_t)*a1);
  }
  v14 = *((_QWORD *)a1 + 4) + 1;
  *((_QWORD *)a1 + 4) = v14;
  v16 = *a3;
  v15 = (std::__shared_weak_count *)a3[1];
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(p_shared_owners);
    while (__stxr(v18 + 1, p_shared_owners));
  }
  v27 = v14;
  v19 = a2[1];
  v28.n128_u64[0] = *a2;
  v28.n128_u64[1] = v19;
  if (v19)
  {
    v20 = (unint64_t *)(v19 + 8);
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  v29 = v16;
  v30 = v15;
  v31 = v27;
  v32 = 1;
  std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__emplace_unique_key_args<ProGL::Private::ProgramHandleImpl::ContextKey,std::pair<ProGL::Private::ProgramHandleImpl::ContextKey const,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>(v6, (ProGL::ContextHandle *)&v28, &v28);
  v23 = v22;
  v24 = v30;
  if (v30)
  {
    v25 = (unint64_t *)&v30->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v28);
  if ((v23 & 1) == 0)
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)"The inserted item is already present in the map, which shouldn't happen.\n", 73);
}

void sub_1B2C0970C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;

  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v13);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a13);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ProGL::Private::ProgramHandleImpl::unuse(ProGL::Private::ProgramHandleImpl *this, ProGL::GL *a2)
{
  unint64_t *v4;
  unint64_t v5;
  char **v6;
  _QWORD *v7;
  char *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  BOOL v16;
  unint64_t *v17;
  unint64_t v18;
  _QWORD v19[2];
  uint64_t v20;
  uint64_t v21;
  os_unfair_lock_t lock;

  lock = (os_unfair_lock_t)this;
  PCSpinLock::lock((os_unfair_lock_t)this);
  ProGL::GL::getPGLContextHandle(a2, &v20);
  v19[0] = v20;
  v19[1] = v21;
  if (v21)
  {
    v4 = (unint64_t *)(v21 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = (char **)((char *)this + 16);
  v7 = std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::find<ProGL::Private::ProgramHandleImpl::ContextKey>((uint64_t)this + 16, (ProGL::ContextHandle *)v19);
  v8 = (char *)this + 24;
  if ((_QWORD *)((char *)this + 24) == v7)
  {
    v9 = 0;
    v10 = 0;
  }
  else
  {
    v9 = (std::__shared_weak_count *)v7[7];
    ++v7[8];
    v10 = v7[6];
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }
  }
  (*(void (**)(uint64_t, ProGL::GL *))(*(_QWORD *)v10 + 24))(v10, a2);
  v13 = *v6;
  if (*v6 != v8)
  {
    while (*((_QWORD *)v13 + 6) != v10)
    {
      v14 = (char *)*((_QWORD *)v13 + 1);
      if (v14)
      {
        do
        {
          v15 = v14;
          v14 = *(char **)v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          v15 = (char *)*((_QWORD *)v13 + 2);
          v16 = *(_QWORD *)v15 == (_QWORD)v13;
          v13 = v15;
        }
        while (!v16);
      }
      v13 = v15;
      if (v15 == v8)
        goto LABEL_23;
    }
    if (!v13[72])
    {
      if (*((_QWORD *)this + 4) >= (unint64_t)*((int *)this + 2))
        std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::erase((uint64_t **)this + 2, (uint64_t *)v13);
      else
        v13[72] = 1;
    }
  }
LABEL_23:
  if (v9)
  {
    v17 = (unint64_t *)&v9->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *, char *))v9->__on_zero_shared)(v9, v13);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v19);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v20);
  if (lock)
    PCSpinLock::unlock(lock);
}

void sub_1B2C098DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  va_list va1;
  uint64_t v10;
  va_list va2;

  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v8 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va1);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va2);
  _Unwind_Resume(a1);
}

void ProGL::Private::ProgramHandleImpl::getProgram(os_unfair_lock_s *this@<X0>, ProGL::GL *a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t *v6;
  unint64_t v7;
  os_unfair_lock_s *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  _QWORD v12[2];
  uint64_t v13;
  uint64_t v14;
  os_unfair_lock_s *v15;

  v15 = this;
  PCSpinLock::lock(this);
  ProGL::GL::getPGLContextHandle(a2, &v13);
  v12[0] = v13;
  v12[1] = v14;
  if (v14)
  {
    v6 = (unint64_t *)(v14 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = (os_unfair_lock_s *)std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::find<ProGL::Private::ProgramHandleImpl::ContextKey>((uint64_t)&this[4], (ProGL::ContextHandle *)v12);
  if (&this[6] == v8)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    ++*(_QWORD *)&v8[16]._os_unfair_lock_opaque;
    v9 = *(_QWORD *)&v8[14]._os_unfair_lock_opaque;
    *a3 = *(_QWORD *)&v8[12]._os_unfair_lock_opaque;
    a3[1] = v9;
    if (v9)
    {
      v10 = (unint64_t *)(v9 + 8);
      do
        v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }
  }
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v12);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v13);
  if (this)
    PCSpinLock::unlock(this);
}

void sub_1B2C099EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  va_list va1;
  uint64_t v8;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v6 = va_arg(va2, _QWORD);
  v8 = va_arg(va2, _QWORD);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va1);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va2);
  _Unwind_Resume(a1);
}

uint64_t ProGL::ProgramHandle::use(os_unfair_lock_s **this, ProGL::GL *a2)
{
  os_unfair_lock_s *v2;

  v2 = *this;
  if (v2)
    return ProGL::Private::ProgramHandleImpl::prepareProgram(v2, a2, 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A50], (uint64_t)"Can't use an empty program handle.\n", 35);
  return 0;
}

void ProGL::ProgramHandle::unuse(ProGL::Private::ProgramHandleImpl **this, ProGL::GL *a2)
{
  ProGL::Private::ProgramHandleImpl *v2;

  v2 = *this;
  if (v2)
    ProGL::Private::ProgramHandleImpl::unuse(v2, a2);
  else
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A50], (uint64_t)"Can't unuse an empty program handle.\n", 37);
}

ProGL::UseProgramSentry *ProGL::UseProgramSentry::UseProgramSentry(ProGL::UseProgramSentry *this, ProGL::GL *a2, const ProGL::ProgramHandle *a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  v5 = ProGL::GL::GL(this, a2);
  v6 = *((_QWORD *)a3 + 1);
  *(_QWORD *)(v5 + 40) = *(_QWORD *)a3;
  *(_QWORD *)(v5 + 48) = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  ProGL::ProgramHandle::use((os_unfair_lock_s **)(v5 + 40), this);
  return this;
}

void sub_1B2C09ADC(_Unwind_Exception *a1)
{
  ProGL::GL *v1;
  uint64_t v2;

  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v2);
  ProGL::GL::~GL(v1);
  _Unwind_Resume(a1);
}

void ProGL::UseProgramSentry::~UseProgramSentry(ProGL::Private::ProgramHandleImpl **this)
{
  char *v2;

  v2 = (char *)(this + 5);
  ProGL::ProgramHandle::unuse(this + 5, (ProGL::GL *)this);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)v2);
  ProGL::GL::~GL((ProGL::GL *)this);
}

uint64_t ProGL::Private::initProgram(ProGL::Private *this)
{
  uint64_t v1;
  uint64_t result;

  v1 = operator new();
  result = ProGL::Private::ShaderCache::ShaderCache(v1);
  return result;
}

void sub_1B2C09B7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1020C400CA8E147);
  _Unwind_Resume(a1);
}

uint64_t ProGL::Private::cleanUpProgram(ProGL::Private *this)
{
  PCSpinLock *v1;
  uint64_t result;

  {
    PCSpinLock::~PCSpinLock(v1);
    result = MEMORY[0x1B5E29170]();
  }
  return result;
}

void `anonymous namespace'::DeleteProgramInstruction::~DeleteProgramInstruction(OZChannelBase *this)
{
  const PCString *v2;

  this->var0 = (void **)&off_1E654B350;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);
  OZChannelBase::setRangeName(this, v2);
}

{
  const PCString *v2;

  this->var0 = (void **)&off_1E654B350;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);
  OZChannelBase::setRangeName(this, v2);
  JUMPOUT(0x1B5E29170);
}

void `anonymous namespace'::DeleteProgramInstruction::execute(_anonymous_namespace_::DeleteProgramInstruction *this)
{
  _BYTE v2[16];
  _BYTE v3[40];

  ProGL::getDeletionContext((os_unfair_lock_s **)this + 2, (const ProGL::ContextHandle *)*((unsigned int *)this + 8), (ProGL::ContextHandle *)v2);
  ProGL::GL::GL((ProGL::GL *)v3, (const ProGL::ContextHandle *)v2);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v2);
  glDeleteProgram(*((_DWORD *)this + 2));
  ProGL::GL::~GL((ProGL::GL *)v3);
}

void sub_1B2C09CBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  ProGL::GL::~GL((ProGL::GL *)va);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(a1, *(_QWORD *)a2);
    std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(a1, *((_QWORD *)a2 + 1));
    if (a2[63] < 0)
      operator delete(*((void **)a2 + 5));
    operator delete(a2);
  }
}

void std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>,0>(uint64_t a1)
{
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](a1 + 56);
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
}

uint64_t **std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  unsigned int v8;
  uint64_t **v9;
  unsigned int v10;
  _DWORD *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = operator new(0x40uLL);
    v11[8] = **a4;
    *((_QWORD *)v11 + 6) = 0;
    *((_QWORD *)v11 + 7) = 0;
    *((_QWORD *)v11 + 5) = 0;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

_QWORD *std::shared_ptr<std::string>::shared_ptr[abi:ne180100]<std::string,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1E654B390;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1B2C09ED8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  a10 = 0;
  if (v10)
    std::default_delete<std::string>::operator()[abi:ne180100]((uint64_t)&a10, v10);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<std::string *,std::shared_ptr<std::string>::__shared_ptr_default_delete<std::string,std::string>,std::allocator<std::string>>::__on_zero_shared(uint64_t a1)
{
  std::default_delete<std::string>::operator()[abi:ne180100](a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<std::string *,std::shared_ptr<std::string>::__shared_ptr_default_delete<std::string,std::string>,std::allocator<std::string>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::default_delete<std::string>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(char *)(a2 + 23) < 0)
      operator delete(*(void **)a2);
    JUMPOUT(0x1B5E29170);
  }
}

void std::__introsort<std::_ClassicAlgPolicy,`anonymous namespace'::StrPtrLess &,std::shared_ptr<std::string> *,false>(uint64_t a1, const void ***a2, uint64_t a3, char a4)
{
  const void ***v8;
  uint64_t v9;
  __int128 *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  _OWORD *v14;
  __int128 v15;
  uint64_t v16;
  unint64_t v17;
  const void ***v18;
  BOOL v19;
  unint64_t v20;
  const void ***v21;
  const void **v22;
  const void **v23;
  __int128 *v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  BOOL v28;
  const void ***v29;
  _BOOL4 v30;
  const void ***v31;
  const void **v32;
  const void **v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  const void **v37;
  const void **v38;
  const void ***v39;
  uint64_t v40;
  uint64_t v41;
  const void ***v42;
  uint64_t v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  __int128 *v70;
  uint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  std::__shared_weak_count *v75;
  unint64_t *v76;
  unint64_t v77;
  const void ***v79;
  const void ***v80;
  std::__shared_weak_count *v81;
  unint64_t *v82;
  unint64_t v83;
  uint64_t v84;
  unint64_t v85;
  __int128 v86;
  __int128 v87;

BOOL `anonymous namespace'::StrPtrLess::operator()(const void ***a1, const void ***a2)
{
  int v2;
  int v3;
  size_t v4;
  const void *v5;
  size_t v6;
  const void *v7;
  size_t v8;
  int v9;

  v2 = *((char *)*a2 + 23);
  v3 = *((char *)*a1 + 23);
  if (v3 >= 0)
    v4 = *((unsigned __int8 *)*a1 + 23);
  else
    v4 = (size_t)(*a1)[1];
  if (v3 >= 0)
    v5 = *a1;
  else
    v5 = **a1;
  if (v2 >= 0)
    v6 = *((unsigned __int8 *)*a2 + 23);
  else
    v6 = (size_t)(*a2)[1];
  if (v2 >= 0)
    v7 = *a2;
  else
    v7 = **a2;
  if (v6 >= v4)
    v8 = v4;
  else
    v8 = v6;
  v9 = memcmp(v5, v7, v8);
  if (v9)
    return v9 < 0;
  else
    return v4 < v6;
}

BOOL std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,`anonymous namespace'::StrPtrLess &,std::shared_ptr<std::string> *,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 result;
  const void **v11;
  uint64_t v12;
  const void **v13;
  uint64_t v14;
  const void **v15;
  uint64_t v16;
  const void **v17;
  uint64_t v18;

  if (result)
  {
    v11 = *(const void ***)a4;
    *(_QWORD *)a4 = *(_QWORD *)a5;
    *(_QWORD *)a5 = v11;
    v12 = *(_QWORD *)(a4 + 8);
    *(_QWORD *)(a4 + 8) = *(_QWORD *)(a5 + 8);
    *(_QWORD *)(a5 + 8) = v12;
    if (result)
    {
      v13 = *(const void ***)a3;
      *(_QWORD *)a3 = *(_QWORD *)a4;
      *(_QWORD *)a4 = v13;
      v14 = *(_QWORD *)(a3 + 8);
      *(_QWORD *)(a3 + 8) = *(_QWORD *)(a4 + 8);
      *(_QWORD *)(a4 + 8) = v14;
      if (result)
      {
        v15 = *(const void ***)a2;
        *(_QWORD *)a2 = *(_QWORD *)a3;
        *(_QWORD *)a3 = v15;
        v16 = *(_QWORD *)(a2 + 8);
        *(_QWORD *)(a2 + 8) = *(_QWORD *)(a3 + 8);
        *(_QWORD *)(a3 + 8) = v16;
        if (result)
        {
          v17 = *(const void ***)a1;
          *(_QWORD *)a1 = *(_QWORD *)a2;
          *(_QWORD *)a2 = v17;
          v18 = *(_QWORD *)(a1 + 8);
          *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
          *(_QWORD *)(a2 + 8) = v18;
        }
      }
    }
  }
  return result;
}

BOOL std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,`anonymous namespace'::StrPtrLess &,std::shared_ptr<std::string> *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v6;
  _BOOL8 result;
  const void **v8;
  uint64_t *v9;
  uint64_t *v10;
  const void **v11;
  uint64_t v12;
  uint64_t *v13;
  const void **v14;
  uint64_t v15;
  const void **v16;
  uint64_t v17;

  if (v6)
  {
    v8 = *(const void ***)a1;
    if (result)
    {
      *(_QWORD *)a1 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v8;
      v9 = (uint64_t *)(a3 + 8);
      v10 = (uint64_t *)(a1 + 8);
    }
    else
    {
      *(_QWORD *)a1 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v8;
      v15 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 8) = v15;
      if (!result)
        return result;
      v16 = *(const void ***)a2;
      *(_QWORD *)a2 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v16;
      v9 = (uint64_t *)(a3 + 8);
      v10 = (uint64_t *)(a2 + 8);
    }
    v13 = v9;
    goto LABEL_10;
  }
  if (result)
  {
    v11 = *(const void ***)a2;
    *(_QWORD *)a2 = *(_QWORD *)a3;
    *(_QWORD *)a3 = v11;
    v13 = (uint64_t *)(a2 + 8);
    v12 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 8) = *(_QWORD *)(a3 + 8);
    *(_QWORD *)(a3 + 8) = v12;
    if (result)
    {
      v14 = *(const void ***)a1;
      *(_QWORD *)a1 = *(_QWORD *)a2;
      v10 = (uint64_t *)(a1 + 8);
      *(_QWORD *)a2 = v14;
LABEL_10:
      v17 = *v10;
      *v10 = *v13;
      *v13 = v17;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,`anonymous namespace'::StrPtrLess &,std::shared_ptr<std::string> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  const void **v6;
  uint64_t v7;
  const void ***v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  __int128 v18;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      {
        v6 = *(const void ***)a1;
        *(_QWORD *)a1 = *(_QWORD *)(a2 - 16);
        *(_QWORD *)(a2 - 16) = v6;
        v7 = *(_QWORD *)(a1 + 8);
        *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 - 8);
        *(_QWORD *)(a2 - 8) = v7;
      }
      return 1;
    case 3:
      return 1;
    case 4:
      return 1;
    case 5:
      return 1;
    default:
      v8 = (const void ***)(a1 + 32);
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    {
      v18 = *(_OWORD *)v9;
      *(_QWORD *)v9 = 0;
      *(_QWORD *)(v9 + 8) = 0;
      v12 = v10;
      while (1)
      {
        std::shared_ptr<TXTextObject>::operator=[abi:ne180100](a1 + v12 + 48, (__int128 *)(a1 + v12 + 32));
        if (v12 == -32)
          break;
        v12 -= 16;
        if (!v13)
        {
          v14 = a1 + v12 + 48;
          goto LABEL_12;
        }
      }
      v14 = a1;
LABEL_12:
      std::shared_ptr<TXTextObject>::operator=[abi:ne180100](v14, &v18);
      v15 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
      if (*((_QWORD *)&v18 + 1))
      {
        v16 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
        do
          v17 = __ldaxr(v16);
        while (__stlxr(v17 - 1, v16));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (const void ***)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

BOOL std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,`anonymous namespace'::StrPtrLess &,std::shared_ptr<std::string> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _BOOL8 result;
  const void **v9;
  uint64_t v10;
  const void **v11;
  uint64_t v12;
  const void **v13;
  uint64_t v14;

  if (result)
  {
    v9 = *(const void ***)a3;
    *(_QWORD *)a3 = *(_QWORD *)a4;
    *(_QWORD *)a4 = v9;
    v10 = *(_QWORD *)(a3 + 8);
    *(_QWORD *)(a3 + 8) = *(_QWORD *)(a4 + 8);
    *(_QWORD *)(a4 + 8) = v10;
    if (result)
    {
      v11 = *(const void ***)a2;
      *(_QWORD *)a2 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v11;
      v12 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 8) = *(_QWORD *)(a3 + 8);
      *(_QWORD *)(a3 + 8) = v12;
      if (result)
      {
        v13 = *(const void ***)a1;
        *(_QWORD *)a1 = *(_QWORD *)a2;
        *(_QWORD *)a2 = v13;
        v14 = *(_QWORD *)(a1 + 8);
        *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
        *(_QWORD *)(a2 + 8) = v14;
      }
    }
  }
  return result;
}

uint64_t **std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,std::string>>(uint64_t **a1, unsigned int *a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unsigned int v7;
  uint64_t **v8;
  unsigned int v9;
  char *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (char *)operator new(0x40uLL);
    *((_DWORD *)v10 + 8) = *(_DWORD *)a3;
    *(_OWORD *)(v10 + 40) = *(_OWORD *)(a3 + 8);
    *((_QWORD *)v10 + 7) = *(_QWORD *)(a3 + 24);
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)(a3 + 24) = 0;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, (uint64_t)v8, v6, (uint64_t *)v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void std::__shared_ptr_pointer<`anonymous namespace'::DeleteProgramInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,`anonymous namespace'::DeleteProgramInstruction>,std::allocator<`anonymous namespace'::DeleteProgramInstruction>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

uint64_t std::__shared_ptr_pointer<`anonymous namespace'::DeleteProgramInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,`anonymous namespace'::DeleteProgramInstruction>,std::allocator<`anonymous namespace'::DeleteProgramInstruction>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<`anonymous namespace'::DeleteProgramInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,`anonymous namespace'::DeleteProgramInstruction>,std::allocator<`anonymous namespace'::DeleteProgramInstruction>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

_QWORD *std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::find<ProGL::Private::ProgramHandleImpl::ContextKey>(uint64_t a1, ProGL::ContextHandle *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  ProGL::ContextHandle *v6;
  unint64_t EAGLContext;

  v3 = (_QWORD *)(a1 + 8);
  v4 = std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__lower_bound<ProGL::Private::ProgramHandleImpl::ContextKey>(a1, a2, *(_QWORD **)(a1 + 8), (_QWORD *)(a1 + 8));
  if (v3 == v4)
    return v3;
  v5 = v4;
  v6 = (ProGL::ContextHandle *)(v4 + 4);
  EAGLContext = ProGL::ContextHandle::getEAGLContext(a2);
  if (EAGLContext < ProGL::ContextHandle::getEAGLContext(v6))
    return v3;
  return v5;
}

_QWORD *std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__lower_bound<ProGL::Private::ProgramHandleImpl::ContextKey>(uint64_t a1, ProGL::ContextHandle *a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *v5;
  unint64_t EAGLContext;
  unint64_t v8;
  _QWORD *v9;

  if (a3)
  {
    v5 = a3;
    do
    {
      EAGLContext = ProGL::ContextHandle::getEAGLContext((ProGL::ContextHandle *)(v5 + 4));
      v8 = ProGL::ContextHandle::getEAGLContext(a2);
      v9 = v5 + 1;
      if (EAGLContext >= v8)
      {
        v9 = v5;
        a4 = v5;
      }
      v5 = (_QWORD *)*v9;
    }
    while (*v9);
  }
  return a4;
}

uint64_t *std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::erase(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v3;

  v3 = std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer(a1, a2);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)(a2 + 6));
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(a2 + 4));
  operator delete(a2);
  return v3;
}

uint64_t *std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__emplace_unique_key_args<ProGL::Private::ProgramHandleImpl::ContextKey,std::pair<ProGL::Private::ProgramHandleImpl::ContextKey const,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>(uint64_t **a1, ProGL::ContextHandle *this, __n128 *a3)
{
  uint64_t **v5;
  uint64_t *result;
  uint64_t *v7;
  uint64_t v8;

  v5 = (uint64_t **)std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__find_equal<ProGL::Private::ProgramHandleImpl::ContextKey>((uint64_t)a1, &v8, this);
  result = *v5;
  if (!*v5)
  {
    std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__construct_node<std::pair<ProGL::Private::ProgramHandleImpl::ContextKey const,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>((uint64_t)a1, a3, (uint64_t)&v7);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v8, v5, v7);
    return v7;
  }
  return result;
}

_QWORD *std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__find_equal<ProGL::Private::ProgramHandleImpl::ContextKey>(uint64_t a1, _QWORD *a2, ProGL::ContextHandle *this)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v7;
  ProGL::ContextHandle *v8;
  unint64_t EAGLContext;
  unint64_t v10;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v7 = v4;
        v8 = (ProGL::ContextHandle *)(v4 + 4);
        EAGLContext = ProGL::ContextHandle::getEAGLContext(this);
        if (EAGLContext >= ProGL::ContextHandle::getEAGLContext(v8))
          break;
        v4 = (_QWORD *)*v7;
        v5 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      v10 = ProGL::ContextHandle::getEAGLContext(v8);
      if (v10 >= ProGL::ContextHandle::getEAGLContext(this))
        break;
      v5 = v7 + 1;
      v4 = (_QWORD *)v7[1];
    }
    while (v4);
  }
  else
  {
    v7 = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

__n128 std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__construct_node<std::pair<ProGL::Private::ProgramHandleImpl::ContextKey const,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>@<Q0>(uint64_t a1@<X0>, __n128 *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  __n128 *v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  __n128 result;

  v5 = a1 + 8;
  v6 = (__n128 *)operator new(0x50uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  v7 = a2->n128_u64[1];
  v6[2].n128_u64[0] = a2->n128_u64[0];
  v6[2].n128_u64[1] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  result = a2[1];
  v6[3] = result;
  a2[1].n128_u64[0] = 0;
  a2[1].n128_u64[1] = 0;
  v6[4].n128_u64[0] = a2[2].n128_u64[0];
  v6[4].n128_u8[8] = a2[2].n128_u8[8];
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

ProGL::Private::Shader *ProGL::Private::Shader::Shader(ProGL::Private::Shader *this, ProGL::GL *a2, unsigned int a3, const char *a4)
{
  ProGL::ContextHandle *v6;
  ProGL::GL *v7;

  v6 = (ProGL::ContextHandle *)(ProGL::Private::ShaderString::ShaderString(this, a3, a4) + 48);
  ProGL::GL::getPGLContextHandle(a2, v6);
  *((_DWORD *)this + 16) = ProGL::ContextHandle::getVirtualScreen(v6);
  *(_QWORD *)((char *)this + 68) = 0;
  *(_QWORD *)((char *)this + 84) = 0;
  *(_QWORD *)((char *)this + 76) = 0;
  *((_DWORD *)this + 23) = 0;
  ProGL::Private::Shader::compile(this, v7);
  return this;
}

void sub_1B2C0B1F8(_Unwind_Exception *a1)
{
  uint64_t v1;
  ProGL::ContextHandle *v2;

  if (*(char *)(v1 + 95) < 0)
    operator delete(*(void **)(v1 + 72));
  ProGL::ContextHandle::~ContextHandle(v2);
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void ProGL::Private::Shader::compile(ProGL::Private::Shader *this, ProGL::GL *a2)
{
  GLenum Size;
  GLuint v4;
  GLuint v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *end;
  unint64_t *v15;
  unint64_t v16;
  std::vector<char> params;
  GLsizei length;
  GLchar *string;

  Size = PVPerfStats::FrameStats::GetSize(this);
  *((_DWORD *)this + 17) = glCreateShader(Size);
  string = (GLchar *)ProGL::Private::ShaderString::c_str(this);
  glShaderSource(*((_DWORD *)this + 17), 1, (const GLchar *const *)&string, 0);
  glCompileShader(*((_DWORD *)this + 17));
  v4 = *((_DWORD *)this + 17);
  LODWORD(params.__begin_) = 0;
  glGetShaderiv(v4, 0x8B81u, (GLint *)&params);
  if (!LODWORD(params.__begin_))
  {
    v5 = *((_DWORD *)this + 17);
    LODWORD(params.__begin_) = 0;
    glGetShaderiv(v5, 0x8B84u, (GLint *)&params);
    length = (GLsizei)params.__begin_;
    if (SLODWORD(params.__begin_) < 2)
    {
      MEMORY[0x1B5E28D80]((char *)this + 72, "Shader compile() member function failed; error unknown.");
    }
    else
    {
      std::vector<char>::vector(&params, LODWORD(params.__begin_));
      glGetShaderInfoLog(*((_DWORD *)this + 17), LODWORD(params.__end_) - LODWORD(params.__begin_), &length, params.__begin_);
      std::string::__assign_trivial[abi:ne180100]<std::__wrap_iter<char *>,std::__wrap_iter<char *>>((std::string *)this + 3, params.__begin_, params.__end_, params.__end_ - params.__begin_);
      if (params.__begin_)
      {
        params.__end_ = params.__begin_;
        operator delete(params.__begin_);
      }
    }
    v6 = operator new();
    v7 = v6;
    v8 = *((_DWORD *)this + 16);
    v9 = *((_DWORD *)this + 17);
    *(_QWORD *)v6 = &off_1E654B480;
    *(_DWORD *)(v6 + 8) = v9;
    v10 = *((_QWORD *)this + 7);
    *(_QWORD *)(v6 + 16) = *((_QWORD *)this + 6);
    *(_QWORD *)(v6 + 24) = v10;
    if (v10)
    {
      v11 = (unint64_t *)(v10 + 8);
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
    *(_DWORD *)(v6 + 32) = v8;
    params.__begin_ = (std::vector<char>::pointer)v6;
    v13 = operator new();
    *(_QWORD *)v13 = &off_1E654B4C0;
    *(_QWORD *)(v13 + 8) = 0;
    *(_QWORD *)(v13 + 16) = 0;
    *(_QWORD *)(v13 + 24) = v7;
    params.__end_ = (std::vector<char>::pointer)v13;
    ProGL::postDeletionInstruction((__int128 *)&params);
    end = (std::__shared_weak_count *)params.__end_;
    if (params.__end_)
    {
      v15 = (unint64_t *)(params.__end_ + 8);
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))end->__on_zero_shared)(end);
        std::__shared_weak_count::__release_weak(end);
      }
    }
    *((_DWORD *)this + 17) = 0;
  }
}

void sub_1B2C0B3F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)&__p);
  _Unwind_Resume(a1);
}

void ProGL::Private::Shader::~Shader(ProGL::Private::Shader *this)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  __int128 v13;

  if (*((_DWORD *)this + 17))
  {
    v2 = operator new();
    v3 = v2;
    v4 = *((_DWORD *)this + 16);
    v5 = *((_DWORD *)this + 17);
    *(_QWORD *)v2 = &off_1E654B480;
    *(_DWORD *)(v2 + 8) = v5;
    v6 = *((_QWORD *)this + 7);
    *(_QWORD *)(v2 + 16) = *((_QWORD *)this + 6);
    *(_QWORD *)(v2 + 24) = v6;
    if (v6)
    {
      v7 = (unint64_t *)(v6 + 8);
      do
        v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
    }
    *(_DWORD *)(v2 + 32) = v4;
    *(_QWORD *)&v13 = v2;
    v9 = (_QWORD *)operator new();
    *v9 = &off_1E654B4C0;
    v9[1] = 0;
    v9[2] = 0;
    v9[3] = v3;
    *((_QWORD *)&v13 + 1) = v9;
    ProGL::postDeletionInstruction(&v13);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
    if (*((_QWORD *)&v13 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
  if (*((char *)this + 95) < 0)
    operator delete(*((void **)this + 9));
  ProGL::ContextHandle::~ContextHandle((ProGL::Private::Shader *)((char *)this + 48));
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

void sub_1B2C0B550(void *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  __clang_call_terminate(a1);
}

BOOL ProGL::Private::Shader::good(ProGL::Private::Shader *this)
{
  uint64_t v1;

  if (*((char *)this + 95) < 0)
    v1 = *((_QWORD *)this + 10);
  else
    v1 = *((unsigned __int8 *)this + 95);
  return v1 == 0;
}

_QWORD *ProGL::Private::makeShader@<X0>(ProGL::Private *this@<X0>, ProGL::GL *a2@<X1>, const char *a3@<X2>, _QWORD *a4@<X8>)
{
  unsigned int v6;
  ProGL::Private::Shader *v9;

  v6 = a2;
  v9 = (ProGL::Private::Shader *)operator new();
  ProGL::Private::Shader::Shader(v9, this, v6, a3);
  return std::shared_ptr<ProGL::Private::Shader>::shared_ptr[abi:ne180100]<ProGL::Private::Shader,void>(a4, (uint64_t)v9);
}

void sub_1B2C0B600(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1032C40C2FE074CLL);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::DeleteShaderInstruction::~DeleteShaderInstruction(OZChannelBase *this)
{
  const PCString *v2;

  this->var0 = (void **)&off_1E654B480;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);
  OZChannelBase::setRangeName(this, v2);
}

{
  const PCString *v2;

  this->var0 = (void **)&off_1E654B480;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);
  OZChannelBase::setRangeName(this, v2);
  JUMPOUT(0x1B5E29170);
}

void `anonymous namespace'::DeleteShaderInstruction::execute(_anonymous_namespace_::DeleteShaderInstruction *this)
{
  _BYTE v2[16];
  _BYTE v3[40];

  ProGL::getDeletionContext((os_unfair_lock_s **)this + 2, (const ProGL::ContextHandle *)*((unsigned int *)this + 8), (ProGL::ContextHandle *)v2);
  ProGL::GL::GL((ProGL::GL *)v3, (const ProGL::ContextHandle *)v2);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v2);
  glDeleteShader(*((_DWORD *)this + 2));
  ProGL::GL::~GL((ProGL::GL *)v3);
}

void sub_1B2C0B6F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  ProGL::GL::~GL((ProGL::GL *)va);
  _Unwind_Resume(a1);
}

void std::string::__assign_trivial[abi:ne180100]<std::__wrap_iter<char *>,std::__wrap_iter<char *>>(std::string *this, std::string::value_type *a2, std::string::value_type *a3, std::string::size_type a4)
{
  std::string *v8;
  std::string::size_type size;
  std::string::size_type v10;
  unint64_t v11;
  unint64_t v12;
  std::string::value_type v13;

  if ((SHIBYTE(this->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v8 = this;
    if (a4 <= 0x16)
      goto LABEL_11;
    size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    v10 = 22;
    goto LABEL_6;
  }
  v11 = this->__r_.__value_.__r.__words[2];
  v10 = (v11 & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v10 < a4)
  {
    size = this->__r_.__value_.__l.__size_;
LABEL_6:
    std::string::__grow_by(this, v10, a4 - v10, size, 0, size, 0);
    this->__r_.__value_.__l.__size_ = 0;
    LOBYTE(v12) = *((_BYTE *)&this->__r_.__value_.__s + 23);
    goto LABEL_8;
  }
  v12 = HIBYTE(v11);
LABEL_8:
  v8 = this;
  if ((v12 & 0x80) != 0)
    v8 = (std::string *)this->__r_.__value_.__r.__words[0];
LABEL_11:
  while (a2 != a3)
  {
    v13 = *a2++;
    v8->__r_.__value_.__s.__data_[0] = v13;
    v8 = (std::string *)((char *)v8 + 1);
  }
  v8->__r_.__value_.__s.__data_[0] = 0;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
    this->__r_.__value_.__l.__size_ = a4;
  else
    *((_BYTE *)&this->__r_.__value_.__s + 23) = a4 & 0x7F;
}

void std::__shared_ptr_pointer<`anonymous namespace'::DeleteShaderInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,`anonymous namespace'::DeleteShaderInstruction>,std::allocator<`anonymous namespace'::DeleteShaderInstruction>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

uint64_t std::__shared_ptr_pointer<`anonymous namespace'::DeleteShaderInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,`anonymous namespace'::DeleteShaderInstruction>,std::allocator<`anonymous namespace'::DeleteShaderInstruction>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<`anonymous namespace'::DeleteShaderInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,`anonymous namespace'::DeleteShaderInstruction>,std::allocator<`anonymous namespace'::DeleteShaderInstruction>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

_QWORD *std::shared_ptr<ProGL::Private::Shader>::shared_ptr[abi:ne180100]<ProGL::Private::Shader,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1E654B538;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1B2C0B8C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<ProGL::Private::Shader>::reset[abi:ne180100]((ProGL::Private::Shader **)va, 0);
  _Unwind_Resume(a1);
}

ProGL::Private::Shader *std::__shared_ptr_pointer<ProGL::Private::Shader *,std::shared_ptr<ProGL::Private::Shader>::__shared_ptr_default_delete<ProGL::Private::Shader,ProGL::Private::Shader>,std::allocator<ProGL::Private::Shader>>::__on_zero_shared(uint64_t a1)
{
  ProGL::Private::Shader *result;

  result = *(ProGL::Private::Shader **)(a1 + 24);
  if (result)
  {
    ProGL::Private::Shader::~Shader(result);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<ProGL::Private::Shader *,std::shared_ptr<ProGL::Private::Shader>::__shared_ptr_default_delete<ProGL::Private::Shader,ProGL::Private::Shader>,std::allocator<ProGL::Private::Shader>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

ProGL::Private::Shader *std::unique_ptr<ProGL::Private::Shader>::reset[abi:ne180100](ProGL::Private::Shader **a1, ProGL::Private::Shader *a2)
{
  ProGL::Private::Shader *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    ProGL::Private::Shader::~Shader(result);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

uint64_t ProGL::Private::ShaderCache::ShaderCache(uint64_t this)
{
  *(_QWORD *)(this + 16) = 0;
  *(_DWORD *)this = 0;
  *(_QWORD *)(this + 8) = this + 16;
  *(_QWORD *)(this + 32) = 0;
  *(_QWORD *)(this + 40) = 0;
  *(_QWORD *)(this + 24) = 0;
  return this;
}

void ProGL::Private::ShaderCache::find(uint64_t **this@<X0>, ProGL::GL *a2@<X1>, const char *a3@<X3>, ProGL::GL *a4@<X2>, _QWORD *a5@<X8>)
{
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  ProGL::Private::ShaderCache *v24;
  PC_Sp_counted_base *v25;
  std::__shared_weak_count *v26;
  void *__p;
  char v28;
  std::__shared_weak_count *v29;
  PCSharedCount v30;
  std::__shared_weak_count *v31;
  uint64_t *v32;
  ProGL::Private::ShaderCache *v33;
  uint64_t v34;
  void *v35[3];
  char v36;

  ProGL::GL::getPGLContextHandle(a2, &v25);
  ProGL::ContextHandle::getShareGroup((os_unfair_lock_s **)&v25, &v30);
  ProGL::ShareGroup::ShareGroup(&v34, &v30);
  ProGL::Private::ShaderString::ShaderString((ProGL::Private::ShaderString *)v35, a4, a3);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v25);
  *a5 = 0;
  a5[1] = 0;
  v33 = (ProGL::Private::ShaderCache *)this;
  PCSpinLock::lock((os_unfair_lock_t)this);
  v10 = std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::find<ProGL::Private::ShaderCache::Key>((uint64_t)(this + 1), &v34);
  if (this + 2 != (uint64_t **)v10)
  {
    v11 = (uint64_t)this[4];
    this[4] = (uint64_t *)(v11 + 1);
    v10[13] = v11;
    std::shared_ptr<TXTextStyle>::operator=[abi:ne180100](a5, v10 + 11);
    ProGL::Private::ShaderCache::maybePurge((ProGL::Private::ShaderCache *)this);
LABEL_25:
    PCSpinLock::unlock((os_unfair_lock_t)this);
    goto LABEL_26;
  }
  ProGL::Private::makeShader(a2, a4, a3, &v25);
  v12 = this[4];
  this[4] = (uint64_t *)((char *)v12 + 1);
  v30.var0 = v25;
  v31 = v26;
  if (v26)
  {
    p_shared_owners = (unint64_t *)&v26->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
    v15 = v26;
    v32 = v12;
    if (v26)
    {
      v16 = (unint64_t *)&v26->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
  else
  {
    v32 = v12;
  }
  std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>::pair[abi:ne180100]<ProGL::Private::ShaderCache::Key&,ProGL::Private::ShaderCache::Value&,0>((uint64_t)&v25, (uint64_t)&v34, &v30);
  std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::__emplace_unique_key_args<ProGL::Private::ShaderCache::Key,std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>>(this + 1, &v25, (uint64_t)&v25);
  v18 = v29;
  if (v29)
  {
    v19 = (unint64_t *)&v29->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  if (v28 < 0)
    operator delete(__p);
  std::shared_ptr<TXTextStyle>::operator=[abi:ne180100](a5, (uint64_t *)&v30);
  v21 = v31;
  if (v31)
  {
    v22 = (unint64_t *)&v31->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = v33;
  ProGL::Private::ShaderCache::maybePurge((ProGL::Private::ShaderCache *)this);
  this = (uint64_t **)v24;
  if (v24)
    goto LABEL_25;
LABEL_26:
  if (v36 < 0)
    operator delete(v35[1]);
}

void sub_1B2C0BBDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;
  uint64_t v18;
  uint64_t v19;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v16 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  v19 = va_arg(va2, _QWORD);
  std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>::~pair((uint64_t)va);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va2);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v2);
  if (*(char *)(v3 - 65) < 0)
    operator delete(*(void **)(v3 - 88));
  _Unwind_Resume(a1);
}

uint64_t std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>::~pair(uint64_t a1)
{
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](a1 + 56);
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void ProGL::Private::ShaderCache::maybePurge(ProGL::Private::ShaderCache *this)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  BOOL v11;
  uint64_t *v12;
  uint64_t *v13;

  v2 = *((_QWORD *)this + 3);
  v3 = *((_QWORD *)this + 5);
  if (v3 > v2)
  {
    v4 = *((_QWORD *)this + 4);
    if (v4 >= 2 * v2)
    {
      v5 = (uint64_t *)*((_QWORD *)this + 1);
      v6 = (uint64_t *)((char *)this + 16);
      if (v5 != (uint64_t *)((char *)this + 16))
      {
        v7 = v4 - 2 * v2;
        do
        {
          v8 = v5[12];
          if (v8 && *(uint64_t *)(v8 + 8) > 0 || v5[13] > v7)
          {
            v9 = (uint64_t *)v5[1];
            if (v9)
            {
              do
              {
                v10 = v9;
                v9 = (uint64_t *)*v9;
              }
              while (v9);
            }
            else
            {
              do
              {
                v10 = (uint64_t *)v5[2];
                v11 = *v10 == (_QWORD)v5;
                v5 = v10;
              }
              while (!v11);
            }
          }
          else
          {
            v12 = (uint64_t *)v5[1];
            v13 = v5;
            if (v12)
            {
              do
              {
                v10 = v12;
                v12 = (uint64_t *)*v12;
              }
              while (v12);
            }
            else
            {
              do
              {
                v10 = (uint64_t *)v13[2];
                v11 = *v10 == (_QWORD)v13;
                v13 = v10;
              }
              while (!v11);
            }
            std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)this + 1, v5);
            std::__destroy_at[abi:ne180100]<std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>,0>((uint64_t)(v5 + 4));
            operator delete(v5);
          }
          v5 = v10;
        }
        while (v10 != v6);
      }
    }
    v3 = 0;
  }
  *((_QWORD *)this + 5) = v3 + 1;
}

uint64_t std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>::pair[abi:ne180100]<ProGL::Private::ShaderCache::Key&,ProGL::Private::ShaderCache::Value&,0>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  std::string *v7;
  __int128 v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  v6 = ProGL::ShareGroup::ShareGroup((_QWORD *)a1, (_QWORD *)a2);
  *((_DWORD *)v6 + 2) = *(_DWORD *)(a2 + 8);
  v7 = (std::string *)(v6 + 2);
  if (*(char *)(a2 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a2 + 16), *(_QWORD *)(a2 + 24));
  }
  else
  {
    v8 = *(_OWORD *)(a2 + 16);
    v7->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 32);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  v9 = a3[1];
  *(_QWORD *)(a1 + 56) = *a3;
  *(_QWORD *)(a1 + 64) = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  *(_QWORD *)(a1 + 72) = a3[2];
  return a1;
}

_QWORD *std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::find<ProGL::Private::ShaderCache::Key>(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;

  v3 = (_QWORD *)(a1 + 8);
  v4 = std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::__lower_bound<ProGL::Private::ShaderCache::Key>(a1, a2, *(_QWORD **)(a1 + 8), (_QWORD *)(a1 + 8));
  if (v3 == v4)
    return v3;
  v5 = v4;
  if (ProGL::operator<(a2, v4 + 4) || ProGL::Private::operator<((uint64_t)(a2 + 1), (uint64_t)(v5 + 5)))
    return v3;
  return v5;
}

_QWORD *std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::__lower_bound<ProGL::Private::ShaderCache::Key>(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *v5;
  uint64_t v7;

  if (a3)
  {
    v5 = a3;
    v7 = (uint64_t)(a2 + 1);
    do
    {
      if (ProGL::operator<(v5 + 4, a2) || ProGL::Private::operator<((uint64_t)(v5 + 5), v7))
        ++v5;
      else
        a4 = v5;
      v5 = (_QWORD *)*v5;
    }
    while (v5);
  }
  return a4;
}

uint64_t *std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::__emplace_unique_key_args<ProGL::Private::ShaderCache::Key,std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>>(uint64_t **a1, _QWORD *a2, uint64_t a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t *v9[3];
  uint64_t v10;

  v5 = (uint64_t **)std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::__find_equal<ProGL::Private::ShaderCache::Key>((uint64_t)a1, &v10, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = v5;
    std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::__construct_node<std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>>((uint64_t)a1, a3, (uint64_t)v9);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v10, v7, v9[0]);
    v6 = v9[0];
    v9[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,void *>>>>::reset[abi:ne180100]((uint64_t)v9, 0);
  }
  return v6;
}

_QWORD *std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::__find_equal<ProGL::Private::ShaderCache::Key>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    v7 = (uint64_t)(a3 + 1);
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = v4 + 4;
        if (!ProGL::operator<(a3, v4 + 4) && !ProGL::Private::operator<(v7, (uint64_t)(v8 + 5)))
          break;
        v4 = (_QWORD *)*v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_12;
      }
      if (!ProGL::operator<(v9, a3) && !ProGL::Private::operator<((uint64_t)(v8 + 5), v7))
        break;
      v5 = v8 + 1;
      v4 = (_QWORD *)v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_12:
  *a2 = v8;
  return v5;
}

uint64_t std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::__construct_node<std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  void *v6;
  uint64_t result;

  v5 = a1 + 8;
  v6 = operator new(0x70uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>::pair[abi:ne180100]((uint64_t)v6 + 32, a2);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1B2C0C0C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__tree_node<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>::pair[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  std::string *v5;
  __int128 v6;

  v4 = ProGL::ShareGroup::ShareGroup((_QWORD *)a1, (_QWORD *)a2);
  *((_DWORD *)v4 + 2) = *(_DWORD *)(a2 + 8);
  v5 = (std::string *)(v4 + 2);
  if (*(char *)(a2 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a2 + 16), *(_QWORD *)(a2 + 24));
  }
  else
  {
    v6 = *(_OWORD *)(a2 + 16);
    v5->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 32);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  return a1;
}

void std::unique_ptr<std::__tree_node<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>,0>((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

ProGL::Private::ShaderString *ProGL::Private::ShaderString::ShaderString(ProGL::Private::ShaderString *this, int a2, char *__s)
{
  char *v3;
  PCWorkingColorVector *v5;
  char v6;
  char *v7;
  char *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  size_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char v18;
  int v19;
  void *__p;
  char *v22;
  char *v23;

  v3 = __s;
  *(_DWORD *)this = a2;
  v5 = (ProGL::Private::ShaderString *)((char *)this + 32);
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 1, __s);
  PCWorkingColorVector::PCWorkingColorVector(v5);
  std::vector<unsigned char>::vector(&__p, 4uLL);
  *(_DWORD *)__p = *(_DWORD *)this;
  v6 = *v3;
  if (*v3)
  {
    v7 = v22;
    do
    {
      if (v7 >= v23)
      {
        v9 = (unint64_t)__p;
        v10 = v7 - (_BYTE *)__p;
        v11 = v7 - (_BYTE *)__p + 1;
        if (v11 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v12 = v23 - (_BYTE *)__p;
        if (2 * (v23 - (_BYTE *)__p) > (unint64_t)v11)
          v11 = 2 * v12;
        if (v12 >= 0x3FFFFFFFFFFFFFFFLL)
          v13 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v13 = v11;
        if (v13)
          v14 = (char *)operator new(v13);
        else
          v14 = 0;
        v15 = &v14[v10];
        v16 = &v14[v10];
        *v16 = v6;
        v8 = v16 + 1;
        if (v7 != (char *)v9)
        {
          v17 = &v7[~v9];
          do
          {
            v18 = *--v7;
            (v17--)[(_QWORD)v14] = v18;
          }
          while (v7 != (char *)v9);
          v7 = (char *)__p;
          v15 = v14;
        }
        __p = v15;
        v22 = v8;
        v23 = &v14[v13];
        if (v7)
          operator delete(v7);
      }
      else
      {
        *v7 = v6;
        v8 = v7 + 1;
      }
      v22 = v8;
      v19 = *++v3;
      v6 = v19;
      v7 = v8;
    }
    while (v19);
  }
  else
  {
    LODWORD(v8) = (_DWORD)v22;
  }
  PCHash128::addData((int8x8_t *)v5, (const unsigned __int8 *)__p, ((_DWORD)v8 - (_DWORD)__p));
  if (__p)
  {
    v22 = (char *)__p;
    operator delete(__p);
  }
  return this;
}

void sub_1B2C0C338(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **a9, void *__p, uint64_t a11)
{
  uint64_t v11;

  if (__p)
    operator delete(__p);
  if (*(char *)(v11 + 31) < 0)
    operator delete(*a9);
  _Unwind_Resume(exception_object);
}

uint64_t ProGL::Private::ShaderString::c_str(ProGL::Private::ShaderString *this)
{
  uint64_t result;

  result = (uint64_t)this + 8;
  if (*((char *)this + 31) < 0)
    return *(_QWORD *)result;
  return result;
}

BOOL ProGL::Private::operator<(uint64_t a1, uint64_t a2)
{
  return operator<((const PCHash128 *)(a1 + 32), (const PCHash128 *)(a2 + 32));
}

void ProGL::Private::uploadUniform(ProGL::Private *this, GLint location, GLint x)
{
  glUniform1i(location, x);
}

void ProGL::Private::uploadUniform(ProGL::Private *this, GLint location, GLfloat a3)
{
  glUniform1f(location, a3);
}

void ProGL::Private::uploadUniform(int a1, GLint location, GLfloat *a3)
{
  glUniform2f(location, *a3, a3[1]);
}

void ProGL::Private::uploadUniform(int a1, GLint location, GLfloat *value)
{
  glUniformMatrix4fv(location, 1, 1u, value);
}

ProGL::Framebuffer *ProGL::Framebuffer::Framebuffer(ProGL::Framebuffer *this)
{
  _BYTE v3[40];

  ProGL::getCurrentContext(this);
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = (char *)this + 32;
  *((_QWORD *)this + 5) = 0;
  ProGL::GL::GL((ProGL::GL *)v3, this);
  glGenFramebuffers(1, (GLuint *)this + 4);
  ProGL::GL::~GL((ProGL::GL *)v3);
  return this;
}

void sub_1B2C0C448(_Unwind_Exception *a1, uint64_t a2, ...)
{
  ProGL::ContextHandle *v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  ProGL::GL::~GL((ProGL::GL *)va);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v3, *((_QWORD **)v2 + 4));
  ProGL::ContextHandle::~ContextHandle(v2);
  _Unwind_Resume(a1);
}

ProGL::Framebuffer *ProGL::Framebuffer::Framebuffer(ProGL::Framebuffer *this, ProGL::GL *a2)
{
  ProGL::GL::getPGLContextHandle(a2, this);
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = (char *)this + 32;
  *((_QWORD *)this + 5) = 0;
  glGenFramebuffers(1, (GLuint *)this + 4);
  return this;
}

void sub_1B2C0C4D0(_Unwind_Exception *a1)
{
  ProGL::ContextHandle *v1;
  uint64_t v2;

  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v2, *((_QWORD **)v1 + 4));
  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

void ProGL::Framebuffer::~Framebuffer(GLuint *this)
{
  _BYTE v2[40];

  ProGL::GL::GL((ProGL::GL *)v2, (const ProGL::ContextHandle *)this);
  glDeleteFramebuffers(1, this + 4);
  ProGL::GL::~GL((ProGL::GL *)v2);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)(this + 6), *((_QWORD **)this + 4));
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)this);
}

void ProGL::Framebuffer::bind(ProGL::Framebuffer *this, ProGL::GL *a2, GLenum target)
{
  glBindFramebuffer(target, *((_DWORD *)this + 4));
}

void ProGL::Framebuffer::unbind(ProGL::Framebuffer *this, ProGL::GL *a2, GLenum target)
{
  glBindFramebuffer(target, 0);
}

uint64_t *ProGL::Framebuffer::attach(uint64_t **this, ProGL::GL *a2, GLenum a3, GLenum a4, ProGL::Private::TextureImpl **a5, GLint a6)
{
  GLenum Target;
  GLuint Name;
  ProGL::GL *v13;

  Target = ProGL::TextureHandle::getTarget(a5);
  Name = ProGL::TextureHandle::getName(a5);
  return ProGL::Framebuffer::attach(this, v13, a3, a4, Target, Name, a6);
}

uint64_t *ProGL::Framebuffer::attach(uint64_t **this, ProGL::GL *a2, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  uint64_t *result;
  GLenum v10;
  unsigned int *v11;

  v10 = attachment;
  if (textarget - 34069 < 6 || textarget == 3553)
    glFramebufferTexture2D(target, attachment, textarget, texture, level);
  v11 = &v10;
  result = std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(this + 3, &v10, (uint64_t)&std::piecewise_construct, &v11);
  *((_DWORD *)result + 8) = textarget;
  return result;
}

uint64_t *ProGL::Framebuffer::attach(uint64_t a1, int a2, GLenum a3, GLenum a4, HGGLBlendingInfo **this)
{
  GLuint Name;
  uint64_t *result;
  GLenum v10;
  unsigned int *v11;

  v10 = a4;
  Name = ProGL::TextureHandle::getName(this);
  glFramebufferRenderbuffer(a3, a4, 0x8D41u, Name);
  v11 = &v10;
  result = std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>((uint64_t **)(a1 + 24), &v10, (uint64_t)&std::piecewise_construct, &v11);
  *((_DWORD *)result + 8) = 36161;
  return result;
}

void ProGL::Framebuffer::detach(ProGL::Framebuffer *this, ProGL::GL *a2, GLenum target, GLenum attachment)
{
  char *v4;
  char *v5;
  char *v6;
  uint64_t **v7;
  char *v8;
  GLenum v9;
  BOOL v10;
  char **v11;
  int v12;

  v6 = (char *)*((_QWORD *)this + 4);
  v4 = (char *)this + 32;
  v5 = v6;
  if (v6)
  {
    v7 = (uint64_t **)(v4 - 8);
    v8 = v4;
    do
    {
      v9 = *((_DWORD *)v5 + 7);
      v10 = v9 >= attachment;
      if (v9 >= attachment)
        v11 = (char **)v5;
      else
        v11 = (char **)(v5 + 8);
      if (v10)
        v8 = v5;
      v5 = *v11;
    }
    while (*v11);
    if (v8 != v4 && *((_DWORD *)v8 + 7) <= attachment)
    {
      v12 = *((_DWORD *)v8 + 8);
      if (v12 == 36161)
      {
        glFramebufferRenderbuffer(target, attachment, 0x8D41u, 0);
      }
      else if (v12 == 3553)
      {
        glFramebufferTexture2D(target, attachment, 0xDE1u, 0, 0);
      }
      std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer(v7, (uint64_t *)v8);
      operator delete(v8);
    }
  }
}

void ProGL::Framebuffer::detach(ProGL::Framebuffer *this, GLenum a2, GLenum a3)
{
  ProGL::GL *v6;
  _BYTE v7[40];

  ProGL::GL::GL((ProGL::GL *)v7);
  ProGL::Framebuffer::detach(this, v6, a2, a3);
  ProGL::GL::~GL((ProGL::GL *)v7);
}

void sub_1B2C0C7EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ProGL::GL::~GL((ProGL::GL *)va);
  _Unwind_Resume(a1);
}

void ProGL::getPerThreadContext(_QWORD *a1@<X8>)
{
  ProGL::Init *v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD v10[2];

  v3 = (ProGL::Init *)pthread_getspecific(*(_QWORD *)sPerThreadContexts);
  if (!v3)
  {
    ProGL::makeSharedEAGLContext(v10);
    v3 = (ProGL::Init *)operator new();
    ProGL::Init::Init(v3);
    v4 = v10[1];
    *((_QWORD *)v3 + 1) = v10[0];
    *((_QWORD *)v3 + 2) = v4;
    if (v4)
    {
      v5 = (unint64_t *)(v4 + 8);
      do
        v6 = __ldxr(v5);
      while (__stxr(v6 + 1, v5));
    }
    pthread_setspecific(*(_QWORD *)sPerThreadContexts, v3);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v10);
  }
  v7 = *((_QWORD *)v3 + 2);
  *a1 = *((_QWORD *)v3 + 1);
  a1[1] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
}

void sub_1B2C0C8C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a9);
  _Unwind_Resume(a1);
}

void ProGL::Private::initPerThreadContext(ProGL::Private *this)
{
  pthread_key_t *v1;

  if (!sPerThreadContexts)
  {
    v1 = (pthread_key_t *)operator new();
    sPerThreadContexts = (uint64_t)v1;
  }
}

void sub_1B2C0C94C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1000C4000313F17);
  _Unwind_Resume(a1);
}

uint64_t ProGL::Private::cleanUpPerThreadContext(ProGL::Private *this)
{
  uint64_t result;

  result = sPerThreadContexts;
  if (sPerThreadContexts)
    result = MEMORY[0x1B5E29170](sPerThreadContexts, 0x1000C4000313F17);
  sPerThreadContexts = 0;
  return result;
}

uint64_t PCThreadSpecific<`anonymous namespace'::Holder>::destroy(uint64_t result)
{
  ProGL::Init *v1;

  if (result)
  {
    v1 = (ProGL::Init *)result;
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(result + 8));
    ProGL::Init::~Init(v1);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

void ProGL::Private::RenderbufferHelper::makeRenderbuffer(ProGL::Private::RenderbufferHelper *this@<X0>, _QWORD *a2@<X8>)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;

  std::shared_ptr<ProGL::Private::RenderbufferImpl>::shared_ptr[abi:ne180100]<ProGL::Private::RenderbufferImpl,void>(&v10, (uint64_t)this);
  v4 = v11;
  *a2 = v10;
  a2[1] = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    v7 = v11;
    if (v11)
    {
      v8 = (unint64_t *)&v11->__shared_owners_;
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void ProGL::createMultisampleRenderbuffer(ProGL *this@<X0>, ProGL::GL *a2@<X1>, unsigned int a3@<W2>, int a4@<W3>, int a5@<W4>, _QWORD *a6@<X8>)
{
  int v9;
  ProGL::Private::RenderbufferImpl *v12;

  v9 = (int)a2;
  v12 = (ProGL::Private::RenderbufferImpl *)operator new();
  ProGL::Private::RenderbufferImpl::RenderbufferImpl(v12, this, v9, a3, a4, a5);
  ProGL::Private::RenderbufferHelper::makeRenderbuffer(v12, a6);
}

void sub_1B2C0CAFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1020C4062D53EE8);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<ProGL::Private::RenderbufferImpl>::shared_ptr[abi:ne180100]<ProGL::Private::RenderbufferImpl,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1E654B5B0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1B2C0CB84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<ProGL::Private::RenderbufferImpl>::reset[abi:ne180100]((ProGL::Private::RenderbufferImpl **)va, 0);
  _Unwind_Resume(a1);
}

ProGL::Private::RenderbufferImpl *std::__shared_ptr_pointer<ProGL::Private::RenderbufferImpl *,std::shared_ptr<ProGL::Private::RenderbufferImpl>::__shared_ptr_default_delete<ProGL::Private::RenderbufferImpl,ProGL::Private::RenderbufferImpl>,std::allocator<ProGL::Private::RenderbufferImpl>>::__on_zero_shared(uint64_t a1)
{
  ProGL::Private::RenderbufferImpl *result;

  result = *(ProGL::Private::RenderbufferImpl **)(a1 + 24);
  if (result)
  {
    ProGL::Private::RenderbufferImpl::~RenderbufferImpl(result);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<ProGL::Private::RenderbufferImpl *,std::shared_ptr<ProGL::Private::RenderbufferImpl>::__shared_ptr_default_delete<ProGL::Private::RenderbufferImpl,ProGL::Private::RenderbufferImpl>,std::allocator<ProGL::Private::RenderbufferImpl>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

ProGL::Private::RenderbufferImpl *std::unique_ptr<ProGL::Private::RenderbufferImpl>::reset[abi:ne180100](ProGL::Private::RenderbufferImpl **a1, ProGL::Private::RenderbufferImpl *a2)
{
  ProGL::Private::RenderbufferImpl *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    ProGL::Private::RenderbufferImpl::~RenderbufferImpl(result);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

void DeleteRenderbufferInstruction::~DeleteRenderbufferInstruction(OZChannelBase *this)
{
  const PCString *v2;

  this->var0 = (void **)&off_1E654B628;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);
  OZChannelBase::setRangeName(this, v2);
}

{
  const PCString *v2;

  this->var0 = (void **)&off_1E654B628;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);
  OZChannelBase::setRangeName(this, v2);
  JUMPOUT(0x1B5E29170);
}

void DeleteRenderbufferInstruction::execute(DeleteRenderbufferInstruction *this)
{
  _BYTE v2[16];
  _BYTE v3[40];

  ProGL::getDeletionContext((os_unfair_lock_s **)this + 2, (const ProGL::ContextHandle *)*((unsigned int *)this + 8), (ProGL::ContextHandle *)v2);
  ProGL::GL::GL((ProGL::GL *)v3, (const ProGL::ContextHandle *)v2);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v2);
  glDeleteRenderbuffers(1, (const GLuint *)this + 2);
  ProGL::GL::~GL((ProGL::GL *)v3);
}

void sub_1B2C0CD1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  ProGL::GL::~GL((ProGL::GL *)va);
  _Unwind_Resume(a1);
}

ProGL::Private::RenderbufferImpl *ProGL::Private::RenderbufferImpl::RenderbufferImpl(ProGL::Private::RenderbufferImpl *this, ProGL::GL *a2)
{
  ProGL::GL::getPGLContextHandle(a2, this);
  *((_DWORD *)this + 4) = ProGL::ContextHandle::getVirtualScreen(this);
  glGenRenderbuffers(1, (GLuint *)this + 5);
  glBindRenderbuffer(0x8D41u, *((_DWORD *)this + 5));
  glRenderbufferStorageMultisampleAPPLE();
  return this;
}

void sub_1B2C0CDCC(_Unwind_Exception *a1)
{
  ProGL::ContextHandle *v1;

  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

void ProGL::Private::RenderbufferImpl::~RenderbufferImpl(ProGL::Private::RenderbufferImpl *this)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  __int128 v11;

  v2 = operator new();
  v3 = *((_DWORD *)this + 4);
  v4 = *((_DWORD *)this + 5);
  *(_QWORD *)v2 = &off_1E654B628;
  *(_DWORD *)(v2 + 8) = v4;
  v5 = *((_QWORD *)this + 1);
  *(_QWORD *)(v2 + 16) = *(_QWORD *)this;
  *(_QWORD *)(v2 + 24) = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  *(_DWORD *)(v2 + 32) = v3;
  std::shared_ptr<ProGL::DeletionInstruction>::shared_ptr[abi:ne180100]<DeleteRenderbufferInstruction,void>(&v11, v2);
  ProGL::postDeletionInstruction(&v11);
  v8 = (std::__shared_weak_count *)*((_QWORD *)&v11 + 1);
  if (*((_QWORD *)&v11 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v11 + 1) + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  ProGL::ContextHandle::~ContextHandle(this);
}

_QWORD *std::shared_ptr<ProGL::DeletionInstruction>::shared_ptr[abi:ne180100]<DeleteRenderbufferInstruction,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1E654B668;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1B2C0CF0C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_pointer<DeleteRenderbufferInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,DeleteRenderbufferInstruction>,std::allocator<DeleteRenderbufferInstruction>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<DeleteRenderbufferInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,DeleteRenderbufferInstruction>,std::allocator<DeleteRenderbufferInstruction>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void ProGL::Private::Any::~Any(ProGL::Private::Any *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
}

void ProGL::getDeletionContext(os_unfair_lock_s **this@<X0>, const ProGL::ContextHandle *a2@<X1>, ProGL::ContextHandle *a3@<X8>)
{
}

uint64_t ProGL::postDeletionInstruction(__int128 *a1)
{
}

uint64_t `anonymous namespace'::DeletionThreadLoop::postInstruction(PCMutex *this, __int128 *a2)
{
  PCThread *v6;
  pthread_t *v7;
  uint64_t result;
  PCMutex *v9;

  {
    {
      v6 = (PCThread *)operator new();
      PCThread::detach(v7);
    }
    if (v9)
      PCMutex::unlock(v9);
  }
  PCMutex::lock(this);
  std::deque<std::shared_ptr<ProGL::DeletionInstruction>>::push_back(&this[1]._Mutex.__opaque[32], a2);
  result = PCConditionVariable::signal((pthread_cond_t *)&this[1]);
  if (this)
    return PCMutex::unlock(this);
  return result;
}

void sub_1B2C0D0C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  MEMORY[0x1B5E29170](v9, 0x20C4093837F09);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  _Unwind_Resume(a1);
}

PCMutex *ProGL::Private::initDeleteObjects(ProGL::Private *this)
{
  uint64_t v1;
  ProGL::SharedPerThreadAuxiliaryMap *v2;
  PCMutex *v3;
  PCMutex *result;

  v1 = operator new();
  PCMutex::PCMutex((PCMutex *)v1);
  PCConditionVariable::PCConditionVariable((PCConditionVariable *)(v1 + 72));
  *(_BYTE *)(v1 + 168) = 0;
  *(_OWORD *)(v1 + 152) = 0u;
  *(_OWORD *)(v1 + 136) = 0u;
  *(_OWORD *)(v1 + 120) = 0u;
  v2 = (ProGL::SharedPerThreadAuxiliaryMap *)operator new();
  ProGL::SharedPerThreadAuxiliaryMap::SharedPerThreadAuxiliaryMap(v2, 0x28u);
  v3 = (PCMutex *)operator new();
  result = PCMutex::PCMutex(v3);
  return result;
}

void sub_1B2C0D1B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1081C4076DFA842);
  _Unwind_Resume(a1);
}

OZChannelBase *ProGL::Private::cleanUpDeleteObjects(ProGL::Private *this, const PCString *a2)
{
  PCMutex *v2;
  _QWORD *v4;
  _QWORD *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  PCSpinLock *v11;
  uint64_t v12;
  OZChannelBase *result;
  uint64_t v14;
  __int128 v15;
  _BYTE v16[120];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  {
    PCSemaphore::PCSemaphore((PCSemaphore *)v16, 0);
    v4 = (_QWORD *)operator new();
    *v4 = &off_1E654B708;
    v4[1] = v16;
    *(_QWORD *)&v15 = v4;
    v5 = (_QWORD *)operator new();
    *v5 = &off_1E654B748;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v4;
    *((_QWORD *)&v15 + 1) = v5;
    v6 = (std::__shared_weak_count *)*((_QWORD *)&v15 + 1);
    if (*((_QWORD *)&v15 + 1))
    {
      v7 = (unint64_t *)(*((_QWORD *)&v15 + 1) + 8);
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    PCSemaphore::wait((PCSemaphore *)v16);
    PCSemaphore::~PCSemaphore((PCSemaphore *)v16);
  }
  {
                                                                                           + 120));
    PCConditionVariable::~PCConditionVariable((pthread_cond_t *)(v9 + 72));
    PCMutex::~PCMutex((PCMutex *)v9);
    MEMORY[0x1B5E29170](v10);
  }
  {
    PCSpinLock::~PCSpinLock(v11);
    MEMORY[0x1B5E29170](v12);
  }
  if (result)
  {
    v14 = OZChannelBase::setRangeName(result, a2);
    result = (OZChannelBase *)MEMORY[0x1B5E29170](v14, 0x20C4093837F09);
  }
  return result;
}

void sub_1B2C0D3F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  PCSemaphore::~PCSemaphore((PCSemaphore *)va);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::threadFunc(_anonymous_namespace_ *this, void *a2)
{
  uint64_t v2;
  uint64_t *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  do
  {
    PCMutex::lock((PCMutex *)v2);
    while (!*(_QWORD *)(v2 + 160))
      PCConditionVariable::wait((pthread_cond_t *)(v2 + 72), (PCMutex *)v2);
    v3 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(v2 + 128) + ((*(_QWORD *)(v2 + 152) >> 5) & 0x7FFFFFFFFFFFFF8))
                   + 16 * *(_QWORD *)(v2 + 152));
    v5 = *v3;
    v4 = (std::__shared_weak_count *)v3[1];
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
    std::deque<std::shared_ptr<ProGL::DeletionInstruction>>::pop_front((int64x2_t *)(v2 + 120));
    PCMutex::unlock((PCMutex *)v2);
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5);
    if (v4)
    {
      v8 = (unint64_t *)&v4->__shared_owners_;
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  while (!*(_BYTE *)(v2 + 168));
}

void sub_1B2C0D554(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::deque<std::shared_ptr<ProGL::DeletionInstruction>>::pop_front(int64x2_t *a1)
{
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](*(_QWORD *)(a1->i64[1] + (((unint64_t)a1[2].i64[0] >> 5) & 0x7FFFFFFFFFFFFF8))+ 16 * a1[2].i64[0]);
  a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_1B304F0B0);
  return std::deque<PVLoadedEffectItem>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)a1, 1);
}

void std::deque<std::shared_ptr<ProGL::DeletionInstruction>>::push_back(_QWORD *a1, __int128 *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  __int128 v9;
  unint64_t *v10;
  unint64_t v11;

  v4 = a1[2];
  v5 = a1[1];
  if (v4 == v5)
    v6 = 0;
  else
    v6 = 32 * (v4 - v5) - 1;
  v7 = a1[5];
  v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<std::shared_ptr<ProGL::DeletionInstruction>>::__add_back_capacity(a1);
    v5 = a1[1];
    v7 = a1[5];
    v8 = v7 + a1[4];
  }
  v9 = *a2;
  *(_OWORD *)(*(_QWORD *)(v5 + ((v8 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v8) = *a2;
  if (*((_QWORD *)&v9 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v9 + 1) + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    v7 = a1[5];
  }
  a1[5] = v7 + 1;
}

void std::deque<std::shared_ptr<ProGL::DeletionInstruction>>::__add_back_capacity(_QWORD *a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  unint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char *v43;
  _QWORD *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void *v53;
  __int128 v54;
  __int128 v55;
  _QWORD *v56;

  v2 = a1[4];
  v3 = v2 >= 0x100;
  v4 = v2 - 256;
  if (v3)
  {
    v5 = (uint64_t)(a1 + 3);
    v6 = (char *)a1[3];
    a1[4] = v4;
    v7 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v11 = *v7;
    v9 = (char *)(v7 + 1);
    v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(_QWORD *)v8 = v10;
      a1[2] += 8;
      return;
    }
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v33 = 1;
      else
        v33 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v5, v33);
      v35 = &v34[8 * (v33 >> 2)];
      v37 = &v34[8 * v36];
      v38 = (uint64_t *)a1[1];
      v8 = v35;
      v39 = a1[2] - (_QWORD)v38;
      if (v39)
      {
        v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        v40 = 8 * (v39 >> 3);
        v41 = &v34[8 * (v33 >> 2)];
        do
        {
          v42 = *v38++;
          *(_QWORD *)v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    v13 = v12 >> 3;
    v14 = v12 >> 3 < -1;
    v15 = (v12 >> 3) + 2;
    if (v14)
      v16 = v15;
    else
      v16 = v13 + 1;
    v17 = -(v16 >> 1);
    v18 = v16 >> 1;
    v19 = &v9[-8 * v18];
    v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      v9 = (char *)a1[1];
    }
    v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  v21 = a1[2];
  v22 = (v21 - a1[1]) >> 3;
  v23 = a1[3];
  v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(_QWORD *)&v54 = operator new(0x1000uLL);
      std::__split_buffer<unsigned long *>::push_back(a1, &v54);
      return;
    }
    *(_QWORD *)&v54 = operator new(0x1000uLL);
    std::__split_buffer<unsigned long *>::push_front((uint64_t)a1, &v54);
    v44 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v45 = *v44;
    v9 = (char *)(v44 + 1);
    v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3])
      goto LABEL_33;
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v46 = 1;
      else
        v46 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 3), v46);
      v35 = &v34[8 * (v46 >> 2)];
      v37 = &v34[8 * v47];
      v48 = (uint64_t *)a1[1];
      v8 = v35;
      v49 = a1[2] - (_QWORD)v48;
      if (v49)
      {
        v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        v50 = 8 * (v49 >> 3);
        v51 = &v34[8 * (v46 >> 2)];
        do
        {
          v52 = *v48++;
          *(_QWORD *)v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1)
    v25 = 1;
  else
    v25 = v24 >> 2;
  v56 = a1 + 3;
  *(_QWORD *)&v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 3), v25);
  *((_QWORD *)&v54 + 1) = v54 + 8 * v22;
  *(_QWORD *)&v55 = *((_QWORD *)&v54 + 1);
  *((_QWORD *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0x1000uLL);
  std::__split_buffer<unsigned long *>::push_back(&v54, &v53);
  v27 = (_QWORD *)a1[2];
  v28 = -7 - (_QWORD)v27;
  while (v27 != (_QWORD *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<unsigned long *>::push_front((uint64_t)&v54, v27);
  }
  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(_QWORD *)&v54 = *a1;
  *((_QWORD *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (_QWORD *)v32)
    *(_QWORD *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  if (v29)
    operator delete(v29);
}

void sub_1B2C0D9A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  void *v13;

  operator delete(v13);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::QuitInstruction::~QuitInstruction(_anonymous_namespace_::QuitInstruction *this)
{
  JUMPOUT(0x1B5E29170);
}

uint64_t `anonymous namespace'::QuitInstruction::execute(PCSemaphore **this)
{
  return PCSemaphore::signal(this[1]);
}

void std::__shared_ptr_pointer<`anonymous namespace'::QuitInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,`anonymous namespace'::QuitInstruction>,std::allocator<`anonymous namespace'::QuitInstruction>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

uint64_t std::__shared_ptr_pointer<`anonymous namespace'::QuitInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,`anonymous namespace'::QuitInstruction>,std::allocator<`anonymous namespace'::QuitInstruction>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<`anonymous namespace'::QuitInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,`anonymous namespace'::QuitInstruction>,std::allocator<`anonymous namespace'::QuitInstruction>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::deque<std::shared_ptr<ProGL::DeletionInstruction>>::~deque[abi:ne180100](_QWORD *a1)
{
  void **v2;
  void **v3;
  _QWORD *v4;
  unint64_t v5;
  void **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  void *v13;

  v2 = (void **)a1[1];
  v3 = (void **)a1[2];
  if (v3 == v2)
  {
    v4 = a1 + 5;
    v3 = (void **)a1[1];
  }
  else
  {
    v4 = a1 + 5;
    v5 = a1[4];
    v6 = &v2[v5 >> 8];
    v7 = (uint64_t)*v6 + 16 * v5;
    v8 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 5) & 0x7FFFFFFFFFFFFF8))
       + 16 * (*((_BYTE *)a1 + 40) + v5);
    if (v7 != v8)
    {
      do
      {
        v7 = std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v7) + 16;
        if (v7 - (_QWORD)*v6 == 4096)
        {
          v9 = (uint64_t)v6[1];
          ++v6;
          v7 = v9;
        }
      }
      while (v7 != v8);
      v2 = (void **)a1[1];
      v3 = (void **)a1[2];
    }
  }
  *v4 = 0;
  v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)a1[2];
      v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v11 = v10 >> 3;
  if (v11 == 1)
  {
    v12 = 128;
  }
  else
  {
    if (v11 != 2)
      goto LABEL_16;
    v12 = 256;
  }
  a1[4] = v12;
LABEL_16:
  while (v2 != v3)
  {
    v13 = *v2++;
    operator delete(v13);
  }
  return std::__split_buffer<unsigned long *>::~__split_buffer((uint64_t)a1);
}

void PCMatrix44Tmpl<double>::rotate(uint64_t a1, double *a2, int a3, double a4)
{
  double v5;
  double v6;
  double v7;
  double v8;
  double sinval;
  double cosval;
  __double2 v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18[11];
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  v6 = *a2;
  v5 = a2[1];
  v7 = a2[2];
  if (a3)
  {
    v8 = sqrt(v6 * v6 + v5 * v5 + v7 * v7 + a2[3] * a2[3]);
    v6 = v6 / v8;
    v5 = v5 / v8;
    v7 = v7 / v8;
  }
  sinval = 0.0;
  cosval = 1.0;
  if (a4 != 0.0)
  {
    sinval = 1.0;
    cosval = 0.0;
    if (fabs(a4 + -1.57079633) >= 0.0000001 && fabs(a4 + 4.71238898) >= 0.0000001)
    {
      sinval = -1.0;
      if (fabs(a4 + 1.57079633) >= 0.0000001 && fabs(a4 + -4.71238898) >= 0.0000001)
      {
        sinval = 0.0;
        cosval = -1.0;
        if (fabs(a4 + -3.14159265) >= 0.0000001 && fabs(a4 + 3.14159265) >= 0.0000001)
        {
          v11 = __sincos_stret(a4);
          cosval = v11.__cosval;
          sinval = v11.__sinval;
        }
      }
    }
  }
  v12 = v5 * v6 * (1.0 - cosval);
  v13 = v7 * v6 * (1.0 - cosval);
  v14 = v7 * v5 * (1.0 - cosval);
  v15 = v6 * sinval;
  v16 = v5 * sinval;
  v17 = v7 * sinval;
  v21 = 0x3FF0000000000000;
  v18[3] = 0.0;
  v18[7] = 0.0;
  v19 = 0u;
  v20 = 0u;
  v18[0] = cosval + v6 * v6 * (1.0 - cosval);
  v18[1] = v12 - v17;
  v18[2] = v13 + v16;
  v18[4] = v12 + v17;
  v18[5] = cosval + v5 * v5 * (1.0 - cosval);
  v18[6] = v14 - v15;
  v18[8] = v13 - v16;
  v18[9] = v14 + v15;
  v18[10] = cosval + v7 * v7 * (1.0 - cosval);
  PCMatrix44Tmpl<double>::rightMult(a1, v18);
}

void ProGL::MatrixState::~MatrixState(ProGL::MatrixState *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;

  v2 = (void *)*((_QWORD *)this + 1);
  if (v2 != *(void **)this)
  {
    v3 = 0;
    if ((unint64_t)(((uint64_t)v2 - *(_QWORD *)this) >> 3) <= 1)
      v4 = 1;
    else
      v4 = ((uint64_t)v2 - *(_QWORD *)this) >> 3;
    do
    {
      v5 = *(_QWORD *)(*(_QWORD *)this + 8 * v3);
      if (v5)
      {
        v6 = *(void **)(v5 + 16);
        if (v6)
        {
          *(_QWORD *)(v5 + 24) = v6;
          operator delete(v6);
        }
        MEMORY[0x1B5E29170](v5, 0x1020C4081634310);
      }
      ++v3;
    }
    while (v4 != v3);
    v2 = *(void **)this;
  }
  if (v2)
  {
    *((_QWORD *)this + 1) = v2;
    operator delete(v2);
  }
}

uint64_t ProGL::ObjectHandle::Data::Data(uint64_t a1, int a2, _QWORD *a3, uint64_t a4)
{
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  *(_DWORD *)a1 = a2;
  v6 = a3[1];
  *(_QWORD *)(a1 + 8) = *a3;
  *(_QWORD *)(a1 + 16) = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  *(_DWORD *)(a1 + 24) = ProGL::ContextHandle::getVirtualScreen((ProGL::ContextHandle *)(a1 + 8));
  *(_QWORD *)(a1 + 32) = a4;
  return a1;
}

void sub_1B2C0DE94(_Unwind_Exception *a1)
{
  ProGL::ContextHandle *v1;

  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

void ProGL::ObjectHandle::Data::~Data(ProGL::ObjectHandle::Data *this)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD v16[2];
  __int128 v17;

  v2 = operator new();
  v3 = v2;
  v4 = *(_DWORD *)this;
  v5 = *((_QWORD *)this + 1);
  v6 = *((_QWORD *)this + 2);
  v16[0] = v5;
  v16[1] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
    v9 = *((_DWORD *)this + 6);
    v10 = *((_QWORD *)this + 4);
    *(_QWORD *)v2 = &off_1E654B7C0;
    *(_DWORD *)(v2 + 8) = v4;
    *(_QWORD *)(v2 + 16) = v5;
    *(_QWORD *)(v2 + 24) = v6;
    do
      v11 = __ldxr(v7);
    while (__stxr(v11 + 1, v7));
  }
  else
  {
    v9 = *((_DWORD *)this + 6);
    v10 = *((_QWORD *)this + 4);
    *(_QWORD *)v2 = &off_1E654B7C0;
    *(_DWORD *)(v2 + 8) = v4;
    *(_QWORD *)(v2 + 16) = v5;
    *(_QWORD *)(v2 + 24) = 0;
  }
  *(_DWORD *)(v2 + 32) = v9;
  *(_QWORD *)(v2 + 40) = v10;
  *(_QWORD *)&v17 = v2;
  v12 = (_QWORD *)operator new();
  *v12 = &off_1E654B800;
  v12[1] = 0;
  v12[2] = 0;
  v12[3] = v3;
  *((_QWORD *)&v17 + 1) = v12;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v16);
  ProGL::postDeletionInstruction(&v17);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  ProGL::ContextHandle::~ContextHandle((ProGL::ObjectHandle::Data *)((char *)this + 8));
}

void sub_1B2C0DFF4(void *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  __clang_call_terminate(a1);
}

uint64_t ProGL::ObjectHandle::name(ProGL::ObjectHandle *this)
{
  if (*(_QWORD *)this)
    return **(unsigned int **)this;
  else
    return 0;
}

void ProGL::createShaderObject(ProGL *this@<X0>, GLenum type@<W1>, _QWORD *a3@<X8>)
{
  GLuint Shader;
  _QWORD v6[2];
  uint64_t (*v7)(_QWORD);
  GLuint v8;

  Shader = glCreateShader(type);
  ProGL::GL::getPGLContextHandle(this, v6);
  v8 = Shader;
  v7 = MEMORY[0x1E0CD0A50];
  std::allocate_shared[abi:ne180100]<ProGL::ObjectHandle::Data,std::allocator<ProGL::ObjectHandle::Data>,unsigned int &,ProGL::ContextHandle const&,void (*&),void>((int *)&v8, v6, (uint64_t *)&v7, a3);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v6);
}

void sub_1B2C0E0A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a9);
  _Unwind_Resume(a1);
}

void ProGL::createProgramObject(ProGL *this@<X0>, _QWORD *a2@<X8>)
{
  GLuint Program;
  _QWORD v6[2];
  uint64_t (*v7)(_QWORD);
  GLuint v8;

  Program = glCreateProgram();
  ProGL::GL::getPGLContextHandle(this, v6);
  v8 = Program;
  v7 = MEMORY[0x1E0CD0A40];
  std::allocate_shared[abi:ne180100]<ProGL::ObjectHandle::Data,std::allocator<ProGL::ObjectHandle::Data>,unsigned int &,ProGL::ContextHandle const&,void (*&),void>((int *)&v8, v6, (uint64_t *)&v7, a2);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v6);
}

void sub_1B2C0E130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a9);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::DeleteObjectInst::~DeleteObjectInst(OZChannelBase *this)
{
  const PCString *v2;

  this->var0 = (void **)&off_1E654B7C0;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);
  OZChannelBase::setRangeName(this, v2);
}

{
  const PCString *v2;

  this->var0 = (void **)&off_1E654B7C0;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);
  OZChannelBase::setRangeName(this, v2);
  JUMPOUT(0x1B5E29170);
}

void `anonymous namespace'::DeleteObjectInst::execute(os_unfair_lock_s **this)
{
  _BYTE v2[40];
  _BYTE v3[16];
  _BYTE v4[16];

  ProGL::getDeletionContext(this + 2, (const ProGL::ContextHandle *)*((unsigned int *)this + 8), (ProGL::ContextHandle *)v4);
  ProGL::CurrentContextSentry::CurrentContextSentry((ProGL::CurrentContextSentry *)v3, (const ProGL::ContextHandle *)v4);
  ((void (*)(_QWORD))this[5])(*((unsigned int *)this + 2));
  ProGL::GL::GL((ProGL::GL *)v2, (const ProGL::ContextHandle *)v4);
  ProGL::GL::~GL((ProGL::GL *)v2);
  ProGL::CurrentContextSentry::~CurrentContextSentry((ProGL::CurrentContextSentry *)v3);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v4);
}

void sub_1B2C0E228(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  ProGL::CurrentContextSentry::~CurrentContextSentry((ProGL::CurrentContextSentry *)va);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(v7 - 32));
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<`anonymous namespace'::DeleteObjectInst *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,`anonymous namespace'::DeleteObjectInst>,std::allocator<`anonymous namespace'::DeleteObjectInst>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

uint64_t std::__shared_ptr_pointer<`anonymous namespace'::DeleteObjectInst *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,`anonymous namespace'::DeleteObjectInst>,std::allocator<`anonymous namespace'::DeleteObjectInst>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<`anonymous namespace'::DeleteObjectInst *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,`anonymous namespace'::DeleteObjectInst>,std::allocator<`anonymous namespace'::DeleteObjectInst>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

_QWORD *std::allocate_shared[abi:ne180100]<ProGL::ObjectHandle::Data,std::allocator<ProGL::ObjectHandle::Data>,unsigned int &,ProGL::ContextHandle const&,void (*&)(unsigned int),void>@<X0>(int *a1@<X1>, _QWORD *a2@<X2>, uint64_t *a3@<X3>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = operator new(0x40uLL);
  result = std::__shared_ptr_emplace<ProGL::ObjectHandle::Data>::__shared_ptr_emplace[abi:ne180100]<unsigned int &,ProGL::ContextHandle const&,void (*&),std::allocator<ProGL::ObjectHandle::Data>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1B2C0E32C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<ProGL::ObjectHandle::Data>::__shared_ptr_emplace[abi:ne180100]<unsigned int &,ProGL::ContextHandle const&,void (*&)(unsigned int),std::allocator<ProGL::ObjectHandle::Data>,0>(_QWORD *a1, int *a2, _QWORD *a3, uint64_t *a4)
{
  char v6;

  a1[2] = 0;
  *a1 = &unk_1E654B878;
  a1[1] = 0;
  std::allocator<ProGL::ObjectHandle::Data>::construct[abi:ne180100]<ProGL::ObjectHandle::Data,unsigned int &,ProGL::ContextHandle const&,void (*&)>((uint64_t)&v6, (uint64_t)(a1 + 3), a2, a3, a4);
  return a1;
}

void sub_1B2C0E394(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<ProGL::ObjectHandle::Data>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E654B878;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ProGL::ObjectHandle::Data>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E654B878;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

void std::__shared_ptr_emplace<ProGL::ObjectHandle::Data>::__on_zero_shared(uint64_t a1)
{
  ProGL::ObjectHandle::Data::~Data((ProGL::ObjectHandle::Data *)(a1 + 24));
}

void std::allocator<ProGL::ObjectHandle::Data>::construct[abi:ne180100]<ProGL::ObjectHandle::Data,unsigned int &,ProGL::ContextHandle const&,void (*&)(unsigned int)>(uint64_t a1, uint64_t a2, int *a3, _QWORD *a4, uint64_t *a5)
{
  int v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD v10[2];

  v6 = *a3;
  v7 = a4[1];
  v10[0] = *a4;
  v10[1] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  ProGL::ObjectHandle::Data::Data(a2, v6, v10, *a5);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v10);
}

void sub_1B2C0E458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a9);
  _Unwind_Resume(a1);
}

uint64_t PGLMasterEAGLContext()
{
  uint64_t result;
  id v1;

  {
    PCAutoreleasePool::PCAutoreleasePool((PCAutoreleasePool *)&v1);
    PCAutoreleasePool::~PCAutoreleasePool(&v1);
  }
  return result;
}

void sub_1B2C0E4C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCAutoreleasePool::~PCAutoreleasePool((id *)va);
  _Unwind_Resume(a1);
}

void ProGL::Private::cleanUpContextSharing(ProGL::Private *this)
{
  {

  }
}

uint64_t PGLCreateSharedEAGLContext()
{
  id v0;
  uint64_t v1;
  id v3;

  PCAutoreleasePool::PCAutoreleasePool((PCAutoreleasePool *)&v3);
  v0 = objc_alloc(MEMORY[0x1E0CD0958]);
  PCAutoreleasePool::~PCAutoreleasePool(&v3);
  return v1;
}

void sub_1B2C0E56C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCAutoreleasePool::~PCAutoreleasePool((id *)va);
  _Unwind_Resume(a1);
}

_QWORD *ProGL::ContextHandle::operator=(_QWORD *a1, uint64_t *a2)
{
  std::shared_ptr<TXTextStyle>::operator=[abi:ne180100](a1, a2);
  return a1;
}

uint64_t ProGL::ContextHandle::makeCurrent(ProGL::ContextHandle *this)
{
  uint64_t result;

  result = *(_QWORD *)this;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  return result;
}

uint64_t ProGL::ContextHandle::getEAGLContext(ProGL::ContextHandle *this)
{
  uint64_t result;

  result = *(_QWORD *)this;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

uint64_t ProGL::ContextHandle::setVirtualScreen(ProGL::ContextHandle *this)
{
  uint64_t result;

  result = *(_QWORD *)this;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  return result;
}

uint64_t ProGL::ContextHandle::getVirtualScreen(ProGL::ContextHandle *this)
{
  uint64_t result;

  result = *(_QWORD *)this;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

uint64_t (*ProGL::ContextHandle::operator void (ProGL::ContextHandle::*)(void)const(_QWORD *a1))(ProGL::ContextHandle *this)
{
  if (*a1)
    return ProGL::ContextHandle::makeCurrent;
  else
    return 0;
}

void ProGL::ContextHandle::getShareGroup(os_unfair_lock_s **this@<X0>, PCSharedCount *a2@<X8>)
{
  os_unfair_lock_s *v2;

  v2 = *this;
  if (v2)
    ProGL::Private::ContextImpl::getShareGroup(v2, a2);
  else
    PCSharedCount::PCSharedCount(a2);
}

void ProGL::getCurrentContext(_QWORD *a1@<X8>)
{
  _anonymous_namespace_ *v3;

  v3 = (_anonymous_namespace_ *)objc_msgSend(MEMORY[0x1E0CD0958], "currentContext");
  if (v3)
  {
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
}

void `anonymous namespace'::HandleFromExistingEAGLContext(_anonymous_namespace_ *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  id v13;

  PCMakeNSRefAndRetain<EAGLContext *>(this, &v13);
  v4 = operator new();
  ProGL::Private::EAGLContextImpl::EAGLContextImpl(v4, &v13);
  std::shared_ptr<ProGL::Private::ContextImpl>::shared_ptr[abi:ne180100]<ProGL::Private::EAGLContextImpl,void>(&v11, v4);
  v5 = v12;
  *a2 = v11;
  a2[1] = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    v8 = v12;
    if (v12)
    {
      v9 = (unint64_t *)&v12->__shared_owners_;
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
  ProCore_Impl::PCNSRefImpl::release(&v13);
}

void sub_1B2C0E738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  va_list va;

  va_start(va, a4);
  MEMORY[0x1B5E29170](v4, 0x1081C402D5EB2C2);
  ProCore_Impl::PCNSRefImpl::release((id *)va);
  _Unwind_Resume(a1);
}

void ProGL::makeSharedEAGLContext(_QWORD *a1@<X8>)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;

  v13 = PGLCreateSharedEAGLContext();
  if (v13)
  {
    v3 = operator new();
    ProGL::masterShareGroup(&v10);
    ProGL::Private::EAGLContextImpl::EAGLContextImpl(v3, &v13, &v10);
    std::shared_ptr<ProGL::Private::ContextImpl>::shared_ptr[abi:ne180100]<ProGL::Private::EAGLContextImpl,void>(&v11, v3);
    v4 = v12;
    *a1 = v11;
    a1[1] = v4;
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
      v7 = v12;
      if (v12)
      {
        v8 = (unint64_t *)&v12->__shared_owners_;
        do
          v9 = __ldaxr(v8);
        while (__stlxr(v9 - 1, v8));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
    }
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
  ProCore_Impl::PCNSRefImpl::release((id *)&v13);
}

void sub_1B2C0E848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  ProCore_Impl::PCNSRefImpl::release((id *)va);
  _Unwind_Resume(a1);
}

void ProGL::makeEAGLContext(os_unfair_lock_s **this@<X0>, const ProGL::ContextHandle *a2@<X1>, uint64_t *a3@<X8>)
{
  os_unfair_lock_s *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  PCSharedCount v16;
  id v17;

  v5 = *this;
  if (v5)
    v6 = (void *)(*(uint64_t (**)(os_unfair_lock_s *, const ProGL::ContextHandle *))(*(_QWORD *)&v5->_os_unfair_lock_opaque
                                                                                             + 24))(v5, a2);
  else
    v6 = 0;
  ProGL::ContextHandle::getShareGroup(this, &v16);
  v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CD0958]), "initWithAPI:sharegroup:", objc_msgSend(v6, "API"), objc_msgSend(v6, "sharegroup"));
  if (v7)
  {
    v17 = v7;
    v8 = operator new();
    ProGL::Private::EAGLContextImpl::EAGLContextImpl(v8, &v17, &v16);
    v9 = (std::__shared_weak_count *)operator new();
    v10 = v9;
    v9->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    v9->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E654B8C8;
    v9->__shared_weak_owners_ = 0;
    v9[1].__vftable = (std::__shared_weak_count_vtbl *)v8;
    *a3 = v8;
    a3[1] = (uint64_t)v9;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  else
  {
    v14 = (_QWORD *)MEMORY[0x1E0DE4A60];
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)"ProGL::unnamed::NewEAGLContext(EAGLContext): ", 45);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"Unable to create a EAGLContext that shares with %p", 50);
    v15 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)".\n", 2);
    v17 = 0;
    *a3 = 0;
    a3[1] = 0;
  }
  ProCore_Impl::PCNSRefImpl::release(&v17);
}

void sub_1B2C0EA1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  ProCore_Impl::PCNSRefImpl::release((id *)va);
  _Unwind_Resume(a1);
}

void ProGL::findContext(_anonymous_namespace_ *this@<X0>, _QWORD *a2@<X8>)
{
  if (this)
  {
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

BOOL ProGL::areContextsShared(os_unfair_lock_s **this, os_unfair_lock_s **a2, const ProGL::ContextHandle *a3)
{
  PCSharedCount v5;
  PCSharedCount v6;

  ProGL::ContextHandle::getShareGroup(this, &v6);
  ProGL::ContextHandle::getShareGroup(a2, &v5);
  return ProGL::operator==(&v6, &v5);
}

void ProGL::Private::initContext(ProGL::Private *this)
{
  _anonymous_namespace_ *v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  id v7;

  PCAutoreleasePool::PCAutoreleasePool((PCAutoreleasePool *)&v7);
  v1 = (_anonymous_namespace_ *)objc_msgSend(MEMORY[0x1E0CD0958], "currentContext");
  if (v1)
  {
    v2 = v6;
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v4 = __ldaxr(p_shared_owners);
      while (__stlxr(v4 - 1, p_shared_owners));
      if (!v4)
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
  }
  PCAutoreleasePool::~PCAutoreleasePool(&v7);
}

void sub_1B2C0EB44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  PCAutoreleasePool::~PCAutoreleasePool((id *)va);
  _Unwind_Resume(a1);
}

id PCMakeNSRefAndRetain<EAGLContext *>@<X0>(void *a1@<X0>, id *a2@<X8>)
{
  *a2 = a1;
  return ProCore_Impl::PCNSRefImpl::retain(a2);
}

void sub_1B2C0EB80(_Unwind_Exception *a1)
{
  id *v1;

  ProCore_Impl::PCNSRefImpl::release(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<ProGL::Private::ContextImpl>::shared_ptr[abi:ne180100]<ProGL::Private::EAGLContextImpl,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1E654B8C8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1B2C0EBF0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_pointer<ProGL::Private::EAGLContextImpl *,std::shared_ptr<ProGL::Private::ContextImpl>::__shared_ptr_default_delete<ProGL::Private::ContextImpl,ProGL::Private::EAGLContextImpl>,std::allocator<ProGL::Private::EAGLContextImpl>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<ProGL::Private::EAGLContextImpl *,std::shared_ptr<ProGL::Private::ContextImpl>::__shared_ptr_default_delete<ProGL::Private::ContextImpl,ProGL::Private::EAGLContextImpl>,std::allocator<ProGL::Private::EAGLContextImpl>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

ProGL::Private::ContextImpl *ProGL::Private::ContextImpl::ContextImpl(ProGL::Private::ContextImpl *this, const ProGL::ShareGroup *a2)
{
  *(_QWORD *)this = off_1E654B940;
  *((_DWORD *)this + 2) = 0;
  ProGL::ShareGroup::ShareGroup((_QWORD *)this + 2, a2);
  return this;
}

void sub_1B2C0ECA0(_Unwind_Exception *a1)
{
  PCSpinLock *v1;

  PCSpinLock::~PCSpinLock(v1);
  _Unwind_Resume(a1);
}

void ProGL::Private::ContextImpl::getShareGroup(os_unfair_lock_s *this@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  uint64_t (*v5)(ProGL::ShareGroup *__hidden);
  uint64_t v6;
  BOOL v7;
  int v8;
  void *v9;
  _QWORD v10[2];

  v4 = this + 2;
  v10[1] = this + 2;
  PCSpinLock::lock(this + 2);
  v5 = ProGL::ShareGroup::operator void (ProGL::ShareGroup::*)(void)(&this[4]._os_unfair_lock_opaque);
  if (v6)
    v7 = (v6 & 1 | (unint64_t)v5) == 0;
  else
    v7 = 1;
  v8 = v7;
  if (!v5 && v8)
  {
    v9 = (void *)(*(uint64_t (**)(os_unfair_lock_s *))(*(_QWORD *)&this->_os_unfair_lock_opaque + 24))(this);
    ProGL::ShareGroup::findGroup(v9, v10);
    *(_QWORD *)&this[4]._os_unfair_lock_opaque = v10[0];
  }
  ProGL::ShareGroup::ShareGroup(a2, &this[4]._os_unfair_lock_opaque);
  PCSpinLock::unlock(v4);
}

void sub_1B2C0ED5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

ProGL::Private::ContextImpl *ProGL::Private::EAGLContextImpl::EAGLContextImpl(ProGL::Private::ContextImpl *a1, _QWORD *a2)
{
  ProGL::Private::ContextImpl *v4;
  PCSharedCount v6;

  PCSharedCount::PCSharedCount(&v6);
  v4 = ProGL::Private::ContextImpl::ContextImpl(a1, (const ProGL::ShareGroup *)&v6);
  *(_QWORD *)a1 = &off_1E654B988;
  *((_QWORD *)v4 + 3) = *a2;
  ProCore_Impl::PCNSRefImpl::retain((id *)v4 + 3);
  return a1;
}

void sub_1B2C0EDCC(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)v1 = off_1E654B940;
  PCSpinLock::~PCSpinLock((PCSpinLock *)(v1 + 8));
  _Unwind_Resume(a1);
}

ProGL::Private::ContextImpl *ProGL::Private::EAGLContextImpl::EAGLContextImpl(ProGL::Private::ContextImpl *a1, _QWORD *a2, ProGL::ShareGroup *a3)
{
  ProGL::Private::ContextImpl *v5;

  v5 = ProGL::Private::ContextImpl::ContextImpl(a1, a3);
  *(_QWORD *)v5 = &off_1E654B988;
  *((_QWORD *)v5 + 3) = *a2;
  ProCore_Impl::PCNSRefImpl::retain((id *)v5 + 3);
  return a1;
}

void sub_1B2C0EE34(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)v1 = off_1E654B940;
  PCSpinLock::~PCSpinLock((PCSpinLock *)(v1 + 8));
  _Unwind_Resume(a1);
}

void ProGL::Private::EAGLContextImpl::~EAGLContextImpl(ProGL::Private::EAGLContextImpl *this)
{
  *(_QWORD *)this = &off_1E654B988;
  ProCore_Impl::PCNSRefImpl::release((id *)this + 3);
  *(_QWORD *)this = off_1E654B940;
  PCSpinLock::~PCSpinLock((PCSpinLock *)this + 2);
}

{
  ProGL::Private::EAGLContextImpl::~EAGLContextImpl(this);
  JUMPOUT(0x1B5E29170);
}

uint64_t ProGL::Private::EAGLContextImpl::makeCurrent(ProGL::Private::EAGLContextImpl *this)
{
  return objc_msgSend(MEMORY[0x1E0CD0958], "setCurrentContext:", *((_QWORD *)this + 3));
}

uint64_t ProGL::Private::EAGLContextImpl::getEAGLContext(ProGL::Private::EAGLContextImpl *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t ProGL::Private::EAGLContextImpl::numVirtualScreens(ProGL::Private::EAGLContextImpl *this)
{
  return 1;
}

uint64_t ProGL::Private::EAGLContextImpl::getVirtualScreen(ProGL::Private::EAGLContextImpl *this)
{
  return 0;
}

ProGL::CurrentContextSentry *ProGL::CurrentContextSentry::CurrentContextSentry(ProGL::CurrentContextSentry *this)
{
  *(_QWORD *)this = objc_msgSend(MEMORY[0x1E0CD0958], "currentContext");
  *((_QWORD *)this + 1) = 0;
  return this;
}

ProGL::CurrentContextSentry *ProGL::CurrentContextSentry::CurrentContextSentry(ProGL::CurrentContextSentry *this, EAGLContext *a2)
{
  EAGLContext *v4;

  *(_QWORD *)this = objc_msgSend(MEMORY[0x1E0CD0958], "currentContext");
  *((_QWORD *)this + 1) = a2;
  if (a2)
  {
    v4 = a2;
    objc_msgSend(MEMORY[0x1E0CD0958], "setCurrentContext:", a2);
  }
  return this;
}

ProGL::CurrentContextSentry *ProGL::CurrentContextSentry::CurrentContextSentry(ProGL::CurrentContextSentry *this, const ProGL::ContextHandle *a2)
{
  uint64_t (*v4)(ProGL::ContextHandle *);
  uint64_t v5;
  BOOL v6;
  int v7;
  id v8;

  *(_QWORD *)this = objc_msgSend(MEMORY[0x1E0CD0958], "currentContext");
  *((_QWORD *)this + 1) = ProGL::ContextHandle::getEAGLContext(a2);
  v4 = ProGL::ContextHandle::operator void (ProGL::ContextHandle::*)(void)const(a2);
  if (v5)
    v6 = (v5 & 1 | (unint64_t)v4) == 0;
  else
    v6 = 1;
  v7 = !v6;
  if (v4 || v7)
  {
    v8 = *((id *)this + 1);
    ProGL::ContextHandle::makeCurrent(a2);
  }
  return this;
}

void ProGL::CurrentContextSentry::~CurrentContextSentry(id *this)
{
  objc_msgSend(MEMORY[0x1E0CD0958], "setCurrentContext:", *this);

}

_QWORD *ProGL::Private::initContextInfo(ProGL::Private *this)
{
  _DWORD *v1;
  _QWORD *result;

  v1 = (_DWORD *)operator new();
  *v1 = 0;
  result = (_QWORD *)operator new();
  result[2] = 0;
  result[1] = 0;
  *result = result + 1;
  return result;
}

uint64_t ProGL::Private::cleanUpContextInfo(ProGL::Private *this)
{
  uint64_t result;
  uint64_t v2;

  {
    result = MEMORY[0x1B5E29170]();
  }
  {
    result = MEMORY[0x1B5E29170](v2, 0x1020C4062D53EE8);
  }
  return result;
}

void std::__tree<std::__value_type<std::pair<ProGL::ShareGroup,int>,`anonymous namespace'::PerGroupContextInfo>,std::__map_value_compare<std::pair<ProGL::ShareGroup,int>,std::__value_type<std::pair<ProGL::ShareGroup,int>,`anonymous namespace'::PerGroupContextInfo>,std::less<std::pair<ProGL::ShareGroup,int>>,true>,std::allocator<std::__value_type<std::pair<ProGL::ShareGroup,int>,`anonymous namespace'::PerGroupContextInfo>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    operator delete(a1);
  }
}

uint64_t OZFactories::getInstance(OZFactories *this)
{
  if (OZFactories::getInstance(void)::once != -1)
    dispatch_once(&OZFactories::getInstance(void)::once, &__block_literal_global_62);
  return OZFactories::_instance;
}

void ___ZN11OZFactories11getInstanceEv_block_invoke()
{
  OZFactories *v0;

  v0 = (OZFactories *)operator new();
  OZFactories::OZFactories(v0);
  OZFactories::_instance = (uint64_t)v0;
}

void sub_1B2C0F1C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40A4A8B666);
  _Unwind_Resume(a1);
}

void OZFactories::OZFactories(OZFactories *this)
{
  _QWORD *v2;

  PCSingleton::PCSingleton(this, 0);
  *v2 = &off_1E654BA38;
  v2[2] = 0;
  v2[1] = v2 + 2;
  v2[3] = 0;
  OZFactories::addChannelFactories((uint64_t **)this);
}

void sub_1B2C0F250(_Unwind_Exception *a1)
{
  PCSingleton *v1;
  uint64_t v2;

  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v2, *((_QWORD **)v1 + 2));
  PCSingleton::~PCSingleton(v1);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::makeThreadKey(_anonymous_namespace_ *this)
{
}

{
}

_OWORD *OZFactories::addChannelFactories(uint64_t **this)
{
  uint64_t **v1;
  uint64_t Instance;
  OZChannel_Factory *v3;
  uint64_t v4;
  OZChannelDouble_Factory *v5;
  uint64_t v6;
  OZChannelBool_Factory *v7;
  uint64_t v8;
  OZChannelUint32_Factory *v9;
  uint64_t v10;
  OZChannelAngle_Factory *v11;
  uint64_t v12;
  OZChannelPercent_Factory *v13;
  uint64_t v14;
  OZChannelShearAngle_Factory *v15;
  uint64_t v16;
  OZChannelAspectRatio_Factory *v17;
  uint64_t v18;
  OZChannelAspectRatioFootage_Factory *v19;
  uint64_t v20;
  OZChannelGammaFootage_Factory *v21;
  uint64_t v22;
  OZChannelFolder_Factory *v23;
  uint64_t v24;
  OZCompoundChannel_Factory *v25;
  uint64_t v26;
  OZChannel2D_Factory *v27;
  uint64_t v28;
  OZChannelBool3D_Factory *v29;
  uint64_t v30;
  OZChannelPosition_Factory *v31;
  uint64_t v32;
  OZChannelPositionPercent_Factory *v33;
  uint64_t v34;
  OZChannelShear_Factory *v35;
  uint64_t v36;
  OZChannelScale_Factory *v37;
  uint64_t v38;
  OZChannel3D_Factory *v39;
  uint64_t v40;
  OZChannelPosition3D_Factory *v41;
  uint64_t v42;
  OZChannelRotation3D_Factory *v43;
  uint64_t v44;
  OZChannelScale3D_Factory *v45;
  uint64_t v46;
  OZChannelColorNoAlpha_Factory *v47;
  uint64_t v48;
  OZChannelColor_Factory *v49;
  uint64_t v50;
  OZChannelQuad_Factory *v51;
  uint64_t v52;
  OZChannelCrop_Factory *v53;
  uint64_t v54;
  OZChannelDiscreteColor_Factory *v55;
  uint64_t v56;
  OZChannelGradient_Factory *v57;
  uint64_t v58;
  OZChannelGradientRGBFolder_Factory *v59;
  uint64_t v60;
  OZChannelGradientAlphaFolder_Factory *v61;
  uint64_t v62;
  OZChannelGradientSample_Factory *v63;
  uint64_t v64;
  OZChannelGradientSampleRGB_Factory *v65;
  uint64_t v66;
  OZChannelGradientSampleAlpha_Factory *v67;
  uint64_t v68;
  OZChannelGradientExtras_Factory *v69;
  uint64_t v70;
  OZChannelGradientPositioned_Factory *v71;
  uint64_t v72;
  OZChannelVaryingFolder_Factory *v73;
  uint64_t v74;
  OZChannelObjectRootBase_Factory *v75;
  uint64_t v76;
  OZChannelHistogram_Factory *v77;
  uint64_t v78;
  OZChannelLevels_Factory *v79;
  uint64_t v80;
  OZChannelButton_Factory *v81;
  uint64_t v82;
  OZChannelHelpButton_Factory *v83;
  uint64_t v84;
  OZChannelText_Factory *v85;
  uint64_t v86;
  OZChannelDoubleOverRange_Factory *v87;
  uint64_t v88;
  OZChannelScaleOverRange_Factory *v89;
  uint64_t v90;
  OZChannelAngleOverRange_Factory *v91;
  uint64_t v92;
  OZChannelPercentOverRange_Factory *v93;
  uint64_t v94;
  OZChannel2DOverRange_Factory *v95;
  uint64_t v96;
  OZChannelTransformSwitch_Factory *v97;
  uint64_t v98;
  OZChannelUint16_Factory *v99;
  uint64_t v100;
  OZChannelSeed_Factory *v101;
  uint64_t v102;
  OZChannelDecibel_Factory *v103;
  uint64_t v104;
  OZChannelFrame_Factory *v105;
  uint64_t v106;
  OZChannelTimecode_Factory *v107;
  uint64_t v108;
  OZChannelBlindData_Factory *v109;
  uint64_t v110;
  OZChannelCurve_Factory *v111;
  uint64_t v112;
  OZChannelEnum_Factory *v113;
  uint64_t v114;
  OZChannelGradientWithAngle_Factory *v115;
  uint64_t v116;
  OZChannelHistogramSample_Factory *v117;
  uint64_t v118;
  OZChannelProgress_Factory *v119;
  uint64_t v120;
  OZChannelScaleOverLife_Factory *v121;
  uint64_t v122;
  OZChannelVertexFolder_Factory *v123;
  uint64_t v124;
  OZChanObjectRef_Factory *v125;
  uint64_t v126;
  _OWORD *result;
  _OWORD *v128;

  v1 = this;
  Instance = OZChannelBase_Factory::getInstance((OZChannelBase_Factory *)this);
  ++v1;
  v128 = (_OWORD *)(Instance + 8);
  v3 = (OZChannel_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(Instance + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v3 + 6) = Instance;
  v4 = OZChannel_Factory::getInstance(v3);
  v128 = (_OWORD *)(v4 + 8);
  v5 = (OZChannelDouble_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v4 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v5 + 6) = v4;
  v6 = OZChannelDouble_Factory::getInstance(v5);
  v128 = (_OWORD *)(v6 + 8);
  v7 = (OZChannelBool_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v6 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v7 + 6) = v6;
  v8 = OZChannelBool_Factory::getInstance(v7);
  v128 = (_OWORD *)(v8 + 8);
  v9 = (OZChannelUint32_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v8 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v9 + 6) = v8;
  v10 = OZChannelUint32_Factory::getInstance(v9);
  v128 = (_OWORD *)(v10 + 8);
  v11 = (OZChannelAngle_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v10 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v11 + 6) = v10;
  v12 = OZChannelAngle_Factory::getInstance(v11);
  v128 = (_OWORD *)(v12 + 8);
  v13 = (OZChannelPercent_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v12 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v13 + 6) = v12;
  v14 = OZChannelPercent_Factory::getInstance(v13);
  v128 = (_OWORD *)(v14 + 8);
  v15 = (OZChannelShearAngle_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v14 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v15 + 6) = v14;
  v16 = OZChannelShearAngle_Factory::getInstance(v15);
  v128 = (_OWORD *)(v16 + 8);
  v17 = (OZChannelAspectRatio_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v16 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v17 + 6) = v16;
  v18 = OZChannelAspectRatio_Factory::getInstance(v17);
  v128 = (_OWORD *)(v18 + 8);
  v19 = (OZChannelAspectRatioFootage_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v18 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v19 + 6) = v18;
  v20 = OZChannelAspectRatioFootage_Factory::getInstance(v19);
  v128 = (_OWORD *)(v20 + 8);
  v21 = (OZChannelGammaFootage_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v20 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v21 + 6) = v20;
  v22 = OZChannelGammaFootage_Factory::getInstance(v21);
  v128 = (_OWORD *)(v22 + 8);
  v23 = (OZChannelFolder_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v22 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v23 + 6) = v22;
  v24 = OZChannelFolder_Factory::getInstance(v23);
  v128 = (_OWORD *)(v24 + 8);
  v25 = (OZCompoundChannel_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v24 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v25 + 6) = v24;
  v26 = OZCompoundChannel_Factory::getInstance(v25);
  v128 = (_OWORD *)(v26 + 8);
  v27 = (OZChannel2D_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v26 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v27 + 6) = v26;
  v28 = OZChannel2D_Factory::getInstance(v27);
  v128 = (_OWORD *)(v28 + 8);
  v29 = (OZChannelBool3D_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v28 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v29 + 6) = v28;
  v30 = OZChannelBool3D_Factory::getInstance(v29);
  v128 = (_OWORD *)(v30 + 8);
  v31 = (OZChannelPosition_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v30 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v31 + 6) = v30;
  v32 = OZChannelPosition_Factory::getInstance(v31);
  v128 = (_OWORD *)(v32 + 8);
  v33 = (OZChannelPositionPercent_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v32 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v33 + 6) = v32;
  v34 = OZChannelPositionPercent_Factory::getInstance(v33);
  v128 = (_OWORD *)(v34 + 8);
  v35 = (OZChannelShear_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v34 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v35 + 6) = v34;
  v36 = OZChannelShear_Factory::getInstance(v35);
  v128 = (_OWORD *)(v36 + 8);
  v37 = (OZChannelScale_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v36 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v37 + 6) = v36;
  v38 = OZChannelScale_Factory::getInstance(v37);
  v128 = (_OWORD *)(v38 + 8);
  v39 = (OZChannel3D_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v38 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v39 + 6) = v38;
  v40 = OZChannel3D_Factory::getInstance(v39);
  v128 = (_OWORD *)(v40 + 8);
  v41 = (OZChannelPosition3D_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v40 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v41 + 6) = v40;
  v42 = OZChannelPosition3D_Factory::getInstance(v41);
  v128 = (_OWORD *)(v42 + 8);
  v43 = (OZChannelRotation3D_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v42 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v43 + 6) = v42;
  v44 = OZChannelRotation3D_Factory::getInstance(v43);
  v128 = (_OWORD *)(v44 + 8);
  v45 = (OZChannelScale3D_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v44 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v45 + 6) = v44;
  v46 = OZChannelScale3D_Factory::getInstance(v45);
  v128 = (_OWORD *)(v46 + 8);
  v47 = (OZChannelColorNoAlpha_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v46 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v47 + 6) = v46;
  v48 = OZChannelColorNoAlpha_Factory::getInstance(v47);
  v128 = (_OWORD *)(v48 + 8);
  v49 = (OZChannelColor_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v48 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v49 + 6) = v48;
  v50 = OZChannelColor_Factory::getInstance(v49);
  v128 = (_OWORD *)(v50 + 8);
  v51 = (OZChannelQuad_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v50 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v51 + 6) = v50;
  v52 = OZChannelQuad_Factory::getInstance(v51);
  v128 = (_OWORD *)(v52 + 8);
  v53 = (OZChannelCrop_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v52 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v53 + 6) = v52;
  v54 = OZChannelCrop_Factory::getInstance(v53);
  v128 = (_OWORD *)(v54 + 8);
  v55 = (OZChannelDiscreteColor_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v54 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v55 + 6) = v54;
  v56 = OZChannelDiscreteColor_Factory::getInstance(v55);
  v128 = (_OWORD *)(v56 + 8);
  v57 = (OZChannelGradient_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v56 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v57 + 6) = v56;
  v58 = OZChannelGradient_Factory::getInstance(v57);
  v128 = (_OWORD *)(v58 + 8);
  v59 = (OZChannelGradientRGBFolder_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v58 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v59 + 6) = v58;
  v60 = OZChannelGradientRGBFolder_Factory::getInstance(v59);
  v128 = (_OWORD *)(v60 + 8);
  v61 = (OZChannelGradientAlphaFolder_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v60 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v61 + 6) = v60;
  v62 = OZChannelGradientAlphaFolder_Factory::getInstance(v61);
  v128 = (_OWORD *)(v62 + 8);
  v63 = (OZChannelGradientSample_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v62 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v63 + 6) = v62;
  v64 = OZChannelGradientSample_Factory::getInstance(v63);
  v128 = (_OWORD *)(v64 + 8);
  v65 = (OZChannelGradientSampleRGB_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v64 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v65 + 6) = v64;
  v66 = OZChannelGradientSampleRGB_Factory::getInstance(v65);
  v128 = (_OWORD *)(v66 + 8);
  v67 = (OZChannelGradientSampleAlpha_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v66 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v67 + 6) = v66;
  v68 = OZChannelGradientSampleAlpha_Factory::getInstance(v67);
  v128 = (_OWORD *)(v68 + 8);
  v69 = (OZChannelGradientExtras_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v68 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v69 + 6) = v68;
  v70 = OZChannelGradientExtras_Factory::getInstance(v69);
  v128 = (_OWORD *)(v70 + 8);
  v71 = (OZChannelGradientPositioned_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v70 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v71 + 6) = v70;
  v72 = OZChannelGradientPositioned_Factory::getInstance(v71);
  v128 = (_OWORD *)(v72 + 8);
  v73 = (OZChannelVaryingFolder_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v72 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v73 + 6) = v72;
  v74 = OZChannelVaryingFolder_Factory::getInstance(v73);
  v128 = (_OWORD *)(v74 + 8);
  v75 = (OZChannelObjectRootBase_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v74 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v75 + 6) = v74;
  v76 = OZChannelObjectRootBase_Factory::getInstance(v75);
  v128 = (_OWORD *)(v76 + 8);
  v77 = (OZChannelHistogram_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v76 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v77 + 6) = v76;
  v78 = OZChannelHistogram_Factory::getInstance(v77);
  v128 = (_OWORD *)(v78 + 8);
  v79 = (OZChannelLevels_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v78 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v79 + 6) = v78;
  v80 = OZChannelLevels_Factory::getInstance(v79);
  v128 = (_OWORD *)(v80 + 8);
  v81 = (OZChannelButton_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v80 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v81 + 6) = v80;
  v82 = OZChannelButton_Factory::getInstance(v81);
  v128 = (_OWORD *)(v82 + 8);
  v83 = (OZChannelHelpButton_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v82 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v83 + 6) = v82;
  v84 = OZChannelHelpButton_Factory::getInstance(v83);
  v128 = (_OWORD *)(v84 + 8);
  v85 = (OZChannelText_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v84 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v85 + 6) = v84;
  v86 = OZChannelText_Factory::getInstance(v85);
  v128 = (_OWORD *)(v86 + 8);
  v87 = (OZChannelDoubleOverRange_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v86 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v87 + 6) = v86;
  v88 = OZChannelDoubleOverRange_Factory::getInstance(v87);
  v128 = (_OWORD *)(v88 + 8);
  v89 = (OZChannelScaleOverRange_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v88 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v89 + 6) = v88;
  v90 = OZChannelScaleOverRange_Factory::getInstance(v89);
  v128 = (_OWORD *)(v90 + 8);
  v91 = (OZChannelAngleOverRange_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v90 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v91 + 6) = v90;
  v92 = OZChannelAngleOverRange_Factory::getInstance(v91);
  v128 = (_OWORD *)(v92 + 8);
  v93 = (OZChannelPercentOverRange_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v92 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v93 + 6) = v92;
  v94 = OZChannelPercentOverRange_Factory::getInstance(v93);
  v128 = (_OWORD *)(v94 + 8);
  v95 = (OZChannel2DOverRange_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v94 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v95 + 6) = v94;
  v96 = OZChannel2DOverRange_Factory::getInstance(v95);
  v128 = (_OWORD *)(v96 + 8);
  v97 = (OZChannelTransformSwitch_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v96 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v97 + 6) = v96;
  v98 = OZChannelTransformSwitch_Factory::getInstance(v97);
  v128 = (_OWORD *)(v98 + 8);
  v99 = (OZChannelUint16_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v98 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v99 + 6) = v98;
  v100 = OZChannelUint16_Factory::getInstance(v99);
  v128 = (_OWORD *)(v100 + 8);
  v101 = (OZChannelSeed_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v100 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v101 + 6) = v100;
  v102 = OZChannelSeed_Factory::getInstance(v101);
  v128 = (_OWORD *)(v102 + 8);
  v103 = (OZChannelDecibel_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v102 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v103 + 6) = v102;
  v104 = OZChannelDecibel_Factory::getInstance(v103);
  v128 = (_OWORD *)(v104 + 8);
  v105 = (OZChannelFrame_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v104 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v105 + 6) = v104;
  v106 = OZChannelFrame_Factory::getInstance(v105);
  v128 = (_OWORD *)(v106 + 8);
  v107 = (OZChannelTimecode_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v106 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v107 + 6) = v106;
  v108 = OZChannelTimecode_Factory::getInstance(v107);
  v128 = (_OWORD *)(v108 + 8);
  v109 = (OZChannelBlindData_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v108 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v109 + 6) = v108;
  v110 = OZChannelBlindData_Factory::getInstance(v109);
  v128 = (_OWORD *)(v110 + 8);
  v111 = (OZChannelCurve_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v110 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v111 + 6) = v110;
  v112 = OZChannelCurve_Factory::getInstance(v111);
  v128 = (_OWORD *)(v112 + 8);
  v113 = (OZChannelEnum_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v112 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v113 + 6) = v112;
  v114 = OZChannelEnum_Factory::getInstance(v113);
  v128 = (_OWORD *)(v114 + 8);
  v115 = (OZChannelGradientWithAngle_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v114 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v115 + 6) = v114;
  v116 = OZChannelGradientWithAngle_Factory::getInstance(v115);
  v128 = (_OWORD *)(v116 + 8);
  v117 = (OZChannelHistogramSample_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v116 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v117 + 6) = v116;
  v118 = OZChannelHistogramSample_Factory::getInstance(v117);
  v128 = (_OWORD *)(v118 + 8);
  v119 = (OZChannelProgress_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v118 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v119 + 6) = v118;
  v120 = OZChannelProgress_Factory::getInstance(v119);
  v128 = (_OWORD *)(v120 + 8);
  v121 = (OZChannelScaleOverLife_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v120 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v121 + 6) = v120;
  v122 = OZChannelScaleOverLife_Factory::getInstance(v121);
  v128 = (_OWORD *)(v122 + 8);
  v123 = (OZChannelVertexFolder_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v122 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v123 + 6) = v122;
  v124 = OZChannelVertexFolder_Factory::getInstance(v123);
  v128 = (_OWORD *)(v124 + 8);
  v125 = (OZChanObjectRef_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v124 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)v125 + 6) = v124;
  v126 = OZChanObjectRef_Factory::getInstance(v125);
  v128 = (_OWORD *)(v126 + 8);
  result = std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v126 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((_QWORD *)result + 6) = v126;
  return result;
}

void OZFactories::~OZFactories(OZFactories *this)
{
  *(_QWORD *)this = &off_1E654BA38;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 8, *((_QWORD **)this + 2));
  PCSingleton::~PCSingleton(this);
}

{
  *(_QWORD *)this = &off_1E654BA38;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 8, *((_QWORD **)this + 2));
  PCSingleton::~PCSingleton(this);
  JUMPOUT(0x1B5E29170);
}

_OWORD *OZFactories::addFactory(uint64_t **this, OZFactory *a2)
{
  _OWORD *result;
  _OWORD *v4;

  v4 = (_OWORD *)((char *)a2 + 8);
  result = std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(this + 1, (unsigned int *)a2 + 2, (uint64_t)&std::piecewise_construct, &v4);
  *((_QWORD *)result + 6) = a2;
  return result;
}

uint64_t OZChannelBase_Factory::getInstance(OZChannelBase_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelBase_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelBase_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelBase_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelBase_Factory::_instance;
}

uint64_t OZChannel_Factory::getInstance(OZChannel_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannel_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannel_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannel_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannel_Factory::_instance;
}

uint64_t OZChannelDouble_Factory::getInstance(OZChannelDouble_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelDouble_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelDouble_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelDouble_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelDouble_Factory::_instance;
}

uint64_t OZChannelBool_Factory::getInstance(OZChannelBool_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelBool_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelBool_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelBool_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelBool_Factory::_instance;
}

uint64_t OZChannelUint32_Factory::getInstance(OZChannelUint32_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelUint32_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelUint32_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelUint32_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelUint32_Factory::_instance;
}

uint64_t OZChannelAngle_Factory::getInstance(OZChannelAngle_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelAngle_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelAngle_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAngle_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAngle_Factory::_instance;
}

uint64_t OZChannelPercent_Factory::getInstance(OZChannelPercent_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelPercent_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelPercent_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelPercent_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelPercent_Factory::_instance;
}

uint64_t OZChannelShearAngle_Factory::getInstance(OZChannelShearAngle_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelShearAngle_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelShearAngle_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelShearAngle_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelShearAngle_Factory::_instance;
}

uint64_t OZChannelAspectRatio_Factory::getInstance(OZChannelAspectRatio_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelAspectRatio_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelAspectRatio_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatio_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAspectRatio_Factory::_instance;
}

uint64_t OZChannelAspectRatioFootage_Factory::getInstance(OZChannelAspectRatioFootage_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelAspectRatioFootage_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelAspectRatioFootage_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatioFootage_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAspectRatioFootage_Factory::_instance;
}

uint64_t OZChannelGammaFootage_Factory::getInstance(OZChannelGammaFootage_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelGammaFootage_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelGammaFootage_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGammaFootage_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGammaFootage_Factory::_instance;
}

uint64_t OZChannelFolder_Factory::getInstance(OZChannelFolder_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelFolder_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelFolder_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelFolder_Factory::_instance;
}

uint64_t OZCompoundChannel_Factory::getInstance(OZCompoundChannel_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZCompoundChannel_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZCompoundChannel_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZCompoundChannel_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZCompoundChannel_Factory::_instance;
}

uint64_t OZChannel2D_Factory::getInstance(OZChannel2D_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannel2D_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannel2D_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannel2D_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannel2D_Factory::_instance;
}

uint64_t OZChannelBool3D_Factory::getInstance(OZChannelBool3D_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelBool3D_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelBool3D_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelBool3D_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelBool3D_Factory::_instance;
}

uint64_t OZChannelPosition_Factory::getInstance(OZChannelPosition_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelPosition_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelPosition_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelPosition_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelPosition_Factory::_instance;
}

uint64_t OZChannelPositionPercent_Factory::getInstance(OZChannelPositionPercent_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelPositionPercent_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelPositionPercent_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelPositionPercent_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelPositionPercent_Factory::_instance;
}

uint64_t OZChannelShear_Factory::getInstance(OZChannelShear_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelShear_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelShear_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelShear_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelShear_Factory::_instance;
}

uint64_t OZChannelScale_Factory::getInstance(OZChannelScale_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelScale_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelScale_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelScale_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelScale_Factory::_instance;
}

uint64_t OZChannel3D_Factory::getInstance(OZChannel3D_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannel3D_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannel3D_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannel3D_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannel3D_Factory::_instance;
}

uint64_t OZChannelPosition3D_Factory::getInstance(OZChannelPosition3D_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelPosition3D_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelPosition3D_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelPosition3D_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelPosition3D_Factory::_instance;
}

uint64_t OZChannelRotation3D_Factory::getInstance(OZChannelRotation3D_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelRotation3D_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelRotation3D_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelRotation3D_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelRotation3D_Factory::_instance;
}

uint64_t OZChannelScale3D_Factory::getInstance(OZChannelScale3D_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelScale3D_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelScale3D_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelScale3D_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelScale3D_Factory::_instance;
}

uint64_t OZChannelColorNoAlpha_Factory::getInstance(OZChannelColorNoAlpha_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelColorNoAlpha_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelColorNoAlpha_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelColorNoAlpha_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelColorNoAlpha_Factory::_instance;
}

uint64_t OZChannelColor_Factory::getInstance(OZChannelColor_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelColor_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelColor_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelColor_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelColor_Factory::_instance;
}

uint64_t OZChannelQuad_Factory::getInstance(OZChannelQuad_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelQuad_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelQuad_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelQuad_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelQuad_Factory::_instance;
}

uint64_t OZChannelCrop_Factory::getInstance(OZChannelCrop_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelCrop_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelCrop_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelCrop_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelCrop_Factory::_instance;
}

uint64_t OZChannelDiscreteColor_Factory::getInstance(OZChannelDiscreteColor_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelDiscreteColor_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelDiscreteColor_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelDiscreteColor_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelDiscreteColor_Factory::_instance;
}

uint64_t OZChannelGradient_Factory::getInstance(OZChannelGradient_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelGradient_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelGradient_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradient_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradient_Factory::_instance;
}

uint64_t OZChannelGradientRGBFolder_Factory::getInstance(OZChannelGradientRGBFolder_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelGradientRGBFolder_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelGradientRGBFolder_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientRGBFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientRGBFolder_Factory::_instance;
}

uint64_t OZChannelGradientAlphaFolder_Factory::getInstance(OZChannelGradientAlphaFolder_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelGradientAlphaFolder_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelGradientAlphaFolder_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientAlphaFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientAlphaFolder_Factory::_instance;
}

uint64_t OZChannelGradientSample_Factory::getInstance(OZChannelGradientSample_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelGradientSample_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelGradientSample_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientSample_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientSample_Factory::_instance;
}

uint64_t OZChannelGradientSampleRGB_Factory::getInstance(OZChannelGradientSampleRGB_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelGradientSampleRGB_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelGradientSampleRGB_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientSampleRGB_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientSampleRGB_Factory::_instance;
}

uint64_t OZChannelGradientSampleAlpha_Factory::getInstance(OZChannelGradientSampleAlpha_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelGradientSampleAlpha_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelGradientSampleAlpha_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientSampleAlpha_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientSampleAlpha_Factory::_instance;
}

uint64_t OZChannelGradientExtras_Factory::getInstance(OZChannelGradientExtras_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelGradientExtras_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelGradientExtras_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientExtras_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientExtras_Factory::_instance;
}

uint64_t OZChannelGradientPositioned_Factory::getInstance(OZChannelGradientPositioned_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelGradientPositioned_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelGradientPositioned_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientPositioned_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientPositioned_Factory::_instance;
}

uint64_t OZChannelVaryingFolder_Factory::getInstance(OZChannelVaryingFolder_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelVaryingFolder_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelVaryingFolder_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelVaryingFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelVaryingFolder_Factory::_instance;
}

uint64_t OZChannelObjectRootBase_Factory::getInstance(OZChannelObjectRootBase_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelObjectRootBase_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelObjectRootBase_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelObjectRootBase_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelObjectRootBase_Factory::_instance;
}

uint64_t OZChannelHistogram_Factory::getInstance(OZChannelHistogram_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelHistogram_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelHistogram_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelHistogram_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelHistogram_Factory::_instance;
}

uint64_t OZChannelLevels_Factory::getInstance(OZChannelLevels_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelLevels_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelLevels_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelLevels_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelLevels_Factory::_instance;
}

uint64_t OZChannelButton_Factory::getInstance(OZChannelButton_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelButton_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelButton_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelButton_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelButton_Factory::_instance;
}

uint64_t OZChannelHelpButton_Factory::getInstance(OZChannelHelpButton_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelHelpButton_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelHelpButton_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelHelpButton_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelHelpButton_Factory::_instance;
}

uint64_t OZChannelText_Factory::getInstance(OZChannelText_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelText_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelText_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelText_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelText_Factory::_instance;
}

uint64_t OZChannelDoubleOverRange_Factory::getInstance(OZChannelDoubleOverRange_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelDoubleOverRange_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelDoubleOverRange_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelDoubleOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelDoubleOverRange_Factory::_instance;
}

uint64_t OZChannelScaleOverRange_Factory::getInstance(OZChannelScaleOverRange_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelScaleOverRange_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelScaleOverRange_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelScaleOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelScaleOverRange_Factory::_instance;
}

uint64_t OZChannelAngleOverRange_Factory::getInstance(OZChannelAngleOverRange_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelAngleOverRange_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelAngleOverRange_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAngleOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAngleOverRange_Factory::_instance;
}

uint64_t OZChannelPercentOverRange_Factory::getInstance(OZChannelPercentOverRange_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelPercentOverRange_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelPercentOverRange_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelPercentOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelPercentOverRange_Factory::_instance;
}

uint64_t OZChannel2DOverRange_Factory::getInstance(OZChannel2DOverRange_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannel2DOverRange_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannel2DOverRange_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannel2DOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannel2DOverRange_Factory::_instance;
}

uint64_t OZChannelTransformSwitch_Factory::getInstance(OZChannelTransformSwitch_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelTransformSwitch_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelTransformSwitch_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelTransformSwitch_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelTransformSwitch_Factory::_instance;
}

uint64_t OZChannelUint16_Factory::getInstance(OZChannelUint16_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelUint16_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelUint16_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelUint16_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelUint16_Factory::_instance;
}

uint64_t OZChannelSeed_Factory::getInstance(OZChannelSeed_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelSeed_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelSeed_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelSeed_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelSeed_Factory::_instance;
}

uint64_t OZChannelDecibel_Factory::getInstance(OZChannelDecibel_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelDecibel_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelDecibel_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelDecibel_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelDecibel_Factory::_instance;
}

uint64_t OZChannelFrame_Factory::getInstance(OZChannelFrame_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelFrame_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelFrame_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelFrame_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelFrame_Factory::_instance;
}

uint64_t OZChannelTimecode_Factory::getInstance(OZChannelTimecode_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelTimecode_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelTimecode_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelTimecode_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelTimecode_Factory::_instance;
}

uint64_t OZChannelBlindData_Factory::getInstance(OZChannelBlindData_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelBlindData_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelBlindData_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelBlindData_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelBlindData_Factory::_instance;
}

uint64_t OZChannelCurve_Factory::getInstance(OZChannelCurve_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelCurve_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelCurve_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelCurve_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelCurve_Factory::_instance;
}

uint64_t OZChannelEnum_Factory::getInstance(OZChannelEnum_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelEnum_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelEnum_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelEnum_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelEnum_Factory::_instance;
}

uint64_t OZChannelGradientWithAngle_Factory::getInstance(OZChannelGradientWithAngle_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelGradientWithAngle_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelGradientWithAngle_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientWithAngle_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientWithAngle_Factory::_instance;
}

uint64_t OZChannelHistogramSample_Factory::getInstance(OZChannelHistogramSample_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelHistogramSample_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelHistogramSample_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelHistogramSample_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelHistogramSample_Factory::_instance;
}

uint64_t OZChannelProgress_Factory::getInstance(OZChannelProgress_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelProgress_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelProgress_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelProgress_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelProgress_Factory::_instance;
}

uint64_t OZChannelScaleOverLife_Factory::getInstance(OZChannelScaleOverLife_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelScaleOverLife_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelScaleOverLife_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelScaleOverLife_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelScaleOverLife_Factory::_instance;
}

uint64_t OZChannelVertexFolder_Factory::getInstance(OZChannelVertexFolder_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelVertexFolder_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelVertexFolder_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelVertexFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelVertexFolder_Factory::_instance;
}

uint64_t OZChanObjectRef_Factory::getInstance(OZChanObjectRef_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChanObjectRef_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChanObjectRef_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChanObjectRef_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChanObjectRef_Factory::_instance;
}

_QWORD *OZFactories::getFactoryLoadMap(OZFactories *this)
{
  _QWORD *v1;

  if (!v1)
  {
    v1 = (_QWORD *)operator new();
    v1[2] = 0;
    v1[1] = 0;
    *v1 = v1 + 1;
  }
  return v1;
}

uint64_t **OZFactories::setFactoryLoadID(OZFactories *this, unsigned int a2, OZFactory *a3)
{
  uint64_t **FactoryLoadMap;
  uint64_t **result;
  unsigned int v6;
  unsigned int *v7;

  v6 = a2;
  FactoryLoadMap = (uint64_t **)OZFactories::getFactoryLoadMap(this);
  v7 = &v6;
  result = std::__tree<std::__value_type<unsigned int,PVImageBuffer * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVImageBuffer * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVImageBuffer * {__strong}>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(FactoryLoadMap, &v6, (uint64_t)&std::piecewise_construct, &v7);
  result[5] = (uint64_t *)a3;
  return result;
}

void OZFactories::clearFactoryLoadIDs(OZFactories *this)
{
  _QWORD *FactoryLoadMap;

  FactoryLoadMap = OZFactories::getFactoryLoadMap(this);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)FactoryLoadMap, (_QWORD *)FactoryLoadMap[1]);
  *FactoryLoadMap = FactoryLoadMap + 1;
  FactoryLoadMap[2] = 0;
  FactoryLoadMap[1] = 0;
}

uint64_t OZFactories::lookupFactory(OZFactories *this, unsigned int a2)
{
  _QWORD *FactoryLoadMap;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  unsigned int v8;
  BOOL v9;
  uint64_t *v10;

  FactoryLoadMap = OZFactories::getFactoryLoadMap(this);
  v6 = FactoryLoadMap[1];
  v4 = FactoryLoadMap + 1;
  v5 = v6;
  if (!v6)
    return 0;
  v7 = v4;
  do
  {
    v8 = *(_DWORD *)(v5 + 32);
    v9 = v8 >= a2;
    if (v8 >= a2)
      v10 = (uint64_t *)v5;
    else
      v10 = (uint64_t *)(v5 + 8);
    if (v9)
      v7 = (_QWORD *)v5;
    v5 = *v10;
  }
  while (*v10);
  if (v7 != v4 && *((_DWORD *)v7 + 8) <= a2)
    return v7[5];
  else
    return 0;
}

uint64_t OZFactories::findFactory(uint64_t a1, unsigned int *a2)
{
  _DWORD *v3;

  v3 = std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::find<PCUUID>(a1 + 8, a2);
  if ((_DWORD *)(a1 + 16) == v3)
    return 0;
  else
    return *((_QWORD *)v3 + 6);
}

uint64_t OZFactories::saveFactories(OZFactories *this, PCSerializerWriteStream *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  OZFactory *v7;
  const OZFactory *v8;
  unsigned int v9;
  unsigned int v10;
  char *v11;
  char *v12;
  BOOL v13;
  PCString v15;
  PCString v16;

  TXSequenceChannels::pushChannelIntoChannelList(a2, (OZChannelBase *)&OZFactoryScope);
  v4 = (char *)*((_QWORD *)this + 1);
  v5 = (char *)this + 16;
  if (v4 != (char *)this + 16)
  {
    v6 = 1;
    do
    {
      v7 = (OZFactory *)*((_QWORD *)v4 + 6);
      OZFactory::setFileRefID(v7, 0);
      if (OZFactory::needsSaving(v7, v8))
      {
        v9 = (*(uint64_t (**)(OZFactory *))(*(_QWORD *)v7 + 64))(v7);
        v10 = (*(uint64_t (**)(OZFactory *))(*(_QWORD *)v7 + 72))(v7);
        (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 92);
        (*(void (**)(PCSerializerWriteStream *, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 111, v6);
        (*(void (**)(PCSerializerWriteStream *, uint64_t, uint64_t))(*(_QWORD *)a2 + 192))(a2, 117, (uint64_t)v7 + 8);
        (*(void (**)(PCString *__return_ptr, OZFactory *))(*(_QWORD *)v7 + 40))(&v16, v7);
        (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 93);
        (*(void (**)(PCSerializerWriteStream *, PCString *))(*(_QWORD *)a2 + 104))(a2, &v16);
        (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
        PCString::~PCString(&v16);
        (*(void (**)(PCString *__return_ptr, OZFactory *))(*(_QWORD *)v7 + 56))(&v15, v7);
        (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 95);
        (*(void (**)(PCSerializerWriteStream *, PCString *))(*(_QWORD *)a2 + 104))(a2, &v15);
        (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
        PCString::~PCString(&v15);
        (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 94);
        (*(void (**)(PCSerializerWriteStream *, double))(*(_QWORD *)a2 + 88))(a2, (double)v10 * 0.1 + (double)v9);
        (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
        (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
        (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 224))(a2);
        OZFactory::setNeedsSaving(v7, 0);
        OZFactory::setFileRefID(v7, (const OZFactory *)v6);
        v6 = (v6 + 1);
      }
      v11 = (char *)*((_QWORD *)v4 + 1);
      if (v11)
      {
        do
        {
          v12 = v11;
          v11 = *(char **)v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          v12 = (char *)*((_QWORD *)v4 + 2);
          v13 = *(_QWORD *)v12 == (_QWORD)v4;
          v4 = v12;
        }
        while (!v13);
      }
      v4 = v12;
    }
    while (v12 != v5);
  }
  (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 224))(a2);
  PCSerializerWriteStream::popScope((uint64_t)a2);
  return 1;
}

void sub_1B2C11908(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCString::~PCString((PCString *)va);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::freeThreadSpecific(_anonymous_namespace_ *this, void *a2)
{
  _QWORD *v3;

  v3 = (_QWORD *)((char *)this + 8);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this, *((_QWORD **)this + 1));
  *(_QWORD *)this = v3;
  *((_QWORD *)this + 2) = 0;
  *v3 = 0;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this, 0);
  MEMORY[0x1B5E29170](this, 0x1020C4062D53EE8);
}

void std::__call_once_param<std::tuple<OZChannelBase_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelBase_Factory *v0;

  v0 = (OZChannelBase_Factory *)operator new();
  OZChannelBase_Factory::OZChannelBase_Factory(v0);
  OZChannelBase_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C119D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelBase_Factory::OZChannelBase_Factory(OZChannelBase_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v4 = xmmword_1B3555750;
  v3 = 0uLL;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654BA70;
  *((_QWORD *)this + 16) = &unk_1E654BB40;
}

void sub_1B2C11A70(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelBase *OZChannelBase_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelBase *v6;

  v6 = (OZChannelBase *)operator new();
  OZChannelBase::OZChannelBase(v6, this, a2, a3);
  return v6;
}

void sub_1B2C11AE0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40384E9B0FLL);
  _Unwind_Resume(a1);
}

OZChannelBase *OZChannelBase_Factory::createCopy(OZChannelBase_Factory *this, OZFactoryBase *a2)
{
  OZChannelBase *v3;
  const OZChannelBase *v4;

  v3 = (OZChannelBase *)operator new();
  OZChannelBase::OZChannelBase(v3, v4, 0);
  return v3;
}

void sub_1B2C11B6C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40384E9B0FLL);
  _Unwind_Resume(a1);
}

OZChannelBase *OZChannelBase_Factory::createChannelCopy(OZChannelBase_Factory *this, OZChannelBase *a2)
{
  OZChannelBase *v3;

  v3 = (OZChannelBase *)operator new();
  OZChannelBase::OZChannelBase(v3, a2, 0);
  return v3;
}

void sub_1B2C11BD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40384E9B0FLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannel_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannel_Factory *v0;

  v0 = (OZChannel_Factory *)operator new();
  OZChannel_Factory::OZChannel_Factory(v0);
  OZChannel_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C11C44(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannel_Factory::OZChannel_Factory(OZChannel_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555750;
  v4 = xmmword_1B3555760;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654BB98;
  *((_QWORD *)this + 16) = &unk_1E654BC68;
}

void sub_1B2C11CE4(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelDouble_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelDouble_Factory *v0;

  v0 = (OZChannelDouble_Factory *)operator new();
  OZChannelDouble_Factory::OZChannelDouble_Factory(v0);
  OZChannelDouble_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C11D40(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelDouble_Factory::OZChannelDouble_Factory(OZChannelDouble_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B3555770;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654BCC0;
  *((_QWORD *)this + 16) = &unk_1E654BD90;
}

void sub_1B2C11DE0(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelDouble *OZChannelDouble_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelDouble *v6;

  v6 = (OZChannelDouble *)operator new();
  OZChannelDouble::OZChannelDouble(v6, this, a2, a3, 0, 0);
  return v6;
}

void sub_1B2C11E58(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelDouble_Factory::createCopy(OZChannelDouble_Factory *this, OZFactoryBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6551358;
  v3->var2 = (void **)&unk_1E65516B8;
  return v3;
}

void sub_1B2C11EFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelDouble_Factory::createChannelCopy(OZChannelDouble_Factory *this, OZChannelBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6551358;
  v3->var2 = (void **)&unk_1E65516B8;
  return v3;
}

void sub_1B2C11FA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelDouble::OZChannelDouble(OZChannelDouble *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannelDouble *v9;
  OZChannelDouble *OZChannelDoubleInfo;
  uint64_t v11;
  uint64_t v12;

  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  *(_QWORD *)v9 = &off_1E6551358;
  *((_QWORD *)v9 + 2) = &unk_1E65516B8;
  OZChannelDoubleInfo = (OZChannelDouble *)OZChannelDouble::createOZChannelDoubleInfo(v9);
  if (a6)
  {
    v11 = *((_QWORD *)this + 17);
  }
  else
  {
    v11 = OZChannelDouble::_OZChannelDoubleInfo;
    *((_QWORD *)this + 17) = OZChannelDouble::_OZChannelDoubleInfo;
  }
  *((_QWORD *)this + 16) = v11;
  OZChannelDouble::createOZChannelDoubleImpl(OZChannelDoubleInfo);
  if (a5)
  {
    v12 = *((_QWORD *)this + 15);
  }
  else
  {
    v12 = OZChannelDouble::_OZChannelDoubleImpl;
    *((_QWORD *)this + 15) = OZChannelDouble::_OZChannelDoubleImpl;
  }
  *((_QWORD *)this + 14) = v12;
}

void sub_1B2C1206C(_Unwind_Exception *a1)
{
  OZChannel *v1;

  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelBool_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelBool_Factory *v0;

  v0 = (OZChannelBool_Factory *)operator new();
  OZChannelBool_Factory::OZChannelBool_Factory(v0);
  OZChannelBool_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C120C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelBool_Factory::OZChannelBool_Factory(OZChannelBool_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B3555780;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654BDE8;
  *((_QWORD *)this + 16) = &unk_1E654BEB8;
}

void sub_1B2C12168(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelBool *OZChannelBool_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelBool *v6;

  v6 = (OZChannelBool *)operator new();
  OZChannelBool::OZChannelBool(v6, this, a2, a3, 0, 0);
  return v6;
}

void sub_1B2C121E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannelBool *OZChannelBool_Factory::createCopy(OZChannelBool_Factory *this, OZFactoryBase *a2)
{
  OZChannelBool *v3;
  const OZChannelBase *v4;

  v3 = (OZChannelBool *)operator new();
  OZChannelBool::OZChannelBool(v3, v4, 0);
  return v3;
}

void sub_1B2C1226C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannelBool *OZChannelBool_Factory::createChannelCopy(OZChannelBool_Factory *this, OZChannelBase *a2)
{
  OZChannelBool *v3;
  const OZChannelBase *v4;

  v3 = (OZChannelBool *)operator new();
  OZChannelBool::OZChannelBool(v3, v4, 0);
  return v3;
}

void sub_1B2C122F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelUint32_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelUint32_Factory *v0;

  v0 = (OZChannelUint32_Factory *)operator new();
  OZChannelUint32_Factory::OZChannelUint32_Factory(v0);
  OZChannelUint32_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C12364(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelUint32_Factory::OZChannelUint32_Factory(OZChannelUint32_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B3555790;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654BF10;
  *((_QWORD *)this + 16) = &unk_1E654BFE0;
}

void sub_1B2C12404(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelUint32 *OZChannelUint32_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelUint32 *v6;

  v6 = (OZChannelUint32 *)operator new();
  OZChannelUint32::OZChannelUint32(v6, this, a2, a3, 0, 0);
  return v6;
}

void sub_1B2C1247C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelUint32_Factory::createCopy(OZChannelUint32_Factory *this, OZFactoryBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6551AF8;
  v3->var2 = (void **)&unk_1E6551E58;
  return v3;
}

void sub_1B2C12520(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelUint32_Factory::createChannelCopy(OZChannelUint32_Factory *this, OZChannelBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6551AF8;
  v3->var2 = (void **)&unk_1E6551E58;
  return v3;
}

void sub_1B2C125C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelUint32::OZChannelUint32(OZChannelUint32 *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannelUint32 *v9;
  OZChannelUint32 *OZChannelUint32Info;
  OZChannelInfo *var17;
  OZChannelImpl *var15;

  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&off_1E6551AF8;
  v9->var2 = (void **)&unk_1E6551E58;
  OZChannelUint32Info = (OZChannelUint32 *)OZChannelUint32::createOZChannelUint32Info(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelUint32::_OZChannelUint32Info;
    this->var17 = (OZChannelInfo *)OZChannelUint32::_OZChannelUint32Info;
  }
  this->var16 = var17;
  OZChannelUint32::createOZChannelUint32Impl(OZChannelUint32Info);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelUint32::_OZChannelUint32Impl;
    this->var15 = (OZChannelImpl *)OZChannelUint32::_OZChannelUint32Impl;
  }
  this->var14 = var15;
}

void sub_1B2C12690(_Unwind_Exception *a1)
{
  OZChannel *v1;

  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelAngle_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelAngle_Factory *v0;

  v0 = (OZChannelAngle_Factory *)operator new();
  OZChannelAngle_Factory::OZChannelAngle_Factory(v0);
  OZChannelAngle_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C126EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelAngle_Factory::OZChannelAngle_Factory(OZChannelAngle_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B35557A0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654C038;
  *((_QWORD *)this + 16) = &unk_1E654C108;
}

void sub_1B2C1278C(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelAngle *OZChannelAngle_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelAngle *v6;

  v6 = (OZChannelAngle *)operator new();
  OZChannelAngle::OZChannelAngle(v6, this, a2, a3, 0, 0);
  return v6;
}

void sub_1B2C12804(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelAngle_Factory::createCopy(OZChannelAngle_Factory *this, OZFactoryBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6551728;
  v3->var2 = (void **)&unk_1E6551A88;
  return v3;
}

void sub_1B2C128A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelAngle_Factory::createChannelCopy(OZChannelAngle_Factory *this, OZChannelBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6551728;
  v3->var2 = (void **)&unk_1E6551A88;
  return v3;
}

void sub_1B2C1294C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelAngle::OZChannelAngle(OZChannelAngle *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannelAngle *v9;
  OZChannelAngle *OZChannelAngleInfo;
  OZChannelInfo *var17;
  OZChannelImpl *var15;

  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&off_1E6551728;
  v9->var2 = (void **)&unk_1E6551A88;
  OZChannelAngleInfo = (OZChannelAngle *)OZChannelAngle::createOZChannelAngleInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelAngle::_OZChannelAngleInfo;
    this->var17 = (OZChannelInfo *)OZChannelAngle::_OZChannelAngleInfo;
  }
  this->var16 = var17;
  OZChannelAngle::createOZChannelAngleImpl(OZChannelAngleInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelAngle::_OZChannelAngleImpl;
    this->var15 = (OZChannelImpl *)OZChannelAngle::_OZChannelAngleImpl;
  }
  this->var14 = var15;
}

void sub_1B2C12A18(_Unwind_Exception *a1)
{
  OZChannel *v1;

  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelPercent_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelPercent_Factory *v0;

  v0 = (OZChannelPercent_Factory *)operator new();
  OZChannelPercent_Factory::OZChannelPercent_Factory(v0);
  OZChannelPercent_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C12A74(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelPercent_Factory::OZChannelPercent_Factory(OZChannelPercent_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B35557B0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654C160;
  *((_QWORD *)this + 16) = &unk_1E654C230;
}

void sub_1B2C12B14(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelPercent *OZChannelPercent_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelPercent *v6;

  v6 = (OZChannelPercent *)operator new();
  OZChannelPercent::OZChannelPercent(v6, this, a2, a3, 0, 0);
  return v6;
}

void sub_1B2C12B8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannelPercent *OZChannelPercent_Factory::createCopy(OZChannelPercent_Factory *this, OZFactoryBase *a2)
{
  OZChannelPercent *v3;
  const OZChannelBase *v4;

  v3 = (OZChannelPercent *)operator new();
  OZChannelPercent::OZChannelPercent(v3, v4, 0);
  return v3;
}

void sub_1B2C12C18(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannelPercent *OZChannelPercent_Factory::createChannelCopy(OZChannelPercent_Factory *this, OZChannelBase *a2)
{
  OZChannelPercent *v3;
  const OZChannelBase *v4;

  v3 = (OZChannelPercent *)operator new();
  OZChannelPercent::OZChannelPercent(v3, v4, 0);
  return v3;
}

void sub_1B2C12CA4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelShearAngle_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelShearAngle_Factory *v0;

  v0 = (OZChannelShearAngle_Factory *)operator new();
  OZChannelShearAngle_Factory::OZChannelShearAngle_Factory(v0);
  OZChannelShearAngle_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C12D10(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelShearAngle_Factory::OZChannelShearAngle_Factory(OZChannelShearAngle_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B35557C0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654C288;
  *((_QWORD *)this + 16) = &unk_1E654C358;
}

void sub_1B2C12DB0(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelShearAngle *OZChannelShearAngle_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelShearAngle *v6;

  v6 = (OZChannelShearAngle *)operator new();
  OZChannelShearAngle::OZChannelShearAngle(v6, this, a2, a3, 0, 0);
  return v6;
}

void sub_1B2C12E28(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelShearAngle_Factory::createCopy(OZChannelShearAngle_Factory *this, OZFactoryBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6552298;
  v3->var2 = (void **)&unk_1E65525F8;
  return v3;
}

void sub_1B2C12ECC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelShearAngle_Factory::createChannelCopy(OZChannelShearAngle_Factory *this, OZChannelBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6552298;
  v3->var2 = (void **)&unk_1E65525F8;
  return v3;
}

void sub_1B2C12F70(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelShearAngle::OZChannelShearAngle(OZChannelShearAngle *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannelShearAngle *v9;
  OZChannelShearAngle *OZChannelShearAngleInfo;
  OZChannelInfo *var17;
  OZChannelImpl *var15;

  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&off_1E6552298;
  v9->var2 = (void **)&unk_1E65525F8;
  OZChannelShearAngleInfo = (OZChannelShearAngle *)OZChannelShearAngle::createOZChannelShearAngleInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelShearAngle::_OZChannelShearAngleInfo;
    this->var17 = (OZChannelInfo *)OZChannelShearAngle::_OZChannelShearAngleInfo;
  }
  this->var16 = var17;
  OZChannelShearAngle::createOZChannelShearAngleImpl(OZChannelShearAngleInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelShearAngle::_OZChannelShearAngleImpl;
    this->var15 = (OZChannelImpl *)OZChannelShearAngle::_OZChannelShearAngleImpl;
  }
  this->var14 = var15;
}

void sub_1B2C1303C(_Unwind_Exception *a1)
{
  OZChannel *v1;

  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

uint64_t OZChannelShearAngle::createOZChannelShearAngleInfo(OZChannelShearAngle *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelShearAngle::createOZChannelShearAngleInfo(void)::_OZChannelShearAngleInfo_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelShearAngle::createOZChannelShearAngleInfo(void)::_OZChannelShearAngleInfo_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelShearAngle::createOZChannelShearAngleInfo(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelShearAngle::_OZChannelShearAngleInfo;
}

uint64_t OZChannelShearAngle::createOZChannelShearAngleImpl(OZChannelShearAngle *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelShearAngle::createOZChannelShearAngleImpl(void)::_OZChannelShearAngleImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelShearAngle::createOZChannelShearAngleImpl(void)::_OZChannelShearAngleImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelShearAngle::createOZChannelShearAngleImpl(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelShearAngle::_OZChannelShearAngleImpl;
}

void std::__call_once_param<std::tuple<OZChannelShearAngle::createOZChannelShearAngleInfo(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelShearAngleInfo *v0;

  if (!OZChannelShearAngle::_OZChannelShearAngleInfo)
  {
    v0 = (OZChannelShearAngleInfo *)operator new();
    OZChannelShearAngleInfo::OZChannelShearAngleInfo(v0);
    OZChannelShearAngle::_OZChannelShearAngleInfo = (uint64_t)v0;
  }
}

void sub_1B2C13160(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelShearAngleInfo::OZChannelShearAngleInfo(OZChannelShearAngleInfo *this)
{
  uint64_t v2;

  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, -1.57079633, 1.57079633, 0.0174532925, 0.000174532925, 57.2957795, "");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(_QWORD *)this = &unk_1E654C3B0;
  *((_QWORD *)this + 10) = &unk_1E654C3D0;
}

void sub_1B2C131FC(_Unwind_Exception *a1)
{
  OZChannelInfo *v1;

  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelShearAngle::createOZChannelShearAngleImpl(void)::{lambda(void)#1} &&>>()
{
  OZChannelShearAngle::createOZChannelShearAngleImpl(void)::{lambda(void)#1}::operator()();
}

void OZChannelShearAngle::createOZChannelShearAngleImpl(void)::{lambda(void)#1}::operator()()
{
  uint64_t v0;
  OZCurveAngle *v1;

  if (!OZChannelShearAngle::_OZChannelShearAngleImpl)
  {
    v0 = operator new();
    v1 = (OZCurveAngle *)operator new();
    OZCurveAngle::OZCurveAngle(v1, 0.0);
    OZChannelImpl::OZChannelImpl((OZChannelImpl *)v0, (OZCurve *)v1, 0.0, 1, 1);
    PCSingleton::PCSingleton((PCSingleton *)(v0 + 40), 100);
    *(_QWORD *)v0 = &unk_1E654C428;
    *(_QWORD *)(v0 + 40) = &unk_1E654C448;
    OZChannelShearAngle::_OZChannelShearAngleImpl = v0;
  }
}

void sub_1B2C132CC(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelAspectRatio_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelAspectRatio_Factory *v0;

  v0 = (OZChannelAspectRatio_Factory *)operator new();
  OZChannelAspectRatio_Factory::OZChannelAspectRatio_Factory(v0);
  OZChannelAspectRatio_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1336C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatio_Factory::OZChannelAspectRatio_Factory(OZChannelAspectRatio_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B35557D0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654C4A0;
  *((_QWORD *)this + 16) = &unk_1E654C570;
}

void sub_1B2C1340C(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelAspectRatio *OZChannelAspectRatio_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelAspectRatio *v6;

  v6 = (OZChannelAspectRatio *)operator new();
  OZChannelAspectRatio::OZChannelAspectRatio(v6, this, a2, a3, 0, 0);
  return v6;
}

void sub_1B2C13484(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelAspectRatio_Factory::createCopy(OZChannelAspectRatio_Factory *this, OZFactoryBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6552668;
  v3->var2 = (void **)&unk_1E65529C8;
  return v3;
}

void sub_1B2C13528(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelAspectRatio_Factory::createChannelCopy(OZChannelAspectRatio_Factory *this, OZChannelBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6552668;
  v3->var2 = (void **)&unk_1E65529C8;
  return v3;
}

void sub_1B2C135CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatio::OZChannelAspectRatio(OZChannelAspectRatio *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannelAspectRatio *v9;
  OZChannelAspectRatio *OZChannelAspectRatioInfo;
  OZChannelInfo *var17;
  OZChannelImpl *var15;

  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&off_1E6552668;
  v9->var2 = (void **)&unk_1E65529C8;
  OZChannelAspectRatioInfo = (OZChannelAspectRatio *)OZChannelAspectRatio::createOZChannelAspectRatioInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelAspectRatio::_OZChannelAspectRatioInfo;
    this->var17 = (OZChannelInfo *)OZChannelAspectRatio::_OZChannelAspectRatioInfo;
  }
  this->var16 = var17;
  OZChannelAspectRatio::createOZChannelAspectRatioImpl(OZChannelAspectRatioInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelAspectRatio::_OZChannelAspectRatioImpl;
    this->var15 = (OZChannelImpl *)OZChannelAspectRatio::_OZChannelAspectRatioImpl;
  }
  this->var14 = var15;
}

void sub_1B2C13698(_Unwind_Exception *a1)
{
  OZChannel *v1;

  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

uint64_t OZChannelAspectRatio::createOZChannelAspectRatioInfo(OZChannelAspectRatio *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelAspectRatio::createOZChannelAspectRatioInfo(void)::_OZChannelAspectRatioInfo_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelAspectRatio::createOZChannelAspectRatioInfo(void)::_OZChannelAspectRatioInfo_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatio::createOZChannelAspectRatioInfo(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAspectRatio::_OZChannelAspectRatioInfo;
}

uint64_t OZChannelAspectRatio::createOZChannelAspectRatioImpl(OZChannelAspectRatio *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelAspectRatio::createOZChannelAspectRatioImpl(void)::_OZChannelAspectRatioImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelAspectRatio::createOZChannelAspectRatioImpl(void)::_OZChannelAspectRatioImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatio::createOZChannelAspectRatioImpl(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAspectRatio::_OZChannelAspectRatioImpl;
}

void std::__call_once_param<std::tuple<OZChannelAspectRatio::createOZChannelAspectRatioInfo(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelAspectRatioInfo *v0;

  if (!OZChannelAspectRatio::_OZChannelAspectRatioInfo)
  {
    v0 = (OZChannelAspectRatioInfo *)operator new();
    OZChannelAspectRatioInfo::OZChannelAspectRatioInfo(v0);
    OZChannelAspectRatio::_OZChannelAspectRatioInfo = (uint64_t)v0;
  }
}

void sub_1B2C137BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatioInfo::OZChannelAspectRatioInfo(OZChannelAspectRatioInfo *this)
{
  uint64_t v2;

  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 3.0, 0.0001, 0.1, 1.0, "");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(_QWORD *)this = &unk_1E654C5C8;
  *((_QWORD *)this + 10) = &unk_1E654C5E8;
}

void sub_1B2C1384C(_Unwind_Exception *a1)
{
  OZChannelInfo *v1;

  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatio::createOZChannelAspectRatioImpl(void)::{lambda(void)#1} &&>>()
{
  OZChannelAspectRatio::createOZChannelAspectRatioImpl(void)::{lambda(void)#1}::operator()();
}

void OZChannelAspectRatio::createOZChannelAspectRatioImpl(void)::{lambda(void)#1}::operator()()
{
  uint64_t v0;
  OZCurveDouble *v1;

  if (!OZChannelAspectRatio::_OZChannelAspectRatioImpl)
  {
    v0 = operator new();
    v1 = (OZCurveDouble *)operator new();
    OZCurveDouble::OZCurveDouble(v1, 1.0);
    OZChannelImpl::OZChannelImpl((OZChannelImpl *)v0, (OZCurve *)v1, 1.0, 0, 1);
    PCSingleton::PCSingleton((PCSingleton *)(v0 + 40), 100);
    *(_QWORD *)v0 = &unk_1E654C640;
    *(_QWORD *)(v0 + 40) = &unk_1E654C660;
    OZChannelAspectRatio::_OZChannelAspectRatioImpl = v0;
  }
}

void sub_1B2C1391C(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelAspectRatioFootage_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelAspectRatioFootage_Factory *v0;

  v0 = (OZChannelAspectRatioFootage_Factory *)operator new();
  OZChannelAspectRatioFootage_Factory::OZChannelAspectRatioFootage_Factory(v0);
  OZChannelAspectRatioFootage_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C139BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatioFootage_Factory::OZChannelAspectRatioFootage_Factory(OZChannelAspectRatioFootage_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B35557E0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654C6B8;
  *((_QWORD *)this + 16) = &unk_1E654C788;
}

void sub_1B2C13A5C(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelAspectRatioFootage *OZChannelAspectRatioFootage_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelAspectRatioFootage *v6;

  v6 = (OZChannelAspectRatioFootage *)operator new();
  OZChannelAspectRatioFootage::OZChannelAspectRatioFootage(v6, this, a2, a3, 0, 0);
  return v6;
}

void sub_1B2C13AD4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelAspectRatioFootage_Factory::createCopy(OZChannelAspectRatioFootage_Factory *this, OZFactoryBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6552A38;
  v3->var2 = (void **)&unk_1E6552D98;
  return v3;
}

void sub_1B2C13B78(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelAspectRatioFootage_Factory::createChannelCopy(OZChannelAspectRatioFootage_Factory *this, OZChannelBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6552A38;
  v3->var2 = (void **)&unk_1E6552D98;
  return v3;
}

void sub_1B2C13C1C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatioFootage::OZChannelAspectRatioFootage(OZChannelAspectRatioFootage *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannelAspectRatioFootage *v9;
  OZChannelAspectRatioFootage *OZChannelAspectRatioFootageInfo;
  OZChannelInfo *var17;
  OZChannelImpl *var15;

  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&off_1E6552A38;
  v9->var2 = (void **)&unk_1E6552D98;
  OZChannelAspectRatioFootageInfo = (OZChannelAspectRatioFootage *)OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageInfo;
    this->var17 = (OZChannelInfo *)OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageInfo;
  }
  this->var16 = var17;
  OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageImpl(OZChannelAspectRatioFootageInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageImpl;
    this->var15 = (OZChannelImpl *)OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageImpl;
  }
  this->var14 = var15;
}

void sub_1B2C13CE8(_Unwind_Exception *a1)
{
  OZChannel *v1;

  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

uint64_t OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageInfo(OZChannelAspectRatioFootage *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageInfo(void)::_OZChannelAspectRatioFootageInfo_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageInfo(void)::_OZChannelAspectRatioFootageInfo_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageInfo(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageInfo;
}

uint64_t OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageImpl(OZChannelAspectRatioFootage *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageImpl(void)::_OZChannelAspectRatioFootageImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageImpl(void)::_OZChannelAspectRatioFootageImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageImpl(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageImpl;
}

void std::__call_once_param<std::tuple<OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageInfo(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelAspectRatioFootageInfo *v0;

  if (!OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageInfo)
  {
    v0 = (OZChannelAspectRatioFootageInfo *)operator new();
    OZChannelAspectRatioFootageInfo::OZChannelAspectRatioFootageInfo(v0);
    OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageInfo = (uint64_t)v0;
  }
}

void sub_1B2C13E0C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatioFootageInfo::OZChannelAspectRatioFootageInfo(OZChannelAspectRatioFootageInfo *this)
{
  uint64_t v2;

  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 3.0, 0.0001, 0.1, 1.0, "");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(_QWORD *)this = &unk_1E654C7E0;
  *((_QWORD *)this + 10) = &unk_1E654C800;
}

void sub_1B2C13E9C(_Unwind_Exception *a1)
{
  OZChannelInfo *v1;

  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageImpl(void)::{lambda(void)#1} &&>>()
{
  OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageImpl(void)::{lambda(void)#1}::operator()();
}

void OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageImpl(void)::{lambda(void)#1}::operator()()
{
  uint64_t v0;
  OZCurveDouble *v1;

  if (!OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageImpl)
  {
    v0 = operator new();
    v1 = (OZCurveDouble *)operator new();
    OZCurveDouble::OZCurveDouble(v1, 1.0);
    OZChannelImpl::OZChannelImpl((OZChannelImpl *)v0, (OZCurve *)v1, 1.0, 0, 1);
    PCSingleton::PCSingleton((PCSingleton *)(v0 + 40), 100);
    *(_QWORD *)v0 = &unk_1E654C858;
    *(_QWORD *)(v0 + 40) = &unk_1E654C878;
    OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageImpl = v0;
  }
}

void sub_1B2C13F6C(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGammaFootage_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelGammaFootage_Factory *v0;

  v0 = (OZChannelGammaFootage_Factory *)operator new();
  OZChannelGammaFootage_Factory::OZChannelGammaFootage_Factory(v0);
  OZChannelGammaFootage_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1400C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGammaFootage_Factory::OZChannelGammaFootage_Factory(OZChannelGammaFootage_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B35557F0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654C8D0;
  *((_QWORD *)this + 16) = &unk_1E654C9A0;
}

void sub_1B2C140AC(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelGammaFootage *OZChannelGammaFootage_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelGammaFootage *v6;

  v6 = (OZChannelGammaFootage *)operator new();
  OZChannelGammaFootage::OZChannelGammaFootage(v6, this, a2, a3, 0, 0);
  return v6;
}

void sub_1B2C14124(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelGammaFootage_Factory::createCopy(OZChannelGammaFootage_Factory *this, OZFactoryBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6552E08;
  v3->var2 = (void **)&unk_1E6553168;
  return v3;
}

void sub_1B2C141C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelGammaFootage_Factory::createChannelCopy(OZChannelGammaFootage_Factory *this, OZChannelBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6552E08;
  v3->var2 = (void **)&unk_1E6553168;
  return v3;
}

void sub_1B2C1426C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelGammaFootage::OZChannelGammaFootage(OZChannelGammaFootage *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannelGammaFootage *v9;
  OZChannelGammaFootage *OZChannelGammaFootageInfo;
  OZChannelInfo *var17;
  OZChannelImpl *var15;

  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&off_1E6552E08;
  v9->var2 = (void **)&unk_1E6553168;
  OZChannelGammaFootageInfo = (OZChannelGammaFootage *)OZChannelGammaFootage::createOZChannelGammaFootageInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelGammaFootage::_OZChannelGammaFootageInfo;
    this->var17 = (OZChannelInfo *)OZChannelGammaFootage::_OZChannelGammaFootageInfo;
  }
  this->var16 = var17;
  OZChannelGammaFootage::createOZChannelGammaFootageImpl(OZChannelGammaFootageInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelGammaFootage::_OZChannelGammaFootageImpl;
    this->var15 = (OZChannelImpl *)OZChannelGammaFootage::_OZChannelGammaFootageImpl;
  }
  this->var14 = var15;
}

void sub_1B2C14338(_Unwind_Exception *a1)
{
  OZChannel *v1;

  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

uint64_t OZChannelGammaFootage::createOZChannelGammaFootageInfo(OZChannelGammaFootage *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelGammaFootage::createOZChannelGammaFootageInfo(void)::_OZChannelGammaFootageInfo_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelGammaFootage::createOZChannelGammaFootageInfo(void)::_OZChannelGammaFootageInfo_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGammaFootage::createOZChannelGammaFootageInfo(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGammaFootage::_OZChannelGammaFootageInfo;
}

uint64_t OZChannelGammaFootage::createOZChannelGammaFootageImpl(OZChannelGammaFootage *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelGammaFootage::createOZChannelGammaFootageImpl(void)::_OZChannelGammaFootageImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelGammaFootage::createOZChannelGammaFootageImpl(void)::_OZChannelGammaFootageImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGammaFootage::createOZChannelGammaFootageImpl(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGammaFootage::_OZChannelGammaFootageImpl;
}

void std::__call_once_param<std::tuple<OZChannelGammaFootage::createOZChannelGammaFootageInfo(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelGammaFootageInfo *v0;

  if (!OZChannelGammaFootage::_OZChannelGammaFootageInfo)
  {
    v0 = (OZChannelGammaFootageInfo *)operator new();
    OZChannelGammaFootageInfo::OZChannelGammaFootageInfo(v0);
    OZChannelGammaFootage::_OZChannelGammaFootageInfo = (uint64_t)v0;
  }
}

void sub_1B2C1445C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelGammaFootageInfo::OZChannelGammaFootageInfo(OZChannelGammaFootageInfo *this)
{
  uint64_t v2;

  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 3.0, 0.0001, 0.1, 1.0, "");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(_QWORD *)this = &unk_1E654C9F8;
  *((_QWORD *)this + 10) = &unk_1E654CA18;
}

void sub_1B2C144EC(_Unwind_Exception *a1)
{
  OZChannelInfo *v1;

  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGammaFootage::createOZChannelGammaFootageImpl(void)::{lambda(void)#1} &&>>()
{
  OZChannelGammaFootage::createOZChannelGammaFootageImpl(void)::{lambda(void)#1}::operator()();
}

void OZChannelGammaFootage::createOZChannelGammaFootageImpl(void)::{lambda(void)#1}::operator()()
{
  uint64_t v0;
  OZCurveDouble *v1;

  if (!OZChannelGammaFootage::_OZChannelGammaFootageImpl)
  {
    v0 = operator new();
    v1 = (OZCurveDouble *)operator new();
    OZCurveDouble::OZCurveDouble(v1, 0.0);
    OZChannelImpl::OZChannelImpl((OZChannelImpl *)v0, (OZCurve *)v1, 0.0, 0, 1);
    PCSingleton::PCSingleton((PCSingleton *)(v0 + 40), 100);
    *(_QWORD *)v0 = &unk_1E654CA70;
    *(_QWORD *)(v0 + 40) = &unk_1E654CA90;
    OZChannelGammaFootage::_OZChannelGammaFootageImpl = v0;
  }
}

void sub_1B2C145BC(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelFolder_Factory *v0;

  v0 = (OZChannelFolder_Factory *)operator new();
  OZChannelFolder_Factory::OZChannelFolder_Factory(v0);
  OZChannelFolder_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1465C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelFolder_Factory::OZChannelFolder_Factory(OZChannelFolder_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555750;
  v4 = xmmword_1B3053A10;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654CAE8;
  *((_QWORD *)this + 16) = &unk_1E654CBB8;
}

void sub_1B2C146FC(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelFolder *OZChannelFolder_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelFolder *v6;

  v6 = (OZChannelFolder *)operator new();
  OZChannelFolder::OZChannelFolder(v6, this, a2, a3, 0);
  return v6;
}

void sub_1B2C14770(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

OZChannelFolder *OZChannelFolder_Factory::createCopy(OZChannelFolder_Factory *this, OZFactoryBase *a2)
{
  OZChannelFolder *v3;
  const OZChannelFolder *v4;

  v3 = (OZChannelFolder *)operator new();
  OZChannelFolder::OZChannelFolder(v3, v4, 0);
  return v3;
}

void sub_1B2C147FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

OZChannelFolder *OZChannelFolder_Factory::createChannelCopy(OZChannelFolder_Factory *this, OZChannelBase *a2)
{
  OZChannelFolder *v3;
  const OZChannelFolder *v4;

  v3 = (OZChannelFolder *)operator new();
  OZChannelFolder::OZChannelFolder(v3, v4, 0);
  return v3;
}

void sub_1B2C14888(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZCompoundChannel_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZCompoundChannel_Factory *v0;

  v0 = (OZCompoundChannel_Factory *)operator new();
  OZCompoundChannel_Factory::OZCompoundChannel_Factory(v0);
  OZCompoundChannel_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C148F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZCompoundChannel_Factory::OZCompoundChannel_Factory(OZCompoundChannel_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3053A10;
  v4 = xmmword_1B3054CD0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654CC10;
  *((_QWORD *)this + 16) = &unk_1E654CCE0;
}

void sub_1B2C14994(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZCompoundChannel *OZCompoundChannel_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZCompoundChannel *v6;

  v6 = (OZCompoundChannel *)operator new();
  OZCompoundChannel::OZCompoundChannel(v6, this, a2, a3, 0);
  return v6;
}

void sub_1B2C14A08(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40441104D3);
  _Unwind_Resume(a1);
}

OZCompoundChannel *OZCompoundChannel_Factory::createCopy(OZCompoundChannel_Factory *this, OZFactoryBase *a2)
{
  OZCompoundChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZCompoundChannel *)operator new();
  OZCompoundChannel::OZCompoundChannel(v3, v4, 0);
  return v3;
}

void sub_1B2C14A94(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40441104D3);
  _Unwind_Resume(a1);
}

OZCompoundChannel *OZCompoundChannel_Factory::createChannelCopy(OZCompoundChannel_Factory *this, OZChannelBase *a2)
{
  OZCompoundChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZCompoundChannel *)operator new();
  OZCompoundChannel::OZCompoundChannel(v3, v4, 0);
  return v3;
}

void sub_1B2C14B20(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40441104D3);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannel2D_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannel2D_Factory *v0;

  v0 = (OZChannel2D_Factory *)operator new();
  OZChannel2D_Factory::OZChannel2D_Factory(v0);
  OZChannel2D_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C14B8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannel2D_Factory::OZChannel2D_Factory(OZChannel2D_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3054CD0;
  v4 = xmmword_1B3555800;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654CD38;
  *((_QWORD *)this + 16) = &unk_1E654CE08;
}

void sub_1B2C14C2C(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannel2D *OZChannel2D_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannel2D *v6;

  v6 = (OZChannel2D *)operator new();
  OZChannel2D::OZChannel2D(v6, this, a2, a3, 2u, 0, 0);
  return v6;
}

void sub_1B2C14CA8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

OZChannel2D *OZChannel2D_Factory::createCopy(OZChannel2D_Factory *this, OZFactoryBase *a2)
{
  OZChannel2D *v3;
  const OZChannel2D *v4;

  v3 = (OZChannel2D *)operator new();
  OZChannel2D::OZChannel2D(v3, v4, 0);
  return v3;
}

void sub_1B2C14D34(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

OZChannel2D *OZChannel2D_Factory::createChannelCopy(OZChannel2D_Factory *this, OZChannelBase *a2)
{
  OZChannel2D *v3;
  const OZChannel2D *v4;

  v3 = (OZChannel2D *)operator new();
  OZChannel2D::OZChannel2D(v3, v4, 0);
  return v3;
}

void sub_1B2C14DC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelBool3D_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelBool3D_Factory *v0;

  v0 = (OZChannelBool3D_Factory *)operator new();
  OZChannelBool3D_Factory::OZChannelBool3D_Factory(v0);
  OZChannelBool3D_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C14E2C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelBool3D_Factory::OZChannelBool3D_Factory(OZChannelBool3D_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3054CD0;
  v4 = xmmword_1B3555810;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654CE60;
  *((_QWORD *)this + 16) = &unk_1E654CF30;
}

void sub_1B2C14ECC(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelBool3D *OZChannelBool3D_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelBool3D *v6;

  v6 = (OZChannelBool3D *)operator new();
  OZChannelBool3D::OZChannelBool3D(v6, this, a2, a3, 3u);
  return v6;
}

void sub_1B2C14F40(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

OZChannelBool3D *OZChannelBool3D_Factory::createCopy(OZChannelBool3D_Factory *this, OZFactoryBase *a2)
{
  OZChannelBool3D *v3;
  const OZChannelBool3D *v4;

  v3 = (OZChannelBool3D *)operator new();
  OZChannelBool3D::OZChannelBool3D(v3, v4, 0);
  return v3;
}

void sub_1B2C14FCC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

OZChannelBool3D *OZChannelBool3D_Factory::createChannelCopy(OZChannelBool3D_Factory *this, OZChannelBase *a2)
{
  OZChannelBool3D *v3;
  const OZChannelBool3D *v4;

  v3 = (OZChannelBool3D *)operator new();
  OZChannelBool3D::OZChannelBool3D(v3, v4, 0);
  return v3;
}

void sub_1B2C15058(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelPosition_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelPosition_Factory *v0;

  v0 = (OZChannelPosition_Factory *)operator new();
  OZChannelPosition_Factory::OZChannelPosition_Factory(v0);
  OZChannelPosition_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C150C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelPosition_Factory::OZChannelPosition_Factory(OZChannelPosition_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555800;
  v4 = xmmword_1B3555820;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654CF88;
  *((_QWORD *)this + 16) = &unk_1E654D058;
}

void sub_1B2C15164(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelPosition *OZChannelPosition_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelPosition *v6;

  v6 = (OZChannelPosition *)operator new();
  OZChannelPosition::OZChannelPosition(v6, this, a2, a3, 2u, 0, 0);
  return v6;
}

void sub_1B2C151E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C4011F1C4E7);
  _Unwind_Resume(a1);
}

OZChannelPosition *OZChannelPosition_Factory::createCopy(OZChannelPosition_Factory *this, OZFactoryBase *a2)
{
  OZChannelPosition *v3;
  const OZChannelPosition *v4;

  v3 = (OZChannelPosition *)operator new();
  OZChannelPosition::OZChannelPosition(v3, v4, 0);
  return v3;
}

void sub_1B2C1526C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C4011F1C4E7);
  _Unwind_Resume(a1);
}

OZChannelPosition *OZChannelPosition_Factory::createChannelCopy(OZChannelPosition_Factory *this, OZChannelBase *a2)
{
  OZChannelPosition *v3;
  const OZChannelPosition *v4;

  v3 = (OZChannelPosition *)operator new();
  OZChannelPosition::OZChannelPosition(v3, v4, 0);
  return v3;
}

void sub_1B2C152F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C4011F1C4E7);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelPositionPercent_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelPositionPercent_Factory *v0;

  v0 = (OZChannelPositionPercent_Factory *)operator new();
  OZChannelPositionPercent_Factory::OZChannelPositionPercent_Factory(v0);
  OZChannelPositionPercent_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C15364(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelPositionPercent_Factory::OZChannelPositionPercent_Factory(OZChannelPositionPercent_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555800;
  v4 = xmmword_1B3555830;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654D0B0;
  *((_QWORD *)this + 16) = &unk_1E654D180;
}

void sub_1B2C15404(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelPositionPercent *OZChannelPositionPercent_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelPositionPercent *v6;

  v6 = (OZChannelPositionPercent *)operator new();
  OZChannelPositionPercent::OZChannelPositionPercent(v6, this, a2, a3);
  return v6;
}

void sub_1B2C15474(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40D0902988);
  _Unwind_Resume(a1);
}

OZChannelPositionPercent *OZChannelPositionPercent_Factory::createCopy(OZChannelPositionPercent_Factory *this, OZFactoryBase *a2)
{
  OZChannelPositionPercent *v3;
  const OZChannelPositionPercent *v4;

  v3 = (OZChannelPositionPercent *)operator new();
  OZChannelPositionPercent::OZChannelPositionPercent(v3, v4, 0);
  return v3;
}

void sub_1B2C15500(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40D0902988);
  _Unwind_Resume(a1);
}

OZChannelPositionPercent *OZChannelPositionPercent_Factory::createChannelCopy(OZChannelPositionPercent_Factory *this, OZChannelBase *a2)
{
  OZChannelPositionPercent *v3;
  const OZChannelPositionPercent *v4;

  v3 = (OZChannelPositionPercent *)operator new();
  OZChannelPositionPercent::OZChannelPositionPercent(v3, v4, 0);
  return v3;
}

void sub_1B2C1558C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40D0902988);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelShear_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelShear_Factory *v0;

  v0 = (OZChannelShear_Factory *)operator new();
  OZChannelShear_Factory::OZChannelShear_Factory(v0);
  OZChannelShear_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C155F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelShear_Factory::OZChannelShear_Factory(OZChannelShear_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3054CD0;
  v4 = xmmword_1B3555840;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654D1D8;
  *((_QWORD *)this + 16) = &unk_1E654D2A8;
}

void sub_1B2C15698(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelShear *OZChannelShear_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelShear *v6;

  v6 = (OZChannelShear *)operator new();
  OZChannelShear::OZChannelShear(v6, this, a2, a3, 2u);
  return v6;
}

void sub_1B2C1570C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

OZChannelShear *OZChannelShear_Factory::createCopy(OZChannelShear_Factory *this, OZFactoryBase *a2)
{
  OZChannelShear *v3;
  const OZChannelShear *v4;

  v3 = (OZChannelShear *)operator new();
  OZChannelShear::OZChannelShear(v3, v4, 0);
  return v3;
}

void sub_1B2C15798(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

OZChannelShear *OZChannelShear_Factory::createChannelCopy(OZChannelShear_Factory *this, OZChannelBase *a2)
{
  OZChannelShear *v3;
  const OZChannelShear *v4;

  v3 = (OZChannelShear *)operator new();
  OZChannelShear::OZChannelShear(v3, v4, 0);
  return v3;
}

void sub_1B2C15824(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelScale_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelScale_Factory *v0;

  v0 = (OZChannelScale_Factory *)operator new();
  OZChannelScale_Factory::OZChannelScale_Factory(v0);
  OZChannelScale_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C15890(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelScale_Factory::OZChannelScale_Factory(OZChannelScale_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555800;
  v4 = xmmword_1B3555850;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654D300;
  *((_QWORD *)this + 16) = &unk_1E654D3D0;
}

void sub_1B2C15930(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelScale *OZChannelScale_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelScale *v6;

  v6 = (OZChannelScale *)operator new();
  OZChannelScale::OZChannelScale(v6, this, a2, a3);
  return v6;
}

void sub_1B2C159A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

OZChannelScale *OZChannelScale_Factory::createCopy(OZChannelScale_Factory *this, OZFactoryBase *a2)
{
  OZChannelScale *v3;
  const OZChannelScale *v4;

  v3 = (OZChannelScale *)operator new();
  OZChannelScale::OZChannelScale(v3, v4, 0);
  return v3;
}

void sub_1B2C15A2C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

OZChannelScale *OZChannelScale_Factory::createChannelCopy(OZChannelScale_Factory *this, OZChannelBase *a2)
{
  OZChannelScale *v3;
  const OZChannelScale *v4;

  v3 = (OZChannelScale *)operator new();
  OZChannelScale::OZChannelScale(v3, v4, 0);
  return v3;
}

void sub_1B2C15AB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannel3D_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannel3D_Factory *v0;

  v0 = (OZChannel3D_Factory *)operator new();
  OZChannel3D_Factory::OZChannel3D_Factory(v0);
  OZChannel3D_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C15B24(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannel3D_Factory::OZChannel3D_Factory(OZChannel3D_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3054CD0;
  v4 = xmmword_1B3555860;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654D428;
  *((_QWORD *)this + 16) = &unk_1E654D4F8;
}

void sub_1B2C15BC4(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannel3D *OZChannel3D_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannel3D *v6;

  v6 = (OZChannel3D *)operator new();
  OZChannel3D::OZChannel3D(v6, this, a2, a3, 3u, 0, 0);
  return v6;
}

void sub_1B2C15C40(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

OZChannel3D *OZChannel3D_Factory::createCopy(OZChannel3D_Factory *this, OZFactoryBase *a2)
{
  OZChannel3D *v3;
  const OZChannel3D *v4;

  v3 = (OZChannel3D *)operator new();
  OZChannel3D::OZChannel3D(v3, v4, 0);
  return v3;
}

void sub_1B2C15CCC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

OZChannel3D *OZChannel3D_Factory::createChannelCopy(OZChannel3D_Factory *this, OZChannelBase *a2)
{
  OZChannel3D *v3;
  const OZChannel3D *v4;

  v3 = (OZChannel3D *)operator new();
  OZChannel3D::OZChannel3D(v3, v4, 0);
  return v3;
}

void sub_1B2C15D58(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelPosition3D_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelPosition3D_Factory *v0;

  v0 = (OZChannelPosition3D_Factory *)operator new();
  OZChannelPosition3D_Factory::OZChannelPosition3D_Factory(v0);
  OZChannelPosition3D_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C15DC4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelPosition3D_Factory::OZChannelPosition3D_Factory(OZChannelPosition3D_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555820;
  v4 = xmmword_1B3555870;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654D550;
  *((_QWORD *)this + 16) = &unk_1E654D620;
}

void sub_1B2C15E64(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelPosition3D *OZChannelPosition3D_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelPosition3D *v6;

  v6 = (OZChannelPosition3D *)operator new();
  OZChannelPosition3D::OZChannelPosition3D(v6, this, a2, a3, 3u);
  return v6;
}

void sub_1B2C15ED8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40CC6A35F7);
  _Unwind_Resume(a1);
}

OZChannelPosition3D *OZChannelPosition3D_Factory::createCopy(OZChannelPosition3D_Factory *this, OZFactoryBase *a2)
{
  OZChannelPosition3D *v3;
  const OZChannelPosition3D *v4;

  v3 = (OZChannelPosition3D *)operator new();
  OZChannelPosition3D::OZChannelPosition3D(v3, v4, 0);
  return v3;
}

void sub_1B2C15F64(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40CC6A35F7);
  _Unwind_Resume(a1);
}

OZChannelPosition3D *OZChannelPosition3D_Factory::createChannelCopy(OZChannelPosition3D_Factory *this, OZChannelBase *a2)
{
  OZChannelPosition3D *v3;
  const OZChannelPosition3D *v4;

  v3 = (OZChannelPosition3D *)operator new();
  OZChannelPosition3D::OZChannelPosition3D(v3, v4, 0);
  return v3;
}

void sub_1B2C15FF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40CC6A35F7);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelRotation3D_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelRotation3D_Factory *v0;

  v0 = (OZChannelRotation3D_Factory *)operator new();
  OZChannelRotation3D_Factory::OZChannelRotation3D_Factory(v0);
  OZChannelRotation3D_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1605C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelRotation3D_Factory::OZChannelRotation3D_Factory(OZChannelRotation3D_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3054CD0;
  v4 = xmmword_1B3555880;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654D678;
  *((_QWORD *)this + 16) = &unk_1E654D748;
}

void sub_1B2C160FC(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelRotation3D *OZChannelRotation3D_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelRotation3D *v6;

  v6 = (OZChannelRotation3D *)operator new();
  OZChannelRotation3D::OZChannelRotation3D(v6, this, a2, a3, 4u);
  return v6;
}

void sub_1B2C16170(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40A120F8A5);
  _Unwind_Resume(a1);
}

OZChannelRotation3D *OZChannelRotation3D_Factory::createCopy(OZChannelRotation3D_Factory *this, OZFactoryBase *a2)
{
  OZChannelRotation3D *v3;
  const OZChannelRotation3D *v4;

  v3 = (OZChannelRotation3D *)operator new();
  OZChannelRotation3D::OZChannelRotation3D(v3, v4, 0);
  return v3;
}

void sub_1B2C161FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40A120F8A5);
  _Unwind_Resume(a1);
}

OZChannelRotation3D *OZChannelRotation3D_Factory::createChannelCopy(OZChannelRotation3D_Factory *this, OZChannelBase *a2)
{
  OZChannelRotation3D *v3;
  const OZChannelRotation3D *v4;

  v3 = (OZChannelRotation3D *)operator new();
  OZChannelRotation3D::OZChannelRotation3D(v3, v4, 0);
  return v3;
}

void sub_1B2C16288(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40A120F8A5);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelScale3D_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelScale3D_Factory *v0;

  v0 = (OZChannelScale3D_Factory *)operator new();
  OZChannelScale3D_Factory::OZChannelScale3D_Factory(v0);
  OZChannelScale3D_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C162F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelScale3D_Factory::OZChannelScale3D_Factory(OZChannelScale3D_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555850;
  v4 = xmmword_1B3555890;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654D7A0;
  *((_QWORD *)this + 16) = &unk_1E654D870;
}

void sub_1B2C16394(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelScale3D *OZChannelScale3D_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelScale3D *v6;

  v6 = (OZChannelScale3D *)operator new();
  OZChannelScale3D::OZChannelScale3D(v6, this, a2, a3);
  return v6;
}

void sub_1B2C16404(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

OZChannelScale3D *OZChannelScale3D_Factory::createCopy(OZChannelScale3D_Factory *this, OZFactoryBase *a2)
{
  OZChannelScale3D *v3;
  const OZChannelScale3D *v4;

  v3 = (OZChannelScale3D *)operator new();
  OZChannelScale3D::OZChannelScale3D(v3, v4, 0);
  return v3;
}

void sub_1B2C16490(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

OZChannelScale3D *OZChannelScale3D_Factory::createChannelCopy(OZChannelScale3D_Factory *this, OZChannelBase *a2)
{
  OZChannelScale3D *v3;
  const OZChannelScale3D *v4;

  v3 = (OZChannelScale3D *)operator new();
  OZChannelScale3D::OZChannelScale3D(v3, v4, 0);
  return v3;
}

void sub_1B2C1651C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelColorNoAlpha_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelColorNoAlpha_Factory *v0;

  v0 = (OZChannelColorNoAlpha_Factory *)operator new();
  OZChannelColorNoAlpha_Factory::OZChannelColorNoAlpha_Factory(v0);
  OZChannelColorNoAlpha_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C16588(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelColorNoAlpha_Factory::OZChannelColorNoAlpha_Factory(OZChannelColorNoAlpha_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3054CD0;
  v4 = xmmword_1B35558A0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654D8C8;
  *((_QWORD *)this + 16) = &unk_1E654D998;
}

void sub_1B2C16628(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelColorNoAlpha *OZChannelColorNoAlpha_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelColorNoAlpha *v6;

  v6 = (OZChannelColorNoAlpha *)operator new();
  OZChannelColorNoAlpha::OZChannelColorNoAlpha(v6, this, a2, a3, 5u);
  return v6;
}

void sub_1B2C1669C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40C7C6813ELL);
  _Unwind_Resume(a1);
}

OZChannelColorNoAlpha *OZChannelColorNoAlpha_Factory::createCopy(OZChannelColorNoAlpha_Factory *this, OZFactoryBase *a2)
{
  OZChannelColorNoAlpha *v3;
  const OZChannelColorNoAlpha *v4;

  v3 = (OZChannelColorNoAlpha *)operator new();
  OZChannelColorNoAlpha::OZChannelColorNoAlpha(v3, v4, 0);
  return v3;
}

void sub_1B2C16728(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40C7C6813ELL);
  _Unwind_Resume(a1);
}

OZChannelColorNoAlpha *OZChannelColorNoAlpha_Factory::createChannelCopy(OZChannelColorNoAlpha_Factory *this, OZChannelBase *a2)
{
  OZChannelColorNoAlpha *v3;
  const OZChannelColorNoAlpha *v4;

  v3 = (OZChannelColorNoAlpha *)operator new();
  OZChannelColorNoAlpha::OZChannelColorNoAlpha(v3, v4, 0);
  return v3;
}

void sub_1B2C167B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40C7C6813ELL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelColor_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelColor_Factory *v0;

  v0 = (OZChannelColor_Factory *)operator new();
  OZChannelColor_Factory::OZChannelColor_Factory(v0);
  OZChannelColor_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C16820(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelColor_Factory::OZChannelColor_Factory(OZChannelColor_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B35558A0;
  v4 = xmmword_1B35558B0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654D9F0;
  *((_QWORD *)this + 16) = &unk_1E654DAC0;
}

void sub_1B2C168C0(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelColor *OZChannelColor_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelColor *v6;

  v6 = (OZChannelColor *)operator new();
  OZChannelColor::OZChannelColor(v6, this, a2, a3, 6u);
  return v6;
}

void sub_1B2C16934(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C400BEEEC36);
  _Unwind_Resume(a1);
}

OZChannelColor *OZChannelColor_Factory::createCopy(OZChannelColor_Factory *this, OZFactoryBase *a2)
{
  OZChannelColor *v3;
  const OZChannelColor *v4;

  v3 = (OZChannelColor *)operator new();
  OZChannelColor::OZChannelColor(v3, v4, 0);
  return v3;
}

void sub_1B2C169C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C400BEEEC36);
  _Unwind_Resume(a1);
}

OZChannelColor *OZChannelColor_Factory::createChannelCopy(OZChannelColor_Factory *this, OZChannelBase *a2)
{
  OZChannelColor *v3;
  const OZChannelColor *v4;

  v3 = (OZChannelColor *)operator new();
  OZChannelColor::OZChannelColor(v3, v4, 0);
  return v3;
}

void sub_1B2C16A4C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C400BEEEC36);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelQuad_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelQuad_Factory *v0;

  v0 = (OZChannelQuad_Factory *)operator new();
  OZChannelQuad_Factory::OZChannelQuad_Factory(v0);
  OZChannelQuad_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C16AB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelQuad_Factory::OZChannelQuad_Factory(OZChannelQuad_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3053A10;
  v4 = xmmword_1B35558C0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654DB18;
  *((_QWORD *)this + 16) = &unk_1E654DBE8;
}

void sub_1B2C16B58(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelQuad *OZChannelQuad_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelQuad *v6;

  v6 = (OZChannelQuad *)operator new();
  OZChannelQuad::OZChannelQuad(v6, this, a2, a3, 4u);
  return v6;
}

void sub_1B2C16BCC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C408B27E029);
  _Unwind_Resume(a1);
}

OZChannelQuad *OZChannelQuad_Factory::createCopy(OZChannelQuad_Factory *this, OZFactoryBase *a2)
{
  OZChannelQuad *v3;
  const OZChannelQuad *v4;

  v3 = (OZChannelQuad *)operator new();
  OZChannelQuad::OZChannelQuad(v3, v4, 0);
  return v3;
}

void sub_1B2C16C58(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C408B27E029);
  _Unwind_Resume(a1);
}

OZChannelQuad *OZChannelQuad_Factory::createChannelCopy(OZChannelQuad_Factory *this, OZChannelBase *a2)
{
  OZChannelQuad *v3;
  const OZChannelQuad *v4;

  v3 = (OZChannelQuad *)operator new();
  OZChannelQuad::OZChannelQuad(v3, v4, 0);
  return v3;
}

void sub_1B2C16CE4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C408B27E029);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelCrop_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelCrop_Factory *v0;

  v0 = (OZChannelCrop_Factory *)operator new();
  OZChannelCrop_Factory::OZChannelCrop_Factory(v0);
  OZChannelCrop_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C16D50(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelCrop_Factory::OZChannelCrop_Factory(OZChannelCrop_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3054CD0;
  v4 = xmmword_1B35558D0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654DC40;
  *((_QWORD *)this + 16) = &unk_1E654DD10;
}

void sub_1B2C16DF0(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelCrop *OZChannelCrop_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelCrop *v6;

  v6 = (OZChannelCrop *)operator new();
  OZChannelCrop::OZChannelCrop(v6, this, a2, a3, 4u);
  return v6;
}

void sub_1B2C16E64(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40044ED5BALL);
  _Unwind_Resume(a1);
}

OZChannelCrop *OZChannelCrop_Factory::createCopy(OZChannelCrop_Factory *this, OZFactoryBase *a2)
{
  OZChannelCrop *v3;
  const OZChannelCrop *v4;

  v3 = (OZChannelCrop *)operator new();
  OZChannelCrop::OZChannelCrop(v3, v4, 0);
  return v3;
}

void sub_1B2C16EF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40044ED5BALL);
  _Unwind_Resume(a1);
}

OZChannelCrop *OZChannelCrop_Factory::createChannelCopy(OZChannelCrop_Factory *this, OZChannelBase *a2)
{
  OZChannelCrop *v3;
  const OZChannelCrop *v4;

  v3 = (OZChannelCrop *)operator new();
  OZChannelCrop::OZChannelCrop(v3, v4, 0);
  return v3;
}

void sub_1B2C16F7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40044ED5BALL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelDiscreteColor_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelDiscreteColor_Factory *v0;

  v0 = (OZChannelDiscreteColor_Factory *)operator new();
  OZChannelDiscreteColor_Factory::OZChannelDiscreteColor_Factory(v0);
  OZChannelDiscreteColor_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C16FE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelDiscreteColor_Factory::OZChannelDiscreteColor_Factory(OZChannelDiscreteColor_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B35558F0;
  v4 = xmmword_1B35558E0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 0);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654DD68;
  *((_QWORD *)this + 16) = &unk_1E654DE38;
}

void sub_1B2C17088(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelDiscreteColor_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannel *v6;

  v6 = (OZChannel *)operator new();
  OZChannelEnum::OZChannelEnum(v6, this, a2, a3, 0, 0);
  v6->var0 = (void **)&off_1E6559510;
  v6->var2 = (void **)&unk_1E6559880;
  return v6;
}

void sub_1B2C17118(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C405E89EA5DLL);
  _Unwind_Resume(a1);
}

OZChannelEnum *OZChannelDiscreteColor_Factory::createCopy(OZChannelDiscreteColor_Factory *this, OZFactoryBase *a2)
{
  OZChannelEnum *v3;
  const OZChannelEnum *v4;

  v3 = (OZChannelEnum *)operator new();
  OZChannelEnum::OZChannelEnum(v3, v4, 0);
  *(_QWORD *)v3 = &off_1E6559510;
  *((_QWORD *)v3 + 2) = &unk_1E6559880;
  return v3;
}

void sub_1B2C171BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C405E89EA5DLL);
  _Unwind_Resume(a1);
}

OZChannelEnum *OZChannelDiscreteColor_Factory::createChannelCopy(OZChannelDiscreteColor_Factory *this, OZChannelBase *a2)
{
  OZChannelEnum *v3;
  const OZChannelEnum *v4;

  v3 = (OZChannelEnum *)operator new();
  OZChannelEnum::OZChannelEnum(v3, v4, 0);
  *(_QWORD *)v3 = &off_1E6559510;
  *((_QWORD *)v3 + 2) = &unk_1E6559880;
  return v3;
}

void sub_1B2C17260(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C405E89EA5DLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradient_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelGradient_Factory *v0;

  v0 = (OZChannelGradient_Factory *)operator new();
  OZChannelGradient_Factory::OZChannelGradient_Factory(v0);
  OZChannelGradient_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C172CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradient_Factory::OZChannelGradient_Factory(OZChannelGradient_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3053A10;
  v4 = xmmword_1B3555900;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654DE90;
  *((_QWORD *)this + 16) = &unk_1E654DF60;
}

void sub_1B2C1736C(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelGradient *OZChannelGradient_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelGradient *v6;

  v6 = (OZChannelGradient *)operator new();
  OZChannelGradient::OZChannelGradient(v6, this, a2, a3);
  return v6;
}

void sub_1B2C173DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C4072D3B705);
  _Unwind_Resume(a1);
}

OZChannelGradient *OZChannelGradient_Factory::createCopy(OZChannelGradient_Factory *this, OZFactoryBase *a2)
{
  OZChannelGradient *v3;
  const OZChannelGradient *v4;

  v3 = (OZChannelGradient *)operator new();
  OZChannelGradient::OZChannelGradient(v3, v4, 0);
  return v3;
}

void sub_1B2C17468(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C4072D3B705);
  _Unwind_Resume(a1);
}

void OZChannelGradient_Factory::description(PCString *a1@<X8>)
{
  PCString::PCString(a1, "Channel Gradient Desc", "com.apple.prochannel.framework");
}

PCString *OZChannelGradient_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Channel Gradient Desc");
}

const char *OZChannelGradient_Factory::getBundleID(OZChannelGradient_Factory *this)
{
  return "com.apple.prochannel.framework";
}

PCString *OZChannelGradient_Factory::getLibraryIconNameInternal@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "OZLibraryGradientIcon");
}

OZChannelGradient *OZChannelGradient_Factory::createChannelCopy(OZChannelGradient_Factory *this, OZChannelBase *a2)
{
  OZChannelGradient *v3;
  const OZChannelGradient *v4;

  v3 = (OZChannelGradient *)operator new();
  OZChannelGradient::OZChannelGradient(v3, v4, 0);
  return v3;
}

void sub_1B2C17538(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C4072D3B705);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientRGBFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelGradientRGBFolder_Factory *v0;

  v0 = (OZChannelGradientRGBFolder_Factory *)operator new();
  OZChannelGradientRGBFolder_Factory::OZChannelGradientRGBFolder_Factory(v0);
  OZChannelGradientRGBFolder_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C175A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientRGBFolder_Factory::OZChannelGradientRGBFolder_Factory(OZChannelGradientRGBFolder_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555920;
  v4 = xmmword_1B3555910;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654DFB8;
  *((_QWORD *)this + 16) = &unk_1E654E088;
}

void sub_1B2C17644(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelGradientRGBFolder *OZChannelGradientRGBFolder_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelGradientRGBFolder *v6;

  v6 = (OZChannelGradientRGBFolder *)operator new();
  OZChannelGradientRGBFolder::OZChannelGradientRGBFolder(v6, this, a2, a3);
  return v6;
}

void sub_1B2C176B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

OZChannelGradientRGBFolder *OZChannelGradientRGBFolder_Factory::createCopy(OZChannelGradientRGBFolder_Factory *this, OZFactoryBase *a2)
{
  OZChannelGradientRGBFolder *v3;
  const OZChannelBase *v4;

  v3 = (OZChannelGradientRGBFolder *)operator new();
  OZChannelGradientRGBFolder::OZChannelGradientRGBFolder(v3, v4, 0);
  return v3;
}

void sub_1B2C17740(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

OZChannelGradientRGBFolder *OZChannelGradientRGBFolder_Factory::createChannelCopy(OZChannelGradientRGBFolder_Factory *this, OZChannelBase *a2)
{
  OZChannelGradientRGBFolder *v3;
  const OZChannelBase *v4;

  v3 = (OZChannelGradientRGBFolder *)operator new();
  OZChannelGradientRGBFolder::OZChannelGradientRGBFolder(v3, v4, 0);
  return v3;
}

void sub_1B2C177CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientAlphaFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelGradientAlphaFolder_Factory *v0;

  v0 = (OZChannelGradientAlphaFolder_Factory *)operator new();
  OZChannelGradientAlphaFolder_Factory::OZChannelGradientAlphaFolder_Factory(v0);
  OZChannelGradientAlphaFolder_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C17838(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientAlphaFolder_Factory::OZChannelGradientAlphaFolder_Factory(OZChannelGradientAlphaFolder_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555920;
  v4 = xmmword_1B3555930;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654E0E0;
  *((_QWORD *)this + 16) = &unk_1E654E1B0;
}

void sub_1B2C178D8(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelGradientAlphaFolder *OZChannelGradientAlphaFolder_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelGradientAlphaFolder *v6;

  v6 = (OZChannelGradientAlphaFolder *)operator new();
  OZChannelGradientAlphaFolder::OZChannelGradientAlphaFolder(v6, this, a2, a3);
  return v6;
}

void sub_1B2C17948(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

OZChannelGradientAlphaFolder *OZChannelGradientAlphaFolder_Factory::createCopy(OZChannelGradientAlphaFolder_Factory *this, OZFactoryBase *a2)
{
  OZChannelGradientAlphaFolder *v3;
  const OZChannelBase *v4;

  v3 = (OZChannelGradientAlphaFolder *)operator new();
  OZChannelGradientAlphaFolder::OZChannelGradientAlphaFolder(v3, v4, 0);
  return v3;
}

void sub_1B2C179D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

OZChannelGradientAlphaFolder *OZChannelGradientAlphaFolder_Factory::createChannelCopy(OZChannelGradientAlphaFolder_Factory *this, OZChannelBase *a2)
{
  OZChannelGradientAlphaFolder *v3;
  const OZChannelBase *v4;

  v3 = (OZChannelGradientAlphaFolder *)operator new();
  OZChannelGradientAlphaFolder::OZChannelGradientAlphaFolder(v3, v4, 0);
  return v3;
}

void sub_1B2C17A60(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientSample_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelGradientSample_Factory *v0;

  v0 = (OZChannelGradientSample_Factory *)operator new();
  OZChannelGradientSample_Factory::OZChannelGradientSample_Factory(v0);
  OZChannelGradientSample_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C17ACC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientSample_Factory::OZChannelGradientSample_Factory(OZChannelGradientSample_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3053A10;
  v4 = xmmword_1B3555940;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654E208;
  *((_QWORD *)this + 16) = &unk_1E654E2D8;
}

void sub_1B2C17B6C(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelGradientSample *OZChannelGradientSample_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelGradientSample *v6;

  v6 = (OZChannelGradientSample *)operator new();
  OZChannelGradientSample::OZChannelGradientSample(v6, this, a2, a3);
  return v6;
}

void sub_1B2C17BDC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40E74858DCLL);
  _Unwind_Resume(a1);
}

OZChannelGradientSample *OZChannelGradientSample_Factory::createCopy(OZChannelGradientSample_Factory *this, OZFactoryBase *a2)
{
  OZChannelGradientSample *v3;
  const OZChannelGradientSample *v4;

  v3 = (OZChannelGradientSample *)operator new();
  OZChannelGradientSample::OZChannelGradientSample(v3, v4, 0);
  return v3;
}

void sub_1B2C17C68(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40E74858DCLL);
  _Unwind_Resume(a1);
}

OZChannelGradientSample *OZChannelGradientSample_Factory::createChannelCopy(OZChannelGradientSample_Factory *this, OZChannelBase *a2)
{
  OZChannelGradientSample *v3;
  const OZChannelGradientSample *v4;

  v3 = (OZChannelGradientSample *)operator new();
  OZChannelGradientSample::OZChannelGradientSample(v3, v4, 0);
  return v3;
}

void sub_1B2C17CF4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40E74858DCLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientSampleRGB_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelGradientSampleRGB_Factory *v0;

  v0 = (OZChannelGradientSampleRGB_Factory *)operator new();
  OZChannelGradientSampleRGB_Factory::OZChannelGradientSampleRGB_Factory(v0);
  OZChannelGradientSampleRGB_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C17D60(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientSampleRGB_Factory::OZChannelGradientSampleRGB_Factory(OZChannelGradientSampleRGB_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555940;
  v4 = xmmword_1B3555950;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654E330;
  *((_QWORD *)this + 16) = &unk_1E654E400;
}

void sub_1B2C17E00(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelGradientSampleRGB *OZChannelGradientSampleRGB_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelGradientSampleRGB *v6;

  v6 = (OZChannelGradientSampleRGB *)operator new();
  OZChannelGradientSampleRGB::OZChannelGradientSampleRGB(v6, this, a2, a3);
  return v6;
}

void sub_1B2C17E70(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40C9B629ABLL);
  _Unwind_Resume(a1);
}

OZChannelGradientSampleRGB *OZChannelGradientSampleRGB_Factory::createCopy(OZChannelGradientSampleRGB_Factory *this, OZFactoryBase *a2)
{
  OZChannelGradientSampleRGB *v3;
  const OZChannelGradientSampleRGB *v4;

  v3 = (OZChannelGradientSampleRGB *)operator new();
  OZChannelGradientSampleRGB::OZChannelGradientSampleRGB(v3, v4, 0);
  return v3;
}

void sub_1B2C17EFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40C9B629ABLL);
  _Unwind_Resume(a1);
}

OZChannelGradientSampleRGB *OZChannelGradientSampleRGB_Factory::createChannelCopy(OZChannelGradientSampleRGB_Factory *this, OZChannelBase *a2)
{
  OZChannelGradientSampleRGB *v3;
  const OZChannelGradientSampleRGB *v4;

  v3 = (OZChannelGradientSampleRGB *)operator new();
  OZChannelGradientSampleRGB::OZChannelGradientSampleRGB(v3, v4, 0);
  return v3;
}

void sub_1B2C17F88(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40C9B629ABLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientSampleAlpha_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelGradientSampleAlpha_Factory *v0;

  v0 = (OZChannelGradientSampleAlpha_Factory *)operator new();
  OZChannelGradientSampleAlpha_Factory::OZChannelGradientSampleAlpha_Factory(v0);
  OZChannelGradientSampleAlpha_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C17FF4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientSampleAlpha_Factory::OZChannelGradientSampleAlpha_Factory(OZChannelGradientSampleAlpha_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555940;
  v4 = xmmword_1B3555960;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654E458;
  *((_QWORD *)this + 16) = &unk_1E654E528;
}

void sub_1B2C18094(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelGradientSampleAlpha *OZChannelGradientSampleAlpha_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelGradientSampleAlpha *v6;

  v6 = (OZChannelGradientSampleAlpha *)operator new();
  OZChannelGradientSampleAlpha::OZChannelGradientSampleAlpha(v6, this, a2, a3);
  return v6;
}

void sub_1B2C18104(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C408C14BFF9);
  _Unwind_Resume(a1);
}

OZChannelGradientSampleAlpha *OZChannelGradientSampleAlpha_Factory::createCopy(OZChannelGradientSampleAlpha_Factory *this, OZFactoryBase *a2)
{
  OZChannelGradientSampleAlpha *v3;
  const OZChannelGradientSampleAlpha *v4;

  v3 = (OZChannelGradientSampleAlpha *)operator new();
  OZChannelGradientSampleAlpha::OZChannelGradientSampleAlpha(v3, v4, 0);
  return v3;
}

void sub_1B2C18190(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C408C14BFF9);
  _Unwind_Resume(a1);
}

OZChannelGradientSampleAlpha *OZChannelGradientSampleAlpha_Factory::createChannelCopy(OZChannelGradientSampleAlpha_Factory *this, OZChannelBase *a2)
{
  OZChannelGradientSampleAlpha *v3;
  const OZChannelGradientSampleAlpha *v4;

  v3 = (OZChannelGradientSampleAlpha *)operator new();
  OZChannelGradientSampleAlpha::OZChannelGradientSampleAlpha(v3, v4, 0);
  return v3;
}

void sub_1B2C1821C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C408C14BFF9);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientExtras_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelGradientExtras_Factory *v0;

  v0 = (OZChannelGradientExtras_Factory *)operator new();
  OZChannelGradientExtras_Factory::OZChannelGradientExtras_Factory(v0);
  OZChannelGradientExtras_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C18288(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientExtras_Factory::OZChannelGradientExtras_Factory(OZChannelGradientExtras_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555900;
  v4 = xmmword_1B3555970;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654E580;
  *((_QWORD *)this + 16) = &unk_1E654E650;
}

void sub_1B2C18328(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelGradientExtras *OZChannelGradientExtras_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelGradientExtras *v6;

  v6 = (OZChannelGradientExtras *)operator new();
  OZChannelGradientExtras::OZChannelGradientExtras(v6, this, a2, a3);
  return v6;
}

void sub_1B2C18398(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C409FA7E95DLL);
  _Unwind_Resume(a1);
}

OZChannelGradientExtras *OZChannelGradientExtras_Factory::createCopy(OZChannelGradientExtras_Factory *this, OZFactoryBase *a2)
{
  OZChannelGradientExtras *v3;
  const OZChannelGradientExtras *v4;

  v3 = (OZChannelGradientExtras *)operator new();
  OZChannelGradientExtras::OZChannelGradientExtras(v3, v4, 0);
  return v3;
}

void sub_1B2C18424(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C409FA7E95DLL);
  _Unwind_Resume(a1);
}

void OZChannelGradientExtras_Factory::description(PCString *a1@<X8>)
{
  PCString::PCString(a1, "GradientExtras", "com.apple.prochannel.framework");
}

PCString *OZChannelGradientExtras_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "GradientExtras");
}

OZChannelGradientExtras *OZChannelGradientExtras_Factory::createChannelCopy(OZChannelGradientExtras_Factory *this, OZChannelBase *a2)
{
  OZChannelGradientExtras *v3;
  const OZChannelGradientExtras *v4;

  v3 = (OZChannelGradientExtras *)operator new();
  OZChannelGradientExtras::OZChannelGradientExtras(v3, v4, 0);
  return v3;
}

void sub_1B2C184D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C409FA7E95DLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientPositioned_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelGradientPositioned_Factory *v0;

  v0 = (OZChannelGradientPositioned_Factory *)operator new();
  OZChannelGradientPositioned_Factory::OZChannelGradientPositioned_Factory(v0);
  OZChannelGradientPositioned_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C18544(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientPositioned_Factory::OZChannelGradientPositioned_Factory(OZChannelGradientPositioned_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555970;
  v4 = xmmword_1B3555980;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654E6A8;
  *((_QWORD *)this + 16) = &unk_1E654E778;
}

void sub_1B2C185E4(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelGradientPositioned *OZChannelGradientPositioned_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelGradientPositioned *v6;

  v6 = (OZChannelGradientPositioned *)operator new();
  OZChannelGradientPositioned::OZChannelGradientPositioned(v6, this, a2, a3);
  return v6;
}

void sub_1B2C18654(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40C94B7CBALL);
  _Unwind_Resume(a1);
}

OZChannelGradientPositioned *OZChannelGradientPositioned_Factory::createCopy(OZChannelGradientPositioned_Factory *this, OZFactoryBase *a2)
{
  OZChannelGradientPositioned *v3;
  const OZChannelGradientPositioned *v4;

  v3 = (OZChannelGradientPositioned *)operator new();
  OZChannelGradientPositioned::OZChannelGradientPositioned(v3, v4, 0);
  return v3;
}

void sub_1B2C186E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40C94B7CBALL);
  _Unwind_Resume(a1);
}

OZChannelGradientPositioned *OZChannelGradientPositioned_Factory::createChannelCopy(OZChannelGradientPositioned_Factory *this, OZChannelBase *a2)
{
  OZChannelGradientPositioned *v3;
  const OZChannelGradientPositioned *v4;

  v3 = (OZChannelGradientPositioned *)operator new();
  OZChannelGradientPositioned::OZChannelGradientPositioned(v3, v4, 0);
  return v3;
}

void sub_1B2C1876C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40C94B7CBALL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelVaryingFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelVaryingFolder_Factory *v0;

  v0 = (OZChannelVaryingFolder_Factory *)operator new();
  OZChannelVaryingFolder_Factory::OZChannelVaryingFolder_Factory(v0);
  OZChannelVaryingFolder_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C187D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelVaryingFolder_Factory::OZChannelVaryingFolder_Factory(OZChannelVaryingFolder_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3053A10;
  v4 = xmmword_1B3555920;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654E7D0;
  *((_QWORD *)this + 16) = &unk_1E654E8A0;
}

void sub_1B2C18878(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelVaryingFolder *OZChannelVaryingFolder_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelVaryingFolder *v6;

  v6 = (OZChannelVaryingFolder *)operator new();
  OZChannelVaryingFolder::OZChannelVaryingFolder(v6, this, a2, a3);
  return v6;
}

void sub_1B2C188E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

OZChannelVaryingFolder *OZChannelVaryingFolder_Factory::createCopy(OZChannelVaryingFolder_Factory *this, OZFactoryBase *a2)
{
  OZChannelVaryingFolder *v3;
  const OZChannelVaryingFolder *v4;

  v3 = (OZChannelVaryingFolder *)operator new();
  OZChannelVaryingFolder::OZChannelVaryingFolder(v3, v4, 0);
  return v3;
}

void sub_1B2C18974(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

OZChannelVaryingFolder *OZChannelVaryingFolder_Factory::createChannelCopy(OZChannelVaryingFolder_Factory *this, OZChannelBase *a2)
{
  OZChannelVaryingFolder *v3;
  const OZChannelVaryingFolder *v4;

  v3 = (OZChannelVaryingFolder *)operator new();
  OZChannelVaryingFolder::OZChannelVaryingFolder(v3, v4, 0);
  return v3;
}

void sub_1B2C18A00(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelObjectRootBase_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelObjectRootBase_Factory *v0;

  v0 = (OZChannelObjectRootBase_Factory *)operator new();
  OZChannelObjectRootBase_Factory::OZChannelObjectRootBase_Factory(v0);
  OZChannelObjectRootBase_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C18A6C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelObjectRootBase_Factory::OZChannelObjectRootBase_Factory(OZChannelObjectRootBase_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3053A10;
  v4 = xmmword_1B3555990;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654E8F8;
  *((_QWORD *)this + 16) = &unk_1E654E9C8;
}

void sub_1B2C18B0C(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelObjectRootBase *OZChannelObjectRootBase_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelObjectRootBase *v6;

  v6 = (OZChannelObjectRootBase *)operator new();
  OZChannelObjectRootBase::OZChannelObjectRootBase(v6, this, a2, a3);
  return v6;
}

void sub_1B2C18B7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40C173384DLL);
  _Unwind_Resume(a1);
}

OZChannelObjectRootBase *OZChannelObjectRootBase_Factory::createCopy(OZChannelObjectRootBase_Factory *this, OZFactoryBase *a2)
{
  OZChannelObjectRootBase *v3;
  const OZChannelObjectRootBase *v4;

  v3 = (OZChannelObjectRootBase *)operator new();
  OZChannelObjectRootBase::OZChannelObjectRootBase(v3, v4, 0);
  return v3;
}

void sub_1B2C18C08(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40C173384DLL);
  _Unwind_Resume(a1);
}

OZChannelObjectRootBase *OZChannelObjectRootBase_Factory::createChannelCopy(OZChannelObjectRootBase_Factory *this, OZChannelBase *a2)
{
  OZChannelObjectRootBase *v3;
  const OZChannelObjectRootBase *v4;

  v3 = (OZChannelObjectRootBase *)operator new();
  OZChannelObjectRootBase::OZChannelObjectRootBase(v3, v4, 0);
  return v3;
}

void sub_1B2C18C94(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40C173384DLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelHistogram_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelHistogram_Factory *v0;

  v0 = (OZChannelHistogram_Factory *)operator new();
  OZChannelHistogram_Factory::OZChannelHistogram_Factory(v0);
  OZChannelHistogram_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C18D00(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelHistogram_Factory::OZChannelHistogram_Factory(OZChannelHistogram_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3053A10;
  v4 = xmmword_1B35559A0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654EA20;
  *((_QWORD *)this + 16) = &unk_1E654EAF0;
}

void sub_1B2C18DA0(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelHistogram *OZChannelHistogram_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelHistogram *v6;

  v6 = (OZChannelHistogram *)operator new();
  OZChannelHistogram::OZChannelHistogram(v6, this, a2, a3, 6u);
  return v6;
}

void sub_1B2C18E14(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40F1099EF6);
  _Unwind_Resume(a1);
}

OZChannelHistogram *OZChannelHistogram_Factory::createCopy(OZChannelHistogram_Factory *this, OZFactoryBase *a2)
{
  OZChannelHistogram *v3;
  const OZChannelHistogram *v4;

  v3 = (OZChannelHistogram *)operator new();
  OZChannelHistogram::OZChannelHistogram(v3, v4, 0);
  return v3;
}

void sub_1B2C18EA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40F1099EF6);
  _Unwind_Resume(a1);
}

OZChannelHistogram *OZChannelHistogram_Factory::createChannelCopy(OZChannelHistogram_Factory *this, OZChannelBase *a2)
{
  OZChannelHistogram *v3;
  const OZChannelHistogram *v4;

  v3 = (OZChannelHistogram *)operator new();
  OZChannelHistogram::OZChannelHistogram(v3, v4, 0);
  return v3;
}

void sub_1B2C18F2C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40F1099EF6);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelLevels_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelLevels_Factory *v0;

  v0 = (OZChannelLevels_Factory *)operator new();
  OZChannelLevels_Factory::OZChannelLevels_Factory(v0);
  OZChannelLevels_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C18F98(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelLevels_Factory::OZChannelLevels_Factory(OZChannelLevels_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3053A10;
  v4 = xmmword_1B35559B0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654EB48;
  *((_QWORD *)this + 16) = &unk_1E654EC18;
}

void sub_1B2C19038(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelLevels *OZChannelLevels_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelLevels *v6;

  v6 = (OZChannelLevels *)operator new();
  OZChannelLevels::OZChannelLevels(v6, this, a2, a3, 3u);
  return v6;
}

void sub_1B2C190AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

OZChannelLevels *OZChannelLevels_Factory::createCopy(OZChannelLevels_Factory *this, OZFactoryBase *a2)
{
  OZChannelLevels *v3;
  const OZChannelLevels *v4;

  v3 = (OZChannelLevels *)operator new();
  OZChannelLevels::OZChannelLevels(v3, v4, 0);
  return v3;
}

void sub_1B2C19138(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

OZChannelLevels *OZChannelLevels_Factory::createChannelCopy(OZChannelLevels_Factory *this, OZChannelBase *a2)
{
  OZChannelLevels *v3;
  const OZChannelLevels *v4;

  v3 = (OZChannelLevels *)operator new();
  OZChannelLevels::OZChannelLevels(v3, v4, 0);
  return v3;
}

void sub_1B2C191C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelButton_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelButton_Factory *v0;

  v0 = (OZChannelButton_Factory *)operator new();
  OZChannelButton_Factory::OZChannelButton_Factory(v0);
  OZChannelButton_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C19230(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelButton_Factory::OZChannelButton_Factory(OZChannelButton_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B35559C0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654EC70;
  *((_QWORD *)this + 16) = &unk_1E654ED40;
}

void sub_1B2C192D0(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelButton *OZChannelButton_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelButton *v6;

  v6 = (OZChannelButton *)operator new();
  OZChannelButton::OZChannelButton(v6, this, a2, a3);
  return v6;
}

void sub_1B2C19340(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C400C70C378);
  _Unwind_Resume(a1);
}

OZChannelButton *OZChannelButton_Factory::createCopy(OZChannelButton_Factory *this, OZFactoryBase *a2)
{
  OZChannelButton *v3;
  const OZChannelButton *v4;

  v3 = (OZChannelButton *)operator new();
  OZChannelButton::OZChannelButton(v3, v4, 0);
  return v3;
}

void sub_1B2C193CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C400C70C378);
  _Unwind_Resume(a1);
}

OZChannelButton *OZChannelButton_Factory::createChannelCopy(OZChannelButton_Factory *this, OZChannelBase *a2)
{
  OZChannelButton *v3;
  const OZChannelButton *v4;

  v3 = (OZChannelButton *)operator new();
  OZChannelButton::OZChannelButton(v3, v4, 0);
  return v3;
}

void sub_1B2C19458(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C400C70C378);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelHelpButton_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelHelpButton_Factory *v0;

  v0 = (OZChannelHelpButton_Factory *)operator new();
  OZChannelHelpButton_Factory::OZChannelHelpButton_Factory(v0);
  OZChannelHelpButton_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C194C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelHelpButton_Factory::OZChannelHelpButton_Factory(OZChannelHelpButton_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B35559C0;
  v4 = xmmword_1B35559D0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654ED98;
  *((_QWORD *)this + 16) = &unk_1E654EE68;
}

void sub_1B2C19564(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelHelpButton *OZChannelHelpButton_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelHelpButton *v6;

  v6 = (OZChannelHelpButton *)operator new();
  OZChannelHelpButton::OZChannelHelpButton(v6, this, a2, a3);
  return v6;
}

void sub_1B2C195D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C400C70C378);
  _Unwind_Resume(a1);
}

OZChannelHelpButton *OZChannelHelpButton_Factory::createCopy(OZChannelHelpButton_Factory *this, OZFactoryBase *a2)
{
  OZChannelHelpButton *v3;
  const OZChannelBase *v4;

  v3 = (OZChannelHelpButton *)operator new();
  OZChannelHelpButton::OZChannelHelpButton(v3, v4, 0);
  return v3;
}

void sub_1B2C19660(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C400C70C378);
  _Unwind_Resume(a1);
}

OZChannelHelpButton *OZChannelHelpButton_Factory::createChannelCopy(OZChannelHelpButton_Factory *this, OZChannelBase *a2)
{
  OZChannelHelpButton *v3;
  const OZChannelBase *v4;

  v3 = (OZChannelHelpButton *)operator new();
  OZChannelHelpButton::OZChannelHelpButton(v3, v4, 0);
  return v3;
}

void sub_1B2C196EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C400C70C378);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelText_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelText_Factory *v0;

  v0 = (OZChannelText_Factory *)operator new();
  OZChannelText_Factory::OZChannelText_Factory(v0);
  OZChannelText_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C19758(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelText_Factory::OZChannelText_Factory(OZChannelText_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B3054C90;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654EEC0;
  *((_QWORD *)this + 16) = &unk_1E654EF90;
}

void sub_1B2C197F8(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelText *OZChannelText_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelText *v6;

  v6 = (OZChannelText *)operator new();
  OZChannelText::OZChannelText(v6, this, a2, a3);
  return v6;
}

void sub_1B2C19868(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40BB3F29BDLL);
  _Unwind_Resume(a1);
}

OZChannelText *OZChannelText_Factory::createCopy(OZChannelText_Factory *this, OZFactoryBase *a2)
{
  OZChannelText *v3;
  const OZChannelText *v4;

  v3 = (OZChannelText *)operator new();
  OZChannelText::OZChannelText(v3, v4, 0);
  return v3;
}

void sub_1B2C198F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40BB3F29BDLL);
  _Unwind_Resume(a1);
}

OZChannelText *OZChannelText_Factory::createChannelCopy(OZChannelText_Factory *this, OZChannelBase *a2)
{
  OZChannelText *v3;
  const OZChannelText *v4;

  v3 = (OZChannelText *)operator new();
  OZChannelText::OZChannelText(v3, v4, 0);
  return v3;
}

void sub_1B2C19980(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40BB3F29BDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelDoubleOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelDoubleOverRange_Factory *v0;

  v0 = (OZChannelDoubleOverRange_Factory *)operator new();
  OZChannelDoubleOverRange_Factory::OZChannelDoubleOverRange_Factory(v0);
  OZChannelDoubleOverRange_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C199EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelDoubleOverRange_Factory::OZChannelDoubleOverRange_Factory(OZChannelDoubleOverRange_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555770;
  v4 = xmmword_1B35559E0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654EFE8;
  *((_QWORD *)this + 16) = &unk_1E654F0B8;
}

void sub_1B2C19A8C(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelDoubleOverRange *OZChannelDoubleOverRange_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelDoubleOverRange *v6;

  v6 = (OZChannelDoubleOverRange *)operator new();
  OZChannelDoubleOverRange::OZChannelDoubleOverRange(v6, this, a2, a3);
  return v6;
}

void sub_1B2C19AFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

OZChannelDoubleOverRange *OZChannelDoubleOverRange_Factory::createCopy(OZChannelDoubleOverRange_Factory *this, OZFactoryBase *a2)
{
  OZChannelDoubleOverRange *v3;
  const OZChannelDoubleOverRange *v4;

  v3 = (OZChannelDoubleOverRange *)operator new();
  OZChannelDoubleOverRange::OZChannelDoubleOverRange(v3, v4, 0);
  return v3;
}

void sub_1B2C19B88(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

OZChannelDoubleOverRange *OZChannelDoubleOverRange_Factory::createChannelCopy(OZChannelDoubleOverRange_Factory *this, OZChannelBase *a2)
{
  OZChannelDoubleOverRange *v3;
  const OZChannelDoubleOverRange *v4;

  v3 = (OZChannelDoubleOverRange *)operator new();
  OZChannelDoubleOverRange::OZChannelDoubleOverRange(v3, v4, 0);
  return v3;
}

void sub_1B2C19C14(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelScaleOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelScaleOverRange_Factory *v0;

  v0 = (OZChannelScaleOverRange_Factory *)operator new();
  OZChannelScaleOverRange_Factory::OZChannelScaleOverRange_Factory(v0);
  OZChannelScaleOverRange_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C19C80(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelScaleOverRange_Factory::OZChannelScaleOverRange_Factory(OZChannelScaleOverRange_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555850;
  v4 = xmmword_1B35559F0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654F110;
  *((_QWORD *)this + 16) = &unk_1E654F1E0;
}

void sub_1B2C19D20(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelScaleOverRange *OZChannelScaleOverRange_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelScaleOverRange *v6;

  v6 = (OZChannelScaleOverRange *)operator new();
  OZChannelScaleOverRange::OZChannelScaleOverRange(v6, this, a2, a3);
  return v6;
}

void sub_1B2C19D90(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40112F5121);
  _Unwind_Resume(a1);
}

OZChannelScaleOverRange *OZChannelScaleOverRange_Factory::createCopy(OZChannelScaleOverRange_Factory *this, OZFactoryBase *a2)
{
  OZChannelScaleOverRange *v3;
  const OZChannelScaleOverRange *v4;

  v3 = (OZChannelScaleOverRange *)operator new();
  OZChannelScaleOverRange::OZChannelScaleOverRange(v3, v4, 0);
  return v3;
}

void sub_1B2C19E1C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40112F5121);
  _Unwind_Resume(a1);
}

OZChannelScaleOverRange *OZChannelScaleOverRange_Factory::createChannelCopy(OZChannelScaleOverRange_Factory *this, OZChannelBase *a2)
{
  OZChannelScaleOverRange *v3;
  const OZChannelScaleOverRange *v4;

  v3 = (OZChannelScaleOverRange *)operator new();
  OZChannelScaleOverRange::OZChannelScaleOverRange(v3, v4, 0);
  return v3;
}

void sub_1B2C19EA8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40112F5121);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelAngleOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelAngleOverRange_Factory *v0;

  v0 = (OZChannelAngleOverRange_Factory *)operator new();
  OZChannelAngleOverRange_Factory::OZChannelAngleOverRange_Factory(v0);
  OZChannelAngleOverRange_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C19F14(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelAngleOverRange_Factory::OZChannelAngleOverRange_Factory(OZChannelAngleOverRange_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B35557A0;
  v4 = xmmword_1B3555A00;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654F238;
  *((_QWORD *)this + 16) = &unk_1E654F308;
}

void sub_1B2C19FB4(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelAngleOverRange *OZChannelAngleOverRange_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelAngleOverRange *v6;

  v6 = (OZChannelAngleOverRange *)operator new();
  OZChannelAngleOverRange::OZChannelAngleOverRange(v6, this, a2, a3);
  return v6;
}

void sub_1B2C1A024(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

OZChannelAngleOverRange *OZChannelAngleOverRange_Factory::createCopy(OZChannelAngleOverRange_Factory *this, OZFactoryBase *a2)
{
  OZChannelAngleOverRange *v3;
  const OZChannelAngleOverRange *v4;

  v3 = (OZChannelAngleOverRange *)operator new();
  OZChannelAngleOverRange::OZChannelAngleOverRange(v3, v4, 0);
  return v3;
}

void sub_1B2C1A0B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

OZChannelAngleOverRange *OZChannelAngleOverRange_Factory::createChannelCopy(OZChannelAngleOverRange_Factory *this, OZChannelBase *a2)
{
  OZChannelAngleOverRange *v3;
  const OZChannelAngleOverRange *v4;

  v3 = (OZChannelAngleOverRange *)operator new();
  OZChannelAngleOverRange::OZChannelAngleOverRange(v3, v4, 0);
  return v3;
}

void sub_1B2C1A13C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelPercentOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelPercentOverRange_Factory *v0;

  v0 = (OZChannelPercentOverRange_Factory *)operator new();
  OZChannelPercentOverRange_Factory::OZChannelPercentOverRange_Factory(v0);
  OZChannelPercentOverRange_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1A1A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelPercentOverRange_Factory::OZChannelPercentOverRange_Factory(OZChannelPercentOverRange_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B35557B0;
  v4 = xmmword_1B3555A10;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654F360;
  *((_QWORD *)this + 16) = &unk_1E654F430;
}

void sub_1B2C1A248(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelPercentOverRange *OZChannelPercentOverRange_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelPercentOverRange *v6;

  v6 = (OZChannelPercentOverRange *)operator new();
  OZChannelPercentOverRange::OZChannelPercentOverRange(v6, this, a2, a3);
  return v6;
}

void sub_1B2C1A2B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

OZChannelPercentOverRange *OZChannelPercentOverRange_Factory::createCopy(OZChannelPercentOverRange_Factory *this, OZFactoryBase *a2)
{
  OZChannelPercentOverRange *v3;
  const OZChannelPercentOverRange *v4;

  v3 = (OZChannelPercentOverRange *)operator new();
  OZChannelPercentOverRange::OZChannelPercentOverRange(v3, v4, 0);
  return v3;
}

void sub_1B2C1A344(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

OZChannelPercentOverRange *OZChannelPercentOverRange_Factory::createChannelCopy(OZChannelPercentOverRange_Factory *this, OZChannelBase *a2)
{
  OZChannelPercentOverRange *v3;
  const OZChannelPercentOverRange *v4;

  v3 = (OZChannelPercentOverRange *)operator new();
  OZChannelPercentOverRange::OZChannelPercentOverRange(v3, v4, 0);
  return v3;
}

void sub_1B2C1A3D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannel2DOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannel2DOverRange_Factory *v0;

  v0 = (OZChannel2DOverRange_Factory *)operator new();
  OZChannel2DOverRange_Factory::OZChannel2DOverRange_Factory(v0);
  OZChannel2DOverRange_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1A43C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannel2DOverRange_Factory::OZChannel2DOverRange_Factory(OZChannel2DOverRange_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555800;
  v4 = xmmword_1B3555A20;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654F488;
  *((_QWORD *)this + 16) = &unk_1E654F558;
}

void sub_1B2C1A4DC(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannel2DOverRange *OZChannel2DOverRange_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannel2DOverRange *v6;

  v6 = (OZChannel2DOverRange *)operator new();
  OZChannel2DOverRange::OZChannel2DOverRange(v6, this, a2, a3);
  return v6;
}

void sub_1B2C1A54C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40112F5121);
  _Unwind_Resume(a1);
}

OZChannel2DOverRange *OZChannel2DOverRange_Factory::createCopy(OZChannel2DOverRange_Factory *this, OZFactoryBase *a2)
{
  OZChannel2DOverRange *v3;
  const OZChannel2DOverRange *v4;

  v3 = (OZChannel2DOverRange *)operator new();
  OZChannel2DOverRange::OZChannel2DOverRange(v3, v4, 0);
  return v3;
}

void sub_1B2C1A5D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40112F5121);
  _Unwind_Resume(a1);
}

OZChannel2DOverRange *OZChannel2DOverRange_Factory::createChannelCopy(OZChannel2DOverRange_Factory *this, OZChannelBase *a2)
{
  OZChannel2DOverRange *v3;
  const OZChannel2DOverRange *v4;

  v3 = (OZChannel2DOverRange *)operator new();
  OZChannel2DOverRange::OZChannel2DOverRange(v3, v4, 0);
  return v3;
}

void sub_1B2C1A664(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40112F5121);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelTransformSwitch_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelTransformSwitch_Factory *v0;

  v0 = (OZChannelTransformSwitch_Factory *)operator new();
  OZChannelTransformSwitch_Factory::OZChannelTransformSwitch_Factory(v0);
  OZChannelTransformSwitch_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1A6D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelTransformSwitch_Factory::OZChannelTransformSwitch_Factory(OZChannelTransformSwitch_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3054CD0;
  v4 = xmmword_1B3555A30;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654F5B0;
  *((_QWORD *)this + 16) = &unk_1E654F680;
}

void sub_1B2C1A770(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelTransformSwitch *OZChannelTransformSwitch_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelTransformSwitch *v6;

  v6 = (OZChannelTransformSwitch *)operator new();
  OZChannelTransformSwitch::OZChannelTransformSwitch(v6, this, a2, a3, 3u);
  return v6;
}

void sub_1B2C1A7E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

OZChannelTransformSwitch *OZChannelTransformSwitch_Factory::createCopy(OZChannelTransformSwitch_Factory *this, OZFactoryBase *a2)
{
  OZChannelTransformSwitch *v3;
  const OZChannelTransformSwitch *v4;

  v3 = (OZChannelTransformSwitch *)operator new();
  OZChannelTransformSwitch::OZChannelTransformSwitch(v3, v4, 0);
  return v3;
}

void sub_1B2C1A870(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

OZChannelTransformSwitch *OZChannelTransformSwitch_Factory::createChannelCopy(OZChannelTransformSwitch_Factory *this, OZChannelBase *a2)
{
  OZChannelTransformSwitch *v3;
  const OZChannelTransformSwitch *v4;

  v3 = (OZChannelTransformSwitch *)operator new();
  OZChannelTransformSwitch::OZChannelTransformSwitch(v3, v4, 0);
  return v3;
}

void sub_1B2C1A8FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelUint16_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelUint16_Factory *v0;

  v0 = (OZChannelUint16_Factory *)operator new();
  OZChannelUint16_Factory::OZChannelUint16_Factory(v0);
  OZChannelUint16_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1A968(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelUint16_Factory::OZChannelUint16_Factory(OZChannelUint16_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B3555A40;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654F6D8;
  *((_QWORD *)this + 16) = &unk_1E654F7A8;
}

void sub_1B2C1AA08(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelUint16 *OZChannelUint16_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelUint16 *v6;

  v6 = (OZChannelUint16 *)operator new();
  OZChannelUint16::OZChannelUint16(v6, this, a2, a3, 0, 0);
  return v6;
}

void sub_1B2C1AA80(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelUint16_Factory::createCopy(OZChannelUint16_Factory *this, OZFactoryBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6551EC8;
  v3->var2 = (void **)&unk_1E6552228;
  return v3;
}

void sub_1B2C1AB24(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelUint16_Factory::createChannelCopy(OZChannelUint16_Factory *this, OZChannelBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6551EC8;
  v3->var2 = (void **)&unk_1E6552228;
  return v3;
}

void sub_1B2C1ABC8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelUint16::OZChannelUint16(OZChannelUint16 *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannelUint16 *v9;
  OZChannelUint16 *OZChannelUint16Info;
  OZChannelInfo *var17;
  OZChannelImpl *var15;

  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&off_1E6551EC8;
  v9->var2 = (void **)&unk_1E6552228;
  OZChannelUint16Info = (OZChannelUint16 *)OZChannelUint16::createOZChannelUint16Info(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelUint16::_OZChannelUint16Info;
    this->var17 = (OZChannelInfo *)OZChannelUint16::_OZChannelUint16Info;
  }
  this->var16 = var17;
  OZChannelUint16::createOZChannelUint16Impl(OZChannelUint16Info);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelUint16::_OZChannelUint16Impl;
    this->var15 = (OZChannelImpl *)OZChannelUint16::_OZChannelUint16Impl;
  }
  this->var14 = var15;
}

void sub_1B2C1AC94(_Unwind_Exception *a1)
{
  OZChannel *v1;

  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

uint64_t OZChannelUint16::createOZChannelUint16Info(OZChannelUint16 *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelUint16::createOZChannelUint16Info(void)::_OZChannelUint16Info_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelUint16::createOZChannelUint16Info(void)::_OZChannelUint16Info_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelUint16::createOZChannelUint16Info(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelUint16::_OZChannelUint16Info;
}

uint64_t OZChannelUint16::createOZChannelUint16Impl(OZChannelUint16 *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelUint16::createOZChannelUint16Impl(void)::_OZChannelUint16Impl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelUint16::createOZChannelUint16Impl(void)::_OZChannelUint16Impl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelUint16::createOZChannelUint16Impl(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelUint16::_OZChannelUint16Impl;
}

void std::__call_once_param<std::tuple<OZChannelUint16::createOZChannelUint16Info(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelUint16Info *v0;

  if (!OZChannelUint16::_OZChannelUint16Info)
  {
    v0 = (OZChannelUint16Info *)operator new();
    OZChannelUint16Info::OZChannelUint16Info(v0);
    OZChannelUint16::_OZChannelUint16Info = (uint64_t)v0;
  }
}

void sub_1B2C1ADB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelUint16Info::OZChannelUint16Info(OZChannelUint16Info *this)
{
  uint64_t v2;

  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 65535.0, 1.0, 1.0, 1.0, "");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(_QWORD *)this = &unk_1E654F800;
  *((_QWORD *)this + 10) = &unk_1E654F820;
}

void sub_1B2C1AE44(_Unwind_Exception *a1)
{
  OZChannelInfo *v1;

  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelUint16::createOZChannelUint16Impl(void)::{lambda(void)#1} &&>>()
{
  OZChannelUint16::createOZChannelUint16Impl(void)::{lambda(void)#1}::operator()();
}

void OZChannelUint16::createOZChannelUint16Impl(void)::{lambda(void)#1}::operator()()
{
  uint64_t v0;
  OZCurveInt *v1;

  if (!OZChannelUint16::_OZChannelUint16Impl)
  {
    v0 = operator new();
    v1 = (OZCurveInt *)operator new();
    OZCurveInt::OZCurveInt(v1, 0.0);
    OZChannelImpl::OZChannelImpl((OZChannelImpl *)v0, (OZCurve *)v1, 0.0, 1, 1);
    PCSingleton::PCSingleton((PCSingleton *)(v0 + 40), 100);
    *(_QWORD *)v0 = &unk_1E654F878;
    *(_QWORD *)(v0 + 40) = &unk_1E654F898;
    OZChannelUint16::_OZChannelUint16Impl = v0;
  }
}

void sub_1B2C1AF14(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelSeed_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelSeed_Factory *v0;

  v0 = (OZChannelSeed_Factory *)operator new();
  OZChannelSeed_Factory::OZChannelSeed_Factory(v0);
  OZChannelSeed_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1AFB4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelSeed_Factory::OZChannelSeed_Factory(OZChannelSeed_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B3555A50;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654F8F0;
  *((_QWORD *)this + 16) = &unk_1E654F9C0;
}

void sub_1B2C1B054(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelSeed *OZChannelSeed_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelSeed *v6;

  v6 = (OZChannelSeed *)operator new();
  OZChannelSeed::OZChannelSeed(v6, this, a2, a3, 0, 0);
  return v6;
}

void sub_1B2C1B0CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelSeed_Factory::createCopy(OZChannelSeed_Factory *this, OZFactoryBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E65531D8;
  v3->var2 = (void **)&unk_1E6553538;
  return v3;
}

void sub_1B2C1B170(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelSeed_Factory::createChannelCopy(OZChannelSeed_Factory *this, OZChannelBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E65531D8;
  v3->var2 = (void **)&unk_1E6553538;
  return v3;
}

void sub_1B2C1B214(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelSeed::OZChannelSeed(OZChannelSeed *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannelSeed *v9;
  OZChannelSeed *OZChannelSeedInfo;
  OZChannelInfo *var17;
  OZChannelImpl *var15;

  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&off_1E65531D8;
  v9->var2 = (void **)&unk_1E6553538;
  OZChannelSeedInfo = (OZChannelSeed *)OZChannelSeed::createOZChannelSeedInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelSeed::_OZChannelSeedInfo;
    this->var17 = (OZChannelInfo *)OZChannelSeed::_OZChannelSeedInfo;
  }
  this->var16 = var17;
  OZChannelSeed::createOZChannelSeedImpl(OZChannelSeedInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelSeed::_OZChannelSeedImpl;
    this->var15 = (OZChannelImpl *)OZChannelSeed::_OZChannelSeedImpl;
  }
  this->var14 = var15;
}

void sub_1B2C1B2E0(_Unwind_Exception *a1)
{
  OZChannel *v1;

  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelDecibel_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelDecibel_Factory *v0;

  v0 = (OZChannelDecibel_Factory *)operator new();
  OZChannelDecibel_Factory::OZChannelDecibel_Factory(v0);
  OZChannelDecibel_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1B33C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelDecibel_Factory::OZChannelDecibel_Factory(OZChannelDecibel_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B3555A60;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654FA18;
  *((_QWORD *)this + 16) = &unk_1E654FAE8;
}

void sub_1B2C1B3DC(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelDecibel *OZChannelDecibel_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelDecibel *v6;

  v6 = (OZChannelDecibel *)operator new();
  OZChannelDecibel::OZChannelDecibel(v6, this, a2, a3, 0, 0);
  return v6;
}

void sub_1B2C1B454(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelDecibel_Factory::createCopy(OZChannelDecibel_Factory *this, OZFactoryBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E65535A8;
  v3->var2 = (void **)&unk_1E6553908;
  return v3;
}

void sub_1B2C1B4F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelDecibel_Factory::createChannelCopy(OZChannelDecibel_Factory *this, OZChannelBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E65535A8;
  v3->var2 = (void **)&unk_1E6553908;
  return v3;
}

void sub_1B2C1B59C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelDecibel::OZChannelDecibel(OZChannelDecibel *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannelDecibel *v9;
  OZChannelDecibel *OZChannelDecibelInfo;
  OZChannelInfo *var17;
  OZChannelImpl *var15;

  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&off_1E65535A8;
  v9->var2 = (void **)&unk_1E6553908;
  OZChannelDecibelInfo = (OZChannelDecibel *)OZChannelDecibel::createOZChannelDecibelInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelDecibel::_OZChannelDecibelInfo;
    this->var17 = (OZChannelInfo *)OZChannelDecibel::_OZChannelDecibelInfo;
  }
  this->var16 = var17;
  OZChannelDecibel::createOZChannelDecibelImpl(OZChannelDecibelInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelDecibel::_OZChannelDecibelImpl;
    this->var15 = (OZChannelImpl *)OZChannelDecibel::_OZChannelDecibelImpl;
  }
  this->var14 = var15;
}

void sub_1B2C1B668(_Unwind_Exception *a1)
{
  OZChannel *v1;

  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

uint64_t OZChannelDecibel::createOZChannelDecibelInfo(OZChannelDecibel *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelDecibel::createOZChannelDecibelInfo(void)::_OZChannelDecibelInfo_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelDecibel::createOZChannelDecibelInfo(void)::_OZChannelDecibelInfo_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelDecibel::createOZChannelDecibelInfo(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelDecibel::_OZChannelDecibelInfo;
}

uint64_t OZChannelDecibel::createOZChannelDecibelImpl(OZChannelDecibel *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelDecibel::createOZChannelDecibelImpl(void)::_OZChannelDecibelImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelDecibel::createOZChannelDecibelImpl(void)::_OZChannelDecibelImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelDecibel::createOZChannelDecibelImpl(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelDecibel::_OZChannelDecibelImpl;
}

void std::__call_once_param<std::tuple<OZChannelDecibel::createOZChannelDecibelInfo(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelDecibelInfo *v0;

  if (!OZChannelDecibel::_OZChannelDecibelInfo)
  {
    v0 = (OZChannelDecibelInfo *)operator new();
    OZChannelDecibelInfo::OZChannelDecibelInfo(v0);
    OZChannelDecibel::_OZChannelDecibelInfo = (uint64_t)v0;
  }
}

void sub_1B2C1B78C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelDecibelInfo::OZChannelDecibelInfo(OZChannelDecibelInfo *this)
{
  uint64_t v2;

  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 4.0, 1.0, 0.1, 1.0, "dB");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(_QWORD *)this = &unk_1E654FB40;
  *((_QWORD *)this + 10) = &unk_1E654FB60;
}

void sub_1B2C1B818(_Unwind_Exception *a1)
{
  OZChannelInfo *v1;

  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelDecibel::createOZChannelDecibelImpl(void)::{lambda(void)#1} &&>>()
{
  OZChannelDecibel::createOZChannelDecibelImpl(void)::{lambda(void)#1}::operator()();
}

void OZChannelDecibel::createOZChannelDecibelImpl(void)::{lambda(void)#1}::operator()()
{
  uint64_t v0;
  OZCurveDouble *v1;

  if (!OZChannelDecibel::_OZChannelDecibelImpl)
  {
    v0 = operator new();
    v1 = (OZCurveDouble *)operator new();
    OZCurveDouble::OZCurveDouble(v1, 0.0);
    OZChannelImpl::OZChannelImpl((OZChannelImpl *)v0, (OZCurve *)v1, 0.0, 1, 1);
    PCSingleton::PCSingleton((PCSingleton *)(v0 + 40), 100);
    *(_QWORD *)v0 = &unk_1E654FBB8;
    *(_QWORD *)(v0 + 40) = &unk_1E654FBD8;
    OZChannelDecibel::_OZChannelDecibelImpl = v0;
  }
}

void sub_1B2C1B8E8(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelFrame_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelFrame_Factory *v0;

  v0 = (OZChannelFrame_Factory *)operator new();
  OZChannelFrame_Factory::OZChannelFrame_Factory(v0);
  OZChannelFrame_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1B988(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelFrame_Factory::OZChannelFrame_Factory(OZChannelFrame_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B3555A70;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654FC30;
  *((_QWORD *)this + 16) = &unk_1E654FD00;
}

void sub_1B2C1BA28(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelFrame *OZChannelFrame_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelFrame *v6;

  v6 = (OZChannelFrame *)operator new();
  OZChannelFrame::OZChannelFrame(v6, this, a2, a3, 0, 0);
  return v6;
}

void sub_1B2C1BAA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelFrame_Factory::createCopy(OZChannelFrame_Factory *this, OZFactoryBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6553978;
  v3->var2 = (void **)&unk_1E6553CD8;
  return v3;
}

void sub_1B2C1BB44(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelFrame_Factory::createChannelCopy(OZChannelFrame_Factory *this, OZChannelBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6553978;
  v3->var2 = (void **)&unk_1E6553CD8;
  return v3;
}

void sub_1B2C1BBE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelFrame::OZChannelFrame(OZChannelFrame *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannelFrame *v9;
  OZChannelFrame *OZChannelFrameInfo;
  OZChannelInfo *var17;
  OZChannelImpl *var15;

  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&off_1E6553978;
  v9->var2 = (void **)&unk_1E6553CD8;
  OZChannelFrameInfo = (OZChannelFrame *)OZChannelFrame::createOZChannelFrameInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelFrame::_OZChannelFrameInfo;
    this->var17 = (OZChannelInfo *)OZChannelFrame::_OZChannelFrameInfo;
  }
  this->var16 = var17;
  OZChannelFrame::createOZChannelFrameImpl(OZChannelFrameInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelFrame::_OZChannelFrameImpl;
    this->var15 = (OZChannelImpl *)OZChannelFrame::_OZChannelFrameImpl;
  }
  this->var14 = var15;
}

void sub_1B2C1BCB4(_Unwind_Exception *a1)
{
  OZChannel *v1;

  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

uint64_t OZChannelFrame::createOZChannelFrameInfo(OZChannelFrame *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelFrame::createOZChannelFrameInfo(void)::_OZChannelFrameInfo_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelFrame::createOZChannelFrameInfo(void)::_OZChannelFrameInfo_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelFrame::createOZChannelFrameInfo(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelFrame::_OZChannelFrameInfo;
}

uint64_t OZChannelFrame::createOZChannelFrameImpl(OZChannelFrame *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelFrame::createOZChannelFrameImpl(void)::_OZChannelFrameImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelFrame::createOZChannelFrameImpl(void)::_OZChannelFrameImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelFrame::createOZChannelFrameImpl(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelFrame::_OZChannelFrameImpl;
}

void std::__call_once_param<std::tuple<OZChannelFrame::createOZChannelFrameInfo(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelFrameInfo *v0;

  if (!OZChannelFrame::_OZChannelFrameInfo)
  {
    v0 = (OZChannelFrameInfo *)operator new();
    OZChannelFrameInfo::OZChannelFrameInfo(v0);
    OZChannelFrame::_OZChannelFrameInfo = (uint64_t)v0;
  }
}

void sub_1B2C1BDD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelFrameInfo::OZChannelFrameInfo(OZChannelFrameInfo *this)
{
  uint64_t v2;

  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 100.0, 1.0, 0.01, 1.0, "");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(_QWORD *)this = &unk_1E654FD58;
  *((_QWORD *)this + 10) = &unk_1E654FD78;
}

void sub_1B2C1BE68(_Unwind_Exception *a1)
{
  OZChannelInfo *v1;

  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelFrame::createOZChannelFrameImpl(void)::{lambda(void)#1} &&>>()
{
  OZChannelFrame::createOZChannelFrameImpl(void)::{lambda(void)#1}::operator()();
}

void OZChannelFrame::createOZChannelFrameImpl(void)::{lambda(void)#1}::operator()()
{
  uint64_t v0;
  OZCurveDouble *v1;

  if (!OZChannelFrame::_OZChannelFrameImpl)
  {
    v0 = operator new();
    v1 = (OZCurveDouble *)operator new();
    OZCurveDouble::OZCurveDouble(v1, 0.0);
    OZChannelImpl::OZChannelImpl((OZChannelImpl *)v0, (OZCurve *)v1, 0.0, 1, 1);
    PCSingleton::PCSingleton((PCSingleton *)(v0 + 40), 100);
    *(_QWORD *)v0 = &unk_1E654FDD0;
    *(_QWORD *)(v0 + 40) = &unk_1E654FDF0;
    OZChannelFrame::_OZChannelFrameImpl = v0;
  }
}

void sub_1B2C1BF38(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelTimecode_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelTimecode_Factory *v0;

  v0 = (OZChannelTimecode_Factory *)operator new();
  OZChannelTimecode_Factory::OZChannelTimecode_Factory(v0);
  OZChannelTimecode_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1BFD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelTimecode_Factory::OZChannelTimecode_Factory(OZChannelTimecode_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B3555A80;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654FE48;
  *((_QWORD *)this + 16) = &unk_1E654FF18;
}

void sub_1B2C1C078(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelTimecode *OZChannelTimecode_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelTimecode *v6;

  v6 = (OZChannelTimecode *)operator new();
  OZChannelTimecode::OZChannelTimecode(v6, this, a2, a3, 0, 0);
  return v6;
}

void sub_1B2C1C0F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelTimecode_Factory::createCopy(OZChannelTimecode_Factory *this, OZFactoryBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6553D48;
  v3->var2 = (void **)&unk_1E65540A8;
  return v3;
}

void sub_1B2C1C194(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelTimecode_Factory::createChannelCopy(OZChannelTimecode_Factory *this, OZChannelBase *a2)
{
  OZChannel *v3;
  const OZChannelBase *v4;

  v3 = (OZChannel *)operator new();
  OZChannel::OZChannel(v3, v4, 0);
  v3->var0 = (void **)&off_1E6553D48;
  v3->var2 = (void **)&unk_1E65540A8;
  return v3;
}

void sub_1B2C1C238(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelTimecode::OZChannelTimecode(OZChannelTimecode *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannelTimecode *v9;
  OZChannelTimecode *OZChannelTimecodeInfo;
  OZChannelInfo *var17;
  OZChannelImpl *var15;

  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&off_1E6553D48;
  v9->var2 = (void **)&unk_1E65540A8;
  OZChannelTimecodeInfo = (OZChannelTimecode *)OZChannelTimecode::createOZChannelTimecodeInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelTimecode::_OZChannelTimecodeInfo;
    this->var17 = (OZChannelInfo *)OZChannelTimecode::_OZChannelTimecodeInfo;
  }
  this->var16 = var17;
  OZChannelTimecode::createOZChannelTimecodeImpl(OZChannelTimecodeInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelTimecode::_OZChannelTimecodeImpl;
    this->var15 = (OZChannelImpl *)OZChannelTimecode::_OZChannelTimecodeImpl;
  }
  this->var14 = var15;
}

void sub_1B2C1C304(_Unwind_Exception *a1)
{
  OZChannel *v1;

  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelBlindData_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelBlindData_Factory *v0;

  v0 = (OZChannelBlindData_Factory *)operator new();
  OZChannelBlindData_Factory::OZChannelBlindData_Factory(v0);
  OZChannelBlindData_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1C360(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelBlindData_Factory::OZChannelBlindData_Factory(OZChannelBlindData_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B3555A90;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E654FF70;
  *((_QWORD *)this + 16) = &unk_1E6550040;
}

void sub_1B2C1C400(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelBlindData *OZChannelBlindData_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelBlindData *v6;

  v6 = (OZChannelBlindData *)operator new();
  OZChannelBlindData::OZChannelBlindData(v6, this, a2, a3, 0, 0, 0, 0, 0);
  return v6;
}

void sub_1B2C1C48C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C4038C80BD5);
  _Unwind_Resume(a1);
}

OZChannelBlindData *OZChannelBlindData_Factory::createCopy(OZChannelBlindData_Factory *this, OZFactoryBase *a2)
{
  OZChannelBlindData *v3;
  const OZChannelBlindData *v4;

  v3 = (OZChannelBlindData *)operator new();
  OZChannelBlindData::OZChannelBlindData(v3, v4, 0);
  return v3;
}

void sub_1B2C1C518(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C4038C80BD5);
  _Unwind_Resume(a1);
}

OZChannelBlindData *OZChannelBlindData_Factory::createChannelCopy(OZChannelBlindData_Factory *this, OZChannelBase *a2)
{
  OZChannelBlindData *v3;
  const OZChannelBlindData *v4;

  v3 = (OZChannelBlindData *)operator new();
  OZChannelBlindData::OZChannelBlindData(v3, v4, 0);
  return v3;
}

void sub_1B2C1C5A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C4038C80BD5);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelCurve_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelCurve_Factory *v0;

  v0 = (OZChannelCurve_Factory *)operator new();
  OZChannelCurve_Factory::OZChannelCurve_Factory(v0);
  OZChannelCurve_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1C610(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelCurve_Factory::OZChannelCurve_Factory(OZChannelCurve_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B3555AA0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E6550098;
  *((_QWORD *)this + 16) = &unk_1E6550168;
}

void sub_1B2C1C6B0(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelCurve *OZChannelCurve_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelCurve *v6;

  v6 = (OZChannelCurve *)operator new();
  OZChannelCurve::OZChannelCurve(v6, this, a2, a3);
  return v6;
}

void sub_1B2C1C720(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C401ABBD6EFLL);
  _Unwind_Resume(a1);
}

OZChannelCurve *OZChannelCurve_Factory::createCopy(OZChannelCurve_Factory *this, OZFactoryBase *a2)
{
  OZChannelCurve *v3;
  const OZChannelCurve *v4;

  v3 = (OZChannelCurve *)operator new();
  OZChannelCurve::OZChannelCurve(v3, v4, 0);
  return v3;
}

void sub_1B2C1C7AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C401ABBD6EFLL);
  _Unwind_Resume(a1);
}

OZChannelCurve *OZChannelCurve_Factory::createChannelCopy(OZChannelCurve_Factory *this, OZChannelBase *a2)
{
  OZChannelCurve *v3;
  const OZChannelCurve *v4;

  v3 = (OZChannelCurve *)operator new();
  OZChannelCurve::OZChannelCurve(v3, v4, 0);
  return v3;
}

void sub_1B2C1C838(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C401ABBD6EFLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelEnum_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelEnum_Factory *v0;

  v0 = (OZChannelEnum_Factory *)operator new();
  OZChannelEnum_Factory::OZChannelEnum_Factory(v0);
  OZChannelEnum_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1C8A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelEnum_Factory::OZChannelEnum_Factory(OZChannelEnum_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B35558F0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E65501C0;
  *((_QWORD *)this + 16) = &unk_1E6550290;
}

void sub_1B2C1C944(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelEnum *OZChannelEnum_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelEnum *v6;

  v6 = (OZChannelEnum *)operator new();
  OZChannelEnum::OZChannelEnum(v6, this, a2, a3, 0, 0);
  return v6;
}

void sub_1B2C1C9BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C405E89EA5DLL);
  _Unwind_Resume(a1);
}

OZChannelEnum *OZChannelEnum_Factory::createCopy(OZChannelEnum_Factory *this, OZFactoryBase *a2)
{
  OZChannelEnum *v3;
  const OZChannelEnum *v4;

  v3 = (OZChannelEnum *)operator new();
  OZChannelEnum::OZChannelEnum(v3, v4, 0);
  return v3;
}

void sub_1B2C1CA48(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C405E89EA5DLL);
  _Unwind_Resume(a1);
}

OZChannelEnum *OZChannelEnum_Factory::createChannelCopy(OZChannelEnum_Factory *this, OZChannelBase *a2)
{
  OZChannelEnum *v3;
  const OZChannelEnum *v4;

  v3 = (OZChannelEnum *)operator new();
  OZChannelEnum::OZChannelEnum(v3, v4, 0);
  return v3;
}

void sub_1B2C1CAD4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C405E89EA5DLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientWithAngle_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelGradientWithAngle_Factory *v0;

  v0 = (OZChannelGradientWithAngle_Factory *)operator new();
  OZChannelGradientWithAngle_Factory::OZChannelGradientWithAngle_Factory(v0);
  OZChannelGradientWithAngle_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1CB40(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientWithAngle_Factory::OZChannelGradientWithAngle_Factory(OZChannelGradientWithAngle_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555970;
  v4 = xmmword_1B3555AB0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E65502E8;
  *((_QWORD *)this + 16) = &unk_1E65503B8;
}

void sub_1B2C1CBE0(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelGradientWithAngle *OZChannelGradientWithAngle_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelGradientWithAngle *v6;

  v6 = (OZChannelGradientWithAngle *)operator new();
  OZChannelGradientWithAngle::OZChannelGradientWithAngle(v6, this, a2, a3);
  return v6;
}

void sub_1B2C1CC50(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40FB5DE3D8);
  _Unwind_Resume(a1);
}

OZChannelGradientWithAngle *OZChannelGradientWithAngle_Factory::createCopy(OZChannelGradientWithAngle_Factory *this, OZFactoryBase *a2)
{
  OZChannelGradientWithAngle *v3;
  const OZChannelGradientWithAngle *v4;

  v3 = (OZChannelGradientWithAngle *)operator new();
  OZChannelGradientWithAngle::OZChannelGradientWithAngle(v3, v4, 0);
  return v3;
}

void sub_1B2C1CCDC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40FB5DE3D8);
  _Unwind_Resume(a1);
}

OZChannelGradientWithAngle *OZChannelGradientWithAngle_Factory::createChannelCopy(OZChannelGradientWithAngle_Factory *this, OZChannelBase *a2)
{
  OZChannelGradientWithAngle *v3;
  const OZChannelGradientWithAngle *v4;

  v3 = (OZChannelGradientWithAngle *)operator new();
  OZChannelGradientWithAngle::OZChannelGradientWithAngle(v3, v4, 0);
  return v3;
}

void sub_1B2C1CD68(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10F1C40FB5DE3D8);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelHistogramSample_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelHistogramSample_Factory *v0;

  v0 = (OZChannelHistogramSample_Factory *)operator new();
  OZChannelHistogramSample_Factory::OZChannelHistogramSample_Factory(v0);
  OZChannelHistogramSample_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1CDD4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelHistogramSample_Factory::OZChannelHistogramSample_Factory(OZChannelHistogramSample_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3053A10;
  v4 = xmmword_1B3555AC0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E6550410;
  *((_QWORD *)this + 16) = &unk_1E65504E0;
}

void sub_1B2C1CE74(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelHistogramSample *OZChannelHistogramSample_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelHistogramSample *v6;

  v6 = (OZChannelHistogramSample *)operator new();
  OZChannelHistogramSample::OZChannelHistogramSample(v6, this, a2, a3, 5u);
  return v6;
}

void sub_1B2C1CEE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40933A2D21);
  _Unwind_Resume(a1);
}

OZChannelHistogramSample *OZChannelHistogramSample_Factory::createCopy(OZChannelHistogramSample_Factory *this, OZFactoryBase *a2)
{
  OZChannelHistogramSample *v3;
  const OZChannelHistogramSample *v4;

  v3 = (OZChannelHistogramSample *)operator new();
  OZChannelHistogramSample::OZChannelHistogramSample(v3, v4, 0);
  return v3;
}

void sub_1B2C1CF74(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40933A2D21);
  _Unwind_Resume(a1);
}

OZChannelHistogramSample *OZChannelHistogramSample_Factory::createChannelCopy(OZChannelHistogramSample_Factory *this, OZChannelBase *a2)
{
  OZChannelHistogramSample *v3;
  const OZChannelHistogramSample *v4;

  v3 = (OZChannelHistogramSample *)operator new();
  OZChannelHistogramSample::OZChannelHistogramSample(v3, v4, 0);
  return v3;
}

void sub_1B2C1D000(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40933A2D21);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelProgress_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelProgress_Factory *v0;

  v0 = (OZChannelProgress_Factory *)operator new();
  OZChannelProgress_Factory::OZChannelProgress_Factory(v0);
  OZChannelProgress_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1D06C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelProgress_Factory::OZChannelProgress_Factory(OZChannelProgress_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B3555AD0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E6550538;
  *((_QWORD *)this + 16) = &unk_1E6550608;
}

void sub_1B2C1D10C(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelProgress *OZChannelProgress_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelProgress *v6;

  v6 = (OZChannelProgress *)operator new();
  OZChannelProgress::OZChannelProgress(v6, this, a2, a3);
  return v6;
}

void sub_1B2C1D17C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40C6BB7E01);
  _Unwind_Resume(a1);
}

OZChannelProgress *OZChannelProgress_Factory::createCopy(OZChannelProgress_Factory *this, OZFactoryBase *a2)
{
  OZChannelProgress *v3;
  const OZChannelBase *v4;

  v3 = (OZChannelProgress *)operator new();
  OZChannelProgress::OZChannelProgress(v3, v4, 0);
  return v3;
}

void sub_1B2C1D208(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40C6BB7E01);
  _Unwind_Resume(a1);
}

OZChannelProgress *OZChannelProgress_Factory::createChannelCopy(OZChannelProgress_Factory *this, OZChannelBase *a2)
{
  OZChannelProgress *v3;
  const OZChannelBase *v4;

  v3 = (OZChannelProgress *)operator new();
  OZChannelProgress::OZChannelProgress(v3, v4, 0);
  return v3;
}

void sub_1B2C1D294(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40C6BB7E01);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelScaleOverLife_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelScaleOverLife_Factory *v0;

  v0 = (OZChannelScaleOverLife_Factory *)operator new();
  OZChannelScaleOverLife_Factory::OZChannelScaleOverLife_Factory(v0);
  OZChannelScaleOverLife_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1D300(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelScaleOverLife_Factory::OZChannelScaleOverLife_Factory(OZChannelScaleOverLife_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555AA0;
  v4 = xmmword_1B3555AE0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E6550660;
  *((_QWORD *)this + 16) = &unk_1E6550730;
}

void sub_1B2C1D3A0(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelScaleOverLife *OZChannelScaleOverLife_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelScaleOverLife *v6;

  v6 = (OZChannelScaleOverLife *)operator new();
  OZChannelScaleOverLife::OZChannelScaleOverLife(v6, this, a2, a3);
  return v6;
}

void sub_1B2C1D410(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C401ABBD6EFLL);
  _Unwind_Resume(a1);
}

OZChannelScaleOverLife *OZChannelScaleOverLife_Factory::createCopy(OZChannelScaleOverLife_Factory *this, OZFactoryBase *a2)
{
  OZChannelScaleOverLife *v3;
  const OZChannelScaleOverLife *v4;

  v3 = (OZChannelScaleOverLife *)operator new();
  OZChannelScaleOverLife::OZChannelScaleOverLife(v3, v4, 0);
  return v3;
}

void sub_1B2C1D49C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C401ABBD6EFLL);
  _Unwind_Resume(a1);
}

OZChannelScaleOverLife *OZChannelScaleOverLife_Factory::createChannelCopy(OZChannelScaleOverLife_Factory *this, OZChannelBase *a2)
{
  OZChannelScaleOverLife *v3;
  const OZChannelScaleOverLife *v4;

  v3 = (OZChannelScaleOverLife *)operator new();
  OZChannelScaleOverLife::OZChannelScaleOverLife(v3, v4, 0);
  return v3;
}

void sub_1B2C1D528(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C401ABBD6EFLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelVertexFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelVertexFolder_Factory *v0;

  v0 = (OZChannelVertexFolder_Factory *)operator new();
  OZChannelVertexFolder_Factory::OZChannelVertexFolder_Factory(v0);
  OZChannelVertexFolder_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1D594(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelVertexFolder_Factory::OZChannelVertexFolder_Factory(OZChannelVertexFolder_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3053A10;
  v4 = xmmword_1B3555AF0;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E6550788;
  *((_QWORD *)this + 16) = &unk_1E6550858;
}

void sub_1B2C1D634(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChannelVertexFolder *OZChannelVertexFolder_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChannelVertexFolder *v6;

  v6 = (OZChannelVertexFolder *)operator new();
  OZChannelVertexFolder::OZChannelVertexFolder(v6, this, a2, a3);
  return v6;
}

void sub_1B2C1D6A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40C4B5480ALL);
  _Unwind_Resume(a1);
}

OZChannelVertexFolder *OZChannelVertexFolder_Factory::createCopy(OZChannelVertexFolder_Factory *this, OZFactoryBase *a2)
{
  OZChannelVertexFolder *v3;
  const OZChannelVertexFolder *v4;

  v3 = (OZChannelVertexFolder *)operator new();
  OZChannelVertexFolder::OZChannelVertexFolder(v3, v4, 0);
  return v3;
}

void sub_1B2C1D730(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40C4B5480ALL);
  _Unwind_Resume(a1);
}

OZChannelVertexFolder *OZChannelVertexFolder_Factory::createChannelCopy(OZChannelVertexFolder_Factory *this, OZChannelBase *a2)
{
  OZChannelVertexFolder *v3;
  const OZChannelVertexFolder *v4;

  v3 = (OZChannelVertexFolder *)operator new();
  OZChannelVertexFolder::OZChannelVertexFolder(v3, v4, 0);
  return v3;
}

void sub_1B2C1D7BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40C4B5480ALL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChanObjectRef_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChanObjectRef_Factory *v0;

  v0 = (OZChanObjectRef_Factory *)operator new();
  OZChanObjectRef_Factory::OZChanObjectRef_Factory(v0);
  OZChanObjectRef_Factory::_instance = (uint64_t)v0;
}

void sub_1B2C1D828(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChanObjectRef_Factory::OZChanObjectRef_Factory(OZChanObjectRef_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555760;
  v4 = xmmword_1B3555B00;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E65508B0;
  *((_QWORD *)this + 16) = &unk_1E6550980;
}

void sub_1B2C1D8C8(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

OZChanObjectRef *OZChanObjectRef_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  OZChanObjectRef *v6;

  v6 = (OZChanObjectRef *)operator new();
  OZChanObjectRef::OZChanObjectRef(v6, this, a2, a3);
  return v6;
}

void sub_1B2C1D938(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChanObjectRef *OZChanObjectRef_Factory::createCopy(OZChanObjectRef_Factory *this, OZFactoryBase *a2)
{
  OZChanObjectRef *v3;
  const OZChannelBase *v4;

  v3 = (OZChanObjectRef *)operator new();
  OZChanObjectRef::OZChanObjectRef(v3, v4, 0);
  return v3;
}

void sub_1B2C1D9C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChanObjectRef *OZChanObjectRef_Factory::createChannelCopy(OZChanObjectRef_Factory *this, OZChannelBase *a2)
{
  OZChanObjectRef *v3;
  const OZChannelBase *v4;

  v3 = (OZChanObjectRef *)operator new();
  OZChanObjectRef::OZChanObjectRef(v3, v4, 0);
  return v3;
}

void sub_1B2C1DA50(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

_OWORD *std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(uint64_t **a1, unsigned int *a2, uint64_t a3, _OWORD **a4)
{
  uint64_t *v6;
  _OWORD *v7;
  uint64_t **v8;
  uint64_t v10;

  v6 = std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__find_equal<PCUUID>((uint64_t)a1, &v10, a2);
  v7 = (_OWORD *)*v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = operator new(0x38uLL);
    v7[2] = **a4;
    *((_QWORD *)v7 + 6) = 0;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v10, v8, (uint64_t *)v7);
  }
  return v7;
}

uint64_t *std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__find_equal<PCUUID>(uint64_t a1, _QWORD *a2, unsigned int *a3)
{
  uint64_t *result;
  uint64_t *v4;
  uint64_t *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  BOOL v14;
  unsigned int v15;
  BOOL v16;

  v5 = *(uint64_t **)(a1 + 8);
  result = (uint64_t *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
    v6 = *a3;
    v7 = a3[1];
    v8 = a3[2];
    v9 = a3[3];
    while (1)
    {
      v10 = v4;
      v11 = *((_DWORD *)v4 + 8);
      if (v6 != v11)
        break;
      v12 = *((_DWORD *)v10 + 9);
      if (v7 == v12)
      {
        v13 = *((_DWORD *)v10 + 10);
        v14 = v8 >= v13;
        if (v8 == v13)
          v14 = v9 >= *((_DWORD *)v10 + 11);
        if (!v14)
          goto LABEL_18;
        v15 = *((_DWORD *)v10 + 10);
        v16 = v15 >= v8;
        if (v15 != v8)
          goto LABEL_14;
        if (*((_DWORD *)v10 + 11) >= v9)
          goto LABEL_23;
LABEL_15:
        result = v10 + 1;
        v4 = (uint64_t *)v10[1];
        if (!v4)
          goto LABEL_23;
      }
      else
      {
        if (v7 >= v12)
        {
          if (v12 >= v7)
            goto LABEL_23;
          goto LABEL_15;
        }
LABEL_18:
        v4 = (uint64_t *)*v10;
        result = v10;
        if (!*v10)
          goto LABEL_23;
      }
    }
    if (v6 >= v11)
    {
      v16 = v11 >= v6;
LABEL_14:
      if (v16)
        goto LABEL_23;
      goto LABEL_15;
    }
    goto LABEL_18;
  }
  v10 = result;
LABEL_23:
  *a2 = v10;
  return result;
}

_DWORD *std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::find<PCUUID>(uint64_t a1, unsigned int *a2)
{
  _DWORD *v3;
  _DWORD *result;
  unsigned int v5;
  BOOL v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  v3 = (_DWORD *)(a1 + 8);
  result = std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__lower_bound<PCUUID>(a1, a2, *(_DWORD **)(a1 + 8), (_DWORD *)(a1 + 8));
  if (v3 == result)
    return v3;
  v5 = result[8];
  v6 = *a2 >= v5;
  if (*a2 == v5)
  {
    v7 = a2[1];
    v8 = result[9];
    v6 = v7 >= v8;
    if (v7 == v8)
    {
      v9 = a2[2];
      v10 = result[10];
      v6 = v9 >= v10;
      if (v9 == v10)
        v6 = a2[3] >= result[11];
    }
  }
  if (!v6)
    return v3;
  return result;
}

_DWORD *std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__lower_bound<PCUUID>(uint64_t a1, unsigned int *a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *result;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  BOOL v13;
  _QWORD *v14;

  result = a4;
  if (a3)
  {
    v5 = *a2;
    v6 = a2[1];
    v7 = a2[2];
    do
    {
      v8 = a3[8];
      v9 = v8 >= v5;
      if (v8 == v5)
      {
        v10 = a3[9];
        v9 = v10 >= v6;
        if (v10 == v6)
        {
          v11 = a3[10];
          v9 = v11 >= v7;
          if (v11 == v7)
            v9 = a3[11] >= a2[3];
        }
      }
      v12 = !v9;
      v13 = v12 == 0;
      if (v12)
        v14 = a3 + 2;
      else
        v14 = a3;
      if (v13)
        result = a3;
      a3 = (_DWORD *)*v14;
    }
    while (*v14);
  }
  return result;
}

void sub_1B2C1DD40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  uint64_t v10;

  PCString::~PCString(&a10);
  MEMORY[0x1B5E29170](v10, 0x10E1C40BB3F29BDLL);
  _Unwind_Resume(a1);
}

void sub_1B2C1DE14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

void sub_1B2C1DEB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

void sub_1B2C1DF68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

uint64_t OZFactory::OZFactory(uint64_t a1, _OWORD *a2, _OWORD *a3, int a4)
{
  *(_QWORD *)a1 = off_1E65509D8;
  *(_OWORD *)(a1 + 8) = *a2;
  *(_OWORD *)(a1 + 24) = *a3;
  *(_QWORD *)(a1 + 48) = 0;
  PCMutex::PCMutex((PCMutex *)(a1 + 56));
  *(_DWORD *)(a1 + 40) = a4;
  return a1;
}

void sub_1B2C1E03C(_Unwind_Exception *a1)
{
  PCMutex *v1;

  PCMutex::~PCMutex(v1);
  _Unwind_Resume(a1);
}

void OZFactory::~OZFactory(OZFactory *this)
{
  *(_QWORD *)this = off_1E65509D8;
  PCMutex::~PCMutex((PCMutex *)((char *)this + 56));
}

uint64_t OZFactory::needsSaving(OZFactory *this, const OZFactory *a2)
{
}

uint64_t *`anonymous namespace'::getThreadSpecificForFactory(_anonymous_namespace_ *this, const OZFactory *a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t **v5;
  uint64_t **v6;
  unint64_t v7;
  BOOL v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t **v12;
  unint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t *v16;

  if (!v3)
  {
    v3 = operator new();
    *(_QWORD *)(v3 + 16) = 0;
    *(_QWORD *)(v3 + 8) = 0;
    *(_QWORD *)v3 = v3 + 8;
  }
  v5 = (uint64_t **)(v3 + 8);
  v4 = *(_QWORD **)(v3 + 8);
  if (!v4)
    goto LABEL_14;
  v6 = (uint64_t **)(v3 + 8);
  do
  {
    v7 = v4[4];
    v8 = v7 >= (unint64_t)this;
    if (v7 >= (unint64_t)this)
      v9 = v4;
    else
      v9 = v4 + 1;
    if (v8)
      v6 = (uint64_t **)v4;
    v4 = (_QWORD *)*v9;
  }
  while (*v9);
  if (v6 != v5 && v6[4] <= (uint64_t *)this)
    return v6[5];
LABEL_14:
  v10 = operator new();
  *(_BYTE *)v10 = 0;
  *(_DWORD *)(v10 + 4) = 0;
  v11 = *v5;
  v12 = (uint64_t **)(v3 + 8);
  if (*v5)
  {
    while (1)
    {
      while (1)
      {
        v12 = (uint64_t **)v11;
        v13 = v11[4];
        if (v13 <= (unint64_t)this)
          break;
        v11 = *v12;
        v5 = v12;
        if (!*v12)
          goto LABEL_21;
      }
      if (v13 >= (unint64_t)this)
        break;
      v11 = v12[1];
      if (!v11)
      {
        v5 = v12 + 1;
        goto LABEL_21;
      }
    }
  }
  else
  {
LABEL_21:
    v14 = (uint64_t *)v12;
    v12 = (uint64_t **)operator new(0x30uLL);
    v12[4] = (uint64_t *)this;
    v12[5] = 0;
    *v12 = 0;
    v12[1] = 0;
    v12[2] = v14;
    *v5 = (uint64_t *)v12;
    v15 = **(_QWORD **)v3;
    v16 = (uint64_t *)v12;
    if (v15)
    {
      *(_QWORD *)v3 = v15;
      v16 = *v5;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v3 + 8), v16);
    ++*(_QWORD *)(v3 + 16);
  }
  v12[5] = (uint64_t *)v10;
  return (uint64_t *)v10;
}

uint64_t *OZFactory::setNeedsSaving(OZFactory *this, const OZFactory *a2)
{
  char v2;
  uint64_t *result;

  v2 = (char)a2;
  *(_BYTE *)result = v2;
  return result;
}

uint64_t OZFactory::fileRefID(OZFactory *this, const OZFactory *a2)
{
}

uint64_t *OZFactory::setFileRefID(OZFactory *this, const OZFactory *a2)
{
  int v2;
  uint64_t *result;

  v2 = (int)a2;
  *((_DWORD *)result + 1) = v2;
  return result;
}

unint64_t OZFactory::getSuperFactory(OZFactory *this)
{
  unint64_t *v1;
  OZFactories *v4;
  uint64_t Instance;
  PCMutex *v8;

  v1 = (unint64_t *)((char *)this + 48);
  if (!atomic_load((unint64_t *)this + 6))
  {
    v8 = (PCMutex *)((char *)this + 56);
    v4 = (OZFactories *)PCMutex::lock((PCMutex *)((char *)this + 56));
    if (!atomic_load(v1))
    {
      Instance = OZFactories::getInstance(v4);
      atomic_store(OZFactories::findFactory(Instance, (unsigned int *)this + 6), (unint64_t *)this + 6);
    }
    if (v8)
      PCMutex::unlock(v8);
  }
  return atomic_load(v1);
}

void sub_1B2C1E304(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  _Unwind_Resume(a1);
}

unint64_t OZFactory::isKindOfClass(unint64_t result, int32x4_t *a2)
{
  int32x4_t v3;

  if (result)
  {
    while (1)
    {
      v3 = *(int32x4_t *)(result + 8);
      if (!*(_QWORD *)&vorr_s8(*(int8x8_t *)v3.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v3, (int8x16_t)v3, 8uLL)))
        return 0;
      if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(v3, *a2)))) & 1) == 0)
        break;
      result = OZFactory::getSuperFactory((OZFactory *)result);
      if (!result)
        return result;
    }
    return 1;
  }
  return result;
}

void OZFactory::getIconName(OZFactory *this@<X0>, PCSharedCount *a2@<X8>)
{
  OZFactory *SuperFactory;
  _BOOL4 v4;
  PCString v5;

  if (this)
  {
    SuperFactory = this;
    while (1)
    {
      (*(void (**)(PCString *__return_ptr, OZFactory *))(*(_QWORD *)SuperFactory + 136))(&v5, SuperFactory);
      v4 = PCString::empty(&v5);
      PCString::~PCString(&v5);
      if (!v4)
        break;
      SuperFactory = (OZFactory *)OZFactory::getSuperFactory(SuperFactory);
      if (!SuperFactory)
        goto LABEL_5;
    }
    (*(void (**)(OZFactory *))(*(_QWORD *)SuperFactory + 136))(SuperFactory);
  }
  else
  {
LABEL_5:
    PCSharedCount::PCSharedCount(a2);
  }
}

void sub_1B2C1E418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

void OZFactory::getIconNameBW(OZFactory *this@<X0>, PCSharedCount *a2@<X8>)
{
  OZFactory *SuperFactory;
  _BOOL4 v4;
  PCString v5;

  if (this)
  {
    SuperFactory = this;
    while (1)
    {
      (*(void (**)(PCString *__return_ptr, OZFactory *))(*(_QWORD *)SuperFactory + 144))(&v5, SuperFactory);
      v4 = PCString::empty(&v5);
      PCString::~PCString(&v5);
      if (!v4)
        break;
      SuperFactory = (OZFactory *)OZFactory::getSuperFactory(SuperFactory);
      if (!SuperFactory)
        goto LABEL_5;
    }
    (*(void (**)(OZFactory *))(*(_QWORD *)SuperFactory + 144))(SuperFactory);
  }
  else
  {
LABEL_5:
    PCSharedCount::PCSharedCount(a2);
  }
}

void sub_1B2C1E4BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

uint64_t OZFactory::getIconID(OZFactory *this)
{
  OZFactory *SuperFactory;

  if (!this)
    return 0xFFFFFFFFLL;
  SuperFactory = this;
  while ((*(unsigned int (**)(OZFactory *))(*(_QWORD *)SuperFactory + 152))(SuperFactory) == -1)
  {
    SuperFactory = (OZFactory *)OZFactory::getSuperFactory(SuperFactory);
    if (!SuperFactory)
      return 0xFFFFFFFFLL;
  }
  return (*(uint64_t (**)(OZFactory *))(*(_QWORD *)SuperFactory + 152))(SuperFactory);
}

uint64_t `anonymous namespace'::freeThreadSpecific(_anonymous_namespace_ **this, void *a2)
{
  _anonymous_namespace_ **v3;
  _anonymous_namespace_ *v4;
  uint64_t v5;
  _anonymous_namespace_ *v6;
  _anonymous_namespace_ **v7;
  BOOL v8;

  v3 = this + 1;
  v4 = *this;
  if (*this != (_anonymous_namespace_ *)(this + 1))
  {
    do
    {
      v5 = *((_QWORD *)v4 + 5);
      if (v5)
        MEMORY[0x1B5E29170](v5, 0x1000C404A09149ALL);
      v6 = (_anonymous_namespace_ *)*((_QWORD *)v4 + 1);
      if (v6)
      {
        do
        {
          v7 = (_anonymous_namespace_ **)v6;
          v6 = *(_anonymous_namespace_ **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (_anonymous_namespace_ **)*((_QWORD *)v4 + 2);
          v8 = *v7 == v4;
          v4 = (_anonymous_namespace_ *)v7;
        }
        while (!v8);
      }
      v4 = (_anonymous_namespace_ *)v7;
    }
    while (v7 != v3);
  }
  MEMORY[0x1B5E29170](this, 0x1020C4062D53EE8);
}

void OZFactory::getLibraryIconName(OZFactory *this@<X0>, PCURL *a2@<X8>)
{
  OZFactory *SuperFactory;
  _BOOL4 v4;
  const char *v5;
  void *v6;
  const void *v7;
  PCString v8;
  PCString v9;

  if (this)
  {
    SuperFactory = this;
    while (1)
    {
      (*(void (**)(PCString *__return_ptr, OZFactory *))(*(_QWORD *)SuperFactory + 160))(&v9, SuperFactory);
      v4 = PCString::empty(&v9);
      PCString::~PCString(&v9);
      if (!v4)
        break;
      SuperFactory = (OZFactory *)OZFactory::getSuperFactory(SuperFactory);
      if (!SuperFactory)
        goto LABEL_5;
    }
    v5 = (const char *)(*(uint64_t (**)(OZFactory *))(*(_QWORD *)SuperFactory + 128))(SuperFactory);
    PCString::PCString(&v9, v5);
    v6 = (void *)objc_msgSend(MEMORY[0x1E0CB34D0], "bundleWithIdentifier:", PCString::ns_str(&v9));
    (*(void (**)(PCString *__return_ptr, OZFactory *))(*(_QWORD *)SuperFactory + 160))(&v8, SuperFactory);
    v7 = (const void *)objc_msgSend(v6, "pathForResource:ofType:", PCString::ns_str(&v8), CFSTR("icns"));
    PCString::~PCString(&v8);
    PCURL::PCURL(a2, v7);
    PCString::~PCString(&v9);
  }
  else
  {
LABEL_5:
    PCSharedCount::PCSharedCount((PCSharedCount *)a2);
  }
}

void sub_1B2C1E6F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

uint64_t OZChanObjectRef::createOZChanObjectRefInfo(OZChanObjectRef *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChanObjectRef::createOZChanObjectRefInfo(void)::_OZChanObjectRefInfo_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChanObjectRef::createOZChanObjectRefInfo(void)::_OZChanObjectRefInfo_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChanObjectRef::createOZChanObjectRefInfo(void)::{lambda(void)#1} &&>>);
  }
  return OZChanObjectRef::_OZChanObjectRefInfo;
}

uint64_t OZChanObjectRef::createOZChanObjectRefImpl(OZChanObjectRef *this, double a2)
{
  unint64_t v2;
  double v4;
  double **v5;
  double *v6;

  v4 = a2;
  v2 = atomic_load(&OZChanObjectRef::createOZChanObjectRefImpl(double)::_OZChanObjectRefImpl_once);
  if (v2 != -1)
  {
    v6 = &v4;
    v5 = &v6;
    std::__call_once(&OZChanObjectRef::createOZChanObjectRefImpl(double)::_OZChanObjectRefImpl_once, &v5, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChanObjectRef::createOZChanObjectRefImpl(double)::{lambda(void)#1} &&>>);
  }
  return OZChanObjectRef::_OZChanObjectRefImpl;
}

void OZChanObjectRef::OZChanObjectRef(OZChanObjectRef *this, OZFactory *a2, const PCString *a3, OZChannelFolder *a4, unsigned int a5, int a6)
{
  OZChanObjectRef *v7;
  OZChanObjectRef *OZChanObjectRefInfo;
  uint64_t v9;
  uint64_t v10;

  OZChannel::OZChannel((OZChannel *)this, a2, a3, a4, a5, a6, 0, 0);
  *(_QWORD *)v7 = &off_1E6550AA0;
  *((_QWORD *)v7 + 2) = &unk_1E6550E10;
  OZChanObjectRefInfo = (OZChanObjectRef *)OZChanObjectRef::createOZChanObjectRefInfo(v7);
  v9 = OZChanObjectRef::_OZChanObjectRefInfo;
  *((_QWORD *)this + 16) = OZChanObjectRef::_OZChanObjectRefInfo;
  *((_QWORD *)this + 17) = v9;
  OZChanObjectRef::createOZChanObjectRefImpl(OZChanObjectRefInfo, 0.0);
  v10 = OZChanObjectRef::_OZChanObjectRefImpl;
  *((_QWORD *)this + 14) = OZChanObjectRef::_OZChanObjectRefImpl;
  *((_QWORD *)this + 15) = v10;
  *((_QWORD *)this + 7) |= 0x1000010000uLL;
}

void sub_1B2C1E854(_Unwind_Exception *a1)
{
  OZChannel *v1;

  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

void OZChanObjectRef::OZChanObjectRef(OZChanObjectRef *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  OZChanObjectRef *v5;
  OZChanObjectRef *OZChanObjectRefInfo;
  uint64_t v7;
  uint64_t v8;

  OZChannel::OZChannel((OZChannel *)this, a2, a3, a4, 0, 0);
  *(_QWORD *)v5 = &off_1E6550AA0;
  *((_QWORD *)v5 + 2) = &unk_1E6550E10;
  OZChanObjectRefInfo = (OZChanObjectRef *)OZChanObjectRef::createOZChanObjectRefInfo(v5);
  v7 = OZChanObjectRef::_OZChanObjectRefInfo;
  *((_QWORD *)this + 16) = OZChanObjectRef::_OZChanObjectRefInfo;
  *((_QWORD *)this + 17) = v7;
  OZChanObjectRef::createOZChanObjectRefImpl(OZChanObjectRefInfo, 0.0);
  v8 = OZChanObjectRef::_OZChanObjectRefImpl;
  *((_QWORD *)this + 14) = OZChanObjectRef::_OZChanObjectRefImpl;
  *((_QWORD *)this + 15) = v8;
  *((_QWORD *)this + 7) |= 0x1000010000uLL;
}

void sub_1B2C1E8E0(_Unwind_Exception *a1)
{
  OZChannel *v1;

  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

void OZChanObjectRef::OZChanObjectRef(OZChanObjectRef *this, const OZChannelBase *a2, OZChannelFolder *a3)
{
  _QWORD *v3;

  OZChannel::OZChannel((OZChannel *)this, a2, a3);
  *v3 = &off_1E6550AA0;
  v3[2] = &unk_1E6550E10;
}

void `non-virtual thunk to'OZChanObjectRef::~OZChanObjectRef(OZChanObjectRef *this)
{
  OZChannel::~OZChannel((OZChannel *)((char *)this - 16));
}

{
  OZChannel::~OZChannel((OZChannel *)((char *)this - 16));
  JUMPOUT(0x1B5E29170);
}

void OZChanObjectRef::~OZChanObjectRef(OZChannel *this)
{
  OZChannel::~OZChannel(this);
  JUMPOUT(0x1B5E29170);
}

OZChannel *OZChanObjectRef::clone(const OZChannelBase *this)
{
  OZChannel *v2;

  v2 = (OZChannel *)operator new();
  OZChannel::OZChannel(v2, this, 0);
  v2->var0 = (void **)&off_1E6550AA0;
  v2->var2 = (void **)&unk_1E6550E10;
  return v2;
}

void sub_1B2C1E9D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChanObjectRef::createOZChanObjectRefInfo(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChanObjectRefInfo *v0;

  if (!OZChanObjectRef::_OZChanObjectRefInfo)
  {
    v0 = (OZChanObjectRefInfo *)operator new();
    OZChanObjectRefInfo::OZChanObjectRefInfo(v0);
    OZChanObjectRef::_OZChanObjectRefInfo = (uint64_t)v0;
  }
}

void sub_1B2C1EA4C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChanObjectRefInfo::OZChanObjectRefInfo(OZChanObjectRefInfo *this)
{
  uint64_t v2;

  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 4294967300.0, 1.0, 1.0, 1.0, "");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(_QWORD *)this = &unk_1E6550E80;
  *((_QWORD *)this + 10) = &unk_1E6550EA0;
}

void sub_1B2C1EAD8(_Unwind_Exception *a1)
{
  OZChannelInfo *v1;

  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

OZChannelImpl *std::__call_once_param<std::tuple<OZChanObjectRef::createOZChanObjectRefImpl(double)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>(OZChannelImpl *result)
{
  double *v1;
  OZCurveEnum *v2;
  OZChannelImpl *v3;

  if (!OZChanObjectRef::_OZChanObjectRefImpl)
  {
    v1 = **(double ***)result;
    v2 = (OZCurveEnum *)operator new();
    OZCurveEnum::OZCurveEnum(v2, *v1);
    v3 = (OZChannelImpl *)operator new();
    result = OZChannelImpl::OZChannelImpl(v3, (OZCurve *)v2, *v1, 0, 1);
    OZChanObjectRef::_OZChanObjectRefImpl = (uint64_t)v3;
  }
  return result;
}

void sub_1B2C1EB7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C407F0BD61ELL);
  _Unwind_Resume(a1);
}

uint64_t OZCoreGlobals::getInstance(OZCoreGlobals *this)
{
  if (OZCoreGlobals::getInstance(void)::once != -1)
    dispatch_once(&OZCoreGlobals::getInstance(void)::once, &__block_literal_global_63);
  return OZCoreGlobals::_instance;
}

__n128 ___ZN13OZCoreGlobals11getInstanceEv_block_invoke()
{
  uint64_t v0;
  uint64_t v1;
  __n128 result;

  v0 = operator new();
  PCSingleton::PCSingleton((PCSingleton *)v0, 0);
  *(_QWORD *)v0 = &unk_1E6550EF8;
  *(_DWORD *)(v0 + 8) = 0x1000000;
  v1 = MEMORY[0x1E0CA2E68];
  result = *(__n128 *)MEMORY[0x1E0CA2E68];
  *(_OWORD *)(v0 + 12) = *MEMORY[0x1E0CA2E68];
  *(_QWORD *)(v0 + 28) = *(_QWORD *)(v1 + 16);
  OZCoreGlobals::_instance = v0;
  return result;
}

void sub_1B2C1EC68(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1081C40A1FA7B50);
  _Unwind_Resume(a1);
}

void OZCoreGlobals::~OZCoreGlobals(OZCoreGlobals *this)
{
  PCSingleton::~PCSingleton(this);
  JUMPOUT(0x1B5E29170);
}

void OZChannel::OZChannel(OZChannel *this, OZFactory *a2, const PCString *a3, OZChannelFolder *a4, unsigned int a5, int a6, OZChannelImpl *a7, OZChannelInfo *a8)
{
  _QWORD *v10;

  OZChannelBase::OZChannelBase((OZChannelBase *)this, a2, a3, a4, a5, a6);
  *v10 = &off_1E6550F70;
  v10[2] = &unk_1E65512D0;
  v10[16] = a8;
  v10[17] = a8;
  v10[14] = a7;
  v10[15] = a7;
  v10[18] = 0;
}

void OZChannel::OZChannel(OZChannel *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  _QWORD *v8;

  OZChannelBase::OZChannelBase((OZChannelBase *)this, a2, a3, a4);
  *v8 = &off_1E6550F70;
  v8[2] = &unk_1E65512D0;
  v8[16] = a6;
  v8[17] = a6;
  v8[14] = a5;
  v8[15] = a5;
  v8[18] = 0;
}

void OZChannel::OZChannel(OZChannel *this, const OZChannelBase *a2, OZChannelFolder *a3)
{
  _QWORD *v5;
  uint64_t var0;
  OZChannelImpl *var1;
  uint64_t var2;
  OZCurve *v9;
  OZChannelInfo *v10;

  OZChannelBase::OZChannelBase((OZChannelBase *)this, a2, a3);
  *v5 = &off_1E6550F70;
  v5[2] = &unk_1E65512D0;
  v5[14] = 0;
  v5[15] = 0;
  var0 = (uint64_t)a2[1].var0;
  if (var0 && !*(_BYTE *)(var0 + 32))
  {
    var0 = operator new();
    OZChannelImpl::OZChannelImpl((OZChannelImpl *)var0, (const OZChannelImpl *)a2[1].var0);
  }
  var1 = (OZChannelImpl *)a2[1].var1;
  this->var14 = (OZChannelImpl *)var0;
  this->var15 = var1;
  this->var16 = 0;
  this->var17 = 0;
  var2 = (uint64_t)a2[1].var2;
  if (!*(_BYTE *)(var2 + 72))
  {
    var2 = operator new();
    OZChannelInfo::OZChannelInfo((OZChannelInfo *)var2, (const OZChannelInfo *)a2[1].var2);
  }
  v10 = *(OZChannelInfo **)&a2[1].var3;
  v9 = (OZCurve *)a2[1].var4.var0;
  this->var16 = (OZChannelInfo *)var2;
  this->var17 = v10;
  if (v9)
    v9 = (OZCurve *)(*(uint64_t (**)(OZCurve *))(*(_QWORD *)v9 + 1224))(v9);
  this->var18 = v9;
}

void sub_1B2C1EE0C(_Unwind_Exception *a1)
{
  OZChannelBase *v1;
  uint64_t v2;

  MEMORY[0x1B5E29170](v2, 0x10A1C407F0BD61ELL);
  OZChannelBase::~OZChannelBase(v1);
  _Unwind_Resume(a1);
}

void OZChannel::~OZChannel(OZChannel *this)
{
  OZChannelImpl *var14;
  OZChannelInfo *var16;
  OZCurve *var18;

  this->var0 = (void **)&off_1E6550F70;
  this->var2 = (void **)&unk_1E65512D0;
  var14 = this->var14;
  if (var14 && !*((_BYTE *)var14 + 32))
  {
    (*(void (**)(OZChannelImpl *))(*(_QWORD *)var14 + 8))(var14);
    this->var14 = 0;
  }
  var16 = this->var16;
  if (var16 && !*((_BYTE *)var16 + 72))
  {
    (*(void (**)(OZChannelInfo *))(*(_QWORD *)var16 + 8))(var16);
    this->var16 = 0;
  }
  this->var15 = 0;
  this->var17 = 0;
  var18 = this->var18;
  if (var18)
    (*(void (**)(OZCurve *))(*(_QWORD *)var18 + 8))(var18);
  this->var18 = 0;
  OZChannelBase::~OZChannelBase((OZChannelBase *)this);
}

{
  OZChannel::~OZChannel(this);
  JUMPOUT(0x1B5E29170);
}

void `non-virtual thunk to'OZChannel::~OZChannel(OZChannel *this)
{
  OZChannel::~OZChannel((OZChannel *)((char *)this - 16));
}

{
  OZChannel::~OZChannel((OZChannel *)((char *)this - 16));
  JUMPOUT(0x1B5E29170);
}

OZChannelImpl *OZChannelImpl::createLocalCopy(OZChannelImpl *this)
{
  OZChannelImpl *v2;

  v2 = (OZChannelImpl *)operator new();
  OZChannelImpl::OZChannelImpl(v2, this);
  return v2;
}

void sub_1B2C1EF8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C407F0BD61ELL);
  _Unwind_Resume(a1);
}

uint64_t OZChannel::resetLocalChannelImplementation(OZChannel *this)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = (uint64_t)this->var14;
  if (!*(_BYTE *)(result + 32))
  {
    result = OZChannelImpl::shouldKeepLocalCopy((OZChannelImpl *)result);
    if ((result & 1) == 0)
    {
      result = OZChannelImpl::operator==((uint64_t)this->var14, (uint64_t)this->var15);
      if ((_DWORD)result)
      {
        var14 = this->var14;
        this->var14 = this->var15;
        if (var14)
          (*(void (**)(OZChannelImpl *))(*(_QWORD *)var14 + 8))(var14);
        return (uint64_t)OZChannel::installPrototypeCurveInterface(this);
      }
    }
  }
  return result;
}

OZChannel *OZChannel::installPrototypeCurveInterface(OZChannel *this)
{
  OZChannel *v1;
  OZChannelImpl *var14;
  uint64_t v3;

  if (this->var18)
  {
    v1 = this;
    var14 = this->var14;
    if (var14 && *((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      v1->var14 = var14;
    }
    v3 = *((_QWORD *)var14 + 1);
    if (v3)
    {
      (*(void (**)(_QWORD))(*(_QWORD *)v3 + 8))(*((_QWORD *)var14 + 1));
      var14 = v1->var14;
    }
    *((_QWORD *)var14 + 1) = 0;
    this = (OZChannel *)(*(uint64_t (**)(OZCurve *))(*(_QWORD *)v1->var18 + 1224))(v1->var18);
    *((_QWORD *)v1->var14 + 1) = this;
    this[1].var0 = (void **)&v1->var0;
  }
  return this;
}

OZChannelInfo *OZChannelInfo::createLocalCopy(OZChannelInfo *this)
{
  OZChannelInfo *v2;

  v2 = (OZChannelInfo *)operator new();
  OZChannelInfo::OZChannelInfo(v2, this);
  return v2;
}

void sub_1B2C1F0D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C403099BD59);
  _Unwind_Resume(a1);
}

uint64_t OZChannel::clone(OZChannel *this)
{
  return 0;
}

void OZChannel::copy(OZChannel *this, const OZChannelBase *a2, char a3)
{
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  OZChannelInfo *var16;
  OZChannelInfo *v9;
  OZChannelImpl *var14;
  uint64_t v11;
  BOOL shouldKeepLocalCopy;
  OZChannelImpl *v13;

  if ((a3 & 1) == 0)
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
  OZChannelBase::copy((OZChannelBase *)this, a2);
  if (!a2)
    return;
  if (!v5)
    return;
  v6 = v5;
  v7 = v5[16];
  var16 = this->var16;
  if (*(_BYTE *)(v7 + 72))
  {
    if (var16 && !*((_BYTE *)var16 + 72))
    {
      (*(void (**)(OZChannelInfo *))(*(_QWORD *)var16 + 8))(var16);
      this->var16 = 0;
      v7 = v6[16];
    }
    this->var16 = (OZChannelInfo *)v7;
  }
  else if (var16 && !*((_BYTE *)var16 + 72))
  {
    OZChannelInfo::operator=((uint64_t)var16, v7);
  }
  else
  {
    v9 = (OZChannelInfo *)operator new();
    OZChannelInfo::OZChannelInfo(v9, (const OZChannelInfo *)v6[16]);
    this->var16 = v9;
  }
  var14 = this->var14;
  v11 = v6[14];
  if (!var14)
  {
    if (v11)
    {
      if (!*(_BYTE *)(v11 + 32))
      {
LABEL_22:
        v13 = (OZChannelImpl *)operator new();
        OZChannelImpl::OZChannelImpl(v13, (const OZChannelImpl *)v6[14]);
        this->var14 = v13;
        return;
      }
      goto LABEL_29;
    }
LABEL_25:
    this->var14 = 0;
    return;
  }
  if (!v11)
  {
    if (!*((_BYTE *)var14 + 32))
    {
      (*(void (**)(OZChannelImpl *))(*(_QWORD *)var14 + 8))(var14);
      this->var14 = 0;
    }
    goto LABEL_25;
  }
  if (*(_BYTE *)(v11 + 32))
  {
    shouldKeepLocalCopy = OZChannelImpl::shouldKeepLocalCopy(var14);
    var14 = this->var14;
    if (!shouldKeepLocalCopy)
    {
      if (!*((_BYTE *)var14 + 32))
      {
        (*(void (**)(OZChannelImpl *))(*(_QWORD *)var14 + 8))(var14);
        this->var14 = 0;
      }
      v11 = v6[14];
LABEL_29:
      this->var14 = (OZChannelImpl *)v11;
      return;
    }
  }
  if (*((_BYTE *)var14 + 32))
    goto LABEL_22;
  OZChannelImpl::operator=(var14, v6[14]);
}

void sub_1B2C1F2D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C407F0BD61ELL);
  _Unwind_Resume(a1);
}

uint64_t OZChannel::compare(OZChannel *this, const OZChannelBase *lpsrc)
{
  _QWORD *v3;
  _QWORD *v4;
  OZChannelImpl *var14;
  uint64_t v6;

  if (lpsrc
  {
    return OZChannelImpl::operator==((uint64_t)var14, v6);
  }
  else
  {
    return 0;
  }
}

void OZChannel::assign(OZChannel *this, const OZChannelBase *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  OZChannelImpl *var14;
  uint64_t LocalCopy;
  BOOL shouldKeepLocalCopy;
  double v9;
  double v10;

  if (!(*((unsigned int (**)(OZChannel *))this->var0 + 33))(this))
    return;
  (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
  OZChannelBase::assign((OZChannelBase *)this, a2);
  if (!a2)
    return;
  if (!v4)
    return;
  v5 = v4;
  var14 = this->var14;
  LocalCopy = v5[14];
  if (var14)
  {
    if (LocalCopy)
    {
      if (*(_BYTE *)(LocalCopy + 32)
        && (shouldKeepLocalCopy = OZChannelImpl::shouldKeepLocalCopy(var14), var14 = this->var14, !shouldKeepLocalCopy))
      {
        if (!*((_BYTE *)var14 + 32))
        {
          (*(void (**)(OZChannelImpl *))(*(_QWORD *)var14 + 8))(var14);
          this->var14 = 0;
        }
        LocalCopy = v5[14];
        this->var14 = (OZChannelImpl *)LocalCopy;
      }
      else
      {
        if (*((_BYTE *)var14 + 32))
          goto LABEL_12;
        OZChannelImpl::operator=(var14, v5[14]);
        LocalCopy = (uint64_t)this->var14;
      }
      if (!LocalCopy)
        return;
      goto LABEL_22;
    }
    if (!*((_BYTE *)var14 + 32))
    {
      (*(void (**)(OZChannelImpl *))(*(_QWORD *)var14 + 8))(var14);
      this->var14 = 0;
    }
LABEL_16:
    this->var14 = 0;
    return;
  }
  if (!LocalCopy)
    goto LABEL_16;
  if (!*(_BYTE *)(LocalCopy + 32))
  {
LABEL_12:
    LocalCopy = operator new();
    OZChannelImpl::OZChannelImpl((OZChannelImpl *)LocalCopy, (const OZChannelImpl *)v5[14]);
  }
  this->var14 = (OZChannelImpl *)LocalCopy;
LABEL_22:
  v9 = *((double *)this->var16 + 5);
  v10 = *(double *)(v5[16] + 40);
  if (vabdd_f64(v9, v10) >= 0.0000001)
  {
    if (*(_BYTE *)(LocalCopy + 32))
    {
      LocalCopy = (uint64_t)OZChannelImpl::createLocalCopy((OZChannelImpl *)LocalCopy);
      this->var14 = (OZChannelImpl *)LocalCopy;
      v10 = *(double *)(v5[16] + 40);
      v9 = *((double *)this->var16 + 5);
    }
    (*(void (**)(_QWORD, double))(**(_QWORD **)(LocalCopy + 8) + 448))(*(_QWORD *)(LocalCopy + 8), v10 / v9);
  }
}

void sub_1B2C1F54C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C407F0BD61ELL);
  _Unwind_Resume(a1);
}

uint64_t OZChannel::allowsAssignment(OZChannel *this, const OZChannelBase *lpsrc)
{
  uint64_t result;
  double v5;
  double v6;
  double v7;

  if (!lpsrc)
    return 0;
  if (result)
  {
    result = OZChannelBase::allowsAssignment((OZChannelBase *)this, lpsrc);
    if ((_DWORD)result)
    {
      if (!(*((unsigned int (**)(const OZChannelBase *, _QWORD))lpsrc->var0 + 69))(lpsrc, 0)
        || (result = (*((uint64_t (**)(OZChannel *))this->var0 + 64))(this), (_DWORD)result))
      {
        v7 = 0.0;
        (*(void (**)(_QWORD, double *))(**((_QWORD **)this->var14 + 1) + 264))(*((_QWORD *)this->var14 + 1), &v7);
        v5 = v7;
        if (v7 <= -3.40282347e38
          || (v7 = 0.0,
              (*(void (**)(_QWORD, double *, _QWORD))(**((_QWORD **)this->var14 + 1) + 248))(*((_QWORD *)this->var14 + 1), &v7, 0), result = 0, v7 >= v5))
        {
          v7 = 0.0;
          (*(void (**)(_QWORD, double *))(**((_QWORD **)this->var14 + 1) + 256))(*((_QWORD *)this->var14 + 1), &v7);
          v6 = v7;
          if (v7 >= 3.40282347e38)
            return 1;
          v7 = 0.0;
          (*(void (**)(_QWORD, double *, _QWORD))(**((_QWORD **)this->var14 + 1) + 248))(*((_QWORD *)this->var14 + 1), &v7, 0);
          result = 0;
          if (v7 <= v6)
            return 1;
        }
      }
    }
  }
  return result;
}

uint64_t OZChannel::lock(OZChannel *this, int a2)
{
  uint64_t result;

  (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 2);
  result = OZChannelBase::lock((OZChannelBase *)this, a2);
  if ((a2 & 1) == 0)
  {
    result = (*((uint64_t (**)(OZChannel *, _QWORD))this->var0 + 69))(this, 0);
    if ((_DWORD)result)
      return (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this->var14 + 1) + 96))(*((_QWORD *)this->var14 + 1), 0);
  }
  return result;
}

uint64_t OZChannel::lockFromParent(OZChannel *this)
{
  return (*((uint64_t (**)(OZChannel *))this->var0 + 12))(this);
}

OZChannelBase *OZChannel::willBeModified(OZChannel *this, uint64_t a2)
{
  uint64_t v2;
  OZChannelFolder *var6;

  v2 = a2;
  if ((a2 & 1) != 0
    && (!(*((unsigned int (**)(OZChannel *))this->var0 + 64))(this)
     || ((*((uint64_t (**)(OZChannel *))this->var0 + 61))(this) & 1) == 0))
  {
    v2 = 2;
  }
  var6 = this->var6;
  if (var6 && (*(unsigned int (**)(OZChannelFolder *))(*(_QWORD *)var6 + 120))(var6))
    OZChannelBase::willBeModified((OZChannelBase *)this->var6, v2);
  return OZChannelBase::willBeModified((OZChannelBase *)this, v2);
}

OZChannelBase *OZChannel::parentWillBeModified(OZChannel *this, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  if ((a2 & 1) != 0
    && (!(*((unsigned int (**)(OZChannel *))this->var0 + 64))(this)
     || ((*((uint64_t (**)(OZChannel *))this->var0 + 61))(this) & 1) == 0))
  {
    v2 = 2;
  }
  return OZChannelBase::willBeModified((OZChannelBase *)this, v2);
}

uint64_t OZChannel::resetToDefault(OZChannel *this, char a2)
{
  uint64_t result;
  void *v5;
  OZChannelImpl *var14;
  uint64_t v7;

  result = (uint64_t)this->var6;
  if (result
    && (result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 120))(result), (_DWORD)result)
    && (result = OZChannelFolder::testFoldFlag(this->var6, 0x100000), (_DWORD)result))
  {
    return (*(uint64_t (**)(void *, OZChannel *, _QWORD))(*(_QWORD *)v5 + 776))(v5, this, 0);
  }
  else
  {
    if ((a2 & 1) == 0)
      result = (*((uint64_t (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    var14 = this->var14;
    if (!*((_BYTE *)var14 + 32))
    {
      v7 = *((_QWORD *)var14 + 2);
      if (v7)
      {
        MEMORY[0x1B5E29170](v7, 0x1000C4021716A34);
        var14 = this->var14;
        *((_QWORD *)var14 + 2) = 0;
      }
      (*(void (**)(_QWORD))(**((_QWORD **)var14 + 1) + 184))(*((_QWORD *)var14 + 1));
      return OZChannel::resetLocalChannelImplementation(this);
    }
  }
  return result;
}

const __CFString *OZChannel::getObjCWrapperName(OZChannel *this)
{
  return CFSTR("CHChannel");
}

uint64_t OZChannel::writeHeader(OZChannel *this, OZFactory *a2, int a3)
{
  uint64_t result;
  OZChannelImpl *var14;
  __int128 *v8;
  __int128 v9;
  CMTime *v10;
  double v11;
  double v12;
  int v13;
  CMTime time2;
  CMTime time1;

  if (!OZChannelBase::testFlag((OZChannelBase *)this, 128)
    || (result = (*(uint64_t (**)(OZFactory *))(*(_QWORD *)a2 + 232))(a2), (result & 1) == 0))
  {
    if (a3)
      return OZChannelBase::writeHeader((OZChannelBase *)this, a2, 1);
    v13 = 0;
    v11 = 0.0;
    v12 = 0.0;
    (*(void (**)(_QWORD, int *))(**((_QWORD **)this->var14 + 1) + 152))(*((_QWORD *)this->var14 + 1), &v13);
    if (v13
      && (v13 != 1
       || (*(unsigned int (**)(_QWORD))(**((_QWORD **)this->var14 + 1) + 512))(*((_QWORD *)this->var14 + 1))))
    {
      return OZChannelBase::writeHeader((OZChannelBase *)this, a2, 0);
    }
    var14 = this->var14;
    v8 = (__int128 *)*((_QWORD *)var14 + 2);
    if (v8)
    {
      v9 = *v8;
      time1.epoch = *((_QWORD *)v8 + 2);
      *(_OWORD *)&time1.value = v9;
      v10 = (CMTime *)MEMORY[0x1E0CA2E68];
      time2 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
      if (CMTimeCompare(&time1, &time2))
        return OZChannelBase::writeHeader((OZChannelBase *)this, a2, 0);
      time1 = *(CMTime *)(*((_QWORD *)this->var14 + 2) + 24);
      time2 = *v10;
      if (CMTimeCompare(&time1, &time2))
        return OZChannelBase::writeHeader((OZChannelBase *)this, a2, 0);
      var14 = this->var14;
    }
    (*(void (**)(_QWORD, double *))(**((_QWORD **)var14 + 1) + 208))(*((_QWORD *)var14 + 1), &v12);
    (*(void (**)(_QWORD, double *))(**((_QWORD **)this->var14 + 1) + 192))(*((_QWORD *)this->var14 + 1), &v11);
    TXSequenceChannels::pushChannelIntoChannelList((TXSequenceChannels *)a2, (OZChannelBase *)&OZChannelScope);
    (*(void (**)(OZFactory *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 110);
    (*(void (**)(OZFactory *, uint64_t, PCString *))(*(_QWORD *)a2 + 216))(a2, 110, &this->var4);
    (*(void (**)(OZFactory *, uint64_t, _QWORD))(*(_QWORD *)a2 + 144))(a2, 111, this->var3);
    OZChannelBase::writeFlags((uint64_t)this, (TXSequenceChannels *)a2, 0);
    if (((*(uint64_t (**)(OZFactory *))(*(_QWORD *)a2 + 232))(a2) & 1) == 0)
      (*(void (**)(OZFactory *, uint64_t, double))(*(_QWORD *)a2 + 184))(a2, 115, v11);
    (*(void (**)(OZFactory *, uint64_t, double))(*(_QWORD *)a2 + 184))(a2, 114, v12);
    return PCSerializerWriteStream::popScope((uint64_t)a2);
  }
  return result;
}

uint64_t `non-virtual thunk to'OZChannel::writeHeader(OZChannel *this, OZFactory *a2, int a3)
{
  return OZChannel::writeHeader((OZChannel *)((char *)this - 16), a2, a3);
}

uint64_t OZChannel::writeBody(OZChannel *this, PCSerializerWriteStream *a2, int a3)
{
  uint64_t result;
  OZChannelImpl *var14;
  __int128 *v8;
  CMTime *v9;
  __int128 v10;
  int32_t v11;
  __int128 *v12;
  __int128 v13;
  CMTime *v14;
  int32_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 *v21;
  __int128 v22;
  int v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  CMTime time2;
  CMTime time1;

  if (!OZChannelBase::testFlag((OZChannelBase *)this, 128)
    || (result = (*(uint64_t (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 232))(a2), (result & 1) == 0))
  {
    TXSequenceChannels::pushChannelIntoChannelList(a2, (OZChannelBase *)&OZChannelScope);
    OZChannelBase::writeBody((OZChannelBase *)this, a2, a3);
    var14 = this->var14;
    v8 = (__int128 *)*((_QWORD *)var14 + 2);
    v9 = (CMTime *)MEMORY[0x1E0CA2E68];
    if (v8)
    {
      v10 = *v8;
      time1.epoch = *((_QWORD *)v8 + 2);
      *(_OWORD *)&time1.value = v10;
      time2 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
      v11 = CMTimeCompare(&time1, &time2);
      var14 = this->var14;
      if (v11)
      {
        v12 = (__int128 *)*((_QWORD *)var14 + 2);
        v13 = *v12;
        v27 = *((_QWORD *)v12 + 2);
        v26 = v13;
        (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 119);
        (*(void (**)(PCSerializerWriteStream *, __int128 *))(*(_QWORD *)a2 + 112))(a2, &v26);
        (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
        var14 = this->var14;
      }
    }
    v14 = (CMTime *)*((_QWORD *)var14 + 2);
    if (v14)
    {
      time1 = v14[1];
      time2 = *v9;
      v15 = CMTimeCompare(&time1, &time2);
      var14 = this->var14;
      if (v15)
      {
        v16 = *((_QWORD *)var14 + 2);
        v25 = *(_QWORD *)(v16 + 40);
        v24 = *(_OWORD *)(v16 + 24);
        (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 120);
        (*(void (**)(PCSerializerWriteStream *, __int128 *))(*(_QWORD *)a2 + 112))(a2, &v24);
        (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
        var14 = this->var14;
      }
    }
    v17 = *((_QWORD *)var14 + 2);
    if (v17)
    {
      v18 = *(unsigned int *)(v17 + 48);
      if (!(_DWORD)v18
        || ((*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 130),
            (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 56))(a2, v18),
            (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2),
            var14 = this->var14,
            (v17 = *((_QWORD *)var14 + 2)) != 0))
      {
        v19 = *(unsigned int *)(v17 + 52);
        if ((_DWORD)v19)
        {
          (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 131);
          (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 56))(a2, v19);
          (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
          var14 = this->var14;
        }
      }
    }
    v23 = 0;
    (*(void (**)(_QWORD, int *))(**((_QWORD **)var14 + 1) + 152))(*((_QWORD *)var14 + 1), &v23);
    if ((a3 & 1) != 0
      || (*(unsigned int (**)(_QWORD))(**((_QWORD **)this->var14 + 1) + 512))(*((_QWORD *)this->var14 + 1))
      || (v21 = (__int128 *)*((_QWORD *)this->var14 + 2)) != 0
      && ((v22 = *v21,
           time1.epoch = *((_QWORD *)v21 + 2),
           *(_OWORD *)&time1.value = v22,
           time2 = *v9,
           CMTimeCompare(&time1, &time2))
       || (time1 = *(CMTime *)(*((_QWORD *)this->var14 + 2) + 24), time2 = *v9, CMTimeCompare(&time1, &time2))))
    {
      v20 = *((_QWORD *)this->var14 + 1);
      (*(void (**)(uint64_t, PCSerializerWriteStream *, _QWORD))(*(_QWORD *)v20 + 16))(v20, a2, 0);
      (*(void (**)(uint64_t, PCSerializerWriteStream *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)v20 + 24))(v20, a2, 0, 1, 1);
      (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
    }
    return PCSerializerWriteStream::popScope((uint64_t)a2);
  }
  return result;
}

uint64_t `non-virtual thunk to'OZChannel::writeBody(OZChannel *this, PCSerializerWriteStream *a2, int a3)
{
  return OZChannel::writeBody((OZChannel *)((char *)this - 16), a2, a3);
}

uint64_t OZChannel::parseBegin(OZChannel *this, PCSerializerReadStream *a2)
{
  OZChannelImpl *var14;
  uint64_t v5;

  OZChannelBase::parseBegin((OZChannelBase *)this, a2);
  PCSerializerReadStream::pushScope(a2, (uint64_t)&OZChannelScope);
  (*(void (**)(_QWORD, PCSerializerReadStream *))(**((_QWORD **)this->var14 + 1) + 40))(*((_QWORD *)this->var14 + 1), a2);
  var14 = this->var14;
  if (!*((_BYTE *)var14 + 32))
  {
    v5 = *((_QWORD *)var14 + 2);
    if (v5)
    {
      MEMORY[0x1B5E29170](v5, 0x1000C4021716A34);
      *((_QWORD *)this->var14 + 2) = 0;
    }
  }
  return 1;
}

uint64_t `non-virtual thunk to'OZChannel::parseBegin(OZChannel *this, PCSerializerReadStream *a2)
{
  OZChannel::parseBegin((OZChannel *)((char *)this - 16), a2);
  return 1;
}

uint64_t OZChannel::parseEnd(OZChannel *this, PCSerializerReadStream *a2)
{
  OZChannelBase::parseEnd((OZChannelBase *)this, a2);
  (*(void (**)(_QWORD, PCSerializerReadStream *))(**((_QWORD **)this->var14 + 1) + 48))(*((_QWORD *)this->var14 + 1), a2);
  OZChannel::resetLocalChannelImplementation(this);
  return 1;
}

uint64_t `non-virtual thunk to'OZChannel::parseEnd(OZChannel *this, PCSerializerReadStream *a2)
{
  OZChannel *v4;

  v4 = (OZChannel *)((char *)this - 16);
  OZChannelBase::parseEnd((OZChannelBase *)&this[-1].var17, a2);
  (*(void (**)(uint64_t, PCSerializerReadStream *))(*(_QWORD *)this->var12->info + 48))(this->var12->info, a2);
  OZChannel::resetLocalChannelImplementation(v4);
  return 1;
}

uint64_t OZChannel::parseElement(OZChannel *this, PCSerializerReadStream *a2, PCStreamElement *a3)
{
  int v6;
  int v7;
  int v8;
  OZChannelImpl *var14;
  unsigned int v11;
  CMTime v12;

  OZChannelBase::parseElement((OZChannelBase *)this, a2, a3);
  v11 = 0;
  v6 = *((_DWORD *)a3 + 2);
  if (v6 <= 119)
  {
    if (v6 == 118)
    {
      var14 = this->var14;
      if (*((_BYTE *)var14 + 32))
      {
        var14 = OZChannelImpl::createLocalCopy(var14);
        this->var14 = var14;
      }
      PCSerializerReadStream::pushHandler(a2, *((PCSerializer **)var14 + 1));
      (*(void (**)(_QWORD, PCSerializerReadStream *, PCStreamElement *))(**((_QWORD **)this->var14 + 1) + 56))(*((_QWORD *)this->var14 + 1), a2, a3);
    }
    else if (v6 == 119)
    {
      (*(void (**)(PCStreamElement *, CMTime *))(*(_QWORD *)a3 + 88))(a3, &v12);
      OZChannel::setFadeInOffset(this, &v12, 0);
    }
  }
  else
  {
    switch(v6)
    {
      case 120:
        (*(void (**)(PCStreamElement *, CMTime *))(*(_QWORD *)a3 + 88))(a3, &v12);
        OZChannel::setFadeOutOffset(this, &v12, 0);
        break;
      case 130:
        (*(void (**)(PCStreamElement *, unsigned int *))(*(_QWORD *)a3 + 32))(a3, &v11);
        v8 = v11;
        if (v11 >= 4)
        {
          v8 = 0;
          v11 = 0;
        }
        OZChannel::setFadeInCurve(this, v8);
        break;
      case 131:
        (*(void (**)(PCStreamElement *, unsigned int *))(*(_QWORD *)a3 + 32))(a3, &v11);
        v7 = v11;
        if (v11 >= 4)
        {
          v7 = 0;
          v11 = 0;
        }
        OZChannel::setFadeOutCurve(this, v7);
        break;
    }
  }
  return 1;
}

__n128 OZChannel::setFadeInOffset(OZChannel *this, const CMTime *a2, int a3)
{
  __n128 result;
  CMTime *v7;
  int32_t v8;
  OZChannelImpl *var14;
  uint64_t v10;
  __int128 v11;
  CMTimeEpoch epoch;
  OZChannelBase *AncestorRootBase;
  OZChannelBase *v14;
  CMTime *v15;
  CMTime *v16;
  __n128 *v17;
  CMTime v18;
  CMTime v19;
  CMTime v20;
  CMTime v21;
  CMTime time1;
  CMTime v23;
  CMTime v24;
  CMTime v25;
  CMTime v26;
  CMTime time2;

  if ((OZChannelBase::isLocked((OZChannelBase *)this, 0) & 1) == 0)
  {
    v7 = (CMTime *)MEMORY[0x1E0CA2E68];
    if (!*((_QWORD *)this->var14 + 2))
    {
      time1 = *a2;
      time2 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
      v8 = CMTimeCompare(&time1, &time2);
      var14 = this->var14;
      if (v8 < 1)
      {
        if (!*((_QWORD *)var14 + 2))
          return result;
      }
      else
      {
        if (var14 && *((_BYTE *)var14 + 32))
          this->var14 = OZChannelImpl::createLocalCopy(var14);
        v10 = operator new();
        v11 = *(_OWORD *)&v7->value;
        *(_OWORD *)v10 = *(_OWORD *)&v7->value;
        epoch = v7->epoch;
        *(_QWORD *)(v10 + 16) = epoch;
        *(_OWORD *)(v10 + 24) = v11;
        *(_QWORD *)(v10 + 40) = epoch;
        *(_QWORD *)(v10 + 48) = 0;
        *((_QWORD *)this->var14 + 2) = v10;
      }
    }
    v24 = *a2;
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    time1 = v24;
    time2 = *v7;
    if (CMTimeCompare(&time1, &time2) < 0)
      v24 = *v7;
    AncestorRootBase = OZChannelBase::getAncestorRootBase((OZChannelBase *)this);
    if (AncestorRootBase && a3)
    {
      v14 = AncestorRootBase;
      (*((void (**)(CMTime *__return_ptr, OZChannelBase *, OZChannel *))AncestorRootBase->var0 + 90))(&time1, AncestorRootBase, this);
      memset(&v21, 0, sizeof(v21));
      (*((void (**)(CMTime *__return_ptr, OZChannelBase *))v14->var0 + 110))(&v21, v14);
      memset(&v20, 0, sizeof(v20));
      time2 = time1;
      v26 = v23;
      PC_CMTimeSaferAdd(&time2, &v26, (uint64_t)&v25);
      time2 = v25;
      v26 = v21;
      PC_CMTimeSaferSubtract(&time2, &v26, (uint64_t)&v20);
      v25 = time1;
      time2 = v24;
      v26 = time1;
      PC_CMTimeSaferAdd(&time2, &v26, (uint64_t)&v19);
      v15 = (CMTime *)*((_QWORD *)this->var14 + 2);
      time2 = v20;
      v26 = v15[1];
      PC_CMTimeSaferSubtract(&time2, &v26, (uint64_t)&v18);
      time2 = v19;
      v26 = v18;
      if (CMTimeCompare(&time2, &v26) >= 1)
      {
        v16 = (CMTime *)*((_QWORD *)this->var14 + 2);
        time2 = v20;
        v26 = v16[1];
        PC_CMTimeSaferSubtract(&time2, &v26, (uint64_t)&v19);
        time2 = v19;
        v26 = v25;
        PC_CMTimeSaferSubtract(&time2, &v26, (uint64_t)&v24);
      }
    }
    v17 = (__n128 *)*((_QWORD *)this->var14 + 2);
    result = *(__n128 *)&v24.value;
    v17[1].n128_u64[0] = v24.epoch;
    *v17 = result;
  }
  return result;
}

double OZChannel::setFadeOutOffset(OZChannel *this, const CMTime *a2, int a3)
{
  double result;
  CMTime *v7;
  int32_t v8;
  OZChannelImpl *var14;
  uint64_t v10;
  __int128 v11;
  CMTimeEpoch epoch;
  OZChannelBase *AncestorRootBase;
  OZChannelBase *v14;
  __int128 *v15;
  __int128 v16;
  __int128 *v17;
  __int128 v18;
  CMTime v19;
  CMTime v20;
  CMTime v21;
  CMTime v22;
  CMTime time1;
  CMTime v24;
  CMTime v25;
  CMTime v26;
  CMTime v27;
  CMTime time2;

  if ((OZChannelBase::isLocked((OZChannelBase *)this, 0) & 1) == 0)
  {
    v7 = (CMTime *)MEMORY[0x1E0CA2E68];
    if (!*((_QWORD *)this->var14 + 2))
    {
      time1 = *a2;
      time2 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
      v8 = CMTimeCompare(&time1, &time2);
      var14 = this->var14;
      if (v8 < 1)
      {
        if (!*((_QWORD *)var14 + 2))
          return result;
      }
      else
      {
        if (var14 && *((_BYTE *)var14 + 32))
          this->var14 = OZChannelImpl::createLocalCopy(var14);
        v10 = operator new();
        v11 = *(_OWORD *)&v7->value;
        *(_OWORD *)v10 = *(_OWORD *)&v7->value;
        epoch = v7->epoch;
        *(_QWORD *)(v10 + 16) = epoch;
        *(_OWORD *)(v10 + 24) = v11;
        *(_QWORD *)(v10 + 40) = epoch;
        *(_QWORD *)(v10 + 48) = 0;
        *((_QWORD *)this->var14 + 2) = v10;
      }
    }
    v25 = *a2;
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    time1 = v25;
    time2 = *v7;
    if (CMTimeCompare(&time1, &time2) < 0)
      v25 = *v7;
    AncestorRootBase = OZChannelBase::getAncestorRootBase((OZChannelBase *)this);
    if (AncestorRootBase && a3)
    {
      v14 = AncestorRootBase;
      (*((void (**)(CMTime *__return_ptr, OZChannelBase *, OZChannel *))AncestorRootBase->var0 + 90))(&time1, AncestorRootBase, this);
      memset(&v22, 0, sizeof(v22));
      (*((void (**)(CMTime *__return_ptr, OZChannelBase *))v14->var0 + 110))(&v22, v14);
      memset(&v21, 0, sizeof(v21));
      time2 = time1;
      v27 = v24;
      PC_CMTimeSaferAdd(&time2, &v27, (uint64_t)&v26);
      time2 = v26;
      v27 = v22;
      PC_CMTimeSaferSubtract(&time2, &v27, (uint64_t)&v21);
      v26 = time1;
      time2 = v21;
      v27 = v25;
      PC_CMTimeSaferSubtract(&time2, &v27, (uint64_t)&v20);
      time2 = v20;
      v27 = v26;
      if (CMTimeCompare(&time2, &v27) < 0)
      {
        time2 = v21;
        v27 = v26;
        PC_CMTimeSaferSubtract(&time2, &v27, (uint64_t)&v25);
      }
      time2 = v21;
      v27 = v25;
      PC_CMTimeSaferSubtract(&time2, &v27, (uint64_t)&v20);
      v15 = (__int128 *)*((_QWORD *)this->var14 + 2);
      v16 = *v15;
      time2.epoch = *((_QWORD *)v15 + 2);
      *(_OWORD *)&time2.value = v16;
      v27 = v26;
      PC_CMTimeSaferAdd(&time2, &v27, (uint64_t)&v19);
      time2 = v20;
      v27 = v19;
      if (CMTimeCompare(&time2, &v27) < 0)
      {
        v17 = (__int128 *)*((_QWORD *)this->var14 + 2);
        v18 = *v17;
        time2.epoch = *((_QWORD *)v17 + 2);
        *(_OWORD *)&time2.value = v18;
        v27 = v26;
        PC_CMTimeSaferAdd(&time2, &v27, (uint64_t)&v19);
        time2 = v21;
        v27 = v19;
        PC_CMTimeSaferSubtract(&time2, &v27, (uint64_t)&v20);
        v25 = v20;
      }
    }
    result = *(double *)&v25.value;
    *(CMTime *)(*((_QWORD *)this->var14 + 2) + 24) = v25;
  }
  return result;
}

uint64_t OZChannel::setFadeInCurve(OZChannel *this, int a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    result = (uint64_t)this->var14;
    v5 = *(_QWORD *)(result + 16);
    if (!a2 || v5)
    {
      if (!v5)
        return result;
    }
    else
    {
      if (*(_BYTE *)(result + 32))
        this->var14 = OZChannelImpl::createLocalCopy((OZChannelImpl *)result);
      v6 = operator new();
      v7 = MEMORY[0x1E0CA2E68];
      v8 = *MEMORY[0x1E0CA2E68];
      *(_OWORD *)v6 = *MEMORY[0x1E0CA2E68];
      v9 = *(_QWORD *)(v7 + 16);
      *(_QWORD *)(v6 + 16) = v9;
      *(_OWORD *)(v6 + 24) = v8;
      *(_QWORD *)(v6 + 40) = v9;
      *(_QWORD *)(v6 + 48) = 0;
      *((_QWORD *)this->var14 + 2) = v6;
    }
    result = (*((uint64_t (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    *(_DWORD *)(*((_QWORD *)this->var14 + 2) + 48) = a2;
  }
  return result;
}

uint64_t OZChannel::setFadeOutCurve(OZChannel *this, int a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    result = (uint64_t)this->var14;
    v5 = *(_QWORD *)(result + 16);
    if (!a2 || v5)
    {
      if (!v5)
        return result;
    }
    else
    {
      if (*(_BYTE *)(result + 32))
        this->var14 = OZChannelImpl::createLocalCopy((OZChannelImpl *)result);
      v6 = operator new();
      v7 = MEMORY[0x1E0CA2E68];
      v8 = *MEMORY[0x1E0CA2E68];
      *(_OWORD *)v6 = *MEMORY[0x1E0CA2E68];
      v9 = *(_QWORD *)(v7 + 16);
      *(_QWORD *)(v6 + 16) = v9;
      *(_OWORD *)(v6 + 24) = v8;
      *(_QWORD *)(v6 + 40) = v9;
      *(_QWORD *)(v6 + 48) = 0;
      *((_QWORD *)this->var14 + 2) = v6;
    }
    result = (*((uint64_t (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    *(_DWORD *)(*((_QWORD *)this->var14 + 2) + 52) = a2;
  }
  return result;
}

uint64_t `non-virtual thunk to'OZChannel::parseElement(OZChannel *this, PCSerializerReadStream *a2, PCStreamElement *a3)
{
  OZChannel::parseElement((OZChannel *)((char *)this - 16), a2, a3);
  return 1;
}

uint64_t OZChannel::calcHashForState(OZChannel *this, PCSerializerWriteStream *a2, const CMTime *a3)
{
  uint64_t result;
  double v7;
  double v8;
  __int128 *v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;

  result = OZChannelBase::testFlag((OZChannelBase *)this, 128);
  if ((result & 1) == 0)
  {
    OZChannelBase::calcHashForState((OZChannelBase *)this, a2, a3);
    TXSequenceChannels::pushChannelIntoChannelList(a2, (OZChannelBase *)&OZChannelScope);
    OZChannel::getValueAsDouble(this, a3, 0.0);
    v8 = v7;
    (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 110);
    (*(void (**)(PCSerializerWriteStream *, double))(*(_QWORD *)a2 + 88))(a2, v8);
    (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
    v9 = (__int128 *)*((_QWORD *)this->var14 + 2);
    if (v9)
    {
      v10 = *v9;
      v17 = *((_QWORD *)v9 + 2);
      v16 = v10;
      (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 119);
      (*(void (**)(PCSerializerWriteStream *, __int128 *))(*(_QWORD *)a2 + 112))(a2, &v16);
      (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
      v11 = *((_QWORD *)this->var14 + 2);
      v15 = *(_QWORD *)(v11 + 40);
      v14 = *(_OWORD *)(v11 + 24);
      (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 120);
      (*(void (**)(PCSerializerWriteStream *, __int128 *))(*(_QWORD *)a2 + 112))(a2, &v14);
      (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
      v12 = *(unsigned int *)(*((_QWORD *)this->var14 + 2) + 48);
      (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 130);
      (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 56))(a2, v12);
      (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
      v13 = *(unsigned int *)(*((_QWORD *)this->var14 + 2) + 52);
      (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 131);
      (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 56))(a2, v13);
      (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
    }
    return PCSerializerWriteStream::popScope((uint64_t)a2);
  }
  return result;
}

void OZChannel::getValueAsDouble(OZChannel *this, const CMTime *a2, double a3)
{
  BOOL v6;
  BOOL v7;
  uint64_t v8;
  CMTime v9;
  int v10;
  uint64_t v11;

  v11 = 0;
  if (*((_QWORD *)this->var14 + 1))
  {
    v10 = 0;
    if (!(*((unsigned int (**)(OZChannel *))this->var0 + 104))(this)
      && ((*(unsigned int (**)(_QWORD, int *))(**((_QWORD **)this->var14 + 1) + 1152))(*((_QWORD *)this->var14 + 1), &v10)? (v6 = v10 == 0): (v6 = 0), v6))
    {
      (*(void (**)(_QWORD, uint64_t *))(**((_QWORD **)this->var14 + 1) + 208))(*((_QWORD *)this->var14 + 1), &v11);
    }
    else
    {
      v7 = OZChannelBase::testFlag((OZChannelBase *)this, 0x80000000);
      v8 = *((_QWORD *)this->var14 + 1);
      if (v7)
      {
        (*((void (**)(CMTime *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(&v9, this, a2);
        (*(void (**)(uint64_t, CMTime *, uint64_t *, double))(*(_QWORD *)v8 + 624))(v8, &v9, &v11, a3);
      }
      else
      {
        (*((void (**)(CMTime *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(&v9, this, a2);
        (*(void (**)(uint64_t, CMTime *, uint64_t *, double))(*(_QWORD *)v8 + 616))(v8, &v9, &v11, a3);
      }
    }
    if ((*((unsigned int (**)(OZChannel *))this->var0 + 83))(this))
    {
      if (!OZChannelBase::testFlag((OZChannelBase *)this, 0x800000000))
      {
        (*((void (**)(CMTime *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(&v9, this, a2);
        OZChannel::getFadeRatio(this, &v9);
      }
    }
  }
}

__n128 OZChannel::getFadeInOffset@<Q0>(OZChannel *this@<X0>, __n128 *a2@<X8>)
{
  __n128 *v2;
  __n128 result;

  v2 = (__n128 *)*((_QWORD *)this->var14 + 2);
  if (!v2)
    v2 = (__n128 *)MEMORY[0x1E0CA2E68];
  result = *v2;
  *a2 = *v2;
  a2[1].n128_u64[0] = v2[1].n128_u64[0];
  return result;
}

OZChannel *OZChannel::getFadeOutOffset@<X0>(OZChannel *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this->var14 + 2);
  if (v2)
  {
    *(_OWORD *)a2 = *(_OWORD *)(v2 + 24);
    v3 = *(_QWORD *)(v2 + 40);
  }
  else
  {
    v4 = MEMORY[0x1E0CA2E68];
    *(_OWORD *)a2 = *MEMORY[0x1E0CA2E68];
    v3 = *(_QWORD *)(v4 + 16);
  }
  *(_QWORD *)(a2 + 16) = v3;
  return this;
}

uint64_t OZChannel::getFadeInCurve(OZChannel *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this->var14 + 2);
  if (v1)
    return *(unsigned int *)(v1 + 48);
  else
    return 0;
}

uint64_t OZChannel::getFadeOutCurve(OZChannel *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this->var14 + 2);
  if (v1)
    return *(unsigned int *)(v1 + 52);
  else
    return 0;
}

double OZChannel::getFadeRatio(OZChannel *this, const CMTime *a2)
{
  OZChannelBase *AncestorRootBase;
  int v5;
  __n128 v6;
  BOOL v7;
  OZChannelTimeConverter *var13;
  __int128 *v9;
  __int128 v10;
  CMTime *v11;
  uint64_t v12;
  CMTimeEpoch v13;
  CMTime *v14;
  double Seconds;
  int *v16;
  int v17;
  double v18;
  BOOL v19;
  CMTime time;
  CMTime v22;
  CMTime v23;
  CMTime v24;
  CMTime v25[2];
  CMTime v26;
  CMTime v27;
  CMTime time2;
  CMTime time1;

  AncestorRootBase = OZChannelBase::getAncestorRootBase((OZChannelBase *)this);
  v5 = (*((uint64_t (**)(OZChannel *))this->var0 + 83))(this);
  v6.n128_u64[0] = 1.0;
  if (v5)
    v7 = AncestorRootBase == 0;
  else
    v7 = 1;
  if (!v7)
  {
    memset(&v26, 0, sizeof(v26));
    (*((void (**)(CMTime *__return_ptr, OZChannelBase *, __n128))AncestorRootBase->var0 + 110))(&v26, AncestorRootBase, v6);
    (*((void (**)(CMTime *__return_ptr, OZChannelBase *, OZChannel *))AncestorRootBase->var0 + 90))(v25, AncestorRootBase, this);
    memset(&v24, 0, sizeof(v24));
    time1 = v25[0];
    time2 = v25[1];
    PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v27);
    time1 = v27;
    time2 = v26;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v24);
    v27 = v25[0];
    var13 = this->var13;
    if (!var13 || ((*(uint64_t (**)(OZChannelTimeConverter *))(*(_QWORD *)var13 + 32))(var13) & 1) == 0)
    {
      (*((void (**)(CMTime *__return_ptr, OZChannel *, CMTime *))this->var0 + 41))(&time1, this, &v24);
      v24 = time1;
      (*((void (**)(CMTime *__return_ptr, OZChannel *, CMTime *))this->var0 + 41))(&time1, this, &v27);
      v27 = time1;
    }
    v9 = (__int128 *)*((_QWORD *)this->var14 + 2);
    v10 = *v9;
    time1.epoch = *((_QWORD *)v9 + 2);
    *(_OWORD *)&time1.value = v10;
    v11 = (CMTime *)MEMORY[0x1E0CA2E68];
    time2 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
    if (!CMTimeCompare(&time1, &time2))
      goto LABEL_10;
    time1 = *a2;
    time2 = v27;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v23);
    v12 = *((_QWORD *)this->var14 + 2);
    time1 = v23;
    v13 = *(_QWORD *)(v12 + 16);
    *(_OWORD *)&time2.value = *(_OWORD *)v12;
    time2.epoch = v13;
    if (CMTimeCompare(&time1, &time2) < 0)
    {
      time1 = *a2;
      time2 = v27;
      PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v23);
      operator/((__int128 *)&v23.value, *((_QWORD *)this->var14 + 2), (uint64_t)&v22);
      Seconds = CMTimeGetSeconds(&v22);
      v16 = (int *)(*((_QWORD *)this->var14 + 2) + 48);
    }
    else
    {
LABEL_10:
      time1 = *(CMTime *)(*((_QWORD *)this->var14 + 2) + 24);
      time2 = *v11;
      if (!CMTimeCompare(&time1, &time2)
        || (v14 = (CMTime *)*((_QWORD *)this->var14 + 2),
            time1 = v24,
            time2 = v14[1],
            PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v23),
            time1 = *a2,
            time2 = v23,
            CMTimeCompare(&time1, &time2) < 1))
      {
        v6.n128_u64[0] = 1.0;
        return v6.n128_f64[0];
      }
      time1 = v24;
      time2 = *a2;
      PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v23);
      operator/((__int128 *)&v23.value, *((_QWORD *)this->var14 + 2) + 24, (uint64_t)&time);
      Seconds = CMTimeGetSeconds(&time);
      v16 = (int *)(*((_QWORD *)this->var14 + 2) + 52);
    }
    v17 = *v16;
    v18 = 1.0;
    if (Seconds <= 1.0)
      v18 = Seconds;
    v19 = Seconds < 0.0;
    v6.n128_u64[0] = 0;
    if (!v19)
      v6.n128_f64[0] = v18;
    switch(v17)
    {
      case 3:
        v6.n128_f64[0] = 0.5 - cos(v6.n128_f64[0] * 3.14159265) * 0.5;
        break;
      case 2:
        v6.n128_f64[0] = sin((v6.n128_f64[0] + -1.0) * 1.57079633) + 1.0;
        break;
      case 1:
        v6.n128_f64[0] = sin(v6.n128_f64[0] * 1.57079633);
        break;
    }
  }
  return v6.n128_f64[0];
}

BOOL OZChannel::hasFadeHandles(OZChannel *this)
{
  __int128 *v1;
  __int128 v3;
  CMTime *v4;
  CMTime v6;
  CMTime time1;

  v1 = (__int128 *)*((_QWORD *)this->var14 + 2);
  if (!v1)
    return 0;
  v3 = *v1;
  time1.epoch = *((_QWORD *)v1 + 2);
  *(_OWORD *)&time1.value = v3;
  v4 = (CMTime *)MEMORY[0x1E0CA2E68];
  v6 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  if (CMTimeCompare(&time1, &v6))
    return 1;
  time1 = *(CMTime *)(*((_QWORD *)this->var14 + 2) + 24);
  v6 = *v4;
  return CMTimeCompare(&time1, &v6) != 0;
}

uint64_t OZChannel::scaleFadeHandles(OZChannel *this, Float64 a2)
{
  uint64_t result;
  __int128 *v5;
  __int128 v6;
  CMTime *v7;
  uint64_t v8;
  __int128 v9;
  CMTime v10;
  CMTime time1;

  result = (*((uint64_t (**)(OZChannel *))this->var0 + 83))(this);
  if ((_DWORD)result)
  {
    v5 = (__int128 *)*((_QWORD *)this->var14 + 2);
    v6 = *v5;
    time1.epoch = *((_QWORD *)v5 + 2);
    *(_OWORD *)&time1.value = v6;
    v7 = (CMTime *)MEMORY[0x1E0CA2E68];
    v10 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
    if (CMTimeCompare(&time1, &v10))
    {
      operator*(*((CMTime **)this->var14 + 2), &time1, a2);
      v8 = *((_QWORD *)this->var14 + 2);
      v9 = *(_OWORD *)&time1.value;
      *(_QWORD *)(v8 + 16) = time1.epoch;
      *(_OWORD *)v8 = v9;
    }
    time1 = *(CMTime *)(*((_QWORD *)this->var14 + 2) + 24);
    v10 = *v7;
    result = CMTimeCompare(&time1, &v10);
    if ((_DWORD)result)
    {
      result = (uint64_t)operator*((CMTime *)(*((_QWORD *)this->var14 + 2) + 24), &time1, a2);
      *(CMTime *)(*((_QWORD *)this->var14 + 2) + 24) = time1;
    }
  }
  return result;
}

uint64_t OZChannel::setValue(OZChannel *this, const CMTime *a2, double a3, char a4)
{
  OZChannelFolder *var6;
  void *v9;
  uint64_t result;
  OZChannelImpl *var14;
  void *ChannelRootBase;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;

  var6 = this->var6;
  if (var6
    && (*(unsigned int (**)(OZChannelFolder *))(*(_QWORD *)var6 + 120))(var6)
    && OZChannelFolder::testFoldFlag(this->var6, 0x100000))
  {
    return (*(uint64_t (**)(void *, OZChannel *, const CMTime *, double))(*(_QWORD *)v9 + 744))(v9, this, a2, a3);
  }
  else
  {
    result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
    if ((result & 1) == 0)
    {
      if ((a4 & 1) == 0)
        (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
      if (((*((uint64_t (**)(OZChannel *))this->var0 + 64))(this) & 1) != 0
        || (*(_QWORD *)&v16 = 0,
            result = (*(uint64_t (**)(_QWORD, __int128 *))(**((_QWORD **)this->var14 + 1) + 208))(*((_QWORD *)this->var14 + 1), &v16), vabdd_f64(a3, *(double *)&v16) >= 0.0000001))
      {
        var14 = this->var14;
        if (var14 && *((_BYTE *)var14 + 32))
          this->var14 = OZChannelImpl::createLocalCopy(var14);
        ChannelRootBase = OZChannelBase::getChannelRootBase((OZChannelBase *)this);
        if (ChannelRootBase)
        {
          v13 = ChannelRootBase;
          (*(void (**)(void *, OZChannel *, const CMTime *, double))(*(_QWORD *)ChannelRootBase + 728))(ChannelRootBase, this, a2, a3);
          if (((*((uint64_t (**)(OZChannel *, _QWORD))this->var0 + 69))(this, 0) & 1) == 0)
          {
            (*(void (**)(__int128 *__return_ptr, void *))(*(_QWORD *)v13 + 712))(&v16, v13);
            v18 = v16;
            v19 = v17;
            if ((*(unsigned int (**)(void *, const CMTime *))(*(_QWORD *)v13 + 800))(v13, a2))
            {
              v14 = *((_QWORD *)this->var14 + 1);
              (*((void (**)(__int128 *__return_ptr, OZChannel *, __int128 *))this->var0 + 41))(&v16, this, &v18);
              OZChannel::getValueAsDouble(this, MEMORY[0x1E0CA2E68], 0.0);
              (*(void (**)(uint64_t, __int128 *, _QWORD))(*(_QWORD *)v14 + 552))(v14, &v16, 0);
            }
          }
        }
        v15 = *((_QWORD *)this->var14 + 1);
        (*((void (**)(__int128 *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(&v16, this, a2);
        (*(void (**)(uint64_t, __int128 *, _QWORD, double))(*(_QWORD *)v15 + 552))(v15, &v16, 0, a3);
        result = (*((uint64_t (**)(OZChannel *))this->var0 + 99))(this);
        if ((_DWORD)result)
          return (*((uint64_t (**)(OZChannel *, const CMTime *))this->var0 + 100))(this, a2);
      }
    }
  }
  return result;
}

double OZChannel::getInitialValue(OZChannel *this)
{
  double v2;

  v2 = 0.0;
  (*(void (**)(_QWORD, double *))(**((_QWORD **)this->var14 + 1) + 208))(*((_QWORD *)this->var14 + 1), &v2);
  return v2;
}

uint64_t OZChannel::setValue(OZChannel *this, const OZChannelBase *a2)
{
  uint64_t result;
  uint64_t v5;
  OZChannelImpl *var14;
  double v7;
  double v8;
  double v9;
  double v10;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    if (result)
    {
      v5 = result;
      var14 = this->var14;
      if (*((_BYTE *)var14 + 32))
      {
        var14 = OZChannelImpl::createLocalCopy(var14);
        this->var14 = var14;
      }
      v9 = 0.0;
      v10 = 0.0;
      (*(void (**)(_QWORD, double *))(**((_QWORD **)var14 + 1) + 264))(*((_QWORD *)var14 + 1), &v10);
      (*(void (**)(_QWORD, double *))(**((_QWORD **)this->var14 + 1) + 256))(*((_QWORD *)this->var14 + 1), &v9);
      OZChannelImpl::copyCurveInterface(this->var14, *(OZCurve **)(*(_QWORD *)(v5 + 112) + 8));
      (*(void (**)(_QWORD, double))(**((_QWORD **)this->var14 + 1) + 280))(*((_QWORD *)this->var14 + 1), v10);
      result = (*(uint64_t (**)(_QWORD, double))(**((_QWORD **)this->var14 + 1) + 272))(*((_QWORD *)this->var14 + 1), v9);
      v7 = *((double *)this->var16 + 5);
      v8 = *(double *)(*(_QWORD *)(v5 + 128) + 40);
      if (vabdd_f64(v7, v8) >= 0.0000001)
        return (*(uint64_t (**)(_QWORD, double))(**((_QWORD **)this->var14 + 1) + 448))(*((_QWORD *)this->var14 + 1), v8 / v7);
    }
  }
  return result;
}

uint64_t OZChannel::setValueOffsetByBehaviors(OZChannel *this, const CMTime *a2, double a3)
{
  double v6;
  double v7;
  uint64_t v8;
  _QWORD v10[3];
  double v11;

  OZChannel::getValueAsDouble(this, a2, 0.0);
  v7 = a3 - v6;
  v11 = 0.0;
  v8 = *((_QWORD *)this->var14 + 1);
  (*((void (**)(_QWORD *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(v10, this, a2);
  (*(void (**)(uint64_t, _QWORD *, double *, double))(*(_QWORD *)v8 + 624))(v8, v10, &v11, 0.0);
  return (*((uint64_t (**)(OZChannel *, const CMTime *, _QWORD, double))this->var0 + 89))(this, a2, 0, v7 + v11);
}

uint64_t OZChannel::setValueAndIgnoreRecordOption(OZChannel *this, const CMTime *a2)
{
  uint64_t result;
  OZChannelImpl *var14;
  uint64_t v6;
  _QWORD v7[3];

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    v6 = *((_QWORD *)var14 + 1);
    (*((void (**)(_QWORD *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(v7, this, a2);
    (*(void (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)v6 + 544))(v6, v7, 1);
    result = (*((uint64_t (**)(OZChannel *))this->var0 + 99))(this);
    if ((_DWORD)result)
      return (*((uint64_t (**)(OZChannel *, const CMTime *))this->var0 + 100))(this, a2);
  }
  return result;
}

uint64_t OZChannel::setValue(OZChannel *this, const CMTime *a2)
{
  uint64_t result;
  OZChannelImpl *var14;
  void *ChannelRootBase;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  _QWORD v14[3];

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    var14 = this->var14;
    if (var14 && *((_BYTE *)var14 + 32))
      this->var14 = OZChannelImpl::createLocalCopy(var14);
    ChannelRootBase = OZChannelBase::getChannelRootBase((OZChannelBase *)this);
    if (ChannelRootBase)
    {
      v7 = ChannelRootBase;
      if (((*((uint64_t (**)(OZChannel *, _QWORD))this->var0 + 69))(this, 0) & 1) == 0)
      {
        if ((*(unsigned int (**)(void *, const CMTime *))(*(_QWORD *)v7 + 800))(v7, a2))
        {
          v8 = *((_QWORD *)this->var14 + 1);
          (*(void (**)(__int128 *__return_ptr, void *))(*(_QWORD *)v7 + 712))(&v10, v7);
          v12 = v10;
          v13 = v11;
          (*((void (**)(_QWORD *__return_ptr, OZChannel *, __int128 *))this->var0 + 41))(v14, this, &v12);
          (*(void (**)(uint64_t, _QWORD *, _QWORD))(*(_QWORD *)v8 + 544))(v8, v14, 0);
        }
      }
    }
    v9 = *((_QWORD *)this->var14 + 1);
    (*((void (**)(__int128 *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(&v10, this, a2);
    (*(void (**)(uint64_t, __int128 *, _QWORD))(*(_QWORD *)v9 + 544))(v9, &v10, 0);
    result = (*((uint64_t (**)(OZChannel *))this->var0 + 99))(this);
    if ((_DWORD)result)
      return (*((uint64_t (**)(OZChannel *, const CMTime *))this->var0 + 100))(this, a2);
  }
  return result;
}

uint64_t OZChannel::getValueAsInt(OZChannel *this, const CMTime *a2, double a3)
{
  double v3;

  OZChannel::getValueAsDouble(this, a2, a3);
  return (int)v3;
}

uint64_t OZChannel::getValueAsUint(OZChannel *this, const CMTime *a2, double a3)
{
  double v3;

  OZChannel::getValueAsDouble(this, a2, a3);
  return v3;
}

uint64_t OZChannel::setDefaultValue(OZChannel *this, double a2)
{
  uint64_t result;
  OZChannelImpl *var14;
  double v6;

  v6 = 0.0;
  result = (*(uint64_t (**)(_QWORD, double *))(**((_QWORD **)this->var14 + 1) + 192))(*((_QWORD *)this->var14 + 1), &v6);
  if (vabdd_f64(v6, a2) >= 0.0000001)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    (*(void (**)(_QWORD, double))(**((_QWORD **)var14 + 1) + 200))(*((_QWORD *)var14 + 1), a2);
    result = OZChannelBase::testFlag((OZChannelBase *)this, 0x200000000);
    if ((_DWORD)result)
      return (uint64_t)OZChannelBase::setFlag((OZChannelBase *)this, 0x100000000, 1);
  }
  return result;
}

double OZChannel::getDefaultValue(OZChannel *this)
{
  double v2;

  v2 = 0.0;
  (*(void (**)(_QWORD, double *))(**((_QWORD **)this->var14 + 1) + 192))(*((_QWORD *)this->var14 + 1), &v2);
  return v2;
}

uint64_t OZChannel::setDefaultAtCurrentTime(OZChannel *this, const CMTime *a2)
{
  double v3;

  OZChannel::getValueAsDouble(this, a2, 0.0);
  return OZChannel::setDefaultValue(this, v3);
}

uint64_t OZChannel::setDefaultToCurrentValue(OZChannel *this)
{
  double v2;

  OZChannel::getValueAsDouble(this, MEMORY[0x1E0CA2E68], 0.0);
  return OZChannel::setDefaultValue(this, v2);
}

uint64_t OZChannel::setInitialValue(OZChannel *this, double a2, char a3)
{
  uint64_t result;
  OZChannelImpl *var14;
  double v8;

  v8 = 0.0;
  result = (*(uint64_t (**)(_QWORD, double *))(**((_QWORD **)this->var14 + 1) + 208))(*((_QWORD *)this->var14 + 1), &v8);
  if (vabdd_f64(v8, a2) >= 0.0000001)
  {
    if ((a3 & 1) == 0)
      (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, double))(**((_QWORD **)var14 + 1) + 216))(*((_QWORD *)var14 + 1), a2);
  }
  return result;
}

BOOL OZChannel::removeValue(OZChannel *this, const CMTime *a2)
{
  _BOOL8 v4;
  uint64_t v5;
  OZChannelImpl *var14;
  _QWORD v8[3];
  uint64_t v9;

  v4 = 0;
  if ((OZChannelBase::isLocked((OZChannelBase *)this, 0) & 1) == 0)
  {
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    v9 = 0;
    v5 = *((_QWORD *)this->var14 + 1);
    (*((void (**)(_QWORD *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(v8, this, a2);
    (*(void (**)(uint64_t, _QWORD *, uint64_t *))(*(_QWORD *)v5 + 696))(v5, v8, &v9);
    v4 = v9 != 0;
    if (v9)
    {
      var14 = this->var14;
      if (*((_BYTE *)var14 + 32))
      {
        var14 = OZChannelImpl::createLocalCopy(var14);
        this->var14 = var14;
      }
      (*(void (**)(_QWORD))(**((_QWORD **)var14 + 1) + 672))(*((_QWORD *)var14 + 1));
    }
  }
  return v4;
}

uint64_t OZChannel::removeAllValues(OZChannel *this, const CMTime *a2, uint64_t a3)
{
  uint64_t result;
  OZChannelImpl *var14;
  uint64_t v8;
  _QWORD v9[3];

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    v8 = *((_QWORD *)var14 + 1);
    (*((void (**)(_QWORD *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(v9, this, a2);
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)v8 + 688))(v8, v9, a3);
  }
  return result;
}

BOOL OZChannel::moveValue(OZChannel *this, const CMTime *a2, const CMTime *a3, uint64_t a4)
{
  _BOOL8 v8;
  uint64_t v9;
  uint64_t v10;
  OZChannelImpl *var14;
  uint64_t v12;
  _QWORD v14[3];
  uint64_t v15;

  v8 = 0;
  if ((OZChannelBase::isLocked((OZChannelBase *)this, 0) & 1) == 0)
  {
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    v15 = 0;
    v9 = *((_QWORD *)this->var14 + 1);
    (*((void (**)(_QWORD *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(v14, this, a2);
    (*(void (**)(uint64_t, _QWORD *, uint64_t *))(*(_QWORD *)v9 + 696))(v9, v14, &v15);
    v10 = v15;
    v8 = v15 != 0;
    if (v15)
    {
      var14 = this->var14;
      if (*((_BYTE *)var14 + 32))
      {
        var14 = OZChannelImpl::createLocalCopy(var14);
        this->var14 = var14;
        v10 = v15;
      }
      v12 = *((_QWORD *)var14 + 1);
      (*((void (**)(_QWORD *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(v14, this, a3);
      (*(void (**)(uint64_t, uint64_t, _QWORD *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v12 + 656))(v12, v10, v14, a4, 0, 0);
    }
  }
  return v8;
}

uint64_t OZChannel::offsetChannel(OZChannel *this, const CMTime *a2, double a3)
{
  uint64_t result;
  OZChannelImpl *var14;
  uint64_t v8;
  _QWORD v9[3];

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    v8 = *((_QWORD *)var14 + 1);
    (*((void (**)(_QWORD *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(v9, this, a2);
    return (*(uint64_t (**)(uint64_t, _QWORD *, double))(*(_QWORD *)v8 + 440))(v8, v9, a3);
  }
  return result;
}

uint64_t OZChannel::scaleChannel(OZChannel *this, double a2)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0 && fabs(a2 + -1.0) >= 0.0000001)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, double))(**((_QWORD **)var14 + 1) + 448))(*((_QWORD *)var14 + 1), a2);
  }
  return result;
}

void OZChannel::copyKeyframesFromChannel(OZChannel *this, const CMTime *a2, OZChannelBase *a3)
{
  char isLocked;
  OZChannel *v7;
  OZChannel *v8;
  OZChannelImpl *var14;
  double v10;
  char *v11;
  unint64_t v12;
  unsigned int v13;
  CMTime *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t value_low;
  uint64_t v18;
  uint64_t v19;
  int v20;
  double v21;
  uint64_t v22;
  double v23;
  uint64_t v24;
  double v25;
  double v26;
  CMTimeValue value;
  double v28;
  CMTimeValue v29;
  __n128 v30;
  __n128 v31;
  uint64_t v32;
  uint64_t v33;
  double v34;
  double v35;
  void *v36;
  CMTime v37;
  double v38;
  unint64_t v39;
  double v40;
  unint64_t v41;
  double v42;
  CMTime v43;
  char *v44;
  char *v45;
  CMTime v46;
  CMTime v47;
  CMTime v48;

  isLocked = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if (!a3)
    return;
  if ((isLocked & 1) != 0)
    return;
  if (!v7)
    return;
  v8 = v7;
  var14 = this->var14;
  if (var14 && *((_BYTE *)var14 + 32))
    this->var14 = OZChannelImpl::createLocalCopy(var14);
  v10 = *((double *)v8->var16 + 5);
  memset(&v46, 0, sizeof(v46));
  (*((void (**)(CMTime *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(&v46, this, a2);
  OZChannel::getKeyframes(v8, 0, &v44);
  v11 = v44;
  if (v45 != v44)
  {
    v12 = 0;
    v13 = 1;
    v14 = (CMTime *)MEMORY[0x1E0CA2E68];
    while (1)
    {
      v43 = *v14;
      v41 = 0;
      v42 = 0.0;
      v39 = 0;
      v40 = 0.0;
      v38 = 0.0;
      (*(void (**)(_QWORD, _QWORD, CMTime *, double *))(**((_QWORD **)v8->var14 + 1) + 752))(*((_QWORD *)v8->var14 + 1), *(_QWORD *)&v11[8 * v12], &v43, &v42);
      (*(void (**)(_QWORD, _QWORD, unint64_t *, double *))(**((_QWORD **)v8->var14 + 1) + 1032))(*((_QWORD *)v8->var14 + 1), *(_QWORD *)&v44[8 * v12], &v41, &v40);
      (*(void (**)(_QWORD, _QWORD, unint64_t *, double *))(**((_QWORD **)v8->var14 + 1) + 1040))(*((_QWORD *)v8->var14 + 1), *(_QWORD *)&v44[8 * v12], &v39, &v38);
      v15 = *(_QWORD *)&v44[8 * v12];
      LODWORD(v48.value) = 0;
      (*(void (**)(_QWORD, uint64_t, CMTime *, _QWORD))(**((_QWORD **)v8->var14 + 1) + 1072))(*((_QWORD *)v8->var14 + 1), v15, &v48, 0);
      v16 = *(_QWORD *)&v44[8 * v12];
      value_low = LODWORD(v48.value);
      LODWORD(v48.value) = 0;
      (*(void (**)(_QWORD, uint64_t, CMTime *))(**((_QWORD **)v8->var14 + 1) + 840))(*((_QWORD *)v8->var14 + 1), v16, &v48);
      v18 = *(_QWORD *)&v44[8 * v12];
      v19 = LODWORD(v48.value);
      LOBYTE(v48.value) = 0;
      (*(void (**)(_QWORD, uint64_t, CMTime *))(**((_QWORD **)v8->var14 + 1) + 864))(*((_QWORD *)v8->var14 + 1), v18, &v48);
      v20 = LOBYTE(v48.value);
      v42 = v10 * v42;
      v40 = v10 * v40;
      v38 = v10 * v38;
      if (v13 == 1)
      {
        v48 = v46;
        v47 = v43;
        PC_CMTimeSaferSubtract(&v48, &v47, (uint64_t)&v37);
        v46 = v37;
      }
      v36 = 0;
      v21 = *((double *)this->var16 + 5);
      v22 = *((_QWORD *)this->var14 + 1);
      v48 = v46;
      v47 = v43;
      v23 = PC_CMTimeSaferAdd(&v48, &v47, (uint64_t)&v37);
      (*(void (**)(uint64_t, CMTime *, void **, double))(*(_QWORD *)v22 + 696))(v22, &v37, &v36, v23);
      if (v36)
      {
        LOBYTE(v48.value) = 0;
        (*(void (**)(_QWORD, void *, CMTime *))(**((_QWORD **)this->var14 + 1) + 888))(*((_QWORD *)this->var14 + 1), v36, &v48);
        if (LOBYTE(v48.value))
          goto LABEL_26;
      }
      v48 = v46;
      v47 = v43;
      PC_CMTimeSaferAdd(&v48, &v47, (uint64_t)&v37);
      OZChannel::setKeyframe(this, &v37, v42 / v21, 0);
      v24 = *((_QWORD *)this->var14 + 1);
      v48 = v46;
      v47 = v43;
      v25 = PC_CMTimeSaferAdd(&v48, &v47, (uint64_t)&v37);
      (*(void (**)(uint64_t, CMTime *, void **, double))(*(_QWORD *)v24 + 696))(v24, &v37, &v36, v25);
      OZChannel::setKeyframeFlags(this, v36, v19);
      (*(void (**)(_QWORD, void *, BOOL, uint64_t))(**((_QWORD **)this->var14 + 1) + 856))(*((_QWORD *)this->var14 + 1), v36, v20 != 0, 1);
      (*(void (**)(_QWORD, void *, uint64_t, uint64_t))(**((_QWORD **)this->var14 + 1) + 1064))(*((_QWORD *)this->var14 + 1), v36, value_low, 1);
      v48 = v46;
      v47 = v43;
      v26 = PC_CMTimeSaferAdd(&v48, &v47, (uint64_t)&v37);
      v48.value = 0;
      (*(void (**)(_QWORD, CMTime *, CMTime *, double))(**((_QWORD **)this->var14 + 1) + 712))(*((_QWORD *)this->var14 + 1), &v37, &v48, v26);
      value = v48.value;
      v35 = 0.0;
      (*(void (**)(_QWORD, CMTimeValue, _QWORD, double *))(**((_QWORD **)this->var14 + 1) + 752))(*((_QWORD *)this->var14 + 1), v48.value, 0, &v35);
      v48 = v46;
      v47 = v43;
      v28 = PC_CMTimeSaferAdd(&v48, &v47, (uint64_t)&v37);
      v48.value = 0;
      (*(void (**)(_QWORD, CMTime *, CMTime *, double))(**((_QWORD **)this->var14 + 1) + 728))(*((_QWORD *)this->var14 + 1), &v37, &v48, v28);
      v29 = v48.value;
      v48.value = 0;
      (*(void (**)(_QWORD, CMTimeValue, _QWORD, CMTime *))(**((_QWORD **)this->var14 + 1) + 752))(*((_QWORD *)this->var14 + 1), v29, 0, &v48);
      if ((unint64_t)(v45 - v44) > 8 || value && vabdd_f64(v35, v42 / v21) >= 0.0000001)
      {
        v30.n128_u64[0] = v41;
        v32 = 127;
        v31.n128_f64[0] = v40 / v21;
      }
      else
      {
        if (!v29)
          goto LABEL_22;
        v30.n128_u64[0] = 0;
        v32 = 128;
        v31.n128_u64[0] = 0;
      }
      (*(void (**)(__n128, __n128))(**((_QWORD **)this->var14 + 1) + 8 * v32))(v30, v31);
      if ((unint64_t)(v45 - v44) > 8 || v29 && vabdd_f64(*(double *)&v48.value, v42 / v21) >= 0.0000001)
      {
        v30.n128_u64[0] = v39;
        v33 = 128;
        v31.n128_f64[0] = v38 / v21;
        goto LABEL_25;
      }
LABEL_22:
      if (value)
      {
        v30.n128_u64[0] = 0;
        v33 = 127;
        v31.n128_u64[0] = 0;
LABEL_25:
        (*(void (**)(__n128, __n128))(**((_QWORD **)this->var14 + 1) + 8 * v33))(v30, v31);
      }
LABEL_26:
      v12 = v13;
      v11 = v44;
      ++v13;
      if (v12 >= (v45 - v44) >> 3)
      {
        if (v44)
          goto LABEL_28;
        return;
      }
    }
  }
  (*((void (**)(OZChannel *, _QWORD))this->var0 + 36))(this, 0);
  OZChannel::getValueAsDouble(v8, MEMORY[0x1E0CA2E68], 0.0);
  OZChannel::setInitialValue(this, v10 * v34 / *((double *)this->var16 + 5), 0);
  v11 = v44;
  if (v44)
  {
LABEL_28:
    v45 = v11;
    operator delete(v11);
  }
}

void sub_1B2C225D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t OZChannel::getKeyframes@<X0>(OZChannel *this@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  _QWORD *v3;
  uint64_t v4;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v3 = (_QWORD *)*((_QWORD *)this->var14 + 1);
  v4 = 792;
  if (a2)
    v4 = 800;
  return (*(uint64_t (**)(void))(*v3 + v4))();
}

void sub_1B2C22660(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t OZChannel::getKeyframe(OZChannel *this, void *a2, CMTime *a3, double *a4)
{
  return (*(uint64_t (**)(_QWORD, void *, CMTime *, double *))(**((_QWORD **)this->var14 + 1) + 752))(*((_QWORD *)this->var14 + 1), a2, a3, a4);
}

uint64_t OZChannel::getKeyframeInputTangents(OZChannel *this, void *a2, double *a3, double *a4, int a5)
{
  uint64_t v5;

  v5 = 1032;
  if (a5)
    v5 = 1000;
  return (*(uint64_t (**)(void))(**((_QWORD **)this->var14 + 1) + v5))();
}

uint64_t OZChannel::getKeyframeOutputTangents(OZChannel *this, void *a2, double *a3, double *a4, int a5)
{
  uint64_t v5;

  v5 = 1040;
  if (a5)
    v5 = 1008;
  return (*(uint64_t (**)(void))(**((_QWORD **)this->var14 + 1) + v5))();
}

uint64_t OZChannel::getKeyframeInterpolation(OZChannel *this, void *a2)
{
  unsigned int v3;

  v3 = 0;
  (*(void (**)(_QWORD, void *, unsigned int *, _QWORD))(**((_QWORD **)this->var14 + 1) + 1072))(*((_QWORD *)this->var14 + 1), a2, &v3, 0);
  return v3;
}

uint64_t OZChannel::getKeyframeFlags(OZChannel *this, void *a2)
{
  unsigned int v3;

  v3 = 0;
  (*(void (**)(_QWORD, void *, unsigned int *))(**((_QWORD **)this->var14 + 1) + 840))(*((_QWORD *)this->var14 + 1), a2, &v3);
  return v3;
}

uint64_t OZChannel::getKeyframeEnabled(OZChannel *this, void *a2)
{
  unsigned __int8 v3;

  v3 = 0;
  (*(void (**)(_QWORD, void *, unsigned __int8 *))(**((_QWORD **)this->var14 + 1) + 864))(*((_QWORD *)this->var14 + 1), a2, &v3);
  return v3;
}

uint64_t OZChannel::setKeyframe(OZChannel *this, const CMTime *a2, double a3, int a4)
{
  uint64_t result;
  OZChannelImpl *var14;
  uint64_t v9;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    v9 = 568;
    if (a4)
      v9 = 552;
    return (*(uint64_t (**)(double))(**((_QWORD **)var14 + 1) + v9))(a3);
  }
  return result;
}

uint64_t OZChannel::setKeyframeFlags(OZChannel *this, void *a2, uint64_t a3)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, void *, uint64_t, uint64_t))(**((_QWORD **)var14 + 1) + 848))(*((_QWORD *)var14 + 1), a2, a3, 1);
  }
  return result;
}

uint64_t OZChannel::getPreviousEnabledKeyframe(OZChannel *this, const CMTime *a2)
{
  uint64_t v3;

  v3 = 0;
  (*(void (**)(_QWORD, const CMTime *, uint64_t *))(**((_QWORD **)this->var14 + 1) + 712))(*((_QWORD *)this->var14 + 1), a2, &v3);
  return v3;
}

uint64_t OZChannel::getNextEnabledKeyframe(OZChannel *this, const CMTime *a2)
{
  uint64_t v3;

  v3 = 0;
  (*(void (**)(_QWORD, const CMTime *, uint64_t *))(**((_QWORD **)this->var14 + 1) + 728))(*((_QWORD *)this->var14 + 1), a2, &v3);
  return v3;
}

uint64_t OZChannel::getTimeForValue(OZChannelBase *a1, uint64_t *a2, __int128 *a3, __int128 *a4, uint64_t a5, double a6)
{
  __int128 *v12;
  void *ChannelRootBase;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;

  v27 = *((_QWORD *)a3 + 2);
  v26 = *a3;
  v28 = *(__int128 *)((char *)a3 + 24);
  v29 = *((_QWORD *)a3 + 5);
  if (!*((_QWORD *)a1[1].var0 + 1))
    return 0;
  v12 = (__int128 *)((char *)a3 + 24);
  ChannelRootBase = OZChannelBase::getChannelRootBase(a1);
  if (ChannelRootBase)
  {
    (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)ChannelRootBase + 880))(&v24);
  }
  else
  {
    v24 = *a4;
    v25 = *((_QWORD *)a4 + 2);
  }
  v22 = *a3;
  v23 = *((_QWORD *)a3 + 2);
  (*((void (**)(__int128 *__return_ptr, OZChannelBase *, __int128 *))a1->var0 + 41))(&v26, a1, &v22);
  v28 = *v12;
  v29 = *((_QWORD *)v12 + 2);
  result = (*(uint64_t (**)(_QWORD, uint64_t *, __int128 *, __int128 *, uint64_t, double))(**((_QWORD **)a1[1].var0 + 1)
                                                                                                 + 432))(*((_QWORD *)a1[1].var0 + 1), a2, &v26, &v24, a5, a6);
  if ((_DWORD)result)
  {
    v15 = *a2;
    if (a2[1] != *a2)
    {
      v16 = 0;
      v17 = 1;
      do
      {
        v18 = 3 * v16;
        (*((void (**)(__int128 *__return_ptr, OZChannelBase *, uint64_t))a1->var0 + 42))(&v22, a1, v15 + 24 * v16);
        v19 = *a2 + 8 * v18;
        v20 = v22;
        *(_QWORD *)(v19 + 16) = v23;
        *(_OWORD *)v19 = v20;
        v16 = v17;
        v15 = *a2;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3) > v17++);
    }
    return 1;
  }
  return result;
}

uint64_t OZChannel::beginPlayback(OZChannel *this, const CMTime *a2, uint64_t a3, uint64_t a4, const CMTime *a5)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (var14)
    {
      if (*((_BYTE *)var14 + 32))
      {
        var14 = OZChannelImpl::createLocalCopy(var14);
        this->var14 = var14;
      }
    }
    return OZChannelImpl::beginPlayback(var14, a2, a3, a4, a5);
  }
  return result;
}

uint64_t OZChannel::endPlayback(OZChannel *this, const CMTime *a2)
{
  return OZChannelImpl::endPlayback(this->var14, a2);
}

uint64_t OZChannel::beginRecording(OZChannel *this, const CMTime *a2)
{
  uint64_t result;
  OZChannelImpl *var14;
  CMTime v6;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (var14 && *((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(this->var14);
      this->var14 = var14;
    }
    (*((void (**)(CMTime *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(&v6, this, a2);
    OZChannelImpl::beginRecording(var14, &v6);
    result = (uint64_t)OZChannelBase::getChannelRootBase((OZChannelBase *)this);
    if (result)
      return (*(uint64_t (**)(uint64_t, OZChannel *, const CMTime *))(*(_QWORD *)result + 736))(result, this, a2);
  }
  return result;
}

void *OZChannel::endRecording(OZChannel *this, const CMTime *a2)
{
  OZChannelImpl *var14;
  void *result;
  CMTime v6;

  var14 = this->var14;
  (*((void (**)(CMTime *__return_ptr))this->var0 + 41))(&v6);
  OZChannelImpl::endRecording(var14, &v6);
  result = OZChannelBase::getChannelRootBase((OZChannelBase *)this);
  if (result)
    return (void *)(*(uint64_t (**)(void *, OZChannel *, const CMTime *))(*(_QWORD *)result + 744))(result, this, a2);
  return result;
}

uint64_t OZChannel::updateCurrentRecordingTime(OZChannel *this, const CMTime *a2)
{
  OZChannelImpl *var14;
  CMTime v4;

  var14 = this->var14;
  (*((void (**)(CMTime *__return_ptr))this->var0 + 41))(&v4);
  return OZChannelImpl::updateCurrentRecordingTime(var14, &v4);
}

OZChannelImpl *OZChannel::didRecordValue(OZChannel *this, const CMTime *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return OZChannelImpl::didRecordValue(this->var14, (OZChannelBase *)this, a2, a4, a5, a6, a7, a8);
}

uint64_t OZChannel::isPlaying(OZChannel *this, unsigned int *a2, unsigned int *a3, CMTime *a4)
{
  return OZChannelImpl::isPlaying(this->var14, a2, a3, a4);
}

uint64_t OZChannel::isRecording(OZChannel *this)
{
  return OZChannelImpl::isRecording(this->var14);
}

void OZChannel::registerRecordingCallback(OZChannel *this, void (*a2)(OZChannelBase *, const CMTime *, void *), void *a3, char a4)
{
  OZChannelImpl *var14;

  if ((OZChannelBase::isLocked((OZChannelBase *)this, 0) & 1) == 0)
  {
    var14 = this->var14;
    if (var14)
    {
      if (*((_BYTE *)var14 + 32))
      {
        var14 = OZChannelImpl::createLocalCopy(var14);
        this->var14 = var14;
      }
    }
    OZChannelImpl::registerRecordingCallback(var14, a2, a3, a4);
  }
}

OZChannelImpl *OZChannel::unregisterRecordingCallback(OZChannel *this, void (*a2)(OZChannelBase *, const CMTime *, void *), void *a3)
{
  return OZChannelImpl::unregisterRecordingCallback(this->var14, a2, a3);
}

void OZChannel::setInfo(OZChannel *this, const OZChannelInfo *a2)
{
  OZChannelInfo *var16;

  var16 = this->var16;
  if (*((_BYTE *)var16 + 72))
  {
    var16 = OZChannelInfo::createLocalCopy(var16);
    this->var16 = var16;
  }
  OZChannelInfo::operator=((uint64_t)var16, (uint64_t)a2);
}

OZChannelInfo *OZChannel::replaceInfo(OZChannel *this, OZChannelInfo *a2)
{
  OZChannelInfo *result;

  result = this->var16;
  if (!*((_BYTE *)result + 72))
    result = (OZChannelInfo *)(*(uint64_t (**)(OZChannelInfo *))(*(_QWORD *)result + 8))(result);
  this->var16 = a2;
  if (*((_BYTE *)a2 + 72))
    this->var17 = a2;
  return result;
}

uint64_t OZChannel::setMin(OZChannel *this, double a2)
{
  uint64_t result;
  OZChannelImpl *var14;
  double v6;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    v6 = 0.0;
    result = (*(uint64_t (**)(_QWORD, double *))(**((_QWORD **)this->var14 + 1) + 264))(*((_QWORD *)this->var14 + 1), &v6);
    if (vabdd_f64(a2, v6) >= 0.0000001)
    {
      var14 = this->var14;
      if (*((_BYTE *)var14 + 32))
      {
        var14 = OZChannelImpl::createLocalCopy(var14);
        this->var14 = var14;
      }
      result = (*(uint64_t (**)(_QWORD, double))(**((_QWORD **)var14 + 1) + 280))(*((_QWORD *)var14 + 1), a2);
      if (*((double *)this->var16 + 2) < a2)
        return (uint64_t)OZChannel::setSliderMin(this, a2);
    }
  }
  return result;
}

OZChannelInfo *OZChannel::setSliderMin(OZChannel *this, double a2)
{
  OZChannelInfo *result;

  result = this->var16;
  if (vabdd_f64(a2, *((double *)result + 2)) >= 0.0000001)
  {
    if (*((_BYTE *)result + 72))
    {
      result = OZChannelInfo::createLocalCopy(this->var17);
      this->var16 = result;
    }
    *((double *)result + 2) = a2;
  }
  return result;
}

void OZChannel::setMax(OZChannel *this, double a2)
{
  OZChannelImpl *var14;
  double v5;

  if ((OZChannelBase::isLocked((OZChannelBase *)this, 0) & 1) == 0)
  {
    v5 = 0.0;
    (*(void (**)(_QWORD, double *))(**((_QWORD **)this->var14 + 1) + 256))(*((_QWORD *)this->var14 + 1), &v5);
    if (vabdd_f64(a2, v5) >= 0.0000001)
    {
      var14 = this->var14;
      if (*((_BYTE *)var14 + 32))
      {
        var14 = OZChannelImpl::createLocalCopy(var14);
        this->var14 = var14;
      }
      (*(void (**)(_QWORD, double))(**((_QWORD **)var14 + 1) + 272))(*((_QWORD *)var14 + 1), a2);
      if ((*((double (**)(OZChannel *))this->var0 + 101))(this) > a2)
        OZChannel::setSliderMax(this, a2);
    }
  }
}

OZChannelInfo *OZChannel::setSliderMax(OZChannel *this, double a2)
{
  OZChannelInfo *result;

  result = this->var16;
  if (vabdd_f64(a2, *((double *)result + 1)) >= 0.0000001)
  {
    if (*((_BYTE *)result + 72))
    {
      result = OZChannelInfo::createLocalCopy(this->var17);
      this->var16 = result;
    }
    *((double *)result + 1) = a2;
  }
  return result;
}

OZChannelInfo *OZChannel::setCoarseDelta(OZChannel *this, double a2)
{
  OZChannelInfo *result;

  result = this->var16;
  if (vabdd_f64(a2, *((double *)result + 4)) >= 0.0000001)
  {
    if (*((_BYTE *)result + 72))
    {
      result = OZChannelInfo::createLocalCopy(this->var17);
      this->var16 = result;
    }
    *((double *)result + 4) = a2;
  }
  return result;
}

OZChannelInfo *OZChannel::setFineDelta(OZChannel *this, double a2)
{
  OZChannelInfo *result;

  result = this->var16;
  if (vabdd_f64(a2, *((double *)result + 3)) >= 0.0000001)
  {
    if (*((_BYTE *)result + 72))
    {
      result = OZChannelInfo::createLocalCopy(this->var17);
      this->var16 = result;
    }
    *((double *)result + 3) = a2;
  }
  return result;
}

OZChannelInfo *OZChannel::setScale(OZChannel *this, double a2)
{
  OZChannelInfo *result;

  result = this->var16;
  if (vabdd_f64(a2, *((double *)result + 5)) >= 0.0000001)
  {
    if (*((_BYTE *)result + 72))
    {
      result = OZChannelInfo::createLocalCopy(this->var17);
      this->var16 = result;
    }
    *((double *)result + 5) = a2;
  }
  return result;
}

OZChannelInfo *OZChannel::setOffset(OZChannel *this, double a2)
{
  OZChannelInfo *result;

  result = this->var16;
  if (vabdd_f64(a2, *((double *)result + 6)) >= 0.0000001)
  {
    if (*((_BYTE *)result + 72))
    {
      result = OZChannelInfo::createLocalCopy(this->var17);
      this->var16 = result;
    }
    *((double *)result + 6) = a2;
  }
  return result;
}

void OZChannel::setSuffix(OZChannel *this, PCString *a2)
{
  OZChannelInfo *var16;

  if (PCString::compare(a2, (const PCString *)this->var16 + 7))
  {
    var16 = this->var16;
    if (*((_BYTE *)var16 + 72))
    {
      var16 = OZChannelInfo::createLocalCopy(this->var17);
      this->var16 = var16;
    }
    PCString::set((PCString *)var16 + 7, a2);
  }
}

void OZChannel::setSuffix(OZChannel *this, const char *a2)
{
  PCString v3;

  PCString::PCString(&v3, a2);
  OZChannel::setSuffix(this, &v3);
  PCString::~PCString(&v3);
}

void sub_1B2C231C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

void OZChannel::setSliderTransformerName(OZChannel *this, const __CFString *a2)
{
  OZChannelInfo *var16;

  if (CFStringCompare(*((CFStringRef *)this->var16 + 8), a2, 0x20uLL))
  {
    var16 = this->var16;
    if (*((_BYTE *)var16 + 72))
    {
      var16 = OZChannelInfo::createLocalCopy(this->var17);
      this->var16 = var16;
    }
    OZChannelInfo::setSliderTransformerName(var16, a2);
  }
}

void *OZChannel::isChannelAffectedByBehaviors(OZChannel *this, uint64_t a2)
{
  void *result;

  result = OZChannelBase::getChannelRootBase((OZChannelBase *)this);
  if (result)
    return (void *)(*(uint64_t (**)(void *, OZChannel *, uint64_t))(*(_QWORD *)result + 808))(result, this, a2);
  return result;
}

uint64_t OZChannel::getCurveInterface(OZChannel *this)
{
  return *((_QWORD *)this->var14 + 1);
}

uint64_t OZChannel::isAnimated(OZChannel *this)
{
  unsigned __int8 v2;

  v2 = 1;
  (*(void (**)(_QWORD, unsigned __int8 *))(**((_QWORD **)this->var14 + 1) + 72))(*((_QWORD *)this->var14 + 1), &v2);
  return v2;
}

void OZChannel::setIsSpline(OZChannel *this, uint64_t a2)
{
  OZChannelFolder *var6;
  void *v5;
  OZChannelImpl *var14;
  void *ChannelRootBase;
  CMTime v8;

  var6 = this->var6;
  if (var6
    && (*(unsigned int (**)(OZChannelFolder *))(*(_QWORD *)var6 + 120))(var6)
    && OZChannelFolder::testFoldFlag(this->var6, 0x100000))
  {
    (*(void (**)(void *, OZChannel *, uint64_t, _QWORD))(*(_QWORD *)v5 + 784))(v5, this, a2, 0);
  }
  else if ((OZChannelBase::isLocked((OZChannelBase *)this, 0) & 1) == 0
         && (*((unsigned int (**)(OZChannel *))this->var0 + 61))(this) != (_DWORD)a2)
  {
    var14 = this->var14;
    if (var14 && *((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    if ((_DWORD)a2)
    {
      OZCurve::setIsSpline(*((OZCurve **)var14 + 1), 1, MEMORY[0x1E0CA2E68]);
    }
    else
    {
      v8 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
      ChannelRootBase = OZChannelBase::getChannelRootBase((OZChannelBase *)this);
      if (ChannelRootBase)
        (*(void (**)(CMTime *__return_ptr, void *, uint64_t))(*(_QWORD *)ChannelRootBase + 848))(&v8, ChannelRootBase, 1);
      OZCurve::setIsSpline(*((OZCurve **)this->var14 + 1), 0, &v8);
    }
  }
}

uint64_t OZChannel::isSpline(OZChannel *this)
{
  uint64_t result;
  int v2;

  v2 = 0;
  LODWORD(result) = (*(uint64_t (**)(_QWORD, int *))(**((_QWORD **)this->var14 + 1) + 152))(*((_QWORD *)this->var14 + 1), &v2);
  if (v2 == 1)
    return result;
  else
    return 0;
}

uint64_t OZChannel::isModified(OZChannel *this)
{
  double v2;
  double v3;
  uint64_t result;
  double v5;

  if (((*((uint64_t (**)(OZChannel *, _QWORD))this->var0 + 69))(this, 0) & 1) != 0)
    return 1;
  if (((*((uint64_t (**)(OZChannel *))this->var0 + 83))(this) & 1) != 0)
    return 1;
  OZChannel::getValueAsDouble(this, MEMORY[0x1E0CA2E68], 0.0);
  v3 = v2;
  v5 = 0.0;
  (*(void (**)(_QWORD, double *))(**((_QWORD **)this->var14 + 1) + 192))(*((_QWORD *)this->var14 + 1), &v5);
  if (vabdd_f64(v3, v5) >= 0.0000001)
    return 1;
  result = (uint64_t)OZChannelBase::getChannelRootBase((OZChannelBase *)this);
  if (result)
    return (*(uint64_t (**)(uint64_t, OZChannel *, _QWORD))(*(_QWORD *)result + 808))(result, this, 0);
  return result;
}

uint64_t OZChannel::setKeyframable(OZChannel *this, uint64_t a2)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    if ((*((unsigned int (**)(OZChannel *))this->var0 + 64))(this) != (_DWORD)a2
      || (result = (*((uint64_t (**)(OZChannel *))this->var0 + 61))(this), (_DWORD)result != (_DWORD)a2))
    {
      var14 = this->var14;
      if (*((_BYTE *)var14 + 32))
      {
        var14 = OZChannelImpl::createLocalCopy(var14);
        this->var14 = var14;
      }
      (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)var14 + 1) + 80))(*((_QWORD *)var14 + 1), a2);
      return (*((uint64_t (**)(OZChannel *, uint64_t))this->var0 + 60))(this, a2);
    }
  }
  return result;
}

uint64_t OZChannel::isKeyframable(OZChannel *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this->var14 + 1) + 88))(*((_QWORD *)this->var14 + 1));
}

void OZChannel::keyframesWithChannels(_QWORD *a1, _OWORD *a2, uint64_t *a3)
{
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  char *v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  char *v39;
  char *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  char *v44;
  char *v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  char *v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  char *v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  CMTimeValue *v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  CMTime time2;
  CMTimeValue v68;
  _BYTE time1[32];
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  void *v74;
  char *v75;
  char *v76;
  void *__p;
  char *v78;
  char *v79;
  uint64_t v80;
  CMTimeRange range;
  CMTime v82;
  __int128 v83;
  uint64_t v84;

  v5 = a2[1];
  v83 = *a2;
  v6 = a2[2];
  *(_OWORD *)&range.start.value = *a2;
  *(_OWORD *)&range.start.epoch = v5;
  v84 = *((_QWORD *)a2 + 2);
  memset(&v82, 0, sizeof(v82));
  *(_OWORD *)&range.duration.timescale = v6;
  CMTimeRangeGetEnd(&v82, &range);
  v80 = 0;
  __p = 0;
  v78 = 0;
  v79 = 0;
  v75 = 0;
  v76 = 0;
  v74 = 0;
  v7 = *(_QWORD *)(a1[14] + 8);
  (*(void (**)(_BYTE *__return_ptr, _QWORD *, __int128 *))(*a1 + 328))(time1, a1, &v83);
  if ((*(unsigned int (**)(uint64_t, _BYTE *, uint64_t *))(*(_QWORD *)v7 + 696))(v7, time1, &v80))
  {
    v8 = v78;
    if (v78 >= v79)
    {
      v10 = (v78 - (_BYTE *)__p) >> 3;
      if ((unint64_t)(v10 + 1) >> 61)
LABEL_80:
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v11 = (v79 - (_BYTE *)__p) >> 2;
      if (v11 <= v10 + 1)
        v11 = v10 + 1;
      if ((unint64_t)(v79 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
        v12 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v12 = v11;
      if (v12)
        v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v79, v12);
      else
        v13 = 0;
      v14 = &v13[8 * v10];
      v15 = &v13[8 * v12];
      *(_QWORD *)v14 = v80;
      v9 = v14 + 8;
      v17 = (char *)__p;
      v16 = v78;
      if (v78 != __p)
      {
        do
        {
          v18 = *((_QWORD *)v16 - 1);
          v16 -= 8;
          *((_QWORD *)v14 - 1) = v18;
          v14 -= 8;
        }
        while (v16 != v17);
        v16 = (char *)__p;
      }
      __p = v14;
      v78 = v9;
      v79 = v15;
      if (v16)
        operator delete(v16);
    }
    else
    {
      *(_QWORD *)v78 = v80;
      v9 = v8 + 8;
    }
    v78 = v9;
  }
  while ((*(unsigned int (**)(_QWORD, __int128 *, __int128 *, _QWORD))(**(_QWORD **)(a1[14] + 8) + 736))(*(_QWORD *)(a1[14] + 8), &v83, &v83, 0))
  {
    *(_OWORD *)time1 = v83;
    *(_QWORD *)&time1[16] = v84;
    time2 = v82;
    if (CMTimeCompare((CMTime *)time1, &time2) > 0)
      break;
    v19 = *(_QWORD *)(a1[14] + 8);
    (*(void (**)(_BYTE *__return_ptr, _QWORD *, __int128 *))(*a1 + 328))(time1, a1, &v83);
    if ((*(unsigned int (**)(uint64_t, _BYTE *, uint64_t *))(*(_QWORD *)v19 + 696))(v19, time1, &v80))
    {
      v20 = v78;
      if (v78 >= v79)
      {
        v22 = (v78 - (_BYTE *)__p) >> 3;
        if ((unint64_t)(v22 + 1) >> 61)
          goto LABEL_80;
        v23 = (v79 - (_BYTE *)__p) >> 2;
        if (v23 <= v22 + 1)
          v23 = v22 + 1;
        if ((unint64_t)(v79 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
          v24 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v24 = v23;
        if (v24)
          v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v79, v24);
        else
          v25 = 0;
        v26 = &v25[8 * v22];
        *(_QWORD *)v26 = v80;
        v21 = v26 + 8;
        v28 = (char *)__p;
        v27 = v78;
        if (v78 != __p)
        {
          do
          {
            v29 = *((_QWORD *)v27 - 1);
            v27 -= 8;
            *((_QWORD *)v26 - 1) = v29;
            v26 -= 8;
          }
          while (v27 != v28);
          v27 = (char *)__p;
        }
        __p = v26;
        v78 = v21;
        v79 = &v25[8 * v24];
        if (v27)
          operator delete(v27);
      }
      else
      {
        *(_QWORD *)v78 = v80;
        v21 = v20 + 8;
      }
      v78 = v21;
    }
  }
  v30 = __p;
  if (v78 == __p)
  {
    v39 = v75;
  }
  else
  {
    v31 = 0;
    v32 = 0;
    do
    {
      v33 = v30[v31];
      (*(void (**)(_QWORD, uint64_t, _BYTE *, _BYTE *))(**(_QWORD **)(a1[14] + 8) + 752))(*(_QWORD *)(a1[14] + 8), v33, time1, &time1[24]);
      (*(void (**)(_QWORD, uint64_t, __int128 *))(**(_QWORD **)(a1[14] + 8) + 864))(*(_QWORD *)(a1[14] + 8), v33, &v70);
      (*(void (**)(_QWORD, uint64_t, char *))(**(_QWORD **)(a1[14] + 8) + 952))(*(_QWORD *)(a1[14] + 8), v33, (char *)&v73 + 8);
      (*(void (**)(_QWORD, uint64_t, char *, _QWORD))(**(_QWORD **)(a1[14] + 8) + 1072))(*(_QWORD *)(a1[14] + 8), v33, (char *)&v73 + 4, 0);
      (*(void (**)(_QWORD, uint64_t, __int128 *))(**(_QWORD **)(a1[14] + 8) + 840))(*(_QWORD *)(a1[14] + 8), v33, &v73);
      (*(void (**)(_QWORD, uint64_t, char *))(**(_QWORD **)(a1[14] + 8) + 1056))(*(_QWORD *)(a1[14] + 8), v33, (char *)&v70 + 8);
      (*(void (**)(_QWORD, uint64_t, __int128 *, __int128 *))(**(_QWORD **)(a1[14] + 8) + 1000))(*(_QWORD *)(a1[14] + 8), v33, &v71, &v72);
      (*(void (**)(_QWORD, uint64_t, char *, char *))(**(_QWORD **)(a1[14] + 8) + 1008))(*(_QWORD *)(a1[14] + 8), v33, (char *)&v71 + 8, (char *)&v72 + 8);
      v34 = v75;
      if (v75 >= v76)
      {
        v40 = (char *)v74;
        v41 = 0xAAAAAAAAAAAAAAABLL * ((v75 - (_BYTE *)v74) >> 5);
        v42 = v41 + 1;
        if (v41 + 1 > 0x2AAAAAAAAAAAAAALL)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        if (0x5555555555555556 * ((v76 - (_BYTE *)v74) >> 5) > v42)
          v42 = 0x5555555555555556 * ((v76 - (_BYTE *)v74) >> 5);
        if (0xAAAAAAAAAAAAAAABLL * ((v76 - (_BYTE *)v74) >> 5) >= 0x155555555555555)
          v43 = 0x2AAAAAAAAAAAAAALL;
        else
          v43 = v42;
        if (v43)
        {
          v44 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<_OZKeyframeInfo>>((uint64_t)&v76, v43);
          v40 = (char *)v74;
          v34 = v75;
        }
        else
        {
          v44 = 0;
        }
        v45 = &v44[96 * v41];
        v46 = *(_OWORD *)&time1[16];
        *(_OWORD *)v45 = *(_OWORD *)time1;
        *((_OWORD *)v45 + 1) = v46;
        v47 = v70;
        v48 = v71;
        v49 = v73;
        *((_OWORD *)v45 + 4) = v72;
        *((_OWORD *)v45 + 5) = v49;
        *((_OWORD *)v45 + 2) = v47;
        *((_OWORD *)v45 + 3) = v48;
        if (v34 == v40)
        {
          v55 = &v44[96 * v41];
        }
        else
        {
          v50 = &v44[96 * v41];
          do
          {
            v51 = *((_OWORD *)v34 - 5);
            *((_OWORD *)v50 - 6) = *((_OWORD *)v34 - 6);
            *((_OWORD *)v50 - 5) = v51;
            v52 = *((_OWORD *)v34 - 4);
            v53 = *((_OWORD *)v34 - 3);
            v54 = *((_OWORD *)v34 - 1);
            v55 = v50 - 96;
            *((_OWORD *)v50 - 2) = *((_OWORD *)v34 - 2);
            *((_OWORD *)v50 - 1) = v54;
            *((_OWORD *)v50 - 4) = v52;
            *((_OWORD *)v50 - 3) = v53;
            v34 -= 96;
            v50 -= 96;
          }
          while (v34 != v40);
        }
        v39 = v45 + 96;
        v74 = v55;
        v75 = v45 + 96;
        v76 = &v44[96 * v43];
        if (v40)
          operator delete(v40);
      }
      else
      {
        v35 = *(_OWORD *)&time1[16];
        *(_OWORD *)v75 = *(_OWORD *)time1;
        *((_OWORD *)v34 + 1) = v35;
        v36 = v70;
        v37 = v71;
        v38 = v73;
        *((_OWORD *)v34 + 4) = v72;
        *((_OWORD *)v34 + 5) = v38;
        *((_OWORD *)v34 + 2) = v36;
        *((_OWORD *)v34 + 3) = v37;
        v39 = v34 + 96;
      }
      v75 = v39;
      v30 = __p;
      v31 = ++v32;
    }
    while (v32 < (unint64_t)((v78 - (_BYTE *)__p) >> 3));
  }
  if (v39 != v74)
  {
    time2.value = (CMTimeValue)a1;
    *(_QWORD *)&time2.timescale = 0;
    time2.epoch = 0;
    v68 = 0;
    std::vector<_OZKeyframeInfo>::__init_with_size[abi:ne180100]<_OZKeyframeInfo*,_OZKeyframeInfo*>(&time2.timescale, v74, (uint64_t)v39, 0xAAAAAAAAAAAAAAABLL * ((v39 - (_BYTE *)v74) >> 5));
    v56 = a3[2];
    v57 = a3[1];
    if (v57 >= v56)
    {
      v58 = (uint64_t)(v57 - *a3) >> 5;
      v59 = v58 + 1;
      if ((unint64_t)(v58 + 1) >> 59)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v60 = v56 - *a3;
      if (v60 >> 4 > v59)
        v59 = v60 >> 4;
      if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFE0)
        v61 = 0x7FFFFFFFFFFFFFFLL;
      else
        v61 = v59;
      *(_QWORD *)&v70 = a3 + 2;
      v62 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LiPolygon::PosEdge>>((uint64_t)(a3 + 2), v61);
      v63 = (CMTimeValue *)&v62[32 * v58];
      *(_QWORD *)time1 = v62;
      *(_QWORD *)&time1[8] = v63;
      *(_QWORD *)&time1[24] = &v62[32 * v64];
      *v63 = time2.value;
      v63[1] = 0;
      v63[2] = 0;
      v63[3] = 0;
      *(_OWORD *)(v63 + 1) = *(_OWORD *)&time2.timescale;
      v63[3] = v68;
      *(_QWORD *)&time2.timescale = 0;
      time2.epoch = 0;
      v68 = 0;
      *(_QWORD *)&time1[16] = v63 + 4;
      std::vector<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>>::__swap_out_circular_buffer(a3, time1);
      v65 = a3[1];
      std::__split_buffer<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>>::~__split_buffer((uint64_t)time1);
      v66 = *(void **)&time2.timescale;
      a3[1] = v65;
      if (v66)
      {
        time2.epoch = (CMTimeEpoch)v66;
        operator delete(v66);
      }
    }
    else
    {
      *(_QWORD *)(v57 + 8) = 0;
      *(_QWORD *)(v57 + 16) = 0;
      *(_QWORD *)(v57 + 24) = 0;
      *(CMTime *)v57 = time2;
      *(_QWORD *)(v57 + 24) = v68;
      a3[1] = v57 + 32;
    }
    v39 = (char *)v74;
  }
  if (v39)
  {
    v75 = v39;
    operator delete(v39);
  }
  if (__p)
  {
    v78 = (char *)__p;
    operator delete(__p);
  }
}

void sub_1B2C23C88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36)
{
  std::__split_buffer<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>>::~__split_buffer((uint64_t)&a19);
  if (__p)
    operator delete(__p);
  if (a32)
  {
    a33 = (uint64_t)a32;
    operator delete(a32);
  }
  if (a35)
  {
    a36 = (uint64_t)a35;
    operator delete(a35);
  }
  _Unwind_Resume(a1);
}

uint64_t OZChannel::setKeyframesWithInfo(OZChannelBase *a1, CMTime *a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  double v11;
  int v12;
  unint64_t v13;
  double v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  CMTimeEpoch v21;
  uint64_t v22;
  uint64_t v23;
  CMTimeEpoch v24;
  double v25;
  uint64_t v26;
  CMTimeEpoch v27;
  double v28;
  CMTimeValue value;
  uint64_t v30;
  CMTimeEpoch v31;
  double v32;
  CMTimeValue v33;
  __n128 v34;
  __n128 v35;
  double v37;
  CMTime v38;
  CMTime v39;
  CMTime v40;
  uint64_t v41;
  CMTime v42;
  CMTime v43;

  result = OZChannelBase::isLocked(a1, 0);
  if ((result & 1) == 0)
  {
    result = (uint64_t)a1[1].var0;
    if (result && *(_BYTE *)(result + 32))
    {
      result = (uint64_t)OZChannelImpl::createLocalCopy((OZChannelImpl *)result);
      a1[1].var0 = (void **)result;
    }
    v7 = *a3;
    if (a3[1] != *a3)
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = v7 + 96 * v8;
        v40 = *(CMTime *)v10;
        v41 = 0;
        v11 = *(double *)(v10 + 24);
        v12 = *(unsigned __int8 *)(v10 + 32);
        v14 = *(double *)(v10 + 40);
        v13 = *(_QWORD *)(v10 + 48);
        v15 = *(_QWORD *)(v10 + 56);
        v16 = *(_QWORD *)(v10 + 64);
        v17 = *(_QWORD *)(v10 + 72);
        v18 = *(unsigned int *)(v10 + 80);
        v19 = *(unsigned int *)(v10 + 84);
        v20 = *(double *)(v10 + 88);
        v43 = v40;
        v21 = *(_QWORD *)(v7 + 16);
        *(_OWORD *)&v42.value = *(_OWORD *)v7;
        v42.epoch = v21;
        PC_CMTimeSaferSubtract(&v43, &v42, (uint64_t)&v38);
        v43 = *a2;
        v42 = v38;
        PC_CMTimeSaferAdd(&v43, &v42, (uint64_t)&v39);
        OZChannel::setKeyframe((OZChannel *)a1, &v39, v11, 0);
        v22 = *((_QWORD *)a1[1].var0 + 1);
        v23 = *a3;
        v43 = v40;
        v24 = *(_QWORD *)(v23 + 16);
        *(_OWORD *)&v42.value = *(_OWORD *)v23;
        v42.epoch = v24;
        PC_CMTimeSaferSubtract(&v43, &v42, (uint64_t)&v38);
        v43 = *a2;
        v42 = v38;
        v25 = PC_CMTimeSaferAdd(&v43, &v42, (uint64_t)&v39);
        (*(void (**)(uint64_t, CMTime *, uint64_t *, double))(*(_QWORD *)v22 + 696))(v22, &v39, &v41, v25);
        (*(void (**)(_QWORD, uint64_t, BOOL, uint64_t))(**((_QWORD **)a1[1].var0 + 1) + 856))(*((_QWORD *)a1[1].var0 + 1), v41, v12 != 0, 1);
        (*(void (**)(_QWORD, uint64_t, uint64_t, double))(**((_QWORD **)a1[1].var0 + 1) + 960))(*((_QWORD *)a1[1].var0 + 1), v41, 1, v20);
        (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(**((_QWORD **)a1[1].var0 + 1) + 1064))(*((_QWORD *)a1[1].var0 + 1), v41, v19, 1);
        (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(**((_QWORD **)a1[1].var0 + 1) + 848))(*((_QWORD *)a1[1].var0 + 1), v41, v18, 1);
        (*(void (**)(_QWORD, uint64_t, double))(**((_QWORD **)a1[1].var0 + 1) + 1048))(*((_QWORD *)a1[1].var0 + 1), v41, v14);
        v26 = *a3;
        v43 = v40;
        v27 = *(_QWORD *)(v26 + 16);
        *(_OWORD *)&v42.value = *(_OWORD *)v26;
        v42.epoch = v27;
        PC_CMTimeSaferSubtract(&v43, &v42, (uint64_t)&v38);
        v43 = *a2;
        v42 = v38;
        v28 = PC_CMTimeSaferAdd(&v43, &v42, (uint64_t)&v39);
        v43.value = 0;
        (*(void (**)(_QWORD, CMTime *, CMTime *, double))(**((_QWORD **)a1[1].var0 + 1) + 712))(*((_QWORD *)a1[1].var0 + 1), &v39, &v43, v28);
        value = v43.value;
        v37 = 0.0;
        (*(void (**)(_QWORD, CMTimeValue, _QWORD, double *))(**((_QWORD **)a1[1].var0 + 1) + 752))(*((_QWORD *)a1[1].var0 + 1), v43.value, 0, &v37);
        v30 = *a3;
        v43 = v40;
        v31 = *(_QWORD *)(v30 + 16);
        *(_OWORD *)&v42.value = *(_OWORD *)v30;
        v42.epoch = v31;
        PC_CMTimeSaferSubtract(&v43, &v42, (uint64_t)&v38);
        v43 = *a2;
        v42 = v38;
        v32 = PC_CMTimeSaferAdd(&v43, &v42, (uint64_t)&v39);
        v43.value = 0;
        (*(void (**)(_QWORD, CMTime *, CMTime *, double))(**((_QWORD **)a1[1].var0 + 1) + 728))(*((_QWORD *)a1[1].var0 + 1), &v39, &v43, v32);
        v33 = v43.value;
        v43.value = 0;
        result = (*(uint64_t (**)(_QWORD, CMTimeValue, _QWORD, CMTime *))(**((_QWORD **)a1[1].var0 + 1) + 752))(*((_QWORD *)a1[1].var0 + 1), v33, 0, &v43);
        if (0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 5) > 1 || value && vabdd_f64(v37, v11) >= 0.0000001)
        {
          v34.n128_u64[0] = v13;
          v35.n128_u64[0] = v16;
          result = (*(uint64_t (**)(__n128, __n128))(**((_QWORD **)a1[1].var0 + 1) + 984))(v34, v35);
        }
        else
        {
          if (!v33)
            goto LABEL_16;
          v34.n128_u64[0] = 0;
          v35.n128_u64[0] = 0;
          result = (*(uint64_t (**)(__n128, __n128))(**((_QWORD **)a1[1].var0 + 1) + 1024))(v34, v35);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 5) <= 1
          && (!v33 || vabdd_f64(*(double *)&v43.value, v11) < 0.0000001))
        {
LABEL_16:
          if (value)
          {
            v34.n128_u64[0] = 0;
            v35.n128_u64[0] = 0;
            result = (*(uint64_t (**)(__n128, __n128))(**((_QWORD **)a1[1].var0 + 1) + 1016))(v34, v35);
          }
          goto LABEL_19;
        }
        v34.n128_u64[0] = v15;
        v35.n128_u64[0] = v17;
        result = (*(uint64_t (**)(__n128, __n128))(**((_QWORD **)a1[1].var0 + 1) + 992))(v34, v35);
LABEL_19:
        v8 = v9;
        v7 = *a3;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 5) > v9++);
    }
  }
  return result;
}

BOOL OZChannel::hasKeypoints(OZChannel *this)
{
  return (*(unsigned int (**)(_QWORD))(**((_QWORD **)this->var14 + 1) + 512))(*((_QWORD *)this->var14 + 1)) != 0;
}

BOOL OZChannel::hasMoreThanOneKeypoint(OZChannel *this)
{
  return (*(unsigned int (**)(_QWORD))(**((_QWORD **)this->var14 + 1) + 512))(*((_QWORD *)this->var14 + 1)) > 1;
}

uint64_t OZChannel::hasKeypointAt(OZChannel *this, const CMTime *a2)
{
  uint64_t v2;
  _QWORD v4[3];
  uint64_t v5;

  v5 = 0;
  v2 = *((_QWORD *)this->var14 + 1);
  (*((void (**)(_QWORD *__return_ptr))this->var0 + 41))(v4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t *))(*(_QWORD *)v2 + 696))(v2, v4, &v5);
}

uint64_t OZChannel::allHaveKeypointsAt(OZChannel *this, const CMTime *a2)
{
  uint64_t v2;
  _QWORD v4[3];
  uint64_t v5;

  v5 = 0;
  v2 = *((_QWORD *)this->var14 + 1);
  (*((void (**)(_QWORD *__return_ptr))this->var0 + 41))(v4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t *))(*(_QWORD *)v2 + 696))(v2, v4, &v5);
}

uint64_t OZChannel::numberOfKeypointsAt(OZChannel *this, const CMTime *a2)
{
  uint64_t v2;
  _QWORD v4[3];
  uint64_t v5;

  v5 = 0;
  v2 = *((_QWORD *)this->var14 + 1);
  (*((void (**)(_QWORD *__return_ptr))this->var0 + 41))(v4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t *))(*(_QWORD *)v2 + 696))(v2, v4, &v5);
}

uint64_t OZChannel::addKeypointAt(OZChannel *this, const CMTime *a2)
{
  OZChannelFolder *var6;
  void *v5;
  uint64_t result;
  OZChannelImpl *var14;
  uint64_t v8;
  _QWORD v9[3];

  var6 = this->var6;
  if (var6
    && (*(unsigned int (**)(OZChannelFolder *))(*(_QWORD *)var6 + 120))(var6)
    && OZChannelFolder::testFoldFlag(this->var6, 0x100000))
  {
    return (*(uint64_t (**)(void *, OZChannel *, const CMTime *, _QWORD))(*(_QWORD *)v5 + 752))(v5, this, a2, 0);
  }
  else
  {
    result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
    if ((result & 1) == 0)
    {
      (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
      var14 = this->var14;
      if (var14 && *((_BYTE *)var14 + 32))
        this->var14 = OZChannelImpl::createLocalCopy(var14);
      if (((*((uint64_t (**)(OZChannel *))this->var0 + 61))(this) & 1) == 0)
        (*((void (**)(OZChannel *, uint64_t))this->var0 + 60))(this, 1);
      v8 = *((_QWORD *)this->var14 + 1);
      (*((void (**)(_QWORD *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(v9, this, a2);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)v8 + 544))(v8, v9, 1);
    }
  }
  return result;
}

uint64_t OZChannel::deleteKeypointAt(OZChannel *this, const CMTime *a2)
{
  OZChannelFolder *var6;
  void *v5;
  uint64_t result;
  OZChannelImpl *var14;
  uint64_t v8;
  _QWORD v9[3];
  uint64_t v10;

  var6 = this->var6;
  if (var6
    && (*(unsigned int (**)(OZChannelFolder *))(*(_QWORD *)var6 + 120))(var6)
    && OZChannelFolder::testFoldFlag(this->var6, 0x100000))
  {
    return (*(uint64_t (**)(void *, OZChannel *, const CMTime *, _QWORD))(*(_QWORD *)v5 + 768))(v5, this, a2, 0);
  }
  else
  {
    result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
    if ((result & 1) == 0)
    {
      (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
      var14 = this->var14;
      if (*((_BYTE *)var14 + 32))
      {
        var14 = OZChannelImpl::createLocalCopy(var14);
        this->var14 = var14;
      }
      v10 = 0;
      v8 = *((_QWORD *)var14 + 1);
      (*((void (**)(_QWORD *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(v9, this, a2);
      result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t *))(*(_QWORD *)v8 + 696))(v8, v9, &v10);
      if (v10)
        return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this->var14 + 1) + 672))(*((_QWORD *)this->var14 + 1), v10, 1);
    }
  }
  return result;
}

uint64_t OZChannel::deleteKeypoints(OZChannel *this, const CMTime *a2, const CMTime *a3)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (var14)
    {
      if (*((_BYTE *)var14 + 32))
        this->var14 = OZChannelImpl::createLocalCopy(var14);
    }
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    return (*(uint64_t (**)(_QWORD, const CMTime *, const CMTime *, uint64_t))(**((_QWORD **)this->var14 + 1)
                                                                                      + 680))(*((_QWORD *)this->var14 + 1), a2, a3, 1);
  }
  return result;
}

uint64_t OZChannel::previousKeypoint(OZChannel *this, CMTime *a2)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v7;
  CMTimeEpoch v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;

  v10 = *MEMORY[0x1E0CA2E68];
  v11 = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
  v9 = 0;
  v4 = *((_QWORD *)this->var14 + 1);
  (*((void (**)(__int128 *__return_ptr))this->var0 + 41))(&v7);
  v5 = (*(uint64_t (**)(uint64_t, __int128 *, __int128 *, uint64_t *))(*(_QWORD *)v4 + 744))(v4, &v7, &v10, &v9);
  if ((_DWORD)v5)
  {
    (*((void (**)(__int128 *__return_ptr, OZChannel *, __int128 *))this->var0 + 42))(&v7, this, &v10);
    *(_OWORD *)&a2->value = v7;
    a2->epoch = v8;
  }
  return v5;
}

uint64_t OZChannel::nextKeypoint(OZChannel *this, CMTime *a2)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v7;
  CMTimeEpoch v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;

  v10 = *MEMORY[0x1E0CA2E68];
  v11 = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
  v9 = 0;
  v4 = *((_QWORD *)this->var14 + 1);
  (*((void (**)(__int128 *__return_ptr))this->var0 + 41))(&v7);
  v5 = (*(uint64_t (**)(uint64_t, __int128 *, __int128 *, uint64_t *))(*(_QWORD *)v4 + 736))(v4, &v7, &v10, &v9);
  if ((_DWORD)v5)
  {
    (*((void (**)(__int128 *__return_ptr, OZChannel *, __int128 *))this->var0 + 42))(&v7, this, &v10);
    *(_OWORD *)&a2->value = v7;
    a2->epoch = v8;
  }
  return v5;
}

_QWORD *OZChannel::moveKeypointTo@<X0>(OZChannel *this@<X0>, const CMTime *a2@<X1>, const CMTime *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  OZChannelFolder *var6;
  void *v12;
  _QWORD *result;
  CMTimeEpoch epoch;
  OZChannelImpl *var14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CMTime v19;
  uint64_t v20;
  CMTime v21;

  v21 = *a3;
  var6 = this->var6;
  if (var6
    && (*(unsigned int (**)(OZChannelFolder *))(*(_QWORD *)var6 + 120))(var6)
    && OZChannelFolder::testFoldFlag(this->var6, 0x100000))
  {
    return (_QWORD *)(*(uint64_t (**)(void *, OZChannel *, const CMTime *, CMTime *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v12 + 760))(v12, this, a2, &v21, a4, a5, 0);
  }
  else
  {
    result = (_QWORD *)OZChannelBase::isLocked((OZChannelBase *)this, 0);
    if ((_DWORD)result)
    {
      *(_OWORD *)a6 = *(_OWORD *)&a2->value;
      epoch = a2->epoch;
    }
    else
    {
      v20 = 0;
      (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
      var14 = this->var14;
      if (var14 && *((_BYTE *)var14 + 32))
        this->var14 = OZChannelImpl::createLocalCopy(var14);
      if (((*((uint64_t (**)(OZChannel *))this->var0 + 61))(this) & 1) == 0)
        (*((void (**)(OZChannel *, uint64_t))this->var0 + 60))(this, 1);
      v16 = *((_QWORD *)this->var14 + 1);
      (*((void (**)(CMTime *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(&v19, this, a2);
      result = (_QWORD *)(*(uint64_t (**)(uint64_t, CMTime *, uint64_t *))(*(_QWORD *)v16 + 696))(v16, &v19, &v20);
      v17 = v20;
      if (v20)
      {
        v18 = *((_QWORD *)this->var14 + 1);
        (*((void (**)(CMTime *__return_ptr, OZChannel *, CMTime *))this->var0 + 41))(&v19, this, &v21);
        (*(void (**)(uint64_t, uint64_t, CMTime *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v18 + 656))(v18, v17, &v19, 1, a5, a4);
        (*(void (**)(_QWORD, uint64_t, CMTime *, _QWORD))(**((_QWORD **)this->var14 + 1) + 752))(*((_QWORD *)this->var14 + 1), v20, &v21, 0);
        result = (*((_QWORD *(**)(CMTime *__return_ptr, OZChannel *, CMTime *))this->var0 + 42))(&v19, this, &v21);
        v21 = v19;
      }
      *(_OWORD *)a6 = *(_OWORD *)&v21.value;
      epoch = v21.epoch;
    }
    *(_QWORD *)(a6 + 16) = epoch;
  }
  return result;
}

uint64_t OZChannel::retimeKeypoints(OZChannel *this, double a2, const CMTime *a3)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    var14 = this->var14;
    if (var14 && *((_BYTE *)var14 + 32))
      this->var14 = OZChannelImpl::createLocalCopy(var14);
    result = OZChannelBase::testFlag((OZChannelBase *)this, 0x20000);
    if ((result & 1) == 0)
      return (*(uint64_t (**)(_QWORD, const CMTime *, uint64_t, double))(**((_QWORD **)this->var14 + 1) + 456))(*((_QWORD *)this->var14 + 1), a3, 1, a2);
  }
  return result;
}

uint64_t OZChannel::adjustToFrameDuration(OZChannel *this, const CMTime *a2)
{
  OZChannelImpl *var14;

  var14 = this->var14;
  if (*((_BYTE *)var14 + 32))
  {
    var14 = OZChannelImpl::createLocalCopy(var14);
    this->var14 = var14;
  }
  return (*(uint64_t (**)(_QWORD, const CMTime *, _QWORD))(**((_QWORD **)var14 + 1) + 464))(*((_QWORD *)var14 + 1), a2, MEMORY[0x1E0CA2E68]);
}

void OZChannel::bake(OZChannel *this, const PCTimeRange *a2, const CMTime *a3)
{
  _QWORD *v4;
  void *ChannelRootBase;
  OZChannelImpl *var14;
  uint64_t v7;
  double v8;
  OZChannelInfo *var16;
  double v10;
  double v11;
  OZChannelFolder *var6;
  _QWORD *p_var0;
  uint64_t v14;
  uint64_t v15;
  char v16[24];
  char v17[24];
  double v18;
  double v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;

  if ((OZChannelBase::isLocked((OZChannelBase *)this, 0) & 1) == 0)
  {
    v21 = 0;
    v22 = 0;
    v20 = 0;
    (*(void (**)(_QWORD, _QWORD **))(**((_QWORD **)this->var14 + 1) + 1144))(*((_QWORD *)this->var14 + 1), &v20);
    v4 = v20;
    if (v21 != v20)
    {
      ChannelRootBase = OZChannelBase::getChannelRootBase((OZChannelBase *)this);
      if (ChannelRootBase
        && (*(unsigned int (**)(void *, OZChannel *, uint64_t))(*(_QWORD *)ChannelRootBase + 808))(ChannelRootBase, this, 1))
      {
        (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
        var14 = this->var14;
        if (*((_BYTE *)var14 + 32))
        {
          var14 = OZChannelImpl::createLocalCopy(var14);
          this->var14 = var14;
        }
        v7 = *(v21 - 1);
        v18 = 0.0;
        v19 = 0.0;
        (*(void (**)(_QWORD, double *, _QWORD))(**((_QWORD **)var14 + 1) + 240))(*((_QWORD *)var14 + 1), &v19, 0);
        (*(void (**)(_QWORD, double *, _QWORD))(**((_QWORD **)this->var14 + 1) + 248))(*((_QWORD *)this->var14 + 1), &v18, 0);
        v8 = vabdd_f64(v19, v18);
        if (v8 >= 0.0000001)
        {
          v10 = v8 * 0.005;
          var16 = this->var16;
        }
        else
        {
          var16 = this->var16;
          v10 = *((double *)var16 + 3);
        }
        if (v10 <= *((double *)var16 + 4))
          v11 = v10;
        else
          v11 = *((double *)var16 + 4);
        var6 = this->var6;
        if (var6
        {
          v14 = 108;
        }
        else
        {
          v14 = 102;
          p_var0 = &this->var0;
        }
        (*(void (**)(void))(*p_var0 + 8 * v14))();
        (*(void (**)(_QWORD, uint64_t, char *, uint64_t *, char *, double, double))(**((_QWORD **)this->var14
                                                                                              + 1)
                                                                                           + 360))(*((_QWORD *)this->var14 + 1), v7, v17, &v15, v16, v11, *((double *)this->var16 + 5));
      }
      v4 = v20;
    }
    if (v4)
    {
      v21 = v4;
      operator delete(v4);
    }
  }
}

void sub_1B2C24C70(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 72);
  if (v3)
  {
    *(_QWORD *)(v1 - 64) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double OZChannel::getBakeParameters(OZChannel *this, const PCTimeRange *a2, CMTime *a3, CMTime *a4, CMTime *a5)
{
  double v10;
  void *ChannelRootBase;
  double result;
  _BYTE v13[24];
  CMTime v14;
  CMTime v15;

  v14 = *(CMTime *)a2;
  (*((void (**)(CMTime *__return_ptr, OZChannel *, CMTime *))this->var0 + 41))(&v15, this, &v14);
  *a3 = v15;
  v15 = *(CMTime *)a2;
  v14 = *(CMTime *)((_BYTE *)a2 + 1);
  v10 = PC_CMTimeSaferAdd(&v15, &v14, (uint64_t)v13);
  (*((void (**)(CMTime *__return_ptr, OZChannel *, _BYTE *, double))this->var0 + 41))(&v15, this, v13, v10);
  *a4 = v15;
  ChannelRootBase = OZChannelBase::getChannelRootBase((OZChannelBase *)this);
  if (ChannelRootBase)
    (*(void (**)(CMTime *__return_ptr))(*(_QWORD *)ChannelRootBase + 880))(&v15);
  else
    CMTimeMake(&v15, 1, 30);
  result = *(double *)&v15.value;
  *a5 = v15;
  return result;
}

uint64_t OZChannel::simplify(OZChannel *this, const CMTime *a2, const CMTime *a3, const CMTime *a4, double a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t result;
  OZChannelImpl *var14;
  double v18;
  double v19;
  uint64_t v20;
  _QWORD v21[3];
  _QWORD v22[3];
  double v23;
  double v24;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    v23 = 0.0;
    v24 = 0.0;
    (*(void (**)(_QWORD, double *, _QWORD))(**((_QWORD **)var14 + 1) + 240))(*((_QWORD *)var14 + 1), &v24, 0);
    (*(void (**)(_QWORD, double *, _QWORD))(**((_QWORD **)this->var14 + 1) + 248))(*((_QWORD *)this->var14 + 1), &v23, 0);
    v18 = vabdd_f64(v24, v23);
    if (v18 >= 0.0000001)
    {
      v19 = a5 / 100.0 * v18;
      if (!a8)
      {
LABEL_10:
        v20 = *((_QWORD *)this->var14 + 1);
        (*((void (**)(_QWORD *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(v22, this, a2);
        (*((void (**)(_QWORD *__return_ptr, OZChannel *, const CMTime *))this->var0 + 41))(v21, this, a3);
        return (*(uint64_t (**)(uint64_t, _QWORD *, _QWORD *, const CMTime *, uint64_t, uint64_t, double, double))(*(_QWORD *)v20 + 496))(v20, v22, v21, a4, a6, a7, v19, *((double *)this->var16 + 5));
      }
    }
    else
    {
      v19 = *((double *)this->var16 + 3);
      if (!a8)
        goto LABEL_10;
    }
    if (v19 > *((double *)this->var16 + 4))
      v19 = *((double *)this->var16 + 4);
    goto LABEL_10;
  }
  return result;
}

uint64_t OZChannel::generateKeys(OZChannel *this, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(**((_QWORD **)var14 + 1) + 824))(*((_QWORD *)var14 + 1), a2, a3, 1);
  }
  return result;
}

BOOL OZChannel::getCurrentMinAndMax(OZChannel *this, CMTime *a2, CMTime *a3, unint64_t a4, unint64_t a5)
{
  _BOOL8 v5;
  OZChannelSegmentVisitor *v11;
  const PCString *v12;
  CMTime v14[3];

  v5 = (a4 | a5) != 0;
  if (a4 | a5)
  {
    OZChannelSegmentVisitor::OZChannelSegmentVisitor((OZChannelSegmentVisitor *)v14);
    v14[0].value = (CMTimeValue)&off_1E6554118;
    *(_OWORD *)&v14[0].timescale = xmmword_1B3556390;
    OZChannelSegmentVisitor::visitSegments(this, a2, a3, v14, v11);
    if (a4)
      *(_QWORD *)a4 = *(_QWORD *)&v14[0].timescale;
    if (a5)
      *(_QWORD *)a5 = v14[0].epoch;
    OZChannelBase::setRangeName((OZChannelBase *)v14, v12);
  }
  return v5;
}

void sub_1B2C2505C(_Unwind_Exception *a1, const PCString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  OZChannelBase::setRangeName((OZChannelBase *)&a10, a2);
  _Unwind_Resume(a1);
}

OZChannelImpl *OZChannel::setOwnerChannel(OZChannel *this, OZChannel *a2)
{
  OZChannelImpl *result;
  uint64_t v4;

  result = this->var14;
  v4 = *((_QWORD *)result + 1);
  if (*(OZChannel **)(v4 + 152) != a2)
  {
    if (*((_BYTE *)result + 32))
    {
      result = OZChannelImpl::createLocalCopy(result);
      this->var14 = result;
      v4 = *((_QWORD *)result + 1);
    }
    *(_QWORD *)(v4 + 152) = a2;
  }
  return result;
}

uint64_t OZChannel::setParametric(OZChannel *this, uint64_t a2)
{
  uint64_t result;
  OZChannelImpl *var14;
  char v6;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    v6 = 0;
    result = (*(uint64_t (**)(_QWORD, char *))(**((_QWORD **)this->var14 + 1) + 112))(*((_QWORD *)this->var14 + 1), &v6);
    if ((v6 != 0) != (_DWORD)a2)
    {
      var14 = this->var14;
      if (*((_BYTE *)var14 + 32))
      {
        var14 = OZChannelImpl::createLocalCopy(var14);
        this->var14 = var14;
      }
      return (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)var14 + 1) + 104))(*((_QWORD *)var14 + 1), a2);
    }
  }
  return result;
}

uint64_t OZChannel::isParametric(OZChannel *this)
{
  unsigned __int8 v2;

  v2 = 0;
  (*(void (**)(_QWORD, unsigned __int8 *))(**((_QWORD **)this->var14 + 1) + 112))(*((_QWORD *)this->var14 + 1), &v2);
  return v2;
}

uint64_t OZChannel::setDiscrete(OZChannel *this, uint64_t a2, char a3)
{
  uint64_t result;
  OZChannelImpl *var14;
  char v8;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    v8 = 0;
    result = (*(uint64_t (**)(_QWORD, char *))(**((_QWORD **)this->var14 + 1) + 176))(*((_QWORD *)this->var14 + 1), &v8);
    if ((v8 != 0) != (_DWORD)a2)
    {
      var14 = this->var14;
      if ((a3 & 1) == 0)
      {
        if (*((_BYTE *)var14 + 32))
        {
          var14 = OZChannelImpl::createLocalCopy(var14);
          this->var14 = var14;
        }
      }
      return (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)var14 + 1) + 168))(*((_QWORD *)var14 + 1), a2);
    }
  }
  return result;
}

uint64_t OZChannel::isDiscrete(OZChannel *this)
{
  unsigned __int8 v2;

  v2 = 0;
  (*(void (**)(_QWORD, unsigned __int8 *))(**((_QWORD **)this->var14 + 1) + 176))(*((_QWORD *)this->var14 + 1), &v2);
  return v2;
}

uint64_t OZChannel::setShouldCreateTangents(OZChannel *this, uint64_t a2)
{
  uint64_t result;
  OZChannelImpl *var14;
  unsigned __int8 v6;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    v6 = 0;
    result = (*(uint64_t (**)(_QWORD, unsigned __int8 *))(**((_QWORD **)this->var14 + 1) + 144))(*((_QWORD *)this->var14 + 1), &v6);
    if (v6 != (_DWORD)a2)
    {
      var14 = this->var14;
      if (*((_BYTE *)var14 + 32))
      {
        var14 = OZChannelImpl::createLocalCopy(var14);
        this->var14 = var14;
      }
      return (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)var14 + 1) + 136))(*((_QWORD *)var14 + 1), a2);
    }
  }
  return result;
}

uint64_t OZChannel::reparametrizeChannel(OZChannel *this)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)var14 + 1) + 472))(*((_QWORD *)var14 + 1));
  }
  return result;
}

uint64_t OZChannel::setInterpolation(OZChannel *this, uint64_t a2)
{
  uint64_t result;
  OZChannelImpl *LocalCopy;
  int v6;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    v6 = 0;
    result = (*(uint64_t (**)(_QWORD, int *))(**((_QWORD **)this->var14 + 1) + 304))(*((_QWORD *)this->var14 + 1), &v6);
    if (v6 != (_DWORD)a2)
    {
      (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
      LocalCopy = this->var14;
      if (*((_BYTE *)LocalCopy + 32))
      {
        LocalCopy = OZChannelImpl::createLocalCopy(LocalCopy);
        this->var14 = LocalCopy;
      }
      return (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)LocalCopy + 1) + 296))(*((_QWORD *)LocalCopy + 1), a2);
    }
  }
  return result;
}

uint64_t OZChannel::getInterpolation(OZChannel *this)
{
  unsigned int v2;

  v2 = 0;
  (*(void (**)(_QWORD, unsigned int *))(**((_QWORD **)this->var14 + 1) + 304))(*((_QWORD *)this->var14 + 1), &v2);
  return v2;
}

uint64_t OZChannel::setCustomInterpolator(OZChannelBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  OZChannelImpl *var0;

  result = OZChannelBase::isLocked(a1, 0);
  if ((result & 1) == 0)
  {
    var0 = (OZChannelImpl *)a1[1].var0;
    if (*((_BYTE *)var0 + 32))
    {
      var0 = OZChannelImpl::createLocalCopy(var0);
      a1[1].var0 = (void **)var0;
    }
    return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)var0 + 1) + 320))(*((_QWORD *)var0 + 1), a2, a3);
  }
  return result;
}

uint64_t OZChannel::setExtrapolation(OZChannel *this, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  OZChannelImpl *var14;
  int v8;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    v8 = 0;
    result = (*(uint64_t (**)(_QWORD, int *, uint64_t))(**((_QWORD **)this->var14 + 1) + 336))(*((_QWORD *)this->var14 + 1), &v8, a3);
    if (v8 != (_DWORD)a2)
    {
      (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
      var14 = this->var14;
      if (*((_BYTE *)var14 + 32))
      {
        var14 = OZChannelImpl::createLocalCopy(var14);
        this->var14 = var14;
      }
      return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)var14 + 1) + 328))(*((_QWORD *)var14 + 1), a2, a3);
    }
  }
  return result;
}

uint64_t OZChannel::getExtrapolation(OZChannel *this, uint64_t a2)
{
  unsigned int v3;

  v3 = 0;
  (*(void (**)(_QWORD, unsigned int *, uint64_t))(**((_QWORD **)this->var14 + 1) + 336))(*((_QWORD *)this->var14 + 1), &v3, a2);
  return v3;
}

uint64_t OZChannel::closeParametricCurve(OZChannel *this)
{
  uint64_t result;
  OZChannelImpl *var14;
  char v4;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    v4 = 0;
    result = (*(uint64_t (**)(_QWORD, char *))(**((_QWORD **)this->var14 + 1) + 128))(*((_QWORD *)this->var14 + 1), &v4);
    if (!v4)
    {
      var14 = this->var14;
      if (*((_BYTE *)var14 + 32))
      {
        var14 = OZChannelImpl::createLocalCopy(var14);
        this->var14 = var14;
      }
      return (*(uint64_t (**)(_QWORD))(**((_QWORD **)var14 + 1) + 120))(*((_QWORD *)var14 + 1));
    }
  }
  return result;
}

uint64_t OZChannel::isParametricCurveClosed(OZChannel *this)
{
  unsigned __int8 v2;

  v2 = 0;
  (*(void (**)(_QWORD, unsigned __int8 *))(**((_QWORD **)this->var14 + 1) + 128))(*((_QWORD *)this->var14 + 1), &v2);
  return v2;
}

uint64_t OZChannel::setUseRetimingExtrapolation(OZChannel *this, uint64_t a2)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    result = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)var14 + 1) + 344))(*((_QWORD *)var14 + 1), a2);
    *(_QWORD *)(*((_QWORD *)this->var14 + 1) + 152) = this;
  }
  return result;
}

uint64_t OZChannel::useRetimingExtrapolation(OZChannel *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this->var14 + 1) + 352))(*((_QWORD *)this->var14 + 1));
}

uint64_t OZChannel::resetCurve(OZChannel *this)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    (*(void (**)(_QWORD))(**((_QWORD **)var14 + 1) + 184))(*((_QWORD *)var14 + 1));
    return OZChannel::resetLocalChannelImplementation(this);
  }
  return result;
}

uint64_t OZChannel::getKeyframeMinTime@<X0>(OZChannel *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;

  v3 = MEMORY[0x1E0CA2E68];
  *(_OWORD *)a2 = *MEMORY[0x1E0CA2E68];
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(v3 + 16);
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this->var14 + 1) + 232))(*((_QWORD *)this->var14 + 1));
}

uint64_t OZChannel::getKeyframeMaxTime@<X0>(OZChannel *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;

  v3 = MEMORY[0x1E0CA2E68];
  *(_OWORD *)a2 = *MEMORY[0x1E0CA2E68];
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(v3 + 16);
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this->var14 + 1) + 224))(*((_QWORD *)this->var14 + 1));
}

double OZChannel::getKeyframeMinValue(OZChannel *this, uint64_t a2)
{
  double v3;

  v3 = 0.0;
  (*(void (**)(_QWORD, double *, uint64_t))(**((_QWORD **)this->var14 + 1) + 248))(*((_QWORD *)this->var14 + 1), &v3, a2);
  return v3;
}

double OZChannel::getKeyframeMaxValue(OZChannel *this, uint64_t a2)
{
  double v3;

  v3 = 0.0;
  (*(void (**)(_QWORD, double *, uint64_t))(**((_QWORD **)this->var14 + 1) + 240))(*((_QWORD *)this->var14 + 1), &v3, a2);
  return v3;
}

double OZChannel::getCurveValue(OZChannel *this, const CMTime *a2, int a3)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)*((_QWORD *)this->var14 + 1);
  v4 = 624;
  if (a3)
    v4 = 616;
  (*(void (**)(double))(*v3 + v4))(0.0);
  return 0.0;
}

uint64_t OZChannel::getKeyframe(OZChannel *this, const CMTime *a2)
{
  uint64_t v3;

  v3 = 0;
  (*(void (**)(_QWORD, const CMTime *, uint64_t *))(**((_QWORD **)this->var14 + 1) + 696))(*((_QWORD *)this->var14 + 1), a2, &v3);
  return v3;
}

uint64_t OZChannel::getKeyframeParametricRange@<X0>(OZChannel *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;

  v3 = MEMORY[0x1E0CA2E68];
  *(_OWORD *)a2 = *MEMORY[0x1E0CA2E68];
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(v3 + 16);
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this->var14 + 1) + 288))(*((_QWORD *)this->var14 + 1));
}

uint64_t OZChannel::getSamples(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 112) + 8) + 368))(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8));
}

{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 112) + 8) + 376))(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8));
}

{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 112) + 8) + 392))(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8));
}

uint64_t OZChannel::getSamples(OZChannel *this, double a2, double a3, unsigned int *a4, double **a5, double **a6, double a7)
{
  return (*(uint64_t (**)(_QWORD, unsigned int *, double **, double **, double, double, double))(**((_QWORD **)this->var14 + 1) + 384))(*((_QWORD *)this->var14 + 1), a4, a5, a6, a2, a3, a7);
}

uint64_t OZChannel::getSamples(OZChannel *this, void *a2, const CMTime *a3, const CMTime *a4, unsigned int *a5, CMTime **a6, double **a7)
{
  return (*(uint64_t (**)(_QWORD, void *, const CMTime *, const CMTime *, unsigned int *, CMTime **, double **))(**((_QWORD **)this->var14 + 1) + 400))(*((_QWORD *)this->var14 + 1), a2, a3, a4, a5, a6, a7);
}

uint64_t OZChannel::getSamples(OZChannel *this, const CMTime *a2, const CMTime *a3, unsigned int *a4, CMTime **a5, double **a6)
{
  return (*(uint64_t (**)(_QWORD, const CMTime *, const CMTime *, unsigned int *, CMTime **, double **))(**((_QWORD **)this->var14 + 1) + 408))(*((_QWORD *)this->var14 + 1), a2, a3, a4, a5, a6);
}

double OZChannel::getCurveValueForNode(OZChannel *this, const CMTime *a2, void *a3, double a4)
{
  double v5;

  v5 = 0.0;
  (*(void (**)(_QWORD, const CMTime *, double *, void *, double))(**((_QWORD **)this->var14 + 1) + 632))(*((_QWORD *)this->var14 + 1), a2, &v5, a3, a4);
  return v5;
}

uint64_t OZChannel::setKeyframe(OZChannel *this, const CMTime *a2)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, const CMTime *, uint64_t))(**((_QWORD **)var14 + 1) + 544))(*((_QWORD *)var14 + 1), a2, 1);
  }
  return result;
}

uint64_t OZChannel::setKeyframe(OZChannel *this, void *a2, const CMTime *a3, double a4)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, void *, const CMTime *, uint64_t, double))(**((_QWORD **)var14 + 1) + 560))(*((_QWORD *)var14 + 1), a2, a3, 1, a4);
  }
  return result;
}

uint64_t OZChannel::appendKeyframe(OZChannel *this, const CMTime *a2, double a3)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, const CMTime *, uint64_t, double))(**((_QWORD **)var14 + 1) + 576))(*((_QWORD *)var14 + 1), a2, 1, a3);
  }
  return result;
}

uint64_t OZChannel::appendKeyframes(OZChannel *this, uint64_t a2, CMTime *a3, double *a4)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, uint64_t, CMTime *, double *, uint64_t))(**((_QWORD **)var14 + 1) + 584))(*((_QWORD *)var14 + 1), a2, a3, a4, 1);
  }
  return result;
}

uint64_t OZChannel::setKeyframeValue(OZChannel *this, void *a2, double a3)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, void *, uint64_t, double))(**((_QWORD **)var14 + 1) + 592))(*((_QWORD *)var14 + 1), a2, 1, a3);
  }
  return result;
}

uint64_t OZChannel::setKeyframesValue(OZChannel *this, double a2)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, uint64_t, double))(**((_QWORD **)var14 + 1) + 600))(*((_QWORD *)var14 + 1), 1, a2);
  }
  return result;
}

uint64_t OZChannel::getNumberOfKeyframes(OZChannel *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this->var14 + 1) + 512))(*((_QWORD *)this->var14 + 1));
}

uint64_t OZChannel::getNextEnabledKeyframe(OZChannel *this, void *a2)
{
  uint64_t v3;

  v3 = 0;
  (*(void (**)(_QWORD, void *, uint64_t *))(**((_QWORD **)this->var14 + 1) + 720))(*((_QWORD *)this->var14 + 1), a2, &v3);
  return v3;
}

uint64_t OZChannel::getPreviousEnabledKeyframe(OZChannel *this, void *a2)
{
  uint64_t v3;

  v3 = 0;
  (*(void (**)(_QWORD, void *, uint64_t *))(**((_QWORD **)this->var14 + 1) + 704))(*((_QWORD *)this->var14 + 1), a2, &v3);
  return v3;
}

uint64_t OZChannel::getFirstEnabledKeyframe(OZChannel *this)
{
  uint64_t v2;

  v2 = 0;
  (*(void (**)(_QWORD, uint64_t *))(**((_QWORD **)this->var14 + 1) + 768))(*((_QWORD *)this->var14 + 1), &v2);
  return v2;
}

uint64_t OZChannel::getLastEnabledKeyframe(OZChannel *this)
{
  uint64_t v2;

  v2 = 0;
  (*(void (**)(_QWORD, uint64_t *))(**((_QWORD **)this->var14 + 1) + 784))(*((_QWORD *)this->var14 + 1), &v2);
  return v2;
}

uint64_t OZChannel::hasDifferentValuesForRange(OZChannel *this, CMTimeRange *a2)
{
  uint64_t v3;
  __int128 v4;
  char *v5;
  char v6;
  double v7;
  __int128 v8;
  double v9;
  uint64_t v10;
  CMTimeRange v12;
  CMTime v13;
  CMTime v14;
  CMTime time2;
  CMTime time1;
  char *v17;
  char *v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v17 = 0;
  v18 = 0;
  v19 = 0;
  v3 = *((_QWORD *)this->var14 + 1);
  v4 = *(_OWORD *)&a2->start.epoch;
  v20 = *(_OWORD *)&a2->start.value;
  v21 = v4;
  v22 = *(_OWORD *)&a2->duration.timescale;
  if (!(*(unsigned int (**)(uint64_t, __int128 *, char **, _QWORD, _QWORD))(*(_QWORD *)v3 + 808))(v3, &v20, &v17, 0, 0))
  {
LABEL_12:
    v10 = 0;
    goto LABEL_13;
  }
  v5 = v17;
  if (v17 == v18)
  {
    v10 = 0;
    if (v17)
      goto LABEL_14;
    return v10;
  }
  v6 = 1;
  v7 = 0.0;
  while (1)
  {
    v20 = *(_OWORD *)v5;
    *(_QWORD *)&v21 = *((_QWORD *)v5 + 2);
    *(_OWORD *)&time1.value = v20;
    time1.epoch = v21;
    time2 = a2->start;
    if (CMTimeCompare(&time1, &time2) < 0)
      goto LABEL_10;
    *(_OWORD *)&v14.value = v20;
    v14.epoch = v21;
    v8 = *(_OWORD *)&a2->start.epoch;
    *(_OWORD *)&v12.start.value = *(_OWORD *)&a2->start.value;
    *(_OWORD *)&v12.start.epoch = v8;
    *(_OWORD *)&v12.duration.timescale = *(_OWORD *)&a2->duration.timescale;
    CMTimeRangeGetEnd(&v13, &v12);
    if (CMTimeCompare(&v14, &v13) > 0)
      goto LABEL_10;
    v9 = *((double *)v5 + 3);
    if ((v6 & 1) == 0)
      break;
    v6 = 0;
LABEL_11:
    v5 += 40;
    v7 = v9;
    if (v5 == v18)
      goto LABEL_12;
  }
  if (v9 == v7)
  {
    v6 = 0;
LABEL_10:
    v9 = v7;
    goto LABEL_11;
  }
  v10 = 1;
LABEL_13:
  v5 = v17;
  if (v17)
  {
LABEL_14:
    v18 = v5;
    operator delete(v5);
  }
  return v10;
}

void sub_1B2C25E28(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 120);
  if (v3)
  {
    *(_QWORD *)(v1 - 112) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t OZChannel::getNextKeyframe(OZChannel *this, const CMTime *a2, CMTime *a3, double *a4)
{
  return (*(uint64_t (**)(_QWORD, const CMTime *, CMTime *, double *))(**((_QWORD **)this->var14 + 1) + 736))(*((_QWORD *)this->var14 + 1), a2, a3, a4);
}

uint64_t OZChannel::getPreviousKeyframe(OZChannel *this, const CMTime *a2, CMTime *a3, double *a4)
{
  return (*(uint64_t (**)(_QWORD, const CMTime *, CMTime *, double *))(**((_QWORD **)this->var14 + 1) + 744))(*((_QWORD *)this->var14 + 1), a2, a3, a4);
}

uint64_t OZChannel::getFirstKeyframe(OZChannel *this, CMTime *a2, double *a3)
{
  return (*(uint64_t (**)(_QWORD, CMTime *, double *))(**((_QWORD **)this->var14 + 1) + 760))(*((_QWORD *)this->var14 + 1), a2, a3);
}

uint64_t OZChannel::getLastKeyframe(OZChannel *this, CMTime *a2, double *a3)
{
  return (*(uint64_t (**)(_QWORD, CMTime *, double *))(**((_QWORD **)this->var14 + 1) + 776))(*((_QWORD *)this->var14 + 1), a2, a3);
}

uint64_t OZChannel::deleteKeyframe(OZChannel *this, void *a2)
{
  OZChannelImpl *var14;

  if ((OZChannelBase::isLocked((OZChannelBase *)this, 0) & 1) != 0)
    return 0;
  var14 = this->var14;
  if (*((_BYTE *)var14 + 32))
  {
    var14 = OZChannelImpl::createLocalCopy(var14);
    this->var14 = var14;
  }
  return (*(uint64_t (**)(_QWORD, void *, uint64_t))(**((_QWORD **)var14 + 1) + 672))(*((_QWORD *)var14 + 1), a2, 1);
}

uint64_t OZChannel::deleteAllKeyframes(OZChannel *this, const CMTime *a2)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, const CMTime *, uint64_t))(**((_QWORD **)var14 + 1) + 688))(*((_QWORD *)var14 + 1), a2, 1);
  }
  return result;
}

uint64_t OZChannel::moveKeyframe(OZChannel *this, void *a2, const CMTime *a3, uint64_t a4, uint64_t a5)
{
  OZChannelImpl *var14;

  if ((OZChannelBase::isLocked((OZChannelBase *)this, 0) & 1) != 0)
    return 0;
  var14 = this->var14;
  if (*((_BYTE *)var14 + 32))
  {
    var14 = OZChannelImpl::createLocalCopy(var14);
    this->var14 = var14;
  }
  return (*(uint64_t (**)(_QWORD, void *, const CMTime *, uint64_t, uint64_t, _QWORD))(**((_QWORD **)var14 + 1)
                                                                                             + 656))(*((_QWORD *)var14 + 1), a2, a3, a4, a5, 0);
}

uint64_t OZChannel::generateKeyframesFromDynamicCurve(OZChannel *this, const CMTime *a2, OZDynamicCurve *a3)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, const CMTime *, OZDynamicCurve *))(**((_QWORD **)var14 + 1) + 488))(*((_QWORD *)var14 + 1), a2, a3);
  }
  return result;
}

uint64_t OZChannel::linearTimeWarp(OZChannel *this, double a2, const CMTime *a3)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, const CMTime *, uint64_t, double))(**((_QWORD **)var14 + 1) + 456))(*((_QWORD *)var14 + 1), a3, 1, a2);
  }
  return result;
}

uint64_t OZChannel::createCurveSegment(OZChannel *this, const CMTime *a2, const CMTime *a3, const CMTime *a4, uint64_t a5)
{
  OZChannelImpl *var14;

  if ((OZChannelBase::isLocked((OZChannelBase *)this, 0) & 1) != 0 || !*((_QWORD *)this->var14 + 1))
    return 0;
  (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
  var14 = this->var14;
  if (*((_BYTE *)var14 + 32))
  {
    var14 = OZChannelImpl::createLocalCopy(var14);
    this->var14 = var14;
  }
  return (*(uint64_t (**)(_QWORD, const CMTime *, const CMTime *, const CMTime *, uint64_t, uint64_t))(**((_QWORD **)var14 + 1) + 520))(*((_QWORD *)var14 + 1), a2, a3, a4, a5, 1);
}

uint64_t OZChannel::setCurveSegmentValue(OZChannel *this, const CMTime *a2, double a3, int a4)
{
  uint64_t result;
  OZChannelImpl *var14;
  uint64_t v10;
  double v11;
  double v12;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0 && *((_QWORD *)this->var14 + 1))
  {
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    v10 = *((_QWORD *)var14 + 1);
    if (a4)
    {
      v11 = *((double *)this->var16 + 2);
      v12 = (*((double (**)(OZChannel *))this->var0 + 101))(this);
      return (*(uint64_t (**)(uint64_t, const CMTime *, uint64_t, double, double, double))(*(_QWORD *)v10 + 536))(v10, a2, 1, a3, v11, v12);
    }
    else
    {
      return (*(uint64_t (**)(_QWORD, const CMTime *, uint64_t, double))(*(_QWORD *)v10 + 528))(*((_QWORD *)var14 + 1), a2, 1, a3);
    }
  }
  return result;
}

uint64_t OZChannel::deriveKeyframe(OZChannel *this, void *a2)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)var14 + 1) + 928))(*((_QWORD *)var14 + 1), a2);
  }
  return result;
}

uint64_t OZChannel::smoothKeyframe(OZChannel *this, void *a2, uint64_t a3)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, void *, uint64_t, uint64_t))(**((_QWORD **)var14 + 1) + 936))(*((_QWORD *)var14 + 1), a2, a3, 1);
  }
  return result;
}

BOOL OZChannel::isSmoothKeyframe(OZChannel *this, void *a2)
{
  _BOOL8 result;
  double v5;
  double v6;

  LODWORD(v6) = 0;
  (*(void (**)(_QWORD, void *, double *, _QWORD))(**((_QWORD **)this->var14 + 1) + 1072))(*((_QWORD *)this->var14 + 1), a2, &v6, 0);
  result = 1;
  if (LODWORD(v6) != 1)
  {
    if (LODWORD(v6) != 4)
      return 0;
    v5 = 0.0;
    v6 = 0.0;
    (*(void (**)(_QWORD, void *, double *, double *))(**((_QWORD **)this->var14 + 1) + 1000))(*((_QWORD *)this->var14 + 1), a2, &v6, &v5);
    if (fabs(v6) >= 0.0000001)
      return 0;
    if (fabs(v5) >= 0.0000001)
      return 0;
    (*(void (**)(_QWORD, void *, double *, double *))(**((_QWORD **)this->var14 + 1) + 1008))(*((_QWORD *)this->var14 + 1), a2, &v6, &v5);
    if (fabs(v6) >= 0.0000001 || fabs(v5) >= 0.0000001)
      return 0;
  }
  return result;
}

uint64_t OZChannel::setKeyframeInputTangents(OZChannel *this, void *a2, double a3, double a4, int a5)
{
  uint64_t result;
  OZChannelImpl *var14;
  uint64_t v11;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    v11 = 1016;
    if (a5)
      v11 = 984;
    return (*(uint64_t (**)(double, double))(**((_QWORD **)var14 + 1) + v11))(a3, a4);
  }
  return result;
}

uint64_t OZChannel::setKeyframeOutputTangents(OZChannel *this, void *a2, double a3, double a4, int a5)
{
  uint64_t result;
  OZChannelImpl *var14;
  uint64_t v11;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    v11 = 1024;
    if (a5)
      v11 = 992;
    return (*(uint64_t (**)(double, double))(**((_QWORD **)var14 + 1) + v11))(a3, a4);
  }
  return result;
}

uint64_t OZChannel::setKeyframeNormal(OZChannel *this, void *a2, double a3)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, void *, uint64_t, double))(**((_QWORD **)var14 + 1) + 960))(*((_QWORD *)var14 + 1), a2, 1, a3);
  }
  return result;
}

double OZChannel::getKeyframeNormal(OZChannel *this, void *a2)
{
  double v3;

  v3 = 0.0;
  (*(void (**)(_QWORD, void *, double *))(**((_QWORD **)this->var14 + 1) + 952))(*((_QWORD *)this->var14 + 1), a2, &v3);
  return v3;
}

double OZChannel::getKeyframeNormal(OZChannel *this, const CMTime *a2)
{
  double v3;

  v3 = 0.0;
  (*(void (**)(_QWORD, const CMTime *, double *))(**((_QWORD **)this->var14 + 1) + 968))(*((_QWORD *)this->var14 + 1), a2, &v3);
  return v3;
}

uint64_t OZChannel::setKeyframeEnabled(OZChannel *this, void *a2, uint64_t a3)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, void *, uint64_t, uint64_t))(**((_QWORD **)var14 + 1) + 856))(*((_QWORD *)var14 + 1), a2, a3, 1);
  }
  return result;
}

uint64_t OZChannel::setKeyframeTangentsBroken(OZChannel *this, void *a2, uint64_t a3)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, void *, uint64_t, uint64_t))(**((_QWORD **)var14 + 1) + 896))(*((_QWORD *)var14 + 1), a2, a3, 1);
  }
  return result;
}

uint64_t OZChannel::setKeyframeInterpolation(OZChannel *this, void *a2, uint64_t a3)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0)
  {
    var14 = this->var14;
    if (var14)
    {
      if (*((_BYTE *)var14 + 32))
        this->var14 = OZChannelImpl::createLocalCopy(var14);
    }
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    return (*(uint64_t (**)(_QWORD, void *, uint64_t, uint64_t))(**((_QWORD **)this->var14 + 1) + 1064))(*((_QWORD *)this->var14 + 1), a2, a3, 1);
  }
  return result;
}

uint64_t OZChannel::setCurveSegmentSpeed(OZChannel *this, void *a2, uint64_t a3)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0 && *((_QWORD *)this->var14 + 1))
  {
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, void *, uint64_t, uint64_t))(**((_QWORD **)var14 + 1) + 1080))(*((_QWORD *)var14 + 1), a2, a3, 1);
  }
  return result;
}

uint64_t OZChannel::getCurveSegmentSpeed(OZChannel *this, void *a2)
{
  unsigned int v3;

  v3 = 0;
  (*(void (**)(_QWORD, void *, unsigned int *))(**((_QWORD **)this->var14 + 1) + 1088))(*((_QWORD *)this->var14 + 1), a2, &v3);
  return v3;
}

uint64_t OZChannel::offsetCurveSegmentSpeed(OZChannel *this, void *a2, double a3)
{
  uint64_t result;
  OZChannelImpl *var14;

  result = OZChannelBase::isLocked((OZChannelBase *)this, 0);
  if ((result & 1) == 0 && *((_QWORD *)this->var14 + 1))
  {
    (*((void (**)(OZChannel *, uint64_t))this->var0 + 58))(this, 1);
    var14 = this->var14;
    if (*((_BYTE *)var14 + 32))
    {
      var14 = OZChannelImpl::createLocalCopy(var14);
      this->var14 = var14;
    }
    return (*(uint64_t (**)(_QWORD, void *, uint64_t, double))(**((_QWORD **)var14 + 1) + 1096))(*((_QWORD *)var14 + 1), a2, 1, a3);
  }
  return result;
}

uint64_t OZChannel::appendCurveProcessingNode(OZChannel *this, void *a2)
{
  OZChannelImpl *var14;

  var14 = this->var14;
  if (*((_BYTE *)var14 + 32))
  {
    var14 = OZChannelImpl::createLocalCopy(var14);
    this->var14 = var14;
  }
  return (*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)var14 + 1) + 1104))(*((_QWORD *)var14 + 1), a2);
}

uint64_t OZChannel::insertCurveProcessingNode(OZChannel *this, void *a2, void *a3)
{
  OZChannelImpl *var14;

  var14 = this->var14;
  if (*((_BYTE *)var14 + 32))
  {
    var14 = OZChannelImpl::createLocalCopy(var14);
    this->var14 = var14;
  }
  return (*(uint64_t (**)(_QWORD, void *, void *))(**((_QWORD **)var14 + 1) + 1112))(*((_QWORD *)var14 + 1), a2, a3);
}

uint64_t OZChannel::deleteCurveProcessingNode(OZChannel *this, void *a2)
{
  OZChannelImpl *var14;

  var14 = this->var14;
  if (*((_BYTE *)var14 + 32))
  {
    var14 = OZChannelImpl::createLocalCopy(var14);
    this->var14 = var14;
  }
  return (*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)var14 + 1) + 1120))(*((_QWORD *)var14 + 1), a2);
}

uint64_t OZChannel::removeCurveProcessingNode(OZChannel *this, void *a2)
{
  OZChannelImpl *var14;

  var14 = this->var14;
  if (*((_BYTE *)var14 + 32))
  {
    var14 = OZChannelImpl::createLocalCopy(var14);
    this->var14 = var14;
  }
  return (*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)var14 + 1) + 1128))(*((_QWORD *)var14 + 1), a2);
}

uint64_t OZChannel::getPreviousProcessingNode(OZChannel *this, void *a2)
{
  uint64_t v3;

  v3 = 0;
  (*(void (**)(_QWORD, void *, uint64_t *))(**((_QWORD **)this->var14 + 1) + 1136))(*((_QWORD *)this->var14 + 1), a2, &v3);
  return v3;
}

uint64_t OZChannel::enumerateCurveProcessingNodes@<X0>(OZChannel *this@<X0>, _QWORD *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return (*(uint64_t (**)(_QWORD, _QWORD *))(**((_QWORD **)this->var14 + 1) + 1144))(*((_QWORD *)this->var14 + 1), a2);
}

void sub_1B2C26AD4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t OZChannel::getNumberOfCurveProcessingNodes(OZChannel *this)
{
  unsigned int v2;

  v2 = 0;
  (*(void (**)(_QWORD, unsigned int *))(**((_QWORD **)this->var14 + 1) + 1152))(*((_QWORD *)this->var14 + 1), &v2);
  return v2;
}

void OZChannel::visibleKeypoints(OZChannel *this@<X0>, CMTimeRange *a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, char **a5@<X8>)
{
  __int128 v10;
  uint64_t v11;
  char *v12;
  char *v13;
  __int128 v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  __int128 v23;
  char *v24;
  char *v25;
  __int128 v26;
  void *v27;
  uint64_t v28;
  unsigned int v29;
  char *v30;
  char *v31;
  __int128 v32;
  char *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  char *v38;
  char *v39;
  __int128 v40;
  char *v41;
  char *v42;
  char *v43;
  __int128 v44;
  __int128 v45;
  char *v46;
  char *v47;
  __int128 v48;
  char *v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  char *v54;
  char *v55;
  char *v56;
  __int128 v57;
  char *v58;
  char *v59;
  __int128 v60;
  CMTimeRange range;
  CMTime v62;
  void *__p;
  _BYTE *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;

  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  v10 = *(_OWORD *)&a2->start.epoch;
  v66 = *(_OWORD *)&a2->start.value;
  v67 = v10;
  v68 = *(_OWORD *)&a2->duration.timescale;
  (*((void (**)(__int128 *__return_ptr))this->var0 + 41))(&v69);
  *(_QWORD *)&v67 = v70;
  v66 = v69;
  v64 = 0;
  v65 = 0;
  v11 = *((_QWORD *)this->var14 + 1);
  v70 = v67;
  __p = 0;
  v71 = v68;
  (*(void (**)(uint64_t, __int128 *, void **, _QWORD, _QWORD))(*(_QWORD *)v11 + 808))(v11, &v69, &__p, 0, 0);
  std::vector<CMTime>::reserve((void **)a5, 0xCCCCCCCCCCCCCCCDLL * ((v64 - (_BYTE *)__p) >> 3));
  v69 = *(_OWORD *)&a2->start.value;
  *(_QWORD *)&v70 = a2->start.epoch;
  if (a3 && (*((unsigned int (**)(OZChannel *, __int128 *, uint64_t))this->var0 + 78))(this, &v69, a4))
  {
    v12 = a5[2];
    v13 = a5[1];
    if (v13 >= v12)
    {
      v16 = 0xAAAAAAAAAAAAAAABLL * ((v13 - *a5) >> 3);
      v17 = v16 + 1;
      if (v16 + 1 > 0xAAAAAAAAAAAAAAALL)
        goto LABEL_62;
      v18 = 0xAAAAAAAAAAAAAAABLL * ((v12 - *a5) >> 3);
      if (2 * v18 > v17)
        v17 = 2 * v18;
      if (v18 >= 0x555555555555555)
        v19 = 0xAAAAAAAAAAAAAAALL;
      else
        v19 = v17;
      if (v19)
        v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a5 + 2), v19);
      else
        v20 = 0;
      v21 = &v20[24 * v16];
      v22 = &v20[24 * v19];
      v23 = v69;
      *((_QWORD *)v21 + 2) = v70;
      *(_OWORD *)v21 = v23;
      v15 = v21 + 24;
      v25 = *a5;
      v24 = a5[1];
      if (v24 != *a5)
      {
        do
        {
          v26 = *(_OWORD *)(v24 - 24);
          *((_QWORD *)v21 - 1) = *((_QWORD *)v24 - 1);
          *(_OWORD *)(v21 - 24) = v26;
          v21 -= 24;
          v24 -= 24;
        }
        while (v24 != v25);
        v24 = *a5;
      }
      *a5 = v21;
      a5[1] = v15;
      a5[2] = v22;
      if (v24)
        operator delete(v24);
    }
    else
    {
      v14 = v69;
      *((_QWORD *)v13 + 2) = v70;
      *(_OWORD *)v13 = v14;
      v15 = v13 + 24;
    }
    a5[1] = v15;
  }
  v27 = __p;
  if (v64 != __p)
  {
    v28 = 0;
    v29 = 0;
    do
    {
      (*((void (**)(CMTime *__return_ptr, OZChannel *, uint64_t))this->var0 + 42))(&v62, this, (uint64_t)v27 + 40 * v28);
      v31 = a5[1];
      v30 = a5[2];
      if (v31 >= v30)
      {
        v34 = 0xAAAAAAAAAAAAAAABLL * ((v31 - *a5) >> 3);
        v35 = v34 + 1;
        if (v34 + 1 > 0xAAAAAAAAAAAAAAALL)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v36 = 0xAAAAAAAAAAAAAAABLL * ((v30 - *a5) >> 3);
        if (2 * v36 > v35)
          v35 = 2 * v36;
        if (v36 >= 0x555555555555555)
          v37 = 0xAAAAAAAAAAAAAAALL;
        else
          v37 = v35;
        if (v37)
          v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a5 + 2), v37);
        else
          v38 = 0;
        v39 = &v38[24 * v34];
        v40 = *(_OWORD *)&v62.value;
        *((_QWORD *)v39 + 2) = v62.epoch;
        *(_OWORD *)v39 = v40;
        v42 = *a5;
        v41 = a5[1];
        v43 = v39;
        if (v41 != *a5)
        {
          do
          {
            v44 = *(_OWORD *)(v41 - 24);
            *((_QWORD *)v43 - 1) = *((_QWORD *)v41 - 1);
            *(_OWORD *)(v43 - 24) = v44;
            v43 -= 24;
            v41 -= 24;
          }
          while (v41 != v42);
          v41 = *a5;
        }
        v33 = v39 + 24;
        *a5 = v43;
        a5[1] = v39 + 24;
        a5[2] = &v38[24 * v37];
        if (v41)
          operator delete(v41);
      }
      else
      {
        v32 = *(_OWORD *)&v62.value;
        *((_QWORD *)v31 + 2) = v62.epoch;
        *(_OWORD *)v31 = v32;
        v33 = v31 + 24;
      }
      a5[1] = v33;
      v27 = __p;
      v28 = ++v29;
    }
    while (0xCCCCCCCCCCCCCCCDLL * ((v64 - (_BYTE *)__p) >> 3) > v29);
  }
  if ((a3 & 1) != 0)
  {
    v45 = *(_OWORD *)&a2->start.epoch;
    *(_OWORD *)&range.start.value = *(_OWORD *)&a2->start.value;
    *(_OWORD *)&range.start.epoch = v45;
    *(_OWORD *)&range.duration.timescale = *(_OWORD *)&a2->duration.timescale;
    CMTimeRangeGetEnd(&v62, &range);
    v69 = *(_OWORD *)&v62.value;
    *(_QWORD *)&v70 = v62.epoch;
    if ((*((unsigned int (**)(OZChannel *, __int128 *, _QWORD))this->var0 + 79))(this, &v69, a4))
    {
      v46 = a5[2];
      v47 = a5[1];
      if (v47 < v46)
      {
        v48 = v69;
        *((_QWORD *)v47 + 2) = v70;
        *(_OWORD *)v47 = v48;
        v49 = v47 + 24;
LABEL_57:
        a5[1] = v49;
        goto LABEL_58;
      }
      v50 = 0xAAAAAAAAAAAAAAABLL * ((v47 - *a5) >> 3);
      v51 = v50 + 1;
      if (v50 + 1 <= 0xAAAAAAAAAAAAAAALL)
      {
        v52 = 0xAAAAAAAAAAAAAAABLL * ((v46 - *a5) >> 3);
        if (2 * v52 > v51)
          v51 = 2 * v52;
        if (v52 >= 0x555555555555555)
          v53 = 0xAAAAAAAAAAAAAAALL;
        else
          v53 = v51;
        if (v53)
          v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a5 + 2), v53);
        else
          v54 = 0;
        v55 = &v54[24 * v50];
        v56 = &v54[24 * v53];
        v57 = v69;
        *((_QWORD *)v55 + 2) = v70;
        *(_OWORD *)v55 = v57;
        v49 = v55 + 24;
        v59 = *a5;
        v58 = a5[1];
        if (v58 != *a5)
        {
          do
          {
            v60 = *(_OWORD *)(v58 - 24);
            *((_QWORD *)v55 - 1) = *((_QWORD *)v58 - 1);
            *(_OWORD *)(v55 - 24) = v60;
            v55 -= 24;
            v58 -= 24;
          }
          while (v58 != v59);
          v58 = *a5;
        }
        *a5 = v55;
        a5[1] = v49;
        a5[2] = v56;
        if (v58)
          operator delete(v58);
        goto LABEL_57;
      }
LABEL_62:
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
  }
LABEL_58:
  if (__p)
  {
    v64 = __p;
    operator delete(__p);
  }
}

void sub_1B2C2700C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  uint64_t v23;
  void *v25;

  if (__p)
    operator delete(__p);
  v25 = *(void **)v23;
  if (*(_QWORD *)v23)
  {
    *(_QWORD *)(v23 + 8) = v25;
    operator delete(v25);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<CMTime>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - (_BYTE *)*a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v5 = ((_BYTE *)a1[1] - (_BYTE *)*a1) / 24;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>(v3, a2);
    v7 = &v6[24 * v5];
    v9 = &v6[24 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *(_OWORD *)(v10 - 24);
        *((_QWORD *)v12 - 1) = *((_QWORD *)v10 - 1);
        *(_OWORD *)(v12 - 24) = v13;
        v12 -= 24;
        v10 -= 24;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

const __CFString *OZChannelDouble::getObjCWrapperName(OZChannelDouble *this)
{
  return CFSTR("CHChannelDouble");
}

const __CFString *OZChannelAngle::getObjCWrapperName(OZChannelAngle *this)
{
  return CFSTR("CHChannelAngle");
}

const __CFString *OZChannelUint32::getObjCWrapperName(OZChannelUint32 *this)
{
  return CFSTR("CHChannelUint32");
}

const __CFString *OZChannelUint16::getObjCWrapperName(OZChannelUint16 *this)
{
  return CFSTR("CHChannelUint16");
}

const __CFString *OZChannelShearAngle::getObjCWrapperName(OZChannelShearAngle *this)
{
  return CFSTR("CHChannelShearAngle");
}

const __CFString *OZChannelAspectRatio::getObjCWrapperName(OZChannelAspectRatio *this)
{
  return CFSTR("CHChannelAspectRatio");
}

const __CFString *OZChannelAspectRatioFootage::getObjCWrapperName(OZChannelAspectRatioFootage *this)
{
  return CFSTR("CHChannelAspectRatioFootage");
}

const __CFString *OZChannelGammaFootage::getObjCWrapperName(OZChannelGammaFootage *this)
{
  return CFSTR("CHChannelGammaFootage");
}

const __CFString *OZChannelSeed::getObjCWrapperName(OZChannelSeed *this)
{
  return CFSTR("CHChannelSeed");
}

const __CFString *OZChannelDecibel::getObjCWrapperName(OZChannelDecibel *this)
{
  return CFSTR("CHChannelDecibel");
}

const __CFString *OZChannelFrame::getObjCWrapperName(OZChannelFrame *this)
{
  return CFSTR("CHChannelFrame");
}

const __CFString *OZChannelTimecode::getObjCWrapperName(OZChannelTimecode *this)
{
  return CFSTR("CHChannelTimecode");
}

void OZChannelDouble::~OZChannelDouble(OZChannel *this)
{
  OZChannel::~OZChannel(this);
  JUMPOUT(0x1B5E29170);
}

OZChannel *OZChannelDouble::clone(const OZChannelBase *this)
{
  OZChannel *v2;

  v2 = (OZChannel *)operator new();
  OZChannel::OZChannel(v2, this, 0);
  v2->var0 = (void **)&off_1E6551358;
  v2->var2 = (void **)&unk_1E65516B8;
  return v2;
}

void sub_1B2C27264(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'OZChannelDouble::~OZChannelDouble(OZChannelDouble *this)
{
  OZChannel::~OZChannel((OZChannel *)((char *)this - 16));
}

{
  OZChannel::~OZChannel((OZChannel *)((char *)this - 16));
  JUMPOUT(0x1B5E29170);
}

OZChannel *OZChannelAngle::clone(OZChannelAngle *this)
{
  OZChannel *v2;

  v2 = (OZChannel *)operator new();
  OZChannel::OZChannel(v2, (const OZChannelBase *)this, 0);
  v2->var0 = (void **)&off_1E6551728;
  v2->var2 = (void **)&unk_1E6551A88;
  return v2;
}

void sub_1B2C27314(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelUint32::clone(OZChannelUint32 *this)
{
  OZChannel *v2;

  v2 = (OZChannel *)operator new();
  OZChannel::OZChannel(v2, (const OZChannelBase *)this, 0);
  v2->var0 = (void **)&off_1E6551AF8;
  v2->var2 = (void **)&unk_1E6551E58;
  return v2;
}

void sub_1B2C27394(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelUint16::clone(OZChannelUint16 *this)
{
  OZChannel *v2;

  v2 = (OZChannel *)operator new();
  OZChannel::OZChannel(v2, (const OZChannelBase *)this, 0);
  v2->var0 = (void **)&off_1E6551EC8;
  v2->var2 = (void **)&unk_1E6552228;
  return v2;
}

void sub_1B2C27414(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelShearAngle::clone(OZChannelShearAngle *this)
{
  OZChannel *v2;

  v2 = (OZChannel *)operator new();
  OZChannel::OZChannel(v2, (const OZChannelBase *)this, 0);
  v2->var0 = (void **)&off_1E6552298;
  v2->var2 = (void **)&unk_1E65525F8;
  return v2;
}

void sub_1B2C27494(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelAspectRatio::clone(OZChannelAspectRatio *this)
{
  OZChannel *v2;

  v2 = (OZChannel *)operator new();
  OZChannel::OZChannel(v2, (const OZChannelBase *)this, 0);
  v2->var0 = (void **)&off_1E6552668;
  v2->var2 = (void **)&unk_1E65529C8;
  return v2;
}

void sub_1B2C27514(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelAspectRatioFootage::clone(OZChannelAspectRatioFootage *this)
{
  OZChannel *v2;

  v2 = (OZChannel *)operator new();
  OZChannel::OZChannel(v2, (const OZChannelBase *)this, 0);
  v2->var0 = (void **)&off_1E6552A38;
  v2->var2 = (void **)&unk_1E6552D98;
  return v2;
}

void sub_1B2C27594(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelGammaFootage::clone(OZChannelGammaFootage *this)
{
  OZChannel *v2;

  v2 = (OZChannel *)operator new();
  OZChannel::OZChannel(v2, (const OZChannelBase *)this, 0);
  v2->var0 = (void **)&off_1E6552E08;
  v2->var2 = (void **)&unk_1E6553168;
  return v2;
}

void sub_1B2C27614(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelSeed::clone(OZChannelSeed *this)
{
  OZChannel *v2;

  v2 = (OZChannel *)operator new();
  OZChannel::OZChannel(v2, (const OZChannelBase *)this, 0);
  v2->var0 = (void **)&off_1E65531D8;
  v2->var2 = (void **)&unk_1E6553538;
  return v2;
}

void sub_1B2C27694(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelDecibel::clone(OZChannelDecibel *this)
{
  OZChannel *v2;

  v2 = (OZChannel *)operator new();
  OZChannel::OZChannel(v2, (const OZChannelBase *)this, 0);
  v2->var0 = (void **)&off_1E65535A8;
  v2->var2 = (void **)&unk_1E6553908;
  return v2;
}

void sub_1B2C27714(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelFrame::clone(OZChannelFrame *this)
{
  OZChannel *v2;

  v2 = (OZChannel *)operator new();
  OZChannel::OZChannel(v2, (const OZChannelBase *)this, 0);
  v2->var0 = (void **)&off_1E6553978;
  v2->var2 = (void **)&unk_1E6553CD8;
  return v2;
}

void sub_1B2C27794(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

OZChannel *OZChannelTimecode::clone(OZChannelTimecode *this)
{
  OZChannel *v2;

  v2 = (OZChannel *)operator new();
  OZChannel::OZChannel(v2, (const OZChannelBase *)this, 0);
  v2->var0 = (void **)&off_1E6553D48;
  v2->var2 = (void **)&unk_1E65540A8;
  return v2;
}

void sub_1B2C27814(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<_OZKeyframeInfo>::__init_with_size[abi:ne180100]<_OZKeyframeInfo*,_OZKeyframeInfo*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<_OZKeyframeInfo>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B2C27894(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<_OZKeyframeInfo>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x2AAAAAAAAAAAAABLL)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<_OZKeyframeInfo>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[96 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<_OZKeyframeInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(96 * a2);
}

void `anonymous namespace'::MinMaxValuesVisitor::~MinMaxValuesVisitor(OZChannelBase *this, const PCString *a2)
{
  OZChannelBase::setRangeName(this, a2);
  JUMPOUT(0x1B5E29170);
}

uint64_t `anonymous namespace'::MinMaxValuesVisitor::visitConstant(uint64_t this, double a2, const CMTime *a3, const CMTime *a4)
{
  double v4;

  v4 = *(double *)(this + 8);
  if (v4 >= a2)
    v4 = a2;
  if (*(double *)(this + 16) > a2)
    a2 = *(double *)(this + 16);
  *(double *)(this + 8) = v4;
  *(double *)(this + 16) = a2;
  return this;
}

void `anonymous namespace'::MinMaxValuesVisitor::visitLinear(_anonymous_namespace_::MinMaxValuesVisitor *this, OZSpline *a2, char *a3, char *a4, const CMTime *a5, const CMTime *a6, const CMTime *a7, const CMTime *a8, __n128 a9)
{
  double v13;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  uint64_t v22;
  double v23;
  double v24;
  _BYTE v25[8];

  if (a3 && a4)
  {
    v13 = a9.n128_f64[0];
    OZLinearInterpolator::OZLinearInterpolator((OZLinearInterpolator *)v25);
    OZLinearInterpolator::interpolate((OZLinearInterpolator *)v25, a2, MEMORY[0x1E0CA2E68], a3, a4, a5);
    v18 = v17;
    OZLinearInterpolator::interpolate((OZLinearInterpolator *)v25, a2, MEMORY[0x1E0CA2E68], a3, a4, a6);
    v19 = v18 + v13;
    v21 = v20 + v13;
    OZLinearInterpolator::~OZLinearInterpolator((OZLinearInterpolator *)v25);
  }
  else
  {
    v22 = MEMORY[0x1E0CA2E68];
    v19 = (*(double (**)(OZSpline *, const CMTime *, _QWORD, _QWORD, const CMTime *, const CMTime *, __n128))(*(_QWORD *)a2 + 240))(a2, a7, MEMORY[0x1E0CA2E68], 0, a5, a6, a9);
    v21 = (*(double (**)(OZSpline *, const CMTime *, uint64_t, _QWORD))(*(_QWORD *)a2 + 240))(a2, a8, v22, 0);
  }
  if (v19 <= v21)
    v23 = v19;
  else
    v23 = v21;
  if (v19 <= v21)
    v24 = v21;
  else
    v24 = v19;
  if (*((double *)this + 1) < v23)
    v23 = *((double *)this + 1);
  if (v24 < *((double *)this + 2))
    v24 = *((double *)this + 2);
  *((double *)this + 1) = v23;
  *((double *)this + 2) = v24;
}

void sub_1B2C27AC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  OZLinearInterpolator::~OZLinearInterpolator((OZLinearInterpolator *)va);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::MinMaxValuesVisitor::visitBezier(_anonymous_namespace_::MinMaxValuesVisitor *this, OZSpline *a2, void *a3, void *a4, const CMTime *a5, const CMTime *a6, const CMTime *a7, const CMTime *a8, double a9)
{
  int32_t v16;
  const CMTime *v17;
  const CMTime *v18;
  double v19;
  double v20;
  double v21;
  double v22;
  _BYTE v23[16];
  CMTime time2;
  CMTime time1;

  v21 = 0.0;
  v22 = 0.0;
  OZBezierInterpolator::OZBezierInterpolator((OZBezierInterpolator *)v23);
  time1 = *a5;
  time2 = *a6;
  v16 = CMTimeCompare(&time1, &time2);
  if (v16 <= 0)
    v17 = a5;
  else
    v17 = a6;
  if (v16 <= 0)
    v18 = a6;
  else
    v18 = a5;
  OZBezierInterpolator::getMinMaxValues((OZBezierInterpolator *)v23, a2, a3, a4, v17, v18, &v22, &v21);
  v21 = v21 + a9;
  v22 = v22 + a9;
  OZBezierInterpolator::~OZBezierInterpolator((OZBezierInterpolator *)v23);
  v19 = v22;
  if (*((double *)this + 1) < v22)
    v19 = *((double *)this + 1);
  v20 = v21;
  if (v21 < *((double *)this + 2))
    v20 = *((double *)this + 2);
  *((double *)this + 1) = v19;
  *((double *)this + 2) = v20;
}

void sub_1B2C27BCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  OZBezierInterpolator::~OZBezierInterpolator((OZBezierInterpolator *)va);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::MinMaxValuesVisitor::visitCatmullRom(_anonymous_namespace_::MinMaxValuesVisitor *this, OZSpline *a2, void *a3, void *a4, const CMTime *a5, const CMTime *a6, const CMTime *a7, const CMTime *a8, double a9)
{
  int32_t v16;
  const CMTime *v17;
  const CMTime *v18;
  double v19;
  double v20;
  double v21;
  double v22;
  _BYTE v23[24];
  CMTime time2;
  CMTime time1;

  v21 = 0.0;
  v22 = 0.0;
  OZCatmullRomInterpolator::OZCatmullRomInterpolator((OZCatmullRomInterpolator *)v23);
  time1 = *a5;
  time2 = *a6;
  v16 = CMTimeCompare(&time1, &time2);
  if (v16 <= 0)
    v17 = a5;
  else
    v17 = a6;
  if (v16 <= 0)
    v18 = a6;
  else
    v18 = a5;
  OZBezierInterpolator::getMinMaxValues((OZBezierInterpolator *)v23, a2, a3, a4, v17, v18, &v22, &v21);
  v21 = v21 + a9;
  v22 = v22 + a9;
  OZCatmullRomInterpolator::~OZCatmullRomInterpolator((OZCatmullRomInterpolator *)v23);
  v19 = v22;
  if (*((double *)this + 1) < v22)
    v19 = *((double *)this + 1);
  v20 = v21;
  if (v21 < *((double *)this + 2))
    v20 = *((double *)this + 2);
  *((double *)this + 1) = v19;
  *((double *)this + 2) = v20;
}

void sub_1B2C27CD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  OZCatmullRomInterpolator::~OZCatmullRomInterpolator((OZCatmullRomInterpolator *)va);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::MinMaxValuesVisitor::visitEaseIn(_anonymous_namespace_::MinMaxValuesVisitor *this, OZSpline *a2, uint64_t a3, uint64_t a4, CMTime *a5, CMTime *a6, const CMTime *a7, const CMTime *a8, double a9)
{
  int32_t v16;
  CMTime *v17;
  CMTime *v18;
  const PCString *v19;
  uint64_t result;
  double v21;
  double v22;
  double v23;
  double v24;
  OZChannelBase v25;

  v23 = 0.0;
  v24 = 0.0;
  OZInterpolator::OZInterpolator((OZInterpolator *)&v25);
  v25.var0 = (void **)&unk_1E6555288;
  *(CMTime *)&v25.var5 = *a5;
  *(CMTime *)&v25.var1 = *a6;
  v16 = CMTimeCompare((CMTime *)&v25.var5, (CMTime *)&v25.var1);
  if (v16 <= 0)
    v17 = a5;
  else
    v17 = a6;
  if (v16 <= 0)
    v18 = a6;
  else
    v18 = a5;
  OZEaseInInterpolator::getMinMaxValues((uint64_t)&v25, (uint64_t)a2, a3, a4, v17, v18, &v24, &v23);
  v23 = v23 + a9;
  v24 = v24 + a9;
  result = OZChannelBase::setRangeName(&v25, v19);
  v21 = v24;
  if (*((double *)this + 1) < v24)
    v21 = *((double *)this + 1);
  v22 = v23;
  if (v23 < *((double *)this + 2))
    v22 = *((double *)this + 2);
  *((double *)this + 1) = v21;
  *((double *)this + 2) = v22;
  return result;
}

void sub_1B2C27DE4(_Unwind_Exception *a1, const PCString *a2, uint64_t a3, OZChannelBase *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  OZChannelBase::setRangeName((OZChannelBase *)&a12, a2);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::MinMaxValuesVisitor::visitEaseOut(_anonymous_namespace_::MinMaxValuesVisitor *this, OZSpline *a2, uint64_t a3, uint64_t a4, CMTime *a5, CMTime *a6, const CMTime *a7, const CMTime *a8, double a9)
{
  int32_t v16;
  CMTime *v17;
  CMTime *v18;
  const PCString *v19;
  uint64_t result;
  double v21;
  double v22;
  double v23;
  double v24;
  OZChannelBase v25;

  v23 = 0.0;
  v24 = 0.0;
  OZInterpolator::OZInterpolator((OZInterpolator *)&v25);
  v25.var0 = (void **)&unk_1E6555320;
  *(CMTime *)&v25.var5 = *a5;
  *(CMTime *)&v25.var1 = *a6;
  v16 = CMTimeCompare((CMTime *)&v25.var5, (CMTime *)&v25.var1);
  if (v16 <= 0)
    v17 = a5;
  else
    v17 = a6;
  if (v16 <= 0)
    v18 = a6;
  else
    v18 = a5;
  OZEaseInInterpolator::getMinMaxValues((uint64_t)&v25, (uint64_t)a2, a3, a4, v17, v18, &v24, &v23);
  v23 = v23 + a9;
  v24 = v24 + a9;
  result = OZChannelBase::setRangeName(&v25, v19);
  v21 = v24;
  if (*((double *)this + 1) < v24)
    v21 = *((double *)this + 1);
  v22 = v23;
  if (v23 < *((double *)this + 2))
    v22 = *((double *)this + 2);
  *((double *)this + 1) = v21;
  *((double *)this + 2) = v22;
  return result;
}

void sub_1B2C27EF8(_Unwind_Exception *a1, const PCString *a2, uint64_t a3, OZChannelBase *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  OZChannelBase::setRangeName((OZChannelBase *)&a12, a2);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::MinMaxValuesVisitor::visitEase(_anonymous_namespace_::MinMaxValuesVisitor *this, OZSpline *a2, uint64_t a3, uint64_t a4, CMTime *a5, CMTime *a6, const CMTime *a7, const CMTime *a8, double a9)
{
  int32_t v16;
  CMTime *v17;
  CMTime *v18;
  double v19;
  double v20;
  double v21;
  double v22;
  void *v23;
  CMTime time2;
  CMTime time1;

  v21 = 0.0;
  v22 = 0.0;
  OZLinearInterpolator::OZLinearInterpolator((OZLinearInterpolator *)&v23);
  v23 = &unk_1E65551F0;
  time1 = *a5;
  time2 = *a6;
  v16 = CMTimeCompare(&time1, &time2);
  if (v16 <= 0)
    v17 = a5;
  else
    v17 = a6;
  if (v16 <= 0)
    v18 = a6;
  else
    v18 = a5;
  OZLinearInterpolator::getMinMaxValues((uint64_t)&v23, (uint64_t)a2, a3, a4, v17, v18, &v22, &v21);
  v21 = v21 + a9;
  v22 = v22 + a9;
  OZEaseInInterpolator::~OZEaseInInterpolator((OZEaseInInterpolator *)&v23);
  v19 = v22;
  if (*((double *)this + 1) < v22)
    v19 = *((double *)this + 1);
  v20 = v21;
  if (v21 < *((double *)this + 2))
    v20 = *((double *)this + 2);
  *((double *)this + 1) = v19;
  *((double *)this + 2) = v20;
}

void sub_1B2C2800C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  OZEaseInInterpolator::~OZEaseInInterpolator((OZEaseInInterpolator *)va);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::MinMaxValuesVisitor::visitAccelerate(_anonymous_namespace_::MinMaxValuesVisitor *this, OZSpline *a2, uint64_t a3, uint64_t a4, CMTime *a5, CMTime *a6, const CMTime *a7, const CMTime *a8, double a9)
{
  int32_t v16;
  CMTime *v17;
  CMTime *v18;
  double v19;
  double v20;
  double v21;
  double v22;
  void *v23;
  CMTime time2;
  CMTime time1;

  v21 = 0.0;
  v22 = 0.0;
  OZLinearInterpolator::OZLinearInterpolator((OZLinearInterpolator *)&v23);
  v23 = &unk_1E6554D50;
  time1 = *a5;
  time2 = *a6;
  v16 = CMTimeCompare(&time1, &time2);
  if (v16 <= 0)
    v17 = a5;
  else
    v17 = a6;
  if (v16 <= 0)
    v18 = a6;
  else
    v18 = a5;
  OZLinearInterpolator::getMinMaxValues((uint64_t)&v23, (uint64_t)a2, a3, a4, v17, v18, &v22, &v21);
  v21 = v21 + a9;
  v22 = v22 + a9;
  OZEaseInInterpolator::~OZEaseInInterpolator((OZEaseInInterpolator *)&v23);
  v19 = v22;
  if (*((double *)this + 1) < v22)
    v19 = *((double *)this + 1);
  v20 = v21;
  if (v21 < *((double *)this + 2))
    v20 = *((double *)this + 2);
  *((double *)this + 1) = v19;
  *((double *)this + 2) = v20;
}

void sub_1B2C28120(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  OZEaseInInterpolator::~OZEaseInInterpolator((OZEaseInInterpolator *)va);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::MinMaxValuesVisitor::visitDecelerate(_anonymous_namespace_::MinMaxValuesVisitor *this, OZSpline *a2, uint64_t a3, uint64_t a4, CMTime *a5, CMTime *a6, const CMTime *a7, const CMTime *a8, double a9)
{
  int32_t v16;
  CMTime *v17;
  CMTime *v18;
  double v19;
  double v20;
  double v21;
  double v22;
  void *v23;
  CMTime time2;
  CMTime time1;

  v21 = 0.0;
  v22 = 0.0;
  OZLinearInterpolator::OZLinearInterpolator((OZLinearInterpolator *)&v23);
  v23 = &unk_1E6555158;
  time1 = *a5;
  time2 = *a6;
  v16 = CMTimeCompare(&time1, &time2);
  if (v16 <= 0)
    v17 = a5;
  else
    v17 = a6;
  if (v16 <= 0)
    v18 = a6;
  else
    v18 = a5;
  OZLinearInterpolator::getMinMaxValues((uint64_t)&v23, (uint64_t)a2, a3, a4, v17, v18, &v22, &v21);
  v21 = v21 + a9;
  v22 = v22 + a9;
  OZEaseInInterpolator::~OZEaseInInterpolator((OZEaseInInterpolator *)&v23);
  v19 = v22;
  if (*((double *)this + 1) < v22)
    v19 = *((double *)this + 1);
  v20 = v21;
  if (v21 < *((double *)this + 2))
    v20 = *((double *)this + 2);
  *((double *)this + 1) = v19;
  *((double *)this + 2) = v20;
}

void sub_1B2C28234(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  OZEaseInInterpolator::~OZEaseInInterpolator((OZEaseInInterpolator *)va);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::MinMaxValuesVisitor::visitExponential(_anonymous_namespace_::MinMaxValuesVisitor *this, OZSpline *a2, uint64_t a3, uint64_t a4, CMTime *a5, CMTime *a6, const CMTime *a7, const CMTime *a8, double a9)
{
  int32_t v16;
  CMTime *v17;
  CMTime *v18;
  const PCString *v19;
  uint64_t result;
  double v21;
  double v22;
  double v23;
  double v24;
  OZChannelBase v25;

  v23 = 0.0;
  v24 = 0.0;
  OZInterpolator::OZInterpolator((OZInterpolator *)&v25);
  v25.var0 = (void **)&unk_1E65553B8;
  *(CMTime *)&v25.var5 = *a5;
  *(CMTime *)&v25.var1 = *a6;
  v16 = CMTimeCompare((CMTime *)&v25.var5, (CMTime *)&v25.var1);
  if (v16 <= 0)
    v17 = a5;
  else
    v17 = a6;
  if (v16 <= 0)
    v18 = a6;
  else
    v18 = a5;
  OZEaseInInterpolator::getMinMaxValues((uint64_t)&v25, (uint64_t)a2, a3, a4, v17, v18, &v24, &v23);
  v23 = v23 + a9;
  v24 = v24 + a9;
  result = OZChannelBase::setRangeName(&v25, v19);
  v21 = v24;
  if (*((double *)this + 1) < v24)
    v21 = *((double *)this + 1);
  v22 = v23;
  if (v23 < *((double *)this + 2))
    v22 = *((double *)this + 2);
  *((double *)this + 1) = v21;
  *((double *)this + 2) = v22;
  return result;
}

void sub_1B2C28348(_Unwind_Exception *a1, const PCString *a2, uint64_t a3, OZChannelBase *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  OZChannelBase::setRangeName((OZChannelBase *)&a12, a2);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::MinMaxValuesVisitor::visitLogarithmic(_anonymous_namespace_::MinMaxValuesVisitor *this, OZSpline *a2, uint64_t a3, uint64_t a4, CMTime *a5, CMTime *a6, const CMTime *a7, const CMTime *a8, double a9)
{
  int32_t v16;
  CMTime *v17;
  CMTime *v18;
  const PCString *v19;
  uint64_t result;
  double v21;
  double v22;
  double v23;
  double v24;
  OZChannelBase v25;

  v23 = 0.0;
  v24 = 0.0;
  OZInterpolator::OZInterpolator((OZInterpolator *)&v25);
  v25.var0 = (void **)&unk_1E65556A0;
  *(CMTime *)&v25.var5 = *a5;
  *(CMTime *)&v25.var1 = *a6;
  v16 = CMTimeCompare((CMTime *)&v25.var5, (CMTime *)&v25.var1);
  if (v16 <= 0)
    v17 = a5;
  else
    v17 = a6;
  if (v16 <= 0)
    v18 = a6;
  else
    v18 = a5;
  OZEaseInInterpolator::getMinMaxValues((uint64_t)&v25, (uint64_t)a2, a3, a4, v17, v18, &v24, &v23);
  v23 = v23 + a9;
  v24 = v24 + a9;
  result = OZChannelBase::setRangeName(&v25, v19);
  v21 = v24;
  if (*((double *)this + 1) < v24)
    v21 = *((double *)this + 1);
  v22 = v23;
  if (v23 < *((double *)this + 2))
    v22 = *((double *)this + 2);
  *((double *)this + 1) = v21;
  *((double *)this + 2) = v22;
  return result;
}

void sub_1B2C2845C(_Unwind_Exception *a1, const PCString *a2, uint64_t a3, OZChannelBase *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  OZChannelBase::setRangeName((OZChannelBase *)&a12, a2);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>>,std::reverse_iterator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>*>,std::reverse_iterator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>*>,std::reverse_iterator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>>,std::reverse_iterator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>*>,std::reverse_iterator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>*>,std::reverse_iterator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_QWORD *)(a3 - 32);
      a3 -= 32;
      *(_QWORD *)(v7 - 32) = v8;
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 24);
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 32;
      *((_QWORD *)&v14 + 1) -= 32;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>>,std::reverse_iterator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>>,std::reverse_iterator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>>,std::reverse_iterator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>>,std::reverse_iterator<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)(v1 + 8);
    if (v3)
    {
      *(_QWORD *)(v1 + 16) = v3;
      operator delete(v3);
    }
    v1 += 32;
  }
}

uint64_t std::__split_buffer<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<std::pair<OZChannel *,std::vector<_OZKeyframeInfo>>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    *(_QWORD *)(a1 + 16) = v2 - 32;
    v5 = *(void **)(v2 - 24);
    if (v5)
    {
      *(_QWORD *)(v2 - 16) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 32;
    }
  }
}

void OZCurve::OZCurve(OZCurve *this, double a2, double a3, double a4, double a5)
{
  OZSplineNode *v8;
  char *v9;
  _QWORD *v10;

  *(_QWORD *)this = off_1E65541A8;
  v8 = (OZSplineNode *)((char *)this + 40);
  v9 = (char *)this + 16;
  OZConstantNode::OZConstantNode((OZConstantNode *)((char *)this + 16), a5);
  OZSplineNode::OZSplineNode(v8, this);
  *((_QWORD *)this + 13) = 0;
  v10 = (_QWORD *)operator new();
  *v10 = 0;
  v10[1] = 0;
  v10[2] = 0;
  *((_QWORD *)this + 14) = v10;
  *((double *)this + 15) = a2;
  *((double *)this + 16) = a3;
  *((_QWORD *)this + 1) = v9;
  *((_DWORD *)this + 42) = 0;
  *((_WORD *)this + 68) = 1;
  *((_BYTE *)this + 138) = 1;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 18) = 0;
}

void sub_1B2C2889C(_Unwind_Exception *a1)
{
  OZConstantNode *v1;
  OZSplineNode *v2;

  OZSplineNode::~OZSplineNode(v2);
  OZConstantNode::~OZConstantNode(v1);
  _Unwind_Resume(a1);
}

void OZCurve::OZCurve(OZCurve *this, const OZCurve *a2, int a3)
{
  OZSplineNode *v6;
  OZSplineNode *v7;
  OZSplineState *v8;
  _QWORD *v9;
  OZRecordingNode *v10;
  int v11;

  *(_QWORD *)this = off_1E65541A8;
  v6 = (OZSplineNode *)((char *)this + 40);
  v7 = (OZSplineNode *)((char *)this + 16);
  OZConstantNode::OZConstantNode((OZConstantNode *)((char *)this + 16), 0.0);
  OZSplineNode::OZSplineNode(v6, this);
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  v8 = (OZSplineState *)*((_QWORD *)a2 + 20);
  if (!*((_BYTE *)v8 + 44))
  {
    v8 = (OZSplineState *)operator new();
    OZSplineState::OZSplineState(v8, *((const OZSplineState **)a2 + 20));
  }
  *((_QWORD *)this + 20) = v8;
  v9 = (_QWORD *)operator new();
  *v9 = 0;
  v9[1] = 0;
  v9[2] = 0;
  *((_QWORD *)this + 14) = v9;
  if (a3)
    OZCurve::cloneTree(this, a2);
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)a2 + 120);
  OZConstantNode::operator=((uint64_t)v7, (uint64_t)a2 + 16);
  OZSplineNode::operator=(v6, (uint64_t)a2 + 40);
  if (*((_QWORD *)a2 + 13))
  {
    v10 = (OZRecordingNode *)operator new();
    OZRecordingNode::OZRecordingNode(v10, *((const OZRecordingNode **)a2 + 13));
    *((_QWORD *)this + 13) = v10;
  }
  *((_WORD *)this + 68) = *((_WORD *)a2 + 68);
  *((_QWORD *)this + 18) = 0;
  *((_BYTE *)this + 138) = *((_BYTE *)a2 + 138);
  v11 = *((_DWORD *)a2 + 42);
  *((_DWORD *)this + 42) = v11;
  if (v11)
  {
    v7 = v6;
    if (v11 != 1)
      v7 = (OZSplineNode *)*((_QWORD *)this + 13);
  }
  *((_QWORD *)this + 1) = v7;
}

void sub_1B2C28A18(_Unwind_Exception *a1)
{
  OZConstantNode *v1;
  OZSplineNode *v2;
  uint64_t v3;

  MEMORY[0x1B5E29170](v3, 0x1000C40C6C45C81);
  OZSplineNode::~OZSplineNode(v2);
  OZConstantNode::~OZConstantNode(v1);
  _Unwind_Resume(a1);
}

void OZCurve::cloneTree(OZCurve *this, const OZCurve *a2)
{
  uint64_t v2;
  _QWORD *v3;
  unint64_t v6;
  void **v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = *((_QWORD *)a2 + 14);
  v3 = *(_QWORD **)v2;
  if (*(_QWORD *)(v2 + 8) != *(_QWORD *)v2)
  {
    LODWORD(v6) = 0;
    do
    {
      v7 = (void **)*((_QWORD *)this + 14);
      v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v3 + 128))(*v3);
      v9 = (uint64_t *)v7[1];
      v10 = (unint64_t)v7[2];
      if ((unint64_t)v9 >= v10)
      {
        v12 = ((char *)v9 - (_BYTE *)*v7) >> 3;
        if ((unint64_t)(v12 + 1) >> 61)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v13 = v10 - (_QWORD)*v7;
        v14 = v13 >> 2;
        if (v13 >> 2 <= (unint64_t)(v12 + 1))
          v14 = v12 + 1;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v14;
        if (v15)
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(v7 + 2), v15);
        else
          v16 = 0;
        v17 = (uint64_t *)&v16[8 * v12];
        *v17 = v8;
        v11 = v17 + 1;
        v19 = (char *)*v7;
        v18 = (char *)v7[1];
        if (v18 != *v7)
        {
          do
          {
            v20 = *((_QWORD *)v18 - 1);
            v18 -= 8;
            *--v17 = v20;
          }
          while (v18 != v19);
          v18 = (char *)*v7;
        }
        *v7 = v17;
        v7[1] = v11;
        v7[2] = &v16[8 * v15];
        if (v18)
          operator delete(v18);
      }
      else
      {
        *v9 = v8;
        v11 = v9 + 1;
      }
      v7[1] = v11;
      v6 = (v6 + 1);
      ++v3;
    }
    while (v6 < (uint64_t)(*(_QWORD *)(*((_QWORD *)a2 + 14) + 8) - **((_QWORD **)a2 + 14)) >> 3);
  }
}

void OZCurve::~OZCurve(OZCurve *this)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)this = off_1E65541A8;
  v2 = *((_QWORD *)this + 14);
LABEL_2:
  v3 = *(_QWORD **)v2;
  while (1)
  {
    v4 = *(_QWORD **)(v2 + 8);
    if (v3 == v4)
      break;
    v5 = *(v4 - 1);
    *(_QWORD *)(v2 + 8) = v4 - 1;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      v2 = *((_QWORD *)this + 14);
      goto LABEL_2;
    }
  }
  if (v3)
  {
    *(_QWORD *)(v2 + 8) = v3;
    operator delete(v3);
  }
  MEMORY[0x1B5E29170](v2, 0x80C40D6874129);
  *((_QWORD *)this + 14) = 0;
  v6 = *((_QWORD *)this + 13);
  if (v6)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    *((_QWORD *)this + 13) = 0;
  }
  if (!*(_BYTE *)(*((_QWORD *)this + 20) + 44))
  {
    MEMORY[0x1B5E29170]();
    *((_QWORD *)this + 20) = 0;
  }
  OZSplineNode::~OZSplineNode((OZSplineNode *)((char *)this + 40));
  OZConstantNode::~OZConstantNode((OZConstantNode *)((char *)this + 16));
}

__n128 OZCurve::operator=(uint64_t a1, uint64_t a2, uint8x8_t a3)
{
  uint64_t v5;
  uint64_t v6;
  OZSplineState *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  OZRecordingNode *v11;
  int v12;
  __n128 result;

  v5 = *(_QWORD *)(a2 + 160);
  v6 = *(_QWORD *)(a1 + 160);
  if (*(_BYTE *)(v5 + 44))
  {
    if (!*(_BYTE *)(v6 + 44))
    {
      MEMORY[0x1B5E29170]();
      *(_QWORD *)(a1 + 160) = 0;
      v5 = *(_QWORD *)(a2 + 160);
    }
    *(_QWORD *)(a1 + 160) = v5;
  }
  else if (*(_BYTE *)(v6 + 44))
  {
    v7 = (OZSplineState *)operator new();
    OZSplineState::OZSplineState(v7, *(const OZSplineState **)(a2 + 160));
    *(_QWORD *)(a1 + 160) = v7;
  }
  else
  {
    OZSplineState::operator=(v6, v5, a3);
  }
  OZConstantNode::operator=(a1 + 16, a2 + 16);
  v8 = a1 + 40;
  OZSplineNode::operator=((OZSplineNode *)(a1 + 40), a2 + 40);
  v9 = *(_QWORD *)(a2 + 104);
  v10 = *(_QWORD *)(a1 + 104);
  if (v9)
  {
    if (v10)
    {
      OZRecordingNode::operator=(v10, v9);
    }
    else
    {
      v11 = (OZRecordingNode *)operator new();
      OZRecordingNode::OZRecordingNode(v11, *(const OZRecordingNode **)(a2 + 104));
      *(_QWORD *)(a1 + 104) = v11;
    }
  }
  else if (v10)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
    *(_QWORD *)(a1 + 104) = 0;
  }
  v12 = *(_DWORD *)(a2 + 168);
  *(_DWORD *)(a1 + 168) = v12;
  if (v12)
  {
    if (v12 != 1)
      v8 = *(_QWORD *)(a1 + 104);
  }
  else
  {
    v8 = a1 + 16;
  }
  *(_QWORD *)(a1 + 8) = v8;
  result = *(__n128 *)(a2 + 120);
  *(__n128 *)(a1 + 120) = result;
  *(_BYTE *)(a1 + 136) = *(_BYTE *)(a2 + 136);
  *(_BYTE *)(a1 + 136) = *(_BYTE *)(a2 + 136);
  *(_WORD *)(a1 + 137) = *(_WORD *)(a2 + 137);
  return result;
}

void sub_1B2C28DF4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C406D9F4237);
  _Unwind_Resume(a1);
}

uint64_t OZCurve::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  const CMTime *v5;

  if (*(double *)(a1 + 120) == *(double *)(a2 + 120)
    && *(double *)(a1 + 128) == *(double *)(a2 + 128)
    && OZConstantNode::operator==(a1 + 16)
    && *(unsigned __int8 *)(a1 + 136) == *(unsigned __int8 *)(a2 + 136)
    && *(unsigned __int8 *)(a1 + 137) == *(unsigned __int8 *)(a2 + 137)
    && *(unsigned __int8 *)(a1 + 138) == *(unsigned __int8 *)(a2 + 138)
    && OZConstantNode::operator==(a1 + 40)
    && OZSplineState::operator==(*(unsigned __int8 **)(a1 + 160), *(unsigned __int8 **)(a2 + 160), v4, v5))
  {
    return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 136))(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 8));
  }
  else
  {
    return 0;
  }
}

uint64_t OZCurve::setSplineState(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  PVInstructionGraphContext *v5;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 160);
  if (v4 && !*(_BYTE *)(v4 + 44))
    MEMORY[0x1B5E29170]();
  *(_QWORD *)(a1 + 160) = a2;
  v5 = (PVInstructionGraphContext *)(a1 + 40);
  result = PVInstructionGraphContext::HGNodeCache(v5);
  if (result)
  {
    result = PVInstructionGraphContext::HGNodeCache(v5);
    *(_QWORD *)(result + 168) = a2;
  }
  return result;
}

uint64_t OZCurve::createLocalSplineState(OZCurve *this)
{
  uint64_t v2;
  uint64_t result;

  *((_QWORD *)this + 20) = OZSplineState::createLocalCopy(*((OZSplineState **)this + 20));
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    return *((_QWORD *)this + 20);
  v2 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  result = *((_QWORD *)this + 20);
  *(_QWORD *)(v2 + 168) = result;
  return result;
}

OZSplineState *OZSplineState::createLocalCopy(OZSplineState *this)
{
  OZSplineState *v2;

  if (!*((_BYTE *)this + 44))
    return this;
  v2 = (OZSplineState *)operator new();
  OZSplineState::OZSplineState(v2, this);
  *((_BYTE *)v2 + 44) = 0;
  return v2;
}

void sub_1B2C29004(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1000C40C6C45C81);
  _Unwind_Resume(a1);
}

double OZCurve::setRootNode(OZCurve *this, const CMTime *a2, double a3)
{
  PVInstructionGraphContext *v5;
  uint64_t v6;
  double result;

  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  *((_QWORD *)this + 1) = (char *)this + 40;
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
    || (v6 = PVInstructionGraphContext::HGNodeCache(v5),
        ((*(_QWORD *)(v6 + 24) - *(_QWORD *)(v6 + 16)) & 0x7FFFFFFF8) == 0))
  {
    *((double *)this + 6) = a3;
  }
  result = *((double *)this + 4);
  *((double *)this + 7) = result;
  *((double *)this + 3) = a3;
  *((_DWORD *)this + 42) = 1;
  return result;
}

uint64_t OZCurve::getCurrentRangeU(OZCurve *this, CMTime *a2)
{
  CMTime v4;

  if (a2)
  {
    (*(void (**)(CMTime *__return_ptr))(**((_QWORD **)this + 1) + 112))(&v4);
    *a2 = v4;
  }
  return 1;
}

uint64_t OZCurve::getCurrentMaxValueV(OZCurve *this, double *a2, uint64_t a3)
{
  *a2 = (*(double (**)(_QWORD, uint64_t))(**((_QWORD **)this + 1) + 144))(*((_QWORD *)this + 1), a3);
  return 1;
}

uint64_t OZCurve::getCurrentMinValueV(OZCurve *this, double *a2, uint64_t a3)
{
  *a2 = (*(double (**)(_QWORD, uint64_t))(**((_QWORD **)this + 1) + 152))(*((_QWORD *)this + 1), a3);
  return 1;
}

uint64_t OZCurve::getCurrentMaxValueU(OZCurve *this, CMTime *a2)
{
  CMTime v4;

  (*(void (**)(CMTime *__return_ptr))(**((_QWORD **)this + 1) + 160))(&v4);
  *a2 = v4;
  return 1;
}

uint64_t OZCurve::getCurrentMinValueU(OZCurve *this, CMTime *a2)
{
  CMTime v4;

  (*(void (**)(CMTime *__return_ptr))(**((_QWORD **)this + 1) + 168))(&v4);
  *a2 = v4;
  return 1;
}

uint64_t OZCurve::getCurveDefaultValue(OZCurve *this, double *a2)
{
  if (a2)
    *a2 = (*(double (**)(_QWORD))(**((_QWORD **)this + 1) + 80))(*((_QWORD *)this + 1));
  return 1;
}

uint64_t OZCurve::getCurveInitialValue(OZCurve *this, double *a2)
{
  double v4;
  double v5;
  double v6;

  if (a2)
  {
    v4 = (*(double (**)(_QWORD))(**((_QWORD **)this + 1) + 96))(*((_QWORD *)this + 1));
    v5 = *((double *)this + 16);
    if (v4 <= v5)
      v5 = v4;
    if (v4 >= *((double *)this + 15))
      v6 = v5;
    else
      v6 = *((double *)this + 15);
    *a2 = v6;
  }
  return 1;
}

uint64_t OZCurve::setCurveToDefault(OZCurve *this)
{
  (*(void (**)(_QWORD))(**((_QWORD **)this + 1) + 200))(*((_QWORD *)this + 1));
  return 1;
}

void OZCurve::setIsSpline(OZCurve *this, int a2, const CMTime *a3)
{
  int v4;
  double v5;
  const CMTime *v6;
  double v7;
  uint64_t v8;

  v4 = *((_DWORD *)this + 42);
  if (a2)
  {
    if (!v4)
    {
      v5 = (*(double (**)(_QWORD, _QWORD, const CMTime *, double, double))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1), MEMORY[0x1E0CA2E68], a3, 0.0, 0.0);
      OZCurve::setRootNode(this, v6, v5);
    }
  }
  else if (v4 == 1)
  {
    v7 = OZSplineNode::solveNode((OZSplineNode *)((char *)this + 40), a3, 0.0, 0.0);
    *((double *)this + 6) = v7;
    v8 = *((_QWORD *)this + 7);
    *((double *)this + 3) = v7;
    *((_QWORD *)this + 4) = v8;
    *((_QWORD *)this + 1) = (char *)this + 16;
    *((_DWORD *)this + 42) = 0;
  }
}

BOOL OZCurve::isAnimated(OZCurve *this)
{
  _BOOL8 result;
  PVInstructionGraphContext *v3;
  uint64_t v4;

  result = 0;
  if (*((_BYTE *)this + 138))
  {
    if (*(_BYTE *)(OZCoreGlobals::getInstance((OZCoreGlobals *)this) + 8))
      return 1;
    v3 = (PVInstructionGraphContext *)((char *)this + 40);
    if (PVInstructionGraphContext::HGNodeCache(v3))
    {
      v4 = PVInstructionGraphContext::HGNodeCache(v3);
      if (((*(_QWORD *)(v4 + 24) - *(_QWORD *)(v4 + 16)) & 0x7FFFFFFF8) != 0)
        return 1;
    }
  }
  return result;
}

uint64_t OZCurve::setCurveKeyframable(OZCurve *this, char a2)
{
  *((_BYTE *)this + 138) = a2;
  return 1;
}

uint64_t OZCurve::isCurveKeyframable(OZCurve *this)
{
  return *((unsigned __int8 *)this + 138);
}

uint64_t OZCurve::getAbsoluteMaxValueV(OZCurve *this, double *a2)
{
  *a2 = *((double *)this + 16);
  return 1;
}

uint64_t OZCurve::getAbsoluteMinValueV(OZCurve *this, double *a2)
{
  *a2 = *((double *)this + 15);
  return 1;
}

uint64_t OZCurve::setAbsoluteMaxValueV(OZCurve *this, double a2)
{
  *((double *)this + 16) = a2;
  return 1;
}

uint64_t OZCurve::setAbsoluteMinValueV(OZCurve *this, double a2)
{
  *((double *)this + 15) = a2;
  return 1;
}

BOOL OZCurve::isCurveAnimated(OZCurve *this, BOOL *a2)
{
  BOOL v4;
  uint64_t v5;

  v4 = 1;
  if (!*(_BYTE *)(OZCoreGlobals::getInstance((OZCoreGlobals *)this) + 8))
  {
    if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
      || (v5 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)),
          ((*(_QWORD *)(v5 + 24) - *(_QWORD *)(v5 + 16)) & 0x7FFFFFFF8) == 0))
    {
      v4 = 0;
    }
  }
  *a2 = v4;
  return OZCurve::isAnimated(this);
}

BOOL OZCurve::getCurveType(OZCurve *this, unsigned int *a2)
{
  if (a2)
    *a2 = (*((_DWORD *)this + 42) - 1) < 2;
  return a2 != 0;
}

uint64_t OZCurve::setCurveType(OZCurve *this, int a2)
{
  uint64_t v2;

  v2 = 0;
  if (!a2)
    goto LABEL_5;
  if (a2 == 3 || a2 == 1)
  {
    LODWORD(v2) = 1;
LABEL_5:
    OZCurve::setIsSpline(this, v2, MEMORY[0x1E0CA2E68]);
    return 1;
  }
  return v2;
}

uint64_t OZCurve::setCurveDeriveTangents(OZCurve *this, int a2)
{
  char v2;
  uint64_t LocalSplineState;

  if ((*(_BYTE *)(*((_QWORD *)this + 20) + 2) != 0) != a2)
  {
    v2 = a2;
    LocalSplineState = OZCurve::createLocalSplineState(this);
    *((_QWORD *)this + 20) = LocalSplineState;
    *(_BYTE *)(LocalSplineState + 2) = v2;
  }
  return 1;
}

uint64_t OZCurve::isCurveDeriveTangents(OZCurve *this, BOOL *a2)
{
  *a2 = *(_BYTE *)(*((_QWORD *)this + 20) + 2);
  return 1;
}

OZCurve *OZCurve::setTreeProperties(OZCurve *this)
{
  uint64_t v1;
  _QWORD *v2;
  OZCurve *v3;

  *((_WORD *)this + 68) = 1;
  v1 = *((_QWORD *)this + 14);
  v2 = *(_QWORD **)v1;
  if (*(_QWORD *)(v1 + 8) != *(_QWORD *)v1)
  {
    v3 = this;
    do
    {
      if (((*(uint64_t (**)(_QWORD))(*(_QWORD *)*v2 + 176))(*v2) & 1) == 0)
        *((_BYTE *)v3 + 136) = 0;
      this = (OZCurve *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*v2 + 184))(*v2);
      if ((_DWORD)this)
        *((_BYTE *)v3 + 137) = 1;
      ++v2;
    }
    while (v2 != *(_QWORD **)(*((_QWORD *)v3 + 14) + 8));
  }
  return this;
}

uint64_t OZCurve::processCurve(OZCurve *this, OZCurveNodeParam *a2, double *a3, void *a4)
{
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  char *v31;
  char *v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  __int128 *i;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  uint64_t v57;
  __int128 v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  char *v67;
  char *v68;
  OZCurveNodeParam *v69;
  uint64_t v70;
  double *v71;
  double v72;
  void *__p;
  char *j;
  char *v75;

  if (a4)
  {
    v6 = *((_QWORD *)this + 14);
    v8 = *(_QWORD **)v6;
    v7 = *(_QWORD **)(v6 + 8);
    if (v8 == v7)
      return 0;
    do
    {
      v9 = (void *)*v8;
      v8 += *v8 != (_QWORD)a4;
    }
    while (v8 != v7 && v9 != a4);
    if (v9 != a4)
      return 0;
    __p = 0;
    j = 0;
    v75 = 0;
    v20 = operator new();
    OZCurveNodeParam::OZCurveNodeParam(v20, (uint64_t)a2);
    *(_OWORD *)(v20 + 24) = *(_OWORD *)(v20 + 96);
    *(_QWORD *)(v20 + 40) = *(_QWORD *)(v20 + 112);
    *(_QWORD *)(v20 + 64) = *(_QWORD *)(v20 + 136);
    *(_OWORD *)(v20 + 48) = *(_OWORD *)(v20 + 120);
    *(_DWORD *)(v20 + 72) = *(_DWORD *)(v20 + 144);
    *(_BYTE *)(v20 + 88) = 0;
    *(_QWORD *)(v20 + 80) = *(_QWORD *)(v20 + 152);
    (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v8 + 104))(*v8, v20);
    std::vector<std::pair<OZCurveNode *,OZCurveNodeParam *>>::reserve(&__p, ((uint64_t)(*(_QWORD *)(*((_QWORD *)this + 14) + 8) - **((_QWORD **)this + 14)) >> 3) + 1);
    v21 = *v8;
    v22 = j;
    if (j >= v75)
    {
      v24 = (j - (_BYTE *)__p) >> 4;
      v25 = v24 + 1;
      if ((unint64_t)(v24 + 1) >> 60)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v26 = v75 - (_BYTE *)__p;
      if ((v75 - (_BYTE *)__p) >> 3 > v25)
        v25 = v26 >> 3;
      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0)
        v27 = 0xFFFFFFFFFFFFFFFLL;
      else
        v27 = v25;
      if (v27)
        v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&v75, v27);
      else
        v28 = 0;
      v34 = &v28[16 * v24];
      v35 = &v28[16 * v27];
      *(_QWORD *)v34 = v21;
      *((_QWORD *)v34 + 1) = v20;
      v23 = v34 + 16;
      v37 = (char *)__p;
      v36 = j;
      if (j != __p)
      {
        do
        {
          *((_OWORD *)v34 - 1) = *((_OWORD *)v36 - 1);
          v34 -= 16;
          v36 -= 16;
        }
        while (v36 != v37);
        v36 = (char *)__p;
      }
      __p = v34;
      j = v23;
      v75 = v35;
      if (v36)
        operator delete(v36);
    }
    else
    {
      *(_QWORD *)j = v21;
      *((_QWORD *)v22 + 1) = v20;
      v23 = v22 + 16;
    }
    j = v23;
    for (i = (__int128 *)MEMORY[0x1E0CA2E68]; v8 != **((_QWORD ***)this + 14); j = v47)
    {
      v39 = v20;
      if (((*(uint64_t (**)(_QWORD))(*(_QWORD *)*v8 + 192))(*v8) & 1) != 0)
        break;
      v20 = operator new();
      *(_WORD *)v20 = 1;
      *(_QWORD *)(v20 + 8) = 0;
      *(_DWORD *)(v20 + 72) = 0;
      *(_QWORD *)(v20 + 80) = 0;
      *(_BYTE *)(v20 + 88) = 0;
      v40 = *i;
      *(_OWORD *)(v20 + 24) = *i;
      v41 = *((_QWORD *)i + 2);
      *(_QWORD *)(v20 + 40) = v41;
      *(_OWORD *)(v20 + 48) = v40;
      *(_QWORD *)(v20 + 64) = v41;
      *(_DWORD *)(v20 + 144) = 0;
      *(_QWORD *)(v20 + 152) = 0;
      *(_BYTE *)(v20 + 160) = 0;
      *(_QWORD *)(v20 + 112) = v41;
      *(_OWORD *)(v20 + 96) = v40;
      *(_OWORD *)(v20 + 120) = v40;
      *(_QWORD *)(v20 + 136) = v41;
      v42 = *(_QWORD *)(v39 + 40);
      *(_OWORD *)(v20 + 96) = *(_OWORD *)(v39 + 24);
      *(_QWORD *)(v20 + 112) = v42;
      v43 = *(_QWORD *)(v39 + 64);
      *(_OWORD *)(v20 + 120) = *(_OWORD *)(v39 + 48);
      *(_QWORD *)(v20 + 136) = v43;
      *(_DWORD *)(v20 + 144) = *(_DWORD *)(v39 + 72);
      *(_BYTE *)(v20 + 160) = 0;
      *(_QWORD *)(v20 + 152) = *(_QWORD *)(v39 + 80);
      *(_BYTE *)(v20 + 1) = *(_BYTE *)(v39 + 1);
      *(_QWORD *)(v20 + 8) = *(_QWORD *)(v39 + 8);
      v44 = *--v8;
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v44 + 104))(v44, v20);
      v45 = *v8;
      v46 = j;
      if (j >= v75)
      {
        v48 = (j - (_BYTE *)__p) >> 4;
        v49 = v48 + 1;
        if ((unint64_t)(v48 + 1) >> 60)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v50 = v75 - (_BYTE *)__p;
        if ((v75 - (_BYTE *)__p) >> 3 > v49)
          v49 = v50 >> 3;
        if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF0)
          v51 = 0xFFFFFFFFFFFFFFFLL;
        else
          v51 = v49;
        if (v51)
          v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&v75, v51);
        else
          v52 = 0;
        v53 = &v52[16 * v48];
        *(_QWORD *)v53 = v45;
        *((_QWORD *)v53 + 1) = v20;
        v55 = (char *)__p;
        v54 = j;
        v56 = v53;
        if (j != __p)
        {
          do
          {
            *((_OWORD *)v56 - 1) = *((_OWORD *)v54 - 1);
            v56 -= 16;
            v54 -= 16;
          }
          while (v54 != v55);
          v54 = (char *)__p;
        }
        v47 = v53 + 16;
        __p = v56;
        j = v53 + 16;
        v75 = &v52[16 * v51];
        if (v54)
          operator delete(v54);
      }
      else
      {
        *(_QWORD *)j = v45;
        *((_QWORD *)v46 + 1) = v20;
        v47 = v46 + 16;
      }
    }
    v57 = operator new();
    *(_WORD *)v57 = 1;
    *(_QWORD *)(v57 + 8) = 0;
    *(_DWORD *)(v57 + 72) = 0;
    *(_QWORD *)(v57 + 80) = 0;
    *(_BYTE *)(v57 + 88) = 0;
    v58 = *i;
    *(_OWORD *)(v57 + 24) = *i;
    v59 = *((_QWORD *)i + 2);
    *(_QWORD *)(v57 + 40) = v59;
    *(_OWORD *)(v57 + 48) = v58;
    *(_QWORD *)(v57 + 64) = v59;
    *(_DWORD *)(v57 + 144) = 0;
    *(_QWORD *)(v57 + 152) = 0;
    *(_BYTE *)(v57 + 160) = 0;
    *(_QWORD *)(v57 + 112) = v59;
    *(_OWORD *)(v57 + 96) = v58;
    *(_OWORD *)(v57 + 120) = v58;
    *(_QWORD *)(v57 + 136) = v59;
    v60 = *(_QWORD *)(v20 + 40);
    *(_OWORD *)(v57 + 96) = *(_OWORD *)(v20 + 24);
    *(_QWORD *)(v57 + 112) = v60;
    v61 = *(_QWORD *)(v20 + 64);
    *(_OWORD *)(v57 + 120) = *(_OWORD *)(v20 + 48);
    *(_QWORD *)(v57 + 136) = v61;
    *(_DWORD *)(v57 + 144) = *(_DWORD *)(v20 + 72);
    *(_BYTE *)(v57 + 160) = 0;
    *(_QWORD *)(v57 + 152) = *(_QWORD *)(v20 + 80);
    *(_BYTE *)(v57 + 1) = *(_BYTE *)(v20 + 1);
    *(_QWORD *)(v57 + 8) = *(_QWORD *)(v20 + 8);
    (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 1) + 104))(*((_QWORD *)this + 1), v57);
    v62 = *((_QWORD *)this + 1);
    v14 = j;
    if (j < v75)
    {
      *(_QWORD *)j = v62;
      *((_QWORD *)v14 + 1) = v57;
      goto LABEL_61;
    }
    v63 = (j - (_BYTE *)__p) >> 4;
    v64 = v63 + 1;
    if ((unint64_t)(v63 + 1) >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v65 = v75 - (_BYTE *)__p;
    if ((v75 - (_BYTE *)__p) >> 3 > v64)
      v64 = v65 >> 3;
    if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF0)
      v66 = 0xFFFFFFFFFFFFFFFLL;
    else
      v66 = v64;
    if (v66)
      v67 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&v75, v66);
    else
      v67 = 0;
    v29 = &v67[16 * v63];
    v30 = &v67[16 * v66];
    *(_QWORD *)v29 = v62;
    *((_QWORD *)v29 + 1) = v57;
    v31 = v29 + 16;
    v68 = (char *)__p;
    v32 = j;
    if (j == __p)
    {
LABEL_74:
      __p = v29;
      j = v31;
      v75 = v30;
      if (v32)
        operator delete(v32);
      goto LABEL_76;
    }
    do
    {
      *((_OWORD *)v29 - 1) = *((_OWORD *)v32 - 1);
      v29 -= 16;
      v32 -= 16;
    }
    while (v32 != v68);
LABEL_73:
    v32 = (char *)__p;
    goto LABEL_74;
  }
  __p = 0;
  j = 0;
  v75 = 0;
  v12 = operator new();
  OZCurveNodeParam::OZCurveNodeParam(v12, (uint64_t)a2);
  *(_OWORD *)(v12 + 24) = *(_OWORD *)(v12 + 96);
  *(_QWORD *)(v12 + 40) = *(_QWORD *)(v12 + 112);
  *(_QWORD *)(v12 + 64) = *(_QWORD *)(v12 + 136);
  *(_OWORD *)(v12 + 48) = *(_OWORD *)(v12 + 120);
  *(_DWORD *)(v12 + 72) = *(_DWORD *)(v12 + 144);
  *(_BYTE *)(v12 + 88) = 0;
  *(_QWORD *)(v12 + 80) = *(_QWORD *)(v12 + 152);
  (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 1) + 104))(*((_QWORD *)this + 1), v12);
  v13 = *((_QWORD *)this + 1);
  v14 = j;
  if (j >= v75)
  {
    v15 = (j - (_BYTE *)__p) >> 4;
    v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v17 = v75 - (_BYTE *)__p;
    if ((v75 - (_BYTE *)__p) >> 3 > v16)
      v16 = v17 >> 3;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0)
      v18 = 0xFFFFFFFFFFFFFFFLL;
    else
      v18 = v16;
    if (v18)
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&v75, v18);
    else
      v19 = 0;
    v29 = &v19[16 * v15];
    v30 = &v19[16 * v18];
    *(_QWORD *)v29 = v13;
    *((_QWORD *)v29 + 1) = v12;
    v31 = v29 + 16;
    v33 = (char *)__p;
    v32 = j;
    if (j == __p)
      goto LABEL_74;
    do
    {
      *((_OWORD *)v29 - 1) = *((_OWORD *)v32 - 1);
      v29 -= 16;
      v32 -= 16;
    }
    while (v32 != v33);
    goto LABEL_73;
  }
  *(_QWORD *)j = v13;
  *((_QWORD *)v14 + 1) = v12;
LABEL_61:
  v31 = v14 + 16;
LABEL_76:
  for (j = v31; __p != v31; j = v31)
  {
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)v31 - 2) + 24))(*((_QWORD *)v31 - 2), *((_QWORD *)v31 - 1));
    v69 = (OZCurveNodeParam *)*((_QWORD *)v31 - 1);
    if (v69)
    {
      OZCurveNodeParam::~OZCurveNodeParam(v69);
      MEMORY[0x1B5E29170]();
    }
    *((_QWORD *)v31 - 1) = 0;
    v31 = j - 16;
  }
  v70 = *((unsigned int *)a2 + 36);
  if ((_DWORD)v70)
  {
    v71 = (double *)*((_QWORD *)a2 + 19);
    do
    {
      v72 = *((double *)this + 16);
      if (*v71 > v72 || (v72 = *((double *)this + 15), *v71 < v72))
        *v71 = v72;
      ++v71;
      --v70;
    }
    while (v70);
  }
  j = v31;
  operator delete(v31);
  return 1;
}

void sub_1B2C29C88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::vector<std::pair<OZCurveNode *,OZCurveNodeParam *>>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 4)
  {
    if (a2 >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF0];
    v9 = &v6[16 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - 1) = *((_OWORD *)v10 - 1);
        v12 -= 16;
        v10 -= 16;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t OZCurve::processTree(OZCurve *this, OZCurveNodeParam *a2, CMTime **a3, double **a4)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  CMTime *v13;
  __int128 v14;
  CMTime v16;
  CMTime v17;
  CMTime v18;

  v16 = *(CMTime *)((_BYTE *)a2 + 4);
  v6 = (uint64_t *)*((_QWORD *)this + 14);
  v8 = *v6;
  v7 = v6[1];
  if (v8 == v7)
    v9 = 0;
  else
    v9 = *(void **)(v7 - 8);
  v10 = OZCurve::processCurve(this, a2, (double *)a3, v9);
  if (a3 && *((_DWORD *)a2 + 36))
  {
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = &(*a3)[v11];
      v14 = *(_OWORD *)&v16.value;
      v13->epoch = v16.epoch;
      *(_OWORD *)&v13->value = v14;
      v18 = v16;
      v17 = *(CMTime *)((_BYTE *)a2 + 5);
      PC_CMTimeSaferAdd(&v18, &v17, (uint64_t)&v16);
      ++v12;
      ++v11;
    }
    while (v12 < *((unsigned int *)a2 + 36));
  }
  return v10;
}

uint64_t OZCurve::processTree(OZCurve *this, OZCurveNodeParam *a2, CMTime **a3, double **a4, void *a5)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  CMTime *v10;
  __int128 v11;
  CMTime v13;
  CMTime v14;
  CMTime v15;

  v13 = *(CMTime *)((_BYTE *)a2 + 4);
  v7 = OZCurve::processCurve(this, a2, (double *)a3, a5);
  if (a3 && *a3 && *((_DWORD *)a2 + 36))
  {
    v8 = 0;
    v9 = 0;
    do
    {
      v10 = &(*a3)[v8];
      v11 = *(_OWORD *)&v13.value;
      v10->epoch = v13.epoch;
      *(_OWORD *)&v10->value = v11;
      v15 = v13;
      v14 = *(CMTime *)((_BYTE *)a2 + 5);
      PC_CMTimeSaferAdd(&v15, &v14, (uint64_t)&v13);
      ++v9;
      ++v8;
    }
    while (v9 < *((unsigned int *)a2 + 36));
  }
  return v7;
}

BOOL OZCurve::getSplineSamplesAndIgnoreLinear(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  PVInstructionGraphContext *v11;
  uint64_t v12;
  uint64_t v13;

  v11 = (PVInstructionGraphContext *)(a1 + 40);
  v12 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)(a1 + 40));
  if (v12)
  {
    v13 = PVInstructionGraphContext::HGNodeCache(v11);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v13 + 80))(v13, a2, a3, a4, a5, a6);
  }
  return v12 != 0;
}

uint64_t OZCurve::getCurveDerivativesSamples(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;

  v11 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)(a1 + 40));
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v11 + 64))(v11, a2, a3, a4, a5, a6, MEMORY[0x1E0CA2E68]);
  return 1;
}

uint64_t OZCurve::getCurveSamples(OZCurve *a1, unsigned int *a2, uint64_t a3, uint64_t a4, Float64 a5, Float64 a6)
{
  double *v12;
  unint64_t v13;
  CMTimeValue v14;
  CMTimeEpoch v15;
  double Seconds;
  double v17;
  unint64_t v18;
  double *v19;
  double *v20;
  double *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  double *v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  CMTime v42;
  CMTime v43;
  double *v44;
  __int16 v45;
  uint64_t v46;
  CMTime v47;
  CMTime v48;
  int v49;
  uint64_t v50;
  char v51;
  CMTime v52;
  CMTime v53;
  int v54;
  double *v55;
  char v56;

  v45 = 1;
  v46 = 0;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v47 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  v48 = v47;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v52 = v47;
  v53 = v47;
  v44 = 0;
  if (a4)
  {
    v12 = (double *)operator new[]();
    v44 = v12;
  }
  else
  {
    v12 = 0;
  }
  OZFigTimeForChannelSeconds(&v43, a5, 0x40000);
  v52 = v43;
  v54 = *a2;
  OZFigTimeForChannelSeconds(&v43, a6, 0x40000);
  v53 = v43;
  HIBYTE(v45) = 0;
  v55 = v12;
  v46 = 0;
  v43.value = 0;
  if (a3)
  {
    v43.value = operator new[]();
    OZCurve::processTree(a1, (OZCurveNodeParam *)&v45, (CMTime **)&v43, &v44);
  }
  else
  {
    OZCurve::processTree(a1, (OZCurveNodeParam *)&v45, 0, &v44);
  }
  if (v43.value)
  {
    std::vector<double>::reserve((void **)a3, *a2);
    if (*a2)
    {
      v13 = 0;
      do
      {
        v14 = v43.value + 24 * v13;
        v15 = *(_QWORD *)(v14 + 16);
        *(_OWORD *)&v42.value = *(_OWORD *)v14;
        v42.epoch = v15;
        Seconds = CMTimeGetSeconds(&v42);
        v17 = Seconds;
        v19 = *(double **)(a3 + 8);
        v18 = *(_QWORD *)(a3 + 16);
        if ((unint64_t)v19 >= v18)
        {
          v21 = *(double **)a3;
          v22 = ((uint64_t)v19 - *(_QWORD *)a3) >> 3;
          v23 = v22 + 1;
          if ((unint64_t)(v22 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v24 = v18 - (_QWORD)v21;
          if (v24 >> 2 > v23)
            v23 = v24 >> 2;
          if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8)
            v25 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v25 = v23;
          if (v25)
          {
            v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a3 + 16, v25);
            v21 = *(double **)a3;
            v19 = *(double **)(a3 + 8);
          }
          else
          {
            v26 = 0;
          }
          v27 = (double *)&v26[8 * v22];
          *v27 = v17;
          v20 = v27 + 1;
          while (v19 != v21)
          {
            v28 = *((_QWORD *)v19-- - 1);
            *((_QWORD *)v27-- - 1) = v28;
          }
          *(_QWORD *)a3 = v27;
          *(_QWORD *)(a3 + 8) = v20;
          *(_QWORD *)(a3 + 16) = &v26[8 * v25];
          if (v21)
            operator delete(v21);
        }
        else
        {
          *v19 = Seconds;
          v20 = v19 + 1;
        }
        *(_QWORD *)(a3 + 8) = v20;
        ++v13;
      }
      while (v13 < *a2);
    }
    if (v43.value)
      MEMORY[0x1B5E2914C](v43.value, 0x1000C80504FFAC1);
    v43.value = 0;
  }
  if (a4)
  {
    std::vector<double>::reserve((void **)a4, *a2);
    if (*a2)
    {
      v29 = 0;
      v30 = (_QWORD *)(a4 + 16);
      v31 = *(_QWORD **)(a4 + 8);
      do
      {
        if ((unint64_t)v31 >= *v30)
        {
          v33 = *(_QWORD **)a4;
          v34 = ((uint64_t)v31 - *(_QWORD *)a4) >> 3;
          v35 = v34 + 1;
          if ((unint64_t)(v34 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v36 = *v30 - (_QWORD)v33;
          if (v36 >> 2 > v35)
            v35 = v36 >> 2;
          if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8)
            v37 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v37 = v35;
          if (v37)
          {
            v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 16, v37);
            v33 = *(_QWORD **)a4;
            v31 = *(_QWORD **)(a4 + 8);
          }
          else
          {
            v38 = 0;
          }
          v39 = &v38[8 * v34];
          *(double *)v39 = v12[v29];
          v32 = v39 + 8;
          while (v31 != v33)
          {
            v40 = *--v31;
            *((_QWORD *)v39 - 1) = v40;
            v39 -= 8;
          }
          *(_QWORD *)a4 = v39;
          *(_QWORD *)(a4 + 8) = v32;
          *(_QWORD *)(a4 + 16) = &v38[8 * v37];
          if (v33)
            operator delete(v33);
        }
        else
        {
          *v31 = *(_QWORD *)&v12[v29];
          v32 = v31 + 1;
        }
        *(_QWORD *)(a4 + 8) = v32;
        ++v29;
        v31 = v32;
      }
      while (v29 < *a2);
    }
    if (v12)
      MEMORY[0x1B5E2914C](v12, 0x1000C8000313F17);
  }
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)&v45);
  return 1;
}

void sub_1B2C2A430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)va);
  _Unwind_Resume(a1);
}

void std::vector<double>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_QWORD *)v11 - 1);
        v11 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t OZCurve::getCurveSamples(OZCurve *a1, __int128 *a2, __int128 *a3, unsigned int *a4, char **a5, uint64_t a6)
{
  double *v12;
  unint64_t v13;
  _QWORD *v14;
  char *v15;
  CMTime *v16;
  __int128 v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  __int128 v23;
  char *v24;
  char *v25;
  char *v26;
  __int128 v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  char *v38;
  uint64_t v39;
  CMTime *v41;
  double *v42;
  __int16 v43;
  uint64_t v44;
  __int128 v45;
  uint64_t v46;
  __int128 v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  char v51;
  __int128 v52;
  uint64_t v53;
  __int128 v54;
  uint64_t v55;
  int v56;
  double *v57;
  char v58;

  v43 = 1;
  v44 = 0;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v45 = *MEMORY[0x1E0CA2E68];
  v46 = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
  v47 = v45;
  v48 = v46;
  v56 = 0;
  v57 = 0;
  v58 = 0;
  v53 = v46;
  v52 = v45;
  v54 = v45;
  v55 = v46;
  v42 = 0;
  if (a6)
  {
    v12 = (double *)operator new[]();
    v42 = v12;
  }
  else
  {
    v12 = 0;
  }
  v52 = *a2;
  v53 = *((_QWORD *)a2 + 2);
  v56 = *a4;
  v54 = *a3;
  v55 = *((_QWORD *)a3 + 2);
  v57 = v12;
  HIBYTE(v43) = 0;
  v44 = 0;
  v41 = 0;
  if (a5)
  {
    v41 = (CMTime *)operator new[]();
    OZCurve::processTree(a1, (OZCurveNodeParam *)&v43, &v41, &v42);
  }
  else
  {
    OZCurve::processTree(a1, (OZCurveNodeParam *)&v43, 0, &v42);
  }
  if (v41)
  {
    std::vector<CMTime>::reserve((void **)a5, *a4);
    if (*a4)
    {
      v13 = 0;
      v14 = a5 + 2;
      v15 = a5[1];
      do
      {
        v16 = &v41[v13];
        if ((unint64_t)v15 >= *v14)
        {
          v18 = 0xAAAAAAAAAAAAAAABLL * ((v15 - *a5) >> 3);
          v19 = v18 + 1;
          if (v18 + 1 > 0xAAAAAAAAAAAAAAALL)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          if (0x5555555555555556 * ((uint64_t)(*v14 - (_QWORD)*a5) >> 3) > v19)
            v19 = 0x5555555555555556 * ((uint64_t)(*v14 - (_QWORD)*a5) >> 3);
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v14 - (_QWORD)*a5) >> 3) >= 0x555555555555555)
            v20 = 0xAAAAAAAAAAAAAAALL;
          else
            v20 = v19;
          if (v20)
            v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a5 + 2), v20);
          else
            v21 = 0;
          v22 = &v21[24 * v18];
          v23 = *(_OWORD *)&v16->value;
          *((_QWORD *)v22 + 2) = v16->epoch;
          *(_OWORD *)v22 = v23;
          v25 = *a5;
          v24 = a5[1];
          v26 = v22;
          if (v24 != *a5)
          {
            do
            {
              v27 = *(_OWORD *)(v24 - 24);
              *((_QWORD *)v26 - 1) = *((_QWORD *)v24 - 1);
              *(_OWORD *)(v26 - 24) = v27;
              v26 -= 24;
              v24 -= 24;
            }
            while (v24 != v25);
            v24 = *a5;
          }
          v15 = v22 + 24;
          *a5 = v26;
          a5[1] = v22 + 24;
          a5[2] = &v21[24 * v20];
          if (v24)
            operator delete(v24);
        }
        else
        {
          v17 = *(_OWORD *)&v16->value;
          *((_QWORD *)v15 + 2) = v16->epoch;
          *(_OWORD *)v15 = v17;
          v15 += 24;
        }
        a5[1] = v15;
        ++v13;
      }
      while (v13 < *a4);
    }
    if (v41)
      MEMORY[0x1B5E2914C](v41, 0x1000C80504FFAC1);
    v41 = 0;
  }
  if (a6)
  {
    std::vector<double>::reserve((void **)a6, *a4);
    if (*a4)
    {
      v28 = 0;
      v29 = (_QWORD *)(a6 + 16);
      v30 = *(_QWORD **)(a6 + 8);
      do
      {
        if ((unint64_t)v30 >= *v29)
        {
          v32 = *(_QWORD **)a6;
          v33 = ((uint64_t)v30 - *(_QWORD *)a6) >> 3;
          v34 = v33 + 1;
          if ((unint64_t)(v33 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v35 = *v29 - (_QWORD)v32;
          if (v35 >> 2 > v34)
            v34 = v35 >> 2;
          if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8)
            v36 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v36 = v34;
          if (v36)
          {
            v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a6 + 16, v36);
            v32 = *(_QWORD **)a6;
            v30 = *(_QWORD **)(a6 + 8);
          }
          else
          {
            v37 = 0;
          }
          v38 = &v37[8 * v33];
          *(double *)v38 = v12[v28];
          v31 = v38 + 8;
          while (v30 != v32)
          {
            v39 = *--v30;
            *((_QWORD *)v38 - 1) = v39;
            v38 -= 8;
          }
          *(_QWORD *)a6 = v38;
          *(_QWORD *)(a6 + 8) = v31;
          *(_QWORD *)(a6 + 16) = &v37[8 * v36];
          if (v32)
            operator delete(v32);
        }
        else
        {
          *v30 = *(_QWORD *)&v12[v28];
          v31 = v30 + 1;
        }
        *(_QWORD *)(a6 + 8) = v31;
        ++v28;
        v30 = v31;
      }
      while (v28 < *a4);
    }
    if (v12)
      MEMORY[0x1B5E2914C](v12, 0x1000C8000313F17);
  }
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)&v43);
  return 1;
}

void sub_1B2C2A8EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)va);
  _Unwind_Resume(a1);
}

uint64_t OZCurve::getCurveSamples(OZCurve *a1, void *a2, __int128 *a3, __int128 *a4, unsigned int *a5, char **a6, uint64_t a7)
{
  double *v14;
  unint64_t v15;
  _QWORD *v16;
  char *v17;
  CMTime *v18;
  __int128 v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  __int128 v25;
  char *v26;
  char *v27;
  char *v28;
  __int128 v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  CMTime *v43;
  double *v44;
  __int16 v45;
  uint64_t v46;
  __int128 v47;
  uint64_t v48;
  __int128 v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  char v53;
  __int128 v54;
  uint64_t v55;
  __int128 v56;
  uint64_t v57;
  int v58;
  double *v59;
  char v60;

  v45 = 1;
  v46 = 0;
  v51 = 0;
  v52 = 0;
  v53 = 0;
  v47 = *MEMORY[0x1E0CA2E68];
  v48 = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
  v49 = v47;
  v50 = v48;
  v58 = 0;
  v59 = 0;
  v60 = 0;
  v55 = v48;
  v54 = v47;
  v56 = v47;
  v57 = v48;
  v44 = 0;
  if (a7)
  {
    v14 = (double *)operator new[]();
    v44 = v14;
  }
  else
  {
    v14 = 0;
  }
  v54 = *a3;
  v55 = *((_QWORD *)a3 + 2);
  v58 = *a5;
  v56 = *a4;
  v57 = *((_QWORD *)a4 + 2);
  v59 = v14;
  HIBYTE(v45) = 0;
  v46 = 0;
  v43 = 0;
  if (a6)
  {
    v43 = (CMTime *)operator new[]();
    OZCurve::processTree(a1, (OZCurveNodeParam *)&v45, &v43, &v44, a2);
  }
  else
  {
    OZCurve::processCurve(a1, (OZCurveNodeParam *)&v45, (double *)a3, a2);
  }
  if (v43)
  {
    std::vector<CMTime>::reserve((void **)a6, *a5);
    if (*a5)
    {
      v15 = 0;
      v16 = a6 + 2;
      v17 = a6[1];
      do
      {
        v18 = &v43[v15];
        if ((unint64_t)v17 >= *v16)
        {
          v20 = 0xAAAAAAAAAAAAAAABLL * ((v17 - *a6) >> 3);
          v21 = v20 + 1;
          if (v20 + 1 > 0xAAAAAAAAAAAAAAALL)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          if (0x5555555555555556 * ((uint64_t)(*v16 - (_QWORD)*a6) >> 3) > v21)
            v21 = 0x5555555555555556 * ((uint64_t)(*v16 - (_QWORD)*a6) >> 3);
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v16 - (_QWORD)*a6) >> 3) >= 0x555555555555555)
            v22 = 0xAAAAAAAAAAAAAAALL;
          else
            v22 = v21;
          if (v22)
            v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a6 + 2), v22);
          else
            v23 = 0;
          v24 = &v23[24 * v20];
          v25 = *(_OWORD *)&v18->value;
          *((_QWORD *)v24 + 2) = v18->epoch;
          *(_OWORD *)v24 = v25;
          v27 = *a6;
          v26 = a6[1];
          v28 = v24;
          if (v26 != *a6)
          {
            do
            {
              v29 = *(_OWORD *)(v26 - 24);
              *((_QWORD *)v28 - 1) = *((_QWORD *)v26 - 1);
              *(_OWORD *)(v28 - 24) = v29;
              v28 -= 24;
              v26 -= 24;
            }
            while (v26 != v27);
            v26 = *a6;
          }
          v17 = v24 + 24;
          *a6 = v28;
          a6[1] = v24 + 24;
          a6[2] = &v23[24 * v22];
          if (v26)
            operator delete(v26);
        }
        else
        {
          v19 = *(_OWORD *)&v18->value;
          *((_QWORD *)v17 + 2) = v18->epoch;
          *(_OWORD *)v17 = v19;
          v17 += 24;
        }
        a6[1] = v17;
        ++v15;
      }
      while (v15 < *a5);
    }
    if (v43)
      MEMORY[0x1B5E2914C](v43, 0x1000C80504FFAC1);
    v43 = 0;
  }
  if (a7)
  {
    std::vector<double>::reserve((void **)a7, *a5);
    if (*a5)
    {
      v30 = 0;
      v31 = (_QWORD *)(a7 + 16);
      v32 = *(_QWORD **)(a7 + 8);
      do
      {
        if ((unint64_t)v32 >= *v31)
        {
          v34 = *(_QWORD **)a7;
          v35 = ((uint64_t)v32 - *(_QWORD *)a7) >> 3;
          v36 = v35 + 1;
          if ((unint64_t)(v35 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v37 = *v31 - (_QWORD)v34;
          if (v37 >> 2 > v36)
            v36 = v37 >> 2;
          if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8)
            v38 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v38 = v36;
          if (v38)
          {
            v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a7 + 16, v38);
            v34 = *(_QWORD **)a7;
            v32 = *(_QWORD **)(a7 + 8);
          }
          else
          {
            v39 = 0;
          }
          v40 = &v39[8 * v35];
          *(double *)v40 = v14[v30];
          v33 = v40 + 8;
          while (v32 != v34)
          {
            v41 = *--v32;
            *((_QWORD *)v40 - 1) = v41;
            v40 -= 8;
          }
          *(_QWORD *)a7 = v40;
          *(_QWORD *)(a7 + 8) = v33;
          *(_QWORD *)(a7 + 16) = &v39[8 * v38];
          if (v34)
            operator delete(v34);
        }
        else
        {
          *v32 = *(_QWORD *)&v14[v30];
          v33 = v32 + 1;
        }
        *(_QWORD *)(a7 + 8) = v33;
        ++v30;
        v32 = v33;
      }
      while (v30 < *a5);
    }
    if (v14)
      MEMORY[0x1B5E2914C](v14, 0x1000C8000313F17);
  }
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)&v45);
  return 1;
}

void sub_1B2C2AD10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)va);
  _Unwind_Resume(a1);
}

uint64_t OZCurve::getCurveSamples(OZCurve *this, Float64 a2, Float64 a3, unsigned int *a4, double **a5, double **a6, double a7)
{
  uint64_t v13;
  unint64_t v14;
  CMTimeEpoch v15;
  CMTime v17;
  CMTime v18;
  __int16 v19;
  double v20;
  CMTime v21;
  CMTime v22;
  int v23;
  uint64_t v24;
  char v25;
  CMTime v26;
  CMTime v27;
  unsigned int v28;
  double *v29;
  char v30;

  v19 = 1;
  v20 = 0.0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v21 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  v22 = v21;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v26 = v21;
  v27 = v21;
  OZFigTimeForChannelSeconds(&v18, a2, 0x40000);
  v26 = v18;
  v28 = *a4;
  OZFigTimeForChannelSeconds(&v18, a3, 0x40000);
  v27 = v18;
  v29 = *a6;
  HIBYTE(v19) = 0;
  v20 = a7;
  if (a5)
  {
    v18.value = operator new[]();
    OZCurve::processTree(this, (OZCurveNodeParam *)&v19, (CMTime **)&v18, a6);
    if (v18.value)
    {
      if (!*a4)
        goto LABEL_7;
      v13 = 0;
      v14 = 0;
      do
      {
        v15 = *(_QWORD *)(v18.value + v13 + 16);
        *(_OWORD *)&v17.value = *(_OWORD *)(v18.value + v13);
        v17.epoch = v15;
        (*a5)[v14++] = CMTimeGetSeconds(&v17);
        v13 += 24;
      }
      while (v14 < *a4);
      if (v18.value)
LABEL_7:
        MEMORY[0x1B5E2914C]();
    }
  }
  else
  {
    OZCurve::processTree(this, (OZCurveNodeParam *)&v19, 0, a6);
  }
  *a4 = v28;
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)&v19);
  return 1;
}

void sub_1B2C2AF14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)va);
  _Unwind_Resume(a1);
}

uint64_t OZCurve::getCurveSamples(OZCurve *this, void *a2, const CMTime *a3, const CMTime *a4, unsigned int *a5, CMTime **a6, double **a7)
{
  __int16 v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  char v17;
  CMTime v18;
  CMTime v19;
  unsigned int v20;
  double *v21;
  char v22;

  v9 = 1;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v11 = *MEMORY[0x1E0CA2E68];
  v12 = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
  v13 = v11;
  v14 = v12;
  v22 = 0;
  v18 = *a3;
  v20 = *a5;
  v19 = *a4;
  v21 = *a7;
  v10 = 0;
  OZCurve::processTree(this, (OZCurveNodeParam *)&v9, a6, a7, a2);
  *a5 = v20;
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)&v9);
  return 1;
}

void sub_1B2C2AFEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)va);
  _Unwind_Resume(a1);
}

uint64_t OZCurve::getCurveSamples(OZCurve *this, const CMTime *a2, const CMTime *a3, unsigned int *a4, CMTime **a5, double **a6)
{
  __int128 v7;
  _BYTE v9[8];
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  char v17;
  CMTime v18;
  __int128 v19;
  CMTimeEpoch epoch;
  unsigned int v21;
  double *v22;
  char v23;

  v9[0] = 1;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v11 = *MEMORY[0x1E0CA2E68];
  v12 = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
  v13 = v11;
  v14 = v12;
  v23 = 0;
  v18 = *a2;
  v21 = *a4;
  v7 = *(_OWORD *)&a3->value;
  epoch = a3->epoch;
  v19 = v7;
  v22 = *a6;
  v9[1] = 0;
  v10 = 0;
  OZCurve::processTree(this, (OZCurveNodeParam *)v9, a5, a6);
  *a4 = v21;
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)v9);
  return 1;
}

void sub_1B2C2B0B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)va);
  _Unwind_Resume(a1);
}

void OZCurve::getValue(OZCurve *this, const CMTime *a2, void *a3, __n128 a4, __n128 a5)
{
  void ***v8;
  void **v9;
  void **v10;
  unsigned int v11;
  void *v12;
  BOOL v13;
  int v14;
  CMTime *v15;
  uint64_t v16;
  CMTimeEpoch epoch;
  CMTime *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  CMTimeEpoch v22;
  CMTime *v23;
  __n128 v24;
  void ***v25;
  void **v26;
  void *v27;
  CMTime *v28;
  uint64_t v29;
  unsigned int v30;
  __int128 v31;
  double *v32;
  __n128 v33;
  __n128 v34;
  void **v35;
  void *v36;
  void **v37;
  void *v38;
  CMTime v39;
  CMTime v40;
  CMTime v41;
  int v42;
  uint64_t v43;
  char v44;
  __int128 v45;
  CMTimeEpoch v46;
  CMTime v47;
  int v48;
  uint64_t *v49;
  char v50;
  CMTime v51;
  uint64_t v52;

  v52 = 0;
  if (a3)
  {
    if (*((_BYTE *)this + 136))
    {
      if (*((_BYTE *)this + 137))
      {
        v8 = (void ***)*((_QWORD *)this + 14);
        v9 = *v8;
        v10 = v8[1];
        v11 = 1;
        if (v9 != v10)
        {
          do
          {
            v12 = *v9;
            v13 = *v9 == a3;
            v9 += *v9 != a3;
            if (!v13)
              ++v11;
            v13 = v9 == v10 || v12 == a3;
          }
          while (!v13);
        }
        v14 = v11 + 1;
        v15 = (CMTime *)operator new[]();
        v16 = *(_QWORD *)(*((_QWORD *)this + 14) + 8);
        v39 = *a2;
        epoch = v39.epoch;
        v18 = &v15[v11];
        *(_OWORD *)&v18->value = *(_OWORD *)&v39.value;
        v18->epoch = epoch;
        v19 = v11 - 1;
        v20 = (uint64_t *)(v16 - 8);
        do
        {
          v21 = *v20--;
          (*(void (**)(CMTime *__return_ptr, uint64_t, CMTime *))(*(_QWORD *)v21 + 120))(&v51, v21, &v39);
          v39 = v51;
          v22 = v51.epoch;
          v23 = &v15[v19];
          *(_OWORD *)&v23->value = *(_OWORD *)&v51.value;
          v23->epoch = v22;
          --v14;
          --v19;
        }
        while (v14 > 1);
        *v15 = v39;
        v24.n128_u64[0] = (*(double (**)(_QWORD, CMTime *, double, double))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1), v15, 0.0, 0.0);
        v25 = (void ***)*((_QWORD *)this + 14);
        v26 = *v25;
        v27 = **v25;
        if (v27 == a3)
        {
          v30 = 1;
        }
        else
        {
          v28 = v15 + 1;
          v29 = 1;
          do
          {
            v24.n128_u64[0] = (*(double (**)(void *, CMTime *, double, __n128))(*(_QWORD *)v27 + 16))(v27, v28, 0.0, v24);
            v30 = v29 + 1;
            v27 = v26[v29];
            ++v28;
            ++v29;
          }
          while (v27 != a3);
        }
        (*(void (**)(void *, CMTime *, double, __n128))(*(_QWORD *)a3 + 16))(a3, &v15[v30], 0.0, v24);
        MEMORY[0x1B5E2914C](v15, 0x1000C80504FFAC1);
      }
      else
      {
        v34.n128_u64[0] = (*(double (**)(_QWORD, const CMTime *, double, double))(**((_QWORD **)this + 1)
                                                                                           + 16))(*((_QWORD *)this + 1), a2, 0.0, 0.0);
        v35 = (void **)**((_QWORD **)this + 14);
        v36 = *v35;
        if (*v35 != a3)
        {
          v37 = v35 + 1;
          do
          {
            v34.n128_u64[0] = (*(double (**)(void *, const CMTime *, double, __n128))(*(_QWORD *)v36 + 16))(v36, a2, 0.0, v34);
            v38 = *v37++;
            v36 = v38;
          }
          while (v38 != a3);
        }
        v33.n128_u64[0] = 0;
        (*(void (**)(void *, const CMTime *, __n128, __n128))(*(_QWORD *)a3 + 16))(a3, a2, v33, v34);
      }
    }
    else
    {
      LOWORD(v39.value) = 1;
      *(_QWORD *)&v39.timescale = 0;
      v42 = 0;
      v43 = 0;
      v44 = 0;
      v40 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
      v41 = v40;
      v49 = 0;
      v50 = 0;
      v47 = v40;
      v31 = *(_OWORD *)&a2->value;
      v46 = a2->epoch;
      v45 = v31;
      v48 = 1;
      CMTimeMake(&v51, 1, 1);
      v47 = v51;
      v49 = &v52;
      OZCurve::processCurve(this, (OZCurveNodeParam *)&v39, v32, a3);
      OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)&v39);
    }
  }
  else
  {
    a4.n128_u64[0] = 0;
    a5.n128_u64[0] = 0;
    (*(void (**)(_QWORD, const CMTime *, __n128, __n128))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1), a2, a4, a5);
  }
}

void sub_1B2C2B418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)&a9);
  _Unwind_Resume(a1);
}

void OZCurve::getValue(OZCurve *this, const CMTime *a2, double a3)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  CMTime *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  CMTimeEpoch epoch;
  CMTime *v19;
  double v20;
  uint64_t v21;
  uint64_t *v22;
  CMTime *v23;
  uint64_t v24;
  __int128 v25;
  double *v26;
  double v27;
  uint64_t **v28;
  uint64_t *i;
  uint64_t v30;
  CMTime v31;
  CMTime v32;
  CMTime v33;
  int v34;
  uint64_t v35;
  char v36;
  __int128 v37;
  CMTimeEpoch v38;
  CMTime v39;
  int v40;
  uint64_t *v41;
  char v42;
  CMTime v43;
  uint64_t v44;

  v44 = 0;
  v6 = (uint64_t *)*((_QWORD *)this + 14);
  v7 = *v6;
  v8 = v6[1];
  if (v7 == v8)
  {
    (*(void (**)(_QWORD, const CMTime *, double, double))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1), a2, a3, 0.0);
  }
  else if (*((_BYTE *)this + 136))
  {
    if (*((_BYTE *)this + 137))
    {
      v9 = v8 - v7;
      v10 = (unint64_t)(v8 - v7) >> 3;
      is_mul_ok((((v8 - v7) << 29) + 0x100000000) >> 32, 0x18uLL);
      v11 = operator new[]();
      v12 = (CMTime *)v11;
      v13 = *(_QWORD *)(*((_QWORD *)this + 14) + 8);
      v31 = *a2;
      if ((_DWORD)v10)
      {
        v14 = v11 + 24 * (int)(v9 >> 3);
        *(_OWORD *)v14 = *(_OWORD *)&a2->value;
        *(_QWORD *)(v14 + 16) = a2->epoch;
        if ((int)v10 >= 1)
        {
          v15 = ((unint64_t)v9 >> 3) + 1;
          v16 = (uint64_t *)(v13 - 8);
          do
          {
            v17 = *v16--;
            (*(void (**)(CMTime *__return_ptr, uint64_t, CMTime *))(*(_QWORD *)v17 + 120))(&v43, v17, &v31);
            v31 = v43;
            epoch = v43.epoch;
            v19 = &v12[(v15 - 2)];
            *(_OWORD *)&v19->value = *(_OWORD *)&v43.value;
            v19->epoch = epoch;
            --v15;
          }
          while (v15 > 1);
        }
      }
      *v12 = v31;
      v20 = (*(double (**)(_QWORD, CMTime *, double, double))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1), v12, a3, 0.0);
      v21 = *((_QWORD *)this + 14);
      v22 = *(uint64_t **)v21;
      if (*(_QWORD *)v21 != *(_QWORD *)(v21 + 8))
      {
        v23 = v12 + 1;
        do
        {
          v24 = *v22++;
          v20 = (*(double (**)(uint64_t, CMTime *, double, double))(*(_QWORD *)v24 + 16))(v24, v23++, a3, v20);
        }
        while (v22 != *(uint64_t **)(*((_QWORD *)this + 14) + 8));
      }
      MEMORY[0x1B5E2914C](v12, 0x1000C80504FFAC1);
    }
    else
    {
      v27 = (*(double (**)(_QWORD, const CMTime *, double, double))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1), a2, a3, 0.0);
      v28 = (uint64_t **)*((_QWORD *)this + 14);
      for (i = *v28; i != v28[1]; ++i)
      {
        v30 = *i;
        v27 = (*(double (**)(uint64_t, const CMTime *, double, double))(*(_QWORD *)v30 + 16))(v30, a2, a3, v27);
        v28 = (uint64_t **)*((_QWORD *)this + 14);
      }
    }
  }
  else
  {
    LOWORD(v31.value) = 1;
    *(_QWORD *)&v31.timescale = 0;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v32 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
    v33 = v32;
    v41 = 0;
    v42 = 0;
    v39 = v32;
    v25 = *(_OWORD *)&a2->value;
    v38 = a2->epoch;
    v37 = v25;
    v40 = 1;
    CMTimeMake(&v43, 1, 1);
    v39 = v43;
    v41 = &v44;
    OZCurve::processCurve(this, (OZCurveNodeParam *)&v31, v26, *(void **)(*(_QWORD *)(*((_QWORD *)this + 14) + 8) - 8));
    OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)&v31);
  }
}

void sub_1B2C2B75C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)&a9);
  _Unwind_Resume(a1);
}

uint64_t OZCurve::getPoint(OZCurve *this, const CMTime *a2, double a3, double *a4)
{
  if (a4)
    *a4 = (*(double (**)(OZCurve *, const CMTime *, double))(*(_QWORD *)this + 1256))(this, a2, a3);
  return 1;
}

uint64_t OZCurve::getPointWithoutBehavior(OZCurve *this, const CMTime *a2, double a3, double *a4)
{
  if (a4)
    *a4 = (*(double (**)(OZCurve *, const CMTime *, _QWORD, double))(*(_QWORD *)this + 1248))(this, a2, 0, a3);
  return 1;
}

uint64_t OZCurve::getPointFromCurveNode(OZCurve *this, const CMTime *a2, double a3, double *a4, void *a5)
{
  if (a4)
    *a4 = (*(double (**)(OZCurve *, const CMTime *, void *, double))(*(_QWORD *)this + 1248))(this, a2, a5, a3);
  return 1;
}

uint64_t OZCurve::setKeyValue(OZCurve *this, char *a2, const CMTime *a3, double a4)
{
  double v7;
  uint64_t v8;
  OZSpline *v10;
  uint64_t v11;

  v7 = *((double *)this + 16);
  if (v7 >= a4)
  {
    if (*((double *)this + 15) > a4)
      v7 = *((double *)this + 15);
    else
      v7 = a4;
  }
  if (*((_DWORD *)this + 42)
    && PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
  {
    if ((*(unsigned int (**)(OZCurve *))(*(_QWORD *)this + 1208))(this))
    {
      v8 = 1;
      (*(void (**)(_QWORD, const CMTime *, uint64_t, double))(**((_QWORD **)this + 13) + 64))(*((_QWORD *)this + 13), a3, 1, v7);
    }
    else if (PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
           && (v10 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)),
               OZSpline::isValidHandle(v10, a2)))
    {
      v11 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
      (*(void (**)(uint64_t, char *, const CMTime *, _QWORD, double))(*(_QWORD *)v11 + 200))(v11, a2, a3, MEMORY[0x1E0CA2E68], v7);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v8 = 1;
    (*(void (**)(_QWORD, const CMTime *, uint64_t, double))(**((_QWORD **)this + 1) + 64))(*((_QWORD *)this + 1), a3, 1, v7);
    *((double *)this + 6) = v7;
  }
  return v8;
}

uint64_t OZCurve::setKeyValue(OZCurve *this, char *a2, double a3)
{
  double v5;
  OZSpline *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v12;
  uint64_t v13;

  v5 = *((double *)this + 16);
  if (v5 >= a3)
  {
    if (*((double *)this + 15) > a3)
      v5 = *((double *)this + 15);
    else
      v5 = a3;
  }
  if (*((_DWORD *)this + 42)
    && PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
  {
    v6 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
    if (OZSpline::isValidHandle(v6, a2))
    {
      if ((*(unsigned int (**)(OZCurve *))(*(_QWORD *)this + 1208))(this))
      {
        v7 = MEMORY[0x1E0CA2E68];
        v12 = *MEMORY[0x1E0CA2E68];
        v13 = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
        v8 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
        (*(void (**)(uint64_t, char *, __int128 *, _QWORD, uint64_t))(*(_QWORD *)v8 + 264))(v8, a2, &v12, 0, v7);
        v9 = 1;
        (*(void (**)(_QWORD, __int128 *, uint64_t, double))(**((_QWORD **)this + 13) + 64))(*((_QWORD *)this + 13), &v12, 1, v5);
      }
      else
      {
        v10 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
        (*(void (**)(uint64_t, char *, _QWORD, double))(*(_QWORD *)v10 + 208))(v10, a2, MEMORY[0x1E0CA2E68], v5);
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v9 = 1;
    (*(void (**)(_QWORD, _QWORD, uint64_t, double))(**((_QWORD **)this + 1) + 64))(*((_QWORD *)this + 1), MEMORY[0x1E0CA2E68], 1, v5);
    *((double *)this + 6) = v5;
  }
  return v9;
}

BOOL OZCurve::setKeyAtCurrentValue(OZCurve *this, const CMTime *a2)
{
  int v2;
  int v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *((_DWORD *)this + 42);
  if (v2)
  {
    v5 = (*(uint64_t (**)(OZCurve *))(*(_QWORD *)this + 1208))(this);
    v6 = 8;
    if (v5)
      v6 = 104;
    v7 = *(_QWORD *)((char *)this + v6);
    (*(void (**)(OZCurve *, const CMTime *, _QWORD))(*(_QWORD *)this + 1248))(this, a2, 0);
    (*(void (**)(uint64_t, const CMTime *, uint64_t))(*(_QWORD *)v7 + 64))(v7, a2, 1);
  }
  return v2 != 0;
}

BOOL OZCurve::lockCurve(OZCurve *this, int a2)
{
  PVInstructionGraphContext *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (PVInstructionGraphContext *)((char *)this + 40);
  v4 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (v4)
  {
    v5 = PVInstructionGraphContext::HGNodeCache(v3);
    OZSpline::lockSpline(v5, a2);
  }
  return v4 != 0;
}

uint64_t OZCurve::setCurveDefaultValue(OZCurve *this, double a2)
{
  *((double *)this + 7) = a2;
  *((double *)this + 4) = a2;
  return 1;
}

uint64_t OZCurve::setCurveInitialValue(OZCurve *this, double a2)
{
  *((double *)this + 6) = a2;
  *((double *)this + 3) = a2;
  return 1;
}

uint64_t OZCurve::setKeypoint(OZCurve *this, const CMTime *a2, int a3)
{
  if (!*((_BYTE *)this + 138) || !OZCurve::isAnimated(this) && !a3)
    return 0;
  OZCurve::setKeyAtCurrentValue(this, a2);
  return 1;
}

BOOL OZCurve::setKeypointValue(OZCurve *this, char *a2, double a3, int a4)
{
  uint64_t Instance;
  int v9;
  _BOOL4 isAnimated;
  char v11;

  if (a2)
  {
    Instance = OZCoreGlobals::getInstance((OZCoreGlobals *)this);
    if (!*((_BYTE *)this + 138))
      goto LABEL_8;
    v9 = *(unsigned __int8 *)(Instance + 10);
    isAnimated = OZCurve::isAnimated(this);
    v11 = a4 ^ 1;
    if (!v9)
      v11 = 0;
    if ((v11 & 1) == 0 && isAnimated | a4)
      OZCurve::setKeyValue(this, a2, a3);
    else
LABEL_8:
      (*(void (**)(OZCurve *, _QWORD, double))(*(_QWORD *)this + 440))(this, MEMORY[0x1E0CA2E68], a3);
  }
  return a2 != 0;
}

uint64_t OZCurve::setKeypointsValue(OZCurve *this, double a2)
{
  double v3;
  OZSpline *v4;

  v3 = *((double *)this + 16);
  if (*((_DWORD *)this + 42))
  {
    if (v3 >= a2)
    {
      v3 = a2;
      if (*((double *)this + 15) > a2)
        v3 = *((double *)this + 15);
    }
    *((double *)this + 6) = v3;
    if (PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    {
      v4 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
      OZSpline::setAllVerticesValues(v4, v3, MEMORY[0x1E0CA2E68]);
    }
  }
  else
  {
    if (v3 >= a2)
    {
      if (*((double *)this + 15) > a2)
        v3 = *((double *)this + 15);
      else
        v3 = a2;
    }
    (*(void (**)(_QWORD, _QWORD, uint64_t, double))(**((_QWORD **)this + 1) + 64))(*((_QWORD *)this + 1), MEMORY[0x1E0CA2E68], 1, v3);
    if (!*((_DWORD *)this + 42))
      *((double *)this + 6) = v3;
  }
  return 1;
}

uint64_t OZCurve::setCurveOffset(OZCurve *this, const CMTime *a2, double a3)
{
  double v4;
  OZSpline *v6;

  v4 = *((double *)this + 16);
  if (*((_DWORD *)this + 42))
  {
    if (v4 >= a3)
    {
      v4 = a3;
      if (*((double *)this + 15) > a3)
        v4 = *((double *)this + 15);
    }
    if (PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    {
      v6 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
      OZSpline::offsetSpline(v6, a2, v4, *((double *)this + 16), *((double *)this + 15), 0, 0, MEMORY[0x1E0CA2E68]);
      return 1;
    }
LABEL_12:
    *((double *)this + 6) = v4;
    return 1;
  }
  if (v4 >= a3)
  {
    if (*((double *)this + 15) > a3)
      v4 = *((double *)this + 15);
    else
      v4 = a3;
  }
  (*(void (**)(_QWORD, _QWORD, uint64_t, double))(**((_QWORD **)this + 1) + 64))(*((_QWORD *)this + 1), MEMORY[0x1E0CA2E68], 1, v4);
  if (!*((_DWORD *)this + 42))
    goto LABEL_12;
  return 1;
}

uint64_t OZCurve::setCurveSegmentValue(OZCurve *this, const CMTime *a2, double a3, int a4)
{
  double v8;
  OZSpline *v9;

  if (*((_BYTE *)this + 138) && (OZCurve::isAnimated(this) || a4))
  {
    v8 = *((double *)this + 16);
    if (*((_DWORD *)this + 42))
    {
      if (v8 >= a3)
      {
        v8 = a3;
        if (*((double *)this + 15) > a3)
          v8 = *((double *)this + 15);
      }
      if (PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
      {
        v9 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
        OZSpline::offsetSpline(v9, a2, v8, *((double *)this + 16), *((double *)this + 15), 1, 0, MEMORY[0x1E0CA2E68]);
        return 1;
      }
LABEL_15:
      *((double *)this + 6) = v8;
      return 1;
    }
    if (v8 >= a3)
    {
      if (*((double *)this + 15) > a3)
        v8 = *((double *)this + 15);
      else
        v8 = a3;
    }
    (*(void (**)(_QWORD, _QWORD, uint64_t, double))(**((_QWORD **)this + 1) + 64))(*((_QWORD *)this + 1), MEMORY[0x1E0CA2E68], 1, v8);
    if (!*((_DWORD *)this + 42))
      goto LABEL_15;
  }
  return 1;
}

uint64_t OZCurve::setCurveSegmentValueBounded(OZCurve *this, const CMTime *a2, double a3, double a4, double a5, int a6)
{
  double v12;
  double v13;
  OZSpline *v14;
  double v15;

  if (*((_BYTE *)this + 138) && (OZCurve::isAnimated(this) || a6))
  {
    if (*((_DWORD *)this + 42))
    {
      if (a3 < a4)
        v12 = a4;
      else
        v12 = a3;
      if (a3 <= a5)
        v13 = v12;
      else
        v13 = a5;
      if (PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
      {
        v14 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
        OZSpline::offsetSpline(v14, a2, v13, a5, a4, 1, 1, MEMORY[0x1E0CA2E68]);
      }
      else
      {
        *((double *)this + 6) = v13;
      }
    }
    else
    {
      v15 = *((double *)this + 16);
      if (v15 >= a3)
      {
        if (*((double *)this + 15) > a3)
          v15 = *((double *)this + 15);
        else
          v15 = a3;
      }
      (*(void (**)(_QWORD, _QWORD, uint64_t, double))(**((_QWORD **)this + 1) + 64))(*((_QWORD *)this + 1), MEMORY[0x1E0CA2E68], 1, v15);
      if (!*((_DWORD *)this + 42))
        *((double *)this + 6) = v15;
    }
  }
  return 1;
}

uint64_t OZCurve::createCurveSegment(OZCurve *this, const CMTime *a2, const CMTime *a3, const CMTime *a4, int a5, int a6)
{
  OZSpline *v12;

  if (!*((_BYTE *)this + 138) || !OZCurve::isAnimated(this) && !a6 || !*((_DWORD *)this + 42))
    return 0;
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
  {
    if (*(_BYTE *)(*((_QWORD *)this + 20) + 44))
      *((_QWORD *)this + 20) = OZCurve::createLocalSplineState(this);
    OZSplineNode::createSpline((OZSplineNode *)((char *)this + 40));
  }
  v12 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  return OZSpline::createSegment(v12, a2, a3, a4, a5);
}

BOOL OZCurve::setKeypoint(OZCurve *this, char *a2, const CMTime *a3, double a4, int a5)
{
  uint64_t Instance;
  int v11;
  _BOOL4 isAnimated;
  char v13;

  if (a2)
  {
    Instance = OZCoreGlobals::getInstance((OZCoreGlobals *)this);
    if (!*((_BYTE *)this + 138))
      goto LABEL_8;
    v11 = *(unsigned __int8 *)(Instance + 10);
    isAnimated = OZCurve::isAnimated(this);
    v13 = a5 ^ 1;
    if (!v11)
      v13 = 0;
    if ((v13 & 1) == 0 && isAnimated | a5)
      OZCurve::setKeyValue(this, a2, a3, a4);
    else
LABEL_8:
      (*(void (**)(OZCurve *, const CMTime *, double))(*(_QWORD *)this + 440))(this, a3, a4);
  }
  return a2 != 0;
}

uint64_t OZCurve::setKeypoint(OZCurve *this, const CMTime *a2, double a3, int a4)
{
  int v8;
  double v9;
  void *v11;

  v11 = 0;
  if (*(_BYTE *)(OZCoreGlobals::getInstance((OZCoreGlobals *)this) + 10))
    v8 = a4 ^ 1;
  else
    v8 = 0;
  if (!*((_BYTE *)this + 138) || ((v8 | (OZCurve::isAnimated(this) | a4) ^ 1) & 1) != 0)
  {
    if ((v8 & 1) != 0
      || !(*(unsigned int (**)(OZCurve *, const CMTime *, void **))(*(_QWORD *)this + 696))(this, a2, &v11))
    {
      (*(void (**)(OZCurve *, const CMTime *, double))(*(_QWORD *)this + 440))(this, a2, a3);
      return 1;
    }
LABEL_10:
    OZCurve::setKeyValue(this, (char *)v11, a2, a3);
    return 1;
  }
  if ((*(unsigned int (**)(OZCurve *, const CMTime *, void **))(*(_QWORD *)this + 696))(this, a2, &v11))
    goto LABEL_10;
  v9 = *((double *)this + 16);
  if (v9 >= a3)
  {
    if (*((double *)this + 15) > a3)
      v9 = *((double *)this + 15);
    else
      v9 = a3;
  }
  (*(void (**)(_QWORD, const CMTime *, uint64_t, double))(**((_QWORD **)this + 1) + 64))(*((_QWORD *)this + 1), a2, 1, v9);
  if (!*((_DWORD *)this + 42))
    *((double *)this + 6) = v9;
  return 1;
}

uint64_t OZCurve::setKeypointNoTangents(OZCurve *this, const CMTime *a2, double a3, int a4)
{
  OZCurve *v7;
  BOOL v8;
  double v9;
  void *v11;

  v7 = this;
  v11 = 0;
  if (!*((_BYTE *)this + 138) || (this = (OZCurve *)OZCurve::isAnimated(this), (this & 1) == 0) && !a4)
  {
    if (*(_BYTE *)(OZCoreGlobals::getInstance((OZCoreGlobals *)this) + 10))
      v8 = a4 == 0;
    else
      v8 = 0;
    if (v8
      || !(*(unsigned int (**)(OZCurve *, const CMTime *, void **))(*(_QWORD *)v7 + 696))(v7, a2, &v11))
    {
      (*(void (**)(OZCurve *, const CMTime *, double))(*(_QWORD *)v7 + 440))(v7, a2, a3);
      return 1;
    }
LABEL_11:
    OZCurve::setKeyValue(v7, (char *)v11, a2, a3);
    return 1;
  }
  if ((*(unsigned int (**)(OZCurve *, const CMTime *, void **))(*(_QWORD *)v7 + 696))(v7, a2, &v11))
    goto LABEL_11;
  v9 = *((double *)v7 + 16);
  if (v9 >= a3)
  {
    if (*((double *)v7 + 15) > a3)
      v9 = *((double *)v7 + 15);
    else
      v9 = a3;
  }
  (*(void (**)(_QWORD, const CMTime *, _QWORD, double))(**((_QWORD **)v7 + 1) + 64))(*((_QWORD *)v7 + 1), a2, 0, v9);
  if (!*((_DWORD *)v7 + 42))
    *((double *)v7 + 6) = v9;
  return 1;
}

uint64_t OZCurve::appendKeypointNoTangents(OZCurve *this, const CMTime *a2, double a3, int a4)
{
  OZSpline *v8;

  if (*((_BYTE *)this + 138) && (OZCurve::isAnimated(this) || a4))
  {
    if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    {
      if (*(_BYTE *)(*((_QWORD *)this + 20) + 44))
        *((_QWORD *)this + 20) = OZCurve::createLocalSplineState(this);
      OZSplineNode::createSpline((OZSplineNode *)((char *)this + 40));
    }
    v8 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
    OZSpline::appendVertexNoTangents(v8, a2, a3, MEMORY[0x1E0CA2E68]);
  }
  else
  {
    (*(void (**)(OZCurve *, const CMTime *, double))(*(_QWORD *)this + 440))(this, a2, a3);
  }
  return 1;
}

uint64_t OZCurve::appendKeypointsNoTangents(OZCurve *this, int a2, CMTime *a3, double *a4, int a5)
{
  uint64_t v7;
  double v10;
  OZSpline *v11;
  void *__p[3];

  LODWORD(v7) = a2;
  if (*((_BYTE *)this + 138) && (OZCurve::isAnimated(this) || a5))
  {
    if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    {
      if (*(_BYTE *)(*((_QWORD *)this + 20) + 44))
        *((_QWORD *)this + 20) = OZCurve::createLocalSplineState(this);
      OZSplineNode::createSpline((OZSplineNode *)((char *)this + 40));
    }
    v11 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
    OZSpline::appendVertexesNoTangents(v11, a3, a4, v7, __p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else if ((_DWORD)v7)
  {
    v7 = v7;
    do
    {
      v10 = *a4++;
      (*(void (**)(OZCurve *, CMTime *, double))(*(_QWORD *)this + 440))(this, a3++, v10);
      --v7;
    }
    while (v7);
  }
  return 1;
}

uint64_t OZCurve::scaleCurve(OZCurve *this, double a2)
{
  PVInstructionGraphContext *v4;
  double v5;
  double v6;
  double v7;
  OZSpline *v8;

  v4 = (PVInstructionGraphContext *)((char *)this + 40);
  v5 = *((double *)this + 7) * a2;
  *((double *)this + 7) = v5;
  v6 = *((double *)this + 16);
  if (v5 > v6)
  {
    *((double *)this + 7) = v6;
    v5 = v6;
  }
  v7 = *((double *)this + 15);
  if (v5 < v7)
    *((double *)this + 7) = v7;
  if (*((double *)this + 6) * a2 <= v6)
    v6 = *((double *)this + 6) * a2;
  if (v6 < v7)
    v6 = v7;
  *((double *)this + 6) = v6;
  if (PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
  {
    v8 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v4);
    OZSpline::scaleSpline(v8, a2, *((double *)this + 15), *((double *)this + 16), MEMORY[0x1E0CA2E68]);
  }
  return 1;
}

uint64_t OZCurve::getUForValue(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8));
}

OZCurve *OZCurve::appendCurveProcessingNode(OZCurve *this, OZCurveNode *a2)
{
  void **v4;
  _QWORD *v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;

  v4 = (void **)*((_QWORD *)this + 14);
  v5 = v4[1];
  v6 = (unint64_t)v4[2];
  if ((unint64_t)v5 >= v6)
  {
    v8 = ((char *)v5 - (_BYTE *)*v4) >> 3;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v9 = v6 - (_QWORD)*v4;
    v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1))
      v10 = v8 + 1;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(v4 + 2), v11);
    else
      v12 = 0;
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    *(_QWORD *)v13 = a2;
    v7 = v13 + 8;
    v16 = (char *)*v4;
    v15 = (char *)v4[1];
    if (v15 != *v4)
    {
      do
      {
        v17 = *((_QWORD *)v15 - 1);
        v15 -= 8;
        *((_QWORD *)v13 - 1) = v17;
        v13 -= 8;
      }
      while (v15 != v16);
      v15 = (char *)*v4;
    }
    *v4 = v13;
    v4[1] = v7;
    v4[2] = v14;
    if (v15)
      operator delete(v15);
  }
  else
  {
    *v5 = a2;
    v7 = v5 + 1;
  }
  v4[1] = v7;
  return OZCurve::setTreeProperties(this);
}

OZCurve *OZCurve::insertCurveProcessingNode(OZCurve *this, OZCurveNode *a2, void *a3)
{
  char **v4;
  char *v5;
  char *v6;
  OZCurveNode *v8;

  v8 = a2;
  v4 = (char **)*((_QWORD *)this + 14);
  v5 = *v4;
  if (a3)
  {
    v6 = v4[1];
    if (v5 != v6)
    {
      while (*(void **)v5 != a3)
      {
        v5 += 8;
        if (v5 == v6)
        {
          v5 = v4[1];
          break;
        }
      }
    }
    v5 += 8;
  }
  std::vector<OZCurveNode *>::insert((uint64_t)v4, v5, (char *)&v8);
  return OZCurve::setTreeProperties(this);
}

char *std::vector<OZCurveNode *>::insert(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  void *__p;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v13 = *(char **)a1;
    v14 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 3) + 1;
    if (v14 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v15 = __src - v13;
    v16 = (__src - v13) >> 3;
    v17 = v7 - (_QWORD)v13;
    if (v17 >> 2 > v14)
      v14 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v14;
    v30 = a1 + 16;
    if (v18)
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a1 + 16, v18);
    else
      v19 = 0;
    v20 = &v19[8 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4)
          v22 = 1;
        else
          v22 = v15 >> 2;
        v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8, v22);
        v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[8 * v24];
        if (v19)
          operator delete(v19);
      }
      else
      {
        v21 = v16 + 2;
        if (v16 >= -1)
          v21 = v16 + 1;
        v20 -= 8 * (v21 >> 1);
        v27 = v20;
      }
    }
    *(_QWORD *)v20 = *(_QWORD *)v3;
    v28 = v20 + 8;
    v4 = std::vector<OZChannelBase *>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27)
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_QWORD *)__src = *(_QWORD *)a3;
    *(_QWORD *)(a1 + 8) = __src + 8;
  }
  else
  {
    v9 = __src + 8;
    v10 = v6 - 8;
    v11 = *(_QWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_QWORD *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    if (v4 <= v3)
      v3 += 8 * (*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    *(_QWORD *)v4 = *(_QWORD *)v3;
  }
  return v4;
}

void sub_1B2C2C974(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL OZCurve::delProcessNode(OZCurve *this, void *a2)
{
  uint64_t v3;
  void **v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  size_t v11;

  v3 = *((_QWORD *)this + 14);
  v5 = *(_QWORD *)v3;
  v4 = *(void ***)(v3 + 8);
  v6 = v5 != (_QWORD)v4;
  if ((void **)v5 != v4)
  {
    v7 = -v5;
    while (*(void **)v5 != a2)
    {
      v5 += 8;
      v7 -= 8;
      v6 = v5 != (_QWORD)v4;
      if ((void **)v5 == v4)
        goto LABEL_11;
    }
    if (a2)
      (*(void (**)(void *))(*(_QWORD *)a2 + 8))(a2);
    *(_QWORD *)v5 = 0;
    v8 = *((_QWORD *)this + 14);
    v9 = -v7;
    v10 = (const void *)(8 - v7);
    v11 = *(_QWORD *)(v8 + 8) - (8 - v7);
    if (v11)
      memmove((void *)v9, v10, v11);
    *(_QWORD *)(v8 + 8) = v9 + v11;
  }
LABEL_11:
  OZCurve::setTreeProperties(this);
  return v6;
}

BOOL OZCurve::removeProcessNode(OZCurve *this, void *a2)
{
  uint64_t v3;
  void **v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;

  v3 = *((_QWORD *)this + 14);
  v5 = *(_QWORD *)v3;
  v4 = *(void ***)(v3 + 8);
  v6 = *(_QWORD *)v3 != (_QWORD)v4;
  if (*(void ***)v3 != v4)
  {
    v7 = -v5;
    while (*(void **)v5 != a2)
    {
      v5 += 8;
      v7 -= 8;
      v6 = v5 != (_QWORD)v4;
      if ((void **)v5 == v4)
        goto LABEL_9;
    }
    v8 = -v7;
    v9 = (char *)v4 - (8 - v7);
    if (v4 != (void **)(8 - v7))
      memmove((void *)-v7, (const void *)(8 - v7), (size_t)v4 - (8 - v7));
    *(_QWORD *)(v3 + 8) = &v9[v8];
  }
LABEL_9:
  OZCurve::setTreeProperties(this);
  return v6;
}

BOOL OZCurve::enumerateCurveProcessingNodes(uint64_t a1, char *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 112);
  if ((char *)v2 != a2 && v2 != 0)
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(a2, *(char **)v2, *(_QWORD *)(v2 + 8), (uint64_t)(*(_QWORD *)(v2 + 8) - *(_QWORD *)v2) >> 3);
  return v2 != 0;
}

uint64_t OZCurve::getPreviousProcessingNode(OZCurve *this, void *a2, void **a3)
{
  void ***v3;
  void **v4;
  void **v5;
  void **v6;
  void *v7;
  uint64_t result;

  v3 = (void ***)*((_QWORD *)this + 14);
  v4 = *v3;
  v5 = v3[1];
  if (*v3 == v5)
    goto LABEL_9;
  v6 = *v3;
  while (*v6 != a2)
  {
    if (++v6 == v5)
    {
      v6 = v5;
      break;
    }
  }
  if (v6 == v4)
  {
LABEL_9:
    result = 0;
    if (!a3)
      return result;
    v7 = 0;
  }
  else
  {
    if (!a3)
      return 1;
    v7 = *(v6 - 1);
    result = 1;
  }
  *a3 = v7;
  return result;
}

uint64_t OZCurve::getNumCurveProcessingNodes(OZCurve *this, unsigned int *a2)
{
  *a2 = (*(_QWORD *)(*((_QWORD *)this + 14) + 8) - **((_QWORD **)this + 14)) >> 3;
  return 1;
}

uint64_t OZCurve::setCustomInterpolator(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 80) = a2;
  *(_QWORD *)(result + 88) = a3;
  return result;
}

BOOL OZCurve::bakeCurve(OZCurve *this, void *a2, const CMTime *a3, const CMTime *a4, CMTime *a5, double a6, double a7)
{
  OZSplineNode *v7;
  OZSplineNode *v8;
  uint64_t v16;
  CMTimeEpoch epoch;
  CMTimeEpoch v18;
  double *v19;
  PCCurveFit *v20;
  uint64_t v21;
  unint64_t i;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  char *v31;
  char *v32;
  char *v33;
  char *v34;
  __int128 v35;
  uint64_t v36;
  uint64_t Instance;
  Float64 *value;
  uint64_t v39;
  OZSpline *v40;
  OZSpline *v41;
  void *v42;
  OZSpline *v43;
  OZStaticVertex *v44;
  uint64_t v45;
  CMTimeValue v46;
  unsigned int v47;
  unint64_t v48;
  const CMTime *v49;
  OZSpline *v50;
  OZStaticVertex *v51;
  uint64_t v52;
  uint64_t v53;
  OZSpline *v54;
  uint64_t v55;
  OZStaticVertex *v56;
  uint64_t v57;
  OZSplineNode *v59;
  CMTime *v60;
  CMTime v61;
  CMTime v62;
  CMTime v63;
  CMTime v64;
  CMTime __p;
  __int128 v66;
  char *v67;
  CMTime time;
  __int16 v69;
  uint64_t v70;
  __int128 v71;
  uint64_t v72;
  __int128 v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  char v77;
  CMTime v78;
  CMTime v79;
  unsigned int Seconds;
  double *v81;
  char v82;
  CMTime v83;
  CMTime v84;

  v7 = (OZSplineNode *)*((_QWORD *)this + 1);
  v8 = (OZSplineNode *)((char *)this + 40);
  if (v7 == (OZSplineNode *)((char *)this + 40))
  {
    v59 = (OZSplineNode *)((char *)this + 40);
    if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v7))
      OZSplineNode::createSpline(v7);
    v69 = 1;
    v75 = 0;
    v76 = 0;
    v77 = 0;
    v71 = *MEMORY[0x1E0CA2E68];
    v16 = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
    v70 = 0;
    v72 = v16;
    v73 = v71;
    v74 = v16;
    Seconds = 0;
    v81 = 0;
    v82 = 0;
    epoch = a3->epoch;
    *(_OWORD *)&v78.value = *(_OWORD *)&a3->value;
    *(_OWORD *)&v79.value = *(_OWORD *)&a4->value;
    v18 = a4->epoch;
    v78.epoch = epoch;
    v79.epoch = v18;
    v84 = *a5;
    v83 = *a3;
    PC_CMTimeSaferSubtract(&v84, &v83, (uint64_t)&v66);
    operator/(&v66, (uint64_t)a4, (uint64_t)&time);
    v60 = a5;
    Seconds = CMTimeGetSeconds(&time);
    v81 = (double *)operator new[]();
    v20 = (PCCurveFit *)OZCurve::processCurve(this, (OZCurveNodeParam *)&v69, v19, a2);
    v66 = 0uLL;
    v67 = 0;
    if (Seconds)
    {
      v21 = 0;
      for (i = 0; i < Seconds; ++i)
      {
        v23 = *((_QWORD *)&v66 + 1);
        if (*((_QWORD *)&v66 + 1) >= (unint64_t)v67)
        {
          v25 = (*((_QWORD *)&v66 + 1) - v21) >> 4;
          v26 = v25 + 1;
          if ((unint64_t)(v25 + 1) >> 60)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v27 = (uint64_t)&v67[-v21];
          if (v27 >> 3 > v26)
            v26 = v27 >> 3;
          if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0)
            v28 = 0xFFFFFFFFFFFFFFFLL;
          else
            v28 = v26;
          v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&v67, v28);
          v31 = &v29[16 * v25];
          *(_QWORD *)v31 = 0;
          *((_QWORD *)v31 + 1) = 0;
          v33 = (char *)*((_QWORD *)&v66 + 1);
          v32 = (char *)v66;
          v34 = v31;
          while (v33 != v32)
          {
            v35 = *((_OWORD *)v33 - 1);
            v33 -= 16;
            *((_OWORD *)v34 - 1) = v35;
            v34 -= 16;
          }
          v24 = (uint64_t)(v31 + 16);
          *(_QWORD *)&v66 = v34;
          *((_QWORD *)&v66 + 1) = v31 + 16;
          v67 = &v29[16 * v30];
          if (v32)
            operator delete(v32);
        }
        else
        {
          v24 = *((_QWORD *)&v66 + 1) + 16;
          **((_QWORD **)&v66 + 1) = 0;
          *(_QWORD *)(v23 + 8) = 0;
        }
        *((_QWORD *)&v66 + 1) = v24;
        memset(&__p, 0, sizeof(__p));
        operator*(&v79, i, &__p);
        v84 = v78;
        v83 = __p;
        v36 = v66;
        PC_CMTimeSaferAdd(&v84, &v83, (uint64_t)&v64);
        *(Float64 *)(v36 + 16 * i) = CMTimeGetSeconds(&v64);
        v21 = v66;
        *(double *)(v66 + 16 * i + 8) = v81[i] * a7;
      }
    }
    memset(&__p, 0, sizeof(__p));
    Instance = PCCurveFit::getInstance(v20);
    PCCurveFit::FitCurve(Instance, (float64x2_t **)&v66, (uint64_t)&__p, a6 / 100.0);
    if (Seconds >= 2)
    {
      value = (Float64 *)__p.value;
      if (*(_QWORD *)&__p.timescale != __p.value)
      {
        v63 = v78;
        *value = CMTimeGetSeconds(&v63);
        *(double *)(__p.value + 8) = *v81 * a7;
        memset(&v62, 0, sizeof(v62));
        operator*(&v79, Seconds - 1, &v62);
        v39 = *(_QWORD *)&__p.timescale;
        v84 = v78;
        v83 = v62;
        PC_CMTimeSaferAdd(&v84, &v83, (uint64_t)&v61);
        *(Float64 *)(v39 - 16) = CMTimeGetSeconds(&v61);
        *(double *)(*(_QWORD *)&__p.timescale - 8) = v81[Seconds - 1] * a7;
      }
    }
    v40 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v7);
    OZSpline::deleteVertices(v40, a3, v60);
    v41 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v7);
    OZSpline::setInterpolation(v41, 4);
    *(_BYTE *)(*((_QWORD *)this + 20) + 3) = 0;
    v42 = *(void **)&__p.timescale;
    if (*(_QWORD *)&__p.timescale != __p.value)
    {
      v43 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v7);
      OZFigTimeForChannelSeconds(&v84, *(Float64 *)__p.value, 0x40000);
      v44 = OZSpline::addVertexNoTangents(v43, &v84, *(double *)(__p.value + 8) / a7, MEMORY[0x1E0CA2E68], 1);
      v45 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v7);
      (*(void (**)(uint64_t, OZStaticVertex *, _QWORD, _QWORD, double, double))(*(_QWORD *)v45 + 120))(v45, v44, MEMORY[0x1E0CA2E68], 0, (*(double *)(__p.value + 16) - *(double *)__p.value) / 12.0, (*(double *)(__p.value + 24) - *(double *)(__p.value + 8)) / 12.0 / a7);
      v46 = (*(_QWORD *)&__p.timescale - __p.value) >> 4;
      if ((unint64_t)(v46 - 5) <= 0xFFFFFFFFFFFFFFFCLL)
      {
        v47 = 3;
        v48 = 2;
        v49 = (const CMTime *)MEMORY[0x1E0CA2E68];
        do
        {
          v50 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v7);
          OZFigTimeForChannelSeconds(&v84, *(Float64 *)(__p.value + 16 * v47), 0x40000);
          v51 = OZSpline::addVertexNoTangents(v50, &v84, *(double *)(__p.value + 16 * v47 + 8) / a7, v49, 1);
          v52 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v7);
          (*(void (**)(uint64_t, OZStaticVertex *, const CMTime *, _QWORD, double, double))(*(_QWORD *)v52 + 120))(v52, v51, v49, 0, (*(double *)(__p.value + 16 * (v47 + 1)) - *(double *)(__p.value + 16 * v47)) / 12.0, (*(double *)(__p.value + 16 * (v47 + 1) + 8) - *(double *)(__p.value + 16 * v47 + 8)) / 12.0 / a7);
          v53 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v7);
          (*(void (**)(uint64_t, OZStaticVertex *, const CMTime *, _QWORD, double, double))(*(_QWORD *)v53 + 112))(v53, v51, v49, 0, (*(double *)(__p.value + 16 * v48) - *(double *)(__p.value + 16 * v47)) / 12.0, (*(double *)(__p.value + 16 * v48 + 8) - *(double *)(__p.value + 16 * v47 + 8)) / 12.0 / a7);
          v48 = v47 + 2;
          v46 = (*(_QWORD *)&__p.timescale - __p.value) >> 4;
          v47 += 3;
        }
        while (v46 - 2 > v48);
      }
      v54 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v7);
      v55 = (v46 - 1);
      OZFigTimeForChannelSeconds(&v84, *(Float64 *)(__p.value + 16 * v55), 0x40000);
      v56 = OZSpline::addVertexNoTangents(v54, &v84, *(double *)(__p.value + 16 * v55 + 8) / a7, MEMORY[0x1E0CA2E68], 1);
      v57 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v7);
      (*(void (**)(uint64_t, OZStaticVertex *, _QWORD, _QWORD, double, double))(*(_QWORD *)v57 + 112))(v57, v56, MEMORY[0x1E0CA2E68], 0, (*(double *)(__p.value + 16 * (v46 - 2)) - *(double *)(__p.value + 16 * v55)) / 12.0, (*(double *)(__p.value + 16 * (v46 - 2) + 8) - *(double *)(__p.value + 16 * v55 + 8))/ 12.0/ a7);
      v42 = (void *)__p.value;
    }
    v82 = 1;
    v81 = 0;
    if (v42)
    {
      *(_QWORD *)&__p.timescale = v42;
      operator delete(v42);
    }
    if ((_QWORD)v66)
    {
      *((_QWORD *)&v66 + 1) = v66;
      operator delete((void *)v66);
    }
    OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)&v69);
    v8 = v59;
  }
  return v7 == v8;
}

void sub_1B2C2D268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  if (__p)
    operator delete(__p);
  if (a26)
    operator delete(a26);
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)&a32);
  _Unwind_Resume(a1);
}

uint64_t OZCurve::simplifyCurve(OZCurve *this, const CMTime *a2, const CMTime *a3, CMTime *a4, double a5, double a6, int a7, int a8)
{
  PVInstructionGraphContext *v8;
  uint64_t v9;
  uint64_t v19;
  OZSpline *v20;
  double v21;
  const CMTime *v22;
  int NextValidVertexWithLock;
  void *value;
  int v25;
  double v26;
  double Seconds;
  double v28;
  double v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  double v36;
  uint64_t v37;
  CMTime *v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v41;
  _QWORD *v42;
  char *v43;
  char *v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  CMTimeEpoch epoch;
  int32_t v54;
  double v55;
  unsigned int v56;
  double *v57;
  PCCurveFit *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  double *v62;
  int v63;
  double v64;
  int v65;
  double *v66;
  CMTimeValue v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  char *v77;
  char *v78;
  char *v79;
  CMTimeValue v80;
  __int128 v81;
  CMTimeValue v82;
  double v83;
  uint64_t Instance;
  _BYTE *v85;
  _QWORD *v86;
  uint64_t v87;
  unsigned int v88;
  uint64_t v89;
  char *v90;
  uint64_t v91;
  void *v92;
  OZSpline *v93;
  OZStaticVertex *v94;
  uint64_t v95;
  Float64 v96;
  CMTimeValue v97;
  unsigned int v98;
  unint64_t v99;
  const CMTime *v100;
  OZSpline *v101;
  OZStaticVertex *v102;
  uint64_t v103;
  Float64 v104;
  uint64_t v105;
  Float64 v106;
  OZSpline *v107;
  uint64_t v108;
  OZStaticVertex *v109;
  uint64_t v110;
  uint64_t v111;
  Float64 v112;
  CMTime *v113;
  CMTime v114;
  CMTime v115;
  CMTime v116;
  CMTime v117;
  CMTime v118;
  CMTime v119;
  CMTime v120;
  CMTime v121;
  CMTime time1;
  __int128 v123;
  CMTimeEpoch v124;
  __int128 v125;
  CMTimeEpoch v126;
  int v127;
  uint64_t v128;
  char v129;
  CMTime v130;
  CMTime v131;
  int v132;
  uint64_t v133;
  char v134;
  CMTime v135;
  CMTime time;
  CMTime __p;
  double v138;
  double v139;
  CMTime v140;
  void *v141;
  int v142;
  char *v143;
  char *v144;
  char *v145;
  _QWORD *v146;
  _BYTE *v147;
  uint64_t v148;
  CMTime v149;
  CMTime time2;

  v146 = 0;
  v147 = 0;
  v148 = 0;
  v143 = 0;
  v144 = 0;
  v145 = 0;
  v8 = (PVInstructionGraphContext *)*((_QWORD *)this + 1);
  if (v8 == (PVInstructionGraphContext *)((char *)this + 40)
    && PVInstructionGraphContext::HGNodeCache(*((PVInstructionGraphContext **)this + 1))
    && (v19 = PVInstructionGraphContext::HGNodeCache(v8),
        (*(void (**)(uint64_t, _QWORD **))(*(_QWORD *)v19 + 24))(v19, &v146),
        (unint64_t)(v147 - (_BYTE *)v146) >= 0x10))
  {
    if (a7 == 4)
    {
      v140.value = 0;
      __p.value = 0;
      v149 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
      v120.value = 0;
      v30 = PVInstructionGraphContext::HGNodeCache(v8);
      (*(void (**)(uint64_t, _QWORD, _QWORD, CMTime *, _QWORD))(*(_QWORD *)v30 + 264))(v30, *v146, 0, &v140, MEMORY[0x1E0CA2E68]);
      if ((unint64_t)(((v147 - (_BYTE *)v146) >> 3) - 3) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v31 = 1;
        v32 = MEMORY[0x1E0CA2E68];
        LODWORD(v33) = 1;
        do
        {
          v34 = PVInstructionGraphContext::HGNodeCache(v8);
          (*(void (**)(uint64_t, _QWORD, CMTime *, CMTime *, uint64_t))(*(_QWORD *)v34 + 264))(v34, v146[v31], &v149, &__p, v32);
          time1 = v149;
          time2 = *a2;
          if (CMTimeCompare(&time1, &time2) < 0 || (time1 = v149, time2 = *a3, CMTimeCompare(&time1, &time2) > 0))
          {
            v140.value = __p.value;
            v33 = (v33 + 1);
          }
          else
          {
            v35 = PVInstructionGraphContext::HGNodeCache(v8);
            v33 = (v33 + 1);
            (*(void (**)(uint64_t, _QWORD, _QWORD, CMTime *, uint64_t))(*(_QWORD *)v35 + 264))(v35, v146[v33], 0, &v120, v32);
            v36 = *(double *)&v120.value - *(double *)&__p.value;
            if ((*(double *)&__p.value - *(double *)&v140.value <= 0.0 || v36 >= 0.0)
              && (*(double *)&__p.value - *(double *)&v140.value >= 0.0 || v36 <= 0.0))
            {
              v37 = PVInstructionGraphContext::HGNodeCache(v8);
              (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)v37 + 32))(v37, v146[v31], 1, v32);
            }
            else
            {
              v140.value = __p.value;
            }
          }
          v31 = v33;
        }
        while (((v147 - (_BYTE *)v146) >> 3) - 1 > v33);
      }
    }
    else if (a7 == 2)
    {
      v142 = 0;
      (*(void (**)(OZCurve *, int *))(*(_QWORD *)this + 304))(this, &v142);
      if (fabs((double)a8) < 0.0000001 && v142 == 1)
      {
        v149 = *a2;
        v120.value = 0;
        v141 = 0;
        v20 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
        v140 = v149;
        v21 = (*(double (**)(OZSpline *, CMTime *, _QWORD, _QWORD))(*(_QWORD *)v20 + 240))(v20, &v149, MEMORY[0x1E0CA2E68], 0);
        if (!OZSpline::getVertexHandle(v20, &v140, (void **)&v120, 0))
          (*(void (**)(OZSpline *, CMTime *, _QWORD, uint64_t, double))(*(_QWORD *)v20 + 192))(v20, &v140, MEMORY[0x1E0CA2E68], 1, v21);
        v22 = (const CMTime *)MEMORY[0x1E0CA2E68];
        NextValidVertexWithLock = OZSpline::getNextValidVertexWithLock(v20, &v149, (void **)&v120, MEMORY[0x1E0CA2E68], 0);
        value = (void *)v120.value;
        if (v120.value)
          v25 = NextValidVertexWithLock;
        else
          v25 = 0;
        if (v25 == 1)
        {
          do
          {
            if (!OZSpline::getNextValidVertexWithLock(v20, value, &v141, v22))
              break;
            v138 = 0.0;
            v139 = 0.0;
            __p = *v22;
            (*(void (**)(OZSpline *, CMTimeValue, CMTime *, double *, const CMTime *))(*(_QWORD *)v20 + 264))(v20, v120.value, &v149, &v139, v22);
            (*(void (**)(OZSpline *, void *, CMTime *, double *, const CMTime *))(*(_QWORD *)v20 + 264))(v20, v141, &__p, &v138, v22);
            v26 = v139;
            time1 = v149;
            time2 = v140;
            PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&time);
            Seconds = CMTimeGetSeconds(&time);
            v28 = v138;
            v29 = v139;
            time1 = __p;
            time2 = v149;
            PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v135);
            if (vabdd_f64((v28 - v29) / CMTimeGetSeconds(&v135), (v26 - v21) / Seconds) >= 0.0000001)
            {
              v140 = v149;
              v21 = v139;
            }
            else
            {
              (*(void (**)(OZSpline *, CMTimeValue, uint64_t, const CMTime *))(*(_QWORD *)v20 + 32))(v20, v120.value, 1, v22);
            }
            v120.value = (CMTimeValue)v141;
            time1 = __p;
            time2 = *a3;
            if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
              break;
            value = (void *)v120.value;
          }
          while (v120.value);
        }
        if (!OZSpline::getVertexHandle(v20, a3, (void **)&v120, 0))
        {
          (*(void (**)(OZSpline *, const CMTime *, _QWORD, _QWORD))(*(_QWORD *)v20 + 240))(v20, a3, MEMORY[0x1E0CA2E68], 0);
          (*(void (**)(OZSpline *, const CMTime *, _QWORD, uint64_t))(*(_QWORD *)v20 + 192))(v20, a3, MEMORY[0x1E0CA2E68], 1);
        }
      }
      else
      {
        v113 = a4;
        v38 = (CMTime *)MEMORY[0x1E0CA2E68];
        if (v147 != (_BYTE *)v146)
        {
          v39 = 0;
          v40 = 0;
          do
          {
            v149 = *v38;
            v41 = PVInstructionGraphContext::HGNodeCache(v8);
            (*(void (**)(uint64_t, _QWORD, CMTime *, _QWORD, CMTime *))(*(_QWORD *)v41 + 264))(v41, v146[v39], &v149, 0, v38);
            time1 = v149;
            time2 = *a2;
            if (CMTimeCompare(&time1, &time2) < 0 || (time1 = v149, time2 = *a3, CMTimeCompare(&time1, &time2) >= 1))
            {
              v42 = v146;
              v43 = v144;
              if (v144 >= v145)
              {
                v45 = (v144 - v143) >> 3;
                if ((unint64_t)(v45 + 1) >> 61)
                  std::vector<double>::__throw_length_error[abi:ne180100]();
                v46 = (v145 - v143) >> 2;
                if (v46 <= v45 + 1)
                  v46 = v45 + 1;
                if ((unint64_t)(v145 - v143) >= 0x7FFFFFFFFFFFFFF8)
                  v47 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v47 = v46;
                if (v47)
                  v48 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v145, v47);
                else
                  v48 = 0;
                v49 = &v48[8 * v45];
                *(_QWORD *)v49 = v42[v39];
                v44 = v49 + 8;
                v51 = v143;
                v50 = v144;
                if (v144 != v143)
                {
                  do
                  {
                    v52 = *((_QWORD *)v50 - 1);
                    v50 -= 8;
                    *((_QWORD *)v49 - 1) = v52;
                    v49 -= 8;
                  }
                  while (v50 != v51);
                  v50 = v143;
                }
                v143 = v49;
                v144 = v44;
                v145 = &v48[8 * v47];
                if (v50)
                  operator delete(v50);
              }
              else
              {
                *(_QWORD *)v144 = v146[v39];
                v44 = v43 + 8;
              }
              v144 = v44;
            }
            v39 = ++v40;
          }
          while (v40 < (unint64_t)((v147 - (_BYTE *)v146) >> 3));
        }
        LOWORD(time1.value) = 1;
        v127 = 0;
        v128 = 0;
        v129 = 0;
        v123 = *(_OWORD *)&v38->value;
        epoch = v38->epoch;
        *(_QWORD *)&time1.timescale = 0;
        v124 = epoch;
        v125 = v123;
        v126 = epoch;
        v132 = 0;
        v133 = 0;
        v134 = 0;
        *(_OWORD *)&v130.value = v123;
        *(_OWORD *)&v131.value = v123;
        v130.epoch = epoch;
        v131.epoch = epoch;
        memset(&v140, 0, sizeof(v140));
        time2 = *a3;
        v149 = *a2;
        PC_CMTimeSaferSubtract(&time2, &v149, (uint64_t)&v140);
        time2 = v140;
        v149 = *v113;
        v54 = CMTimeCompare(&time2, &v149);
        v55 = a5 / 100.0 / a6;
        if (v55 > 1.0 || v54 >= 1)
        {
          v131 = *v113;
          time2 = *a3;
          v149 = *a2;
          PC_CMTimeSaferSubtract(&time2, &v149, (uint64_t)&__p);
          operator/((__int128 *)&__p.value, (uint64_t)v113, (uint64_t)&v121);
          v56 = CMTimeGetSeconds(&v121);
        }
        else
        {
          v131 = v140;
          operator*(&v131, &time2, 0.001);
          v131 = time2;
          v56 = 1000;
        }
        v132 = v56;
        v130 = *a2;
        v133 = operator new[]();
        v58 = (PCCurveFit *)OZCurve::processCurve(this, (OZCurveNodeParam *)&time1, v57, 0);
        LODWORD(v59) = v132;
        if (a8 >= 1)
        {
          v60 = operator new[]();
          v59 = v132;
          v58 = (PCCurveFit *)v133;
          if (v132 >= 1)
          {
            v61 = 0;
            v62 = (double *)(v133 + 8 * (v132 - 1));
            do
            {
              *(_QWORD *)(v60 + 8 * v61) = 0;
              v63 = v61 - a8;
              if (v61 + a8 >= (int)v61 - a8)
              {
                v64 = 0.0;
                v65 = (2 * a8) | 1;
                do
                {
                  v66 = (double *)((char *)v58 + 8 * v63);
                  if (v63 >= (int)v59)
                    v66 = v62;
                  if (v63 < 0)
                    v66 = (double *)v58;
                  v64 = v64 + 1.0 / ((double)a8 + (double)a8 + 1.0) * *v66;
                  *(double *)(v60 + 8 * v61) = v64;
                  ++v63;
                  --v65;
                }
                while (v65);
              }
              ++v61;
            }
            while (v61 != v59);
          }
          if (v58)
          {
            v58 = (PCCurveFit *)MEMORY[0x1B5E2914C](v58, 0x1000C8000313F17);
            LODWORD(v59) = v132;
          }
          v133 = v60;
        }
        memset(&__p, 0, sizeof(__p));
        if ((_DWORD)v59)
        {
          v67 = 0;
          v68 = 0;
          do
          {
            v69 = *(_QWORD *)&__p.timescale;
            if (*(_QWORD *)&__p.timescale >= __p.epoch)
            {
              v71 = (*(_QWORD *)&__p.timescale - v67) >> 4;
              v72 = v71 + 1;
              if ((unint64_t)(v71 + 1) >> 60)
                std::vector<double>::__throw_length_error[abi:ne180100]();
              v73 = __p.epoch - v67;
              if (v73 >> 3 > v72)
                v72 = v73 >> 3;
              if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFF0)
                v74 = 0xFFFFFFFFFFFFFFFLL;
              else
                v74 = v72;
              v75 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&__p.epoch, v74);
              v77 = &v75[16 * v71];
              *(_QWORD *)v77 = 0;
              *((_QWORD *)v77 + 1) = 0;
              v78 = (char *)__p.value;
              v79 = *(char **)&__p.timescale;
              v80 = (CMTimeValue)v77;
              while (v79 != v78)
              {
                v81 = *((_OWORD *)v79 - 1);
                v79 -= 16;
                *(_OWORD *)(v80 - 16) = v81;
                v80 -= 16;
              }
              v70 = (uint64_t)(v77 + 16);
              __p.value = v80;
              *(_QWORD *)&__p.timescale = v77 + 16;
              __p.epoch = (CMTimeEpoch)&v75[16 * v76];
              if (v78)
                operator delete(v78);
            }
            else
            {
              v70 = *(_QWORD *)&__p.timescale + 16;
              **(_QWORD **)&__p.timescale = 0;
              *(_QWORD *)(v69 + 8) = 0;
            }
            *(_QWORD *)&__p.timescale = v70;
            memset(&v120, 0, sizeof(v120));
            operator*(&v131, v68, &v120);
            v82 = __p.value;
            time2 = v130;
            v149 = v120;
            PC_CMTimeSaferAdd(&time2, &v149, (uint64_t)&v119);
            v83 = CMTimeGetSeconds(&v119);
            v118 = *v113;
            *(double *)(v82 + 16 * v68) = v83 / CMTimeGetSeconds(&v118);
            v67 = __p.value;
            *(_QWORD *)(__p.value + 16 * v68 + 8) = *(_QWORD *)(v133 + 8 * v68);
            ++v68;
          }
          while (v68 < v132);
        }
        memset(&time2, 0, sizeof(time2));
        Instance = PCCurveFit::getInstance(v58);
        PCCurveFit::FitCurve(Instance, (float64x2_t **)&__p, (uint64_t)&time2, v55);
        v134 = 1;
        v133 = 0;
        v86 = v146;
        v85 = v147;
        if (v147 != (_BYTE *)v146)
        {
          v87 = 0;
          v88 = 0;
          v89 = MEMORY[0x1E0CA2E68];
          do
          {
            v90 = v143;
            if (v143 != v144)
            {
              while (*(_QWORD *)v90 != v86[v87])
              {
                v90 += 8;
                if (v90 == v144)
                {
                  v90 = v144;
                  break;
                }
              }
            }
            if (v90 == v144)
            {
              v91 = PVInstructionGraphContext::HGNodeCache(v8);
              (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)v91 + 32))(v91, v146[v87], 1, v89);
              v86 = v146;
              v85 = v147;
            }
            v87 = ++v88;
          }
          while (v88 < (unint64_t)((v85 - (_BYTE *)v86) >> 3));
        }
        v92 = *(void **)&time2.timescale;
        if (*(_QWORD *)&time2.timescale != time2.value)
        {
          v93 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
          OZFigTimeForChannelSeconds(&v120, *(Float64 *)time2.value, 0x40000);
          operator*((__int128 *)&v120.value, (uint64_t)v113, (uint64_t)&v149);
          v94 = OZSpline::addVertexNoTangents(v93, &v149, *(double *)(time2.value + 8), MEMORY[0x1E0CA2E68], 1);
          v95 = PVInstructionGraphContext::HGNodeCache(v8);
          operator*(v113, &v117, *(double *)(time2.value + 16) - *(double *)time2.value);
          v96 = CMTimeGetSeconds(&v117);
          (*(void (**)(uint64_t, OZStaticVertex *, _QWORD, _QWORD, Float64, double))(*(_QWORD *)v95 + 120))(v95, v94, MEMORY[0x1E0CA2E68], 0, v96 / 12.0, (*(double *)(time2.value + 24) - *(double *)(time2.value + 8)) / 12.0);
          v97 = (*(_QWORD *)&time2.timescale - time2.value) >> 4;
          if ((unint64_t)(v97 - 5) <= 0xFFFFFFFFFFFFFFFCLL)
          {
            v98 = 3;
            v99 = 2;
            v100 = (const CMTime *)MEMORY[0x1E0CA2E68];
            do
            {
              v101 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
              OZFigTimeForChannelSeconds(&v120, *(Float64 *)(time2.value + 16 * v98), 0x40000);
              operator*((__int128 *)&v120.value, (uint64_t)v113, (uint64_t)&v149);
              v102 = OZSpline::addVertexNoTangents(v101, &v149, *(double *)(time2.value + 16 * v98 + 8), v100, 1);
              v103 = PVInstructionGraphContext::HGNodeCache(v8);
              operator*(v113, &v116, *(double *)(time2.value + 16 * v99) - *(double *)(time2.value + 16 * v98));
              v104 = CMTimeGetSeconds(&v116);
              (*(void (**)(uint64_t, OZStaticVertex *, const CMTime *, _QWORD, Float64, double))(*(_QWORD *)v103 + 112))(v103, v102, v100, 0, v104 / 12.0, (*(double *)(time2.value + 16 * v99 + 8) - *(double *)(time2.value + 16 * v98 + 8)) / 12.0);
              v105 = PVInstructionGraphContext::HGNodeCache(v8);
              operator*(v113, &v115, *(double *)(time2.value + 16 * (v98 + 1)) - *(double *)(time2.value + 16 * v98));
              v106 = CMTimeGetSeconds(&v115);
              (*(void (**)(uint64_t, OZStaticVertex *, const CMTime *, _QWORD, Float64, double))(*(_QWORD *)v105 + 120))(v105, v102, v100, 0, v106 / 12.0, (*(double *)(time2.value + 16 * (v98 + 1) + 8) - *(double *)(time2.value + 16 * v98 + 8)) / 12.0);
              v99 = v98 + 2;
              v97 = (*(_QWORD *)&time2.timescale - time2.value) >> 4;
              v98 += 3;
            }
            while (v97 - 2 > v99);
          }
          v107 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
          v108 = (v97 - 1);
          OZFigTimeForChannelSeconds(&v120, *(Float64 *)(time2.value + 16 * v108), 0x40000);
          operator*((__int128 *)&v120.value, (uint64_t)v113, (uint64_t)&v149);
          v109 = OZSpline::addVertexNoTangents(v107, &v149, *(double *)(time2.value + 16 * v108 + 8), MEMORY[0x1E0CA2E68], 1);
          v110 = PVInstructionGraphContext::HGNodeCache(v8);
          v111 = (v97 - 2);
          operator*(v113, &v114, *(double *)(time2.value + 16 * v111) - *(double *)(time2.value + 16 * v108));
          v112 = CMTimeGetSeconds(&v114);
          (*(void (**)(uint64_t, OZStaticVertex *, _QWORD, _QWORD, Float64, double))(*(_QWORD *)v110 + 112))(v110, v109, MEMORY[0x1E0CA2E68], 0, v112 / 12.0, (*(double *)(time2.value + 16 * v111 + 8) - *(double *)(time2.value + 16 * v108 + 8)) / 12.0);
          v92 = (void *)time2.value;
        }
        if (v92)
        {
          *(_QWORD *)&time2.timescale = v92;
          operator delete(v92);
        }
        if (__p.value)
        {
          *(_QWORD *)&__p.timescale = __p.value;
          operator delete((void *)__p.value);
        }
        OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)&time1);
      }
    }
    v9 = 1;
  }
  else
  {
    v9 = 0;
  }
  if (v143)
  {
    v144 = v143;
    operator delete(v143);
  }
  if (v146)
  {
    v147 = v146;
    operator delete(v146);
  }
  return v9;
}

void sub_1B2C2E220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  uint64_t v35;
  void *v37;
  void *v38;

  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)&a35);
  v37 = *(void **)(v35 - 256);
  if (v37)
  {
    *(_QWORD *)(v35 - 248) = v37;
    operator delete(v37);
  }
  v38 = *(void **)(v35 - 232);
  if (v38)
  {
    *(_QWORD *)(v35 - 224) = v38;
    operator delete(v38);
  }
  _Unwind_Resume(a1);
}

uint64_t OZCurve::smoothCurve(OZCurve *this, const CMTime *a2, const CMTime *a3, const CMTime *a4)
{
  PVInstructionGraphContext *v4;
  uint64_t v5;
  uint64_t v10;
  CMTime *v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  _QWORD *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  unsigned int Seconds;
  double *v27;
  uint64_t v28;
  uint64_t v29;
  double *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  unsigned int v34;
  double v35;
  double *v36;
  _BYTE *v37;
  _QWORD *v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  const CMTime *v45;
  double v46;
  OZSpline *v47;
  OZStaticVertex *v48;
  uint64_t v49;
  uint64_t v50;
  CMTime v52;
  CMTime v53;
  CMTime time;
  CMTime v55;
  CMTime time1;
  CMTime v57;
  CMTime v58;
  int v59;
  uint64_t v60;
  char v61;
  CMTime v62;
  CMTime v63;
  int v64;
  uint64_t v65;
  char v66;
  int v67;
  char *v68;
  char *v69;
  char *v70;
  _QWORD *v71;
  _BYTE *v72;
  uint64_t v73;
  CMTime v74;
  CMTime time2;

  v71 = 0;
  v72 = 0;
  v73 = 0;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v4 = (PVInstructionGraphContext *)*((_QWORD *)this + 1);
  if (v4 == (PVInstructionGraphContext *)((char *)this + 40))
  {
    if (PVInstructionGraphContext::HGNodeCache(*((PVInstructionGraphContext **)this + 1))
      && (v10 = PVInstructionGraphContext::HGNodeCache(v4),
          (*(void (**)(uint64_t, _QWORD **))(*(_QWORD *)v10 + 24))(v10, &v71),
          (unint64_t)(v72 - (_BYTE *)v71) >= 0x10))
    {
      v67 = 0;
      (*(void (**)(OZCurve *, int *))(*(_QWORD *)this + 304))(this, &v67);
      v11 = (CMTime *)MEMORY[0x1E0CA2E68];
      if (v72 != (_BYTE *)v71)
      {
        v12 = 0;
        v13 = 0;
        do
        {
          v74 = *v11;
          v14 = PVInstructionGraphContext::HGNodeCache(v4);
          (*(void (**)(uint64_t, _QWORD, CMTime *, _QWORD, CMTime *))(*(_QWORD *)v14 + 264))(v14, v71[v12], &v74, 0, v11);
          time1 = v74;
          time2 = *a2;
          if (CMTimeCompare(&time1, &time2) < 0 || (time1 = v74, time2 = *a3, CMTimeCompare(&time1, &time2) >= 1))
          {
            v15 = v71;
            v16 = v69;
            if (v69 >= v70)
            {
              v18 = (v69 - v68) >> 3;
              if ((unint64_t)(v18 + 1) >> 61)
                std::vector<double>::__throw_length_error[abi:ne180100]();
              v19 = (v70 - v68) >> 2;
              if (v19 <= v18 + 1)
                v19 = v18 + 1;
              if ((unint64_t)(v70 - v68) >= 0x7FFFFFFFFFFFFFF8)
                v20 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v20 = v19;
              if (v20)
                v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v70, v20);
              else
                v21 = 0;
              v22 = &v21[8 * v18];
              *(_QWORD *)v22 = v15[v12];
              v17 = v22 + 8;
              v24 = v68;
              v23 = v69;
              if (v69 != v68)
              {
                do
                {
                  v25 = *((_QWORD *)v23 - 1);
                  v23 -= 8;
                  *((_QWORD *)v22 - 1) = v25;
                  v22 -= 8;
                }
                while (v23 != v24);
                v23 = v68;
              }
              v68 = v22;
              v69 = v17;
              v70 = &v21[8 * v20];
              if (v23)
                operator delete(v23);
            }
            else
            {
              *(_QWORD *)v69 = v71[v12];
              v17 = v16 + 8;
            }
            v69 = v17;
          }
          v12 = ++v13;
        }
        while (v13 < (unint64_t)((v72 - (_BYTE *)v71) >> 3));
      }
      LOWORD(time1.value) = 1;
      *(_QWORD *)&time1.timescale = 0;
      v59 = 0;
      v60 = 0;
      v61 = 0;
      v57 = *v11;
      v58 = v57;
      v64 = 0;
      v65 = 0;
      v66 = 0;
      v62 = v57;
      v63 = v57;
      memset(&v55, 0, sizeof(v55));
      time2 = *a3;
      v74 = *a2;
      PC_CMTimeSaferSubtract(&time2, &v74, (uint64_t)&v55);
      time2 = v55;
      v74 = *a4;
      if (CMTimeCompare(&time2, &v74) < 1)
      {
        v63 = v55;
        operator*(&v63, &time2, 0.001);
        v63 = time2;
        Seconds = 1000;
      }
      else
      {
        v63 = *a4;
        time2 = *a3;
        v74 = *a2;
        PC_CMTimeSaferSubtract(&time2, &v74, (uint64_t)&v53);
        operator/((__int128 *)&v53.value, (uint64_t)a4, (uint64_t)&time);
        Seconds = CMTimeGetSeconds(&time);
      }
      v64 = Seconds;
      v62 = *a2;
      v65 = operator new[]();
      OZCurve::processCurve(this, (OZCurveNodeParam *)&time1, v27, 0);
      v28 = operator new[]();
      v29 = v64;
      v30 = (double *)v65;
      if (v64 >= 1)
      {
        v31 = 0;
        do
        {
          *(_QWORD *)(v28 + 8 * v31) = 0;
          v32 = v31 - 3;
          v33 = (int)v31 + 3;
          if (v33 >= (int)v31 - 3)
          {
            v34 = 0;
            v35 = 0.0;
            do
            {
              v36 = &v30[v32];
              if (v32 >= (int)v29)
                v36 = &v30[(v29 - 1)];
              if (v32 < 0)
                v36 = v30;
              v35 = v35 + *v36 * dbl_1B35564F0[v34] * 0.0476190476;
              *(double *)(v28 + 8 * v31) = v35;
              ++v34;
              ++v32;
            }
            while (v33 >= v32);
          }
          ++v31;
        }
        while (v31 != v29);
      }
      if (v30)
        MEMORY[0x1B5E2914C](v30, 0x1000C8000313F17);
      v65 = v28;
      v38 = v71;
      v37 = v72;
      if (v72 != (_BYTE *)v71)
      {
        v39 = 0;
        v40 = 0;
        v41 = MEMORY[0x1E0CA2E68];
        do
        {
          v42 = v68;
          if (v68 != v69)
          {
            while (*(_QWORD *)v42 != v38[v39])
            {
              v42 += 8;
              if (v42 == v69)
              {
                v42 = v69;
                break;
              }
            }
          }
          if (v42 == v69)
          {
            v43 = PVInstructionGraphContext::HGNodeCache(v4);
            (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)v43 + 32))(v43, v71[v39], 1, v41);
            v38 = v71;
            v37 = v72;
          }
          v39 = ++v40;
        }
        while (v40 < (unint64_t)((v37 - (_BYTE *)v38) >> 3));
      }
      if (v64)
      {
        v44 = 0;
        v45 = (const CMTime *)MEMORY[0x1E0CA2E68];
        do
        {
          memset(&v53, 0, sizeof(v53));
          operator*(&v63, v44, &v53);
          memset(&v52, 0, sizeof(v52));
          time2 = v62;
          v74 = v53;
          PC_CMTimeSaferAdd(&time2, &v74, (uint64_t)&v52);
          v46 = *(double *)(v65 + 8 * v44);
          v47 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v4);
          v48 = OZSpline::addVertexNoTangents(v47, &v52, v46, v45, 1);
          v49 = PVInstructionGraphContext::HGNodeCache(v4);
          (*(void (**)(uint64_t, OZStaticVertex *, const CMTime *, _QWORD, double, double))(*(_QWORD *)v49 + 112))(v49, v48, v45, 0, 0.0, 0.0);
          v50 = PVInstructionGraphContext::HGNodeCache(v4);
          (*(void (**)(uint64_t, OZStaticVertex *, const CMTime *, _QWORD, double, double))(*(_QWORD *)v50 + 120))(v50, v48, v45, 0, 0.0, 0.0);
          ++v44;
        }
        while (v44 < v64);
      }
      v5 = 1;
      v66 = 1;
      v65 = 0;
      OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)&time1);
    }
    else
    {
      v5 = 0;
    }
    if (v68)
    {
      v69 = v68;
      operator delete(v68);
    }
  }
  else
  {
    v5 = 0;
  }
  if (v71)
  {
    v72 = v71;
    operator delete(v71);
  }
  return v5;
}

void sub_1B2C2E96C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  uint64_t v15;
  void *v17;
  void *v18;
  va_list va;

  va_start(va, a15);
  OZCurveNodeParam::~OZCurveNodeParam((OZCurveNodeParam *)va);
  v17 = *(void **)(v15 - 208);
  if (v17)
  {
    *(_QWORD *)(v15 - 200) = v17;
    operator delete(v17);
  }
  v18 = *(void **)(v15 - 184);
  if (v18)
  {
    *(_QWORD *)(v15 - 176) = v18;
    operator delete(v18);
  }
  _Unwind_Resume(a1);
}

uint64_t OZCurve::moveKeypoint(OZCurve *this, char *a2, const CMTime *a3, int a4, int a5, char a6)
{
  PVInstructionGraphContext *v12;
  uint64_t result;
  OZSpline *v14;
  OZSpline *v15;

  if (!a2)
    return 0;
  v12 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    if (*((_BYTE *)this + 138) && (OZCurve::isAnimated(this) || a4))
    {
      v14 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v12);
      result = OZSpline::isValidHandle(v14, a2);
      if ((_DWORD)result)
      {
        v15 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v12);
        return OZSpline::moveVertex(v15, a2, a3, MEMORY[0x1E0CA2E68], 0, a6, a5) != 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t OZCurve::cloneKeypoint(OZCurve *this, char *a2, const CMTime *a3, int a4)
{
  PVInstructionGraphContext *v8;
  uint64_t result;
  OZSpline *v10;
  OZSpline *v11;

  if (!a2)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    if (*((_BYTE *)this + 138) && (OZCurve::isAnimated(this) || a4))
    {
      v10 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
      result = OZSpline::isValidHandle(v10, a2);
      if ((_DWORD)result)
      {
        v11 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
        return OZSpline::moveVertex(v11, a2, a3, MEMORY[0x1E0CA2E68], 1, 0, 0) != 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t OZCurve::setCurveExtrapolation(OZCurve *this, int a2, int a3)
{
  uint64_t v5;
  uint64_t LocalSplineState;
  _DWORD *v7;
  uint64_t v8;

  v5 = *((_QWORD *)this + 20);
  if (a3)
  {
    if (*(_DWORD *)(v5 + 40) != a2)
    {
      LocalSplineState = OZCurve::createLocalSplineState(this);
      *((_QWORD *)this + 20) = LocalSplineState;
      v7 = (_DWORD *)(LocalSplineState + 40);
LABEL_6:
      *v7 = a2;
    }
  }
  else if (*(_DWORD *)(v5 + 36) != a2)
  {
    v8 = OZCurve::createLocalSplineState(this);
    *((_QWORD *)this + 20) = v8;
    v7 = (_DWORD *)(v8 + 36);
    goto LABEL_6;
  }
  return 1;
}

uint64_t OZCurve::getCurveExtrapolation(OZCurve *this, unsigned int *a2, int a3)
{
  uint64_t v3;

  if (a2)
  {
    v3 = 40;
    if (!a3)
      v3 = 36;
    *a2 = *(_DWORD *)(*((_QWORD *)this + 20) + v3);
  }
  return 1;
}

OZCurve *OZCurve::setRetimingExtrapolation(OZCurve *this, int a2)
{
  char v2;
  OZCurve *v3;

  if ((*(_BYTE *)(*((_QWORD *)this + 20) + 4) != 0) != a2)
  {
    v2 = a2;
    v3 = this;
    this = (OZCurve *)OZCurve::createLocalSplineState(this);
    *((_QWORD *)v3 + 20) = this;
    *((_BYTE *)this + 4) = v2;
  }
  return this;
}

uint64_t OZCurve::getRetimingExtrapolation(OZCurve *this)
{
  return *(unsigned __int8 *)(*((_QWORD *)this + 20) + 4);
}

BOOL OZCurve::getKeypointHandle(OZCurve *this, const CMTime *a2, void **a3)
{
  PVInstructionGraphContext *v5;
  OZSpline *v6;

  if (!*((_DWORD *)this + 42))
    return 0;
  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    return 0;
  v6 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
  return OZSpline::getVertexHandle(v6, a2, a3, 1);
}

uint64_t OZCurve::getNumberOfKeypoints(OZCurve *this)
{
  PVInstructionGraphContext *v1;
  uint64_t result;
  uint64_t v3;

  if (!*((_DWORD *)this + 42))
    return 0;
  v1 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v3 = PVInstructionGraphContext::HGNodeCache(v1);
    return (*(_QWORD *)(v3 + 24) - *(_QWORD *)(v3 + 16)) >> 3;
  }
  return result;
}

uint64_t OZCurve::getKeypointHandleList(uint64_t a1, uint64_t a2)
{
  PVInstructionGraphContext *v3;
  uint64_t v4;

  if (!*(_DWORD *)(a1 + 168))
    return 0;
  v3 = (PVInstructionGraphContext *)(a1 + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)(a1 + 40)))
    return 0;
  v4 = PVInstructionGraphContext::HGNodeCache(v3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 24))(v4, a2);
}

uint64_t OZCurve::getKeypointValidHandleList(uint64_t a1, void **a2)
{
  PVInstructionGraphContext *v3;
  os_unfair_lock_s *v4;

  if (!*(_DWORD *)(a1 + 168))
    return 0;
  v3 = (PVInstructionGraphContext *)(a1 + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)(a1 + 40)))
    return 0;
  v4 = (os_unfair_lock_s *)PVInstructionGraphContext::HGNodeCache(v3);
  return OZSpline::getAllValidVerticesHandles(v4, a2, MEMORY[0x1E0CA2E68]);
}

__n128 OZCurve::getKeypointsTimeAndValue(uint64_t a1, _OWORD *a2, uint64_t a3, __n128 *a4, __n128 *a5)
{
  PVInstructionGraphContext *v9;
  __n128 result;
  os_unfair_lock_s *v11;
  __int128 v12;
  __n128 *v13;
  _OWORD v14[3];

  if (*(_DWORD *)(a1 + 168)
    && (v9 = (PVInstructionGraphContext *)(a1 + 40),
        PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)(a1 + 40))))
  {
    v11 = (os_unfair_lock_s *)PVInstructionGraphContext::HGNodeCache(v9);
    v12 = a2[1];
    v14[0] = *a2;
    v14[1] = v12;
    v14[2] = a2[2];
    OZSpline::getVerticesTimeAndValue(v11, (uint64_t)v14, (void **)a3, (uint64_t)a4, (uint64_t)a5);
  }
  else
  {
    *(_QWORD *)(a3 + 8) = *(_QWORD *)a3;
    v13 = (__n128 *)MEMORY[0x1E0CA2E18];
    if (a4)
    {
      result = *(__n128 *)MEMORY[0x1E0CA2E18];
      a4[1].n128_u64[0] = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
      *a4 = result;
    }
    if (a5)
    {
      result = *v13;
      a5[1].n128_u64[0] = v13[1].n128_u64[0];
      *a5 = result;
    }
  }
  return result;
}

uint64_t OZCurve::getFirstKeypoint(OZCurve *this, CMTime *a2, double *a3)
{
  PVInstructionGraphContext *v5;
  OZSpline *v6;
  __int128 *v7;
  uint64_t v8;
  uint64_t result;
  __int128 v10;
  __int128 v11;
  CMTimeEpoch v12;
  void *v13;

  if (*((_DWORD *)this + 42)
    && (v5 = (PVInstructionGraphContext *)((char *)this + 40),
        PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    && (v13 = 0,
        v6 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5),
        v7 = (__int128 *)MEMORY[0x1E0CA2E68],
        OZSpline::getFirstValidVertexWithLock(v6, &v13, MEMORY[0x1E0CA2E68])))
  {
    v11 = *v7;
    v12 = *((_QWORD *)v7 + 2);
    v8 = PVInstructionGraphContext::HGNodeCache(v5);
    (*(void (**)(uint64_t, void *, __int128 *, double *, __int128 *))(*(_QWORD *)v8 + 264))(v8, v13, &v11, a3, v7);
    if (a2)
    {
      *(_OWORD *)&a2->value = v11;
      a2->epoch = v12;
    }
    return 1;
  }
  else
  {
    if (a2)
    {
      v10 = *MEMORY[0x1E0CA2E68];
      a2->epoch = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
      *(_OWORD *)&a2->value = v10;
    }
    result = 0;
    if (a3)
      *a3 = 0.0;
  }
  return result;
}

uint64_t OZCurve::getFirstValidKeypointHandle(OZCurve *this, void **a2)
{
  PVInstructionGraphContext *v3;
  uint64_t result;
  OZSpline *v5;

  v3 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v5 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v3);
    return OZSpline::getFirstValidVertexWithLock(v5, a2, MEMORY[0x1E0CA2E68]);
  }
  return result;
}

uint64_t OZCurve::getLastKeypoint(OZCurve *this, CMTime *a2, double *a3)
{
  PVInstructionGraphContext *v5;
  OZSpline *v6;
  __int128 *v7;
  uint64_t v8;
  uint64_t result;
  __int128 v10;
  __int128 v11;
  CMTimeEpoch v12;
  void *v13;

  if (*((_DWORD *)this + 42)
    && (v5 = (PVInstructionGraphContext *)((char *)this + 40),
        PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    && (v13 = 0,
        v6 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5),
        v7 = (__int128 *)MEMORY[0x1E0CA2E68],
        OZSpline::getLastValidVertexWithLock(v6, &v13, MEMORY[0x1E0CA2E68])))
  {
    v11 = *v7;
    v12 = *((_QWORD *)v7 + 2);
    v8 = PVInstructionGraphContext::HGNodeCache(v5);
    (*(void (**)(uint64_t, void *, __int128 *, double *, __int128 *))(*(_QWORD *)v8 + 264))(v8, v13, &v11, a3, v7);
    if (a2)
    {
      *(_OWORD *)&a2->value = v11;
      a2->epoch = v12;
    }
    return 1;
  }
  else
  {
    if (a2)
    {
      v10 = *MEMORY[0x1E0CA2E68];
      a2->epoch = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
      *(_OWORD *)&a2->value = v10;
    }
    result = 0;
    if (a3)
      *a3 = 0.0;
  }
  return result;
}

uint64_t OZCurve::getLastValidKeypointHandle(OZCurve *this, void **a2)
{
  PVInstructionGraphContext *v3;
  uint64_t result;
  OZSpline *v5;

  v3 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v5 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v3);
    return OZSpline::getLastValidVertexWithLock(v5, a2, MEMORY[0x1E0CA2E68]);
  }
  return result;
}

uint64_t OZCurve::getNextKeypoint(OZCurve *this, const CMTime *a2, CMTime *a3, double *a4)
{
  PVInstructionGraphContext *v8;
  uint64_t result;
  OZSpline *v10;
  __int128 *v11;
  int NextValidVertexWithLock;
  uint64_t v13;
  __int128 v14;
  CMTimeEpoch v15;
  void *v16;

  v16 = 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    if (*((_DWORD *)this + 42))
    {
      v10 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
      v11 = (__int128 *)MEMORY[0x1E0CA2E68];
      NextValidVertexWithLock = OZSpline::getNextValidVertexWithLock(v10, a2, &v16, MEMORY[0x1E0CA2E68], 0);
      result = 0;
      if (NextValidVertexWithLock)
      {
        v14 = *v11;
        v15 = *((_QWORD *)v11 + 2);
        v13 = PVInstructionGraphContext::HGNodeCache(v8);
        (*(void (**)(uint64_t, void *, __int128 *, double *, __int128 *))(*(_QWORD *)v13 + 264))(v13, v16, &v14, a4, v11);
        if (a3)
        {
          *(_OWORD *)&a3->value = v14;
          a3->epoch = v15;
        }
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t OZCurve::getPreviousKeypoint(OZCurve *this, const CMTime *a2, CMTime *a3, double *a4)
{
  PVInstructionGraphContext *v8;
  uint64_t result;
  OZSpline *v10;
  __int128 *v11;
  int PreviousValidVertexWithLock;
  uint64_t v13;
  __int128 v14;
  CMTimeEpoch v15;
  void *v16;

  v16 = 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    if (*((_DWORD *)this + 42))
    {
      v10 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
      v11 = (__int128 *)MEMORY[0x1E0CA2E68];
      PreviousValidVertexWithLock = OZSpline::getPreviousValidVertexWithLock(v10, a2, &v16, MEMORY[0x1E0CA2E68], 0);
      result = 0;
      if (PreviousValidVertexWithLock)
      {
        v14 = *v11;
        v15 = *((_QWORD *)v11 + 2);
        v13 = PVInstructionGraphContext::HGNodeCache(v8);
        (*(void (**)(uint64_t, void *, __int128 *, double *, __int128 *))(*(_QWORD *)v13 + 264))(v13, v16, &v14, a4, v11);
        if (a3)
        {
          *(_OWORD *)&a3->value = v14;
          a3->epoch = v15;
        }
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t OZCurve::getKeypoint(OZCurve *this, char *a2, CMTime *a3, double *a4)
{
  PVInstructionGraphContext *v7;
  uint64_t result;
  OZSpline *v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  CMTimeEpoch v13;

  if (!a2)
    return 0;
  v7 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v9 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v7);
    result = OZSpline::isValidHandle(v9, a2);
    if ((_DWORD)result)
    {
      v10 = MEMORY[0x1E0CA2E68];
      v12 = *MEMORY[0x1E0CA2E68];
      v13 = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
      v11 = PVInstructionGraphContext::HGNodeCache(v7);
      result = (*(uint64_t (**)(uint64_t, char *, __int128 *, double *, uint64_t))(*(_QWORD *)v11 + 264))(v11, a2, &v12, a4, v10);
      if (a3)
      {
        *(_OWORD *)&a3->value = v12;
        a3->epoch = v13;
      }
    }
  }
  return result;
}

char *OZCurve::delKeypoint(OZCurve *this, char *a2, int a3)
{
  char *v3;
  PVInstructionGraphContext *v6;
  OZSpline *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  double v16;

  v3 = a2;
  if (a2)
  {
    v6 = (PVInstructionGraphContext *)((char *)this + 40);
    if (PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
      && *((_BYTE *)this + 138)
      && (OZCurve::isAnimated(this) || a3)
      && (v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v6), OZSpline::isValidHandle(v7, v3)))
    {
      v16 = 0.0;
      v8 = PVInstructionGraphContext::HGNodeCache(v6);
      v9 = MEMORY[0x1E0CA2E68];
      v10 = (*(uint64_t (**)(uint64_t, char *, _QWORD, double *, _QWORD))(*(_QWORD *)v8 + 264))(v8, v3, 0, &v16, MEMORY[0x1E0CA2E68]);
      v11 = PVInstructionGraphContext::HGNodeCache(v6);
      v3 = (char *)(*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)v11 + 32))(v11, v3, 1, v9);
      v12 = PVInstructionGraphContext::HGNodeCache(v6);
      if (((*(_QWORD *)(v12 + 24) - *(_QWORD *)(v12 + 16)) & 0x7FFFFFFF8) != 0)
      {
        if (**((_BYTE **)this + 20))
        {
          v13 = PVInstructionGraphContext::HGNodeCache(v6);
          OZSpline::reparametrize(v13);
        }
      }
      else
      {
        if (v10)
          (*(void (**)(OZCurve *, double))(*(_QWORD *)this + 216))(this, v16);
        v15 = *((_QWORD *)this + 8);
        if (v15)
          (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
        *((_QWORD *)this + 8) = 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t OZCurve::delKeypoints(OZCurve *this, const CMTime *a2, const CMTime *a3, int a4)
{
  PVInstructionGraphContext *v8;
  uint64_t v9;
  OZSpline *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
    || !*((_BYTE *)this + 138)
    || !OZCurve::isAnimated(this) && !a4)
  {
    return 0;
  }
  v11 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  v9 = OZSpline::deleteVertices(v11, a2, a3);
  v12 = PVInstructionGraphContext::HGNodeCache(v8);
  if (((*(_QWORD *)(v12 + 24) - *(_QWORD *)(v12 + 16)) & 0x7FFFFFFF8) != 0)
  {
    if (**((_BYTE **)this + 20))
    {
      v13 = PVInstructionGraphContext::HGNodeCache(v8);
      OZSpline::reparametrize(v13);
    }
  }
  else
  {
    v14 = *((_QWORD *)this + 8);
    if (v14)
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
    *((_QWORD *)this + 8) = 0;
  }
  return v9;
}

uint64_t OZCurve::delAllKeypoints(OZCurve *this, const CMTime *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (*((_BYTE *)this + 138)
    && (OZCurve::isAnimated(this) || a3)
    && PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
  {
    v6 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
    if (((*(_QWORD *)(v6 + 24) - *(_QWORD *)(v6 + 16)) & 0x7FFFFFFF8) != 0)
    {
      v7 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
      (*(void (**)(uint64_t, const CMTime *, _QWORD, _QWORD))(*(_QWORD *)v7 + 240))(v7, a2, MEMORY[0x1E0CA2E68], 0);
      (*(void (**)(OZCurve *))(*(_QWORD *)this + 216))(this);
    }
    v8 = *((_QWORD *)this + 8);
    if (v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
    *((_QWORD *)this + 8) = 0;
  }
  return 0;
}

uint64_t OZCurve::getKeypointFlags(OZCurve *this, char *a2, unsigned int *a3)
{
  PVInstructionGraphContext *v5;
  OZSpline *v6;
  OZSpline *v7;

  if (!a2)
    return 0;
  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    return 0;
  v6 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
  if (!OZSpline::isValidHandle(v6, a2))
    return 0;
  v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
  return OZSpline::getVertexFlags(v7, a2, a3);
}

BOOL OZCurve::setKeypointFlags(OZCurve *this, char *a2, uint64_t a3, int a4)
{
  PVInstructionGraphContext *v8;
  OZSpline *v9;
  OZSpline *v10;

  if (!a2)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
    || !*((_DWORD *)this + 42)
    || !*((_BYTE *)this + 138)
    || !OZCurve::isAnimated(this) && !a4)
  {
    return 0;
  }
  v9 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  if (!OZSpline::isValidHandle(v9, a2))
    return 0;
  v10 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  return OZSpline::setVertexFlags(v10, a2, a3);
}

uint64_t OZCurve::getKeypointNormal(OZCurve *this, char *a2, double *a3)
{
  PVInstructionGraphContext *v5;
  OZSpline *v6;
  uint64_t v7;

  if (!a2)
    return 0;
  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    return 0;
  v6 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
  if (!OZSpline::isValidHandle(v6, a2))
    return 0;
  v7 = PVInstructionGraphContext::HGNodeCache(v5);
  return (*(uint64_t (**)(uint64_t, char *, double *, _QWORD))(*(_QWORD *)v7 + 168))(v7, a2, a3, MEMORY[0x1E0CA2E68]);
}

uint64_t OZCurve::setKeypointNormal(OZCurve *this, char *a2, double a3, int a4)
{
  PVInstructionGraphContext *v8;
  OZSpline *v9;
  uint64_t v10;

  if (!a2)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
    || !*((_DWORD *)this + 42)
    || !*((_BYTE *)this + 138)
    || !OZCurve::isAnimated(this) && !a4)
  {
    return 0;
  }
  v9 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  if (!OZSpline::isValidHandle(v9, a2))
    return 0;
  v10 = PVInstructionGraphContext::HGNodeCache(v8);
  return (*(uint64_t (**)(uint64_t, char *, _QWORD, double))(*(_QWORD *)v10 + 160))(v10, a2, MEMORY[0x1E0CA2E68], a3);
}

uint64_t OZCurve::getKeypointNormal(OZCurve *this, const CMTime *a2, double *a3)
{
  PVInstructionGraphContext *v5;
  uint64_t result;
  uint64_t v7;

  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v7 = PVInstructionGraphContext::HGNodeCache(v5);
    return (*(uint64_t (**)(uint64_t, const CMTime *, double *, _QWORD))(*(_QWORD *)v7 + 184))(v7, a2, a3, MEMORY[0x1E0CA2E68]);
  }
  return result;
}

uint64_t OZCurve::setKeypointNormal(OZCurve *this, const CMTime *a2, double a3, int a4)
{
  PVInstructionGraphContext *v8;
  uint64_t v9;

  if (!*((_DWORD *)this + 42) || !*((_BYTE *)this + 138) || !OZCurve::isAnimated(this) && !a4)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache(v8))
    return 0;
  v9 = PVInstructionGraphContext::HGNodeCache(v8);
  return (*(uint64_t (**)(uint64_t, const CMTime *, _QWORD, double))(*(_QWORD *)v9 + 176))(v9, a2, MEMORY[0x1E0CA2E68], a3);
}

uint64_t OZCurve::enableKeypoint(OZCurve *this, char *a2, int a3, int a4)
{
  PVInstructionGraphContext *v8;
  OZSpline *v9;
  _QWORD *v10;
  uint64_t v11;

  if (!a2)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
    || !*((_BYTE *)this + 138)
    || !OZCurve::isAnimated(this) && !a4)
  {
    return 0;
  }
  v9 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  if (!OZSpline::isValidHandle(v9, a2))
    return 0;
  v10 = (_QWORD *)PVInstructionGraphContext::HGNodeCache(v8);
  v11 = 96;
  if (a3)
    v11 = 88;
  return (*(uint64_t (**)(_QWORD *, char *, _QWORD))(*v10 + v11))(v10, a2, MEMORY[0x1E0CA2E68]);
}

uint64_t OZCurve::isEnabledKeypoint(OZCurve *this, char *a2, BOOL *a3)
{
  PVInstructionGraphContext *v5;
  uint64_t result;
  OZSpline *v7;
  uint64_t v8;

  if (!a2)
    return 0;
  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
    result = OZSpline::isValidHandle(v7, a2);
    if ((_DWORD)result)
    {
      v8 = PVInstructionGraphContext::HGNodeCache(v5);
      *a3 = (*(uint64_t (**)(uint64_t, char *, _QWORD))(*(_QWORD *)v8 + 104))(v8, a2, MEMORY[0x1E0CA2E68]);
      return 1;
    }
  }
  return result;
}

BOOL OZCurve::selectKeypoint(OZCurve *this, char *a2, int a3, int a4)
{
  PVInstructionGraphContext *v8;
  OZSpline *v9;
  OZSpline *v10;

  if (!a2)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
    || !*((_DWORD *)this + 42)
    || !*((_BYTE *)this + 138)
    || !OZCurve::isAnimated(this) && !a4)
  {
    return 0;
  }
  v9 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  if (!OZSpline::isValidHandle(v9, a2))
    return 0;
  v10 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  if (a3)
    return OZSpline::setVertexFlag(v10, a2, 16);
  else
    return OZSpline::resetVertexFlag(v10, a2, 16);
}

BOOL OZCurve::lockKeypoint(OZCurve *this, char *a2, int a3, int a4)
{
  PVInstructionGraphContext *v8;
  OZSpline *v9;
  OZSpline *v10;

  if (!a2)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
    || !*((_BYTE *)this + 138)
    || !OZCurve::isAnimated(this) && !a4)
  {
    return 0;
  }
  v9 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  if (!OZSpline::isValidHandle(v9, a2))
    return 0;
  v10 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  if (a3)
    return OZSpline::setVertexFlag(v10, a2, 2);
  else
    return OZSpline::resetVertexFlag(v10, a2, 2);
}

uint64_t OZCurve::isLockedKeypoint(OZCurve *this, char *a2, BOOL *a3)
{
  PVInstructionGraphContext *v5;
  uint64_t result;
  OZSpline *v7;
  OZSpline *v8;
  int v9;
  unsigned int v10;

  v10 = 0;
  if (!a2)
    return 0;
  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
    result = OZSpline::isValidHandle(v7, a2);
    if ((_DWORD)result)
    {
      v8 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
      result = OZSpline::getVertexFlags(v8, a2, &v10);
      v9 = (v10 >> 1) & 1;
    }
    else
    {
      LOBYTE(v9) = 0;
    }
    *a3 = v9;
  }
  return result;
}

BOOL OZCurve::weightHandles(OZCurve *this, char *a2, int a3, int a4)
{
  PVInstructionGraphContext *v8;
  OZSpline *v9;
  OZSpline *v10;

  if (!a2)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
    || !*((_BYTE *)this + 138)
    || !OZCurve::isAnimated(this) && !a4)
  {
    return 0;
  }
  v9 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  if (!OZSpline::isValidHandle(v9, a2))
    return 0;
  v10 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  if (a3)
    return OZSpline::setVertexFlag(v10, a2, 8);
  else
    return OZSpline::resetVertexFlag(v10, a2, 8);
}

uint64_t OZCurve::areHandlesWeighted(OZCurve *this, char *a2, BOOL *a3)
{
  PVInstructionGraphContext *v5;
  uint64_t result;
  OZSpline *v7;
  OZSpline *v8;
  int v9;
  unsigned int v10;

  v10 = 0;
  if (!a2)
    return 0;
  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
    result = OZSpline::isValidHandle(v7, a2);
    if ((_DWORD)result)
    {
      v8 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
      result = OZSpline::getVertexFlags(v8, a2, &v10);
      v9 = (v10 >> 3) & 1;
    }
    else
    {
      LOBYTE(v9) = 0;
    }
    *a3 = v9;
  }
  return result;
}

BOOL OZCurve::breakKeypointHandles(OZCurve *this, char *a2, int a3, int a4)
{
  PVInstructionGraphContext *v8;
  OZSpline *v9;
  OZSpline *v10;

  if (!a2)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
    || !*((_BYTE *)this + 138)
    || !OZCurve::isAnimated(this) && !a4)
  {
    return 0;
  }
  v9 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  if (!OZSpline::isValidHandle(v9, a2))
    return 0;
  v10 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  if (a3)
    return OZSpline::setVertexFlag(v10, a2, 1);
  else
    return OZSpline::resetVertexFlag(v10, a2, 1);
}

uint64_t OZCurve::areHandlesBroken(OZCurve *this, char *a2, BOOL *a3)
{
  PVInstructionGraphContext *v5;
  uint64_t result;
  OZSpline *v7;
  OZSpline *v8;
  BOOL v9;
  unsigned int v10;

  v10 = 0;
  if (!a2)
    return 0;
  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
    result = OZSpline::isValidHandle(v7, a2);
    if ((_DWORD)result)
    {
      v8 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
      result = OZSpline::getVertexFlags(v8, a2, &v10);
      v9 = v10 & 1;
    }
    else
    {
      v9 = 0;
    }
    *a3 = v9;
  }
  return result;
}

uint64_t OZCurve::flattenHandles(OZCurve *this, char *a2, int a3)
{
  PVInstructionGraphContext *v6;
  OZSpline *v7;
  uint64_t v8;

  if (!a2)
    return 0;
  v6 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
    || !*((_BYTE *)this + 138)
    || !OZCurve::isAnimated(this) && !a3)
  {
    return 0;
  }
  v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v6);
  if (!OZSpline::isValidHandle(v7, a2))
    return 0;
  v8 = PVInstructionGraphContext::HGNodeCache(v6);
  return (*(uint64_t (**)(uint64_t, char *, _QWORD))(*(_QWORD *)v8 + 144))(v8, a2, MEMORY[0x1E0CA2E68]);
}

uint64_t OZCurve::setKeypointInputNormalizedTangents(OZCurve *this, char *a2, double a3, double a4, int a5)
{
  PVInstructionGraphContext *v10;
  OZSpline *v11;
  uint64_t v12;

  if (!a2)
    return 0;
  v10 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
    || !*((_BYTE *)this + 138)
    || !OZCurve::isAnimated(this) && !a5)
  {
    return 0;
  }
  v11 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v10);
  if (!OZSpline::isValidHandle(v11, a2))
    return 0;
  v12 = PVInstructionGraphContext::HGNodeCache(v10);
  return (*(uint64_t (**)(uint64_t, char *, _QWORD, _QWORD, double, double))(*(_QWORD *)v12 + 112))(v12, a2, MEMORY[0x1E0CA2E68], 0, a3, a4);
}

uint64_t OZCurve::setKeypointOutputNormalizedTangents(OZCurve *this, char *a2, double a3, double a4, int a5)
{
  PVInstructionGraphContext *v10;
  OZSpline *v11;
  uint64_t v12;

  if (!a2)
    return 0;
  v10 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
    || !*((_BYTE *)this + 138)
    || !OZCurve::isAnimated(this) && !a5)
  {
    return 0;
  }
  v11 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v10);
  if (!OZSpline::isValidHandle(v11, a2))
    return 0;
  v12 = PVInstructionGraphContext::HGNodeCache(v10);
  return (*(uint64_t (**)(uint64_t, char *, _QWORD, _QWORD, double, double))(*(_QWORD *)v12 + 120))(v12, a2, MEMORY[0x1E0CA2E68], 0, a3, a4);
}

uint64_t OZCurve::setKeypointInputHandles(OZCurve *this, char *a2, double a3, double a4, int a5)
{
  PVInstructionGraphContext *v10;
  int v11;
  OZSpline *v12;
  double v13;
  double v14;
  double v15;
  uint64_t v16;

  if (!a2)
    return 0;
  v10 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
    || !*((_BYTE *)this + 138)
    || !OZCurve::isAnimated(this) && !a5)
  {
    return 0;
  }
  v11 = **((unsigned __int8 **)this + 20);
  v12 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v10);
  if (!OZSpline::isValidHandle(v12, a2))
    return 0;
  v13 = 1.0;
  if (!v11)
    v13 = 12.0;
  v14 = a4 / v13;
  v15 = a3 / v13;
  v16 = PVInstructionGraphContext::HGNodeCache(v10);
  return (*(uint64_t (**)(uint64_t, char *, _QWORD, _QWORD, double, double))(*(_QWORD *)v16 + 112))(v16, a2, MEMORY[0x1E0CA2E68], 0, v15, v14);
}

uint64_t OZCurve::setKeypointOutputHandles(OZCurve *this, char *a2, double a3, double a4, int a5)
{
  PVInstructionGraphContext *v10;
  int v11;
  OZSpline *v12;
  double v13;
  double v14;
  double v15;
  uint64_t v16;

  if (!a2)
    return 0;
  v10 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40))
    || !*((_BYTE *)this + 138)
    || !OZCurve::isAnimated(this) && !a5)
  {
    return 0;
  }
  v11 = **((unsigned __int8 **)this + 20);
  v12 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v10);
  if (!OZSpline::isValidHandle(v12, a2))
    return 0;
  v13 = 1.0;
  if (!v11)
    v13 = 12.0;
  v14 = a4 / v13;
  v15 = a3 / v13;
  v16 = PVInstructionGraphContext::HGNodeCache(v10);
  return (*(uint64_t (**)(uint64_t, char *, _QWORD, _QWORD, double, double))(*(_QWORD *)v16 + 120))(v16, a2, MEMORY[0x1E0CA2E68], 0, v15, v14);
}

uint64_t OZCurve::getKeypointInputNormalizedTangents(OZCurve *this, char *a2, double *a3, double *a4)
{
  PVInstructionGraphContext *v7;
  OZSpline *v8;
  uint64_t v9;

  if (!a2)
    return 0;
  v7 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    return 0;
  v8 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v7);
  if (!OZSpline::isValidHandle(v8, a2))
    return 0;
  v9 = PVInstructionGraphContext::HGNodeCache(v7);
  return (*(uint64_t (**)(uint64_t, char *, double *, double *, _QWORD, _QWORD))(*(_QWORD *)v9 + 128))(v9, a2, a3, a4, MEMORY[0x1E0CA2E68], 0);
}

uint64_t OZCurve::getKeypointOutputNormalizedTangents(OZCurve *this, char *a2, double *a3, double *a4)
{
  PVInstructionGraphContext *v7;
  OZSpline *v8;
  uint64_t v9;

  if (!a2)
    return 0;
  v7 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    return 0;
  v8 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v7);
  if (!OZSpline::isValidHandle(v8, a2))
    return 0;
  v9 = PVInstructionGraphContext::HGNodeCache(v7);
  return (*(uint64_t (**)(uint64_t, char *, double *, double *, _QWORD, _QWORD))(*(_QWORD *)v9 + 136))(v9, a2, a3, a4, MEMORY[0x1E0CA2E68], 0);
}

uint64_t OZCurve::getKeypointInputHandles(OZCurve *this, char *a2, double *a3, double *a4)
{
  PVInstructionGraphContext *v8;
  uint64_t result;
  OZSpline *v10;
  uint64_t v11;
  double v12;

  if (!a2)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v10 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
    result = OZSpline::isValidHandle(v10, a2);
    if ((_DWORD)result)
    {
      v11 = PVInstructionGraphContext::HGNodeCache(v8);
      result = (*(uint64_t (**)(uint64_t, char *, double *, double *, _QWORD, _QWORD))(*(_QWORD *)v11 + 128))(v11, a2, a3, a4, MEMORY[0x1E0CA2E68], 0);
    }
    v12 = 1.0;
    if (!**((_BYTE **)this + 20))
      v12 = 12.0;
    if (a3)
      *a3 = v12 * *a3;
    if (a4)
      *a4 = v12 * *a4;
  }
  return result;
}

uint64_t OZCurve::getKeypointOutputHandles(OZCurve *this, char *a2, double *a3, double *a4)
{
  PVInstructionGraphContext *v8;
  uint64_t result;
  OZSpline *v10;
  uint64_t v11;
  double v12;

  if (!a2)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v10 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
    result = OZSpline::isValidHandle(v10, a2);
    if ((_DWORD)result)
    {
      v11 = PVInstructionGraphContext::HGNodeCache(v8);
      result = (*(uint64_t (**)(uint64_t, char *, double *, double *, _QWORD, _QWORD))(*(_QWORD *)v11 + 136))(v11, a2, a3, a4, MEMORY[0x1E0CA2E68], 0);
    }
    v12 = 1.0;
    if (!**((_BYTE **)this + 20))
      v12 = 12.0;
    if (a3)
      *a3 = v12 * *a3;
    if (a4)
      *a4 = v12 * *a4;
  }
  return result;
}

BOOL OZCurve::getPointInputTangents(OZCurve *this, const CMTime *a2, double *a3, double *a4, int a5)
{
  PVInstructionGraphContext *v9;
  uint64_t v10;
  uint64_t v11;
  double v12;

  v9 = (PVInstructionGraphContext *)((char *)this + 40);
  v10 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (v10)
  {
    v11 = PVInstructionGraphContext::HGNodeCache(v9);
    (*(void (**)(uint64_t, const CMTime *, double *, double *, _QWORD))(*(_QWORD *)v11 + 224))(v11, a2, a3, a4, MEMORY[0x1E0CA2E68]);
    v12 = 1.0;
    if (a5)
      v12 = 12.0;
    if (a3)
      *a3 = v12 * *a3;
    if (a4)
      *a4 = v12 * *a4;
  }
  return v10 != 0;
}

BOOL OZCurve::getPointOutputTangents(OZCurve *this, const CMTime *a2, double *a3, double *a4, int a5)
{
  PVInstructionGraphContext *v9;
  uint64_t v10;
  uint64_t v11;
  double v12;

  v9 = (PVInstructionGraphContext *)((char *)this + 40);
  v10 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (v10)
  {
    v11 = PVInstructionGraphContext::HGNodeCache(v9);
    (*(void (**)(uint64_t, const CMTime *, double *, double *, _QWORD))(*(_QWORD *)v11 + 232))(v11, a2, a3, a4, MEMORY[0x1E0CA2E68]);
    v12 = 1.0;
    if (a5)
      v12 = 12.0;
    if (a3)
      *a3 = v12 * *a3;
    if (a4)
      *a4 = v12 * *a4;
  }
  return v10 != 0;
}

uint64_t OZCurve::deriveKeypoint(OZCurve *this, char *a2)
{
  PVInstructionGraphContext *v3;
  uint64_t result;
  OZSpline *v5;
  uint64_t v6;
  OZSpline *v7;

  if (!a2)
    return 0;
  v3 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v5 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v3);
    result = OZSpline::isValidHandle(v5, a2);
    if ((_DWORD)result)
    {
      v6 = PVInstructionGraphContext::HGNodeCache(v3);
      (*(void (**)(uint64_t, char *, _QWORD))(*(_QWORD *)v6 + 216))(v6, a2, MEMORY[0x1E0CA2E68]);
      v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v3);
      OZSpline::resetVertexFlag(v7, a2, 128);
      return 1;
    }
  }
  return result;
}

BOOL OZCurve::setKeypointInterpolation(OZCurve *this, char *a2, uint64_t a3, int a4)
{
  PVInstructionGraphContext *v8;
  OZSpline *v9;
  OZSpline *v10;

  if (!a2 || !*((_BYTE *)this + 138) || !OZCurve::isAnimated(this) && !a4)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache(v8))
    return 0;
  v9 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  if (!OZSpline::isValidHandle(v9, a2))
    return 0;
  v10 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  return OZSpline::setVertexInterpolation(v10, a2, a3);
}

BOOL OZCurve::setCurveInterpolation(OZCurve *this, uint64_t a2)
{
  int v2;
  uint64_t LocalSplineState;
  PVInstructionGraphContext *v6;
  OZSpline *v7;

  v2 = *((unsigned __int8 *)this + 138);
  if (*((_BYTE *)this + 138))
  {
    OZCurve::isAnimated(this);
    if (*(_DWORD *)(*((_QWORD *)this + 20) + 32) != (_DWORD)a2)
    {
      LocalSplineState = OZCurve::createLocalSplineState(this);
      *((_QWORD *)this + 20) = LocalSplineState;
      *(_DWORD *)(LocalSplineState + 32) = a2;
      v6 = (PVInstructionGraphContext *)((char *)this + 40);
      if (PVInstructionGraphContext::HGNodeCache(v6))
      {
        v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v6);
        OZSpline::setInterpolation(v7, a2);
      }
    }
  }
  return v2 != 0;
}

uint64_t OZCurve::setKeypointSpeed(OZCurve *this, char *a2, int a3, int a4)
{
  PVInstructionGraphContext *v8;
  OZSpline *v9;
  OZSpline *v10;

  if (!a2 || !*((_BYTE *)this + 138) || !OZCurve::isAnimated(this) && !a4)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache(v8))
    return 0;
  v9 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  if (!OZSpline::isValidHandle(v9, a2))
    return 0;
  v10 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  return OZSpline::setVertexSpeed(v10, a2, a3);
}

uint64_t OZCurve::getKeypointSpeed(OZCurve *this, char *a2, unsigned int *a3)
{
  PVInstructionGraphContext *v5;
  OZSpline *v6;
  OZSpline *v7;

  if (!a2)
    return 0;
  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    return 0;
  v6 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
  if (!OZSpline::isValidHandle(v6, a2))
    return 0;
  v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
  return OZSpline::getVertexSpeed(v7, a2, a3);
}

uint64_t OZCurve::adjustKeypointSpeed(OZCurve *this, char *a2, double a3, int a4)
{
  PVInstructionGraphContext *v8;
  OZSpline *v9;
  void ***v10;

  if (!a2 || !*((_BYTE *)this + 138) || !OZCurve::isAnimated(this) && !a4)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache(v8))
    return 0;
  v9 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  if (!OZSpline::isValidHandle(v9, a2))
    return 0;
  v10 = (void ***)PVInstructionGraphContext::HGNodeCache(v8);
  return OZSpline::adjustVertexSpeed(v10, a2, a3);
}

uint64_t OZCurve::setCurveParametric(OZCurve *this, int a2)
{
  char v2;
  _BYTE *LocalSplineState;

  if ((**((_BYTE **)this + 20) != 0) != a2)
  {
    v2 = a2;
    LocalSplineState = (_BYTE *)OZCurve::createLocalSplineState(this);
    *((_QWORD *)this + 20) = LocalSplineState;
    *LocalSplineState = v2;
  }
  return 1;
}

uint64_t OZCurve::isCurveParametric(OZCurve *this, BOOL *a2)
{
  *a2 = **((_BYTE **)this + 20);
  return 1;
}

uint64_t OZCurve::getCurveInterpolation(OZCurve *this, unsigned int *a2)
{
  PVInstructionGraphContext *v4;
  uint64_t v5;

  v4 = (PVInstructionGraphContext *)((char *)this + 40);
  if (PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
  {
    v5 = PVInstructionGraphContext::HGNodeCache(v4);
    (*(void (**)(uint64_t, unsigned int *, _QWORD, _QWORD))(*(_QWORD *)v5 + 16))(v5, a2, 0, 0);
    return 1;
  }
  if (a2)
  {
    *a2 = *(_DWORD *)(*((_QWORD *)this + 20) + 32);
    return 1;
  }
  return 0;
}

BOOL OZCurve::closeCurve(OZCurve *this)
{
  PVInstructionGraphContext *v1;
  uint64_t v2;
  OZSpline *v3;

  v1 = (PVInstructionGraphContext *)((char *)this + 40);
  v2 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (v2)
  {
    v3 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v1);
    OZSpline::setClosed(v3, 1, 0);
  }
  return v2 != 0;
}

BOOL OZCurve::isClosedCurve(OZCurve *this, BOOL *a2)
{
  PVInstructionGraphContext *v3;
  uint64_t v4;

  v3 = (PVInstructionGraphContext *)((char *)this + 40);
  v4 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (v4)
    *a2 = *(_BYTE *)(PVInstructionGraphContext::HGNodeCache(v3) + 144);
  return v4 != 0;
}

BOOL OZCurve::getKeypointInterpolation(OZCurve *this, char *a2, unsigned int *a3, BOOL *a4)
{
  PVInstructionGraphContext *v7;
  OZSpline *v8;
  OZInterpolators **v9;

  if (!a2)
    return 0;
  v7 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    return 0;
  v8 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v7);
  if (!OZSpline::isValidHandle(v8, a2))
    return 0;
  v9 = (OZInterpolators **)PVInstructionGraphContext::HGNodeCache(v7);
  return OZSpline::getVertexInterpolation(v9, a2, a3, a4);
}

uint64_t OZCurve::generateKeypoints(OZCurve *this, int a2, unsigned int a3, int a4)
{
  PVInstructionGraphContext *v8;
  OZSpline *v9;

  if (!*((_BYTE *)this + 138) || !OZCurve::isAnimated(this) && !a4)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache(v8))
    return 0;
  v9 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  return OZSpline::generateExtrapolatedVertices(v9, a2, a3, MEMORY[0x1E0CA2E68]);
}

uint64_t OZCurve::warpCurveLinear(OZCurve *this, Float64 a2, const CMTime *a3, int a4)
{
  uint64_t result;
  uint64_t v9;

  if (!*((_BYTE *)this + 138) || !OZCurve::isAnimated(this) && !a4)
    return 0;
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v9 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
    OZSpline::warpSplineLinear(v9, a2, a3, MEMORY[0x1E0CA2E68]);
    return 1;
  }
  return result;
}

uint64_t OZCurve::forceRetimeCurve(OZCurve *this, const CMTime *a2, const CMTime *a3)
{
  PVInstructionGraphContext *v5;
  uint64_t result;
  OZSpline *v7;

  if (!*((_BYTE *)this + 138))
    return 0;
  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
    OZSpline::forceWarpSplineLinear(v7, a2, a3);
    return 1;
  }
  return result;
}

uint64_t OZCurve::reverseKeypoints(OZCurve *this, _BYTE **a2, _BYTE **a3, int a4)
{
  uint64_t result;
  OZSpline *v9;

  if (!*((_BYTE *)this + 138) || !OZCurve::isAnimated(this) && !a4)
    return 0;
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v9 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
    OZSpline::reverseVertices(v9, a2, a3);
    return 1;
  }
  return result;
}

BOOL OZCurve::purgeCurve(OZCurve *this)
{
  PVInstructionGraphContext *v1;
  uint64_t v2;
  OZSpline *v3;

  v1 = (PVInstructionGraphContext *)((char *)this + 40);
  v2 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (v2)
  {
    v3 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v1);
    OZSpline::purge(v3);
  }
  return v2 != 0;
}

uint64_t OZCurve::setKeypointSmooth(OZCurve *this, char *a2, uint64_t a3, int a4)
{
  PVInstructionGraphContext *v8;
  OZSpline *v9;
  uint64_t v10;

  if (!*((_BYTE *)this + 138) || !OZCurve::isAnimated(this) && !a4)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache(v8))
    return 0;
  v9 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
  if (!OZSpline::isValidHandle(v9, a2))
    return 0;
  v10 = PVInstructionGraphContext::HGNodeCache(v8);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t, _QWORD))(*(_QWORD *)v10 + 152))(v10, a2, a3, MEMORY[0x1E0CA2E68]);
}

uint64_t OZCurve::offsetKeypointInTime(OZCurve *this, char *a2, const CMTime *a3, int a4)
{
  PVInstructionGraphContext *v8;
  uint64_t result;
  OZSpline *v10;
  OZSpline *v11;

  if (!a2)
    return 0;
  v8 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    if (*((_BYTE *)this + 138) && (OZCurve::isAnimated(this) || a4))
    {
      v10 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
      result = OZSpline::isValidHandle(v10, a2);
      if ((_DWORD)result)
      {
        v11 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v8);
        OZSpline::offsetVertexInTime(v11, a2, a3, MEMORY[0x1E0CA2E68]);
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t OZCurve::setRoundingInUSpace(OZCurve *this, int a2)
{
  uint64_t LocalSplineState;
  int32_t v5;
  __int128 v6;
  CMTime v8;

  if ((*(_BYTE *)(*((_QWORD *)this + 20) + 1) != 0) != a2)
  {
    LocalSplineState = OZCurve::createLocalSplineState(this);
    *((_QWORD *)this + 20) = LocalSplineState;
    *(_BYTE *)(LocalSplineState + 1) = a2;
    if (a2)
      v5 = 30;
    else
      v5 = 3000000;
    CMTimeMake(&v8, 1, v5);
    v6 = *(_OWORD *)&v8.value;
    *(_QWORD *)(LocalSplineState + 24) = v8.epoch;
    *(_OWORD *)(LocalSplineState + 8) = v6;
  }
  return 1;
}

uint64_t OZCurve::isRoundingInUSpace(OZCurve *this, BOOL *a2)
{
  *a2 = *(_BYTE *)(*((_QWORD *)this + 20) + 1);
  return 1;
}

uint64_t OZCurve::setKeypointBiasLinear(OZCurve *this, char *a2, double a3)
{
  PVInstructionGraphContext *v5;
  OZSpline *v6;
  uint64_t v7;

  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    return 0;
  v6 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
  if (!OZSpline::isValidHandle(v6, a2))
    return 0;
  v7 = PVInstructionGraphContext::HGNodeCache(v5);
  return (*(uint64_t (**)(uint64_t, char *, _QWORD, double))(*(_QWORD *)v7 + 272))(v7, a2, MEMORY[0x1E0CA2E68], a3);
}

uint64_t OZCurve::getKeypointBiasLinear(OZCurve *this, char *a2, double *a3)
{
  PVInstructionGraphContext *v5;
  OZSpline *v6;
  uint64_t v7;

  if (!a3)
    return 0;
  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
    return 0;
  v6 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
  if (!OZSpline::isValidHandle(v6, a2))
    return 0;
  v7 = PVInstructionGraphContext::HGNodeCache(v5);
  return (*(uint64_t (**)(uint64_t, char *, double *, _QWORD))(*(_QWORD *)v7 + 280))(v7, a2, a3, MEMORY[0x1E0CA2E68]);
}

BOOL OZCurve::hasInterpolation(OZCurve *this, int a2, BOOL *a3)
{
  PVInstructionGraphContext *v5;
  uint64_t v6;
  uint64_t v7;
  OZSpline *v8;

  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  v6 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  v7 = v6;
  if (a3 && v6)
  {
    v8 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
    *a3 = OZSpline::hasInterpolation(v8, a2);
  }
  return v7 != 0;
}

uint64_t OZCurve::getPreviousValidKeypointHandle(OZCurve *this, void *a2, void **a3)
{
  PVInstructionGraphContext *v5;
  uint64_t result;
  OZSpline *v7;

  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
    return OZSpline::getPreviousValidVertexWithLock(v7, a2, a3, MEMORY[0x1E0CA2E68]);
  }
  return result;
}

uint64_t OZCurve::getNextValidKeypointHandle(OZCurve *this, void *a2, void **a3)
{
  PVInstructionGraphContext *v5;
  uint64_t result;
  OZSpline *v7;

  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
    return OZSpline::getNextValidVertexWithLock(v7, a2, a3, MEMORY[0x1E0CA2E68]);
  }
  return result;
}

uint64_t OZCurve::getPreviousValidKeypointHandle(OZCurve *this, const CMTime *a2, void **a3)
{
  PVInstructionGraphContext *v5;
  uint64_t result;
  OZSpline *v7;

  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
    return OZSpline::getPreviousValidVertexWithLock(v7, a2, a3, MEMORY[0x1E0CA2E68], 0);
  }
  return result;
}

uint64_t OZCurve::getNextValidKeypointHandle(OZCurve *this, const CMTime *a2, void **a3)
{
  PVInstructionGraphContext *v5;
  uint64_t result;
  OZSpline *v7;

  v5 = (PVInstructionGraphContext *)((char *)this + 40);
  result = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (result)
  {
    v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(v5);
    return OZSpline::getNextValidVertexWithLock(v7, a2, a3, MEMORY[0x1E0CA2E68], 0);
  }
  return result;
}

BOOL OZCurve::reparametrizeCurve(OZCurve *this)
{
  PVInstructionGraphContext *v1;
  uint64_t v2;
  uint64_t v3;

  v1 = (PVInstructionGraphContext *)((char *)this + 40);
  v2 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
  if (v2)
  {
    v3 = PVInstructionGraphContext::HGNodeCache(v1);
    OZSpline::reparametrize(v3);
  }
  return v2 != 0;
}

void OZCurve::loadVertices(OZCurve *this, int a2, int a3)
{
  void **v6;
  OZSpline *v7;

  if (a3)
  {
    if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
      OZSplineNode::createSpline((OZSplineNode *)((char *)this + 40));
    v6 = (void **)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
    if (a2)
      OZSpline::reserveMemoryForKeypoints(v6, a3);
    else
      OZSpline::setDirty((OZSpline *)v6, 1);
  }
  *((_BYTE *)this + 96) = a2;
  v7 = (OZSpline *)*((_QWORD *)this + 8);
  if (v7)
    OZSpline::setDirty(v7, 1);
}

uint64_t OZCurve::generateCurveFromDynamicCurve(OZCurve *this, const CMTime *a2, OZDynamicCurve *a3)
{
  OZSplineNode *v6;
  OZSpline *v7;

  v6 = (OZSplineNode *)((char *)this + 40);
  if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
  {
    if (*(_BYTE *)(*((_QWORD *)this + 20) + 44))
      *((_QWORD *)this + 20) = OZCurve::createLocalSplineState(this);
    OZSplineNode::createSpline(v6);
  }
  v7 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v6);
  OZSpline::generateSplineFromDynamicSpline(v7, a2, (OZDynamicCurve *)((char *)a3 + 8));
  return 1;
}

CMTime *OZCurve::getFrameDuration@<X0>(OZCurve *this@<X0>, CMTime *a2@<X8>)
{
  OZChannelBase *v2;

  v2 = (OZChannelBase *)*((_QWORD *)this + 19);
  if (v2)
    return OZChannelBase::getFrameDuration(v2, a2);
  else
    return CMTimeMake(a2, 1, 30);
}

void OZCurve::beginPlayback(OZCurve *this, const CMTime *a2, int a3, int a4, const CMTime *a5)
{
  OZRecordingNode *v9;

  v9 = (OZRecordingNode *)*((_QWORD *)this + 13);
  if (!v9)
  {
    v9 = (OZRecordingNode *)operator new();
    OZRecordingNode::OZRecordingNode(v9, (OZSplineNode *)((char *)this + 40));
    *((_QWORD *)this + 13) = v9;
  }
  OZRecordingNode::beginPlayback(v9, a2, a3, a4, a5);
}

void sub_1B2C314E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C406D9F4237);
  _Unwind_Resume(a1);
}

void OZCurve::endPlayback(OZCurve *this, const CMTime *a2)
{
  OZRecordingNode::endPlayback(*((OZRecordingNode **)this + 13), a2);
}

uint64_t OZCurve::beginRecording(OZCurve *this, const CMTime *a2)
{
  uint64_t result;

  result = OZRecordingNode::beginRecording(*((OZRecordingNode **)this + 13), a2);
  *((_QWORD *)this + 1) = *((_QWORD *)this + 13);
  *((_DWORD *)this + 42) = 2;
  return result;
}

void OZCurve::endRecording(OZCurve *this, const CMTime *a2)
{
  OZRecordingNode::endRecording(*((OZRecordingNode **)this + 13), a2);
  *((_QWORD *)this + 1) = (char *)this + 40;
  *((_DWORD *)this + 42) = 1;
}

void OZCurve::updateCurrentRecordingTime(OZCurve *this, const CMTime *a2)
{
  OZRecordingNode::updateCurrentTime(*((OZRecordingNode **)this + 13), a2);
}

BOOL OZCurve::isPlaying(OZCurve *this, unsigned int *a2, unsigned int *a3, CMTime *a4)
{
  uint64_t v4;
  int v5;
  __int128 v6;

  v4 = *((_QWORD *)this + 13);
  v5 = *(unsigned __int8 *)(v4 + 16);
  if (*(_BYTE *)(v4 + 16))
  {
    if (a2)
      *a2 = *(_DWORD *)(v4 + 8);
    if (a3)
      *a3 = *(_DWORD *)(v4 + 12);
    if (a4)
    {
      v6 = *(_OWORD *)(v4 + 88);
      a4->epoch = *(_QWORD *)(v4 + 104);
      *(_OWORD *)&a4->value = v6;
    }
  }
  return v5 != 0;
}

BOOL OZCurve::isRecording(OZCurve *this)
{
  return *((_QWORD *)this + 1) == *((_QWORD *)this + 13);
}

uint64_t OZCurve::writeHeader(OZCurve *this, PCSerializerWriteStream *a2)
{
  TXSequenceChannels::pushChannelIntoChannelList(a2, (OZChannelBase *)&OZCurveScope);
  (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 118);
  return PCSerializerWriteStream::popScope((uint64_t)a2);
}

void OZCurve::writeBody(OZCurve *this, PCSerializerWriteStream *a2)
{
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  double v7;
  double v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  __int128 v20;
  uint64_t v21;
  char v22;
  unsigned int v23;
  void *__p;
  _BYTE *v25;
  uint64_t v26;
  double v27;
  uint64_t v28;
  char v29;
  unsigned int v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  __int128 v37;
  uint64_t v38;
  double v39;

  v39 = 0.0;
  v37 = *MEMORY[0x1E0CA2E68];
  v38 = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
  v35 = 0.0;
  v36 = 0.0;
  v33 = 0.0;
  v34 = 0.0;
  v31 = 0.0;
  v32 = 0.0;
  v30 = 0;
  v29 = 0;
  v27 = 0.0;
  v28 = 0;
  __p = 0;
  v25 = 0;
  v26 = 0;
  TXSequenceChannels::pushChannelIntoChannelList(a2, (OZChannelBase *)&OZCurveScope);
  v4 = (*(uint64_t (**)(OZCurve *))(*(_QWORD *)this + 1216))(this);
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 512))(v4);
  (*(void (**)(OZCurve *, uint64_t *))(*(_QWORD *)this + 152))(this, &v28);
  (*(void (**)(PCSerializerWriteStream *, uint64_t, _QWORD))(*(_QWORD *)a2 + 144))(a2, 4, v28);
  (*(void (**)(OZCurve *, double *))(*(_QWORD *)this + 192))(this, &v39);
  if (((*(uint64_t (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 232))(a2) & 1) == 0)
    (*(void (**)(PCSerializerWriteStream *, uint64_t, double))(*(_QWORD *)a2 + 184))(a2, 8, v39);
  if ((_DWORD)v28)
  {
    (*(void (**)(OZCurve *, double *))(*(_QWORD *)this + 208))(this, &v39);
    v6.n128_f64[0] = v39;
  }
  else
  {
    v6.n128_f64[0] = OZConstantNode::solveNode((OZConstantNode *)((char *)this + 16), MEMORY[0x1E0CA2E68], 0.0, 0.0);
    v39 = v6.n128_f64[0];
  }
  (*(void (**)(PCSerializerWriteStream *, uint64_t, __n128))(*(_QWORD *)a2 + 184))(a2, 1, v6);
  (*(void (**)(OZCurve *, char *))(*(_QWORD *)this + 112))(this, &v29);
  if (v29)
    (*(void (**)(PCSerializerWriteStream *, uint64_t, uint64_t))(*(_QWORD *)a2 + 152))(a2, 5, 1);
  (*(void (**)(OZCurve *, char *))(*(_QWORD *)this + 176))(this, &v29);
  if (!v29)
    (*(void (**)(PCSerializerWriteStream *, uint64_t, _QWORD))(*(_QWORD *)a2 + 152))(a2, 6, 0);
  if ((*(unsigned int (**)(OZCurve *))(*(_QWORD *)this + 352))(this))
    (*(void (**)(PCSerializerWriteStream *, uint64_t, uint64_t))(*(_QWORD *)a2 + 152))(a2, 7, 1);
  if ((_DWORD)v5)
  {
    (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 62);
    (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 56))(a2, v5);
    (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
  }
  if (((*(uint64_t (**)(OZCurve *))(*(_QWORD *)this + 1240))(this) & 1) == 0)
  {
    v7 = *((double *)this + 15);
    if (v7 > -1.79769313e308)
    {
      (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 64);
      (*(void (**)(PCSerializerWriteStream *, double))(*(_QWORD *)a2 + 88))(a2, v7);
      (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
    }
    v8 = *((double *)this + 16);
    if (v8 < 1.79769313e308)
    {
      (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 65);
      (*(void (**)(PCSerializerWriteStream *, double))(*(_QWORD *)a2 + 88))(a2, v8);
      (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
    }
  }
  v23 = 0;
  (*(void (**)(OZCurve *, unsigned int *, uint64_t))(*(_QWORD *)this + 336))(this, &v23, 1);
  v9 = v23;
  if (v23)
  {
    (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 52);
    (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 56))(a2, v9);
    (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
  }
  (*(void (**)(OZCurve *, unsigned int *, _QWORD))(*(_QWORD *)this + 336))(this, &v23, 0);
  v10 = v23;
  if (v23)
  {
    (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 51);
    (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 56))(a2, v10);
    (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
  }
  v22 = 0;
  (*(void (**)(OZCurve *, char *))(*(_QWORD *)this + 128))(this, &v22);
  if (v22)
  {
    (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 61);
    (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 48))(a2, 1);
    (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
  }
  if ((_DWORD)v5)
  {
    std::vector<void *>::reserve(&__p, v5);
    (*(void (**)(uint64_t, void **))(*(_QWORD *)v4 + 792))(v4, &__p);
  }
  if (v25 != __p)
  {
    v11 = 0;
    v12 = 1;
    do
    {
      (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 53);
      (*(void (**)(uint64_t, _QWORD, char *, _QWORD))(*(_QWORD *)v4 + 1072))(v4, *((_QWORD *)__p + v11), (char *)&v28 + 4, 0);
      if (HIDWORD(v28) != 4)
        (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 144))(a2, 10);
      (*(void (**)(uint64_t, _QWORD, char *))(*(_QWORD *)v4 + 864))(v4, *((_QWORD *)__p + v11), &v29);
      if (!v29)
        (*(void (**)(PCSerializerWriteStream *, uint64_t, _QWORD))(*(_QWORD *)a2 + 152))(a2, 9, 0);
      (*(void (**)(uint64_t, _QWORD, unsigned int *))(*(_QWORD *)v4 + 840))(v4, *((_QWORD *)__p + v11), &v30);
      (*(void (**)(PCSerializerWriteStream *, uint64_t, _QWORD))(*(_QWORD *)a2 + 144))(a2, 11, v30);
      (*(void (**)(uint64_t, _QWORD, double *))(*(_QWORD *)v4 + 1056))(v4, *((_QWORD *)__p + v11), &v27);
      (*(void (**)(uint64_t, _QWORD, __int128 *, double *))(*(_QWORD *)v4 + 752))(v4, *((_QWORD *)__p + v11), &v37, &v36);
      (*(void (**)(uint64_t, _QWORD, double *))(*(_QWORD *)v4 + 952))(v4, *((_QWORD *)__p + v11), &v31);
      v21 = v38;
      v20 = v37;
      (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 54);
      (*(void (**)(PCSerializerWriteStream *, __int128 *))(*(_QWORD *)a2 + 112))(a2, &v20);
      (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
      v13 = v36;
      (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 55);
      (*(void (**)(PCSerializerWriteStream *, double))(*(_QWORD *)a2 + 88))(a2, v13);
      (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
      v14 = v27;
      if (fabs(v27 + -1.0) >= 0.0000001)
      {
        (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 60);
        (*(void (**)(PCSerializerWriteStream *, double))(*(_QWORD *)a2 + 88))(a2, v14);
        (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
      }
      v15 = v31;
      if (v31 <= -0.0000001 || v31 >= 0.0000001)
      {
        (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 63);
        (*(void (**)(PCSerializerWriteStream *, double))(*(_QWORD *)a2 + 88))(a2, v15);
        (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
      }
      if (*(_BYTE *)(*((_QWORD *)this + 20) + 2) || HIDWORD(v28) == 18)
      {
        (*(void (**)(uint64_t, _QWORD, double *, double *))(*(_QWORD *)v4 + 1000))(v4, *((_QWORD *)__p + v11), &v35, &v34);
        (*(void (**)(uint64_t, _QWORD, double *, double *))(*(_QWORD *)v4 + 1008))(v4, *((_QWORD *)__p + v11), &v33, &v32);
        v16 = v35;
        if (fabs(v35) >= 0.0000001 || fabs(v34) >= 0.0000001)
        {
          (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 56);
          (*(void (**)(PCSerializerWriteStream *, double))(*(_QWORD *)a2 + 88))(a2, v16);
          (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
          v17 = v34;
          (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 57);
          (*(void (**)(PCSerializerWriteStream *, double))(*(_QWORD *)a2 + 88))(a2, v17);
          (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
        }
        v18 = v33;
        if (fabs(v33) >= 0.0000001 || fabs(v32) >= 0.0000001)
        {
          (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 58);
          (*(void (**)(PCSerializerWriteStream *, double))(*(_QWORD *)a2 + 88))(a2, v18);
          (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
          v19 = v32;
          (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(_QWORD *)a2 + 16))(a2, 59);
          (*(void (**)(PCSerializerWriteStream *, double))(*(_QWORD *)a2 + 88))(a2, v19);
          (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
        }
      }
      (*(void (**)(PCSerializerWriteStream *))(*(_QWORD *)a2 + 24))(a2);
      v11 = v12++;
    }
    while (v11 < (v25 - (_BYTE *)__p) >> 3);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  PCSerializerWriteStream::popScope((uint64_t)a2);
  if (__p)
  {
    v25 = __p;
    operator delete(__p);
  }
}

void sub_1B2C31E70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::vector<void *>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_QWORD *)v10 - 1);
        v10 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t OZCurve::parseBegin(OZCurve *this, PCSerializerReadStream *a2)
{
  PCSerializerReadStream::pushScope(a2, (uint64_t)&OZCurveScope);
  return 1;
}

uint64_t OZCurve::parseEnd(OZCurve *this, PCSerializerReadStream *a2)
{
  uint64_t v3;
  uint64_t v4;
  OZSpline *v5;

  v3 = *((_QWORD *)this + 18);
  if (v3)
  {
    (*(void (**)(OZCurve *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)this + 848))(this, *(_QWORD *)v3, *(unsigned int *)(v3 + 12), 1);
    v4 = *((_QWORD *)this + 18);
    if (v4)
      MEMORY[0x1B5E29170](v4, 0x1080C4003FABA15);
    *((_QWORD *)this + 18) = 0;
  }
  *((_BYTE *)this + 96) = 0;
  v5 = (OZSpline *)*((_QWORD *)this + 8);
  if (v5)
    OZSpline::setDirty(v5, 1);
  return 1;
}

uint64_t OZCurve::parseElement(OZCurve *this, PCSerializerReadStream *a2, PCStreamElement *a3)
{
  int v6;
  void (*v7)(OZCurve *);
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  OZSpline *v12;
  OZStaticVertex *appended;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void **v17;
  OZSpline *v18;
  char *v19;
  uint64_t v20;
  CMTimeEpoch epoch;
  CMTime v23;
  CMTime v24;
  Float64 v25;
  unsigned __int8 v26;
  double v27;
  uint64_t v28;

  v27 = 0.0;
  v28 = 0;
  v26 = 0;
  v25 = 0.0;
  v6 = *((_DWORD *)a3 + 2);
  switch(v6)
  {
    case '3':
      PCSerializerReadStream::getAsInt32((uint64_t)a2, (uint64_t)a3, (uint64_t)&v28 + 4);
      (*(void (**)(OZCurve *, _QWORD, _QWORD))(*(_QWORD *)this + 328))(this, HIDWORD(v28), 0);
      break;
    case '4':
      PCSerializerReadStream::getAsInt32((uint64_t)a2, (uint64_t)a3, (uint64_t)&v28 + 4);
      (*(void (**)(OZCurve *, _QWORD, uint64_t))(*(_QWORD *)this + 328))(this, HIDWORD(v28), 1);
      break;
    case '5':
      v8 = *((_QWORD *)this + 18);
      if (v8)
      {
        (*(void (**)(OZCurve *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)this + 848))(this, *(_QWORD *)v8, *(unsigned int *)(v8 + 12), 1);
        v9 = *((_QWORD *)this + 18);
        if (v9)
          MEMORY[0x1B5E29170](v9, 0x1080C4003FABA15);
        *((_QWORD *)this + 18) = 0;
      }
      v10 = operator new();
      *(_QWORD *)v10 = 0;
      v11 = MEMORY[0x1E0CA2E68];
      *(_OWORD *)(v10 + 20) = *MEMORY[0x1E0CA2E68];
      *(_OWORD *)(v10 + 48) = 0u;
      *(_OWORD *)(v10 + 64) = 0u;
      *(_OWORD *)(v10 + 88) = xmmword_1B304F7A0;
      *(_BYTE *)(v10 + 16) = 1;
      *(_QWORD *)(v10 + 36) = *(_QWORD *)(v11 + 16);
      *(_QWORD *)(v10 + 80) = 0;
      *((_QWORD *)this + 18) = v10;
      *(_QWORD *)(v10 + 8) = 4;
      PCSerializerReadStream::getAttributeAsUInt32((uint64_t)a2, (uint64_t)a3, 10, v10 + 8);
      PCSerializerReadStream::getAttributeAsBool((uint64_t)a2, (uint64_t)a3, 9, *((_QWORD *)this + 18) + 16);
      PCSerializerReadStream::getAttributeAsUInt32((uint64_t)a2, (uint64_t)a3, 11, *((_QWORD *)this + 18) + 12);
      *(_DWORD *)(*((_QWORD *)this + 18) + 12) &= ~0x20u;
      break;
    case '6':
      if (*((_DWORD *)a2 + 26) < 5u)
      {
        PCSerializerReadStream::getAsDouble((uint64_t)a2, (uint64_t)a3, (uint64_t)&v25);
        v23 = *(CMTime *)((char *)a2 + 112);
        operator*(&v23, &v24, v25);
      }
      else
      {
        PCSerializerReadStream::getAsFigTime((uint64_t)a2, (uint64_t)a3, (uint64_t)&v24);
      }
      v20 = *((_QWORD *)this + 18);
      epoch = v24.epoch;
      *(_OWORD *)(v20 + 20) = *(_OWORD *)&v24.value;
      *(_QWORD *)(v20 + 36) = epoch;
      break;
    case '7':
      PCSerializerReadStream::getAsDouble((uint64_t)a2, (uint64_t)a3, *((_QWORD *)this + 18) + 80);
      if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
      {
        if (*(_BYTE *)(*((_QWORD *)this + 20) + 44))
          *((_QWORD *)this + 20) = OZCurve::createLocalSplineState(this);
        OZSplineNode::createSpline((OZSplineNode *)((char *)this + 40));
      }
      v12 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
      appended = OZSpline::appendVertexNoTangents(v12, (const CMTime *)(*((_QWORD *)this + 18) + 20), *(double *)(*((_QWORD *)this + 18) + 80), MEMORY[0x1E0CA2E68]);
      v14 = *((_QWORD *)this + 18);
      *(_QWORD *)v14 = appended;
      (*(void (**)(OZCurve *, OZStaticVertex *, _QWORD, uint64_t))(*(_QWORD *)this + 1064))(this, appended, *(unsigned int *)(v14 + 8), 1);
      break;
    case '8':
      PCSerializerReadStream::getAsDouble((uint64_t)a2, (uint64_t)a3, *((_QWORD *)this + 18) + 48);
      if (*((_DWORD *)a2 + 26) <= 4u)
        *(double *)(*((_QWORD *)this + 18) + 48) = *((double *)a2 + 17) * *(double *)(*((_QWORD *)this + 18) + 48);
      break;
    case '9':
      PCSerializerReadStream::getAsDouble((uint64_t)a2, (uint64_t)a3, *((_QWORD *)this + 18) + 56);
      v15 = *((_QWORD *)this + 18);
      if (*(_BYTE *)(*((_QWORD *)this + 20) + 2) || *(_DWORD *)(v15 + 8) == 18)
        (*(void (**)(OZCurve *, _QWORD, uint64_t, double, double))(*(_QWORD *)this + 984))(this, *(_QWORD *)v15, 1, *(double *)(v15 + 48), *(double *)(v15 + 56));
      break;
    case ':':
      PCSerializerReadStream::getAsDouble((uint64_t)a2, (uint64_t)a3, *((_QWORD *)this + 18) + 64);
      if (*((_DWORD *)a2 + 26) <= 4u)
        *(double *)(*((_QWORD *)this + 18) + 64) = *((double *)a2 + 17) * *(double *)(*((_QWORD *)this + 18) + 64);
      break;
    case ';':
      PCSerializerReadStream::getAsDouble((uint64_t)a2, (uint64_t)a3, *((_QWORD *)this + 18) + 72);
      v16 = *((_QWORD *)this + 18);
      if (*(_BYTE *)(*((_QWORD *)this + 20) + 2) || *(_DWORD *)(v16 + 8) == 18)
      {
        (*(void (**)(OZCurve *, _QWORD, uint64_t, double, double))(*(_QWORD *)this + 992))(this, *(_QWORD *)v16, 1, *(double *)(v16 + 64), *(double *)(v16 + 72));
        v16 = *((_QWORD *)this + 18);
      }
      if (!*(_BYTE *)(v16 + 16))
        (*(void (**)(OZCurve *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)this + 856))(this, *(_QWORD *)v16, 0, 1);
      break;
    case '<':
      PCSerializerReadStream::getAsDouble((uint64_t)a2, (uint64_t)a3, *((_QWORD *)this + 18) + 88);
      (*(void (**)(OZCurve *, _QWORD, double))(*(_QWORD *)this + 1048))(this, **((_QWORD **)this + 18), *(double *)(*((_QWORD *)this + 18) + 88));
      break;
    case '=':
      PCSerializerReadStream::getAsInt32((uint64_t)a2, (uint64_t)a3, (uint64_t)&v28 + 4);
      if (HIDWORD(v28))
        (*(void (**)(OZCurve *))(*(_QWORD *)this + 120))(this);
      break;
    case '>':
      PCSerializerReadStream::getAsInt32((uint64_t)a2, (uint64_t)a3, (uint64_t)&v28 + 4);
      (*(void (**)(OZCurve *, _QWORD, uint64_t))(*(_QWORD *)this + 688))(this, MEMORY[0x1E0CA2E68], 1);
      if (!PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40)))
      {
        if (*(_BYTE *)(*((_QWORD *)this + 20) + 44))
          *((_QWORD *)this + 20) = OZCurve::createLocalSplineState(this);
        OZSplineNode::createSpline((OZSplineNode *)((char *)this + 40));
      }
      v17 = (void **)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)((char *)this + 40));
      OZSpline::reserveMemoryForKeypoints(v17, SHIDWORD(v28));
      *((_BYTE *)this + 96) = 1;
      v18 = (OZSpline *)*((_QWORD *)this + 8);
      if (v18)
        OZSpline::setDirty(v18, 1);
      break;
    case '?':
      PCSerializerReadStream::getAsDouble((uint64_t)a2, (uint64_t)a3, *((_QWORD *)this + 18) + 96);
      (*(void (**)(OZCurve *, _QWORD, uint64_t, double))(*(_QWORD *)this + 960))(this, **((_QWORD **)this + 18), 1, *(double *)(*((_QWORD *)this + 18) + 96));
      break;
    case '@':
      v19 = (char *)this + 120;
      goto LABEL_48;
    case 'A':
      v19 = (char *)this + 128;
LABEL_48:
      PCSerializerReadStream::getAsDouble((uint64_t)a2, (uint64_t)a3, (uint64_t)v19);
      break;
    default:
      if (v6 == 118)
      {
        PCSerializerReadStream::getAttributeAsUInt32((uint64_t)a2, (uint64_t)a3, 4, (uint64_t)&v28);
        v7 = *(void (**)(OZCurve *))(*(_QWORD *)this + 160);
        if ((_DWORD)v28)
        {
          v7(this);
          if (PCSerializerReadStream::getAttributeAsDouble((uint64_t)a2, (uint64_t)a3, 1, (uint64_t)&v27))
            (*(void (**)(OZCurve *, double))(*(_QWORD *)this + 216))(this, v27);
          if (PCSerializerReadStream::getAttributeAsDouble((uint64_t)a2, (uint64_t)a3, 8, (uint64_t)&v27))
            (*(void (**)(OZCurve *, double))(*(_QWORD *)this + 200))(this, v27);
        }
        else
        {
          v7(this);
          if (PCSerializerReadStream::getAttributeAsDouble((uint64_t)a2, (uint64_t)a3, 1, (uint64_t)&v27))
            *((double *)this + 3) = v27;
          if (PCSerializerReadStream::getAttributeAsDouble((uint64_t)a2, (uint64_t)a3, 8, (uint64_t)&v27))
            *((double *)this + 4) = v27;
        }
        if (PCSerializerReadStream::getAttributeAsBool((uint64_t)a2, (uint64_t)a3, 5, (uint64_t)&v26))
          (*(void (**)(OZCurve *, _QWORD))(*(_QWORD *)this + 104))(this, v26);
        if (PCSerializerReadStream::getAttributeAsBool((uint64_t)a2, (uint64_t)a3, 6, (uint64_t)&v26))
          (*(void (**)(OZCurve *, _QWORD))(*(_QWORD *)this + 168))(this, v26);
        if (PCSerializerReadStream::getAttributeAsBool((uint64_t)a2, (uint64_t)a3, 7, (uint64_t)&v26))
          (*(void (**)(OZCurve *, _QWORD))(*(_QWORD *)this + 344))(this, v26);
      }
      break;
  }
  return 1;
}

uint64_t OZCurve::getCurveWorkingCopy(OZCurve *this)
{
  return 0;
}

double OZCurveNodeParam::OZCurveNodeParam(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  __int128 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double result;

  *(_DWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_BYTE *)(a1 + 88) = 0;
  v2 = MEMORY[0x1E0CA2E68];
  v3 = *MEMORY[0x1E0CA2E68];
  *(_OWORD *)(a1 + 24) = *MEMORY[0x1E0CA2E68];
  v4 = *(_QWORD *)(v2 + 16);
  *(_QWORD *)(a1 + 40) = v4;
  *(_OWORD *)(a1 + 48) = v3;
  *(_QWORD *)(a1 + 64) = v4;
  *(_DWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_BYTE *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 112) = v4;
  *(_OWORD *)(a1 + 96) = v3;
  *(_QWORD *)(a1 + 136) = v4;
  *(_OWORD *)(a1 + 120) = v3;
  v5 = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 40) = v5;
  v6 = *(_QWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 64) = v6;
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  *(_BYTE *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  v7 = *(_QWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(_QWORD *)(a1 + 112) = v7;
  v8 = *(_QWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 136) = v8;
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a2 + 144);
  *(_BYTE *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
  *(_WORD *)a1 = *(_WORD *)a2;
  result = *(double *)(a2 + 8);
  *(double *)(a1 + 8) = result;
  return result;
}

void OZCurveNodeParam::~OZCurveNodeParam(OZCurveNodeParam *this)
{
  uint64_t v2;
  uint64_t v3;

  if (*((_BYTE *)this + 160))
  {
    v2 = *((_QWORD *)this + 19);
    if (v2)
      MEMORY[0x1B5E2914C](v2, 0x1000C8000313F17);
  }
  if (*((_BYTE *)this + 88))
  {
    v3 = *((_QWORD *)this + 10);
    if (v3)
      MEMORY[0x1B5E2914C](v3, 0x1000C8000313F17);
  }
}

void PCException::PCException(PCException *this, const PCException *a2)
{
  const void *v4;
  std::string *v5;
  __int128 v6;

  *(_QWORD *)this = &off_1E65115B8;
  v4 = (const void *)*((_QWORD *)a2 + 1);
  *((_QWORD *)this + 1) = v4;
  if (v4)
    CFRetain(v4);
  PCString::PCString((PCString *)this + 2, (const PCString *)a2 + 2);
  PCString::PCString((PCString *)this + 3, (const PCString *)a2 + 3);
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  v5 = (std::string *)((char *)this + 40);
  if (*((char *)a2 + 63) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 5), *((_QWORD *)a2 + 6));
  }
  else
  {
    v6 = *(_OWORD *)((char *)a2 + 40);
    *((_QWORD *)this + 7) = *((_QWORD *)a2 + 7);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
}

void sub_1B2C328B4(_Unwind_Exception *a1)
{
  std::exception *v1;
  const void **v2;
  PCString *v3;
  PCString *v4;

  PCString::~PCString(v4);
  PCString::~PCString(v3);
  PCCFRef<__CFArray const*>::~PCCFRef(v2);
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void sub_1B2C329E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  uint64_t v10;

  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  MEMORY[0x1B5E29170](v10, 0x10F1C405E89EA5DLL);
  _Unwind_Resume(a1);
}

void sub_1B2C331FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, PCString a19)
{
  PCString::~PCString(&a19);
  _Unwind_Resume(a1);
}

void sub_1B2C332C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

void OZDynamicCurve::OZDynamicCurve(OZDynamicCurve *this)
{
  OZSplineState *v2;
  CMTime v3;

  *(_QWORD *)this = &off_1E65546C0;
  v2 = (OZDynamicCurve *)((char *)this + 184);
  OZDynamicSpline::OZDynamicSpline((OZDynamicCurve *)((char *)this + 8), (OZDynamicCurve *)((char *)this + 184));
  OZSplineState::OZSplineState(v2);
  *((_BYTE *)this + 185) = 0;
  CMTimeMake(&v3, 1, 3000000);
  *((CMTime *)this + 8) = v3;
  *((_BYTE *)this + 184) = 1;
}

void sub_1B2C33830(_Unwind_Exception *a1)
{
  OZDynamicSpline *v1;

  OZDynamicSpline::~OZDynamicSpline(v1);
  _Unwind_Resume(a1);
}

void OZDynamicCurve::~OZDynamicCurve(OZDynamicCurve *this)
{
  OZDynamicSpline *v2;

  *(_QWORD *)this = &off_1E65546C0;
  v2 = (OZDynamicCurve *)((char *)this + 8);
  OZSpline::deleteAllVertices((OZDynamicCurve *)((char *)this + 8));
  (*(void (**)(OZDynamicCurve *))(*(_QWORD *)this + 56))(this);
  OZDynamicSpline::~OZDynamicSpline(v2);
}

{
  OZDynamicCurve::~OZDynamicCurve(this);
  JUMPOUT(0x1B5E29170);
}

double OZDynamicCurve::operator=(uint64_t a1, os_unfair_lock_s *a2)
{
  uint8x8_t v4;

  OZSpline::operator=((OZSpline *)(a1 + 8), a2 + 2);
  return OZSplineState::operator=(a1 + 184, (uint64_t)&a2[46], v4);
}

BOOL OZDynamicCurve::operator==(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v5;
  const CMTime *v6;

  result = OZSpline::operator==(a1 + 8, a2 + 8);
  if (result)
    return OZSplineState::operator==((unsigned __int8 *)(a1 + 184), (unsigned __int8 *)(a2 + 184), v5, v6);
  return result;
}

uint64_t OZDynamicCurve::setCurveExtrapolation(OZDynamicCurve *this, int a2, int a3)
{
  OZSpline::setExtrapolation((OZDynamicCurve *)((char *)this + 8), a2, a3);
  return 1;
}

uint64_t OZDynamicCurve::getCurveExtrapolation(OZDynamicCurve *this, unsigned int *a2, int a3)
{
  if (a2)
    *a2 = OZSpline::getExtrapolation((OZDynamicCurve *)((char *)this + 8), a3);
  return 1;
}

uint64_t OZDynamicCurve::getCurveSamples(OZDynamicCurve *this, const CMTime *a2, Float64 a3, Float64 a4, unsigned int *a5, double *a6, double *a7)
{
  if (((*((_QWORD *)this + 4) - *((_QWORD *)this + 3)) & 0x7FFFFFFF8) != 0)
    return OZDynamicSpline::sampleSpline((OZDynamicCurve *)((char *)this + 8), a3, a4, a5, a6, a7, a2);
  else
    return 0;
}

uint64_t OZDynamicCurve::getCurveSamples(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, Float64 a6, Float64 a7)
{
  if (((*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24)) & 0x7FFFFFFF8) != 0)
    return OZDynamicSpline::sampleSpline(a1 + 8, a3, a4, a5, a2, a6, a7);
  else
    return 0;
}

uint64_t OZDynamicCurve::closeCurve(OZDynamicCurve *this)
{
  if (!*((_BYTE *)this + 152) && ((*((_QWORD *)this + 4) - *((_QWORD *)this + 3)) & 0x7FFFFFFF8) != 0)
    OZSpline::setClosed((OZDynamicCurve *)((char *)this + 8), 1, 0);
  return 1;
}

uint64_t OZDynamicCurve::openCurve(OZDynamicCurve *this, void *a2)
{
  if (*((_BYTE *)this + 152) && ((*((_QWORD *)this + 4) - *((_QWORD *)this + 3)) & 0x7FFFFFFF8) != 0)
    OZSpline::setClosed((OZDynamicCurve *)((char *)this + 8), 0, a2);
  return 1;
}

uint64_t OZDynamicCurve::isClosedCurve(OZDynamicCurve *this, BOOL *a2)
{
  if (a2)
    *a2 = *((_BYTE *)this + 152);
  return 1;
}

uint64_t OZDynamicCurve::resetCurve(OZDynamicCurve *this)
{
  OZSpline::setClosed((OZDynamicCurve *)((char *)this + 8), 0, 0);
  return 1;
}

uint64_t OZDynamicCurve::getNumberOfKeypoints(OZDynamicCurve *this)
{
  return (*((_QWORD *)this + 4) - *((_QWORD *)this + 3)) >> 3;
}

unint64_t OZDynamicCurve::getNumberOfValidKeypoints(os_unfair_lock_s *this, const CMTime *a2)
{
  _BYTE *v2;
  _BYTE *v3;
  _BYTE *v5;
  _BYTE *v6;
  uint64_t v7;

  v5 = 0;
  v6 = 0;
  v7 = 0;
  OZSpline::getAllValidVerticesHandles(this + 2, (void **)&v5, (uint64_t)a2);
  v2 = v5;
  v3 = v6;
  if (v5)
  {
    v6 = v5;
    operator delete(v5);
  }
  return (unint64_t)(v3 - v2) >> 3;
}

void sub_1B2C33B0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t OZDynamicCurve::getCurrentMaxValueV(OZDynamicCurve *this, const CMTime *a2, double *a3, double *a4)
{
  CMTime v6;
  CMTime v7;

  v7 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  *a3 = OZSpline::getMaxValueV((OZDynamicCurve *)((char *)this + 8), a2, &v7);
  if (a4)
  {
    v6 = v7;
    *a4 = CMTimeGetSeconds(&v6);
  }
  return 1;
}

uint64_t OZDynamicCurve::getCurrentMinValueV(OZDynamicCurve *this, const CMTime *a2, double *a3, double *a4)
{
  CMTime v6;
  CMTime v7;

  v7 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  *a3 = OZSpline::getMinValueV((OZDynamicCurve *)((char *)this + 8), a2, &v7);
  if (a4)
  {
    v6 = v7;
    *a4 = CMTimeGetSeconds(&v6);
  }
  return 1;
}

uint64_t OZDynamicCurve::getCurrentMaxValueU(OZDynamicCurve *this, const CMTime *a2, double *a3)
{
  CMTime v5;
  CMTime v6;

  v6 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  OZSpline::getMaxValueU((OZDynamicCurve *)((char *)this + 8), a2, 1, (uint64_t)&v6);
  if (a3)
  {
    v5 = v6;
    *a3 = CMTimeGetSeconds(&v5);
  }
  return 1;
}

uint64_t OZDynamicCurve::getCurrentMinValueU(OZDynamicCurve *this, const CMTime *a2, double *a3)
{
  CMTime v5;
  CMTime v6;

  v6 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  OZSpline::getMinValueU((OZDynamicCurve *)((char *)this + 8), a2, 1, (uint64_t)&v6);
  if (a3)
  {
    v5 = v6;
    *a3 = CMTimeGetSeconds(&v5);
  }
  return 1;
}

uint64_t OZDynamicCurve::getCurrentRangeU(OZDynamicCurve *this, const CMTime *a2, double *a3)
{
  CMTime time;

  if (a3)
  {
    OZSpline::getRangeU((OZDynamicCurve *)((char *)this + 8), a2, &time);
    *a3 = CMTimeGetSeconds(&time);
  }
  return 1;
}

uint64_t OZDynamicCurve::setKeypoint(OZDynamicCurve *this, char *a2, const CMTime *a3, Float64 a4, double a5)
{
  os_unfair_lock_s *v9;
  uint64_t result;
  CMTime v11;

  v9 = (os_unfair_lock_s *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
  {
    OZFigTimeForChannelSeconds(&v11, a4, 0x40000);
    return OZDynamicSpline::setVertex(v9, (_BYTE **)a2, &v11, a5, a3);
  }
  return result;
}

BOOL OZDynamicCurve::setKeypoint(OZDynamicCurve *this, const CMTime *a2, Float64 a3, CMTimeEpoch **a4)
{
  OZSpline *v7;
  double VertexValue;
  CMTimeEpoch *v9;
  CMTimeEpoch *v10;
  CMTime v12;
  CMTime v13;

  v7 = (OZDynamicCurve *)((char *)this + 8);
  OZFigTimeForChannelSeconds(&v13, a3, 0x40000);
  OZFigTimeForChannelSeconds(&v12, a3, 0x40000);
  VertexValue = OZSpline::getVertexValue(v7, &v12, a2, 0);
  v9 = OZDynamicSpline::addVertex((os_unfair_lock_s *)v7, &v13, VertexValue, a2);
  v10 = v9;
  if (v9)
  {
    if (a4)
      *a4 = v9;
    OZSpline::reparametrize((uint64_t)v7);
  }
  return v10 != 0;
}

BOOL OZDynamicCurve::setKeypoint(OZDynamicCurve *this, const CMTime *a2, Float64 a3, double a4, void **a5)
{
  OZSpline *v10;
  void *DepthBuffer;
  void *appended;
  void *v13;
  CMTime v15;
  CMTime v16;
  CMTime time2;
  CMTime time1;

  v10 = (OZDynamicCurve *)((char *)this + 8);
  v16 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  if (((*((_QWORD *)this + 4) - *((_QWORD *)this + 3)) & 0x7FFFFFFF8) != 0)
  {
    DepthBuffer = (void *)DepthBufferManager::getDepthBuffer((OZDynamicCurve *)((char *)this + 8));
    OZSpline::getVertex(v10, DepthBuffer, &v16, 0, a2);
  }
  else
  {
    v16 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E28];
  }
  OZFigTimeForChannelSeconds(&v15, a3, 0x40000);
  time1 = v15;
  time2 = v16;
  if (CMTimeCompare(&time1, &time2) < 1 || *((_BYTE *)this + 152))
  {
    OZFigTimeForChannelSeconds(&time1, a3, 0x40000);
    appended = OZDynamicSpline::addVertex((os_unfair_lock_s *)v10, &time1, a4, a2);
  }
  else
  {
    OZFigTimeForChannelSeconds(&time1, a3, 0x40000);
    appended = OZDynamicSpline::appendVertex((os_unfair_lock_s *)v10, &time1, a4, a2);
  }
  v13 = appended;
  OZSpline::reparametrize((uint64_t)v10);
  if (a5)
    *a5 = v13;
  return v13 != 0;
}

uint64_t OZDynamicCurve::setKeypointBiasLinear(OZDynamicCurve *this, char *a2, const CMTime *a3, double a4)
{
  OZSpline *v7;
  uint64_t result;

  v7 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
    return OZSpline::setVertexBiasLinear(v7, a2, a4, a3);
  return result;
}

uint64_t OZDynamicCurve::getKeypointBiasLinear(OZDynamicCurve *this, void *a2, const CMTime *a3, double *a4)
{
  OZSpline *v7;

  if (a4
    && (v7 = (OZDynamicCurve *)((char *)this + 8),
        OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), (char *)a2)))
  {
    return OZSpline::getVertexBiasLinear(v7, a2, a4, a3);
  }
  else
  {
    return 0;
  }
}

uint64_t OZDynamicCurve::moveKeypoint(OZDynamicCurve *this, char *a2, const CMTime *a3, Float64 a4)
{
  OZSpline *v7;
  uint64_t result;
  CMTime v9;

  v7 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
  {
    OZFigTimeForChannelSeconds(&v9, a4, 0x40000);
    return OZSpline::moveVertex(v7, a2, &v9, a3, 0, 0, 0) != 0;
  }
  return result;
}

uint64_t OZDynamicCurve::cloneKeypoint(OZDynamicCurve *this, char *a2, const CMTime *a3, Float64 a4)
{
  OZSpline *v7;
  uint64_t result;
  CMTime v9;

  v7 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
  {
    OZFigTimeForChannelSeconds(&v9, a4, 0x40000);
    return OZSpline::moveVertex(v7, a2, &v9, a3, 1, 0, 0) != 0;
  }
  return result;
}

uint64_t OZDynamicCurve::getPoint(OZDynamicCurve *this, const CMTime *a2, Float64 a3, double *a4)
{
  OZSpline *v6;
  CMTime v8;

  if (a4)
  {
    v6 = (OZDynamicCurve *)((char *)this + 8);
    OZFigTimeForChannelSeconds(&v8, a3, 0x40000);
    *a4 = OZSpline::getVertexValue(v6, &v8, a2, 0);
  }
  return 1;
}

BOOL OZDynamicCurve::getKeypointHandle(OZDynamicCurve *this, const CMTime *a2, Float64 a3, void **a4)
{
  OZSpline *v5;
  CMTime v7;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  OZFigTimeForChannelSeconds(&v7, a3, 0x40000);
  return OZSpline::getVertexHandle(v5, &v7, a4, 0);
}

uint64_t OZDynamicCurve::getKeypointHandleList(uint64_t a1, char **a2)
{
  return OZDynamicSpline::getAllVerticesHandles((OZSpline *)(a1 + 8), a2);
}

uint64_t OZDynamicCurve::getKeypointValidHandleList(os_unfair_lock_s *a1, uint64_t a2, void **a3)
{
  return OZSpline::getAllValidVerticesHandles(a1 + 2, a3, a2);
}

uint64_t OZDynamicCurve::getFirstKeypoint(OZDynamicCurve *this, const CMTime *a2, double *a3, double *a4)
{
  OZSpline *v7;
  CMTime v9;
  CMTime v10;
  void *v11;

  v11 = 0;
  v10 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  v7 = (OZDynamicCurve *)((char *)this + 8);
  OZSpline::getFirstValidVertex((OZDynamicCurve *)((char *)this + 8), &v11, MEMORY[0x1E0CA2E68]);
  if (v11)
  {
    OZSpline::getVertex(v7, v11, &v10, a4, a2);
    if (a3)
    {
      v9 = v10;
      *a3 = CMTimeGetSeconds(&v9);
    }
  }
  return 1;
}

BOOL OZDynamicCurve::getLastKeypoint(OZDynamicCurve *this, const CMTime *a2, double *a3, double *a4)
{
  OZSpline *v7;
  void *v8;
  CMTime v10;
  CMTime v11;
  void *v12;

  v11 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  v12 = 0;
  v7 = (OZDynamicCurve *)((char *)this + 8);
  OZSpline::getLastValidVertex((OZDynamicCurve *)((char *)this + 8), &v12, MEMORY[0x1E0CA2E68]);
  v8 = v12;
  if (v12)
  {
    OZSpline::getVertex(v7, v12, &v11, a4, a2);
    if (a3)
    {
      v10 = v11;
      *a3 = CMTimeGetSeconds(&v10);
    }
  }
  return v8 != 0;
}

BOOL OZDynamicCurve::getKeypoint(OZDynamicCurve *this, char *a2, const CMTime *a3, double *a4, double *a5)
{
  OZSpline *v9;
  _BOOL8 Vertex;
  CMTime v12;
  CMTime v13;

  v9 = (OZDynamicCurve *)((char *)this + 8);
  v13 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  if (!OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2))
    return 0;
  Vertex = OZSpline::getVertex(v9, a2, &v13, a5, a3);
  if (a4)
  {
    v12 = v13;
    *a4 = CMTimeGetSeconds(&v12);
  }
  return Vertex;
}

uint64_t OZDynamicCurve::delKeypoint(OZDynamicCurve *this, char *a2, const CMTime *a3)
{
  char **v6;
  uint64_t v7;

  v6 = (char **)((char *)this + 8);
  if (!OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2))
    return 0;
  v7 = OZDynamicSpline::deleteVertex(v6, a2, 1, a3);
  if (((*((_QWORD *)this + 4) - *((_QWORD *)this + 3)) & 0x7FFFFFFF8) == 0)
    (*(void (**)(OZDynamicCurve *))(*(_QWORD *)this + 56))(this);
  OZSpline::reparametrize((uint64_t)v6);
  return v7;
}

BOOL OZDynamicCurve::delAllKeypoints(OZDynamicCurve *this)
{
  _BOOL8 v2;

  v2 = OZSpline::deleteAllVertices((OZDynamicCurve *)((char *)this + 8));
  (*(void (**)(OZDynamicCurve *))(*(_QWORD *)this + 56))(this);
  return v2;
}

uint64_t OZDynamicCurve::getKeypointFlags(OZDynamicCurve *this, char *a2, unsigned int *a3)
{
  OZSpline *v5;
  uint64_t result;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
    return OZSpline::getVertexFlags(v5, a2, a3);
  return result;
}

uint64_t OZDynamicCurve::setKeypointFlags(OZDynamicCurve *this, char *a2, uint64_t a3)
{
  OZSpline *v5;
  uint64_t result;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
    return OZSpline::setVertexFlags(v5, a2, a3);
  return result;
}

uint64_t OZDynamicCurve::enableKeypoint(OZDynamicCurve *this, char *a2, int a3, const CMTime *a4)
{
  OZSpline *v7;
  uint64_t result;

  v7 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
  {
    if (a3)
      return OZDynamicSpline::enableVertex(v7, a2, a4);
    else
      return OZDynamicSpline::disableVertex(v7, a2, a4);
  }
  return result;
}

uint64_t OZDynamicCurve::isEnabledKeypoint(OZDynamicCurve *this, char *a2, const CMTime *a3, BOOL *a4)
{
  OZSpline *v7;
  uint64_t isValidHandle;

  v7 = (OZDynamicCurve *)((char *)this + 8);
  isValidHandle = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)isValidHandle)
    *a4 = OZSpline::isEnabledVertex(v7, a2, a3);
  return isValidHandle;
}

uint64_t OZDynamicCurve::selectKeypoint(OZDynamicCurve *this, char *a2, int a3)
{
  OZSpline *v5;
  uint64_t result;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
  {
    if (a3)
      return OZSpline::setVertexFlag(v5, a2, 16);
    else
      return OZSpline::resetVertexFlag(v5, a2, 16);
  }
  return result;
}

uint64_t OZDynamicCurve::isSelectedKeypoint(OZDynamicCurve *this, char *a2, BOOL *a3)
{
  OZSpline *v5;
  uint64_t isValidHandle;
  unsigned int v8;

  v8 = 0;
  v5 = (OZDynamicCurve *)((char *)this + 8);
  isValidHandle = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)isValidHandle)
  {
    OZSpline::getVertexFlags(v5, a2, &v8);
    *a3 = (v8 & 0x10) != 0;
  }
  return isValidHandle;
}

uint64_t OZDynamicCurve::lockKeypoint(OZDynamicCurve *this, char *a2, int a3)
{
  OZSpline *v5;
  uint64_t result;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
  {
    if (a3)
      return OZSpline::setVertexFlag(v5, a2, 2);
    else
      return OZSpline::resetVertexFlag(v5, a2, 2);
  }
  return result;
}

uint64_t OZDynamicCurve::isLockedKeypoint(OZDynamicCurve *this, char *a2, BOOL *a3)
{
  OZSpline *v5;
  uint64_t isValidHandle;
  unsigned int v8;

  v8 = 0;
  v5 = (OZDynamicCurve *)((char *)this + 8);
  isValidHandle = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)isValidHandle)
  {
    OZSpline::getVertexFlags(v5, a2, &v8);
    *a3 = (v8 & 2) != 0;
  }
  return isValidHandle;
}

uint64_t OZDynamicCurve::setOpenEdgeKeypoint(OZDynamicCurve *this, char *a2, int a3)
{
  OZSpline *v5;
  uint64_t result;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
  {
    if (a3)
      return OZSpline::setVertexFlag(v5, a2, 512);
    else
      return OZSpline::resetVertexFlag(v5, a2, 512);
  }
  return result;
}

uint64_t OZDynamicCurve::isOpenEdgeKeypoint(OZDynamicCurve *this, char *a2, BOOL *a3)
{
  OZSpline *v5;
  uint64_t isValidHandle;
  unsigned int v8;

  v8 = 0;
  v5 = (OZDynamicCurve *)((char *)this + 8);
  isValidHandle = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)isValidHandle)
  {
    OZSpline::getVertexFlags(v5, a2, &v8);
    *a3 = (v8 & 0x200) != 0;
  }
  return isValidHandle;
}

uint64_t OZDynamicCurve::enableBehaviorForKeypoint(OZDynamicCurve *this, char *a2, uint64_t a3)
{
  OZDynamicSpline *v5;
  uint64_t isValidHandle;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  isValidHandle = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)isValidHandle)
    OZDynamicSpline::enableBehaviorForVertex(v5, a2, a3);
  return isValidHandle;
}

uint64_t OZDynamicCurve::isBehaviorEnabledForKeypoint(OZDynamicCurve *this, char *a2, BOOL *a3)
{
  OZDynamicSpline *v5;
  uint64_t isValidHandle;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  isValidHandle = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)isValidHandle)
    *a3 = OZDynamicSpline::enabledBehaviorForVertex(v5, a2);
  return isValidHandle;
}

uint64_t OZDynamicCurve::weightHandles(OZDynamicCurve *this, char *a2, int a3)
{
  OZSpline *v5;
  uint64_t result;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
  {
    if (a3)
      return OZSpline::setVertexFlag(v5, a2, 8);
    else
      return OZSpline::resetVertexFlag(v5, a2, 8);
  }
  return result;
}

uint64_t OZDynamicCurve::areHandlesWeighted(OZDynamicCurve *this, char *a2, BOOL *a3)
{
  OZSpline *v5;
  uint64_t isValidHandle;
  unsigned int v8;

  v8 = 0;
  v5 = (OZDynamicCurve *)((char *)this + 8);
  isValidHandle = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)isValidHandle)
  {
    OZSpline::getVertexFlags(v5, a2, &v8);
    *a3 = (v8 & 8) != 0;
  }
  return isValidHandle;
}

uint64_t OZDynamicCurve::breakKeypointHandles(OZDynamicCurve *this, char *a2, int a3)
{
  OZSpline *v5;
  uint64_t result;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
  {
    if (a3)
      return OZSpline::setVertexFlag(v5, a2, 1);
    else
      return OZSpline::resetVertexFlag(v5, a2, 1);
  }
  return result;
}

uint64_t OZDynamicCurve::areHandlesBroken(OZDynamicCurve *this, char *a2, BOOL *a3)
{
  OZSpline *v5;
  uint64_t isValidHandle;
  unsigned int v8;

  v8 = 0;
  v5 = (OZDynamicCurve *)((char *)this + 8);
  isValidHandle = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)isValidHandle)
  {
    OZSpline::getVertexFlags(v5, a2, &v8);
    *a3 = v8 & 1;
  }
  return isValidHandle;
}

uint64_t OZDynamicCurve::flattenHandles(OZDynamicCurve *this, char *a2, const CMTime *a3)
{
  OZSpline *v5;
  uint64_t result;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
    return OZSpline::flattenHandles(v5, a2, a3);
  return result;
}

uint64_t OZDynamicCurve::setKeypointInputHandles(OZDynamicCurve *this, char *a2, const CMTime *a3, double a4)
{
  os_unfair_lock_s *v7;
  uint64_t result;

  v7 = (os_unfair_lock_s *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
    return OZDynamicSpline::setVertexInputHandles(v7, a2, 0.0, a4, a3);
  return result;
}

uint64_t OZDynamicCurve::setKeypointOutputHandles(OZDynamicCurve *this, char *a2, const CMTime *a3, double a4)
{
  os_unfair_lock_s *v7;
  uint64_t result;

  v7 = (os_unfair_lock_s *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
    return OZDynamicSpline::setVertexOutputHandles(v7, a2, 0.0, a4, a3);
  return result;
}

uint64_t OZDynamicCurve::getKeypointInputHandles(OZDynamicCurve *this, char *a2, const CMTime *a3, double *a4)
{
  os_unfair_lock_s *v7;
  uint64_t result;

  v7 = (os_unfair_lock_s *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
    return OZDynamicSpline::getVertexInputHandles(v7, a2, 0, a4, a3);
  return result;
}

uint64_t OZDynamicCurve::getKeypointOutputHandles(OZDynamicCurve *this, char *a2, const CMTime *a3, double *a4)
{
  os_unfair_lock_s *v7;
  uint64_t result;

  v7 = (os_unfair_lock_s *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
    return OZDynamicSpline::getVertexOutputHandles(v7, a2, 0, a4, a3);
  return result;
}

uint64_t OZDynamicCurve::setKeypointInterpolation(OZDynamicCurve *this, char *a2, uint64_t a3)
{
  OZSpline *v5;
  uint64_t result;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
    return OZSpline::setVertexInterpolation(v5, a2, a3);
  return result;
}

uint64_t OZDynamicCurve::setCurveInterpolation(OZDynamicCurve *this, uint64_t a2)
{
  int v2;

  v2 = a2;
  OZSpline::setInterpolation((OZDynamicCurve *)((char *)this + 8), a2);
  *((_DWORD *)this + 54) = v2;
  return 1;
}

BOOL OZDynamicCurve::getCurveInterpolation(OZDynamicCurve *this, unsigned int *a2, BOOL *a3, BOOL *a4)
{
  return OZDynamicSpline::getInterpolation((OZDynamicCurve *)((char *)this + 8), a2, a3, a4);
}

uint64_t OZDynamicCurve::getKeypointInterpolation(OZDynamicCurve *this, char *a2, unsigned int *a3, BOOL *a4)
{
  OZInterpolators **v7;
  uint64_t result;

  v7 = (OZInterpolators **)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
    return OZSpline::getVertexInterpolation(v7, a2, a3, a4);
  return result;
}

uint64_t OZDynamicCurve::generateKeypoints(OZDynamicCurve *this, int a2, unsigned int a3)
{
  return OZSpline::generateExtrapolatedVertices((OZDynamicCurve *)((char *)this + 8), a2, a3, MEMORY[0x1E0CA2E68]);
}

uint64_t OZDynamicCurve::reparametrizeCurve(OZDynamicCurve *this)
{
  OZSpline::reparametrize((uint64_t)this + 8);
  return 1;
}

uint64_t OZDynamicCurve::reverseWindingOrder(OZDynamicCurve *this)
{
  OZDynamicSpline::reverseWindingOrder((OZDynamicCurve *)((char *)this + 8), MEMORY[0x1E0CA2E68]);
  return 1;
}

uint64_t OZDynamicCurve::getVertexChannel(OZDynamicCurve *this, char *a2, OZChannelVertexFolder **a3)
{
  OZDynamicSpline *v5;
  unsigned int isValidHandle;
  uint64_t v7;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  isValidHandle = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if (a3)
    v7 = isValidHandle;
  else
    v7 = 0;
  if ((_DWORD)v7 == 1)
    *a3 = (OZChannelVertexFolder *)OZDynamicSpline::getVertexChannel(v5, a2);
  return v7;
}

uint64_t OZDynamicCurve::setVertexChannel(OZDynamicCurve *this, char *a2, OZChannelVertexFolder *a3)
{
  OZDynamicSpline *v5;
  unsigned int isValidHandle;
  uint64_t v7;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  isValidHandle = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if (a3)
    v7 = isValidHandle;
  else
    v7 = 0;
  if ((_DWORD)v7 == 1)
    OZDynamicSpline::setVertexChannel(v5, a2, a3);
  return v7;
}

uint64_t OZDynamicCurve::getPreviousKeypointHandle(OZDynamicCurve *this, const CMTime *a2, char *a3, void **a4)
{
  OZSpline *v6;
  uint64_t result;
  void *PreviousVertex;

  v6 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a3);
  if ((_DWORD)result)
  {
    PreviousVertex = (void *)OZSpline::getPreviousVertex(v6, a3);
    if (a4)
      *a4 = PreviousVertex;
    return PreviousVertex != 0;
  }
  return result;
}

uint64_t OZDynamicCurve::getNextKeypointHandle(OZDynamicCurve *this, const CMTime *a2, char *a3, void **a4)
{
  void ***v6;
  uint64_t result;
  void *NextVertex;

  v6 = (void ***)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a3);
  if ((_DWORD)result)
  {
    NextVertex = OZSpline::getNextVertex(v6, a3);
    if (a4)
      *a4 = NextVertex;
    return NextVertex != 0;
  }
  return result;
}

uint64_t OZDynamicCurve::getPreviousValidKeypointHandle(OZDynamicCurve *this, const CMTime *a2, char *a3, void **a4)
{
  OZSpline *v7;
  uint64_t result;
  void *v9;
  void *v10;

  v7 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a3);
  if ((_DWORD)result)
  {
    v10 = 0;
    OZSpline::getPreviousValidVertex(v7, a3, &v10, a2);
    v9 = v10;
    if (a4)
      *a4 = v10;
    return v9 != 0;
  }
  return result;
}

uint64_t OZDynamicCurve::getNextValidKeypointHandle(OZDynamicCurve *this, const CMTime *a2, char *a3, void **a4)
{
  void ***v7;
  uint64_t result;
  void *v9;
  void *v10;

  v7 = (void ***)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a3);
  if ((_DWORD)result)
  {
    v10 = 0;
    OZSpline::getNextValidVertex(v7, a3, &v10, a2);
    v9 = v10;
    if (a4)
      *a4 = v10;
    return v9 != 0;
  }
  return result;
}

BOOL OZDynamicCurve::getPreviousValidKeypointHandle(OZDynamicCurve *this, const CMTime *a2, Float64 a3, void **a4)
{
  OZSpline *v6;
  CMTime v8;

  v6 = (OZDynamicCurve *)((char *)this + 8);
  OZFigTimeForChannelSeconds(&v8, a3, 0x40000);
  OZSpline::getPreviousValidVertex(v6, &v8, a4, a2, 0);
  return *a4 != 0;
}

BOOL OZDynamicCurve::getNextValidKeypointHandle(OZDynamicCurve *this, const CMTime *a2, Float64 a3, void **a4)
{
  OZSpline *v6;
  CMTime v8;

  v6 = (OZDynamicCurve *)((char *)this + 8);
  OZFigTimeForChannelSeconds(&v8, a3, 0x40000);
  OZSpline::getNextValidVertex(v6, &v8, a4, a2, 0);
  return *a4 != 0;
}

uint64_t OZDynamicCurve::deriveKeypoint(OZDynamicCurve *this, char *a2)
{
  OZSpline *v3;
  uint64_t result;

  if (!a2)
    return 0;
  v3 = (OZDynamicCurve *)((char *)this + 8);
  result = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)result)
  {
    OZSpline::deriveVertex(v3, a2, MEMORY[0x1E0CA2E68]);
    return 1;
  }
  return result;
}

uint64_t OZDynamicCurve::isValidHandle(OZDynamicCurve *this, char *a2)
{
  return OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
}

uint64_t OZDynamicCurve::flattenCurve(OZDynamicCurve *this)
{
  OZDynamicSpline::flattenSpline((OZDynamicCurve *)((char *)this + 8));
  return 1;
}

uint64_t OZDynamicCurve::isCurveFlattened(OZDynamicCurve *this)
{
  return OZDynamicSpline::isSplineFlattened((OZDynamicCurve *)((char *)this + 8));
}

uint64_t OZDynamicCurve::isKeypointFlattened(OZDynamicCurve *this, char *a2, BOOL *a3)
{
  OZDynamicSpline *v5;
  uint64_t isValidHandle;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  isValidHandle = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)isValidHandle)
    *a3 = OZDynamicSpline::isVertexFlattened(v5, a2);
  return isValidHandle;
}

uint64_t OZDynamicCurve::getLastValidKeypointHandle(OZDynamicCurve *this, const CMTime *a2, void **a3)
{
  return OZSpline::getLastValidVertex((OZDynamicCurve *)((char *)this + 8), a3, a2);
}

BOOL OZDynamicCurve::getFirstValidKeypointHandle(OZDynamicCurve *this, const CMTime *a2, void **a3)
{
  return OZSpline::getFirstValidVertex((OZDynamicCurve *)((char *)this + 8), a3, a2);
}

uint64_t OZDynamicCurve::setDefaultAtCurrentTime(OZDynamicCurve *this, const CMTime *a2)
{
  OZDynamicSpline::setDefaultValueAtCurrentTime((OZDynamicCurve *)((char *)this + 8), a2);
  return 1;
}

uint64_t OZDynamicCurve::setDefaultAtCurrentTime(OZDynamicCurve *this, char *a2, const CMTime *a3)
{
  os_unfair_lock_s *v5;
  uint64_t isValidHandle;

  v5 = (os_unfair_lock_s *)((char *)this + 8);
  isValidHandle = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)isValidHandle)
    OZDynamicSpline::setDefaultValueAtCurrentTime(v5, a2, a3);
  return isValidHandle;
}

uint64_t OZDynamicCurve::updateKeypointBias(OZDynamicCurve *this, void *a2)
{
  OZDynamicSpline::updateVertexBias((OZDynamicCurve *)((char *)this + 8), a2);
  return 1;
}

uint64_t OZDynamicCurve::getVertexToInsert(OZDynamicCurve *this, const CMTime *a2, Float64 a3, double *a4, double *a5, double *a6, double *a7, double *a8)
{
  OZInterpolators **v14;
  CMTime v16;

  v14 = (OZInterpolators **)((char *)this + 8);
  OZFigTimeForChannelSeconds(&v16, a3, 0x40000);
  OZDynamicSpline::getVertexToInsert(v14, a2, &v16, a4, a5, a6, a7, a8);
  return 1;
}

uint64_t OZDynamicCurve::setKeypointID(OZDynamicCurve *this, char *a2, unsigned int a3)
{
  OZDynamicSpline *v5;
  uint64_t isValidHandle;

  v5 = (OZDynamicCurve *)((char *)this + 8);
  isValidHandle = OZSpline::isValidHandle((OZDynamicCurve *)((char *)this + 8), a2);
  if ((_DWORD)isValidHandle)
    OZDynamicSpline::setVertexID(v5, a2, a3);
  return isValidHandle;
}

void OZSplineState::OZSplineState(OZSplineState *this)
{
  CMTime v2;

  *(_WORD *)this = 256;
  *((_BYTE *)this + 2) = 1;
  *((_QWORD *)this + 4) = 1;
  *((_DWORD *)this + 10) = 0;
  *((_BYTE *)this + 44) = 1;
  *((_BYTE *)this + 4) = 0;
  CMTimeMake(&v2, 1, 30);
  *(CMTime *)((char *)this + 8) = v2;
  *((_BYTE *)this + 3) = 1;
}

void OZSplineState::OZSplineState(OZSplineState *this, const OZSplineState *a2, uint8x8_t a3)
{
  int32_t v4;
  CMTime v5;

  a3.i32[0] = *(_DWORD *)a2;
  *(_DWORD *)this = *(_DWORD *)a2;
  *((_QWORD *)this + 4) = *((_QWORD *)a2 + 4);
  *((_DWORD *)this + 10) = *((_DWORD *)a2 + 10);
  *((_BYTE *)this + 4) = *((_BYTE *)a2 + 4);
  *((_BYTE *)this + 44) = 0;
  if (vmovl_u8(a3).i8[2])
    v4 = 30;
  else
    v4 = 3000000;
  CMTimeMake(&v5, 1, v4);
  *(CMTime *)((char *)this + 8) = v5;
}

double OZSplineState::operator=(uint64_t a1, uint64_t a2, uint8x8_t a3)
{
  int32_t v4;
  double result;
  CMTime v6;

  a3.i32[0] = *(_DWORD *)a2;
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
  if (vmovl_u8(a3).i8[2])
    v4 = 30;
  else
    v4 = 3000000;
  CMTimeMake(&v6, 1, v4);
  result = *(double *)&v6.value;
  *(CMTime *)(a1 + 8) = v6;
  return result;
}

BOOL OZSplineState::operator==(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3, const CMTime *a4)
{
  return *a1 == *a2
      && a1[1] == a2[1]
      && a1[2] == a2[2]
      && a1[3] == a2[3]
      && *((_DWORD *)a1 + 8) == *((_DWORD *)a2 + 8)
      && *((_DWORD *)a1 + 9) == *((_DWORD *)a2 + 9)
      && *((_DWORD *)a1 + 10) == *((_DWORD *)a2 + 10)
      && a1[4] == a2[4]
      && PCMath::equal((PCMath *)(a1 + 8), (const CMTime *)(a2 + 8), MEMORY[0x1E0CA2E68], a4);
}

void OZChannelHelpButton::OZChannelHelpButton(OZChannelHelpButton *this, const PCString *a2, OZChannelFolder *a3, unsigned int a4, int a5)
{
  OZFactory *Instance;

  Instance = (OZFactory *)OZChannelHelpButton_Factory::getInstance(this);
  OZChannelButton::OZChannelButton((OZChannelButton *)this, Instance, a2, a3, a4, a5);
  *(_QWORD *)this = &off_1E6554980;
  *((_QWORD *)this + 2) = &unk_1E6554CE0;
}

void OZChannelHelpButton::OZChannelHelpButton(OZChannelHelpButton *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  _QWORD *v4;

  OZChannelButton::OZChannelButton((OZChannelButton *)this, a2, a3, a4);
  *v4 = &off_1E6554980;
  v4[2] = &unk_1E6554CE0;
}

void OZChannelHelpButton::OZChannelHelpButton(OZChannelHelpButton *this, const OZChannelBase *a2, OZChannelFolder *a3)
{
  _QWORD *v3;

  OZChannelButton::OZChannelButton((OZChannelButton *)this, a2, a3);
  *v3 = &off_1E6554980;
  v3[2] = &unk_1E6554CE0;
}

OZChannelButton *OZChannelHelpButton::clone(const OZChannelBase *this)
{
  OZChannelButton *v2;

  v2 = (OZChannelButton *)operator new();
  OZChannelButton::OZChannelButton(v2, this, 0);
  v2->var0 = (void **)&off_1E6554980;
  v2->var2 = (void **)&unk_1E6554CE0;
  return v2;
}

void sub_1B2C35710(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C400C70C378);
  _Unwind_Resume(a1);
}

const __CFString *OZChannelHelpButton::getObjCWrapperName(OZChannelHelpButton *this)
{
  return CFSTR("CHChannelHelpButton");
}

void OZChannelHelpButton::~OZChannelHelpButton(OZChannelButton *this)
{
  OZChannelButton::~OZChannelButton(this);
  JUMPOUT(0x1B5E29170);
}

void `non-virtual thunk to'OZChannelHelpButton::~OZChannelHelpButton(OZChannelHelpButton *this)
{
  OZChannelButton::~OZChannelButton((OZChannelButton *)((char *)this - 16));
}

{
  OZChannelButton::~OZChannelButton((OZChannelButton *)((char *)this - 16));
  JUMPOUT(0x1B5E29170);
}

void OZAccelerateInterpolator::easeTime(CMTime *a1@<X2>, _BYTE **a2@<X3>, uint64_t a3@<X4>, uint64_t a4@<X8>)
{
  double v8;
  double Seconds;
  Float64 v10;
  double *v11;
  CMTime v12;
  Float64 v13;
  CMTime v14;
  CMTime v15;
  CMTime time;
  CMTime v17;
  CMTime v18;

  v8 = (2.0 - (*((double (**)(_BYTE **, _QWORD))*a2 + 5))(a2, MEMORY[0x1E0CA2E68])) * 0.5;
  v17 = *(CMTime *)(a2 + 2);
  v18 = *a1;
  PC_CMTimeSaferSubtract(&v18, &v17, (uint64_t)&time);
  Seconds = CMTimeGetSeconds(&time);
  memset(&v15, 0, sizeof(v15));
  v18 = *(CMTime *)(a3 + 16);
  v17 = *(CMTime *)(a2 + 2);
  PC_CMTimeSaferSubtract(&v18, &v17, (uint64_t)&v15);
  v14 = v15;
  v10 = CMTimeGetSeconds(&v14);
  v13 = 0.0;
  PCMath::easeInOut(&v13, Seconds / v10, v8, 0.0, 0.0, 1.0, 0, v11);
  operator*(&v15, &v12, v13);
  v17 = *(CMTime *)(a2 + 2);
  v18 = v12;
  PC_CMTimeSaferAdd(&v18, &v17, a4);
}

void OZAccelerateInterpolator::~OZAccelerateInterpolator(OZAccelerateInterpolator *this)
{
  OZEaseInInterpolator::~OZEaseInInterpolator(this);
  JUMPOUT(0x1B5E29170);
}

void sub_1B2C35A50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  uint64_t v10;

  PCString::~PCString(&a10);
  MEMORY[0x1B5E29170](v10, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelDecibel::OZChannelDecibel(OZChannelDecibel *this, const PCString *a2, OZChannelFolder *a3, unsigned int a4, int a5, OZChannelImpl *a6, OZChannelInfo *a7)
{
  OZFactory *OZChannelDecibel_FactoryBase;
  OZChannelDecibel *v15;
  OZChannelDecibel *OZChannelDecibelInfo;
  OZChannelInfo *var17;
  OZChannelImpl *var15;

  OZChannelDecibel_FactoryBase = (OZFactory *)getOZChannelDecibel_FactoryBase();
  OZChannel::OZChannel((OZChannel *)this, OZChannelDecibel_FactoryBase, a2, a3, a4, a5, a6, a7);
  this->var0 = (void **)&off_1E65535A8;
  this->var2 = (void **)&unk_1E6553908;
  OZChannelDecibelInfo = (OZChannelDecibel *)OZChannelDecibel::createOZChannelDecibelInfo(v15);
  if (a7)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelDecibel::_OZChannelDecibelInfo;
    this->var17 = (OZChannelInfo *)OZChannelDecibel::_OZChannelDecibelInfo;
  }
  this->var16 = var17;
  OZChannelDecibel::createOZChannelDecibelImpl(OZChannelDecibelInfo);
  if (a6)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelDecibel::_OZChannelDecibelImpl;
    this->var15 = (OZChannelImpl *)OZChannelDecibel::_OZChannelDecibelImpl;
  }
  this->var14 = var15;
}

void sub_1B2C35B8C(_Unwind_Exception *a1)
{
  OZChannel *v1;

  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

void OZChannelImpl::OZChannelImpl(OZChannelImpl *this, OZCurve *a2, double a3, int a4, char a5)
{
  _BOOL8 v7;

  *(_QWORD *)this = &off_1E6554DE8;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = 0;
  atomic_store(0, (unint64_t *)this + 3);
  *((_BYTE *)this + 32) = a5;
  v7 = a4 == 1;
  OZCurve::setIsSpline(a2, v7, MEMORY[0x1E0CA2E68]);
  (*(void (**)(_QWORD, _BOOL8))(**((_QWORD **)this + 1) + 80))(*((_QWORD *)this + 1), v7);
  (*(void (**)(_QWORD, double))(**((_QWORD **)this + 1) + 200))(*((_QWORD *)this + 1), a3);
  (*(void (**)(_QWORD, double))(**((_QWORD **)this + 1) + 216))(*((_QWORD *)this + 1), a3);
}

void OZChannelImpl::operator=(OZChannelImpl *this, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  BOOL v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  __int128 *v11;
  __int128 v12;
  __int128 v13;

  v4 = *((_QWORD *)this + 2);
  v5 = *(_QWORD *)(a2 + 16);
  if (!(v4 | v5))
    goto LABEL_13;
  if (v4)
    v6 = v5 == 0;
  else
    v6 = 0;
  if (v6)
  {
    MEMORY[0x1B5E29170]();
LABEL_13:
    *((_QWORD *)this + 2) = 0;
    goto LABEL_14;
  }
  if (v4)
    v7 = 1;
  else
    v7 = v5 == 0;
  if (v7)
  {
    v8 = *(_OWORD *)v5;
    *(_QWORD *)(v4 + 16) = *(_QWORD *)(v5 + 16);
    *(_OWORD *)v4 = v8;
    v9 = *(_OWORD *)(v5 + 24);
    *(_QWORD *)(v4 + 40) = *(_QWORD *)(v5 + 40);
    *(_OWORD *)(v4 + 24) = v9;
    *(_QWORD *)(v4 + 48) = *(_QWORD *)(v5 + 48);
  }
  else
  {
    v10 = operator new();
    v11 = *(__int128 **)(a2 + 16);
    v12 = *v11;
    *(_QWORD *)(v10 + 16) = *((_QWORD *)v11 + 2);
    *(_OWORD *)v10 = v12;
    v13 = *(__int128 *)((char *)v11 + 24);
    *(_QWORD *)(v10 + 40) = *((_QWORD *)v11 + 5);
    *(_OWORD *)(v10 + 24) = v13;
    *(_QWORD *)(v10 + 48) = *((_QWORD *)v11 + 6);
    *((_QWORD *)this + 2) = v10;
  }
LABEL_14:
  OZChannelImpl::copyCurveInterface(this, *(OZCurve **)(a2 + 8));
  *((_BYTE *)this + 32) = 0;
}

void OZChannelImpl::OZChannelImpl(OZChannelImpl *this, const OZChannelImpl *a2)
{
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_1E6554DE8;
  atomic_store(0, (unint64_t *)this + 3);
  *((_BYTE *)this + 32) = 0;
  OZChannelImpl::operator=(this, (uint64_t)a2);
}

void OZChannelImpl::~OZChannelImpl(OZChannelImpl *this)
{
  uint64_t v2;
  unint64_t v4;
  void *v5;
  uint64_t v6;

  *(_QWORD *)this = &off_1E6554DE8;
  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    *((_QWORD *)this + 1) = 0;
  }
  if (atomic_load((unint64_t *)this + 3))
  {
    v4 = atomic_load((unint64_t *)this + 3);
    if (v4)
    {
      v5 = *(void **)v4;
      if (*(_QWORD *)v4)
      {
        *(_QWORD *)(v4 + 8) = v5;
        operator delete(v5);
      }
      MEMORY[0x1B5E29170](v4, 0x20C40960023A9);
    }
    atomic_store(0, (unint64_t *)this + 3);
  }
  v6 = *((_QWORD *)this + 2);
  if (v6)
  {
    MEMORY[0x1B5E29170](v6, 0x1000C4021716A34);
    *((_QWORD *)this + 2) = 0;
  }
}

{
  OZChannelImpl::~OZChannelImpl(this);
  JUMPOUT(0x1B5E29170);
}

void OZChannelImpl::copyCurveInterface(OZChannelImpl *this, OZCurve *a2)
{
  OZCurve *v3;
  uint8x8_t v5;
  uint64_t v6;

  v3 = (OZCurve *)*((_QWORD *)this + 1);
  if (v3 != a2)
  {
    if (v3)
    {
      if ((*(unsigned int (**)(OZCurve *))(*(_QWORD *)v3 + 1232))(v3)
        && (*(unsigned int (**)(OZCurve *))(*(_QWORD *)a2 + 1232))(a2))
      {
        OZCurve::operator=(*((_QWORD *)this + 1), (uint64_t)a2, v5);
        return;
      }
      v6 = *((_QWORD *)this + 1);
      if (v6)
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      *((_QWORD *)this + 1) = 0;
    }
    *((_QWORD *)this + 1) = (*(uint64_t (**)(OZCurve *))(*(_QWORD *)a2 + 1224))(a2);
  }
}

uint64_t OZChannelImpl::operator==(uint64_t a1, uint64_t a2)
{
  __int128 *v2;
  __int128 *v3;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CMTime v13;
  CMTime time1;

  v2 = *(__int128 **)(a1 + 16);
  v3 = *(__int128 **)(a2 + 16);
  if ((v2 != 0) == (v3 == 0))
    return 0;
  if (!v2 || v3 == 0)
    return OZCurve::operator==(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 8));
  v8 = *v2;
  time1.epoch = *((_QWORD *)v2 + 2);
  *(_OWORD *)&time1.value = v8;
  v9 = *v3;
  v13.epoch = *((_QWORD *)v3 + 2);
  *(_OWORD *)&v13.value = v9;
  if (!CMTimeCompare(&time1, &v13)
    && (v10 = *(_QWORD *)(a2 + 16),
        time1 = *(CMTime *)(*(_QWORD *)(a1 + 16) + 24),
        v13 = *(CMTime *)(v10 + 24),
        !CMTimeCompare(&time1, &v13))
    && (v11 = *(_QWORD *)(a1 + 16), v12 = *(_QWORD *)(a2 + 16), *(_DWORD *)(v11 + 48) == *(_DWORD *)(v12 + 48))
    && *(_DWORD *)(v11 + 52) == *(_DWORD *)(v12 + 52))
  {
    return OZCurve::operator==(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 8));
  }
  else
  {
    return 0;
  }
}

BOOL OZChannelImpl::shouldKeepLocalCopy(OZChannelImpl *this)
{
  _BOOL8 result;
  int v3;

  result = 0;
  if (!*((_BYTE *)this + 32))
  {
    v3 = 0;
    (*(void (**)(_QWORD, int *))(**((_QWORD **)this + 1) + 1152))(*((_QWORD *)this + 1), &v3);
    if (v3 || *(_QWORD *)(*((_QWORD *)this + 1) + 152))
      return 1;
  }
  return result;
}

uint64_t OZChannelImpl::beginPlayback(OZChannelImpl *this, const CMTime *a2, uint64_t a3, uint64_t a4, const CMTime *a5)
{
  return (*(uint64_t (**)(_QWORD, const CMTime *, uint64_t, uint64_t, const CMTime *))(**((_QWORD **)this + 1)
                                                                                             + 1160))(*((_QWORD *)this + 1), a2, a3, a4, a5);
}

uint64_t OZChannelImpl::endPlayback(OZChannelImpl *this, const CMTime *a2)
{
  return (*(uint64_t (**)(_QWORD, const CMTime *))(**((_QWORD **)this + 1) + 1168))(*((_QWORD *)this + 1), a2);
}

uint64_t OZChannelImpl::beginRecording(OZChannelImpl *this, const CMTime *a2)
{
  unint64_t *v4;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v10;

  v4 = (unint64_t *)((char *)this + 24);
  if (atomic_load((unint64_t *)this + 3))
  {
    v6 = (_QWORD *)atomic_load(v4);
    v6[1] = *v6;
  }
  else
  {
    v7 = (_QWORD *)operator new();
    v8 = v7;
    v7[1] = 0;
    v7[2] = 0;
    *v7 = 0;
    while (!__ldaxr(v4))
    {
      if (!__stlxr((unint64_t)v7, v4))
        return (*(uint64_t (**)(_QWORD, const CMTime *))(**((_QWORD **)this + 1) + 1176))(*((_QWORD *)this + 1), a2);
    }
    __clrex();
    v10 = (void *)*v7;
    if (*v8)
    {
      v8[1] = v10;
      operator delete(v10);
    }
    MEMORY[0x1B5E29170](v8, 0x20C40960023A9);
  }
  return (*(uint64_t (**)(_QWORD, const CMTime *))(**((_QWORD **)this + 1) + 1176))(*((_QWORD *)this + 1), a2);
}

uint64_t OZChannelImpl::endRecording(OZChannelImpl *this, const CMTime *a2)
{
  return (*(uint64_t (**)(_QWORD, const CMTime *))(**((_QWORD **)this + 1) + 1184))(*((_QWORD *)this + 1), a2);
}

uint64_t OZChannelImpl::updateCurrentRecordingTime(OZChannelImpl *this, const CMTime *a2)
{
  return (*(uint64_t (**)(_QWORD, const CMTime *))(**((_QWORD **)this + 1) + 1192))(*((_QWORD *)this + 1), a2);
}

OZChannelImpl *OZChannelImpl::didRecordValue(OZChannelImpl *this, OZChannelBase *a2, const CMTime *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  OZChannelImpl *v11;
  uint64_t v12;
  unsigned int v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  __int128 v18;
  CMTimeEpoch epoch;

  v8 = (_QWORD *)atomic_load((unint64_t *)this + 3);
  if (v8[1] != *v8)
  {
    v11 = this;
    v12 = 0;
    v13 = 1;
    do
    {
      v14 = (_QWORD *)atomic_load((unint64_t *)v11 + 3);
      v15 = *v14 + 24 * v12;
      v18 = *(_OWORD *)&a3->value;
      epoch = a3->epoch;
      if (*(_BYTE *)(v15 + 16))
        OZChannelBase::ensureObjCWrapperExists(a2, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
      this = (OZChannelImpl *)(*(uint64_t (**)(OZChannelBase *, __int128 *, _QWORD))v15)(a2, &v18, *(_QWORD *)(v15 + 8));
      v12 = v13;
      v16 = (_QWORD *)atomic_load((unint64_t *)v11 + 3);
    }
    while (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v16[1] - *v16) >> 3) > v13++);
  }
  return this;
}

uint64_t OZChannelImpl::isPlaying(OZChannelImpl *this, unsigned int *a2, unsigned int *a3, CMTime *a4)
{
  return (*(uint64_t (**)(_QWORD, unsigned int *, unsigned int *, CMTime *))(**((_QWORD **)this + 1) + 1200))(*((_QWORD *)this + 1), a2, a3, a4);
}

uint64_t OZChannelImpl::isRecording(OZChannelImpl *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 1208))(*((_QWORD *)this + 1));
}

void OZChannelImpl::registerRecordingCallback(OZChannelImpl *this, void (*a2)(OZChannelBase *, const CMTime *, void *), void *a3, char a4)
{
  unint64_t *v7;
  _QWORD *v9;
  _QWORD *v10;
  void *v12;
  void **v13;
  char *v14;
  char *v15;
  char *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  __int128 v26;

  v7 = (unint64_t *)((char *)this + 24);
  if (!atomic_load((unint64_t *)this + 3))
  {
    v9 = (_QWORD *)operator new();
    v10 = v9;
    v9[1] = 0;
    v9[2] = 0;
    *v9 = 0;
    while (!__ldaxr(v7))
    {
      if (!__stlxr((unint64_t)v9, v7))
        goto LABEL_9;
    }
    __clrex();
    v12 = (void *)*v9;
    if (*v10)
    {
      v10[1] = v12;
      operator delete(v12);
    }
    MEMORY[0x1B5E29170](v10, 0x20C40960023A9);
  }
LABEL_9:
  v13 = (void **)atomic_load(v7);
  v14 = (char *)v13[1];
  v15 = (char *)v13[2];
  if (v14 >= v15)
  {
    v17 = 0xAAAAAAAAAAAAAAABLL * ((v14 - (_BYTE *)*v13) >> 3);
    v18 = v17 + 1;
    if (v17 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v19 = 0xAAAAAAAAAAAAAAABLL * ((v15 - (_BYTE *)*v13) >> 3);
    if (2 * v19 > v18)
      v18 = 2 * v19;
    if (v19 >= 0x555555555555555)
      v20 = 0xAAAAAAAAAAAAAAALL;
    else
      v20 = v18;
    if (v20)
      v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(v13 + 2), v20);
    else
      v21 = 0;
    v22 = &v21[24 * v17];
    v23 = &v21[24 * v20];
    *(_QWORD *)v22 = a2;
    *((_QWORD *)v22 + 1) = a3;
    v22[16] = a4;
    v16 = v22 + 24;
    v25 = (char *)*v13;
    v24 = (char *)v13[1];
    if (v24 != *v13)
    {
      do
      {
        v26 = *(_OWORD *)(v24 - 24);
        *(v22 - 8) = *(v24 - 8);
        *(_OWORD *)(v22 - 24) = v26;
        v22 -= 24;
        v24 -= 24;
      }
      while (v24 != v25);
      v24 = (char *)*v13;
    }
    *v13 = v22;
    v13[1] = v16;
    v13[2] = v23;
    if (v24)
      operator delete(v24);
  }
  else
  {
    *(_QWORD *)v14 = a2;
    *((_QWORD *)v14 + 1) = a3;
    v16 = v14 + 24;
    v14[16] = a4;
  }
  v13[1] = v16;
}

OZChannelImpl *OZChannelImpl::unregisterRecordingCallback(OZChannelImpl *this, void (*a2)(OZChannelBase *, const CMTime *, void *), void *a3)
{
  unint64_t *v5;
  OZChannelImpl *v7;
  void *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v5 = (unint64_t *)((char *)this + 24);
  if (!atomic_load((unint64_t *)this + 3))
  {
    this = (OZChannelImpl *)operator new();
    v7 = this;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
    *(_QWORD *)this = 0;
    while (!__ldaxr(v5))
    {
      if (!__stlxr((unint64_t)this, v5))
        goto LABEL_9;
    }
    __clrex();
    v9 = *(void **)this;
    if (*(_QWORD *)v7)
    {
      *((_QWORD *)v7 + 1) = v9;
      operator delete(v9);
    }
    this = (OZChannelImpl *)MEMORY[0x1B5E29170](v7, 0x20C40960023A9);
  }
LABEL_9:
  v10 = (uint64_t *)atomic_load(v5);
  v11 = *v10;
  v12 = atomic_load(v5);
  if (v11 != *(_QWORD *)(v12 + 8))
  {
    v13 = -v11;
    while (*(void (**)(OZChannelBase *, const CMTime *, void *))v11 != a2 || *(void **)(v11 + 8) != a3)
    {
      v11 += 24;
      v14 = atomic_load(v5);
      v13 -= 24;
      if (v11 == *(_QWORD *)(v14 + 8))
        return this;
    }
    v15 = atomic_load(v5);
    v16 = -v13;
    v17 = *(_QWORD *)(v15 + 8);
    v18 = v17 - (24 - v13);
    if (v17 != 24 - v13)
      this = (OZChannelImpl *)memmove((void *)-v13, (const void *)(24 - v13), v18 - 7);
    *(_QWORD *)(v15 + 8) = v16 + v18;
    atomic_load(v5);
  }
  return this;
}

uint64_t OZChannelImpl::setMin(OZChannelImpl *this, double a2)
{
  return (*(uint64_t (**)(_QWORD, double))(**((_QWORD **)this + 1) + 280))(*((_QWORD *)this + 1), a2);
}

uint64_t OZChannelImpl::setMax(OZChannelImpl *this, double a2)
{
  return (*(uint64_t (**)(_QWORD, double))(**((_QWORD **)this + 1) + 272))(*((_QWORD *)this + 1), a2);
}

uint64_t OZChannelImpl::setDiscrete(OZChannelImpl *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 168))(*((_QWORD *)this + 1));
}

uint64_t OZChannelImpl::setParametric(OZChannelImpl *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 104))(*((_QWORD *)this + 1));
}

uint64_t OZChannelImpl::setInterpolation(OZChannelImpl *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 296))(*((_QWORD *)this + 1));
}

uint64_t OZChannelImpl::setShouldCreateTangents(OZChannelImpl *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 136))(*((_QWORD *)this + 1));
}

void sub_1B2C3662C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  uint64_t v10;

  PCString::~PCString(&a10);
  MEMORY[0x1B5E29170](v10, 0x10E1C4011F1C4E7);
  _Unwind_Resume(a1);
}

void OZBezierInterpolator::OZBezierInterpolator(OZBezierInterpolator *this)
{
  _QWORD *v1;

  OZSplineInterpolator::OZSplineInterpolator(this);
  *v1 = &off_1E6554E18;
  v1[1] = 0x3FF0000000000000;
}

void OZBezierInterpolator::~OZBezierInterpolator(OZBezierInterpolator *this)
{
  OZEaseInInterpolator::~OZEaseInInterpolator(this);
  JUMPOUT(0x1B5E29170);
}

uint64_t OZBezierInterpolator::computeTangents(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t result;

  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a3 + 64))(a3, a6, a7, a5);
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a4 + 56))(a4, a8, a9, a5);
  if (!**(_BYTE **)(a2 + 168))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, a2, a6, a7);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, a2, a8, a9);
  }
  return result;
}

double OZBezierInterpolator::getControlPoints(OZBezierInterpolator *this, OZSpline *a2, void *a3, void *a4, const CMTime *a5, CMTime *a6, CMTime *a7, double *a8, double *a9)
{
  __int128 v17;
  __int128 v18;
  double *v19;
  double Seconds;
  int8x16_t v21;
  int8x16_t v22;
  double v23;
  double v24;
  double v25;
  double result;
  _BYTE *v27;
  CMTime time;
  CMTime v29;
  __int128 v30;
  CMTimeEpoch v31;
  CMTime time2;
  CMTime time1;

  v17 = *((_OWORD *)a3 + 1);
  a6->epoch = *((_QWORD *)a3 + 4);
  *(_OWORD *)&a6->value = v17;
  v18 = *((_OWORD *)a4 + 1);
  a7->epoch = *((_QWORD *)a4 + 4);
  *(_OWORD *)&a7->value = v18;
  time1 = *a6;
  time2 = *a7;
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    OZSpline::getSmallDeltaU(a2, &v29);
    time1 = *a6;
    time2 = v29;
    PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v30);
    *(_OWORD *)&a7->value = v30;
    a7->epoch = v31;
  }
  *a9 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)a3 + 24))(a3, a5);
  a9[3] = (*(double (**)(void *, const CMTime *))(*(_QWORD *)a4 + 24))(a4, a5);
  *a8 = 0.0;
  a8[3] = 1.0;
  (*(void (**)(OZBezierInterpolator *, OZSpline *, void *, void *, const CMTime *, double *, double *, double *, double *))(*(_QWORD *)this + 128))(this, a2, a3, a4, a5, a8 + 1, a9 + 1, a8 + 2, a9 + 2);
  time1 = *a7;
  time2 = *a6;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&time);
  Seconds = CMTimeGetSeconds(&time);
  v22.i64[0] = 0x3EE4F8B580000000;
  if (Seconds >= 0.00000999999975)
    *(double *)v22.i64 = Seconds;
  v23 = a8[2];
  v24 = *((double *)this + 1) * a8[1];
  a8[1] = v24;
  *(double *)v21.i64 = *((double *)this + 1) * v23;
  a8[1] = v24 / *(double *)v22.i64;
  a8[2] = (Seconds + *(double *)v21.i64) / *(double *)v22.i64;
  a9[1] = *a9 + a9[1] * *((double *)this + 1);
  v25 = *((double *)this + 1);
  *(double *)v22.i64 = a9[2] * v25;
  result = a9[3] + *(double *)v22.i64;
  a9[2] = result;
  v27 = (_BYTE *)*((_QWORD *)a2 + 21);
  if (!*v27)
  {
    if (v27[3])
      return OZBezierSanitizeControlPolygon(a8, a9, v19, result, v22, v25, v21);
  }
  return result;
}

void OZBezierInterpolator::interpolate(OZBezierInterpolator *this, OZSpline *a2, const CMTime *a3, void *a4, void *a5, const CMTime *a6, char a7, char a8)
{
  double Seconds;
  double v14;
  uint64_t v15;
  double *v16;
  double *v17;
  __n128 v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  double v22;
  const CMTime *v23;
  CMTime v24;
  CMTime v25;
  CMTime v26;
  CMTime v27;
  CMTime time;
  CMTime v29;
  CMTime v30;
  CMTime v31;
  CMTime time2;
  CMTime time1;
  double v34[4];
  double v35[5];

  v35[4] = *(double *)MEMORY[0x1E0C80C00];
  v30 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  v29 = v30;
  OZBezierInterpolator::getControlPoints(this, a2, a4, a5, a3, &v30, &v29, v35, v34);
  v31 = *a6;
  time1 = v29;
  time2 = v30;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&time);
  Seconds = CMTimeGetSeconds(&time);
  if (Seconds >= 0.00000999999975)
    v14 = Seconds;
  else
    v14 = 0.00000999999975;
  time1 = v31;
  time2 = v30;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v27);
  v18.n128_f64[0] = CMTimeGetSeconds(&v27);
  if ((a8 & 1) != 0)
  {
    memset(&v26, 0, sizeof(v26));
    CMTimeMake(&v25, 1, 1000);
    time1 = *a6;
    time2 = v25;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v26);
    memset(&v25, 0, sizeof(v25));
    CMTimeMake(&v24, 1, 1000);
    time1 = *a6;
    time2 = v24;
    v22 = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v25);
    v23 = (const CMTime *)MEMORY[0x1E0CA2E68];
    (*(void (**)(OZSpline *, CMTime *, _QWORD, _QWORD, double))(*(_QWORD *)a2 + 240))(a2, &v26, MEMORY[0x1E0CA2E68], 0, v22);
    (*(void (**)(OZSpline *, CMTime *, const CMTime *, _QWORD))(*(_QWORD *)a2 + 240))(a2, &v25, v23, 0);
    OZSpline::getMinValueU(a2, v23, 0, (uint64_t)&v24);
    time1 = v26;
    time2 = v24;
    if (CMTimeCompare(&time1, &time2) < 0
      || (OZSpline::getMaxValueU(a2, MEMORY[0x1E0CA2E68], 0, (uint64_t)&v24),
          time1 = v25,
          time2 = v24,
          CMTimeCompare(&time1, &time2) >= 1))
    {
      (*(double (**)(OZSpline *, const CMTime *, _QWORD, _QWORD))(*(_QWORD *)a2 + 240))(a2, a6, MEMORY[0x1E0CA2E68], 0);
    }
  }
  else
  {
    v18.n128_f64[0] = v18.n128_f64[0] / v14;
    if ((a7 & 1) == 0)
      v18.n128_f64[0] = OZBezierFindParameter(v35, v18.n128_f64[0], v19, v20, v21, v15, v16, v17);
    (*(void (**)(OZBezierInterpolator *, double *, __n128))(*(_QWORD *)this + 112))(this, v34, v18);
  }
}

double OZBezierInterpolator::eval(OZBezierInterpolator *this, const double *a2, double a3)
{
  return OZBezierEval(a2, a3);
}

uint64_t OZBezierInterpolator::eval(OZBezierInterpolator *this, OZSpline *a2, const CMTime *a3, char *a4, _BYTE **a5, double a6)
{
  int32_t v12;
  uint64_t v13;
  uint64_t v14;
  float64x2_t v15;
  CMTime v17;
  CMTime time1;
  double v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  time1 = *(CMTime *)(a4 + 16);
  v17 = *(CMTime *)(a5 + 2);
  v12 = CMTimeCompare(&time1, &v17);
  if (v12 <= 0)
    v13 = 64;
  else
    v13 = 56;
  if (v12 <= 0)
    v14 = 56;
  else
    v14 = 64;
  (*(void (**)(char *, _QWORD, CMTimeScale *, const CMTime *))(*(_QWORD *)a4 + v13))(a4, 0, &time1.timescale, a3);
  (*(void (**)(_BYTE **, _QWORD, CMTimeEpoch *, const CMTime *))&(*a5)[v14])(a5, 0, &time1.epoch, a3);
  if (!**((_BYTE **)a2 + 21))
  {
    (*(void (**)(OZBezierInterpolator *, OZSpline *, _QWORD, CMTimeScale *))(*(_QWORD *)this + 48))(this, a2, 0, &time1.timescale);
    (*(void (**)(OZBezierInterpolator *, OZSpline *, _QWORD, CMTimeEpoch *))(*(_QWORD *)this + 48))(this, a2, 0, &time1.epoch);
  }
  time1.value = (*(double (**)(char *, const CMTime *))(*(_QWORD *)a4 + 24))(a4, a3);
  v19 = (*((double (**)(_BYTE **, const CMTime *))*a5 + 3))(a5, a3);
  *(_QWORD *)&v15.f64[0] = time1.value;
  v15.f64[1] = v19;
  *(float64x2_t *)&time1.timescale = vaddq_f64(v15, vmulq_n_f64(*(float64x2_t *)&time1.timescale, *((double *)this + 1)));
  return (*(uint64_t (**)(OZBezierInterpolator *, CMTime *, double))(*(_QWORD *)this + 112))(this, &time1, a6);
}

uint64_t OZBezierInterpolator::subDivide(OZBezierInterpolator *this, OZSpline *a2, const CMTime *a3, char *a4, char *a5, _BYTE **a6)
{
  __n128 v12;
  double Seconds;
  float64x2_t v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  __n128 v20;
  uint64_t v21;
  uint64_t v22;
  CMTime v24;
  CMTime time;
  CMTime v26;
  CMTime v27;
  CMTime v28;
  double v29;
  CMTime v30;
  unint64_t v31;
  CMTime time2;
  double v33;
  CMTime time1;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v27 = *(CMTime *)(a4 + 16);
  v26 = *(CMTime *)(a5 + 16);
  time1 = *(CMTime *)(a4 + 16);
  time2 = *(CMTime *)(a5 + 16);
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    OZSpline::getSmallDeltaU(a2, &v30);
    time1 = v27;
    time2 = v30;
    v12.n128_f64[0] = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v26);
  }
  time2.value = (*(double (**)(char *, const CMTime *, __n128))(*(_QWORD *)a4 + 24))(a4, a3, v12);
  v33 = (*(double (**)(char *, const CMTime *))(*(_QWORD *)a5 + 24))(a5, a3);
  time1.value = 0;
  v35 = 0x3FF0000000000000;
  (*(void (**)(char *, CMTimeScale *, CMTimeScale *, const CMTime *))(*(_QWORD *)a4 + 64))(a4, &time1.timescale, &time2.timescale, a3);
  (*(void (**)(char *, CMTimeEpoch *, CMTimeEpoch *, const CMTime *))(*(_QWORD *)a5 + 56))(a5, &time1.epoch, &time2.epoch, a3);
  if (!**((_BYTE **)a2 + 21))
  {
    (*(void (**)(OZBezierInterpolator *, OZSpline *, CMTimeScale *, CMTimeScale *))(*(_QWORD *)this + 48))(this, a2, &time1.timescale, &time2.timescale);
    (*(void (**)(OZBezierInterpolator *, OZSpline *, CMTimeEpoch *, CMTimeEpoch *))(*(_QWORD *)this + 48))(this, a2, &time1.epoch, &time2.epoch);
  }
  v30 = v26;
  v28 = v27;
  PC_CMTimeSaferSubtract(&v30, &v28, (uint64_t)&time);
  Seconds = CMTimeGetSeconds(&time);
  *(double *)&time1.timescale = *(double *)&time1.timescale / Seconds;
  *(double *)&time1.epoch = (Seconds + *(double *)&time1.epoch) / Seconds;
  *(_QWORD *)&v14.f64[0] = time2.value;
  v14.f64[1] = v33;
  *(float64x2_t *)&time2.timescale = vaddq_f64(v14, vmulq_n_f64(*(float64x2_t *)&time2.timescale, *((double *)this + 1)));
  v30 = *(CMTime *)(a6 + 2);
  v28 = v27;
  PC_CMTimeSaferSubtract(&v30, &v28, (uint64_t)&v24);
  v20.n128_f64[0] = CMTimeGetSeconds(&v24) / Seconds;
  v15 = *(double *)&time2.value + v20.n128_f64[0] * (*(double *)&time2.timescale - *(double *)&time2.value);
  v16 = *(double *)&time2.timescale + v20.n128_f64[0] * (*(double *)&time2.epoch - *(double *)&time2.timescale);
  v17 = (1.0 - v20.n128_f64[0]) * v15 + v20.n128_f64[0] * v16;
  v18 = *(double *)&time2.epoch + v20.n128_f64[0] * (v33 - *(double *)&time2.epoch);
  v19 = (1.0 - v20.n128_f64[0]) * v16 + v20.n128_f64[0] * v18;
  v20.n128_f64[0] = (1.0 - v20.n128_f64[0]) * v17 + v20.n128_f64[0] * v19;
  v30.value = time2.value;
  *(double *)&v30.timescale = v15 - *(double *)&time2.value;
  *(double *)&v30.epoch = v17 - v20.n128_f64[0];
  v31 = v20.n128_u64[0];
  v28.value = v20.n128_u64[0];
  *(double *)&v28.timescale = v19 - v20.n128_f64[0];
  *(double *)&v28.epoch = v18 - v33;
  v29 = v33;
  if (!**((_BYTE **)a2 + 21))
  {
    (*(void (**)(OZBezierInterpolator *, OZSpline *, _QWORD, CMTimeEpoch *))(*(_QWORD *)this + 40))(this, a2, 0, &v30.epoch);
    (*(void (**)(OZBezierInterpolator *, OZSpline *, _QWORD, CMTimeScale *))(*(_QWORD *)this + 40))(this, a2, 0, &v30.timescale);
    (*(void (**)(OZBezierInterpolator *, OZSpline *, _QWORD, CMTimeEpoch *))(*(_QWORD *)this + 40))(this, a2, 0, &v28.epoch);
    (*(void (**)(OZBezierInterpolator *, OZSpline *, _QWORD, CMTimeScale *))(*(_QWORD *)this + 40))(this, a2, 0, &v28.timescale);
    v20.n128_u64[0] = v31;
  }
  (*((void (**)(_BYTE **, const CMTime *, __n128))*a6 + 4))(a6, a3, v20);
  (*((void (**)(_BYTE **, const CMTime *, double, double))*a6 + 9))(a6, a3, 1.0, *(double *)&v30.epoch);
  (*((void (**)(_BYTE **, const CMTime *, double, double))*a6 + 10))(a6, a3, 1.0, *(double *)&v28.timescale);
  v21 = (*(uint64_t (**)(char *))(*(_QWORD *)a4 + 168))(a4);
  (*(void (**)(char *, uint64_t))(*(_QWORD *)a4 + 160))(a4, 2);
  (*(void (**)(char *, const CMTime *, double, double))(*(_QWORD *)a4 + 80))(a4, a3, 1.0, *(double *)&v30.timescale);
  (*(void (**)(char *, uint64_t))(*(_QWORD *)a4 + 176))(a4, v21);
  v22 = (*(uint64_t (**)(char *))(*(_QWORD *)a5 + 168))(a5);
  (*(void (**)(char *, uint64_t))(*(_QWORD *)a5 + 160))(a5, 2);
  (*(void (**)(char *, const CMTime *, double, double))(*(_QWORD *)a5 + 72))(a5, a3, 1.0, *(double *)&v28.epoch);
  return (*(uint64_t (**)(char *, uint64_t))(*(_QWORD *)a5 + 176))(a5, v22);
}

void OZBezierInterpolator::getMinMaxValues(OZBezierInterpolator *this, OZSpline *a2, void *a3, void *a4, const CMTime *a5, const CMTime *a6, double *a7, double *a8)
{
  double Parameter;
  double Seconds;
  Float64 v15;
  uint64_t v16;
  double *v17;
  double *v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  double v22;
  Float64 v23;
  uint64_t v24;
  double *v25;
  double *v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  double v30;
  double *v31;
  double v32;
  int8x16_t v33;
  int8x16_t v34;
  int v35;
  double v36;
  double v37;
  double *v38;
  double v39;
  CMTime v40;
  CMTime v41;
  CMTime v42;
  CMTime time;
  CMTime v44;
  CMTime v45;
  CMTime time2;
  CMTime time1;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52[5];

  v52[4] = *(double *)MEMORY[0x1E0C80C00];
  OZBezierInterpolator::getControlPoints(this, a2, a3, a4, MEMORY[0x1E0CA2E68], &v45, &v44, v52, &v48);
  time1 = v45;
  time2 = *a5;
  Parameter = 0.0;
  if (CMTimeCompare(&time1, &time2) < 0)
  {
    time1 = *a5;
    time2 = v45;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&time);
    Seconds = CMTimeGetSeconds(&time);
    time1 = v44;
    time2 = v45;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v42);
    v15 = CMTimeGetSeconds(&v42);
    Parameter = OZBezierFindParameter(v52, Seconds / v15, v19, v20, v21, v16, v17, v18);
  }
  time1 = v44;
  time2 = *a6;
  if (CMTimeCompare(&time1, &time2) < 1)
  {
    v30 = 1.0;
  }
  else
  {
    time1 = *a6;
    time2 = v45;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v41);
    v22 = CMTimeGetSeconds(&v41);
    time1 = v44;
    time2 = v45;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v40);
    v23 = CMTimeGetSeconds(&v40);
    v30 = OZBezierFindParameter(v52, v22 / v23, v27, v28, v29, v24, v25, v26);
  }
  *a7 = (*(double (**)(OZBezierInterpolator *, double *, double))(*(_QWORD *)this + 112))(this, &v48, Parameter);
  v32 = (*(double (**)(OZBezierInterpolator *, double *, double))(*(_QWORD *)this + 112))(this, &v48, v30);
  *a8 = v32;
  v34.i64[0] = *(uint64_t *)a7;
  if (*a7 > v32)
  {
    *a7 = v32;
    *a8 = *(double *)v34.i64;
  }
  *(double *)v34.i64 = v48 * 6.0 + v49 * -12.0 + v50 * 6.0;
  time1.value = 0;
  time2.value = 0;
  v33.i64[0] = 0;
  v35 = PCMath::quadratic((PCMath *)&time1, v48 * -3.0 + v49 * 9.0 - v50 * 9.0 + v51 * 3.0, v34, v48 * -3.0 + v49 * 3.0, (double *)&time2.value, v31, v33);
  if (v35 == 2)
  {
    if (*(double *)&time1.value >= Parameter && *(double *)&time1.value <= v30)
    {
      v37 = (*(double (**)(OZBezierInterpolator *, double *))(*(_QWORD *)this + 112))(this, &v48);
      v38 = a7;
      if (v37 < *a7 || (v38 = a8, v37 > *a8))
        *v38 = v37;
    }
    v36 = *(double *)&time2.value;
  }
  else
  {
    if (v35 != 1)
      return;
    v36 = *(double *)&time1.value;
  }
  if (v36 >= Parameter && v36 <= v30)
  {
    v39 = (*(double (**)(OZBezierInterpolator *, double *))(*(_QWORD *)this + 112))(this, &v48);
    if (v39 >= *a7)
    {
      if (v39 > *a8)
        *a8 = v39;
    }
    else
    {
      *a7 = v39;
    }
  }
}

BOOL OZBezierInterpolator::uForCurveValue(OZBezierInterpolator *a1, OZSpline *a2, void *a3, void *a4, CMTime *a5, CMTime *a6, void **a7, double a8)
{
  double *v13;
  double *v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int Roots;
  double Seconds;
  uint64_t i;
  double v21;
  double v22;
  char *v23;
  char *v24;
  __int128 v25;
  char *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  char *v32;
  __int128 v33;
  char *v34;
  char *v35;
  char *v36;
  __int128 v37;
  CMTime v39;
  CMTime v40;
  CMTime time;
  CMTime v42;
  CMTime v43;
  CMTime time2;
  CMTime time1;
  double v46[3];
  double v47[4];
  double v48[7];

  v48[4] = *(double *)MEMORY[0x1E0C80C00];
  v43 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  v42 = v43;
  OZBezierInterpolator::getControlPoints(a1, a2, a3, a4, MEMORY[0x1E0CA2E68], &v43, &v42, v48, v47);
  Roots = OZBezierGetRoots(v47, a8, v46, v13, v14, v15, v16, v17);
  if (!Roots)
    return 0;
  time1 = v42;
  time2 = v43;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&time);
  Seconds = CMTimeGetSeconds(&time);
  for (i = 0; i != Roots; ++i)
  {
    v21 = v46[i];
    if ((v21 > 0.0 || fabs(v21) < 0.0000001) && (v21 < 1.0 || fabs(v21 + -1.0) < 0.0000001))
    {
      memset(&v40, 0, sizeof(v40));
      v22 = (*(double (**)(OZBezierInterpolator *, double *))(*(_QWORD *)a1 + 112))(a1, v48);
      OZFigTimeForChannelSeconds(&v39, Seconds * v22, 0x40000);
      time1 = v43;
      time2 = v39;
      PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v40);
      time1 = v40;
      time2 = *a5;
      if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
      {
        time1 = v40;
        time2 = *a6;
        if (CMTimeCompare(&time1, &time2) <= 0)
        {
          v24 = (char *)a7[1];
          v23 = (char *)a7[2];
          if (v24 >= v23)
          {
            v27 = 0xAAAAAAAAAAAAAAABLL * ((v24 - (_BYTE *)*a7) >> 3);
            v28 = v27 + 1;
            if (v27 + 1 > 0xAAAAAAAAAAAAAAALL)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v29 = 0xAAAAAAAAAAAAAAABLL * ((v23 - (_BYTE *)*a7) >> 3);
            if (2 * v29 > v28)
              v28 = 2 * v29;
            if (v29 >= 0x555555555555555)
              v30 = 0xAAAAAAAAAAAAAAALL;
            else
              v30 = v28;
            if (v30)
              v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a7 + 2), v30);
            else
              v31 = 0;
            v32 = &v31[24 * v27];
            v33 = *(_OWORD *)&v40.value;
            *((_QWORD *)v32 + 2) = v40.epoch;
            *(_OWORD *)v32 = v33;
            v35 = (char *)*a7;
            v34 = (char *)a7[1];
            v36 = v32;
            if (v34 != *a7)
            {
              do
              {
                v37 = *(_OWORD *)(v34 - 24);
                *((_QWORD *)v36 - 1) = *((_QWORD *)v34 - 1);
                *(_OWORD *)(v36 - 24) = v37;
                v36 -= 24;
                v34 -= 24;
              }
              while (v34 != v35);
              v34 = (char *)*a7;
            }
            v26 = v32 + 24;
            *a7 = v36;
            a7[1] = v32 + 24;
            a7[2] = &v31[24 * v30];
            if (v34)
              operator delete(v34);
          }
          else
          {
            v25 = *(_OWORD *)&v40.value;
            *((_QWORD *)v24 + 2) = v40.epoch;
            *(_OWORD *)v24 = v25;
            v26 = v24 + 24;
          }
          a7[1] = v26;
        }
      }
    }
  }
  return *a7 != a7[1];
}

__n128 OZInterpolator::easeTime@<Q0>(__n128 *a1@<X2>, __n128 *a2@<X8>)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  return result;
}

double OZBezierEval(const double *a1, double a2)
{
  return *a1
       + (a1[1] * 3.0
        - *a1 * 3.0
        + (*a1 * 3.0 + a1[1] * -6.0 + a1[2] * 3.0 + (a1[3] + a1[1] * 3.0 - *a1 - a1[2] * 3.0) * a2) * a2)
       * a2;
}

double OZBezierSanitizeControlPolygon(double *a1, double *a2, double *a3, double a4, int8x16_t a5, double a6, int8x16_t a7)
{
  double v7;
  double v8;
  double result;
  double v10;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  BOOL v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  uint64_t v28;
  uint64_t v29;

  a7.i64[0] = (uint64_t)a1[1];
  v7 = *a1 * -3.0;
  v8 = a1[2];
  result = v7 + *(double *)a7.i64 * 9.0 - v8 * 9.0 + a1[3] * 3.0;
  if (result > 0.0)
  {
    *(double *)a5.i64 = *a1 * 6.0 + *(double *)a7.i64 * -12.0 + v8 * 6.0;
    v10 = -*(double *)a5.i64 / (result + result);
    if (v10 >= 0.0 && v10 <= 1.0)
    {
      v14 = v7 + *(double *)a7.i64 * 3.0;
      v28 = 0;
      v29 = 0;
      a7.i64[0] = 0;
      if (PCMath::quadratic((PCMath *)&v29, result, a5, v14, (double *)&v28, a3, a7) == 2)
      {
        v15 = *a1;
        v16 = a1[1] - *a1;
        v17 = a1[3];
        v18 = v17 - a1[2];
        v19 = 0.5;
        if (vabdd_f64(v16, v18) >= 0.0000001)
        {
          v20 = (v16 - sqrt(v16 * v18)) / (v16 - v18);
          v21 = 1.0;
          if (v20 <= 1.0)
            v21 = v20;
          v22 = v20 < 0.0;
          v19 = 0.0;
          if (!v22)
            v19 = v21;
        }
        v23 = (1.0 - v19 * 3.0 + v19 * (v19 * 3.0)) / (v17 - v15);
        v24 = v15 + v19 * v19 / v23;
        v25 = v15 + (v19 * (v19 + v19) - v19) / v23;
        v26 = (v24 - v15) / v16;
        if (v18 > v16)
          v26 = (v17 - v25) / v18;
        a1[1] = v24;
        a1[2] = v25;
        v27 = *a2 + v26 * (a2[1] - *a2);
        result = a2[3] + v26 * (a2[2] - a2[3]);
        a2[1] = v27;
        a2[2] = result;
      }
    }
  }
  return result;
}

uint64_t OZBezierGetRoots(double *a1, double a2, double *a3, double *a4, double *a5, int8x16_t a6, int8x16_t a7, int8x16_t a8)
{
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;

  a7.i64[0] = *(uint64_t *)a1;
  v8 = a1[1];
  *(double *)a6.i64 = v8 * 3.0;
  v9 = a1[2] * 3.0;
  v10 = a1[3] + v8 * 3.0 - *a1 - v9;
  v11 = *a1 * 3.0;
  v12 = v11 + v8 * -6.0 + v9;
  if (v10 <= -0.0000001 || v10 >= 0.0000001)
  {
    *(double *)a7.i64 = (*(double *)a7.i64 - a2) / v10;
    return PCMath::cubic((PCMath *)a3, v12 / v10, (*(double *)a6.i64 - v11) / v10, a7, a3 + 1, a3 + 2, a5);
  }
  else
  {
    *(double *)a6.i64 = *(double *)a6.i64 - v11;
    a8.i64[0] = 0;
    return PCMath::quadratic((PCMath *)a3, v12, a6, *(double *)a7.i64 - a2, a3 + 1, a4, a8);
  }
}

double OZBezierFindParameter(double *a1, double a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, uint64_t a6, double *a7, double *a8)
{
  int Roots;
  double result;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  _BOOL4 v17;
  _BOOL4 v18;
  BOOL v19;
  double v20;
  double v21;
  double v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  Roots = OZBezierGetRoots(a1, a2, &v20, a7, a8, a3, a4, a5);
  if (Roots == 3)
  {
    result = v20;
    v11 = 0.0;
    v12 = v20 + -1.0;
    if (v20 <= 1.0)
      v12 = 0.0;
    if (v20 < 0.0)
      v12 = 0.0 - v20;
    if (v21 >= 0.0)
    {
      if (v21 > 1.0)
        v11 = v21 + -1.0;
    }
    else
    {
      v11 = 0.0 - v21;
    }
    if (v12 >= v11)
    {
      v16 = 0.0;
      if (v22 >= 0.0)
      {
        if (v22 > 1.0)
          v16 = v22 + -1.0;
      }
      else
      {
        v16 = 0.0 - v22;
      }
      v17 = v22 < 0.0;
      v18 = v21 < 0.0;
      v19 = v11 < v16;
      if (v11 >= v16)
        result = v22;
      else
        result = v21;
    }
    else
    {
      v14 = 0.0;
      if (v22 >= 0.0)
      {
        if (v22 > 1.0)
          v14 = v22 + -1.0;
      }
      else
      {
        v14 = 0.0 - v22;
      }
      v17 = v22 < 0.0;
      v18 = v20 < 0.0;
      v19 = v12 < v14;
      if (v12 >= v14)
        result = v22;
    }
  }
  else
  {
    if (Roots != 2)
    {
      result = 0.0;
      if (Roots == 1)
      {
        v10 = 1.0;
        if (v20 <= 1.0)
          v10 = v20;
        result = 0.0;
        if (v20 >= 0.0)
          return v10;
      }
      return result;
    }
    result = v20;
    v13 = 0.0;
    if (v20 >= 0.0)
    {
      if (v20 > 1.0)
        v13 = v20 + -1.0;
    }
    else
    {
      v13 = 0.0 - v20;
    }
    v15 = 0.0;
    if (v21 >= 0.0)
    {
      if (v21 > 1.0)
        v15 = v21 + -1.0;
    }
    else
    {
      v15 = 0.0 - v21;
    }
    v17 = v21 < 0.0;
    v18 = v20 < 0.0;
    v19 = v13 < v15;
    if (v13 >= v15)
      result = v21;
  }
  if (v19)
    v17 = v18;
  if (result > 1.0)
    result = 1.0;
  if (v17)
    return 0.0;
  return result;
}

void OZBSplineInterpolator::OZBSplineInterpolator(OZBSplineInterpolator *this)
{
  uint64_t v1;

  OZInterpolator::OZInterpolator(this);
  *(_QWORD *)v1 = &off_1E6554EC8;
  *(_QWORD *)(v1 + 8) = 0;
  *(_QWORD *)(v1 + 16) = 0;
  *(_QWORD *)(v1 + 24) = 0;
  *(_OWORD *)(v1 + 40) = 0u;
  *(_OWORD *)(v1 + 56) = 0u;
  *(_OWORD *)(v1 + 72) = 0u;
  *(_OWORD *)(v1 + 88) = 0u;
  *(_QWORD *)(v1 + 104) = 0;
  *(_DWORD *)(v1 + 112) = 4;
  *(_DWORD *)(v1 + 32) = 0;
  *(_BYTE *)(v1 + 116) = 0;
}

void OZBSplineInterpolator::OZBSplineInterpolator(OZBSplineInterpolator *this, const OZBSplineInterpolator *a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;

  OZInterpolator::OZInterpolator(this);
  *(_QWORD *)v4 = &off_1E6554EC8;
  *(_QWORD *)(v4 + 8) = 0;
  v5 = (char *)(v4 + 8);
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 24) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  v6 = (char *)(v4 + 40);
  *(_OWORD *)(v4 + 88) = 0u;
  v7 = (char *)(v4 + 88);
  *(_OWORD *)(v4 + 56) = 0u;
  *(_OWORD *)(v4 + 72) = 0u;
  *(_QWORD *)(v4 + 104) = 0;
  *(_DWORD *)(v4 + 112) = *((_DWORD *)a2 + 28);
  if ((const OZBSplineInterpolator *)v4 != a2)
  {
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)this + 64, *((char **)a2 + 8), *((_QWORD *)a2 + 9), (uint64_t)(*((_QWORD *)a2 + 9) - *((_QWORD *)a2 + 8)) >> 3);
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(v7, *((char **)a2 + 11), *((_QWORD *)a2 + 12), (uint64_t)(*((_QWORD *)a2 + 12) - *((_QWORD *)a2 + 11)) >> 3);
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(v5, *((char **)a2 + 1), *((_QWORD *)a2 + 2), (uint64_t)(*((_QWORD *)a2 + 2) - *((_QWORD *)a2 + 1)) >> 3);
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(v6, *((char **)a2 + 5), *((_QWORD *)a2 + 6), (uint64_t)(*((_QWORD *)a2 + 6) - *((_QWORD *)a2 + 5)) >> 3);
  }
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  *((_BYTE *)this + 116) = *((_BYTE *)a2 + 116);
}

void sub_1B2C3809C(_Unwind_Exception *a1)
{
  OZChannelBase *v1;
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  __CFString *v7;
  const PCString *v8;

  v7 = (__CFString *)*v4;
  if (*v4)
  {
    v1->var12 = v7;
    operator delete(v7);
  }
  OZBSplineInterpolator::OZBSplineInterpolator(v5, v3, v2, v1);
  OZChannelBase::setRangeName(v1, v8);
  _Unwind_Resume(a1);
}

void OZBSplineInterpolator::~OZBSplineInterpolator(OZChannelBase *this, const PCString *a2)
{
  __CFString *var11;
  void *var8;
  PCString *var5;
  void **var1;

  this->var0 = (void **)&off_1E6554EC8;
  var11 = this->var11;
  if (var11)
  {
    this->var12 = var11;
    operator delete(var11);
  }
  var8 = (void *)this->var8;
  if (var8)
  {
    this->var9 = var8;
    operator delete(var8);
  }
  var5 = this->var5;
  if (var5)
  {
    this->var6 = (OZChannelFolder *)var5;
    operator delete(var5);
  }
  var1 = (void **)this->var1;
  if (var1)
  {
    this->var2 = var1;
    operator delete(var1);
  }
  OZChannelBase::setRangeName(this, a2);
}

{
  OZBSplineInterpolator::~OZBSplineInterpolator(this, a2);
  JUMPOUT(0x1B5E29170);
}

BOOL OZBSplineInterpolator::operator==(uint64_t a1, uint64_t a2)
{
  double *v2;
  double *v3;
  double *v4;
  double *v5;
  double *v6;
  double *v7;
  double *v8;
  double *v9;
  double *v10;
  uint64_t v11;
  uint64_t v12;
  double *v13;
  uint64_t v14;
  double v15;
  _BOOL8 result;
  BOOL v17;

  if (*(_DWORD *)(a1 + 112) != *(_DWORD *)(a2 + 112))
    return 0;
  v3 = *(double **)(a1 + 64);
  v2 = *(double **)(a1 + 72);
  v4 = *(double **)(a2 + 64);
  if ((char *)v2 - (char *)v3 != *(_QWORD *)(a2 + 72) - (_QWORD)v4)
    return 0;
  while (v3 != v2)
  {
    if (*v3 != *v4)
      return 0;
    ++v3;
    ++v4;
  }
  v6 = *(double **)(a1 + 88);
  v5 = *(double **)(a1 + 96);
  v7 = *(double **)(a2 + 88);
  if ((char *)v5 - (char *)v6 != *(_QWORD *)(a2 + 96) - (_QWORD)v7)
    return 0;
  while (v6 != v5)
  {
    if (*v6 != *v7)
      return 0;
    ++v6;
    ++v7;
  }
  if (*(_DWORD *)(a1 + 32) != *(_DWORD *)(a2 + 32))
    return 0;
  v9 = *(double **)(a1 + 40);
  v8 = *(double **)(a1 + 48);
  v10 = *(double **)(a2 + 40);
  if ((char *)v8 - (char *)v9 != *(_QWORD *)(a2 + 48) - (_QWORD)v10)
    return 0;
  while (v9 != v8)
  {
    if (*v9 != *v10)
      return 0;
    ++v9;
    ++v10;
  }
  v12 = *(_QWORD *)(a1 + 8);
  v11 = *(_QWORD *)(a1 + 16);
  v13 = *(double **)(a2 + 8);
  if (v11 - v12 != *(_QWORD *)(a2 + 16) - (_QWORD)v13)
    return 0;
  if (v12 == v11)
    return 1;
  v14 = v12 + 8;
  do
  {
    v15 = *v13++;
    result = *(double *)(v14 - 8) == v15;
    v17 = *(double *)(v14 - 8) != v15 || v14 == v11;
    v14 += 8;
  }
  while (!v17);
  return result;
}

double OZBSplineInterpolator::convertBSplineBiasToLinear(OZBSplineInterpolator *this, double a2)
{
  double v2;
  double v3;

  if (a2 >= 1.0)
  {
    v2 = 25.0 - a2;
    v3 = 24.0;
  }
  else
  {
    v2 = 1.9 - a2;
    v3 = 0.9;
  }
  return v2 / v3;
}

void OZBSplineInterpolator::generateOpenKnotVector(OZBSplineInterpolator *this, OZSpline *a2)
{
  _QWORD *v3;
  int v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  double *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  double *v21;
  BOOL v22;
  double *v23;
  double v24;
  double *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  double *v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  char *v37;
  uint64_t v38;
  double *v39;
  double *v40;
  uint64_t v41;

  v3 = (_QWORD *)*((_QWORD *)this + 8);
  v4 = *((_DWORD *)this + 8);
  v5 = (*((_DWORD *)this + 28) + v4);
  *((_QWORD *)this + 9) = v3;
  v7 = (_QWORD *)((char *)this + 80);
  v6 = *((_QWORD *)this + 10);
  if ((unint64_t)v3 >= v6)
  {
    v9 = v6 - (_QWORD)v3;
    v10 = v9 >> 2;
    if ((unint64_t)(v9 >> 2) <= 1)
      v10 = 1;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v12 = std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 80, v11);
    v13 = (char *)*((_QWORD *)this + 8);
    v14 = (char *)*((_QWORD *)this + 9);
    v16 = &v12[v15];
    *v12 = 0;
    v8 = (double *)(v12 + 1);
    while (v14 != v13)
    {
      v17 = *((_QWORD *)v14 - 1);
      v14 -= 8;
      *--v12 = v17;
    }
    *((_QWORD *)this + 8) = v12;
    *((_QWORD *)this + 9) = v8;
    *((_QWORD *)this + 10) = v16;
    if (v13)
      operator delete(v13);
  }
  else
  {
    *v3 = 0;
    v8 = (double *)(v3 + 1);
  }
  *((_QWORD *)this + 9) = v8;
  if (v5 >= 2)
  {
    v18 = (v4 + 2);
    v19 = 1;
    do
    {
      v20 = v19 - 1;
      v22 = v19++ >= *((unsigned int *)this + 28);
      v21 = (double *)*((_QWORD *)this + 8);
      v22 = !v22 || v19 >= v18;
      if (v22)
      {
        if ((unint64_t)v8 >= *v7)
        {
          v26 = v8 - v21;
          v27 = v26 + 1;
          if ((unint64_t)(v26 + 1) >> 61)
            goto LABEL_56;
          v28 = *v7 - (_QWORD)v21;
          if (v28 >> 2 > v27)
            v27 = v28 >> 2;
          if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8)
            v29 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v29 = v27;
          if (v29)
          {
            v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v7, v29);
            v31 = (double *)*((_QWORD *)this + 8);
            v8 = (double *)*((_QWORD *)this + 9);
          }
          else
          {
            v30 = 0;
            v31 = (double *)*((_QWORD *)this + 8);
          }
          v37 = &v30[8 * v26];
          *(double *)v37 = v21[v20];
          v25 = (double *)(v37 + 8);
          while (v8 != v31)
          {
            v38 = *((_QWORD *)v8-- - 1);
            *((_QWORD *)v37 - 1) = v38;
            v37 -= 8;
          }
          *((_QWORD *)this + 8) = v37;
          *((_QWORD *)this + 9) = v25;
          *((_QWORD *)this + 10) = &v30[8 * v29];
          if (!v31)
            goto LABEL_54;
          v39 = v31;
          goto LABEL_53;
        }
        *v8 = v21[v20];
        v23 = v8 + 1;
      }
      else
      {
        v24 = v21[v20] + 1.0;
        if ((unint64_t)v8 >= *v7)
        {
          v32 = v8 - v21;
          v33 = v32 + 1;
          if ((unint64_t)(v32 + 1) >> 61)
LABEL_56:
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v34 = *v7 - (_QWORD)v21;
          if (v34 >> 2 > v33)
            v33 = v34 >> 2;
          if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8)
            v35 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v35 = v33;
          if (v35)
          {
            v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v7, v35);
            v21 = (double *)*((_QWORD *)this + 8);
            v8 = (double *)*((_QWORD *)this + 9);
          }
          else
          {
            v36 = 0;
          }
          v40 = (double *)&v36[8 * v32];
          *v40 = v24;
          v25 = v40 + 1;
          while (v8 != v21)
          {
            v41 = *((_QWORD *)v8-- - 1);
            *((_QWORD *)v40-- - 1) = v41;
          }
          *((_QWORD *)this + 8) = v40;
          *((_QWORD *)this + 9) = v25;
          *((_QWORD *)this + 10) = &v36[8 * v35];
          if (!v21)
            goto LABEL_54;
          v39 = v21;
LABEL_53:
          operator delete(v39);
          goto LABEL_54;
        }
        *v8 = v24;
        v23 = v8 + 1;
      }
      v25 = v23;
LABEL_54:
      *((_QWORD *)this + 9) = v25;
      v8 = v25;
    }
    while (v19 != v5);
  }
}

void OZBSplineInterpolator::generatePeriodicKnotVector(OZBSplineInterpolator *this, OZSpline *a2)
{
  void **v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  _QWORD *v7;
  double *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  int i;
  double v19;
  double *v20;
  double *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  double *v27;
  uint64_t v28;

  v3 = (void **)((char *)this + 64);
  v4 = (_QWORD *)*((_QWORD *)this + 8);
  v5 = *((_DWORD *)this + 28) + *((_DWORD *)this + 8);
  *((_QWORD *)this + 9) = v4;
  v7 = (_QWORD *)((char *)this + 80);
  v6 = *((_QWORD *)this + 10);
  if ((unint64_t)v4 >= v6)
  {
    v9 = v6 - (_QWORD)v4;
    v10 = v9 >> 2;
    if ((unint64_t)(v9 >> 2) <= 1)
      v10 = 1;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v12 = std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 80, v11);
    v13 = (char *)*((_QWORD *)this + 8);
    v14 = (char *)*((_QWORD *)this + 9);
    v16 = &v12[v15];
    *v12 = 0;
    v8 = (double *)(v12 + 1);
    while (v14 != v13)
    {
      v17 = *((_QWORD *)v14 - 1);
      v14 -= 8;
      *--v12 = v17;
    }
    *((_QWORD *)this + 8) = v12;
    *((_QWORD *)this + 9) = v8;
    *((_QWORD *)this + 10) = v16;
    if (v13)
      operator delete(v13);
  }
  else
  {
    *v4 = 0;
    v8 = (double *)(v4 + 1);
  }
  *((_QWORD *)this + 9) = v8;
  if (v5 >= 2)
  {
    for (i = 1; i != v5; ++i)
    {
      v19 = (double)i;
      if ((unint64_t)v8 >= *v7)
      {
        v21 = (double *)*v3;
        v22 = ((char *)v8 - (_BYTE *)*v3) >> 3;
        v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) >> 61)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v24 = *v7 - (_QWORD)v21;
        if (v24 >> 2 > v23)
          v23 = v24 >> 2;
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8)
          v25 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v25 = v23;
        if (v25)
        {
          v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v7, v25);
          v21 = (double *)*((_QWORD *)this + 8);
          v8 = (double *)*((_QWORD *)this + 9);
        }
        else
        {
          v26 = 0;
        }
        v27 = (double *)&v26[8 * v22];
        *v27 = v19;
        v20 = v27 + 1;
        while (v8 != v21)
        {
          v28 = *((_QWORD *)v8-- - 1);
          *((_QWORD *)v27-- - 1) = v28;
        }
        *((_QWORD *)this + 8) = v27;
        *((_QWORD *)this + 9) = v20;
        *((_QWORD *)this + 10) = &v26[8 * v25];
        if (v21)
          operator delete(v21);
      }
      else
      {
        *v8 = v19;
        v20 = v8 + 1;
      }
      *((_QWORD *)this + 9) = v20;
      v8 = v20;
    }
  }
}

uint64_t OZBSplineInterpolator::generateRationalBasisFunctions(uint64_t this, double a2)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v6;
  double *v7;
  double *v8;
  double *v9;
  void **v10;
  double *v11;
  uint64_t v12;
  double *v13;
  double v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  double v20;
  double v21;
  double v22;
  uint64_t v23;
  double v24;
  uint64_t v25;
  double *v26;
  double v27;
  double *v28;
  double v29;
  double v30;
  double v31;
  unint64_t v32;
  double v33;
  _QWORD *v34;
  double *v35;
  double v36;
  unint64_t v37;
  double *v38;
  double *v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  double *v48;
  uint64_t v49;
  uint64_t v50;

  v2 = *(_DWORD *)(this + 32);
  v3 = *(_DWORD *)(this + 112);
  v4 = (v3 + v2);
  if (v3 + v2)
  {
    v6 = this;
    v7 = (double *)operator new[]();
    v8 = v7;
    v10 = (void **)(v6 + 88);
    v9 = *(double **)(v6 + 88);
    *(_QWORD *)(v6 + 96) = v9;
    if ((_DWORD)v4 != 1)
    {
      v11 = (double *)(*(_QWORD *)(v6 + 64) + 8);
      v12 = (v4 - 1);
      v13 = v7;
      do
      {
        if (*(v11 - 1) > a2 || (v14 = 1.0, *v11 <= a2))
          v14 = 0.0;
        *v13++ = v14;
        ++v11;
        --v12;
      }
      while (v12);
    }
    v15 = *(_DWORD *)(v6 + 112);
    if (v15 >= 2)
    {
      if (v15 + 1 > 3)
        v16 = v15 + 1;
      else
        v16 = 3;
      v17 = 1;
      v18 = 2;
      do
      {
        if (v18 != v4)
        {
          v19 = 0;
          v20 = *v7;
          do
          {
            v21 = 0.0;
            v22 = 0.0;
            if (fabs(v20) >= 0.0000001)
              v22 = v20
                  * (a2 - *(double *)(*(_QWORD *)(v6 + 64) + 8 * v19))
                  / (*(double *)(*(_QWORD *)(v6 + 64) + 8 * (v17 + v19))
                   - *(double *)(*(_QWORD *)(v6 + 64) + 8 * v19));
            v20 = v7[v19 + 1];
            if (fabs(v20) >= 0.0000001)
            {
              v23 = *(_QWORD *)(v6 + 64);
              v24 = *(double *)(v23 + 8 * (v18 + v19));
              v21 = v20 * (v24 - a2) / (v24 - *(double *)(v23 + 8 * v19 + 8));
            }
            v7[v19++] = v22 + v21;
          }
          while (v19 < (v4 - v18));
        }
        ++v18;
        ++v17;
      }
      while (v18 != v16);
    }
    v25 = *(unsigned int *)(v6 + 32);
    if (vabdd_f64(a2, *(double *)(*(_QWORD *)(v6 + 64) + 8 * (v4 - 1))) < 0.0000001)
      v7[(v25 - 1)] = 1.0;
    if (!(_DWORD)v25)
LABEL_63:
      JUMPOUT(0x1B5E2914CLL);
    v26 = *(double **)(v6 + 40);
    v27 = 0.0;
    v28 = v7;
    do
    {
      v29 = *v28++;
      v30 = v29;
      v31 = *v26++;
      v27 = v27 + v30 * v31;
      --v25;
    }
    while (v25);
    v32 = 0;
    v33 = fabs(v27);
    v34 = (_QWORD *)(v6 + 104);
    while (1)
    {
      if (v33 >= 0.0000001)
      {
        v36 = v8[v32] * *(double *)(*(_QWORD *)(v6 + 40) + 8 * v32) / v27;
        v37 = *(_QWORD *)(v6 + 104);
        if ((unint64_t)v9 >= v37)
        {
          v39 = (double *)*v10;
          v45 = ((char *)v9 - (_BYTE *)*v10) >> 3;
          v46 = v45 + 1;
          if ((unint64_t)(v45 + 1) >> 61)
LABEL_62:
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v47 = v37 - (_QWORD)v39;
          if (v47 >> 2 > v46)
            v46 = v47 >> 2;
          if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF8)
            v43 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v43 = v46;
          if (v43)
          {
            v44 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v6 + 104, v43);
            v39 = *(double **)(v6 + 88);
            v9 = *(double **)(v6 + 96);
          }
          else
          {
            v44 = 0;
          }
          v48 = (double *)&v44[8 * v45];
          *v48 = v36;
          v38 = v48 + 1;
          while (v9 != v39)
          {
            v50 = *((_QWORD *)v9-- - 1);
            *((_QWORD *)v48-- - 1) = v50;
          }
          goto LABEL_57;
        }
        *v9 = v36;
        v35 = v9 + 1;
      }
      else
      {
        if ((unint64_t)v9 >= *v34)
        {
          v39 = (double *)*v10;
          v40 = ((char *)v9 - (_BYTE *)*v10) >> 3;
          v41 = v40 + 1;
          if ((unint64_t)(v40 + 1) >> 61)
            goto LABEL_62;
          v42 = *v34 - (_QWORD)v39;
          if (v42 >> 2 > v41)
            v41 = v42 >> 2;
          if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8)
            v43 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v43 = v41;
          if (v43)
          {
            v44 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v6 + 104, v43);
            v39 = *(double **)(v6 + 88);
            v9 = *(double **)(v6 + 96);
          }
          else
          {
            v44 = 0;
          }
          v48 = (double *)&v44[8 * v40];
          *v48 = 0.0;
          v38 = v48 + 1;
          while (v9 != v39)
          {
            v49 = *((_QWORD *)v9-- - 1);
            *((_QWORD *)v48-- - 1) = v49;
          }
LABEL_57:
          *(_QWORD *)(v6 + 88) = v48;
          *(_QWORD *)(v6 + 96) = v38;
          *(_QWORD *)(v6 + 104) = &v44[8 * v43];
          if (v39)
            operator delete(v39);
          goto LABEL_59;
        }
        *v9 = 0.0;
        v35 = v9 + 1;
      }
      v38 = v35;
LABEL_59:
      *(_QWORD *)(v6 + 96) = v38;
      ++v32;
      v9 = v38;
      if (v32 >= *(unsigned int *)(v6 + 32))
        goto LABEL_63;
    }
  }
  return this;
}

uint64_t OZBSplineInterpolator::useKeypoints(OZBSplineInterpolator *this)
{
  return 0;
}

CMTime *OZBSplineInterpolator::getAdjustedMaxU@<X0>(OZBSplineInterpolator *this@<X0>, OZSpline *a2@<X1>, const CMTime *a3@<X2>, const CMTime *a4@<X3>, CMTime *a5@<X8>)
{
  CMTime *result;
  unint64_t v11;
  double v12;

  result = (CMTime *)OZSpline::getNumberOfValidVerticesWithMultiplicity(a2, MEMORY[0x1E0CA2E68]);
  if ((_DWORD)result)
  {
    if ((*(unsigned int (**)(OZBSplineInterpolator *, OZSpline *))(*(_QWORD *)this + 88))(this, a2))
      (*(void (**)(OZBSplineInterpolator *, OZSpline *, const CMTime *))(*(_QWORD *)this + 16))(this, a2, a3);
    if (*((_BYTE *)a2 + 144))
    {
      LODWORD(v11) = *((_DWORD *)this + 8);
      v12 = (double)v11;
    }
    else
    {
      v12 = (double)(unint64_t)(((uint64_t)(*((_QWORD *)this + 9) - *((_QWORD *)this + 8)) >> 3) - 1);
    }
    return OZFigTimeForChannelSeconds(a5, v12, 0x40000);
  }
  else
  {
    *(_OWORD *)&a5->value = *(_OWORD *)&a4->value;
    a5->epoch = a4->epoch;
  }
  return result;
}

CMTime *OZBSplineInterpolator::getAdjustedMinU@<X0>(OZBSplineInterpolator *this@<X0>, OZSpline *a2@<X1>, const CMTime *a3@<X2>, const CMTime *a4@<X3>, CMTime *a5@<X8>)
{
  uint64_t v10;
  CMTime *result;
  CMTimeEpoch epoch;

  v10 = MEMORY[0x1E0CA2E68];
  result = (CMTime *)OZSpline::getNumberOfValidVerticesWithMultiplicity(a2, MEMORY[0x1E0CA2E68]);
  if ((_DWORD)result)
  {
    result = (CMTime *)(*(uint64_t (**)(OZBSplineInterpolator *, OZSpline *))(*(_QWORD *)this + 88))(this, a2);
    if ((_DWORD)result)
      result = (CMTime *)(*(uint64_t (**)(OZBSplineInterpolator *, OZSpline *, const CMTime *))(*(_QWORD *)this + 16))(this, a2, a3);
    if (*((_BYTE *)a2 + 144))
      return OZFigTimeForChannelSeconds(a5, (double)(*((_DWORD *)this + 28) - 1), 0x40000);
    *(_OWORD *)&a5->value = *(_OWORD *)v10;
    epoch = *(_QWORD *)(v10 + 16);
  }
  else
  {
    *(_OWORD *)&a5->value = *(_OWORD *)&a4->value;
    epoch = a4->epoch;
  }
  a5->epoch = epoch;
  return result;
}

void OZBSplineInterpolator::init(OZBSplineInterpolator *this, OZSpline *a2, const CMTime *a3)
{
  int v5;
  unsigned int NumberOfValidVerticesWithMultiplicity;
  OZSpline *v7;
  int v8;

  v5 = *((unsigned __int8 *)a2 + 144);
  NumberOfValidVerticesWithMultiplicity = OZSpline::getNumberOfValidVerticesWithMultiplicity(a2, MEMORY[0x1E0CA2E68]);
  if (v5)
  {
    *((_DWORD *)this + 8) = NumberOfValidVerticesWithMultiplicity + 3;
    *((_DWORD *)this + 28) = 4;
    OZBSplineInterpolator::generatePeriodicKnotVector(this, v7);
  }
  else
  {
    *((_DWORD *)this + 8) = NumberOfValidVerticesWithMultiplicity;
    if (NumberOfValidVerticesWithMultiplicity >= 4)
      v8 = 4;
    else
      v8 = NumberOfValidVerticesWithMultiplicity;
    *((_DWORD *)this + 28) = v8;
    OZBSplineInterpolator::generateOpenKnotVector(this, v7);
  }
  OZSpline::setDirty(a2, 0);
}

void OZBSplineInterpolator::fillTempArrays(OZBSplineInterpolator *this, OZSpline *a2, const CMTime *a3)
{
  uint64_t v6;
  void **v7;
  void **v8;
  const CMTime *v9;
  unsigned int v10;
  _QWORD *v11;
  _QWORD *v12;
  unsigned int v13;
  const CMTime *v14;
  unsigned int v15;
  uint64_t v16;
  double *v17;
  double v18;
  void *v19;
  void *v20;
  void *v21;

  v20 = 0;
  v21 = 0;
  v19 = 0;
  v7 = (void **)((char *)this + 40);
  v6 = *((_QWORD *)this + 5);
  v8 = (void **)((char *)this + 8);
  *((_QWORD *)this + 2) = *((_QWORD *)this + 1);
  *((_QWORD *)this + 6) = v6;
  if (*((_BYTE *)a2 + 144))
  {
    v9 = (const CMTime *)MEMORY[0x1E0CA2E68];
    OZSpline::getFirstValidVertex(a2, &v21, MEMORY[0x1E0CA2E68]);
    OZSpline::getLastValidVertex(a2, &v20, v9);
    std::vector<double>::reserve(v8, *((unsigned int *)this + 8));
    std::vector<double>::reserve(v7, *((unsigned int *)this + 8));
    *(double *)(*((_QWORD *)this + 5) + 8) = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v21 + 40))(v21, a3);
    *(double *)(*((_QWORD *)this + 1) + 8) = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v21 + 24))(v21, a3);
    v19 = v21;
    v10 = 1;
    if (OZSpline::getNextValidVertex((void ***)a2, v21, &v19, v9))
    {
      do
      {
        *((double *)*v7 + ++v10) = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v19 + 40))(v19, a3);
        *((double *)*v8 + v10) = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v19 + 24))(v19, a3);
      }
      while ((OZSpline::getNextValidVertex((void ***)a2, v19, &v19, v9) & 1) != 0);
    }
    v11 = *v8;
    *((_QWORD *)*v8 + v10 + 1) = *((_QWORD *)*v8 + 1);
    v12 = *v7;
    *((_QWORD *)*v7 + v10 + 1) = *((_QWORD *)*v7 + 1);
    v13 = v10 + 2;
    v11[v13] = v11[2];
    v12[v13] = v12[2];
    *v11 = v11[v10];
    *v12 = v12[v10];
  }
  else
  {
    std::vector<double>::reserve((void **)this + 1, *((unsigned int *)this + 8));
    std::vector<double>::reserve(v7, *((unsigned int *)this + 8));
    v14 = (const CMTime *)MEMORY[0x1E0CA2E68];
    OZSpline::getFirstValidVertex(a2, &v21, MEMORY[0x1E0CA2E68]);
    **((double **)this + 5) = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v21 + 40))(v21, a3);
    **((double **)this + 1) = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v21 + 24))(v21, a3);
    v19 = v21;
    if (OZSpline::getNextValidVertex((void ***)a2, v21, &v19, v14))
    {
      v15 = 1;
      do
      {
        *((double *)*v7 + v15) = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v19 + 40))(v19, a3);
        *((double *)*v8 + v15++) = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v19 + 24))(v19, a3);
      }
      while ((OZSpline::getNextValidVertex((void ***)a2, v19, &v19, v14) & 1) != 0);
    }
  }
  v16 = *((unsigned int *)this + 8);
  if ((_DWORD)v16)
  {
    v17 = (double *)*v7;
    do
    {
      if (*v17 <= 1.0)
        v18 = *v17 * -24.0 + 25.0;
      else
        v18 = *v17 * -0.9 + 1.9;
      *v17++ = v18;
      --v16;
    }
    while (v16);
  }
  OZSpline::setDirty(a2, 0);
}

void OZBSplineInterpolator::interpolate(OZBSplineInterpolator *this, OZSpline *a2, const CMTime *a3, void *a4, void *a5, const CMTime *a6, int a7)
{
  OZSpline *v11;
  double Seconds;
  double v13;
  CMTime v14;
  CMTime v15;
  CMTime time;

  OZBSplineInterpolator::fillTempArrays(this, a2, a3);
  if (a7)
  {
    time = *a6;
    Seconds = CMTimeGetSeconds(&time);
    if (!*((_BYTE *)a2 + 144))
    {
      v15 = *a6;
      v13 = CMTimeGetSeconds(&v15);
      OZSpline::getMaxValueU(a2, MEMORY[0x1E0CA2E68], 0, (uint64_t)&v14);
      Seconds = v13
              / CMTimeGetSeconds(&v14)
              * *(double *)(*((_QWORD *)this + 8)
                          + 8 * (*((_DWORD *)this + 28) + *((_DWORD *)this + 8) - 1));
    }
    OZBSplineInterpolator::evalBSplineNURB(this, v11, Seconds);
  }
}

double OZBSplineInterpolator::evalBSplineNURB(OZBSplineInterpolator *this, OZSpline *a2, double a3)
{
  uint64_t v4;
  double *v5;
  double *v6;
  double result;
  double v8;
  double v9;
  double v10;

  OZBSplineInterpolator::generateRationalBasisFunctions((uint64_t)this, a3);
  v4 = *((unsigned int *)this + 8);
  if (!(_DWORD)v4)
    return 0.0;
  v5 = (double *)*((_QWORD *)this + 1);
  v6 = (double *)*((_QWORD *)this + 11);
  result = 0.0;
  do
  {
    v8 = *v5++;
    v9 = v8;
    v10 = *v6++;
    result = result + v9 * v10;
    --v4;
  }
  while (v4);
  return result;
}

uint64_t OZBSplineInterpolator::needInit(OZBSplineInterpolator *this, OZSpline *a2)
{
  return OZSpline::isDirty(a2);
}

uint64_t OZBSplineInterpolator::subDivide(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE **a4, _BYTE **a5, _BYTE **a6)
{
  double v9;
  double v10;
  double Seconds;
  Float64 v12;
  CMTime v14;
  CMTime time;
  CMTime v16;
  CMTime v17;
  CMTime v18;
  CMTime v19;

  v17 = *(CMTime *)(a4 + 2);
  v9 = (*((double (**)(_BYTE **, uint64_t))*a4 + 3))(a4, a3);
  v16 = *(CMTime *)(a5 + 2);
  v10 = (*((double (**)(_BYTE **, uint64_t))*a5 + 3))(a5, a3);
  v19 = *(CMTime *)(a6 + 2);
  v18 = v17;
  PC_CMTimeSaferSubtract(&v19, &v18, (uint64_t)&time);
  Seconds = CMTimeGetSeconds(&time);
  v19 = v16;
  v18 = v17;
  PC_CMTimeSaferSubtract(&v19, &v18, (uint64_t)&v14);
  v12 = CMTimeGetSeconds(&v14);
  return (*((uint64_t (**)(_BYTE **, _QWORD, double))*a6 + 4))(a6, MEMORY[0x1E0CA2E68], v9 + Seconds * ((v10 - v9) / v12));
}

void OZBSplineInterpolator::OZBSplineInterpolator(void **a1, void **a2, void **a3, _QWORD *a4)
{
  void *v7;
  void *v8;
  void *v9;

  v7 = *a1;
  if (v7)
  {
    a4[9] = v7;
    operator delete(v7);
  }
  v8 = *a2;
  if (*a2)
  {
    a4[6] = v8;
    operator delete(v8);
  }
  v9 = *a3;
  if (*a3)
  {
    a4[2] = v9;
    operator delete(v9);
  }
}

void OZCardinalInterpolator::OZCardinalInterpolator(OZCardinalInterpolator *this, double a2)
{
  uint64_t v3;

  OZHermiteInterpolator::OZHermiteInterpolator(this);
  *(_QWORD *)v3 = &off_1E6554F60;
  *(double *)(v3 + 16) = a2;
}

void OZCardinalInterpolator::~OZCardinalInterpolator(OZCardinalInterpolator *this)
{
  OZHermiteInterpolator::~OZHermiteInterpolator(this);
  JUMPOUT(0x1B5E29170);
}

uint64_t OZCardinalInterpolator::useTangents(OZCardinalInterpolator *this)
{
  return 0;
}

void OZCardinalInterpolator::computeTangents(OZCardinalInterpolator *this, OZSpline *a2, _BYTE **a3, _BYTE **a4, const CMTime *a5, double *a6, double *a7, double *a8, double *a9)
{
  double v16;
  double Seconds;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  CMTime v26;
  CMTime v27;
  CMTime v28;
  CMTime v29;
  CMTime time;
  CMTime v31;
  CMTime v32;
  CMTime v33;
  CMTime v34;
  double v35;
  double v36;
  CMTime v37;
  void *v38;
  void *v39;
  void *v40;
  CMTime v41;
  CMTime v42;

  v39 = 0;
  v40 = 0;
  v38 = 0;
  v36 = 0.0;
  v35 = 0.0;
  v16 = (1.0 - *((double *)this + 2)) * 0.5;
  if ((OZSpline::getPreviousValidVertex(a2, a3, &v40, MEMORY[0x1E0CA2E68]) & 1) != 0)
  {
    v37 = *(CMTime *)((char *)v40 + 16);
    v42 = *(CMTime *)(a4 + 2);
    v41 = v37;
    PC_CMTimeSaferSubtract(&v42, &v41, (uint64_t)&time);
    Seconds = CMTimeGetSeconds(&time);
    v18 = (*((double (**)(_BYTE **, const CMTime *))*a4 + 3))(a4, a5);
    v19 = v18 - (*(double (**)(void *, const CMTime *))(*(_QWORD *)v40 + 24))(v40, a5);
LABEL_5:
    v36 = v16 * v19;
    goto LABEL_7;
  }
  if (*((_BYTE *)a2 + 144))
  {
    v34 = *(CMTime *)(a3 + 2);
    OZSpline::getSmallDeltaU(a2, &v33);
    v42 = v34;
    v41 = v33;
    PC_CMTimeSaferSubtract(&v42, &v41, (uint64_t)&v37);
    v42 = *(CMTime *)(a4 + 2);
    v41 = v37;
    PC_CMTimeSaferSubtract(&v42, &v41, (uint64_t)&v32);
    Seconds = CMTimeGetSeconds(&v32);
    OZSpline::getLastValidVertex(a2, &v38, MEMORY[0x1E0CA2E68]);
    (*(void (**)(OZSpline *, void *, _QWORD, double *, const CMTime *))(*(_QWORD *)a2 + 264))(a2, v38, 0, &v36, a5);
    v20 = (*((double (**)(_BYTE **, const CMTime *))*a4 + 3))(a4, a5);
    v19 = v20 - v36;
    goto LABEL_5;
  }
  v33 = *(CMTime *)(a3 + 2);
  operator*(2, &v33, &v34);
  v41 = *(CMTime *)(a4 + 2);
  v42 = v34;
  PC_CMTimeSaferSubtract(&v42, &v41, (uint64_t)&v37);
  v42 = *(CMTime *)(a4 + 2);
  v41 = v37;
  PC_CMTimeSaferSubtract(&v42, &v41, (uint64_t)&v31);
  Seconds = CMTimeGetSeconds(&v31);
  v36 = 0.0;
LABEL_7:
  if ((OZSpline::getNextValidVertex((void ***)a2, a4, &v39, MEMORY[0x1E0CA2E68]) & 1) != 0)
  {
    v34 = *(CMTime *)((char *)v39 + 16);
    v42 = *(CMTime *)(a3 + 2);
    v41 = v34;
    PC_CMTimeSaferSubtract(&v42, &v41, (uint64_t)&v26);
    v21 = CMTimeGetSeconds(&v26);
    v22 = (*((double (**)(_BYTE **, const CMTime *))*a3 + 3))(a3, a5);
    v23 = v22 - (*(double (**)(void *, const CMTime *))(*(_QWORD *)v39 + 24))(v39, a5);
    goto LABEL_11;
  }
  if (*((_BYTE *)a2 + 144))
  {
    v33 = *(CMTime *)(a4 + 2);
    OZSpline::getSmallDeltaU(a2, &v29);
    v42 = v33;
    v41 = v29;
    PC_CMTimeSaferAdd(&v42, &v41, (uint64_t)&v34);
    v37 = v34;
    v42 = *(CMTime *)(a3 + 2);
    v41 = v34;
    PC_CMTimeSaferSubtract(&v42, &v41, (uint64_t)&v28);
    v21 = CMTimeGetSeconds(&v28);
    OZSpline::getFirstValidVertex(a2, &v38, MEMORY[0x1E0CA2E68]);
    (*(void (**)(OZSpline *, void *, _QWORD, double *, const CMTime *))(*(_QWORD *)a2 + 264))(a2, v38, 0, &v35, a5);
    v24 = (*((double (**)(_BYTE **, const CMTime *))*a3 + 3))(a3, a5);
    v23 = v24 - v35;
LABEL_11:
    v25 = v16 * v23;
    if (!a6)
      goto LABEL_13;
    goto LABEL_12;
  }
  v29 = *(CMTime *)(a4 + 2);
  operator*(2, &v29, &v33);
  v41 = *(CMTime *)(a3 + 2);
  v42 = v33;
  PC_CMTimeSaferSubtract(&v42, &v41, (uint64_t)&v34);
  v37 = v34;
  v42 = *(CMTime *)(a3 + 2);
  v41 = v34;
  PC_CMTimeSaferSubtract(&v42, &v41, (uint64_t)&v27);
  v21 = CMTimeGetSeconds(&v27);
  v25 = 0.0;
  if (a6)
LABEL_12:
    *a6 = v16 * Seconds;
LABEL_13:
  if (a7)
    *a7 = v36;
  if (a8)
    *a8 = v16 * v21;
  if (a9)
    *a9 = v25;
}

void OZCatmullRomInterpolator::OZCatmullRomInterpolator(OZCatmullRomInterpolator *this)
{
  _QWORD *v1;

  OZCardinalInterpolator::OZCardinalInterpolator(this, 0.0);
  *v1 = &off_1E6555010;
}

void OZCatmullRomInterpolator::~OZCatmullRomInterpolator(OZCatmullRomInterpolator *this)
{
  OZCardinalInterpolator::~OZCardinalInterpolator(this);
  JUMPOUT(0x1B5E29170);
}

void OZConstantInterpolator::OZConstantInterpolator(OZConstantInterpolator *this)
{
  _QWORD *v1;

  OZInterpolator::OZInterpolator(this);
  *v1 = &off_1E65550C0;
}

void OZConstantInterpolator::~OZConstantInterpolator(OZChannelBase *this, const PCString *a2)
{
  OZChannelBase::setRangeName(this, a2);
  JUMPOUT(0x1B5E29170);
}

double OZConstantInterpolator::interpolate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  double result;

  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a4 + 24))(a4, a3);
  if (a8)
    return 0.0;
  return result;
}

uint64_t OZConstantInterpolator::subDivide(OZConstantInterpolator *this, OZSpline *a2, const CMTime *a3, char *a4, char *a5, void *a6)
{
  CMTime v12;
  CMTime v13;
  CMTime v14;
  CMTime v15;
  CMTime time2;
  CMTime time1;

  v14 = *(CMTime *)(a4 + 16);
  v13 = *(CMTime *)(a5 + 16);
  time1 = *(CMTime *)(a4 + 16);
  time2 = *(CMTime *)(a5 + 16);
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    OZSpline::getSmallDeltaU(a2, &v15);
    time1 = v14;
    time2 = v15;
    PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v13);
  }
  memset(&v12, 0, sizeof(v12));
  time1 = v13;
  time2 = v14;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v15);
  operator*(&v15, &v12, 0.5);
  time2 = v12;
  v15 = v14;
  PC_CMTimeSaferAdd(&time2, &v15, (uint64_t)&time1);
  v12 = time1;
  (*(void (**)(OZConstantInterpolator *, OZSpline *, const CMTime *, char *, char *, CMTime *, _QWORD, _QWORD))(*(_QWORD *)this + 24))(this, a2, a3, a4, a5, &v12, 0, 0);
  return (*(uint64_t (**)(OZSpline *, CMTime *, const CMTime *, uint64_t))(*(_QWORD *)a2 + 192))(a2, &v12, a3, 1);
}

BOOL OZConstantInterpolator::uForCurveValue(double a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __int128 *a6, uint64_t a7, void **a8)
{
  double v11;
  char *v12;
  char *v13;
  __int128 v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  __int128 v23;
  char *v24;
  char *v25;
  __int128 v26;

  v11 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a4 + 24))(a4, MEMORY[0x1E0CA2E68]);
  if (v11 == a1)
  {
    v12 = (char *)a8[2];
    v13 = (char *)a8[1];
    if (v13 >= v12)
    {
      v16 = 0xAAAAAAAAAAAAAAABLL * ((v13 - (_BYTE *)*a8) >> 3);
      v17 = v16 + 1;
      if (v16 + 1 > 0xAAAAAAAAAAAAAAALL)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v18 = 0xAAAAAAAAAAAAAAABLL * ((v12 - (_BYTE *)*a8) >> 3);
      if (2 * v18 > v17)
        v17 = 2 * v18;
      if (v18 >= 0x555555555555555)
        v19 = 0xAAAAAAAAAAAAAAALL;
      else
        v19 = v17;
      if (v19)
        v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a8 + 2), v19);
      else
        v20 = 0;
      v21 = &v20[24 * v16];
      v22 = &v20[24 * v19];
      v23 = *a6;
      *((_QWORD *)v21 + 2) = *((_QWORD *)a6 + 2);
      *(_OWORD *)v21 = v23;
      v15 = v21 + 24;
      v25 = (char *)*a8;
      v24 = (char *)a8[1];
      if (v24 != *a8)
      {
        do
        {
          v26 = *(_OWORD *)(v24 - 24);
          *((_QWORD *)v21 - 1) = *((_QWORD *)v24 - 1);
          *(_OWORD *)(v21 - 24) = v26;
          v21 -= 24;
          v24 -= 24;
        }
        while (v24 != v25);
        v24 = (char *)*a8;
      }
      *a8 = v21;
      a8[1] = v15;
      a8[2] = v22;
      if (v24)
        operator delete(v24);
    }
    else
    {
      v14 = *a6;
      *((_QWORD *)v13 + 2) = *((_QWORD *)a6 + 2);
      *(_OWORD *)v13 = v14;
      v15 = v13 + 24;
    }
    a8[1] = v15;
  }
  return v11 == a1;
}

void OZDecelerateInterpolator::easeTime(CMTime *a1@<X2>, _BYTE **a2@<X3>, uint64_t a3@<X4>, uint64_t a4@<X8>)
{
  double v8;
  double Seconds;
  Float64 v10;
  double *v11;
  CMTime v12;
  Float64 v13;
  CMTime v14;
  CMTime v15;
  CMTime time;
  CMTime v17;
  CMTime v18;

  v8 = (2.0 - (*((double (**)(_BYTE **, _QWORD))*a2 + 5))(a2, MEMORY[0x1E0CA2E68])) * 0.5;
  v17 = *(CMTime *)(a2 + 2);
  v18 = *a1;
  PC_CMTimeSaferSubtract(&v18, &v17, (uint64_t)&time);
  Seconds = CMTimeGetSeconds(&time);
  memset(&v15, 0, sizeof(v15));
  v18 = *(CMTime *)(a3 + 16);
  v17 = *(CMTime *)(a2 + 2);
  PC_CMTimeSaferSubtract(&v18, &v17, (uint64_t)&v15);
  v14 = v15;
  v10 = CMTimeGetSeconds(&v14);
  v13 = 0.0;
  PCMath::easeInOut(&v13, Seconds / v10, 0.0, v8, 0.0, 1.0, 0, v11);
  operator*(&v15, &v12, v13);
  v17 = *(CMTime *)(a2 + 2);
  v18 = v12;
  PC_CMTimeSaferAdd(&v18, &v17, a4);
}

void OZEaseInterpolator::easeTime(CMTime *a1@<X2>, _BYTE **a2@<X3>, uint64_t a3@<X4>, uint64_t a4@<X8>)
{
  double v8;
  double Seconds;
  Float64 v10;
  double *v11;
  CMTime v12;
  Float64 v13;
  CMTime v14;
  CMTime v15;
  CMTime time;
  CMTime v17;
  CMTime v18;

  v8 = (2.0 - (*((double (**)(_BYTE **, _QWORD))*a2 + 5))(a2, MEMORY[0x1E0CA2E68])) * 0.25;
  v17 = *(CMTime *)(a2 + 2);
  v18 = *a1;
  PC_CMTimeSaferSubtract(&v18, &v17, (uint64_t)&time);
  Seconds = CMTimeGetSeconds(&time);
  memset(&v15, 0, sizeof(v15));
  v18 = *(CMTime *)(a3 + 16);
  v17 = *(CMTime *)(a2 + 2);
  PC_CMTimeSaferSubtract(&v18, &v17, (uint64_t)&v15);
  v14 = v15;
  v10 = CMTimeGetSeconds(&v14);
  v13 = 0.0;
  PCMath::easeInOut(&v13, Seconds / v10, v8, v8, 0.0, 1.0, 0, v11);
  operator*(&v15, &v12, v13);
  v17 = *(CMTime *)(a2 + 2);
  v18 = v12;
  PC_CMTimeSaferAdd(&v18, &v17, a4);
}

long double OZEaseInInterpolator::interpolate(OZEaseInInterpolator *this, OZSpline *a2, const CMTime *a3, _BYTE **a4, _BYTE **a5, const CMTime *a6)
{
  double v10;
  double v11;
  Float64 Seconds;
  _BYTE v14[24];
  CMTime v15;
  CMTime time;
  CMTime v17;
  CMTime v18;
  CMTime v19;
  CMTime time2;
  CMTime time1;

  v19 = *(CMTime *)(a4 + 2);
  v18 = *(CMTime *)(a5 + 2);
  v10 = (*((double (**)(_BYTE **, const CMTime *))*a4 + 3))(a4, a3);
  v11 = (*((double (**)(_BYTE **, const CMTime *))*a5 + 3))(a5, a3);
  time1 = v19;
  time2 = v18;
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    OZSpline::getSmallDeltaU(a2, &v17);
    time1 = v19;
    time2 = v17;
    PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v18);
  }
  time1 = *a6;
  time2 = v19;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v15);
  operator*(&v15, &v17, 3.14159265);
  time1 = v18;
  time2 = v19;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)v14);
  operator/((__int128 *)&v17.value, (uint64_t)v14, (uint64_t)&time);
  Seconds = CMTimeGetSeconds(&time);
  return v10 + (v11 - v10) * (1.0 - cos(Seconds * 0.5));
}

uint64_t OZEaseInInterpolator::subDivide(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __int128 v9;
  uint64_t v10;

  v9 = *(_OWORD *)(a6 + 16);
  v10 = *(_QWORD *)(a6 + 32);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __int128 *, _QWORD, _QWORD))(*(_QWORD *)a1 + 24))(a1, a2, a3, a4, a5, &v9, 0, 0);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a6 + 32))(a6, a3);
}

void OZEaseInInterpolator::getMinMaxValues(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CMTime *a5, CMTime *a6, double *a7, double *a8)
{
  uint64_t v16;
  double v17;
  double v18;
  CMTime v19;
  __int128 v20;
  CMTimeEpoch epoch;
  CMTime time2;
  CMTime time1;

  v20 = *(_OWORD *)(a3 + 16);
  epoch = *(_QWORD *)(a3 + 32);
  v19 = *(CMTime *)(a4 + 16);
  time1 = *a5;
  time2 = *(CMTime *)(a3 + 16);
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    v20 = *(_OWORD *)&a5->value;
    epoch = a5->epoch;
  }
  time1 = *a6;
  time2 = v19;
  if (CMTimeCompare(&time1, &time2) < 0)
    v19 = *a6;
  v16 = MEMORY[0x1E0CA2E68];
  *a7 = (*(double (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, __int128 *, _QWORD, _QWORD))(*(_QWORD *)a1 + 24))(a1, a2, MEMORY[0x1E0CA2E68], a3, a4, &v20, 0, 0);
  v17 = (*(double (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, CMTime *, _QWORD, _QWORD))(*(_QWORD *)a1 + 24))(a1, a2, v16, a3, a4, &v19, 0, 0);
  *a8 = v17;
  v18 = *a7;
  if (*a7 > v17)
  {
    *a7 = v17;
    *a8 = v18;
  }
}

BOOL OZEaseInInterpolator::uForCurveValue(double a1, uint64_t a2, uint64_t a3, _BYTE **a4, _BYTE **a5, uint64_t a6, uint64_t a7, void **a8)
{
  uint64_t v14;
  double v15;
  double v16;
  double v17;
  _BOOL8 v18;
  uint64_t v19;
  double v20;
  double v21;
  long double v22;
  char *v23;
  char *v24;
  __int128 v25;
  char *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  char *v32;
  char *v33;
  __int128 v34;
  char *v35;
  char *v36;
  __int128 v37;
  CMTime v39;
  CMTime v40;
  CMTime v41;
  CMTime v42;
  __int128 v43;
  uint64_t v44;
  CMTime v45;
  CMTime v46;
  CMTime v47;

  v14 = MEMORY[0x1E0CA2E68];
  v15 = (*(double (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a3 + 240))(a3, a6, MEMORY[0x1E0CA2E68], 0);
  v16 = (*(double (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a3 + 240))(a3, a7, v14, 0);
  if (v15 >= v16)
    v17 = v15;
  else
    v17 = v16;
  if (v15 <= v16)
    v16 = v15;
  v18 = v16 <= a1 && v17 >= a1;
  if (v18)
  {
    v19 = MEMORY[0x1E0CA2E68];
    v20 = (*((double (**)(_BYTE **, _QWORD))*a4 + 3))(a4, MEMORY[0x1E0CA2E68]);
    v21 = (*((double (**)(_BYTE **, uint64_t))*a5 + 3))(a5, v19);
    v45 = *(CMTime *)(a4 + 2);
    v47 = *(CMTime *)(a5 + 2);
    v43 = 0uLL;
    v44 = 0;
    v46 = *(CMTime *)(a4 + 2);
    PC_CMTimeSaferSubtract(&v47, &v46, (uint64_t)&v39);
    operator*(&v39, &v40, 2.0);
    operator/((__int128 *)&v40.value, (uint64_t)&v41, 3.14159265);
    v22 = acos((v20 - a1) / (v21 - v20) + 1.0);
    operator*(&v41, &v42, v22);
    v47 = v42;
    v46 = v45;
    PC_CMTimeSaferAdd(&v47, &v46, (uint64_t)&v43);
    v23 = (char *)a8[2];
    v24 = (char *)a8[1];
    if (v24 >= v23)
    {
      v27 = 0xAAAAAAAAAAAAAAABLL * ((v24 - (_BYTE *)*a8) >> 3);
      v28 = v27 + 1;
      if (v27 + 1 > 0xAAAAAAAAAAAAAAALL)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v29 = 0xAAAAAAAAAAAAAAABLL * ((v23 - (_BYTE *)*a8) >> 3);
      if (2 * v29 > v28)
        v28 = 2 * v29;
      if (v29 >= 0x555555555555555)
        v30 = 0xAAAAAAAAAAAAAAALL;
      else
        v30 = v28;
      if (v30)
        v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a8 + 2), v30);
      else
        v31 = 0;
      v32 = &v31[24 * v27];
      v33 = &v31[24 * v30];
      v34 = v43;
      *((_QWORD *)v32 + 2) = v44;
      *(_OWORD *)v32 = v34;
      v26 = v32 + 24;
      v36 = (char *)*a8;
      v35 = (char *)a8[1];
      if (v35 != *a8)
      {
        do
        {
          v37 = *(_OWORD *)(v35 - 24);
          *((_QWORD *)v32 - 1) = *((_QWORD *)v35 - 1);
          *(_OWORD *)(v32 - 24) = v37;
          v32 -= 24;
          v35 -= 24;
        }
        while (v35 != v36);
        v35 = (char *)*a8;
      }
      *a8 = v32;
      a8[1] = v26;
      a8[2] = v33;
      if (v35)
        operator delete(v35);
    }
    else
    {
      v25 = v43;
      *((_QWORD *)v24 + 2) = v44;
      *(_OWORD *)v24 = v25;
      v26 = v24 + 24;
    }
    a8[1] = v26;
  }
  return v18;
}

void OZEaseInInterpolator::~OZEaseInInterpolator(OZChannelBase *this, const PCString *a2)
{
  OZChannelBase::setRangeName(this, a2);
  JUMPOUT(0x1B5E29170);
}

long double OZEaseOutInterpolator::interpolate(OZEaseOutInterpolator *this, OZSpline *a2, const CMTime *a3, _BYTE **a4, _BYTE **a5, const CMTime *a6)
{
  double v10;
  double v11;
  Float64 Seconds;
  _BYTE v14[24];
  CMTime v15;
  CMTime time;
  CMTime v17;
  CMTime v18;
  CMTime v19;
  CMTime time2;
  CMTime time1;

  v19 = *(CMTime *)(a4 + 2);
  v18 = *(CMTime *)(a5 + 2);
  v10 = (*((double (**)(_BYTE **, const CMTime *))*a4 + 3))(a4, a3);
  v11 = (*((double (**)(_BYTE **, const CMTime *))*a5 + 3))(a5, a3);
  time1 = v19;
  time2 = v18;
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    OZSpline::getSmallDeltaU(a2, &v17);
    time1 = v19;
    time2 = v17;
    PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v18);
  }
  time1 = *a6;
  time2 = v19;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v15);
  operator*(&v15, &v17, 3.14159265);
  time1 = v18;
  time2 = v19;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)v14);
  operator/((__int128 *)&v17.value, (uint64_t)v14, (uint64_t)&time);
  Seconds = CMTimeGetSeconds(&time);
  return v10 + (v11 - v10) * sin(Seconds * 0.5);
}

uint64_t OZEaseOutInterpolator::subDivide(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __int128 v9;
  uint64_t v10;

  v9 = *(_OWORD *)(a6 + 16);
  v10 = *(_QWORD *)(a6 + 32);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __int128 *, _QWORD, _QWORD))(*(_QWORD *)a1 + 24))(a1, a2, a3, a4, a5, &v9, 0, 0);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a6 + 32))(a6, a3);
}

BOOL OZEaseOutInterpolator::uForCurveValue(double a1, uint64_t a2, uint64_t a3, _BYTE **a4, _BYTE **a5, uint64_t a6, uint64_t a7, void **a8)
{
  uint64_t v14;
  double v15;
  double v16;
  double v17;
  _BOOL8 v18;
  uint64_t v19;
  double v20;
  double v21;
  long double v22;
  char *v23;
  char *v24;
  __int128 v25;
  char *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  char *v32;
  char *v33;
  __int128 v34;
  char *v35;
  char *v36;
  __int128 v37;
  CMTime v39;
  CMTime v40;
  CMTime v41;
  CMTime v42;
  __int128 v43;
  uint64_t v44;
  CMTime v45;
  CMTime v46;
  CMTime v47;

  v14 = MEMORY[0x1E0CA2E68];
  v15 = (*(double (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a3 + 240))(a3, a6, MEMORY[0x1E0CA2E68], 0);
  v16 = (*(double (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a3 + 240))(a3, a7, v14, 0);
  if (v15 >= v16)
    v17 = v15;
  else
    v17 = v16;
  if (v15 <= v16)
    v16 = v15;
  v18 = v16 <= a1 && v17 >= a1;
  if (v18)
  {
    v19 = MEMORY[0x1E0CA2E68];
    v20 = (*((double (**)(_BYTE **, _QWORD))*a4 + 3))(a4, MEMORY[0x1E0CA2E68]);
    v21 = (*((double (**)(_BYTE **, uint64_t))*a5 + 3))(a5, v19);
    v45 = *(CMTime *)(a4 + 2);
    v47 = *(CMTime *)(a5 + 2);
    v43 = 0uLL;
    v44 = 0;
    v46 = *(CMTime *)(a4 + 2);
    PC_CMTimeSaferSubtract(&v47, &v46, (uint64_t)&v39);
    operator*(&v39, &v40, 2.0);
    operator/((__int128 *)&v40.value, (uint64_t)&v41, 3.14159265);
    v22 = asin((a1 - v20) / (v21 - v20));
    operator*(&v41, &v42, v22);
    v47 = v42;
    v46 = v45;
    PC_CMTimeSaferAdd(&v47, &v46, (uint64_t)&v43);
    v23 = (char *)a8[2];
    v24 = (char *)a8[1];
    if (v24 >= v23)
    {
      v27 = 0xAAAAAAAAAAAAAAABLL * ((v24 - (_BYTE *)*a8) >> 3);
      v28 = v27 + 1;
      if (v27 + 1 > 0xAAAAAAAAAAAAAAALL)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v29 = 0xAAAAAAAAAAAAAAABLL * ((v23 - (_BYTE *)*a8) >> 3);
      if (2 * v29 > v28)
        v28 = 2 * v29;
      if (v29 >= 0x555555555555555)
        v30 = 0xAAAAAAAAAAAAAAALL;
      else
        v30 = v28;
      if (v30)
        v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a8 + 2), v30);
      else
        v31 = 0;
      v32 = &v31[24 * v27];
      v33 = &v31[24 * v30];
      v34 = v43;
      *((_QWORD *)v32 + 2) = v44;
      *(_OWORD *)v32 = v34;
      v26 = v32 + 24;
      v36 = (char *)*a8;
      v35 = (char *)a8[1];
      if (v35 != *a8)
      {
        do
        {
          v37 = *(_OWORD *)(v35 - 24);
          *((_QWORD *)v32 - 1) = *((_QWORD *)v35 - 1);
          *(_OWORD *)(v32 - 24) = v37;
          v32 -= 24;
          v35 -= 24;
        }
        while (v35 != v36);
        v35 = (char *)*a8;
      }
      *a8 = v32;
      a8[1] = v26;
      a8[2] = v33;
      if (v35)
        operator delete(v35);
    }
    else
    {
      v25 = v43;
      *((_QWORD *)v24 + 2) = v44;
      *(_OWORD *)v24 = v25;
      v26 = v24 + 24;
    }
    a8[1] = v26;
  }
  return v18;
}

double OZExponentialInterpolator::interpolate(OZExponentialInterpolator *this, OZSpline *a2, const CMTime *a3, _BYTE **a4, _BYTE **a5, const CMTime *a6)
{
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  Float64 Seconds;
  double v16;
  double v17;
  __int128 v19;
  CMTime time;
  CMTime v21;
  CMTime v22;
  CMTime v23;
  CMTime time2;
  CMTime time1;

  v23 = *(CMTime *)(a4 + 2);
  v22 = *(CMTime *)(a5 + 2);
  v10 = (*((double (**)(_BYTE **, const CMTime *))*a4 + 3))(a4, a3);
  v11 = (*((double (**)(_BYTE **, const CMTime *))*a5 + 3))(a5, a3);
  time1 = v23;
  time2 = v22;
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    OZSpline::getSmallDeltaU(a2, &v21);
    time1 = v23;
    time2 = v21;
    PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v22);
  }
  memset(&v21, 0, sizeof(v21));
  time1 = v22;
  time2 = v23;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v21);
  time1 = v21;
  time2 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  if (CMTimeCompare(&time1, &time2))
  {
    v12 = v11 - v10;
    v13 = -(v11 - v10);
    if (v11 >= v10)
      v13 = v11 - v10;
    v14 = log(v13);
    time1 = *a6;
    time2 = v23;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v19);
    operator/(&v19, (uint64_t)&v21, (uint64_t)&time);
    Seconds = CMTimeGetSeconds(&time);
    v16 = v14 + 9.21034037;
    v17 = exp((v14 + 9.21034037) * Seconds + -9.21034037);
    return v10 + v12 * (v17 + -0.0001) / (exp(v16 + -9.21034037) + -0.0001);
  }
  return v10;
}

uint64_t OZExponentialInterpolator::subDivide(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __int128 v9;
  uint64_t v10;

  v9 = *(_OWORD *)(a6 + 16);
  v10 = *(_QWORD *)(a6 + 32);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __int128 *, _QWORD, _QWORD))(*(_QWORD *)a1 + 24))(a1, a2, a3, a4, a5, &v9, 0, 0);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a6 + 32))(a6, a3);
}

BOOL OZExponentialInterpolator::uForCurveValue(double a1, uint64_t a2, OZSpline *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void **a8)
{
  uint64_t v14;
  double v15;
  __n128 v16;
  _BOOL8 result;
  double v18;
  CMTime *v20;
  double v21;
  double v22;
  double v23;
  long double v24;
  long double v25;
  long double v26;
  char *v27;
  char *v28;
  __int128 v29;
  char *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  char *v35;
  char *v36;
  char *v37;
  __int128 v38;
  char *v39;
  char *v40;
  __int128 v41;
  CMTime v42;
  __int128 v43;
  uint64_t v44;
  CMTime v45;
  CMTime v46;
  CMTime v47;
  CMTime time2;
  CMTime time1;

  v14 = MEMORY[0x1E0CA2E68];
  v15 = (*(double (**)(OZSpline *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a3 + 240))(a3, a6, MEMORY[0x1E0CA2E68], 0);
  v16.n128_f64[0] = (*(double (**)(OZSpline *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a3 + 240))(a3, a7, v14, 0);
  result = 0;
  if (v15 >= v16.n128_f64[0])
    v18 = v15;
  else
    v18 = v16.n128_f64[0];
  if (v15 <= v16.n128_f64[0])
    v16.n128_f64[0] = v15;
  if (v18 >= a1 && v16.n128_f64[0] <= a1)
  {
    v20 = (CMTime *)MEMORY[0x1E0CA2E68];
    v21 = (*(double (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)a4 + 24))(a4, MEMORY[0x1E0CA2E68], v16);
    v22 = (*(double (**)(uint64_t, CMTime *))(*(_QWORD *)a5 + 24))(a5, v20);
    v47 = *(CMTime *)(a4 + 16);
    v46 = *(CMTime *)(a5 + 16);
    time1 = *(CMTime *)(a4 + 16);
    time2 = *(CMTime *)(a5 + 16);
    if (CMTimeCompare(&time1, &time2) >= 1)
    {
      OZSpline::getSmallDeltaU(a3, &v45);
      time1 = v47;
      time2 = v45;
      PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v46);
    }
    memset(&v45, 0, sizeof(v45));
    time1 = v46;
    time2 = v47;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v45);
    time1 = v45;
    time2 = *v20;
    if (CMTimeCompare(&time1, &time2))
    {
      v23 = -(v22 - v21);
      if (v22 >= v21)
        v23 = v22 - v21;
      v24 = log(v23) + 9.21034037;
      v25 = exp(v24 + -9.21034037);
      v43 = 0uLL;
      v44 = 0;
      v26 = log((a1 - v21) * (v25 + -0.0001) / (v22 - v21));
      operator*(&v45, &v42, (v26 + 9.21034037) / v24);
      time1 = v42;
      time2 = v47;
      PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v43);
      v27 = (char *)a8[2];
      v28 = (char *)a8[1];
      if (v28 >= v27)
      {
        v31 = 0xAAAAAAAAAAAAAAABLL * ((v28 - (_BYTE *)*a8) >> 3);
        v32 = v31 + 1;
        if (v31 + 1 > 0xAAAAAAAAAAAAAAALL)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v33 = 0xAAAAAAAAAAAAAAABLL * ((v27 - (_BYTE *)*a8) >> 3);
        if (2 * v33 > v32)
          v32 = 2 * v33;
        if (v33 >= 0x555555555555555)
          v34 = 0xAAAAAAAAAAAAAAALL;
        else
          v34 = v32;
        if (v34)
          v35 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a8 + 2), v34);
        else
          v35 = 0;
        v36 = &v35[24 * v31];
        v37 = &v35[24 * v34];
        v38 = v43;
        *((_QWORD *)v36 + 2) = v44;
        *(_OWORD *)v36 = v38;
        v30 = v36 + 24;
        v40 = (char *)*a8;
        v39 = (char *)a8[1];
        if (v39 != *a8)
        {
          do
          {
            v41 = *(_OWORD *)(v39 - 24);
            *((_QWORD *)v36 - 1) = *((_QWORD *)v39 - 1);
            *(_OWORD *)(v36 - 24) = v41;
            v36 -= 24;
            v39 -= 24;
          }
          while (v39 != v40);
          v39 = (char *)*a8;
        }
        *a8 = v36;
        a8[1] = v30;
        a8[2] = v37;
        if (v39)
          operator delete(v39);
      }
      else
      {
        v29 = v43;
        *((_QWORD *)v28 + 2) = v44;
        *(_OWORD *)v28 = v29;
        v30 = v28 + 24;
      }
      result = 0;
      a8[1] = v30;
    }
    else
    {
      return v21 != 0.0;
    }
  }
  return result;
}

void OZHermiteInterpolator::OZHermiteInterpolator(OZHermiteInterpolator *this)
{
  _QWORD *v1;

  OZBezierInterpolator::OZBezierInterpolator(this);
  *v1 = &off_1E6555450;
  v1[1] = 0x3FD5555555555555;
}

void OZHermiteInterpolator::~OZHermiteInterpolator(OZHermiteInterpolator *this)
{
  OZAccelerateInterpolator::~OZAccelerateInterpolator(this);
  JUMPOUT(0x1B5E29170);
}

void OZInterpolator::OZInterpolator(OZInterpolator *this)
{
  *(_QWORD *)this = off_1E6555500;
}

uint64_t OZInterpolator::useTangents(OZInterpolator *this)
{
  return 0;
}

uint64_t OZInterpolator::useKeypoints(OZInterpolator *this)
{
  return 1;
}

__n128 OZInterpolator::getAdjustedMaxU@<Q0>(__n128 *a1@<X3>, __n128 *a2@<X8>)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  return result;
}

__n128 OZInterpolator::getAdjustedMinU@<Q0>(__n128 *a1@<X3>, __n128 *a2@<X8>)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  return result;
}

void OZInterpolators::OZInterpolators(OZInterpolators *this)
{
  atomic_store(0, (unint64_t *)this);
  atomic_store(0, (unint64_t *)this + 1);
  *((_QWORD *)this + 2) = OZInterpolatorStrategies::getInstance(this);
}

void OZInterpolators::OZInterpolators(OZInterpolators *this, const OZInterpolators *a2)
{
  unint64_t *v3;
  OZBSplineInterpolator *v5;
  const OZBSplineInterpolator *v6;
  unint64_t *v7;
  OZXSplineInterpolator *v9;
  const OZXSplineInterpolator *v10;

  v3 = (unint64_t *)this;
  if (atomic_load((unint64_t *)a2))
  {
    v5 = (OZBSplineInterpolator *)operator new();
    v6 = (const OZBSplineInterpolator *)atomic_load((unint64_t *)a2);
    this = OZBSplineInterpolator::OZBSplineInterpolator(v5, v6);
  }
  else
  {
    v5 = 0;
  }
  atomic_store((unint64_t)v5, v3);
  v7 = (unint64_t *)((char *)a2 + 8);
  if (atomic_load((unint64_t *)a2 + 1))
  {
    v9 = (OZXSplineInterpolator *)operator new();
    v10 = (const OZXSplineInterpolator *)atomic_load(v7);
    OZXSplineInterpolator::OZXSplineInterpolator(v9, v10);
    atomic_store((unint64_t)v9, v3 + 1);
  }
  else
  {
    atomic_store(0, v3 + 1);
  }
  v3[2] = OZInterpolatorStrategies::getInstance(this);
}

void sub_1B2C3B140(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1081C40701C9BA7);
  _Unwind_Resume(a1);
}

void OZInterpolators::~OZInterpolators(OZInterpolators *this)
{
  unint64_t v3;
  unint64_t v5;

  if (atomic_load((unint64_t *)this))
  {
    v3 = atomic_load((unint64_t *)this);
    if (v3)
      (*(void (**)(unint64_t))(*(_QWORD *)v3 + 8))(v3);
    atomic_store(0, (unint64_t *)this);
  }
  if (atomic_load((unint64_t *)this + 1))
  {
    v5 = atomic_load((unint64_t *)this + 1);
    if (v5)
      (*(void (**)(unint64_t))(*(_QWORD *)v5 + 8))(v5);
    atomic_store(0, (unint64_t *)this + 1);
  }
}

uint64_t OZInterpolators::getInterpolator(OZInterpolators *this, int a2)
{
  unint64_t *v3;
  OZXSplineInterpolator *v5;
  OZBSplineInterpolator *v8;

  if (a2 == 10)
  {
    if (!atomic_load((unint64_t *)this))
    {
      v8 = (OZBSplineInterpolator *)operator new();
      OZBSplineInterpolator::OZBSplineInterpolator(v8);
      while (!__ldaxr((unint64_t *)this))
      {
        if (!__stlxr((unint64_t)v8, (unint64_t *)this))
          return atomic_load((unint64_t *)this);
      }
      __clrex();
      (*(void (**)(OZBSplineInterpolator *))(*(_QWORD *)v8 + 8))(v8);
    }
    return atomic_load((unint64_t *)this);
  }
  else if (a2 == 12)
  {
    v3 = (unint64_t *)((char *)this + 8);
    if (!atomic_load((unint64_t *)this + 1))
    {
      v5 = (OZXSplineInterpolator *)operator new();
      OZXSplineInterpolator::OZXSplineInterpolator(v5);
      while (!__ldaxr(v3))
      {
        if (!__stlxr((unint64_t)v5, v3))
          return atomic_load(v3);
      }
      __clrex();
      (*(void (**)(OZXSplineInterpolator *))(*(_QWORD *)v5 + 8))(v5);
    }
    return atomic_load(v3);
  }
  else
  {
    return OZInterpolatorStrategies::getInterpolator(*((OZInterpolatorStrategies **)this + 2), a2);
  }
}

void sub_1B2C3B2E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1081C40AD291579);
  _Unwind_Resume(a1);
}

uint64_t OZInterpolators::operator==(unint64_t *a1, unint64_t *a2)
{
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!atomic_load(a1))
  {
    if (atomic_load(a2))
      return 0;
  }
  if (atomic_load(a1))
  {
    if (!atomic_load(a2))
      return 0;
  }
  if (!atomic_load(a1 + 1))
  {
    if (atomic_load(a2 + 1))
      return 0;
  }
  if (atomic_load(a1 + 1))
  {
    if (!atomic_load(a2 + 1))
      return 0;
  }
  v10 = atomic_load(a1);
  if (v10 || (v11 = atomic_load(a2)) != 0)
  {
    v12 = atomic_load(a1);
    v13 = atomic_load(a2);
    if (!OZBSplineInterpolator::operator==(v12, v13))
      return 0;
  }
  if (((v14 = atomic_load(a1 + 1)) != 0 || (v15 = atomic_load(a2 + 1)) != 0)
    && (v16 = atomic_load(a1 + 1), v17 = atomic_load(a2 + 1), !OZXSplineInterpolator::operator==(v16, v17)))
  {
    return 0;
  }
  else
  {
    return 1;
  }
}

void sub_1B2C3B500(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  uint64_t v10;

  PCString::~PCString(&a10);
  MEMORY[0x1B5E29170](v10, 0x10E1C40044ED5BALL);
  _Unwind_Resume(a1);
}

void OZInterpolatorStrategies::OZInterpolatorStrategies(OZInterpolatorStrategies *this)
{
  _QWORD *v2;
  OZConstantInterpolator *v3;
  OZLinearInterpolator *v4;
  OZBezierInterpolator *v5;
  OZCatmullRomInterpolator *v6;
  OZInterpolator *v7;
  OZInterpolator *v8;
  OZInterpolator *v9;
  OZInterpolator *v10;
  OZLinearInterpolator *v11;
  OZLinearInterpolator *v12;
  OZLinearInterpolator *v13;
  OZConvexInterpolator *v14;
  OZConcaveInterpolator *v15;
  OZSCurveInterpolator *v16;

  PCSingleton::PCSingleton(this, 0);
  *v2 = &off_1E6555590;
  v3 = (OZConstantInterpolator *)operator new();
  OZConstantInterpolator::OZConstantInterpolator(v3);
  *((_QWORD *)this + 1) = v3;
  v4 = (OZLinearInterpolator *)operator new();
  OZLinearInterpolator::OZLinearInterpolator(v4);
  *((_QWORD *)this + 2) = v4;
  v5 = (OZBezierInterpolator *)operator new();
  OZBezierInterpolator::OZBezierInterpolator(v5);
  *((_QWORD *)this + 3) = v5;
  v6 = (OZCatmullRomInterpolator *)operator new();
  OZCatmullRomInterpolator::OZCatmullRomInterpolator(v6);
  *((_QWORD *)this + 4) = v6;
  v7 = (OZInterpolator *)operator new();
  OZInterpolator::OZInterpolator(v7);
  *(_QWORD *)v7 = &unk_1E6555288;
  *((_QWORD *)this + 5) = v7;
  v8 = (OZInterpolator *)operator new();
  OZInterpolator::OZInterpolator(v8);
  *(_QWORD *)v8 = &unk_1E6555320;
  *((_QWORD *)this + 6) = v8;
  v9 = (OZInterpolator *)operator new();
  OZInterpolator::OZInterpolator(v9);
  *(_QWORD *)v9 = &unk_1E65553B8;
  *((_QWORD *)this + 7) = v9;
  v10 = (OZInterpolator *)operator new();
  OZInterpolator::OZInterpolator(v10);
  *(_QWORD *)v10 = &unk_1E65556A0;
  *((_QWORD *)this + 8) = v10;
  v11 = (OZLinearInterpolator *)operator new();
  OZLinearInterpolator::OZLinearInterpolator(v11);
  *(_QWORD *)v11 = &unk_1E6554D50;
  *((_QWORD *)this + 9) = v11;
  v12 = (OZLinearInterpolator *)operator new();
  OZLinearInterpolator::OZLinearInterpolator(v12);
  *(_QWORD *)v12 = &unk_1E6555158;
  *((_QWORD *)this + 10) = v12;
  v13 = (OZLinearInterpolator *)operator new();
  OZLinearInterpolator::OZLinearInterpolator(v13);
  *(_QWORD *)v13 = &unk_1E65551F0;
  *((_QWORD *)this + 11) = v13;
  v14 = (OZConvexInterpolator *)operator new();
  OZConvexInterpolator::OZConvexInterpolator(v14);
  *((_QWORD *)this + 12) = v14;
  v15 = (OZConcaveInterpolator *)operator new();
  OZConcaveInterpolator::OZConcaveInterpolator(v15);
  *((_QWORD *)this + 13) = v15;
  v16 = (OZSCurveInterpolator *)operator new();
  OZSCurveInterpolator::OZSCurveInterpolator(v16);
  *((_QWORD *)this + 14) = v16;
}

void sub_1B2C3B910(_Unwind_Exception *a1)
{
  PCSingleton *v1;
  uint64_t v2;
  uint64_t v3;

  v3 = v2;
  MEMORY[0x1B5E29170](v3, 0x81C40B8603338);
  PCSingleton::~PCSingleton(v1);
  _Unwind_Resume(a1);
}

void OZInterpolatorStrategies::~OZInterpolatorStrategies(OZInterpolatorStrategies *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  *(_QWORD *)this = &off_1E6555590;
  v2 = *((_QWORD *)this + 1);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 1) = 0;
  v3 = *((_QWORD *)this + 2);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  *((_QWORD *)this + 2) = 0;
  v4 = *((_QWORD *)this + 3);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  *((_QWORD *)this + 3) = 0;
  v5 = *((_QWORD *)this + 4);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  *((_QWORD *)this + 4) = 0;
  v6 = *((_QWORD *)this + 5);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  *((_QWORD *)this + 5) = 0;
  v7 = *((_QWORD *)this + 6);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  *((_QWORD *)this + 6) = 0;
  v8 = *((_QWORD *)this + 7);
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  *((_QWORD *)this + 7) = 0;
  v9 = *((_QWORD *)this + 8);
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  *((_QWORD *)this + 8) = 0;
  v10 = *((_QWORD *)this + 9);
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  *((_QWORD *)this + 9) = 0;
  v11 = *((_QWORD *)this + 10);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  *((_QWORD *)this + 10) = 0;
  v12 = *((_QWORD *)this + 11);
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
  *((_QWORD *)this + 11) = 0;
  v13 = *((_QWORD *)this + 12);
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  *((_QWORD *)this + 12) = 0;
  v14 = *((_QWORD *)this + 13);
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
  *((_QWORD *)this + 13) = 0;
  v15 = *((_QWORD *)this + 14);
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  *((_QWORD *)this + 14) = 0;
  PCSingleton::~PCSingleton(this);
}

{
  OZInterpolatorStrategies::~OZInterpolatorStrategies(this);
  JUMPOUT(0x1B5E29170);
}

uint64_t OZInterpolatorStrategies::getInterpolator(OZInterpolatorStrategies *this, int a2)
{
  char *v2;

  switch(a2)
  {
    case 0:
      v2 = (char *)this + 8;
      break;
    case 1:
    case 18:
      v2 = (char *)this + 16;
      break;
    case 6:
      v2 = (char *)this + 32;
      break;
    case 7:
      v2 = (char *)this + 40;
      break;
    case 8:
      v2 = (char *)this + 48;
      break;
    case 13:
      v2 = (char *)this + 56;
      break;
    case 14:
      v2 = (char *)this + 64;
      break;
    case 15:
      v2 = (char *)this + 88;
      break;
    case 16:
      v2 = (char *)this + 72;
      break;
    case 17:
      v2 = (char *)this + 80;
      break;
    case 19:
      v2 = (char *)this + 96;
      break;
    case 20:
      v2 = (char *)this + 104;
      break;
    case 21:
      v2 = (char *)this + 112;
      break;
    default:
      v2 = (char *)this + 24;
      break;
  }
  return *(_QWORD *)v2;
}

uint64_t OZInterpolatorStrategies::getInstance(OZInterpolatorStrategies *this)
{
  if (OZInterpolatorStrategies::getInstance(void)::once != -1)
    dispatch_once(&OZInterpolatorStrategies::getInstance(void)::once, &__block_literal_global_64);
  return OZInterpolatorStrategies::_instance;
}

void ___ZN24OZInterpolatorStrategies11getInstanceEv_block_invoke()
{
  OZInterpolatorStrategies *v0;

  v0 = (OZInterpolatorStrategies *)operator new();
  OZInterpolatorStrategies::OZInterpolatorStrategies(v0);
  OZInterpolatorStrategies::_instance = (uint64_t)v0;
}

void sub_1B2C3BC68(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0xA1C40706B6075);
  _Unwind_Resume(a1);
}

void OZLinearInterpolator::OZLinearInterpolator(OZLinearInterpolator *this)
{
  _QWORD *v1;

  OZInterpolator::OZInterpolator(this);
  *v1 = &off_1E6555608;
}

void OZLinearInterpolator::~OZLinearInterpolator(OZChannelBase *this, const PCString *a2)
{
  OZChannelBase::setRangeName(this, a2);
  JUMPOUT(0x1B5E29170);
}

void OZLinearInterpolator::interpolate(OZLinearInterpolator *this, OZSpline *a2, const CMTime *a3, char *a4, char *a5, const CMTime *a6)
{
  __n128 v12;
  CMTime v13;
  CMTime v14;
  CMTime time;
  CMTime v16;
  CMTime v17;
  CMTime v18;
  CMTime time2;
  CMTime time1;

  v18 = *(CMTime *)(a4 + 16);
  v17 = *(CMTime *)(a5 + 16);
  time1 = *(CMTime *)(a4 + 16);
  time2 = *(CMTime *)(a5 + 16);
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    OZSpline::getSmallDeltaU(a2, &v16);
    time1 = v18;
    time2 = v16;
    v12.n128_f64[0] = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v17);
  }
  memset(&v16, 0, sizeof(v16));
  (*(void (**)(CMTime *__return_ptr, OZLinearInterpolator *, OZSpline *, const CMTime *, char *, char *, __n128))(*(_QWORD *)this + 104))(&v16, this, a2, a6, a4, a5, v12);
  time1 = v18;
  time2 = v17;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&time);
  CMTimeGetSeconds(&time);
  time1 = v16;
  time2 = v17;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v14);
  CMTimeGetSeconds(&v14);
  time1 = v16;
  time2 = v18;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v13);
  CMTimeGetSeconds(&v13);
  (*(void (**)(char *, const CMTime *))(*(_QWORD *)a4 + 24))(a4, a3);
  (*(double (**)(char *, const CMTime *))(*(_QWORD *)a5 + 24))(a5, a3);
}

uint64_t OZLinearInterpolator::subDivide(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;

  v12 = *(_OWORD *)(a6 + 16);
  v13 = *(_QWORD *)(a6 + 32);
  (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)a1 + 104))(&v10);
  v12 = v10;
  v13 = v11;
  (*(void (**)(uint64_t, __int128 *, uint64_t, _QWORD))(*(_QWORD *)a2 + 240))(a2, &v12, a3, 0);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a6 + 32))(a6, a3);
}

void OZLinearInterpolator::getMinMaxValues(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CMTime *a5, CMTime *a6, double *a7, double *a8)
{
  uint64_t v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  CMTime v22;
  CMTime v23;
  CMTime time2;
  CMTime time1;

  *(_OWORD *)&v23.value = *(_OWORD *)(a3 + 16);
  v23.epoch = *(_QWORD *)(a3 + 32);
  *(_OWORD *)&v22.value = *(_OWORD *)(a4 + 16);
  v22.epoch = *(_QWORD *)(a4 + 32);
  v16 = MEMORY[0x1E0CA2E68];
  v17 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, MEMORY[0x1E0CA2E68]);
  v18 = (*(double (**)(uint64_t, uint64_t))(*(_QWORD *)a4 + 24))(a4, v16);
  time1 = *a5;
  time2 = v23;
  v19 = v17;
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    time1 = *a5;
    time2 = v22;
    v19 = v18;
    if (CMTimeCompare(&time1, &time2) < 0)
      v19 = (*(double (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, CMTime *, _QWORD, _QWORD))(*(_QWORD *)a1 + 24))(a1, a2, MEMORY[0x1E0CA2E68], a3, a4, a5, 0, 0);
  }
  time1 = *a6;
  time2 = v23;
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    time1 = *a6;
    time2 = v22;
    v17 = v18;
    if (CMTimeCompare(&time1, &time2) < 0)
      v17 = (*(double (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, CMTime *, _QWORD, _QWORD))(*(_QWORD *)a1 + 24))(a1, a2, MEMORY[0x1E0CA2E68], a3, a4, a6, 0, 0);
  }
  if (v17 >= v19)
    v20 = v19;
  else
    v20 = v17;
  if (v17 >= v19)
    v21 = v17;
  else
    v21 = v19;
  *a7 = v20;
  *a8 = v21;
}

BOOL OZLinearInterpolator::uForCurveValue(double a1, uint64_t a2, uint64_t a3, _BYTE **a4, _BYTE **a5, uint64_t a6, uint64_t a7, void **a8)
{
  uint64_t v14;
  double v15;
  double v16;
  double v17;
  _BOOL8 v18;
  uint64_t v19;
  double v20;
  double v21;
  BOOL v22;
  double v23;
  char *v24;
  char *v25;
  __int128 v26;
  char *v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  char *v34;
  __int128 v35;
  char *v36;
  char *v37;
  __int128 v38;
  CMTime v40;
  __int128 v41;
  uint64_t v42;
  CMTime v43;
  CMTime v44;
  CMTime v45;
  CMTime v46;

  v14 = MEMORY[0x1E0CA2E68];
  v15 = (*(double (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a3 + 240))(a3, a6, MEMORY[0x1E0CA2E68], 0);
  v16 = (*(double (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a3 + 240))(a3, a7, v14, 0);
  if (v15 >= v16)
    v17 = v15;
  else
    v17 = v16;
  if (v15 <= v16)
    v16 = v15;
  v18 = v16 <= a1 && v17 >= a1;
  if (v18)
  {
    v44 = *(CMTime *)(a4 + 2);
    v46 = *(CMTime *)(a5 + 2);
    v19 = MEMORY[0x1E0CA2E68];
    v20 = (*((double (**)(_BYTE **, _QWORD))*a4 + 3))(a4, MEMORY[0x1E0CA2E68]);
    v21 = (*((double (**)(_BYTE **, uint64_t))*a5 + 3))(a5, v19) - v20;
    memset(&v43, 0, sizeof(v43));
    v45 = v44;
    PC_CMTimeSaferSubtract(&v46, &v45, (uint64_t)&v43);
    v22 = v21 >= 0.0000001 || v21 <= -0.0000001;
    v23 = 0.001;
    if (v22)
      v23 = v21;
    v41 = 0uLL;
    v42 = 0;
    operator*(&v43, &v40, (a1 - v20) / v23);
    v46 = v44;
    v45 = v40;
    PC_CMTimeSaferAdd(&v46, &v45, (uint64_t)&v41);
    v24 = (char *)a8[2];
    v25 = (char *)a8[1];
    if (v25 >= v24)
    {
      v28 = 0xAAAAAAAAAAAAAAABLL * ((v25 - (_BYTE *)*a8) >> 3);
      v29 = v28 + 1;
      if (v28 + 1 > 0xAAAAAAAAAAAAAAALL)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v30 = 0xAAAAAAAAAAAAAAABLL * ((v24 - (_BYTE *)*a8) >> 3);
      if (2 * v30 > v29)
        v29 = 2 * v30;
      if (v30 >= 0x555555555555555)
        v31 = 0xAAAAAAAAAAAAAAALL;
      else
        v31 = v29;
      if (v31)
        v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a8 + 2), v31);
      else
        v32 = 0;
      v33 = &v32[24 * v28];
      v34 = &v32[24 * v31];
      v35 = v41;
      *((_QWORD *)v33 + 2) = v42;
      *(_OWORD *)v33 = v35;
      v27 = v33 + 24;
      v37 = (char *)*a8;
      v36 = (char *)a8[1];
      if (v36 != *a8)
      {
        do
        {
          v38 = *(_OWORD *)(v36 - 24);
          *((_QWORD *)v33 - 1) = *((_QWORD *)v36 - 1);
          *(_OWORD *)(v33 - 24) = v38;
          v33 -= 24;
          v36 -= 24;
        }
        while (v36 != v37);
        v36 = (char *)*a8;
      }
      *a8 = v33;
      a8[1] = v27;
      a8[2] = v34;
      if (v36)
        operator delete(v36);
    }
    else
    {
      v26 = v41;
      *((_QWORD *)v25 + 2) = v42;
      *(_OWORD *)v25 = v26;
      v27 = v25 + 24;
    }
    a8[1] = v27;
  }
  return v18;
}

double OZLogarithmicInterpolator::interpolate(OZLogarithmicInterpolator *this, OZSpline *a2, const CMTime *a3, _BYTE **a4, _BYTE **a5, const CMTime *a6)
{
  double v10;
  double v11;
  Float64 Seconds;
  __int128 v14;
  CMTime time;
  CMTime v16;
  CMTime v17;
  CMTime v18;
  CMTime time2;
  CMTime time1;

  v18 = *(CMTime *)(a4 + 2);
  v17 = *(CMTime *)(a5 + 2);
  v10 = (*((double (**)(_BYTE **, const CMTime *))*a4 + 3))(a4, a3);
  v11 = (*((double (**)(_BYTE **, const CMTime *))*a5 + 3))(a5, a3);
  time1 = v18;
  time2 = v17;
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    OZSpline::getSmallDeltaU(a2, &v16);
    time1 = v18;
    time2 = v16;
    PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v17);
  }
  memset(&v16, 0, sizeof(v16));
  time1 = v17;
  time2 = v18;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v16);
  time1 = v16;
  time2 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  if (CMTimeCompare(&time1, &time2))
  {
    time1 = *a6;
    time2 = v18;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v14);
    operator/(&v14, (uint64_t)&v16, (uint64_t)&time);
    Seconds = CMTimeGetSeconds(&time);
    return v10 + (v11 - v10) / 6.90775528 * log(Seconds * 999.0 + 1.0);
  }
  return v10;
}

uint64_t OZLogarithmicInterpolator::subDivide(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __int128 v9;
  uint64_t v10;

  v9 = *(_OWORD *)(a6 + 16);
  v10 = *(_QWORD *)(a6 + 32);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __int128 *, _QWORD, _QWORD))(*(_QWORD *)a1 + 24))(a1, a2, a3, a4, a5, &v9, 0, 0);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a6 + 32))(a6, a3);
}

uint64_t OZLogarithmicInterpolator::uForCurveValue(double a1, uint64_t a2, OZSpline *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void **a8)
{
  uint64_t v14;
  double v15;
  __n128 v16;
  double v17;
  uint64_t v19;
  double v20;
  double v21;
  long double v22;
  char *v23;
  char *v24;
  __int128 v25;
  char *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  char *v32;
  char *v33;
  __int128 v34;
  char *v35;
  char *v36;
  __int128 v37;
  CMTime v39;
  __int128 v40;
  uint64_t v41;
  CMTime v42;
  CMTime v43;
  CMTime v44;
  CMTime time2;
  CMTime time1;

  v14 = MEMORY[0x1E0CA2E68];
  v15 = (*(double (**)(OZSpline *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a3 + 240))(a3, a6, MEMORY[0x1E0CA2E68], 0);
  v16.n128_f64[0] = (*(double (**)(OZSpline *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a3 + 240))(a3, a7, v14, 0);
  if (v15 >= v16.n128_f64[0])
    v17 = v15;
  else
    v17 = v16.n128_f64[0];
  if (v15 <= v16.n128_f64[0])
    v16.n128_f64[0] = v15;
  if (v17 >= a1 && v16.n128_f64[0] <= a1)
  {
    v19 = MEMORY[0x1E0CA2E68];
    v20 = (*(double (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)a4 + 24))(a4, MEMORY[0x1E0CA2E68], v16);
    v21 = (*(double (**)(uint64_t, uint64_t))(*(_QWORD *)a5 + 24))(a5, v19);
    v44 = *(CMTime *)(a4 + 16);
    v43 = *(CMTime *)(a5 + 16);
    time1 = *(CMTime *)(a4 + 16);
    time2 = *(CMTime *)(a5 + 16);
    if (CMTimeCompare(&time1, &time2) >= 1)
    {
      OZSpline::getSmallDeltaU(a3, &v42);
      time1 = v44;
      time2 = v42;
      PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v43);
    }
    memset(&v42, 0, sizeof(v42));
    time1 = v43;
    time2 = v44;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v42);
    v40 = 0uLL;
    v41 = 0;
    v22 = exp((a1 - v20) / ((v21 - v20) / 6.90775528));
    operator*(&v42, &v39, (v22 + -1.0) / 999.0);
    time1 = v39;
    time2 = v44;
    PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v40);
    v23 = (char *)a8[2];
    v24 = (char *)a8[1];
    if (v24 >= v23)
    {
      v27 = 0xAAAAAAAAAAAAAAABLL * ((v24 - (_BYTE *)*a8) >> 3);
      v28 = v27 + 1;
      if (v27 + 1 > 0xAAAAAAAAAAAAAAALL)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v29 = 0xAAAAAAAAAAAAAAABLL * ((v23 - (_BYTE *)*a8) >> 3);
      if (2 * v29 > v28)
        v28 = 2 * v29;
      if (v29 >= 0x555555555555555)
        v30 = 0xAAAAAAAAAAAAAAALL;
      else
        v30 = v28;
      if (v30)
        v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a8 + 2), v30);
      else
        v31 = 0;
      v32 = &v31[24 * v27];
      v33 = &v31[24 * v30];
      v34 = v40;
      *((_QWORD *)v32 + 2) = v41;
      *(_OWORD *)v32 = v34;
      v26 = v32 + 24;
      v36 = (char *)*a8;
      v35 = (char *)a8[1];
      if (v35 != *a8)
      {
        do
        {
          v37 = *(_OWORD *)(v35 - 24);
          *((_QWORD *)v32 - 1) = *((_QWORD *)v35 - 1);
          *(_OWORD *)(v32 - 24) = v37;
          v32 -= 24;
          v35 -= 24;
        }
        while (v35 != v36);
        v35 = (char *)*a8;
      }
      *a8 = v32;
      a8[1] = v26;
      a8[2] = v33;
      if (v35)
        operator delete(v35);
    }
    else
    {
      v25 = v40;
      *((_QWORD *)v24 + 2) = v41;
      *(_OWORD *)v24 = v25;
      v26 = v24 + 24;
    }
    a8[1] = v26;
  }
  return 0;
}

void OZSplineInterpolator::OZSplineInterpolator(OZSplineInterpolator *this)
{
  _QWORD *v1;

  OZInterpolator::OZInterpolator(this);
  *v1 = &off_1E6555738;
}

void OZSplineInterpolator::~OZSplineInterpolator(OZChannelBase *this, const PCString *a2)
{
  OZChannelBase::setRangeName(this, a2);
  JUMPOUT(0x1B5E29170);
}

uint64_t OZSplineInterpolator::useTangents(OZSplineInterpolator *this)
{
  return 1;
}

double OZSplineInterpolator::convertHandlesToTangents(uint64_t a1, uint64_t a2, double *a3, double *a4)
{
  double result;

  result = 0.333333333;
  if (!**(_BYTE **)(a2 + 168))
    result = 12.0;
  if (a3)
    *a3 = *a3 / result;
  if (a4)
  {
    result = *a4 / result;
    *a4 = result;
  }
  return result;
}

double OZSplineInterpolator::convertTangentsToHandles(uint64_t a1, uint64_t a2, double *a3, double *a4)
{
  double result;

  result = 0.333333333;
  if (!**(_BYTE **)(a2 + 168))
    result = 12.0;
  if (a3)
    *a3 = result * *a3;
  if (a4)
  {
    result = result * *a4;
    *a4 = result;
  }
  return result;
}

double OZSplineInterpolator::interpolate()
{
  return 0.0;
}

double OZSplineInterpolator::eval(OZSplineInterpolator *this, double *a2, double a3)
{
  return 0.0;
}

uint64_t OZSplineInterpolator::eval(OZSplineInterpolator *this, OZSpline *a2, const CMTime *a3, void *a4, void *a5, double a6)
{
  double v12;
  double v13;
  _BYTE v15[8];
  double v16;
  double v17[3];

  v17[2] = *(double *)MEMORY[0x1E0C80C00];
  (*(void (**)(void *, _QWORD, double *, const CMTime *))(*(_QWORD *)a4 + 64))(a4, 0, &v16, a3);
  (*(void (**)(void *, _QWORD, double *, const CMTime *))(*(_QWORD *)a5 + 56))(a5, 0, v17, a3);
  if (!**((_BYTE **)a2 + 21))
  {
    (*(void (**)(OZSplineInterpolator *, OZSpline *, _QWORD, double *))(*(_QWORD *)this + 48))(this, a2, 0, &v16);
    (*(void (**)(OZSplineInterpolator *, OZSpline *, _QWORD, double *))(*(_QWORD *)this + 48))(this, a2, 0, v17);
  }
  v12 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)a4 + 24))(a4, a3);
  v16 = v12 + v16;
  v13 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)a5 + 24))(a5, a3);
  v17[0] = v13 + v17[0];
  return (*(uint64_t (**)(OZSplineInterpolator *, _BYTE *, double))(*(_QWORD *)this + 112))(this, v15, a6);
}

void OZXSplineInterpolator::OZXSplineInterpolator(OZXSplineInterpolator *this)
{
  uint64_t v1;

  OZInterpolator::OZInterpolator(this);
  *(_QWORD *)v1 = &off_1E65557E0;
  *(_QWORD *)(v1 + 8) = 0;
  *(_QWORD *)(v1 + 16) = 0;
  *(_QWORD *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 32) = 0;
  *(_BYTE *)(v1 + 36) = 1;
}

void OZXSplineInterpolator::OZXSplineInterpolator(OZXSplineInterpolator *this, const OZXSplineInterpolator *a2)
{
  uint64_t v3;

  OZInterpolator::OZInterpolator(this);
  *(_QWORD *)v3 = &off_1E65557E0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_QWORD *)(v3 + 16) = 0;
  *(_QWORD *)(v3 + 24) = 0;
  *(_DWORD *)(v3 + 32) = *((_DWORD *)a2 + 8);
  *(_BYTE *)(v3 + 36) = *((_BYTE *)a2 + 36);
}

void OZXSplineInterpolator::~OZXSplineInterpolator(OZChannelBase *this, const PCString *a2)
{
  void **var1;

  this->var0 = (void **)&off_1E65557E0;
  var1 = (void **)this->var1;
  if (var1)
  {
    this->var2 = var1;
    operator delete(var1);
  }
  OZChannelBase::setRangeName(this, a2);
}

{
  OZXSplineInterpolator::~OZXSplineInterpolator(this, a2);
  JUMPOUT(0x1B5E29170);
}

BOOL OZXSplineInterpolator::operator==(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int8 *)(a1 + 36) == *(unsigned __int8 *)(a2 + 36) && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32);
}

uint64_t OZXSplineInterpolator::useKeypoints(OZXSplineInterpolator *this)
{
  return 0;
}

__n128 OZXSplineInterpolator::getAdjustedMaxU@<Q0>(OZXSplineInterpolator *this@<X0>, OZSpline *a2@<X1>, const CMTime *a3@<X2>, const CMTime *a4@<X3>, CMTime *a5@<X8>)
{
  int v10;
  __n128 result;

  if (OZSpline::getNumberOfValidVertices(a2, a3))
  {
    if ((*(unsigned int (**)(OZXSplineInterpolator *, OZSpline *))(*(_QWORD *)this + 88))(this, a2))
      (*(void (**)(OZXSplineInterpolator *, OZSpline *, const CMTime *))(*(_QWORD *)this + 16))(this, a2, a3);
    v10 = *((_DWORD *)this + 8);
    if (!*((_BYTE *)a2 + 144))
      --v10;
    OZFigTimeForChannelSeconds(a5, (double)v10, a4->timescale);
  }
  else
  {
    result = *(__n128 *)&a4->value;
    *(_OWORD *)&a5->value = *(_OWORD *)&a4->value;
    a5->epoch = a4->epoch;
  }
  return result;
}

uint64_t OZXSplineInterpolator::getAdjustedMinU@<X0>(OZXSplineInterpolator *this@<X0>, OZSpline *a2@<X1>, const CMTime *a3@<X2>, const CMTime *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t result;
  uint64_t v11;
  CMTimeEpoch epoch;

  result = OZSpline::getNumberOfValidVertices(a2, a3);
  if ((_DWORD)result)
  {
    result = (*(uint64_t (**)(OZXSplineInterpolator *, OZSpline *))(*(_QWORD *)this + 88))(this, a2);
    if ((_DWORD)result)
      result = (*(uint64_t (**)(OZXSplineInterpolator *, OZSpline *, const CMTime *))(*(_QWORD *)this + 16))(this, a2, a3);
    v11 = MEMORY[0x1E0CA2E68];
    *(_OWORD *)a5 = *MEMORY[0x1E0CA2E68];
    epoch = *(_QWORD *)(v11 + 16);
  }
  else
  {
    *(_OWORD *)a5 = *(_OWORD *)&a4->value;
    epoch = a4->epoch;
  }
  *(_QWORD *)(a5 + 16) = epoch;
  return result;
}

void OZXSplineInterpolator::init(OZXSplineInterpolator *this, OZSpline *a2, const CMTime *a3)
{
  int v5;
  int NumberOfValidVertices;
  int v7;

  v5 = *((unsigned __int8 *)a2 + 144);
  NumberOfValidVertices = OZSpline::getNumberOfValidVertices(a2, a3);
  if (v5)
    v7 = NumberOfValidVertices;
  else
    v7 = NumberOfValidVertices + 1;
  *((_DWORD *)this + 8) = v7;
  OZSpline::setDirty(a2, 0);
}

void OZXSplineInterpolator::initTempArrays(OZXSplineInterpolator *this, OZSpline *a2, const CMTime *a3)
{
  char **v6;
  void **v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  void **v15;
  char *v16;
  char *v17;
  char *v18;
  void *v19;
  unint64_t v20;
  void **v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  void **v28;
  char *v29;
  char *v30;
  void *v31;
  unint64_t v32;
  void **v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  void **v40;
  char *v41;
  char *v42;
  char *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;

  v46 = 0;
  v47 = 0;
  v6 = (char **)((char *)this + 8);
  *((_QWORD *)this + 2) = *((_QWORD *)this + 1);
  std::vector<void *>::reserve((void **)this + 1, *((int *)this + 8));
  OZSpline::getFirstValidVertex(a2, &v47, a3);
  OZSpline::getLastValidVertex(a2, &v46, a3);
  v7 = (void **)*((_QWORD *)this + 2);
  v8 = *((_QWORD *)this + 3);
  if ((unint64_t)v7 >= v8)
  {
    v10 = ((char *)v7 - *v6) >> 3;
    if ((unint64_t)(v10 + 1) >> 61)
      goto LABEL_54;
    v11 = v8 - (_QWORD)*v6;
    v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1))
      v12 = v10 + 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 24, v13);
    else
      v14 = 0;
    v15 = (void **)&v14[8 * v10];
    v16 = &v14[8 * v13];
    *v15 = v47;
    v9 = v15 + 1;
    v18 = (char *)*((_QWORD *)this + 1);
    v17 = (char *)*((_QWORD *)this + 2);
    if (v17 != v18)
    {
      do
      {
        v19 = (void *)*((_QWORD *)v17 - 1);
        v17 -= 8;
        *--v15 = v19;
      }
      while (v17 != v18);
      v17 = *v6;
    }
    *((_QWORD *)this + 1) = v15;
    *((_QWORD *)this + 2) = v9;
    *((_QWORD *)this + 3) = v16;
    if (v17)
      operator delete(v17);
  }
  else
  {
    *v7 = v47;
    v9 = v7 + 1;
  }
  *((_QWORD *)this + 2) = v9;
  v45 = v47;
  if (OZSpline::getNextValidVertex((void ***)a2, v47, &v45, a3))
  {
    do
    {
      v21 = (void **)*((_QWORD *)this + 2);
      v20 = *((_QWORD *)this + 3);
      if ((unint64_t)v21 >= v20)
      {
        v23 = ((char *)v21 - *v6) >> 3;
        if ((unint64_t)(v23 + 1) >> 61)
          goto LABEL_54;
        v24 = v20 - (_QWORD)*v6;
        v25 = v24 >> 2;
        if (v24 >> 2 <= (unint64_t)(v23 + 1))
          v25 = v23 + 1;
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8)
          v26 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v26 = v25;
        if (v26)
          v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 24, v26);
        else
          v27 = 0;
        v28 = (void **)&v27[8 * v23];
        *v28 = v45;
        v22 = v28 + 1;
        v30 = (char *)*((_QWORD *)this + 1);
        v29 = (char *)*((_QWORD *)this + 2);
        if (v29 != v30)
        {
          do
          {
            v31 = (void *)*((_QWORD *)v29 - 1);
            v29 -= 8;
            *--v28 = v31;
          }
          while (v29 != v30);
          v29 = *v6;
        }
        *((_QWORD *)this + 1) = v28;
        *((_QWORD *)this + 2) = v22;
        *((_QWORD *)this + 3) = &v27[8 * v26];
        if (v29)
          operator delete(v29);
      }
      else
      {
        *v21 = v45;
        v22 = v21 + 1;
      }
      *((_QWORD *)this + 2) = v22;
    }
    while ((OZSpline::getNextValidVertex((void ***)a2, v45, &v45, a3) & 1) != 0);
  }
  if (!*((_BYTE *)a2 + 144))
  {
    v33 = (void **)*((_QWORD *)this + 2);
    v32 = *((_QWORD *)this + 3);
    if ((unint64_t)v33 < v32)
    {
      *v33 = v46;
      v34 = v33 + 1;
LABEL_52:
      *((_QWORD *)this + 2) = v34;
      goto LABEL_53;
    }
    v35 = ((char *)v33 - *v6) >> 3;
    if (!((unint64_t)(v35 + 1) >> 61))
    {
      v36 = v32 - (_QWORD)*v6;
      v37 = v36 >> 2;
      if (v36 >> 2 <= (unint64_t)(v35 + 1))
        v37 = v35 + 1;
      if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8)
        v38 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v38 = v37;
      if (v38)
        v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 24, v38);
      else
        v39 = 0;
      v40 = (void **)&v39[8 * v35];
      v41 = &v39[8 * v38];
      *v40 = v46;
      v34 = v40 + 1;
      v43 = (char *)*((_QWORD *)this + 1);
      v42 = (char *)*((_QWORD *)this + 2);
      if (v42 != v43)
      {
        do
        {
          v44 = (void *)*((_QWORD *)v42 - 1);
          v42 -= 8;
          *--v40 = v44;
        }
        while (v42 != v43);
        v42 = *v6;
      }
      *((_QWORD *)this + 1) = v40;
      *((_QWORD *)this + 2) = v34;
      *((_QWORD *)this + 3) = v41;
      if (v42)
        operator delete(v42);
      goto LABEL_52;
    }
LABEL_54:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
LABEL_53:
  OZSpline::setDirty(a2, 0);
}

void OZXSplineInterpolator::interpolate(OZXSplineInterpolator *this, OZSpline *a2, const CMTime *a3, void *a4, void *a5, const CMTime *a6, int a7)
{
  double Seconds;
  CMTime v12;

  if (a7)
  {
    if (*((_DWORD *)this + 8))
      OZXSplineInterpolator::initTempArrays(this, a2, a3);
    v12 = *a6;
    Seconds = CMTimeGetSeconds(&v12);
    OZXSplineInterpolator::evalXSpline(this, a2, Seconds, a3);
  }
}

void OZXSplineInterpolator::evalXSpline(OZXSplineInterpolator *this, OZSpline *a2, double a3, const CMTime *a4)
{
  double v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  BOOL v12;
  double v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  uint64_t v21;
  double v22;
  double v23;
  double v24;
  uint64_t v25;
  void *v26;
  double v28;
  uint64_t v29;
  double v30;
  uint64_t v31;
  void *v32;
  double v34;
  uint64_t v35;
  double v36;
  int8x16_t v37;
  float64x2_t v38;
  float64x2_t v39;
  double v40;
  float64x2_t v41;
  float64x2_t v42;
  double v43;
  double v44;
  float64x2_t v45;
  float64x2_t v46;
  double v47;
  __n128 v48;
  double v49;
  float64x2_t v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  float64x2_t v59;
  float64x2_t v61;
  float64x2_t v63;
  float64x2_t v65;
  float64x2_t v68;
  float64x2_t v69;
  double v70;
  double v71;
  double v72;
  double v73;
  double v74;
  double v75;
  uint64_t v76;
  _QWORD *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  int v83;
  double v84;
  uint64_t v85;
  int v86;
  int v87;
  double v88;
  uint64_t v89;
  int v90;
  double v91;
  uint64_t v92;
  double v93;
  double v94;
  uint64_t v95;
  float64_t v98;
  void *v99;
  void *v100;

  v7 = floor(a3) + -1.0;
  v8 = (int)v7;
  if (*((_BYTE *)a2 + 144))
  {
    if (v8 < -2)
      return;
    *(double *)&v95 = v7;
    v9 = *((_DWORD *)this + 8);
    v10 = (v9 & (v8 >> 31)) + v8;
    v11 = *(_QWORD *)(*((_QWORD *)this + 1) + 8 * ((v10 + 1) % v9));
    v12 = (*(double (**)(uint64_t, const CMTime *, double))(*(_QWORD *)v11 + 40))(v11, a4, 0.0) <= 1.0;
    v13 = 1.0;
    if (v12)
    {
      v14 = *(_QWORD *)(*((_QWORD *)this + 1) + 8 * ((v10 + 1) % *((_DWORD *)this + 8)));
      v13 = (*(double (**)(uint64_t, const CMTime *, double))(*(_QWORD *)v14 + 40))(v14, a4, 1.0);
    }
    v93 = v13;
    v15 = *(_QWORD *)(*((_QWORD *)this + 1) + 8 * ((v10 + 2) % *((_DWORD *)this + 8)));
    v16 = (*(double (**)(uint64_t, const CMTime *))(*(_QWORD *)v15 + 40))(v15, a4);
    __asm { FMOV            V20.2D, #1.0 }
    _Q20.f64[1] = v93;
    if (v16 <= 1.0)
    {
      v21 = *(_QWORD *)(*((_QWORD *)this + 1) + 8 * ((v10 + 2) % *((_DWORD *)this + 8)));
      v22 = (*(double (**)(uint64_t, const CMTime *))(*(_QWORD *)v21 + 40))(v21, a4);
      _Q20.f64[1] = v93;
      _Q20.f64[0] = v22;
    }
    v23 = a3;
  }
  else
  {
    *(double *)&v95 = v7;
    v99 = 0;
    v100 = 0;
    OZSpline::getFirstValidVertex(a2, &v100, a4);
    OZSpline::getLastValidVertex(a2, &v99, a4);
    if (v8 < 0)
      v10 = -1;
    else
      v10 = v8;
    _Q20.f64[0] = 0.0;
    v24 = 0.0;
    if ((v8 & 0x80000000) == 0)
    {
      v24 = 0.0;
      if (v10 < *((_DWORD *)this + 8) - 1)
      {
        v25 = (v10 + 1);
        v26 = *(void **)(*((_QWORD *)this + 1) + 8 * v25);
        v24 = 1.0;
        if (v26 != v100 && v26 != v99)
        {
          v28 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v26 + 40))(v26, a4);
          _Q20.f64[0] = 0.0;
          v24 = 1.0;
          if (v28 <= 1.0)
          {
            v29 = *(_QWORD *)(*((_QWORD *)this + 1) + 8 * v25);
            v30 = (*(double (**)(uint64_t, const CMTime *))(*(_QWORD *)v29 + 40))(v29, a4);
            _Q20.f64[0] = 0.0;
            v24 = v30;
          }
        }
      }
    }
    v31 = (v10 + 2);
    v23 = a3;
    if ((int)v31 < *((_DWORD *)this + 8) - 1)
    {
      v32 = *(void **)(*((_QWORD *)this + 1) + 8 * v31);
      _Q20.f64[0] = 1.0;
      if (v32 != v100 && v32 != v99)
      {
        v94 = v24;
        v34 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v32 + 40))(v32, a4);
        v24 = v94;
        v23 = a3;
        _Q20.f64[0] = 1.0;
        if (v34 <= 1.0)
        {
          v35 = *(_QWORD *)(*((_QWORD *)this + 1) + 8 * v31);
          v36 = (*(double (**)(uint64_t, const CMTime *))(*(_QWORD *)v35 + 40))(v35, a4);
          v24 = v94;
          v23 = a3;
          _Q20.f64[0] = v36;
        }
      }
    }
    _Q20.f64[1] = v24;
  }
  v37 = (int8x16_t)vaddq_f64((float64x2_t)vdupq_lane_s64(v95, 0), (float64x2_t)xmmword_1B3556780);
  v38 = vmaxnmq_f64(_Q20, (float64x2_t)0);
  v39 = vaddq_f64((float64x2_t)v37, v38);
  v40 = v39.f64[1];
  v41 = vsubq_f64((float64x2_t)v37, v38);
  v42.f64[0] = v39.f64[0];
  v42.f64[1] = v41.f64[1];
  v43 = *(double *)&v95 - v39.f64[1];
  v44 = v43 * v43 + v43 * v43;
  v45 = vsubq_f64((float64x2_t)vextq_s8(v37, v37, 8uLL), v42);
  v48 = (__n128)vmulq_f64(v45, v45);
  v46 = vaddq_f64((float64x2_t)v48, (float64x2_t)v48);
  v47 = *(double *)&v95 + 3.0 - v41.f64[0];
  v48.n128_f64[0] = v47 * v47 + v47 * v47;
  v49 = v23 - v39.f64[1];
  if (*((_BYTE *)this + 36))
  {
    __asm { FMOV            V19.2D, #-0.5 }
    v51 = (float64x2_t)vandq_s8((int8x16_t)vmulq_f64(_Q20, _Q19), (int8x16_t)vcltzq_f64(_Q20));
    v52 = v49 / v43;
    v53 = 0.0;
    if (v51.f64[1] <= 0.0)
      v54 = 0.0;
    else
      v54 = v52
          * (v51.f64[1] + v52 * (v51.f64[1] + v51.f64[1] - v52 * v52 * (v51.f64[1] + v51.f64[1] + v51.f64[1] * v52)));
    v55 = v52
        * (v51.f64[1]
         + v52
         * (v51.f64[1]
          + v51.f64[1]
          + v52
          * (vmuld_lane_f64(-12.0, v51, 1)
           + 10.0
           - v44
           + v52 * (v52 * (vmuld_lane_f64(-5.0, v51, 1) + 6.0 - v44) + vmuld_lane_f64(14.0, v51, 1) + v44 + v44 + -15.0))));
    if (v40 >= v23)
      v56 = v55;
    else
      v56 = v54;
    v57 = v51.f64[0] + v51.f64[0];
    __asm { FMOV            V7.2D, #-12.0 }
    v59 = vmulq_f64(v51, _Q7);
    __asm { FMOV            V7.2D, #14.0 }
    v61 = vmulq_f64(v51, _Q7);
    __asm { FMOV            V21.2D, #-5.0 }
    v63 = vdivq_f64(vsubq_f64((float64x2_t)vdupq_lane_s64(*(uint64_t *)&v23, 0), v42), v45);
    __asm { FMOV            V4.2D, #10.0 }
    v65 = vaddq_f64(v59, _Q4);
    __asm
    {
      FMOV            V20.2D, #-15.0
      FMOV            V16.2D, #6.0
    }
    v68 = vaddq_f64(vmulq_f64(v51, _Q21), _Q16);
    v59.f64[0] = v51.f64[0] + v51.f64[0];
    v59.f64[1] = v51.f64[1] + v51.f64[1];
    v69 = vmulq_f64(v63, vaddq_f64(v51, vmulq_f64(v63, vaddq_f64(v59, vmulq_f64(v63, vaddq_f64(vsubq_f64(v65, v46), vmulq_f64(v63, vaddq_f64(vmulq_f64(v63, vsubq_f64(v68, v46)), vaddq_f64(vaddq_f64(v61, vaddq_f64(v46, v46)), _Q20)))))))));
    if (v41.f64[0] <= v23)
    {
      v53 = (v23 - v41.f64[0])
          / v47
          * (v51.f64[0]
           + (v23 - v41.f64[0])
           / v47
           * (v57
            + (v23 - v41.f64[0])
            / v47
            * (v65.f64[0]
             - v48.n128_f64[0]
             + (v23 - v41.f64[0])
             / v47
             * ((v23 - v41.f64[0]) / v47 * (v68.f64[0] - v48.n128_f64[0])
              + v61.f64[0]
              + v48.n128_f64[0]
              + v48.n128_f64[0]
              + -15.0))));
    }
    else if (v51.f64[0] > 0.0)
    {
      v53 = (v23 - v41.f64[0])
          / v47
          * (v51.f64[0]
           + (v23 - v41.f64[0])
           / v47
           * (v57
            - (v23 - v41.f64[0]) / v47 * ((v23 - v41.f64[0]) / v47) * (v57 + v51.f64[0] * ((v23 - v41.f64[0]) / v47))));
    }
  }
  else
  {
    if (v39.f64[1] >= v23 || (v56 = 0.0, vabdd_f64(v23, v39.f64[1]) < 0.0000001))
      v56 = v49
          / v43
          * (v49
           / v43
           * (v49
            / v43))
          * (v49 / v43 * (v49 / v43 * (6.0 - v44)) + 10.0 - v44 + v49 / v43 * (v44 + v44 + -15.0));
    v70 = v23 - v39.f64[0];
    if (v39.f64[0] >= v23 || (v69.f64[0] = 0.0, fabs(v70) < 0.0000001))
      v69.f64[0] = v70
                 / v45.f64[0]
                 * (v70
                  / v45.f64[0]
                  * (v70
                   / v45.f64[0]))
                 * (v70 / v45.f64[0] * (v70 / v45.f64[0] * (6.0 - v46.f64[0]))
                  + 10.0
                  - v46.f64[0]
                  + v70 / v45.f64[0] * (v46.f64[0] + v46.f64[0] + -15.0));
    v71 = v23 - v41.f64[1];
    if (v41.f64[1] <= v23 || (v72 = 0.0, fabs(v71) < 0.0000001))
      v72 = v71
          / v45.f64[1]
          * (v71
           / v45.f64[1]
           * (v71
            / v45.f64[1]))
          * (v71 / v45.f64[1] * (v71 / v45.f64[1] * (6.0 - v46.f64[1]))
           + 10.0
           - v46.f64[1]
           + v71 / v45.f64[1] * (v46.f64[1] + v46.f64[1] + -15.0));
    v73 = v23 - v41.f64[0];
    v69.f64[1] = v72;
    if (v41.f64[0] <= v23 || (v53 = 0.0, fabs(v73) < 0.0000001))
      v53 = v73
          / v47
          * (v73
           / v47
           * (v73
            / v47))
          * (v73 / v47 * (v73 / v47 * (6.0 - v48.n128_f64[0]))
           + 10.0
           - v48.n128_f64[0]
           + v73 / v47 * (v48.n128_f64[0] + v48.n128_f64[0] + -15.0));
  }
  v74 = v69.f64[1];
  v75 = fabs(v56);
  v98 = v69.f64[0];
  if (*((_BYTE *)a2 + 144))
  {
    if (v10 < 0)
    {
      if (v75 < 0.0000001)
        goto LABEL_61;
      v76 = *((int *)this + 8) - 1;
    }
    else
    {
      if (v75 < 0.0000001)
        goto LABEL_61;
      v76 = (v10 % *((_DWORD *)this + 8));
    }
    v78 = *(_QWORD *)(*((_QWORD *)this + 1) + 8 * v76);
    (*(double (**)(uint64_t, const CMTime *))(*(_QWORD *)v78 + 24))(v78, a4);
    v69.f64[0] = v98;
LABEL_61:
    if (fabs(v69.f64[0]) >= 0.0000001)
    {
      v79 = *(_QWORD *)(*((_QWORD *)this + 1) + 8 * ((v10 + 1) % *((_DWORD *)this + 8)));
      (*(double (**)(uint64_t, const CMTime *))(*(_QWORD *)v79 + 24))(v79, a4);
    }
    if (fabs(v74) >= 0.0000001)
    {
      v80 = *(_QWORD *)(*((_QWORD *)this + 1) + 8 * ((v10 + 2) % *((_DWORD *)this + 8)));
      (*(double (**)(uint64_t, const CMTime *))(*(_QWORD *)v80 + 24))(v80, a4);
    }
    v48.n128_u64[0] = 0;
    if (fabs(v53) >= 0.0000001)
    {
      v81 = (v10 + 3) % *((_DWORD *)this + 8);
      goto LABEL_87;
    }
    return;
  }
  if (v10 < 0)
  {
    if (v75 < 0.0000001)
      goto LABEL_70;
    v77 = (_QWORD *)*((_QWORD *)this + 1);
  }
  else
  {
    if (v75 < 0.0000001)
      goto LABEL_70;
    v77 = (_QWORD *)(*((_QWORD *)this + 1) + 8 * v10);
  }
  (*(double (**)(_QWORD, const CMTime *))(*(_QWORD *)*v77 + 24))(*v77, a4);
  v69.f64[0] = v98;
LABEL_70:
  v82 = v10 + 1;
  v83 = *((_DWORD *)this + 8);
  v84 = fabs(v69.f64[0]);
  if (v10 + 1 >= v83)
  {
    if (v84 < 0.0000001)
      goto LABEL_76;
    v82 = v83 - 1;
    goto LABEL_75;
  }
  if (v84 >= 0.0000001)
  {
LABEL_75:
    v85 = *(_QWORD *)(*((_QWORD *)this + 1) + 8 * v82);
    (*(double (**)(uint64_t, const CMTime *))(*(_QWORD *)v85 + 24))(v85, a4);
  }
LABEL_76:
  v86 = v10 + 2;
  v87 = *((_DWORD *)this + 8);
  v88 = fabs(v74);
  if (v10 + 2 >= v87)
  {
    if (v88 < 0.0000001)
      goto LABEL_82;
    v86 = v87 - 1;
    goto LABEL_81;
  }
  if (v88 >= 0.0000001)
  {
LABEL_81:
    v89 = *(_QWORD *)(*((_QWORD *)this + 1) + 8 * v86);
    (*(double (**)(uint64_t, const CMTime *))(*(_QWORD *)v89 + 24))(v89, a4);
  }
LABEL_82:
  v81 = v10 + 3;
  v90 = *((_DWORD *)this + 8);
  v91 = fabs(v53);
  v48.n128_u64[0] = 0;
  if (v10 + 3 >= v90)
  {
    if (v91 < 0.0000001)
      return;
    v81 = v90 - 1;
    goto LABEL_87;
  }
  if (v91 >= 0.0000001)
  {
LABEL_87:
    v92 = *(_QWORD *)(*((_QWORD *)this + 1) + 8 * v81);
    (*(double (**)(uint64_t, const CMTime *, __n128))(*(_QWORD *)v92 + 24))(v92, a4, v48);
  }
}

uint64_t OZXSplineInterpolator::needInit()
{
  return 1;
}

uint64_t OZXSplineInterpolator::subDivide(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE **a4, _BYTE **a5, _BYTE **a6)
{
  double v9;
  double v10;
  double Seconds;
  Float64 v12;
  CMTime v14;
  CMTime time;
  CMTime v16;
  CMTime v17;
  CMTime v18;
  CMTime v19;

  v17 = *(CMTime *)(a4 + 2);
  v9 = (*((double (**)(_BYTE **, uint64_t))*a4 + 3))(a4, a3);
  v16 = *(CMTime *)(a5 + 2);
  v10 = (*((double (**)(_BYTE **, uint64_t))*a5 + 3))(a5, a3);
  v19 = *(CMTime *)(a6 + 2);
  v18 = v17;
  PC_CMTimeSaferSubtract(&v19, &v18, (uint64_t)&time);
  Seconds = CMTimeGetSeconds(&time);
  v19 = v16;
  v18 = v17;
  PC_CMTimeSaferSubtract(&v19, &v18, (uint64_t)&v14);
  v12 = CMTimeGetSeconds(&v14);
  return (*((uint64_t (**)(_BYTE **, _QWORD, double))*a6 + 4))(a6, MEMORY[0x1E0CA2E68], v9 + Seconds * ((v10 - v9) / v12));
}

void sub_1B2C3DD34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  uint64_t v10;

  PCString::~PCString(&a10);
  MEMORY[0x1B5E29170](v10, 0x10E1C401ABBD6EFLL);
  _Unwind_Resume(a1);
}

void sub_1B2C3E040(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  if (a16)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

void OZConstantNode::OZConstantNode(OZConstantNode *this, double a2)
{
  uint64_t v3;

  OZCurveNode::OZCurveNode(this);
  *(_QWORD *)v3 = &off_1E6555878;
  *(double *)(v3 + 8) = a2;
  *(double *)(v3 + 16) = a2;
}

void OZConstantNode::OZConstantNode(OZConstantNode *this, const OZConstantNode *a2)
{
  uint64_t v3;

  OZCurveNode::OZCurveNode(this);
  *(_QWORD *)v3 = &off_1E6555878;
  *(_OWORD *)(v3 + 8) = *(_OWORD *)((char *)a2 + 8);
}

void OZConstantNode::~OZConstantNode(OZChannelBase *this, const PCString *a2)
{
  OZChannelBase::setRangeName(this, a2);
  JUMPOUT(0x1B5E29170);
}

double OZConstantNode::getMaxValue(OZConstantNode *this)
{
  return *((double *)this + 1);
}

double OZConstantNode::getMinValue(OZConstantNode *this)
{
  return *((double *)this + 1);
}

double OZConstantNode::solveNode(OZConstantNode *this, const CMTime *a2, double a3, double a4)
{
  return *((double *)this + 1);
}

double OZConstantNode::solveNode(OZConstantNode *this, OZCurveNodeParam *a2)
{
  int v2;
  double *v3;
  double result;

  v2 = *((_DWORD *)a2 + 36);
  if (v2)
  {
    v3 = (double *)*((_QWORD *)a2 + 19);
    do
    {
      result = *((double *)this + 1);
      *v3++ = result;
      --v2;
    }
    while (v2);
  }
  return result;
}

BOOL OZConstantNode::getUForValue(uint64_t a1, void **a2, __int128 *a3, double a4)
{
  double v4;
  uint64_t v6;
  char *v7;
  char *v8;
  __int128 v9;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;
  __int128 v22;
  uint64_t v23;

  v4 = vabdd_f64(*(double *)(a1 + 8), a4);
  if (v4 < 0.0000001)
  {
    v22 = *a3;
    v23 = *((_QWORD *)a3 + 2);
    v6 = (uint64_t)(a2 + 2);
    v7 = (char *)a2[2];
    v8 = (char *)a2[1];
    if (v8 >= v7)
    {
      v11 = 0xAAAAAAAAAAAAAAABLL * ((v8 - (_BYTE *)*a2) >> 3);
      v12 = v11 + 1;
      if (v11 + 1 > 0xAAAAAAAAAAAAAAALL)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v13 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (_BYTE *)*a2) >> 3);
      if (2 * v13 > v12)
        v12 = 2 * v13;
      if (v13 >= 0x555555555555555)
        v14 = 0xAAAAAAAAAAAAAAALL;
      else
        v14 = v12;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>(v6, v14);
      else
        v15 = 0;
      v16 = &v15[24 * v11];
      v17 = &v15[24 * v14];
      *(_OWORD *)v16 = v22;
      *((_QWORD *)v16 + 2) = v23;
      v10 = v16 + 24;
      v19 = (char *)*a2;
      v18 = (char *)a2[1];
      if (v18 != *a2)
      {
        do
        {
          v20 = *(_OWORD *)(v18 - 24);
          *((_QWORD *)v16 - 1) = *((_QWORD *)v18 - 1);
          *(_OWORD *)(v16 - 24) = v20;
          v16 -= 24;
          v18 -= 24;
        }
        while (v18 != v19);
        v18 = (char *)*a2;
      }
      *a2 = v16;
      a2[1] = v10;
      a2[2] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      v9 = *a3;
      *((_QWORD *)v8 + 2) = *((_QWORD *)a3 + 2);
      *(_OWORD *)v8 = v9;
      v10 = v8 + 24;
    }
    a2[1] = v10;
  }
  return v4 < 0.0000001;
}

uint64_t OZConstantNode::cloneNode(OZConstantNode *this)
{
  uint64_t v2;

  v2 = operator new();
  OZCurveNode::OZCurveNode((OZCurveNode *)v2);
  *(_QWORD *)v2 = &off_1E6555878;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  return v2;
}

void sub_1B2C3E2F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1081C40468F112ELL);
  _Unwind_Resume(a1);
}

double *OZConstantNode::compare(OZConstantNode *this, const OZCurveNode *lpsrc)
{
  double *result;

  if (!lpsrc)
    return 0;
  if (result)
    return (double *)(*((double *)this + 1) == result[1] && *((double *)this + 2) == result[2]);
  return result;
}

__n128 OZConstantNode::operator=(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 8);
  *(__n128 *)(a1 + 8) = result;
  return result;
}

uint64_t OZConstantNode::operator==(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
}

__n128 OZConstantNode::getNeededRange(OZConstantNode *this, OZCurveNodeParam *a2)
{
  __n128 result;

  *(_OWORD *)((char *)a2 + 24) = *((_OWORD *)a2 + 6);
  *((_QWORD *)a2 + 5) = *((_QWORD *)a2 + 14);
  result = *(__n128 *)((char *)a2 + 120);
  *((__n128 *)a2 + 3) = result;
  *((_QWORD *)a2 + 8) = *((_QWORD *)a2 + 17);
  *((_DWORD *)a2 + 18) = *((_DWORD *)a2 + 36);
  *((_BYTE *)a2 + 88) = 0;
  *((_QWORD *)a2 + 10) = *((_QWORD *)a2 + 19);
  return result;
}

uint64_t OZConstantNode::setValue(uint64_t this, const CMTime *a2, double a3)
{
  *(double *)(this + 8) = a3;
  return this;
}

uint64_t OZConstantNode::setDefaultValue(uint64_t this, double a2)
{
  *(double *)(this + 16) = a2;
  return this;
}

double OZConstantNode::getDefaultValue(OZConstantNode *this)
{
  return *((double *)this + 2);
}

double OZConstantNode::getInitialValue(OZConstantNode *this)
{
  return *((double *)this + 1);
}

double OZConstantNode::reset(OZConstantNode *this)
{
  double result;

  result = *((double *)this + 2);
  *((double *)this + 1) = result;
  return result;
}

void sub_1B2C3E4D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  uint64_t v10;

  PCString::~PCString(&a10);
  MEMORY[0x1B5E29170](v10, 0x10F1C4072D3B705);
  _Unwind_Resume(a1);
}

void OZCurveNode::OZCurveNode(OZCurveNode *this)
{
  *(_QWORD *)this = off_1E6555970;
}

double OZCurveNode::getMaxValue(OZCurveNode *this)
{
  return 0.0;
}

double OZCurveNode::getMinValue(OZCurveNode *this)
{
  return 0.0;
}

uint64_t OZCurveNode::getTimeAndDistanceAlongCurve(OZCurveNode *this, const CMTime *a2, CMTime *a3, double *a4)
{
  return 0;
}

uint64_t OZCurveNode::getTimeAndDistanceAlongCurve(OZCurveNode *this, const CMTime *a2, unsigned int a3, CMTime *a4, double *a5)
{
  return 0;
}

uint64_t OZCurveNode::getParametricValueAndDoubleValueForTime(OZCurveNode *this, const CMTime *a2, CMTime *a3, double *a4)
{
  return 0;
}

double OZCurveNode::solveNode(OZCurveNode *this, const CMTime *a2, double a3, double a4)
{
  return a4;
}

uint64_t OZRecordingNode::OZRecordingNode(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;
  CMTime v9;

  OZCurveNode::OZCurveNode((OZCurveNode *)a1);
  *(_QWORD *)(v4 + 128) = v4 + 120;
  *(_QWORD *)(v4 + 136) = 0;
  *(_QWORD *)(v4 + 112) = a2;
  *(_QWORD *)(v4 + 120) = v4 + 120;
  *(_DWORD *)(v4 + 144) = 0;
  *(_QWORD *)(v4 + 24) = 0;
  *(_QWORD *)v4 = &off_1E6555A60;
  *(_QWORD *)(v4 + 8) = 0;
  *(_BYTE *)(v4 + 16) = 0;
  v5 = MEMORY[0x1E0CA2E68];
  v6 = *MEMORY[0x1E0CA2E68];
  *(_OWORD *)(v4 + 56) = *MEMORY[0x1E0CA2E68];
  v7 = *(_QWORD *)(v5 + 16);
  *(_OWORD *)(v4 + 32) = v6;
  *(_QWORD *)(v4 + 48) = v7;
  *(_QWORD *)(v4 + 72) = v7;
  *(_QWORD *)(v4 + 80) = 0;
  CMTimeMake(&v9, 1, 1);
  *(CMTime *)(a1 + 88) = v9;
  return a1;
}

void sub_1B2C3E82C(_Unwind_Exception *a1)
{
  OZChannelBase *v1;
  _QWORD *v2;
  PCSpinLock *v3;
  const PCString *v5;

  PCSpinLock::~PCSpinLock(v3);
  std::__list_imp<unsigned int>::clear(v2);
  OZChannelBase::setRangeName(v1, v5);
  _Unwind_Resume(a1);
}

__n128 OZRecordingNode::OZRecordingNode(OZCurveNode *a1, uint64_t a2)
{
  uint64_t v3;
  __int128 v4;
  __int128 v5;
  __n128 result;

  OZCurveNode::OZCurveNode(a1);
  *(_QWORD *)v3 = &off_1E6555A60;
  *(_QWORD *)(v3 + 128) = v3 + 120;
  *(_QWORD *)(v3 + 136) = 0;
  *(_DWORD *)(v3 + 144) = 0;
  *(_QWORD *)(v3 + 112) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(v3 + 120) = v3 + 120;
  *(_QWORD *)(v3 + 8) = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(v3 + 16) = 0;
  *(_QWORD *)(v3 + 24) = *(_QWORD *)(a2 + 24);
  v4 = *(_OWORD *)(a2 + 56);
  *(_QWORD *)(v3 + 72) = *(_QWORD *)(a2 + 72);
  *(_OWORD *)(v3 + 56) = v4;
  v5 = *(_OWORD *)(a2 + 32);
  *(_QWORD *)(v3 + 48) = *(_QWORD *)(a2 + 48);
  *(_OWORD *)(v3 + 32) = v5;
  *(_QWORD *)(v3 + 80) = *(_QWORD *)(a2 + 80);
  result = *(__n128 *)(a2 + 88);
  *(_QWORD *)(v3 + 104) = *(_QWORD *)(a2 + 104);
  *(__n128 *)(v3 + 88) = result;
  return result;
}

void OZRecordingNode::~OZRecordingNode(PCSpinLock *this)
{
  PCSpinLock *v2;
  const PCString *v3;

  *(_QWORD *)&this->_lock._os_unfair_lock_opaque = &off_1E6555A60;
  v2 = this + 30;
  PCSpinLock::~PCSpinLock(this + 36);
  std::__list_imp<unsigned int>::clear(v2);
  OZChannelBase::setRangeName((OZChannelBase *)this, v3);
}

{
  OZRecordingNode::~OZRecordingNode(this);
  JUMPOUT(0x1B5E29170);
}

OZCurveNode *OZRecordingNode::cloneNode(OZRecordingNode *this)
{
  OZCurveNode *v2;

  v2 = (OZCurveNode *)operator new();
  OZRecordingNode::OZRecordingNode(v2, (uint64_t)this);
  return v2;
}

void sub_1B2C3E990(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C406D9F4237);
  _Unwind_Resume(a1);
}

char *OZRecordingNode::compare(OZRecordingNode *this, const OZCurveNode *lpsrc)
{
  char *result;
  char *v4;
  uint64_t v5;
  char *v6;
  __int128 v7;
  __int128 v8;
  int32_t v9;
  CMTime v10;
  CMTime time1;

  if (!lpsrc)
    return 0;
  if (!result)
    return result;
  v4 = result;
  if (*((_DWORD *)this + 2) != *((_DWORD *)result + 2)
    || *((_DWORD *)this + 3) != *((_DWORD *)result + 3)
    || *((_QWORD *)this + 17) != *((_QWORD *)result + 17))
  {
    return 0;
  }
  v5 = *((_QWORD *)this + 16);
  if ((OZRecordingNode *)v5 == (OZRecordingNode *)((char *)this + 120))
  {
LABEL_11:
    time1 = *(CMTime *)((char *)this + 56);
    v10 = *(CMTime *)(v4 + 56);
    if (!CMTimeCompare(&time1, &v10))
    {
      time1 = *(CMTime *)((char *)this + 32);
      v10 = *(CMTime *)(v4 + 32);
      if (!CMTimeCompare(&time1, &v10)
        && vabdd_f64(*((double *)this + 10), *((double *)v4 + 10)) < 0.0000001
        && vabdd_f64(*((double *)this + 3), *((double *)v4 + 3)) < 0.0000001)
      {
        time1 = *(CMTime *)((char *)this + 88);
        v10 = *(CMTime *)(v4 + 88);
        return (char *)(CMTimeCompare(&time1, &v10) == 0);
      }
    }
    return 0;
  }
  v6 = result + 120;
  while (1)
  {
    v6 = (char *)*((_QWORD *)v6 + 1);
    v7 = *(_OWORD *)(v5 + 16);
    time1.epoch = *(_QWORD *)(v5 + 32);
    *(_OWORD *)&time1.value = v7;
    v8 = *((_OWORD *)v6 + 1);
    v10.epoch = *((_QWORD *)v6 + 4);
    *(_OWORD *)&v10.value = v8;
    v9 = CMTimeCompare(&time1, &v10);
    result = 0;
    if (v9 || *(double *)(v5 + 40) != *((double *)v6 + 5))
      return result;
    v5 = *(_QWORD *)(v5 + 8);
    if ((OZRecordingNode *)v5 == (OZRecordingNode *)((char *)this + 120))
      goto LABEL_11;
  }
}

void OZRecordingNode::operator=(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  v4 = (os_unfair_lock_s *)(a2 + 144);
  PCSpinLock::lock((os_unfair_lock_t)(a2 + 144));
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  if (a1 != a2)
    std::list<std::pair<CMTime,double>>::__assign_with_sentinel[abi:ne180100]<std::__list_const_iterator<std::pair<CMTime,double>,void *>,std::__list_const_iterator<std::pair<CMTime,double>,void *>>((uint64_t *)(a1 + 120), *(_QWORD *)(a2 + 128), a2 + 120);
  v5 = *(_OWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v5;
  v6 = *(_OWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = v6;
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  v7 = *(_OWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 88) = v7;
  PCSpinLock::unlock(v4);
}

__n128 OZRecordingNode::getNeededRange(OZRecordingNode *this, OZCurveNodeParam *a2)
{
  __n128 result;

  *(_OWORD *)((char *)a2 + 24) = *((_OWORD *)a2 + 6);
  *((_QWORD *)a2 + 5) = *((_QWORD *)a2 + 14);
  result = *(__n128 *)((char *)a2 + 120);
  *((__n128 *)a2 + 3) = result;
  *((_QWORD *)a2 + 8) = *((_QWORD *)a2 + 17);
  *((_DWORD *)a2 + 18) = *((_DWORD *)a2 + 36);
  *((_BYTE *)a2 + 88) = 0;
  *((_QWORD *)a2 + 10) = *((_QWORD *)a2 + 19);
  return result;
}

void OZRecordingNode::beginPlayback(OZRecordingNode *this, const CMTime *a2, int a3, int a4, const CMTime *a5)
{
  __int128 v9;
  uint64_t v10;
  double v11;
  __int128 v12;

  *((_DWORD *)this + 2) = a3;
  *((_DWORD *)this + 3) = a4;
  *((_BYTE *)this + 16) = 1;
  v9 = *(_OWORD *)&a2->value;
  *((_QWORD *)this + 9) = a2->epoch;
  *(_OWORD *)((char *)this + 56) = v9;
  v10 = PVInstructionGraphContext::HGNodeCache(*((PVInstructionGraphContext **)this + 14));
  v11 = (*(double (**)(uint64_t, const CMTime *, _QWORD, _QWORD))(*(_QWORD *)v10 + 240))(v10, a2, MEMORY[0x1E0CA2E68], 0);
  *((double *)this + 10) = v11;
  *((double *)this + 3) = v11;
  v12 = *(_OWORD *)&a5->value;
  *((_QWORD *)this + 13) = a5->epoch;
  *(_OWORD *)((char *)this + 88) = v12;
  PCSpinLock::lock((os_unfair_lock_t)this + 36);
  std::__list_imp<unsigned int>::clear((_QWORD *)this + 15);
  PCSpinLock::unlock((os_unfair_lock_t)this + 36);
  if (a3 == 3)
    (*(void (**)(OZRecordingNode *, const CMTime *, _QWORD, double))(*(_QWORD *)this + 64))(this, a2, 0, *((double *)this + 10));
}

void OZRecordingNode::endPlayback(OZRecordingNode *this, const CMTime *a2)
{
  *((_BYTE *)this + 16) = 0;
  if ((*((_DWORD *)this + 2) & 0xFFFFFFFE) == 2)
  {
    (*(void (**)(OZRecordingNode *, const CMTime *, _QWORD, double))(*(_QWORD *)this + 64))(this, a2, 0, *((double *)this + 3));
    PCSpinLock::lock((os_unfair_lock_t)this + 36);
    OZRecordingNode::commitChanges(this);
    PCSpinLock::unlock((os_unfair_lock_t)this + 36);
  }
}

_QWORD *OZRecordingNode::commitChanges(_QWORD *this)
{
  _QWORD *v1;
  _QWORD *v2;
  int v3;
  OZSpline *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  OZSpline *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  OZSpline *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  if (this[17])
  {
    v1 = this;
    v2 = this + 15;
    if (!*((_DWORD *)this + 3))
    {
      v3 = *((_DWORD *)this + 2);
      v4 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)this[14]);
      if (v3)
      {
        v5 = MEMORY[0x1E0CA2E68];
        (*(void (**)(OZSpline *, uint64_t, _QWORD, uint64_t, double))(*(_QWORD *)v4 + 192))(v4, v1[15] + 16, MEMORY[0x1E0CA2E68], 1, *(double *)(v1[15] + 40));
        v6 = (uint64_t *)v1[15];
        v7 = *v6;
        *(_QWORD *)(v7 + 8) = v6[1];
        *(_QWORD *)v6[1] = v7;
        --v1[17];
        operator delete(v6);
        v8 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v1[14]);
        v9 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, double))(*(_QWORD *)v8 + 192))(v8, v1[16] + 16, v5, 1, *(double *)(v1[16] + 40));
        v10 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v1[14]);
        OZSpline::setVertexInterpolation(v10, v9, 1);
        v11 = (uint64_t *)v1[16];
        v12 = v1[17];
        v13 = *v11;
        *(_QWORD *)(v13 + 8) = v11[1];
        *(_QWORD *)v11[1] = v13;
        v1[17] = v12 - 1;
        operator delete(v11);
        v14 = (OZSpline *)PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v1[14]);
        OZSpline::deleteVertices(v14, (const CMTime *)(v1[16] + 16), (const CMTime *)(v1[15] + 16));
        v15 = v1[16];
        if ((_QWORD *)v15 != v2)
        {
          v16 = MEMORY[0x1E0CA2E68];
          do
          {
            v17 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v1[14]);
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, double))(*(_QWORD *)v17 + 192))(v17, v15 + 16, v16, 1, *(double *)(v15 + 40));
            v15 = *(_QWORD *)(v15 + 8);
          }
          while ((_QWORD *)v15 != v2);
        }
      }
      else
      {
        OZSpline::deleteVertices(v4, (const CMTime *)(v1[16] + 16), (const CMTime *)(v1[15] + 16));
        v18 = v1[16];
        if ((_QWORD *)v18 != v2)
        {
          v19 = MEMORY[0x1E0CA2E68];
          do
          {
            v20 = PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v1[14]);
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, double))(*(_QWORD *)v20 + 192))(v20, v18 + 16, v19, 1, *(double *)(v18 + 40));
            v18 = *(_QWORD *)(v18 + 8);
          }
          while ((_QWORD *)v18 != v2);
        }
      }
    }
    return std::__list_imp<unsigned int>::clear(v2);
  }
  return this;
}

uint64_t OZRecordingNode::beginRecording(OZRecordingNode *this, const CMTime *a2)
{
  uint64_t result;
  __n128 v5;
  int v6;

  result = (*(uint64_t (**)(_QWORD, double, double))(**((_QWORD **)this + 14) + 16))(*((_QWORD *)this + 14), 0.0, 0.0);
  v6 = *((_DWORD *)this + 2);
  if ((v6 - 1) >= 2)
  {
    if (v6 != 3)
      return result;
    v5.n128_u64[0] = *((_QWORD *)this + 10);
  }
  return (*(uint64_t (**)(OZRecordingNode *, const CMTime *, _QWORD, __n128))(*(_QWORD *)this + 64))(this, a2, 0, v5);
}

void OZRecordingNode::endRecording(OZRecordingNode *this, const CMTime *a2)
{
  if (*((_DWORD *)this + 2) == 1)
    (*(void (**)(OZRecordingNode *, const CMTime *, _QWORD, double))(*(_QWORD *)this + 64))(this, a2, 0, *((double *)this + 3));
  PCSpinLock::lock((os_unfair_lock_t)this + 36);
  if ((*((_DWORD *)this + 2) & 0xFFFFFFFE) != 2)
    OZRecordingNode::commitChanges(this);
  PCSpinLock::unlock((os_unfair_lock_t)this + 36);
}

void OZRecordingNode::updateCurrentTime(OZRecordingNode *this, const CMTime *a2)
{
  os_unfair_lock_s *v4;
  char *v5;
  uint64_t v6;
  __int128 v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  double v15;
  _OWORD *v16;
  uint64_t v17;
  __int128 v18;
  _BYTE v19[24];
  __int128 v20;
  uint64_t v21;
  CMTime v22;
  CMTime time2;
  CMTime time1;

  v4 = (os_unfair_lock_s *)((char *)this + 144);
  PCSpinLock::lock((os_unfair_lock_t)this + 36);
  v22 = *(CMTime *)((char *)this + 88);
  if (*((_QWORD *)this + 17) && *((_DWORD *)this + 2))
  {
    v5 = (char *)this + 120;
    v6 = **((_QWORD **)this + 15);
    time1 = *a2;
    v7 = *(_OWORD *)(v6 + 16);
    time2.epoch = *(_QWORD *)(v6 + 32);
    *(_OWORD *)&time2.value = v7;
    if (CMTimeCompare(&time1, &time2) < 1)
    {
      time1 = *a2;
      v18 = *(_OWORD *)(v6 + 16);
      time2.epoch = *(_QWORD *)(v6 + 32);
      *(_OWORD *)&time2.value = v18;
      if (!CMTimeCompare(&time1, &time2))
        *(_QWORD *)(v6 + 40) = *((_QWORD *)this + 3);
    }
    else
    {
      v8 = (uint64_t *)*((_QWORD *)this + 15);
      v9 = *v8;
      *(_QWORD *)(v9 + 8) = v8[1];
      *(_QWORD *)v8[1] = v9;
      --*((_QWORD *)this + 17);
      operator delete(v8);
      v10 = *((_QWORD *)this + 3);
      v11 = operator new(0x30uLL);
      v11[1] = *(_OWORD *)&a2->value;
      *((_QWORD *)v11 + 4) = a2->epoch;
      *((_QWORD *)v11 + 5) = v10;
      v12 = *((_QWORD *)this + 15);
      *(_QWORD *)v11 = v12;
      *((_QWORD *)v11 + 1) = v5;
      *(_QWORD *)(v12 + 8) = v11;
      *((_QWORD *)this + 15) = v11;
      ++*((_QWORD *)this + 17);
      time1 = *a2;
      time2 = v22;
      PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v20);
      v13 = PVInstructionGraphContext::HGNodeCache(*((PVInstructionGraphContext **)this + 14));
      time1 = *a2;
      time2 = v22;
      v14 = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)v19);
      v15 = (*(double (**)(uint64_t, _BYTE *, _QWORD, _QWORD, double))(*(_QWORD *)v13 + 240))(v13, v19, MEMORY[0x1E0CA2E68], 0, v14);
      v16 = operator new(0x30uLL);
      v16[1] = v20;
      *((_QWORD *)v16 + 4) = v21;
      *((double *)v16 + 5) = v15;
      v17 = *((_QWORD *)this + 15);
      *(_QWORD *)v16 = v17;
      *((_QWORD *)v16 + 1) = v5;
      *(_QWORD *)(v17 + 8) = v16;
      *((_QWORD *)this + 15) = v16;
      ++*((_QWORD *)this + 17);
    }
  }
  PCSpinLock::unlock(v4);
}

double OZRecordingNode::getMaxValue(OZRecordingNode *this, char a2)
{
  OZSpline *v4;
  double MaxValueVWithTangents;
  double v6;
  uint64_t i;

  v4 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(*((PVInstructionGraphContext **)this + 14));
  if ((a2 & 1) != 0)
    MaxValueVWithTangents = OZSpline::getMaxValueVWithTangents(v4, MEMORY[0x1E0CA2E68], 0);
  else
    MaxValueVWithTangents = OZSpline::getMaxValueV(v4, MEMORY[0x1E0CA2E68], 0);
  v6 = MaxValueVWithTangents;
  PCSpinLock::lock((os_unfair_lock_t)this + 36);
  for (i = *((_QWORD *)this + 16); (OZRecordingNode *)i != (OZRecordingNode *)((char *)this + 120); i = *(_QWORD *)(i + 8))
  {
    if (*(double *)(i + 40) > v6)
      v6 = *(double *)(i + 40);
  }
  PCSpinLock::unlock((os_unfair_lock_t)this + 36);
  return v6;
}

double OZRecordingNode::getMinValue(OZRecordingNode *this, char a2)
{
  OZSpline *v4;
  double MinValueVWithTangents;
  double v6;
  uint64_t i;

  v4 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(*((PVInstructionGraphContext **)this + 14));
  if ((a2 & 1) != 0)
    MinValueVWithTangents = OZSpline::getMinValueVWithTangents(v4, MEMORY[0x1E0CA2E68], 0);
  else
    MinValueVWithTangents = OZSpline::getMinValueV(v4, MEMORY[0x1E0CA2E68], 0);
  v6 = MinValueVWithTangents;
  PCSpinLock::lock((os_unfair_lock_t)this + 36);
  for (i = *((_QWORD *)this + 16); (OZRecordingNode *)i != (OZRecordingNode *)((char *)this + 120); i = *(_QWORD *)(i + 8))
  {
    if (*(double *)(i + 40) < v6)
      v6 = *(double *)(i + 40);
  }
  PCSpinLock::unlock((os_unfair_lock_t)this + 36);
  return v6;
}

double OZRecordingNode::solveNode(OZRecordingNode *this, const CMTime *a2, double a3, double a4)
{
  os_unfair_lock_s *v8;
  char *v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  OZSpline *v17;
  CMTimeValue value;
  uint64_t v19;
  double Seconds;
  double v21;
  double v22;
  double v23;
  uint64_t v24;
  uint64_t v25;
  OZSpline *v26;
  _BYTE **v27;
  uint64_t v28;
  double v29;
  double v30;
  uint64_t v31;
  double v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  CMTime v42;
  _BYTE v43[32];
  CMTime v44;
  CMTime time;
  CMTime v46;
  __int128 v47;
  uint64_t v48;
  CMTime v49;
  CMTime v50;
  CMTime v51;
  CMTime v52;
  void *v53;
  CMTime time2;
  CMTime time1;

  v8 = (os_unfair_lock_s *)((char *)this + 144);
  PCSpinLock::lock((os_unfair_lock_t)this + 36);
  if (!*((_QWORD *)this + 17))
    goto LABEL_5;
  v9 = (char *)this + 120;
  v10 = *((_QWORD *)this + 16) + 16;
  if (!*((_DWORD *)this + 2))
  {
    *(_QWORD *)&v43[16] = a2->epoch;
    *(_OWORD *)v43 = *(_OWORD *)&a2->value;
    v14 = *(_OWORD *)v10;
    time1.epoch = *(_QWORD *)(v10 + 16);
    *(_OWORD *)&time1.value = v14;
    if (CMTimeCompare((CMTime *)v43, &time1) < 0)
    {
      v53 = 0;
      v26 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(*((PVInstructionGraphContext **)this + 14));
      if (!OZSpline::getPreviousValidVertexWithLock(v26, (const CMTime *)(*((_QWORD *)this + 16) + 16), &v53, MEMORY[0x1E0CA2E68], 0))goto LABEL_5;
      v27 = (_BYTE **)v53;
      if (!v53)
        goto LABEL_5;
      time2 = *(CMTime *)((char *)v53 + 16);
      *(CMTime *)v43 = time2;
      time1 = *a2;
      if ((CMTimeCompare((CMTime *)v43, &time1) & 0x80000000) == 0)
        goto LABEL_5;
      v28 = *((_QWORD *)this + 16);
      time2 = *(CMTime *)(v28 + 16);
      v29 = *(double *)(v28 + 40);
      v49 = *(CMTime *)(v27 + 2);
      *(_OWORD *)v43 = *(_OWORD *)&a2->value;
      *(_QWORD *)&v43[16] = a2->epoch;
      time1 = v49;
      v30 = PC_CMTimeSaferSubtract((CMTime *)v43, &time1, (uint64_t)&v50);
      v31 = MEMORY[0x1E0CA2E68];
      v32 = (*((double (**)(_BYTE **, _QWORD, double))*v27 + 3))(v27, MEMORY[0x1E0CA2E68], v30);
      operator*(&v50, &v51, v29 - v32);
      v46 = *(CMTime *)(v27 + 2);
      *(CMTime *)v43 = time2;
      time1 = v46;
      PC_CMTimeSaferSubtract((CMTime *)v43, &time1, (uint64_t)&v47);
      operator/((__int128 *)&v51.value, (uint64_t)&v47, (uint64_t)&v52);
      Seconds = CMTimeGetSeconds(&v52);
      v23 = (*((double (**)(_BYTE **, uint64_t))*v27 + 3))(v27, v31);
    }
    else
    {
      v15 = *(_QWORD *)v9;
      *(_QWORD *)&v43[16] = a2->epoch;
      *(_OWORD *)v43 = *(_OWORD *)&a2->value;
      v16 = *(_OWORD *)(v15 + 16);
      time1.epoch = *(_QWORD *)(v15 + 32);
      *(_OWORD *)&time1.value = v16;
      if (CMTimeCompare((CMTime *)v43, &time1) < 1)
      {
        v33 = *((_QWORD *)this + 16);
        if ((char *)v33 != v9)
        {
          v34 = *((_QWORD *)this + 16);
          do
          {
            v35 = v34;
            v34 = v33;
            *(_OWORD *)v43 = *(_OWORD *)(v33 + 16);
            *(_QWORD *)&v43[16] = *(_QWORD *)(v33 + 32);
            time1 = *a2;
            if (CMTimeCompare((CMTime *)v43, &time1))
            {
              *(_OWORD *)v43 = *(_OWORD *)(v34 + 16);
              *(_QWORD *)&v43[16] = *(_QWORD *)(v34 + 32);
              time1 = *a2;
              if (CMTimeCompare((CMTime *)v43, &time1) >= 1)
              {
                *(_QWORD *)&v43[16] = a2->epoch;
                *(_OWORD *)v43 = *(_OWORD *)&a2->value;
                v36 = *(_OWORD *)(v35 + 16);
                time1.epoch = *(_QWORD *)(v35 + 32);
                *(_OWORD *)&time1.value = v36;
                PC_CMTimeSaferSubtract((CMTime *)v43, &time1, (uint64_t)&v51);
                operator*(&v51, &time2, *(double *)(v34 + 40) - *(double *)(v35 + 40));
                v37 = *(_OWORD *)(v34 + 16);
                *(_QWORD *)&v43[16] = *(_QWORD *)(v34 + 32);
                *(_OWORD *)v43 = v37;
                v38 = *(_OWORD *)(v35 + 16);
                time1.epoch = *(_QWORD *)(v35 + 32);
                *(_OWORD *)&time1.value = v38;
                PC_CMTimeSaferSubtract((CMTime *)v43, &time1, (uint64_t)&v50);
                operator/((__int128 *)&time2.value, (uint64_t)&v50, (uint64_t)&v44);
                a4 = CMTimeGetSeconds(&v44) + *(double *)(v35 + 40);
              }
            }
            else
            {
              a4 = *(double *)(v34 + 40);
            }
            v33 = *(_QWORD *)(v34 + 8);
          }
          while ((char *)v33 != v9);
        }
        goto LABEL_6;
      }
      v46.value = 0;
      v17 = (OZSpline *)PVInstructionGraphContext::HGNodeCache(*((PVInstructionGraphContext **)this + 14));
      if (!OZSpline::getNextValidVertexWithLock(v17, (const CMTime *)(*((_QWORD *)this + 15) + 16), (void **)&v46, MEMORY[0x1E0CA2E68], 0))goto LABEL_5;
      value = v46.value;
      if (!v46.value)
        goto LABEL_5;
      time2 = *(CMTime *)(v46.value + 16);
      *(CMTime *)v43 = time2;
      time1 = *a2;
      if (CMTimeCompare((CMTime *)v43, &time1) < 1)
        goto LABEL_5;
      v19 = *(_QWORD *)v9;
      time2 = *(CMTime *)(*(_QWORD *)v9 + 16);
      Seconds = *(double *)(v19 + 40);
      *(_OWORD *)v43 = *(_OWORD *)&a2->value;
      *(_QWORD *)&v43[16] = a2->epoch;
      time1 = time2;
      v21 = PC_CMTimeSaferSubtract((CMTime *)v43, &time1, (uint64_t)&v50);
      v22 = (*(double (**)(CMTimeValue, _QWORD, double))(*(_QWORD *)value + 24))(value, MEMORY[0x1E0CA2E68], v21);
      operator*(&v50, &v51, v22 - Seconds);
      v48 = *(_QWORD *)(value + 32);
      v47 = *(_OWORD *)(value + 16);
      *(_OWORD *)v43 = v47;
      *(_QWORD *)&v43[16] = v48;
      time1 = time2;
      PC_CMTimeSaferSubtract((CMTime *)v43, &time1, (uint64_t)&v49);
      operator/((__int128 *)&v51.value, (uint64_t)&v49, (uint64_t)&time);
      v23 = CMTimeGetSeconds(&time);
    }
    a4 = Seconds + v23;
    goto LABEL_6;
  }
  v11 = *(_OWORD *)(*(_QWORD *)v9 + 32);
  *(_OWORD *)v43 = *(_OWORD *)(*(_QWORD *)v9 + 16);
  *(_OWORD *)&v43[16] = v11;
  time1 = *a2;
  v12 = *(_OWORD *)v10;
  time2.epoch = *(_QWORD *)(v10 + 16);
  *(_OWORD *)&time2.value = v12;
  if (CMTimeCompare(&time1, &time2) < 0 || (time1 = *a2, time2 = *(CMTime *)v43, CMTimeCompare(&time1, &time2) >= 1))
  {
LABEL_5:
    a4 = (*(double (**)(_QWORD, const CMTime *, double, double))(**((_QWORD **)this + 14) + 16))(*((_QWORD *)this + 14), a2, a3, a4);
    goto LABEL_6;
  }
  v24 = *((_QWORD *)this + 16);
  if ((char *)v24 != v9)
  {
    v25 = v24;
    while (1)
    {
      time1 = *(CMTime *)(v25 + 16);
      time2 = *a2;
      if (!CMTimeCompare(&time1, &time2))
      {
        a4 = *(double *)(v25 + 40);
        goto LABEL_6;
      }
      time1 = *(CMTime *)(v25 + 16);
      time2 = *a2;
      if (CMTimeCompare(&time1, &time2) >= 1)
        break;
      v24 = v25;
      v25 = *(_QWORD *)(v25 + 8);
      if ((char *)v25 == v9)
        goto LABEL_6;
    }
    time1 = *a2;
    v39 = *(_OWORD *)(v24 + 16);
    time2.epoch = *(_QWORD *)(v24 + 32);
    *(_OWORD *)&time2.value = v39;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v50);
    operator*(&v50, &v51, *(double *)(v25 + 40) - *(double *)(v24 + 40));
    v40 = *(_OWORD *)(v25 + 16);
    time1.epoch = *(_QWORD *)(v25 + 32);
    *(_OWORD *)&time1.value = v40;
    v41 = *(_OWORD *)(v24 + 16);
    time2.epoch = *(_QWORD *)(v24 + 32);
    *(_OWORD *)&time2.value = v41;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v49);
    operator/((__int128 *)&v51.value, (uint64_t)&v49, (uint64_t)&v42);
    a4 = CMTimeGetSeconds(&v42) + *(double *)(v24 + 40);
  }
LABEL_6:
  PCSpinLock::unlock(v8);
  return a4;
}

__n128 OZRecordingNode::solveNode(OZRecordingNode *this, OZCurveNodeParam *a2)
{
  uint64_t v2;
  __n128 result;
  uint64_t v6;
  CMTime v7;
  CMTime v8;
  CMTime v9;
  CMTime v10;
  CMTime v11;

  v2 = *((_QWORD *)a2 + 19);
  v8 = *(CMTime *)((_BYTE *)a2 + 5);
  result = *((__n128 *)a2 + 6);
  *(__n128 *)&v7.value = result;
  v7.epoch = *((_QWORD *)a2 + 14);
  if (*((_DWORD *)a2 + 36))
  {
    v6 = 0;
    do
    {
      *(double *)(v2 + 8 * v6) = (*(double (**)(OZRecordingNode *, CMTime *, double, double))(*(_QWORD *)this + 16))(this, &v7, 0.0, *(double *)(v2 + 8 * v6));
      v10 = v7;
      v9 = v8;
      PC_CMTimeSaferAdd(&v10, &v9, (uint64_t)&v11);
      result = *(__n128 *)&v11.value;
      v7 = v11;
      ++v6;
    }
    while (v6 < *((_DWORD *)a2 + 36));
  }
  return result;
}

void OZRecordingNode::setValue(OZRecordingNode *this, const CMTime *a2, double a3)
{
  os_unfair_lock_s *v6;
  double **v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t *v11;
  uint64_t v12;
  _OWORD *v13;
  uint64_t v14;
  uint64_t v15;
  __n128 v16;
  double v17;
  double *v18;
  __int128 v19;
  _OWORD *v20;
  uint64_t v21;
  double v22;
  uint64_t v23;
  double v24;
  _OWORD *v25;
  uint64_t v26;
  uint64_t v27;
  _OWORD *v28;
  uint64_t v29;
  __n128 v30;
  double v31;
  uint64_t v32;
  __int128 v33;
  double *v34;
  __int128 v35;
  _BYTE v36[24];
  __int128 v37;
  uint64_t v38;
  CMTime v39;
  CMTime time2;
  CMTime time1;

  v39 = *(CMTime *)((char *)this + 88);
  v6 = (os_unfair_lock_s *)((char *)this + 144);
  PCSpinLock::lock((os_unfair_lock_t)this + 36);
  v7 = (double **)((char *)this + 120);
  v8 = *((_QWORD *)this + 17);
  if (!*((_DWORD *)this + 2))
  {
    if (v8)
    {
      v18 = *v7;
      time1 = *a2;
      v19 = *((_OWORD *)v18 + 1);
      time2.epoch = (CMTimeEpoch)v18[4];
      *(_OWORD *)&time2.value = v19;
      if (CMTimeCompare(&time1, &time2) < 1)
      {
        v34 = *v7;
        time1 = *a2;
        v35 = *((_OWORD *)v34 + 1);
        time2.epoch = (CMTimeEpoch)v34[4];
        *(_OWORD *)&time2.value = v35;
        if (CMTimeCompare(&time1, &time2))
          goto LABEL_12;
        (*v7)[5] = a3;
        goto LABEL_11;
      }
    }
    v20 = operator new(0x30uLL);
    v20[1] = *(_OWORD *)&a2->value;
    *((_QWORD *)v20 + 4) = a2->epoch;
    *((double *)v20 + 5) = a3;
    goto LABEL_10;
  }
  if (!v8)
  {
    time1 = *a2;
    time2 = v39;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v37);
    v21 = PVInstructionGraphContext::HGNodeCache(*((PVInstructionGraphContext **)this + 14));
    time1 = *a2;
    time2 = v39;
    v22 = PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)v36);
    v23 = MEMORY[0x1E0CA2E68];
    v24 = (*(double (**)(uint64_t, _BYTE *, _QWORD, _QWORD, double))(*(_QWORD *)v21 + 240))(v21, v36, MEMORY[0x1E0CA2E68], 0, v22);
    v25 = operator new(0x30uLL);
    v25[1] = v37;
    *((_QWORD *)v25 + 4) = v38;
    *((double *)v25 + 5) = v24;
    v26 = *((_QWORD *)this + 15);
    *(_QWORD *)v25 = v26;
    *((_QWORD *)v25 + 1) = v7;
    *(_QWORD *)(v26 + 8) = v25;
    *((_QWORD *)this + 15) = v25;
    v27 = *((_QWORD *)this + 17);
    *((_QWORD *)this + 17) = v27 + 1;
    v28 = operator new(0x30uLL);
    v28[1] = *(_OWORD *)&a2->value;
    *((_QWORD *)v28 + 4) = a2->epoch;
    *((double *)v28 + 5) = a3;
    *(_QWORD *)v28 = v25;
    *((_QWORD *)v28 + 1) = v7;
    *((_QWORD *)v25 + 1) = v28;
    *((_QWORD *)this + 15) = v28;
    *((_QWORD *)this + 17) = v27 + 2;
    time1 = *a2;
    time2 = v39;
    PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v37);
    v29 = PVInstructionGraphContext::HGNodeCache(*((PVInstructionGraphContext **)this + 14));
    time1 = *a2;
    time2 = v39;
    v30.n128_f64[0] = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)v36);
    v17 = (*(double (**)(uint64_t, _BYTE *, uint64_t, _QWORD, __n128))(*(_QWORD *)v29 + 240))(v29, v36, v23, 0, v30);
    goto LABEL_9;
  }
  v9 = *(_QWORD *)*v7;
  time1 = *a2;
  v10 = *(_OWORD *)(v9 + 16);
  time2.epoch = *(_QWORD *)(v9 + 32);
  *(_OWORD *)&time2.value = v10;
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    v11 = (uint64_t *)*((_QWORD *)this + 15);
    v12 = *v11;
    *(_QWORD *)(v12 + 8) = v11[1];
    *(_QWORD *)v11[1] = v12;
    --*((_QWORD *)this + 17);
    operator delete(v11);
    v13 = operator new(0x30uLL);
    v13[1] = *(_OWORD *)&a2->value;
    *((_QWORD *)v13 + 4) = a2->epoch;
    *((double *)v13 + 5) = a3;
    v14 = *((_QWORD *)this + 15);
    *(_QWORD *)v13 = v14;
    *((_QWORD *)v13 + 1) = v7;
    *(_QWORD *)(v14 + 8) = v13;
    *((_QWORD *)this + 15) = v13;
    ++*((_QWORD *)this + 17);
    time1 = *a2;
    time2 = v39;
    PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v37);
    v15 = PVInstructionGraphContext::HGNodeCache(*((PVInstructionGraphContext **)this + 14));
    time1 = *a2;
    time2 = v39;
    v16.n128_f64[0] = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)v36);
    v17 = (*(double (**)(uint64_t, _BYTE *, _QWORD, _QWORD, __n128))(*(_QWORD *)v15 + 240))(v15, v36, MEMORY[0x1E0CA2E68], 0, v16);
LABEL_9:
    v31 = v17;
    v20 = operator new(0x30uLL);
    v20[1] = v37;
    *((_QWORD *)v20 + 4) = v38;
    *((double *)v20 + 5) = v31;
LABEL_10:
    v32 = *((_QWORD *)this + 15);
    *(_QWORD *)v20 = v32;
    *((_QWORD *)v20 + 1) = v7;
    *(_QWORD *)(v32 + 8) = v20;
    *((_QWORD *)this + 15) = v20;
    ++*((_QWORD *)this + 17);
    goto LABEL_11;
  }
  time1 = *a2;
  v33 = *(_OWORD *)(v9 + 16);
  time2.epoch = *(_QWORD *)(v9 + 32);
  *(_OWORD *)&time2.value = v33;
  if (CMTimeCompare(&time1, &time2))
    goto LABEL_12;
  *(double *)(v9 + 40) = a3;
LABEL_11:
  *((double *)this + 3) = a3;
LABEL_12:
  PCSpinLock::unlock(v6);
}

BOOL OZRecordingNode::getUForValue(uint64_t a1, CMTime *a2, CMTime *a3, CMTime *a4, int a5, double a6)
{
  uint64_t v11;

  v11 = PVInstructionGraphContext::HGNodeCache(*(PVInstructionGraphContext **)(a1 + 112));
  return OZSpline::getUForValue(v11, a2, a3, a4, a5, a6);
}

uint64_t OZRecordingNode::setDefaultValue(OZRecordingNode *this, double a2)
{
  return (*(uint64_t (**)(_QWORD, double))(**((_QWORD **)this + 14) + 72))(*((_QWORD *)this + 14), a2);
}

uint64_t OZRecordingNode::getDefaultValue(OZRecordingNode *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 14) + 80))(*((_QWORD *)this + 14));
}

uint64_t OZRecordingNode::setInitialValue(OZRecordingNode *this, double a2)
{
  return (*(uint64_t (**)(_QWORD, double))(**((_QWORD **)this + 14) + 88))(*((_QWORD *)this + 14), a2);
}

uint64_t OZRecordingNode::getInitialValue(OZRecordingNode *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 14) + 96))(*((_QWORD *)this + 14));
}

uint64_t OZRecordingNode::getCurrentRange(OZRecordingNode *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 14) + 112))(*((_QWORD *)this + 14));
}

uint64_t OZRecordingNode::getMaxValueU(OZRecordingNode *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 14) + 160))(*((_QWORD *)this + 14));
}

uint64_t OZRecordingNode::getMinValueU(OZRecordingNode *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 14) + 168))(*((_QWORD *)this + 14));
}

uint64_t *std::list<std::pair<CMTime,double>>::__assign_with_sentinel[abi:ne180100]<std::__list_const_iterator<std::pair<CMTime,double>,void *>,std::__list_const_iterator<std::pair<CMTime,double>,void *>>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *i;
  __int128 v6;

  for (i = (uint64_t *)a1[1]; a2 != a3 && i != a1; i = (uint64_t *)i[1])
  {
    v6 = *(_OWORD *)(a2 + 16);
    i[4] = *(_QWORD *)(a2 + 32);
    *((_OWORD *)i + 1) = v6;
    i[5] = *(_QWORD *)(a2 + 40);
    a2 = *(_QWORD *)(a2 + 8);
  }
  if (i == a1)
    return std::list<std::pair<CMTime,double>>::__insert_with_sentinel[abi:ne180100]<std::__list_const_iterator<std::pair<CMTime,double>,void *>,std::__list_const_iterator<std::pair<CMTime,double>,void *>>((uint64_t)a1, a1, a2, a3);
  else
    return std::list<std::pair<CMTime,double>>::erase((uint64_t)a1, i, a1);
}

uint64_t *std::list<std::pair<CMTime,double>>::__insert_with_sentinel[abi:ne180100]<std::__list_const_iterator<std::pair<CMTime,double>,void *>,std::__list_const_iterator<std::pair<CMTime,double>,void *>>(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;
  _QWORD *v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  __int128 v14;
  uint64_t v15;

  if (a3 != a4)
  {
    v8 = operator new(0x30uLL);
    v9 = v8;
    *v8 = 0;
    v8[1] = 0;
    v10 = *(_OWORD *)(a3 + 32);
    *((_OWORD *)v8 + 1) = *(_OWORD *)(a3 + 16);
    *((_OWORD *)v8 + 2) = v10;
    v11 = *(_QWORD *)(a3 + 8);
    v12 = 1;
    if (v11 != a4)
    {
      v13 = v8;
      do
      {
        v8 = operator new(0x30uLL);
        *v8 = v13;
        v8[1] = 0;
        v14 = *(_OWORD *)(v11 + 32);
        *((_OWORD *)v8 + 1) = *(_OWORD *)(v11 + 16);
        *((_OWORD *)v8 + 2) = v14;
        v13[1] = v8;
        ++v12;
        v11 = *(_QWORD *)(v11 + 8);
        v13 = v8;
      }
      while (v11 != a4);
    }
    v15 = *a2;
    *(_QWORD *)(v15 + 8) = v9;
    *v9 = v15;
    *a2 = (uint64_t)v8;
    v8[1] = a2;
    *(_QWORD *)(a1 + 16) += v12;
    return v9;
  }
  return a2;
}

void sub_1B2C400E0(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;

  __cxa_begin_catch(a1);
  do
  {
    v2 = (_QWORD *)*v1;
    operator delete(v1);
    v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_1B2C40100(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t *std::list<std::pair<CMTime,double>>::erase(uint64_t a1, uint64_t *__p, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;

  if (__p != a3)
  {
    v5 = *a3;
    v6 = *__p;
    *(_QWORD *)(v6 + 8) = *(_QWORD *)(*a3 + 8);
    **(_QWORD **)(v5 + 8) = v6;
    do
    {
      v7 = (uint64_t *)__p[1];
      --*(_QWORD *)(a1 + 16);
      operator delete(__p);
      __p = v7;
    }
    while (v7 != a3);
  }
  return a3;
}

OZSpline *OZSplineNode::allocOZSpline(OZSplineNode *this, OZSpline *a2)
{
  OZSpline *v4;
  OZSpline *v5;
  uint64_t v6;
  OZSpline *result;

  v4 = (OZSpline *)operator new();
  v5 = v4;
  v6 = *((_QWORD *)this + 4);
  if (a2)
    result = OZSpline::OZSpline(v4, a2, *(OZSplineState **)(v6 + 160));
  else
    result = OZSpline::OZSpline(v4, *(OZSplineState **)(v6 + 160));
  *((_QWORD *)this + 3) = v5;
  *((_QWORD *)v5 + 20) = this;
  return result;
}

void sub_1B2C401F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C4049CA59C4);
  _Unwind_Resume(a1);
}

void OZSplineNode::OZSplineNode(OZSplineNode *this, OZCurve *a2)
{
  uint64_t v3;

  OZConstantNode::OZConstantNode(this, 0.0);
  *(_QWORD *)v3 = &off_1E6555B58;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = a2;
  *(_QWORD *)(v3 + 40) = 0;
  *(_QWORD *)(v3 + 48) = 0;
  *(_BYTE *)(v3 + 56) = 0;
}

void OZSplineNode::~OZSplineNode(OZSplineNode *this)
{
  OZSpline *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E6555B58;
  v2 = (OZSpline *)*((_QWORD *)this + 3);
  if (v2)
  {
    OZSpline::deleteAllVertices(v2);
    v3 = *((_QWORD *)this + 3);
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    *((_QWORD *)this + 3) = 0;
  }
  OZEaseInInterpolator::~OZEaseInInterpolator(this);
}

{
  OZSplineNode::~OZSplineNode(this);
  JUMPOUT(0x1B5E29170);
}

OZSpline *OZSplineNode::createSpline(OZSplineNode *this)
{
  return OZSplineNode::allocOZSpline(this, 0);
}

double OZSplineNode::getMinValue(OZSplineNode *this, char a2)
{
  OZSpline *v3;

  v3 = (OZSpline *)*((_QWORD *)this + 3);
  if (!v3)
    return OZConstantNode::getMinValue(this);
  if ((a2 & 1) != 0)
    return OZSpline::getMinValueVWithTangents(v3, MEMORY[0x1E0CA2E68], 0);
  return OZSpline::getMinValueV(v3, MEMORY[0x1E0CA2E68], 0);
}

double OZSplineNode::getMaxValue(OZSplineNode *this, char a2)
{
  OZSpline *v3;

  v3 = (OZSpline *)*((_QWORD *)this + 3);
  if (!v3)
    return OZConstantNode::getMaxValue(this);
  if ((a2 & 1) != 0)
    return OZSpline::getMaxValueVWithTangents(v3, MEMORY[0x1E0CA2E68], 0);
  return OZSpline::getMaxValueV(v3, MEMORY[0x1E0CA2E68], 0);
}

__n128 OZSplineNode::getCurrentRange@<Q0>(OZSplineNode *this@<X0>, CMTime *a2@<X8>)
{
  OZSpline *v2;
  __n128 result;
  uint64_t v4;

  v2 = (OZSpline *)*((_QWORD *)this + 3);
  if (v2)
  {
    OZSpline::getRangeU(v2, MEMORY[0x1E0CA2E68], a2);
  }
  else
  {
    v4 = MEMORY[0x1E0CA2E68];
    result = *(__n128 *)MEMORY[0x1E0CA2E68];
    *(_OWORD *)&a2->value = *MEMORY[0x1E0CA2E68];
    a2->epoch = *(_QWORD *)(v4 + 16);
  }
  return result;
}

__n128 OZSplineNode::getMaxValueU@<Q0>(OZSplineNode *this@<X0>, uint64_t a2@<X8>)
{
  OZSpline *v2;
  __n128 result;
  uint64_t v4;

  v2 = (OZSpline *)*((_QWORD *)this + 3);
  if (v2)
  {
    result.n128_u64[0] = OZSpline::getMaxValueU(v2, MEMORY[0x1E0CA2E68], 1, a2).n128_u64[0];
  }
  else
  {
    v4 = MEMORY[0x1E0CA2E68];
    result = *(__n128 *)MEMORY[0x1E0CA2E68];
    *(_OWORD *)a2 = *MEMORY[0x1E0CA2E68];
    *(_QWORD *)(a2 + 16) = *(_QWORD *)(v4 + 16);
  }
  return result;
}

__n128 OZSplineNode::getMinValueU@<Q0>(OZSplineNode *this@<X0>, uint64_t a2@<X8>)
{
  OZSpline *v2;
  __n128 result;
  uint64_t v4;

  v2 = (OZSpline *)*((_QWORD *)this + 3);
  if (v2)
  {
    OZSpline::getMinValueU(v2, MEMORY[0x1E0CA2E68], 1, a2);
  }
  else
  {
    v4 = MEMORY[0x1E0CA2E68];
    result = *(__n128 *)MEMORY[0x1E0CA2E68];
    *(_OWORD *)a2 = *MEMORY[0x1E0CA2E68];
    *(_QWORD *)(a2 + 16) = *(_QWORD *)(v4 + 16);
  }
  return result;
}

double OZSplineNode::reset(OZSplineNode *this)
{
  uint64_t v2;
  double result;

  v2 = *((_QWORD *)this + 3);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    *((_QWORD *)this + 3) = 0;
  }
  result = *((double *)this + 2);
  *((double *)this + 1) = result;
  return result;
}

double OZSplineNode::solveNode(OZSplineNode *this, const CMTime *a2, double a3, double a4)
{
  _QWORD *v5;
  double result;

  v5 = (_QWORD *)*((_QWORD *)this + 3);
  if (!v5 || ((v5[3] - v5[2]) & 0x7FFFFFFF8) == 0)
    return OZConstantNode::solveNode(this, a2, a3, a4);
  (*(void (**)(_QWORD *, const CMTime *, _QWORD, uint64_t, double, double))(*v5 + 240))(v5, a2, MEMORY[0x1E0CA2E68], 1, a3, a4);
  return result;
}

void OZSplineNode::solveNode(OZSplineNode *this, OZCurveNodeParam *a2)
{
  uint64_t *v3;
  uint64_t v4;

  v3 = (uint64_t *)*((_QWORD *)this + 3);
  if (v3 && ((v3[3] - v3[2]) & 0x7FFFFFFF8) != 0)
  {
    v4 = *v3;
    if (*((_BYTE *)a2 + 1))
      (*(void (**)(void))(v4 + 72))();
    else
      (*(void (**)(void))(v4 + 40))();
  }
  else
  {
    OZConstantNode::solveNode(this, a2);
  }
}

BOOL OZSplineNode::getUForValue(uint64_t a1, CMTime *a2, CMTime *a3, CMTime *a4, int a5, double a6)
{
  uint64_t v6;

  v6 = *(_QWORD *)(a1 + 24);
  if (v6 && ((*(_QWORD *)(v6 + 24) - *(_QWORD *)(v6 + 16)) & 0x7FFFFFFF8) != 0)
    return OZSpline::getUForValue(*(_QWORD *)(a1 + 24), a2, a3, a4, a5, a6);
  else
    return OZConstantNode::getUForValue(a1, (void **)a2, (__int128 *)&a3->value, a6);
}

OZStaticVertex *OZSplineNode::setValue(OZSpline **this, const CMTime *a2, double a3, int a4)
{
  OZSpline *v8;

  if (!this[3])
    OZSplineNode::allocOZSpline((OZSplineNode *)this, 0);
  v8 = this[3];
  if (a4)
    return (OZStaticVertex *)(*(uint64_t (**)(OZSpline *, const CMTime *, _QWORD, uint64_t, double))(*(_QWORD *)v8 + 192))(v8, a2, MEMORY[0x1E0CA2E68], 1, a3);
  else
    return OZSpline::addVertexNoTangents(v8, a2, a3, MEMORY[0x1E0CA2E68], 1);
}

uint64_t OZSplineNode::cloneNode(OZSplineNode *this)
{
  uint64_t v2;

  v2 = operator new();
  OZConstantNode::OZConstantNode((OZConstantNode *)v2, this);
  *(_QWORD *)v2 = &off_1E6555B58;
  *(_OWORD *)(v2 + 24) = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)(v2 + 40) = *(_OWORD *)((char *)this + 40);
  *(_BYTE *)(v2 + 56) = *((_BYTE *)this + 56);
  return v2;
}

void sub_1B2C405FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40A6C35FEDLL);
  _Unwind_Resume(a1);
}

CMTime *OZSplineNode::getFrameDuration@<X0>(OZSplineNode *this@<X0>, CMTime *a2@<X8>)
{
  OZCurve *v2;

  v2 = (OZCurve *)*((_QWORD *)this + 4);
  if (v2)
    return OZCurve::getFrameDuration(v2, a2);
  else
    return CMTimeMake(a2, 1, 30);
}

BOOL OZSplineNode::compare(OZSplineNode *this, const OZCurveNode *lpsrc)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 result;

  if (!lpsrc)
  {
    OZConstantNode::compare(this, 0);
    return 0;
  }
  if ((OZConstantNode::compare(this, lpsrc) & 1) == 0 || !v4)
    return 0;
  v5 = *((_QWORD *)this + 3);
  v6 = v4[3];
  result = (v5 | v6) == 0;
  if (v5 && v6)
    return OZSpline::operator==(*((_QWORD *)this + 3), v6);
  return result;
}

OZSpline *OZSplineNode::operator=(OZSplineNode *a1, uint64_t a2)
{
  __n128 v4;
  OZSpline *result;
  OZSpline *v6;

  v4 = OZConstantNode::operator=((uint64_t)a1, a2);
  result = (OZSpline *)*((_QWORD *)a1 + 3);
  if (result)
  {
    result = (OZSpline *)(*(uint64_t (**)(OZSpline *, __n128))(*(_QWORD *)result + 8))(result, v4);
    *((_QWORD *)a1 + 3) = 0;
  }
  *((_QWORD *)a1 + 5) = *(_QWORD *)(a2 + 40);
  v6 = *(OZSpline **)(a2 + 24);
  if (v6)
    return OZSplineNode::allocOZSpline(a1, v6);
  return result;
}

__n128 OZSplineNode::getNeededRange(OZSplineNode *this, OZCurveNodeParam *a2)
{
  __n128 result;

  *(_OWORD *)((char *)a2 + 24) = *((_OWORD *)a2 + 6);
  *((_QWORD *)a2 + 5) = *((_QWORD *)a2 + 14);
  result = *(__n128 *)((char *)a2 + 120);
  *((__n128 *)a2 + 3) = result;
  *((_QWORD *)a2 + 8) = *((_QWORD *)a2 + 17);
  *((_DWORD *)a2 + 18) = *((_DWORD *)a2 + 36);
  *((_BYTE *)a2 + 88) = 0;
  *((_QWORD *)a2 + 10) = *((_QWORD *)a2 + 19);
  return result;
}

void OZDynamicSpline::OZDynamicSpline(OZDynamicSpline *this, OZSplineState *a2)
{
  _QWORD *v2;

  OZSpline::OZSpline(this, a2);
  *v2 = &off_1E6555C50;
}

void OZDynamicSpline::~OZDynamicSpline(OZDynamicSpline *this)
{
  OZSpline::~OZSpline(this);
  JUMPOUT(0x1B5E29170);
}

CMTimeEpoch *OZDynamicSpline::addVertex(os_unfair_lock_s *this, const CMTime *a2, double a3, const CMTime *a4)
{
  os_unfair_lock_s *v8;
  CMTimeEpoch *v9;
  CMTime *v10;
  os_unfair_lock_s *v11;
  const void **v12;
  _OWORD *v13;
  char *v14;
  uint64_t v15;
  double v16;
  uint64_t v17;
  const void *v18;
  _QWORD *v19;
  const void **v20;
  uint64_t v21;
  OZInterpolators *v22;
  int v23;
  uint64_t Interpolator;
  OZDynamicVertex *v25;
  uint64_t v26;
  const void *value;
  OZDynamicVertex *v28;
  _QWORD *v29;
  OZInterpolators *v30;
  int v31;
  uint64_t v32;
  unint64_t v33;
  CMTimeEpoch **v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  char *v40;
  CMTimeEpoch **v41;
  char *v42;
  char *v43;
  char *v44;
  CMTimeEpoch *v45;
  const void *v46;
  OZDynamicVertex *v47;
  OZDynamicVertex *v49;
  CMTime v50;
  CMTime v51;
  CMTime time2;
  CMTime time1;

  v8 = this + 2;
  PCSpinLock::lock(this + 2);
  v9 = (CMTimeEpoch *)operator new();
  v10 = (CMTime *)MEMORY[0x1E0CA2E68];
  OZDynamicVertex::OZDynamicVertex((OZDynamicVertex *)v9, a2, a3, MEMORY[0x1E0CA2E68]);
  v12 = *(const void ***)&this[4]._os_unfair_lock_opaque;
  v11 = this + 4;
  if (v12 != *(const void ***)&this[6]._os_unfair_lock_opaque)
  {
    v13 = v9 + 2;
    v14 = *(char **)&this[4]._os_unfair_lock_opaque;
    while (1)
    {
      v51 = *(CMTime *)((char *)*v12 + 16);
      *(_OWORD *)&time2.value = *v13;
      time2.epoch = v9[4];
      time1 = v51;
      if (!CMTimeCompare(&time1, &time2))
      {
        v15 = *(_QWORD *)&this[42]._os_unfair_lock_opaque;
        *(_OWORD *)&v50.value = *(_OWORD *)(v15 + 8);
        v50.epoch = *(_QWORD *)(v15 + 24);
        time1 = *a2;
        time2 = v50;
        v16 = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v51);
        (*(void (**)(CMTimeEpoch *, CMTime *, double))(*v9 + 16))(v9, &v51, v16);
      }
      v51 = *(CMTime *)((char *)*v12 + 16);
      *(_OWORD *)&time2.value = *v13;
      time2.epoch = v9[4];
      time1 = v51;
      if (CMTimeCompare(&time1, &time2) >= 1)
        break;
      ++v12;
      v14 += 8;
      if (v12 == *(const void ***)&this[6]._os_unfair_lock_opaque)
        goto LABEL_7;
    }
    memset(&v51, 0, sizeof(v51));
    (*(void (**)(CMTime *__return_ptr, _QWORD *, const CMTime *))(v19[42] + 328))(&v51, v19 + 42, a4);
    v20 = *(const void ***)&v11->_os_unfair_lock_opaque;
    v21 = (*(uint64_t (**)(const void *))(*(_QWORD *)*v12 + 208))(*v12);
    (*(void (**)(CMTimeEpoch *, uint64_t))(*v9 + 200))(v9, v21);
    if (v12 == v20)
    {
      time1 = *a4;
      time2 = *v10;
      if (CMTimeCompare(&time1, &time2))
      {
        v26 = MEMORY[0x1E0CA2E68];
        (*(void (**)(os_unfair_lock_s *, const CMTime *, _QWORD, _QWORD))(*(_QWORD *)&this->_os_unfair_lock_opaque
                                                                                   + 240))(this, a2, MEMORY[0x1E0CA2E68], 0);
        (*(void (**)(CMTimeEpoch *, uint64_t))(*v9 + 32))(v9, v26);
      }
    }
    else
    {
      v22 = *(OZInterpolators **)&this[38]._os_unfair_lock_opaque;
      v23 = (*(uint64_t (**)(const void *))(*(_QWORD *)*v12 + 208))(*v12);
      Interpolator = OZInterpolators::getInterpolator(v22, v23);
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)Interpolator + 64))(Interpolator))
      {
        if (*v12)
        else
          v25 = 0;
        v46 = *(v12 - 1);
        if (v46)
        else
          v47 = 0;
        OZDynamicSpline::subdivideWithAnimation((OZInterpolators **)this, a4, (OZDynamicVertex *)v9, v47, v25);
        goto LABEL_44;
      }
    }
    (*(void (**)(CMTimeEpoch *, CMTime *, double))(*v9 + 32))(v9, &v51, a3);
LABEL_44:
    time1.value = (CMTimeValue)v9;
    std::vector<OZVertex *>::insert((uint64_t)&this[4], v14, &time1);
    goto LABEL_45;
  }
LABEL_7:
  if (v12 != *(const void ***)&v11->_os_unfair_lock_opaque)
  {
    v17 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*(v12 - 1) + 208))(*(v12 - 1));
    (*(void (**)(CMTimeEpoch *, uint64_t))(*v9 + 200))(v9, v17);
    if (LOBYTE(this[36]._os_unfair_lock_opaque))
    {
      time2.value = 0;
      v18 = *(v12 - 1);
      OZSpline::getFirstValidVertex((OZSpline *)this, (void **)&time2, a4);
      if (v18)
      else
        v49 = 0;
      value = (const void *)time2.value;
      memset(&time1, 0, sizeof(time1));
      (*(void (**)(CMTime *__return_ptr, _QWORD *, const CMTime *))(v29[42] + 328))(&time1, v29 + 42, a4);
      v30 = *(OZInterpolators **)&this[38]._os_unfair_lock_opaque;
      v31 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*(v12 - 1) + 208))(*(v12 - 1));
      v32 = OZInterpolators::getInterpolator(v30, v31);
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v32 + 64))(v32))
        OZDynamicSpline::subdivideWithAnimation((OZInterpolators **)this, a4, (OZDynamicVertex *)v9, v49, v28);
      else
        (*(void (**)(CMTimeEpoch *, CMTime *, double))(*v9 + 32))(v9, &time1, a3);
    }
  }
  v33 = *(_QWORD *)&this[8]._os_unfair_lock_opaque;
  v34 = *(CMTimeEpoch ***)&this[6]._os_unfair_lock_opaque;
  if ((unint64_t)v34 >= v33)
  {
    v36 = ((uint64_t)v34 - *(_QWORD *)&v11->_os_unfair_lock_opaque) >> 3;
    if ((unint64_t)(v36 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v37 = v33 - *(_QWORD *)&v11->_os_unfair_lock_opaque;
    v38 = v37 >> 2;
    if (v37 >> 2 <= (unint64_t)(v36 + 1))
      v38 = v36 + 1;
    if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8)
      v39 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v39 = v38;
    if (v39)
      v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&this[8], v39);
    else
      v40 = 0;
    v41 = (CMTimeEpoch **)&v40[8 * v36];
    v42 = &v40[8 * v39];
    *v41 = v9;
    v35 = v41 + 1;
    v44 = *(char **)&this[4]._os_unfair_lock_opaque;
    v43 = *(char **)&this[6]._os_unfair_lock_opaque;
    if (v43 != v44)
    {
      do
      {
        v45 = (CMTimeEpoch *)*((_QWORD *)v43 - 1);
        v43 -= 8;
        *--v41 = v45;
      }
      while (v43 != v44);
      v43 = *(char **)&v11->_os_unfair_lock_opaque;
    }
    *(_QWORD *)&this[4]._os_unfair_lock_opaque = v41;
    *(_QWORD *)&this[6]._os_unfair_lock_opaque = v35;
    *(_QWORD *)&this[8]._os_unfair_lock_opaque = v42;
    if (v43)
      operator delete(v43);
  }
  else
  {
    *v34 = v9;
    v35 = v34 + 1;
  }
  *(_QWORD *)&this[6]._os_unfair_lock_opaque = v35;
LABEL_45:
  OZSpline::setDirty((OZSpline *)this, 1);
  PCSpinLock::unlock(v8);
  return v9;
}

void sub_1B2C40CF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40974A25EBLL);
  _Unwind_Resume(a1);
}

char *std::vector<OZVertex *>::insert(uint64_t a1, char *__src, _QWORD *a3)
{
  char *v4;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  _BYTE *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  void *__p;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;

  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 16);
  v7 = a1 + 16;
  v8 = v9;
  if ((unint64_t)v6 >= v9)
  {
    v14 = *(_BYTE **)a1;
    v15 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 3) + 1;
    if (v15 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v16 = (__src - v14) >> 3;
    v17 = v8 - (_QWORD)v14;
    if (v17 >> 2 > v15)
      v15 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v15;
    v25 = v7;
    if (v18)
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v7, v18);
    else
      v19 = 0;
    __p = v19;
    v22 = &v19[8 * v16];
    v23 = v22;
    v24 = &v19[8 * v18];
    std::__split_buffer<unsigned long *>::push_back(&__p, a3);
    v4 = std::vector<OZChannelBase *>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v23 != v22)
      v23 += (v22 - v23 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_QWORD *)__src = *a3;
    *(_QWORD *)(a1 + 8) = __src + 8;
  }
  else
  {
    v10 = __src + 8;
    v11 = v6 - 8;
    v12 = v6;
    while (v11 < v6)
    {
      v13 = *(_QWORD *)v11;
      v11 += 8;
      *(_QWORD *)v12 = v13;
      v12 += 8;
    }
    *(_QWORD *)(a1 + 8) = v12;
    if (v6 != v10)
      memmove(&v6[-8 * ((v6 - v10) >> 3)], __src, v6 - v10);
    *(_QWORD *)v4 = *a3;
  }
  return v4;
}

void sub_1B2C40E84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t OZDynamicSpline::subdivideWithAnimation(OZInterpolators **this, const CMTime *a2, OZDynamicVertex *a3, OZDynamicVertex *a4, OZDynamicVertex *a5)
{
  int v10;
  uint64_t Interpolator;
  uint64_t v12;
  char *v13;
  __int128 *v14;
  OZDynamicVertex *v15;
  OZDynamicVertex *v16;
  OZDynamicVertex *v17;
  OZDynamicVertex *v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  double v22;
  double v24;
  double v25;
  CMTime v26[39];
  CMTime v27[39];
  uint64_t v28;
  OZDynamicVertex *v29;
  unint64_t v30;
  uint64_t v31;
  OZDynamicVertex *v32;
  unint64_t v33;
  __int128 v34;
  uint64_t v35;
  CMTime v36;

  v10 = (*(uint64_t (**)(OZDynamicVertex *))(*(_QWORD *)a5 + 208))(a5);
  Interpolator = OZInterpolators::getInterpolator(this[19], v10);
  v12 = (*(uint64_t (**)(OZDynamicVertex *))(*(_QWORD *)a5 + 208))(a5);
  (*(void (**)(OZDynamicVertex *, uint64_t))(*(_QWORD *)a3 + 200))(a3, v12);
  memset(&v36, 0, sizeof(v36));
  (*(void (**)(CMTime *__return_ptr, char *, const CMTime *))(*((_QWORD *)a5 + 42) + 328))(&v36, (char *)a5 + 336, a2);
  v13 = (char *)a4 + 48;
  if ((*(unsigned int (**)(char *, _QWORD))(*((_QWORD *)a4 + 6) + 552))((char *)a4 + 48, 0))
  {
    v14 = (__int128 *)MEMORY[0x1E0CA2E28];
    v34 = *MEMORY[0x1E0CA2E28];
    v35 = *(_QWORD *)(MEMORY[0x1E0CA2E28] + 16);
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    while ((*(unsigned int (**)(char *, __int128 *, _QWORD))(*(_QWORD *)v13 + 632))((char *)a4 + 48, &v34, 0))
    {
      OZDynamicVertex::OZDynamicVertex((OZDynamicVertex *)v27, a4);
      OZDynamicVertex::OZDynamicVertex((OZDynamicVertex *)v26, a5);
      (*(void (**)(char *, __int128 *))(*((_QWORD *)a3 + 6) + 600))((char *)a3 + 48, &v34);
      (*(void (**)(uint64_t, OZInterpolators **, __int128 *, CMTime *, CMTime *, OZDynamicVertex *))(*(_QWORD *)Interpolator + 32))(Interpolator, this, &v34, v27, v26, a3);
      (*(void (**)(OZDynamicVertex *, uint64_t, __int128 *))(*(_QWORD *)a3 + 128))(a3, 1, &v34);
      v15 = v32;
      if ((unint64_t)v32 >= v33)
      {
        v16 = (OZDynamicVertex *)std::vector<OZDynamicVertex>::__push_back_slow_path<OZDynamicVertex const&>(&v31, (const OZDynamicVertex *)v27);
      }
      else
      {
        OZDynamicVertex::OZDynamicVertex(v32, (const OZDynamicVertex *)v27);
        v16 = (OZDynamicVertex *)((char *)v15 + 944);
      }
      v32 = v16;
      v17 = v29;
      if ((unint64_t)v29 >= v30)
      {
        v18 = (OZDynamicVertex *)std::vector<OZDynamicVertex>::__push_back_slow_path<OZDynamicVertex const&>(&v28, (const OZDynamicVertex *)v26);
      }
      else
      {
        OZDynamicVertex::OZDynamicVertex(v29, (const OZDynamicVertex *)v26);
        v18 = (OZDynamicVertex *)((char *)v17 + 944);
      }
      v29 = v18;
      OZDynamicVertex::~OZDynamicVertex((OZDynamicVertex *)v26);
      OZDynamicVertex::~OZDynamicVertex((OZDynamicVertex *)v27);
    }
    v19 = (*(uint64_t (**)(OZDynamicVertex *))(*(_QWORD *)a4 + 168))(a4);
    (*(void (**)(OZDynamicVertex *, uint64_t))(*(_QWORD *)a4 + 160))(a4, 2);
    v20 = (*(uint64_t (**)(OZDynamicVertex *))(*(_QWORD *)a5 + 168))(a5);
    (*(void (**)(OZDynamicVertex *, uint64_t))(*(_QWORD *)a5 + 160))(a5, 2);
    v21 = 0;
    v34 = *v14;
    v35 = *((_QWORD *)v14 + 2);
    while ((*(unsigned int (**)(char *, __int128 *, _QWORD))(*(_QWORD *)v13 + 632))((char *)a4 + 48, &v34, 0))
    {
      OZDynamicVertex::OZDynamicVertex((OZDynamicVertex *)v27, a4);
      OZDynamicVertex::OZDynamicVertex((OZDynamicVertex *)v26, a5);
      v24 = 0.0;
      v25 = 0.0;
      (*(void (**)(uint64_t, double *, double *, __int128 *))(*(_QWORD *)(v31 + 944 * v21) + 64))(v31 + 944 * v21, &v25, &v24, &v34);
      (*(void (**)(OZDynamicVertex *, __int128 *, double, double))(*(_QWORD *)a4 + 80))(a4, &v34, v25, v24);
      (*(void (**)(uint64_t, double *, double *, __int128 *))(*(_QWORD *)(v28 + 944 * v21) + 56))(v28 + 944 * v21, &v25, &v24, &v34);
      (*(void (**)(OZDynamicVertex *, __int128 *, double, double))(*(_QWORD *)a5 + 72))(a5, &v34, v25, v24);
      ++v21;
      OZDynamicVertex::~OZDynamicVertex((OZDynamicVertex *)v26);
      OZDynamicVertex::~OZDynamicVertex((OZDynamicVertex *)v27);
    }
    (*(void (**)(OZDynamicVertex *, uint64_t))(*(_QWORD *)a4 + 176))(a4, v19);
    (*(void (**)(OZDynamicVertex *, uint64_t))(*(_QWORD *)a5 + 176))(a5, v20);
    v27[0].value = (CMTimeValue)&v28;
    std::vector<OZDynamicVertex>::__destroy_vector::operator()[abi:ne180100]((void ***)v27);
    v27[0].value = (CMTimeValue)&v31;
    std::vector<OZDynamicVertex>::__destroy_vector::operator()[abi:ne180100]((void ***)v27);
  }
  else
  {
    (*(void (**)(uint64_t, OZInterpolators **, const CMTime *, OZDynamicVertex *, OZDynamicVertex *, OZDynamicVertex *))(*(_QWORD *)Interpolator + 32))(Interpolator, this, a2, a4, a5, a3);
    (*(void (**)(OZDynamicVertex *, uint64_t, const CMTime *))(*(_QWORD *)a3 + 128))(a3, 1, a2);
  }
  v27[0] = v36;
  v26[0] = *a2;
  v22 = PC_CMTimeSaferSubtract(v27, v26, (uint64_t)&v34);
  return (*(uint64_t (**)(OZDynamicVertex *, __int128 *, double))(*(_QWORD *)a3 + 248))(a3, &v34, v22);
}

void sub_1B2C412AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  STACK[0x3C0] = v1 - 192;
  std::vector<OZDynamicVertex>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x3C0]);
  STACK[0x3C0] = v1 - 168;
  std::vector<OZDynamicVertex>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x3C0]);
  _Unwind_Resume(a1);
}

OZDynamicVertex *OZDynamicSpline::appendVertex(os_unfair_lock_s *this, const CMTime *a2, double a3, const CMTime *a4)
{
  os_unfair_lock_s *v8;
  OZDynamicVertex *v9;
  uint64_t v10;
  os_unfair_lock_s *v11;
  uint64_t v12;
  unint64_t v13;
  OZDynamicVertex **v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  OZDynamicVertex **v21;
  char *v22;
  char *v23;
  char *v24;
  OZDynamicVertex *v25;

  v8 = this + 2;
  PCSpinLock::lock(this + 2);
  v9 = (OZDynamicVertex *)operator new();
  OZDynamicVertex::OZDynamicVertex(v9, a2, a3, a4);
  v10 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
  v11 = this + 4;
  if (v10 == *(_QWORD *)&this[4]._os_unfair_lock_opaque)
    v12 = *(unsigned int *)(*(_QWORD *)&this[42]._os_unfair_lock_opaque + 32);
  else
    v12 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v10 - 8) + 208))(*(_QWORD *)(v10 - 8));
  (*(void (**)(OZDynamicVertex *, uint64_t))(*(_QWORD *)v9 + 200))(v9, v12);
  v13 = *(_QWORD *)&this[8]._os_unfair_lock_opaque;
  v14 = *(OZDynamicVertex ***)&this[6]._os_unfair_lock_opaque;
  if ((unint64_t)v14 >= v13)
  {
    v16 = ((uint64_t)v14 - *(_QWORD *)&v11->_os_unfair_lock_opaque) >> 3;
    if ((unint64_t)(v16 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v17 = v13 - *(_QWORD *)&v11->_os_unfair_lock_opaque;
    v18 = v17 >> 2;
    if (v17 >> 2 <= (unint64_t)(v16 + 1))
      v18 = v16 + 1;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v19 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v19 = v18;
    if (v19)
      v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&this[8], v19);
    else
      v20 = 0;
    v21 = (OZDynamicVertex **)&v20[8 * v16];
    v22 = &v20[8 * v19];
    *v21 = v9;
    v15 = v21 + 1;
    v24 = *(char **)&this[4]._os_unfair_lock_opaque;
    v23 = *(char **)&this[6]._os_unfair_lock_opaque;
    if (v23 != v24)
    {
      do
      {
        v25 = (OZDynamicVertex *)*((_QWORD *)v23 - 1);
        v23 -= 8;
        *--v21 = v25;
      }
      while (v23 != v24);
      v23 = *(char **)&v11->_os_unfair_lock_opaque;
    }
    *(_QWORD *)&this[4]._os_unfair_lock_opaque = v21;
    *(_QWORD *)&this[6]._os_unfair_lock_opaque = v15;
    *(_QWORD *)&this[8]._os_unfair_lock_opaque = v22;
    if (v23)
      operator delete(v23);
  }
  else
  {
    *v14 = v9;
    v15 = v14 + 1;
  }
  *(_QWORD *)&this[6]._os_unfair_lock_opaque = v15;
  OZSpline::setDirty((OZSpline *)this, 1);
  PCSpinLock::unlock(v8);
  return v9;
}

void sub_1B2C414B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C40974A25EBLL);
  _Unwind_Resume(a1);
}

BOOL OZDynamicSpline::setVertex(os_unfair_lock_s *this, _BYTE **a2, const CMTime *a3, double a4, const CMTime *a5)
{
  os_unfair_lock_s *v10;
  CMTime v12;
  CMTime time1;

  v10 = this + 2;
  PCSpinLock::lock(this + 2);
  if (a2)
  {
    v12 = *(CMTime *)(a2 + 2);
    time1 = *a3;
    if (CMTimeCompare(&time1, &v12))
    {
      (*((void (**)(_BYTE **, const CMTime *))*a2 + 2))(a2, a3);
      OZSpline::setDirty((OZSpline *)this, 1);
    }
    (*((void (**)(_BYTE **, const CMTime *, double))*a2 + 4))(a2, a5, a4);
  }
  PCSpinLock::unlock(v10);
  return a2 != 0;
}

uint64_t OZDynamicSpline::getVertexChannel(OZDynamicSpline *this, void *lpsrc)
{
  if (lpsrc)
  else
    return 0;
}

void OZDynamicSpline::setVertexChannel(OZDynamicSpline *this, void *lpsrc, OZChannelVertexFolder *a3)
{
  OZDynamicVertex *v4;

  if (lpsrc)
  else
    v4 = 0;
  OZDynamicVertex::setChannel(v4, a3);
}

uint64_t OZDynamicSpline::sampleSpline(OZDynamicSpline *this, Float64 a2, Float64 a3, unsigned int *a4, double *a5, double *a6, const CMTime *a7)
{
  uint64_t v14;
  unint64_t v15;
  CMTime *v16;
  CMTime v18;
  CMTime v19;
  CMTime v20;

  if (a5)
    v14 = operator new[]();
  else
    v14 = 0;
  OZFigTimeForChannelSeconds(&v20, a2, 0x40000);
  OZFigTimeForChannelSeconds(&v19, a3, 0x40000);
  (*(void (**)(OZDynamicSpline *, CMTime *, CMTime *, unsigned int *, uint64_t, double *, const CMTime *, _QWORD))(*(_QWORD *)this + 40))(this, &v20, &v19, a4, v14, a6, a7, 0);
  if (a5)
  {
    if (*a4)
    {
      v15 = 0;
      v16 = (CMTime *)v14;
      do
      {
        v18 = *v16;
        a5[v15++] = CMTimeGetSeconds(&v18);
        ++v16;
      }
      while (v15 < *a4);
      goto LABEL_10;
    }
    if (v14)
LABEL_10:
      MEMORY[0x1B5E2914C](v14, 0x1000C80504FFAC1);
  }
  return 1;
}

uint64_t OZDynamicSpline::sampleSpline(OZInterpolators **this, const CMTime *a2, CMTime *a3, int32_t *a4, CMTime *a5, double *a6, const CMTime *a7, char a8)
{
  uint64_t Interpolator;
  uint64_t v17;
  uint64_t v18;
  double v19;
  unsigned int v20;
  CMTimeEpoch epoch;
  __int128 v22;
  void *v23;
  void *v24;
  CMTimeEpoch v25;
  __int128 v26;
  __int128 v27;
  double v29;
  void *v30;
  void *v31;
  CMTime v32;
  CMTime v33;
  CMTime v34;
  CMTime v35;
  CMTime v36;
  unsigned int v37;
  CMTime v38;
  CMTime v39[2];

  v37 = 0;
  (*((void (**)(OZInterpolators **, unsigned int *, _QWORD, _QWORD))*this + 2))(this, &v37, 0, 0);
  Interpolator = OZInterpolators::getInterpolator(this[19], v37);
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)Interpolator + 64))(Interpolator) & 1) != 0)
  {
    OZSpline::sampleSpline((OZSpline *)this, a2, a3, a4, a5, a6, a7, a8);
    return 1;
  }
  PCSpinLock::lock((os_unfair_lock_t)this + 2);
  memset(&v36, 0, sizeof(v36));
  operator*(a3, *a4, &v36);
  memset(&v35, 0, sizeof(v35));
  v39[0] = *a2;
  v38 = v36;
  PC_CMTimeSaferAdd(v39, &v38, (uint64_t)&v35);
  v17 = OZInterpolators::getInterpolator(this[19], v37);
  (*(void (**)(CMTime *__return_ptr, uint64_t, OZInterpolators **, const CMTime *, CMTime *))(*(_QWORD *)v17 + 72))(v39, v17, this, a7, &v35);
  v35 = v39[0];
  memset(&v34, 0, sizeof(v34));
  v18 = OZInterpolators::getInterpolator(this[19], v37);
  (*(void (**)(CMTime *__return_ptr, uint64_t, OZInterpolators **, const CMTime *, const CMTime *))(*(_QWORD *)v18 + 80))(&v34, v18, this, a7, a2);
  v33 = *a3;
  if (v37 == 10 || *((_BYTE *)this + 144))
  {
    v39[0] = v35;
    v38 = v34;
    PC_CMTimeSaferSubtract(v39, &v38, (uint64_t)&v32);
    v19 = (double)(*a4 - 1);
  }
  else
  {
    if (v37 != 12)
      goto LABEL_7;
    v39[0] = v35;
    v38 = v34;
    v29 = PC_CMTimeSaferSubtract(v39, &v38, (uint64_t)&v32);
    LODWORD(v29) = *a4;
    v19 = (double)*(unint64_t *)&v29;
  }
  operator*(&v32, &v33, 1.0 / v19);
LABEL_7:
  if (*a4)
  {
    v20 = 0;
    do
    {
      if (a6)
      {
        v31 = 0;
        OZSpline::getFirstValidVertex((OZSpline *)this, &v31, a7);
        v30 = 0;
        OZSpline::getLastValidVertex((OZSpline *)this, &v30, a7);
        operator*(&v33, v20, v39);
        v36 = v39[0];
        epoch = v39[0].epoch;
        v22 = *(_OWORD *)&v39[0].value;
        v24 = v30;
        v23 = v31;
        v39[0] = v34;
        *(_OWORD *)&v38.value = v22;
        v38.epoch = epoch;
        PC_CMTimeSaferAdd(v39, &v38, (uint64_t)&v32);
        OZSpline::interpolate((OZSpline *)this, a7, v23, v24, &v32, a6++, 0);
      }
      if (a5)
      {
        operator*(&v33, v20, v39);
        v36 = v39[0];
        v25 = v39[0].epoch;
        v26 = *(_OWORD *)&v39[0].value;
        v39[0] = v34;
        *(_OWORD *)&v38.value = v26;
        v38.epoch = v25;
        PC_CMTimeSaferAdd(v39, &v38, (uint64_t)&v32);
        v27 = *(_OWORD *)&v32.value;
        a5->epoch = v32.epoch;
        *(_OWORD *)&a5->value = v27;
        ++a5;
      }
      ++v20;
    }
    while (v20 < *a4);
  }
  PCSpinLock::unlock((os_unfair_lock_t)this + 2);
  return 1;
}

uint64_t OZDynamicSpline::sampleSpline(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, Float64 a6, Float64 a7)
{
  void **v14;
  unint64_t v15;
  uint64_t v16;
  CMTimeEpoch v17;
  double Seconds;
  double v19;
  unint64_t v20;
  double *v21;
  double *v22;
  double *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  double *v29;
  uint64_t v30;
  void *v31;
  CMTime v33;
  CMTime v34;
  CMTime v35;

  if (a3)
  {
    v14 = (void **)operator new();
    v14[1] = 0;
    v14[2] = 0;
    *v14 = 0;
  }
  else
  {
    v14 = 0;
  }
  OZFigTimeForChannelSeconds(&v35, a6, 0x40000);
  OZFigTimeForChannelSeconds(&v34, a7, 0x40000);
  (*(void (**)(uint64_t, CMTime *, CMTime *, _DWORD *, void **, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 48))(a1, &v35, &v34, a2, v14, a4, a5, 0);
  if (a3)
  {
    if (*a2)
    {
      v15 = 0;
      do
      {
        v16 = (uint64_t)*v14 + 24 * v15;
        v17 = *(_QWORD *)(v16 + 16);
        *(_OWORD *)&v33.value = *(_OWORD *)v16;
        v33.epoch = v17;
        Seconds = CMTimeGetSeconds(&v33);
        v19 = Seconds;
        v21 = *(double **)(a3 + 8);
        v20 = *(_QWORD *)(a3 + 16);
        if ((unint64_t)v21 >= v20)
        {
          v23 = *(double **)a3;
          v24 = ((uint64_t)v21 - *(_QWORD *)a3) >> 3;
          v25 = v24 + 1;
          if ((unint64_t)(v24 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v26 = v20 - (_QWORD)v23;
          if (v26 >> 2 > v25)
            v25 = v26 >> 2;
          if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8)
            v27 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v27 = v25;
          if (v27)
          {
            v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a3 + 16, v27);
            v23 = *(double **)a3;
            v21 = *(double **)(a3 + 8);
          }
          else
          {
            v28 = 0;
          }
          v29 = (double *)&v28[8 * v24];
          *v29 = v19;
          v22 = v29 + 1;
          while (v21 != v23)
          {
            v30 = *((_QWORD *)v21-- - 1);
            *((_QWORD *)v29-- - 1) = v30;
          }
          *(_QWORD *)a3 = v29;
          *(_QWORD *)(a3 + 8) = v22;
          *(_QWORD *)(a3 + 16) = &v28[8 * v27];
          if (v23)
            operator delete(v23);
        }
        else
        {
          *v21 = Seconds;
          v22 = v21 + 1;
        }
        *(_QWORD *)(a3 + 8) = v22;
        ++v15;
      }
      while (v15 < *a2);
    }
    if (v14)
    {
      v31 = *v14;
      if (*v14)
      {
        v14[1] = v31;
        operator delete(v31);
      }
      MEMORY[0x1B5E29170](v14, 0x20C40960023A9);
    }
  }
  return 1;
}

uint64_t OZDynamicSpline::sampleSpline(os_unfair_lock_s *a1, CMTime *a2, CMTime *a3, int32_t *a4, void **a5, uint64_t a6, const CMTime *a7, char a8)
{
  uint64_t Interpolator;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  CMTimeEpoch epoch;
  __int128 v21;
  void *v22;
  void *v23;
  unint64_t v24;
  double *v25;
  double *v26;
  double *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  double *v33;
  uint64_t v34;
  CMTimeEpoch v35;
  __int128 v36;
  char *v37;
  char *v38;
  __int128 v39;
  char *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  char *v45;
  char *v46;
  __int128 v47;
  char *v48;
  char *v49;
  char *v50;
  __int128 v51;
  double v53;
  double v54;
  void *v55;
  void *v56;
  CMTime v57;
  CMTime v58;
  CMTime v59;
  CMTime v60;
  CMTime v61;
  int v62;
  CMTime v63;
  CMTime v64;

  v62 = 0;
  if (a5)
    std::vector<CMTime>::reserve(a5, *a4);
  if (a6)
    std::vector<double>::reserve((void **)a6, *a4);
  (*(void (**)(os_unfair_lock_s *, int *, _QWORD, _QWORD))(*(_QWORD *)&a1->_os_unfair_lock_opaque + 16))(a1, &v62, 0, 0);
  Interpolator = OZInterpolators::getInterpolator(*(OZInterpolators **)&a1[38]._os_unfair_lock_opaque, v62);
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)Interpolator + 64))(Interpolator) & 1) != 0)
  {
    OZSpline::sampleSpline((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
    PCSpinLock::lock(a1 + 2);
    memset(&v61, 0, sizeof(v61));
    operator*(a3, *a4, &v61);
    memset(&v60, 0, sizeof(v60));
    v64 = *a2;
    v63 = v61;
    PC_CMTimeSaferAdd(&v64, &v63, (uint64_t)&v60);
    v17 = OZInterpolators::getInterpolator(*(OZInterpolators **)&a1[38]._os_unfair_lock_opaque, v62);
    (*(void (**)(CMTime *__return_ptr, uint64_t, os_unfair_lock_s *, const CMTime *, CMTime *))(*(_QWORD *)v17 + 72))(&v64, v17, a1, a7, &v60);
    v60 = v64;
    memset(&v59, 0, sizeof(v59));
    v18 = OZInterpolators::getInterpolator(*(OZInterpolators **)&a1[38]._os_unfair_lock_opaque, v62);
    (*(void (**)(CMTime *__return_ptr, uint64_t, os_unfair_lock_s *, const CMTime *, CMTime *))(*(_QWORD *)v18 + 80))(&v59, v18, a1, a7, a2);
    v58 = v59;
    if (v62 == 10 || LOBYTE(a1[36]._os_unfair_lock_opaque))
    {
      v64 = v60;
      v63 = v59;
      PC_CMTimeSaferSubtract(&v64, &v63, (uint64_t)&v57);
      operator*(&v57, &v58, 1.0 / (double)(*a4 - 1));
    }
    else if (v62 == 12)
    {
      v64 = v60;
      v63 = v59;
      v53 = PC_CMTimeSaferSubtract(&v64, &v63, (uint64_t)&v57);
      LODWORD(v53) = *a4;
      operator*(&v57, &v64, 1.0 / (double)*(unint64_t *)&v53);
      v58 = v64;
    }
    if (*a4)
    {
      v19 = 0;
      do
      {
        if (a6)
        {
          v56 = 0;
          OZSpline::getFirstValidVertex((OZSpline *)a1, &v56, a7);
          v55 = 0;
          OZSpline::getLastValidVertex((OZSpline *)a1, &v55, a7);
          v54 = 0.0;
          operator*(&v58, v19, &v64);
          v61 = v64;
          epoch = v64.epoch;
          v21 = *(_OWORD *)&v64.value;
          v22 = v55;
          v23 = v56;
          v64 = v59;
          *(_OWORD *)&v63.value = v21;
          v63.epoch = epoch;
          PC_CMTimeSaferAdd(&v64, &v63, (uint64_t)&v57);
          OZSpline::interpolate((OZSpline *)a1, a7, v23, v22, &v57, &v54, 0);
          v25 = *(double **)(a6 + 8);
          v24 = *(_QWORD *)(a6 + 16);
          if ((unint64_t)v25 >= v24)
          {
            v27 = *(double **)a6;
            v28 = ((uint64_t)v25 - *(_QWORD *)a6) >> 3;
            v29 = v28 + 1;
            if ((unint64_t)(v28 + 1) >> 61)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v30 = v24 - (_QWORD)v27;
            if (v30 >> 2 > v29)
              v29 = v30 >> 2;
            if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8)
              v31 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v31 = v29;
            if (v31)
            {
              v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a6 + 16, v31);
              v27 = *(double **)a6;
              v25 = *(double **)(a6 + 8);
            }
            else
            {
              v32 = 0;
            }
            v33 = (double *)&v32[8 * v28];
            *v33 = v54;
            v26 = v33 + 1;
            while (v25 != v27)
            {
              v34 = *((_QWORD *)v25-- - 1);
              *((_QWORD *)v33-- - 1) = v34;
            }
            *(_QWORD *)a6 = v33;
            *(_QWORD *)(a6 + 8) = v26;
            *(_QWORD *)(a6 + 16) = &v32[8 * v31];
            if (v27)
              operator delete(v27);
          }
          else
          {
            *v25 = v54;
            v26 = v25 + 1;
          }
          *(_QWORD *)(a6 + 8) = v26;
        }
        if (a5)
        {
          operator*(&v58, v19, &v64);
          v61 = v64;
          v35 = v64.epoch;
          v36 = *(_OWORD *)&v64.value;
          v64 = v59;
          *(_OWORD *)&v63.value = v36;
          v63.epoch = v35;
          PC_CMTimeSaferAdd(&v64, &v63, (uint64_t)&v57);
          v38 = (char *)a5[1];
          v37 = (char *)a5[2];
          if (v38 >= v37)
          {
            v41 = 0xAAAAAAAAAAAAAAABLL * ((v38 - (_BYTE *)*a5) >> 3);
            v42 = v41 + 1;
            if (v41 + 1 > 0xAAAAAAAAAAAAAAALL)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v43 = 0xAAAAAAAAAAAAAAABLL * ((v37 - (_BYTE *)*a5) >> 3);
            if (2 * v43 > v42)
              v42 = 2 * v43;
            if (v43 >= 0x555555555555555)
              v44 = 0xAAAAAAAAAAAAAAALL;
            else
              v44 = v42;
            if (v44)
              v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a5 + 2), v44);
            else
              v45 = 0;
            v46 = &v45[24 * v41];
            v47 = *(_OWORD *)&v57.value;
            *((_QWORD *)v46 + 2) = v57.epoch;
            *(_OWORD *)v46 = v47;
            v49 = (char *)*a5;
            v48 = (char *)a5[1];
            v50 = v46;
            if (v48 != *a5)
            {
              do
              {
                v51 = *(_OWORD *)(v48 - 24);
                *((_QWORD *)v50 - 1) = *((_QWORD *)v48 - 1);
                *(_OWORD *)(v50 - 24) = v51;
                v50 -= 24;
                v48 -= 24;
              }
              while (v48 != v49);
              v48 = (char *)*a5;
            }
            v40 = v46 + 24;
            *a5 = v50;
            a5[1] = v46 + 24;
            a5[2] = &v45[24 * v44];
            if (v48)
              operator delete(v48);
          }
          else
          {
            v39 = *(_OWORD *)&v57.value;
            *((_QWORD *)v38 + 2) = v57.epoch;
            *(_OWORD *)v38 = v39;
            v40 = v38 + 24;
          }
          a5[1] = v40;
        }
        ++v19;
      }
      while (v19 < *a4);
    }
    PCSpinLock::unlock(a1 + 2);
  }
  return 1;
}

BOOL OZDynamicSpline::setVertexInputHandles(os_unfair_lock_s *this, void *a2, double a3, double a4, const CMTime *a5)
{
  os_unfair_lock_s *v9;

  v9 = this + 2;
  PCSpinLock::lock(this + 2);
  if (a2)
    (*(void (**)(void *, const CMTime *, double, double))(*(_QWORD *)a2 + 72))(a2, a5, a3, a4);
  PCSpinLock::unlock(v9);
  return a2 != 0;
}

BOOL OZDynamicSpline::setVertexOutputHandles(os_unfair_lock_s *this, void *a2, double a3, double a4, const CMTime *a5)
{
  os_unfair_lock_s *v10;
  void **VertexIter;
  void **v12;

  v10 = this + 2;
  PCSpinLock::lock(this + 2);
  VertexIter = OZSpline::getVertexIter((OZSpline *)this, a2);
  v12 = *(void ***)&this[6]._os_unfair_lock_opaque;
  if (v12 != VertexIter)
    (*(void (**)(void *, const CMTime *, double, double))(*(_QWORD *)a2 + 80))(a2, a5, a3, a4);
  PCSpinLock::unlock(v10);
  return v12 != VertexIter;
}

BOOL OZDynamicSpline::getVertexInputHandles(os_unfair_lock_s *this, void *a2, double *a3, double *a4, const CMTime *a5)
{
  os_unfair_lock_s *v9;
  uint64_t v11;
  uint64_t v12;

  v11 = 0;
  v12 = 0;
  v9 = this + 2;
  PCSpinLock::lock(this + 2);
  if (a2)
  {
    (*(void (**)(void *, uint64_t *, uint64_t *, const CMTime *))(*(_QWORD *)a2 + 56))(a2, &v12, &v11, a5);
    if (a3)
      *(_QWORD *)a3 = v12;
    if (a4)
      *(_QWORD *)a4 = v11;
  }
  PCSpinLock::unlock(v9);
  return a2 != 0;
}

BOOL OZDynamicSpline::getVertexOutputHandles(os_unfair_lock_s *this, void *a2, double *a3, double *a4, const CMTime *a5)
{
  os_unfair_lock_s *v10;
  void **VertexIter;
  void **v12;
  uint64_t v14;
  uint64_t v15;

  v14 = 0;
  v15 = 0;
  v10 = this + 2;
  PCSpinLock::lock(this + 2);
  VertexIter = OZSpline::getVertexIter((OZSpline *)this, a2);
  v12 = *(void ***)&this[6]._os_unfair_lock_opaque;
  if (v12 != VertexIter)
  {
    (*(void (**)(void *, uint64_t *, uint64_t *, const CMTime *))(*(_QWORD *)a2 + 64))(a2, &v15, &v14, a5);
    if (a3)
      *(_QWORD *)a3 = v15;
    if (a4)
      *(_QWORD *)a4 = v14;
  }
  PCSpinLock::unlock(v10);
  return v12 != VertexIter;
}

void OZDynamicSpline::reverseWindingOrder(OZDynamicSpline *this, const CMTime *a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  unint64_t v7;
  uint64_t v8;
  BOOL v9;
  uint64_t *i;
  uint64_t v11;

  v3 = *((_QWORD *)this + 2);
  v4 = *((_QWORD *)this + 3);
  v5 = (_QWORD *)(v4 - 8);
  if (v3 + 8 != v4 && (unint64_t)v5 > v3 + 8)
  {
    v7 = v3 + 16;
    do
    {
      v8 = *(_QWORD *)(v7 - 8);
      *(_QWORD *)(v7 - 8) = *v5;
      *v5-- = v8;
      v9 = v7 >= (unint64_t)v5;
      v7 += 8;
    }
    while (!v9);
  }
  OZSpline::reparametrize((uint64_t)this);
  for (i = (uint64_t *)*((_QWORD *)this + 2); i != *((uint64_t **)this + 3); ++i)
  {
    v11 = *i;
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 120))(v11);
  }
  OZSpline::setDirty(this, 1);
}

BOOL OZDynamicSpline::getInterpolation(OZDynamicSpline *this, unsigned int *a2, BOOL *a3, BOOL *a4)
{
  int v8;
  uint64_t Interpolator;
  uint64_t v10;

  if (a2)
  {
    v8 = *(_DWORD *)(*((_QWORD *)this + 21) + 32);
    *a2 = v8;
    if (a3)
    {
      Interpolator = OZInterpolators::getInterpolator(*((OZInterpolators **)this + 19), v8);
      *a3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)Interpolator + 56))(Interpolator);
    }
    if (a4)
    {
      v10 = OZInterpolators::getInterpolator(*((OZInterpolators **)this + 19), *a2);
      *a4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 64))(v10) ^ 1;
    }
  }
  return a2 != 0;
}

void OZDynamicSpline::deriveCurve(OZDynamicSpline *this, OZVertex *lpsrc, const CMTime *a3)
{
  const OZDynamicVertex *v6;
  OZInterpolators *v7;
  int v8;
  uint64_t Interpolator;
  const OZDynamicVertex *v10;
  __n128 v11;
  OZInterpolators *v12;
  int v13;
  uint64_t v14;
  const OZDynamicVertex *v15;
  __n128 v16;
  OZInterpolators *v17;
  int v18;
  uint64_t v19;
  CMTime v20;
  CMTime v21;
  CMTime v22;
  _BYTE v23[944];
  double v24;
  void *v25;
  void *lpsrca;
  void *v27;
  void *v28;
  _BYTE v29[944];
  CMTime v30;
  CMTime v31;

  OZDynamicVertex::OZDynamicVertex((OZDynamicVertex *)v29, v6);
  v28 = 0;
  v27 = 0;
  lpsrca = 0;
  v25 = 0;
  v24 = 0.0;
  OZSpline::getPreviousValidVertex(this, lpsrc, &v28, a3);
  OZSpline::getNextValidVertex((void ***)this, lpsrc, &v27, a3);
  OZSpline::getFirstValidVertex(this, &v25, a3);
  OZSpline::getLastValidVertex(this, &lpsrca, a3);
  if (v28 && v27)
  {
    v7 = (OZInterpolators *)*((_QWORD *)this + 19);
    v8 = (*(uint64_t (**)(OZVertex *))(*(_QWORD *)lpsrc + 208))(lpsrc);
    Interpolator = OZInterpolators::getInterpolator(v7, v8);
    (*(void (**)(uint64_t, OZDynamicSpline *, const CMTime *, void *, void *, _BYTE *))(*(_QWORD *)Interpolator
                                                                                                + 32))(Interpolator, this, a3, v28, v27, v29);
    OZDynamicVertex::getInputTangents((OZDynamicVertex *)v29, 0, &v24, a3);
    (*(void (**)(OZVertex *, const CMTime *, double, double))(*(_QWORD *)lpsrc + 72))(lpsrc, a3, 0.0, v24);
    OZDynamicVertex::getOutputTangents((OZDynamicVertex *)v29, 0, &v24, a3);
    (*(void (**)(OZVertex *, const CMTime *, double, double))(*(_QWORD *)lpsrc + 80))(lpsrc, a3, 0.0, v24);
    goto LABEL_15;
  }
  if (v28 || !v27)
  {
    if (v28 && !v27 && *((_BYTE *)this + 144) && v25)
    {
      OZDynamicVertex::OZDynamicVertex((OZDynamicVertex *)v23, v15);
      v21 = *(CMTime *)((char *)lpsrc + 16);
      OZSpline::getStep(this, &v20);
      v31 = v21;
      v30 = v20;
      PC_CMTimeSaferAdd(&v31, &v30, (uint64_t)&v22);
      v16 = OZVertex::setValueU((OZVertex *)v23, &v22);
      v17 = (OZInterpolators *)*((_QWORD *)this + 19);
      v18 = (*(uint64_t (**)(OZVertex *, __n128))(*(_QWORD *)lpsrc + 208))(lpsrc, v16);
      v19 = OZInterpolators::getInterpolator(v17, v18);
      (*(void (**)(uint64_t, OZDynamicSpline *, const CMTime *, void *, _BYTE *, _BYTE *))(*(_QWORD *)v19 + 32))(v19, this, a3, v28, v23, v29);
      OZDynamicVertex::getInputTangents((OZDynamicVertex *)v29, 0, &v24, a3);
      (*(void (**)(OZVertex *, const CMTime *, double, double))(*(_QWORD *)lpsrc + 72))(lpsrc, a3, 0.0, v24);
      OZDynamicVertex::getOutputTangents((OZDynamicVertex *)v29, 0, &v24, a3);
      (*(void (**)(OZVertex *, const CMTime *, double, double))(*(_QWORD *)lpsrc + 80))(lpsrc, a3, 0.0, v24);
      goto LABEL_14;
    }
  }
  else if (*((_BYTE *)this + 144) && lpsrca)
  {
    OZDynamicVertex::OZDynamicVertex((OZDynamicVertex *)v23, v10);
    v21 = *(CMTime *)((char *)lpsrc + 16);
    OZSpline::getStep(this, &v20);
    v31 = v21;
    v30 = v20;
    PC_CMTimeSaferSubtract(&v31, &v30, (uint64_t)&v22);
    v11 = OZVertex::setValueU((OZVertex *)v23, &v22);
    v12 = (OZInterpolators *)*((_QWORD *)this + 19);
    v13 = (*(uint64_t (**)(OZVertex *, __n128))(*(_QWORD *)lpsrc + 208))(lpsrc, v11);
    v14 = OZInterpolators::getInterpolator(v12, v13);
    (*(void (**)(uint64_t, OZDynamicSpline *, const CMTime *, _BYTE *, void *, _BYTE *))(*(_QWORD *)v14 + 32))(v14, this, a3, v23, v27, v29);
    OZDynamicVertex::getInputTangents((OZDynamicVertex *)v29, 0, &v24, a3);
    (*(void (**)(OZVertex *, const CMTime *, double, double))(*(_QWORD *)lpsrc + 72))(lpsrc, a3, 0.0, v24);
    OZDynamicVertex::getOutputTangents((OZDynamicVertex *)v29, 0, &v24, a3);
    (*(void (**)(OZVertex *, const CMTime *, double, double))(*(_QWORD *)lpsrc + 80))(lpsrc, a3, 0.0, v24);
LABEL_14:
    OZDynamicVertex::~OZDynamicVertex((OZDynamicVertex *)v23);
  }
LABEL_15:
  OZDynamicVertex::~OZDynamicVertex((OZDynamicVertex *)v29);
}

void sub_1B2C429BC(_Unwind_Exception *a1)
{
  OZDynamicVertex::~OZDynamicVertex((OZDynamicVertex *)&STACK[0x430]);
  _Unwind_Resume(a1);
}

uint64_t OZDynamicSpline::setVertexSmooth(OZDynamicSpline *this, void *a2, char a3, const CMTime *a4)
{
  if ((a3 & 1) == 0)
  {
    (*(void (**)(void *, const CMTime *, double, double))(*(_QWORD *)a2 + 72))(a2, a4, 0.0, 0.0);
    (*(void (**)(void *, const CMTime *, double, double))(*(_QWORD *)a2 + 80))(a2, a4, 0.0, 0.0);
  }
  return 1;
}

BOOL OZDynamicSpline::enableVertex(OZSpline *this, void *a2, const CMTime *a3)
{
  *((_BYTE *)this + 112) = 0;
  return OZSpline::enableVertex(this, a2, a3);
}

BOOL OZDynamicSpline::disableVertex(OZSpline *this, void *a2, const CMTime *a3)
{
  *((_BYTE *)this + 112) = 0;
  return OZSpline::disableVertex(this, a2, a3);
}

OZChannelBase *OZDynamicSpline::setVertexID(OZDynamicSpline *this, void *lpsrc, unsigned int a3)
{
  char *v4;

  if (lpsrc)
  else
    v4 = 0;
  return OZChannelBase::setID((OZChannelBase *)(v4 + 48), a3);
}

void OZDynamicSpline::flattenSpline(OZDynamicSpline *this)
{
  uint64_t *v2;
  os_unfair_lock_s *v3;
  uint64_t v4;

  v2 = (uint64_t *)*((_QWORD *)this + 5);
  v3 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock((os_unfair_lock_t)this + 2);
  while (v2 != *((uint64_t **)this + 6))
  {
    v4 = *v2++;
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 96))(v4);
  }
  PCSpinLock::unlock(v3);
}

uint64_t OZDynamicSpline::isSplineFlattened(OZDynamicSpline *this)
{
  _QWORD *v2;
  os_unfair_lock_s *v3;
  uint64_t v4;

  v2 = (_QWORD *)*((_QWORD *)this + 5);
  v3 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock((os_unfair_lock_t)this + 2);
  if (*((_QWORD **)this + 6) == v2)
  {
    v4 = 1;
  }
  else
  {
    do
    {
      v4 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v2 + 144))(*v2);
      if ((v4 & 1) == 0)
        break;
      ++v2;
    }
    while (v2 != *((_QWORD **)this + 6));
  }
  PCSpinLock::unlock(v3);
  return v4;
}

uint64_t OZDynamicSpline::isVertexFlattened(OZDynamicSpline *this, void *a2)
{
  return (*(uint64_t (**)(void *))(*(_QWORD *)a2 + 144))(a2);
}

void OZDynamicSpline::setDefaultValueAtCurrentTime(OZDynamicSpline *this, const CMTime *a2)
{
  uint64_t *v4;
  os_unfair_lock_s *v5;
  uint64_t v6;

  v4 = (uint64_t *)*((_QWORD *)this + 5);
  v5 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock((os_unfair_lock_t)this + 2);
  while (v4 != *((uint64_t **)this + 6))
  {
    v6 = *v4++;
    (*(void (**)(uint64_t, const CMTime *))(*(_QWORD *)v6 + 192))(v6, a2);
  }
  PCSpinLock::unlock(v5);
}

void OZDynamicSpline::setDefaultValueAtCurrentTime(os_unfair_lock_s *this, void *a2, const CMTime *a3)
{
  os_unfair_lock_s *v5;

  v5 = this + 2;
  PCSpinLock::lock(this + 2);
  (*(void (**)(void *, const CMTime *))(*(_QWORD *)a2 + 192))(a2, a3);
  PCSpinLock::unlock(v5);
}

BOOL OZDynamicSpline::updateVertexBias(OZDynamicSpline *this, void *a2)
{
  if (a2)
    (*(void (**)(void *))(*(_QWORD *)a2 + 224))(a2);
  return a2 != 0;
}

uint64_t OZDynamicSpline::getVertexToInsert(OZInterpolators **this, const CMTime *a2, const CMTime *a3, double *a4, double *a5, double *a6, double *a7, double *a8)
{
  uint64_t result;
  OZStaticVertex *v17;
  __int128 v18;
  double v19;
  OZStaticVertex *v20;
  __int128 v21;
  double v22;
  OZStaticVertex *v23;
  uint64_t Interpolator;
  double *v25;
  double v26;
  CMTime v27;
  void *v28;
  void *v29;
  unsigned int v30;

  v30 = 0;
  (*((void (**)(OZInterpolators **, unsigned int *, _QWORD, _QWORD))*this + 2))(this, &v30, 0, 0);
  v28 = 0;
  v29 = 0;
  result = OZSpline::getPreviousValidVertex((OZSpline *)this, a3, &v29, a2, 0);
  if ((_DWORD)result)
  {
    result = OZSpline::getNextValidVertex((OZSpline *)this, a3, &v28, a2, 0);
    if ((result & 1) != 0
      || *((_BYTE *)this + 144) && (result = OZSpline::getFirstValidVertex((OZSpline *)this, &v28, a2), (_DWORD)result))
    {
      v17 = (OZStaticVertex *)operator new();
      v18 = *((_OWORD *)v29 + 1);
      v27.epoch = *((_QWORD *)v29 + 4);
      *(_OWORD *)&v27.value = v18;
      v19 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v29 + 24))(v29, a2);
      OZStaticVertex::OZStaticVertex(v17, &v27, v19);
      v25 = a8;
      v20 = (OZStaticVertex *)operator new();
      v21 = *((_OWORD *)v28 + 1);
      v27.epoch = *((_QWORD *)v28 + 4);
      *(_OWORD *)&v27.value = v21;
      v22 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v28 + 24))(v28, a2);
      OZStaticVertex::OZStaticVertex(v20, &v27, v22);
      v23 = (OZStaticVertex *)operator new();
      OZStaticVertex::OZStaticVertex(v23, a3, 0.0);
      v26 = 0.0;
      v27.value = 0;
      (*(void (**)(void *, CMTime *, double *, const CMTime *))(*(_QWORD *)v29 + 56))(v29, &v27, &v26, a2);
      (*(void (**)(OZStaticVertex *, const CMTime *, double, double))(*(_QWORD *)v17 + 72))(v17, a2, *(double *)&v27.value, v26);
      (*(void (**)(void *, CMTime *, double *, const CMTime *))(*(_QWORD *)v29 + 64))(v29, &v27, &v26, a2);
      (*(void (**)(OZStaticVertex *, const CMTime *, double, double))(*(_QWORD *)v17 + 80))(v17, a2, *(double *)&v27.value, v26);
      (*(void (**)(void *, CMTime *, double *, const CMTime *))(*(_QWORD *)v28 + 56))(v28, &v27, &v26, a2);
      (*(void (**)(OZStaticVertex *, const CMTime *, double, double))(*(_QWORD *)v20 + 72))(v20, a2, *(double *)&v27.value, v26);
      (*(void (**)(void *, CMTime *, double *, const CMTime *))(*(_QWORD *)v28 + 64))(v28, &v27, &v26, a2);
      (*(void (**)(OZStaticVertex *, const CMTime *, double, double))(*(_QWORD *)v20 + 80))(v20, a2, *(double *)&v27.value, v26);
      Interpolator = OZInterpolators::getInterpolator(this[19], v30);
      (*(void (**)(uint64_t, OZInterpolators **, const CMTime *, OZStaticVertex *, OZStaticVertex *, OZStaticVertex *))(*(_QWORD *)Interpolator + 32))(Interpolator, this, a2, v17, v20, v23);
      if (a4)
        *a4 = (*(double (**)(OZStaticVertex *, const CMTime *))(*(_QWORD *)v23 + 24))(v23, a2);
      (*(void (**)(OZStaticVertex *, _QWORD, double *, const CMTime *))(*(_QWORD *)v23 + 64))(v23, 0, a6, a2);
      (*(void (**)(OZStaticVertex *, _QWORD, double *, const CMTime *))(*(_QWORD *)v23 + 56))(v23, 0, a5, a2);
      (*(void (**)(OZStaticVertex *, _QWORD, double *, const CMTime *))(*(_QWORD *)v17 + 64))(v17, 0, a7, a2);
      (*(void (**)(OZStaticVertex *, _QWORD, double *, const CMTime *))(*(_QWORD *)v20 + 56))(v20, 0, v25, a2);
      (*(void (**)(OZStaticVertex *))(*(_QWORD *)v17 + 8))(v17);
      (*(void (**)(OZStaticVertex *))(*(_QWORD *)v20 + 8))(v20);
      return (*(uint64_t (**)(OZStaticVertex *))(*(_QWORD *)v23 + 8))(v23);
    }
  }
  return result;
}

void sub_1B2C42FE0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1081C4082842762);
  _Unwind_Resume(a1);
}

uint64_t OZDynamicSpline::enabledBehaviorForVertex(OZDynamicSpline *this, void *a2)
{
  return (*(uint64_t (**)(void *))(*(_QWORD *)a2 + 240))(a2);
}

uint64_t OZDynamicSpline::enableBehaviorForVertex(OZDynamicSpline *this, void *a2, uint64_t a3)
{
  return (*(uint64_t (**)(void *, uint64_t))(*(_QWORD *)a2 + 232))(a2, a3);
}

uint64_t OZDynamicSpline::getAllVerticesHandles(OZSpline *a1, char **a2)
{
  uint64_t *v4;
  uint64_t *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;

  OZSpline::preSplineAccess(a1, 1);
  v4 = (uint64_t *)*((_QWORD *)a1 + 2);
  v5 = (uint64_t *)*((_QWORD *)a1 + 3);
  if (v4 != v5)
  {
    v6 = a2 + 2;
    v7 = a2[1];
    do
    {
      v8 = *v4;
      if ((unint64_t)v7 >= *v6)
      {
        v9 = (v7 - *a2) >> 3;
        if ((unint64_t)(v9 + 1) >> 61)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = *v6 - (_QWORD)*a2;
        v11 = v10 >> 2;
        if (v10 >> 2 <= (unint64_t)(v9 + 1))
          v11 = v9 + 1;
        if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
          v12 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v12 = v11;
        if (v12)
          v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a2 + 2), v12);
        else
          v13 = 0;
        v14 = &v13[8 * v9];
        *(_QWORD *)v14 = v8;
        v7 = v14 + 8;
        v16 = *a2;
        v15 = a2[1];
        if (v15 != *a2)
        {
          do
          {
            v17 = *((_QWORD *)v15 - 1);
            v15 -= 8;
            *((_QWORD *)v14 - 1) = v17;
            v14 -= 8;
          }
          while (v15 != v16);
          v15 = *a2;
        }
        *a2 = v14;
        a2[1] = v7;
        a2[2] = &v13[8 * v12];
        if (v15)
          operator delete(v15);
      }
      else
      {
        *(_QWORD *)v7 = v8;
        v7 += 8;
      }
      a2[1] = v7;
      ++v4;
    }
    while (v4 != v5);
  }
  OZSpline::postSplineAccess(a1, 1);
  return 1;
}

uint64_t OZDynamicSpline::deleteVertex(char **this, void *a2, int a3, const CMTime *a4)
{
  void *v8;
  uint64_t v9;
  void **VertexIter;
  void **v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  CMTime v16;
  CMTime v17;

  OZSpline::preSplineAccess((OZSpline *)this, 1);
  if (!a2)
    goto LABEL_4;
  v9 = (uint64_t)v8;
  if (v8)
  {
    if (((*(uint64_t (**)(void *, uint64_t))(*(_QWORD *)v8 + 184))(v8, 2) & 1) != 0)
    {
LABEL_4:
      v9 = 0;
      goto LABEL_15;
    }
    VertexIter = OZSpline::getVertexIter((OZSpline *)this, a2);
    v11 = VertexIter;
    if (a3)
    {
      OZSpline::scaleTangentsBeforeDeletion((OZSpline *)this, (_BYTE **)*VertexIter, a4);
      v17 = *a4;
      v12 = v9 + 48;
      if ((*(unsigned int (**)(uint64_t, CMTime *, _QWORD))(*(_QWORD *)(v9 + 48) + 624))(v9 + 48, &v17, 0))
      {
        do
          OZSpline::scaleTangentsBeforeDeletion((OZSpline *)this, (_BYTE **)*v11, &v17);
        while (((*(uint64_t (**)(uint64_t, CMTime *, _QWORD))(*(_QWORD *)v12 + 624))(v9 + 48, &v17, 0) & 1) != 0);
      }
      v16 = *a4;
      if ((*(unsigned int (**)(uint64_t, CMTime *, _QWORD))(*(_QWORD *)v12 + 632))(v9 + 48, &v16, 0))
      {
        do
          OZSpline::scaleTangentsBeforeDeletion((OZSpline *)this, (_BYTE **)*v11, &v16);
        while (((*(uint64_t (**)(uint64_t, CMTime *, _QWORD))(*(_QWORD *)v12 + 632))(v9 + 48, &v16, 0) & 1) != 0);
      }
    }
    v13 = this[3];
    v14 = v13 - (char *)(v11 + 1);
    if (v13 != (char *)(v11 + 1))
      memmove(v11, v11 + 1, v13 - (char *)(v11 + 1));
    this[3] = (char *)v11 + v14;
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
    if (this[2] == this[3])
      *((_BYTE *)this + 144) = 0;
    v9 = 1;
    OZSpline::setDirty((OZSpline *)this, 1);
  }
LABEL_15:
  OZSpline::postSplineAccess((OZSpline *)this, 1);
  return v9;
}

void std::vector<OZDynamicVertex>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void (***v2)(_QWORD);
  void (***v4)(_QWORD);
  void *v5;
  void (***v6)(_QWORD);
  BOOL v7;

  v1 = *a1;
  v2 = (void (***)(_QWORD))**a1;
  if (v2)
  {
    v4 = (void (***)(_QWORD))v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 118;
      do
      {
        (**v6)(v6);
        v7 = v6 == v2;
        v6 -= 118;
      }
      while (!v7);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<OZDynamicVertex>::__push_back_slow_path<OZDynamicVertex const&>(uint64_t *a1, const OZDynamicVertex *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v13;
  OZDynamicVertex *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xCBEEA4E1A08AD8F3 * ((a1[1] - *a1) >> 4);
  v5 = v4 + 1;
  if (v4 + 1 > 0x456C797DD49C34)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xCBEEA4E1A08AD8F3 * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x22B63CBEEA4E1ALL)
    v9 = 0x456C797DD49C34;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<OZDynamicVertex>>(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = (OZDynamicVertex *)&v10[944 * v4];
  v16 = &v10[944 * v9];
  OZDynamicVertex::OZDynamicVertex(v14, a2);
  v15 = (char *)v14 + 944;
  std::vector<OZDynamicVertex>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<OZDynamicVertex>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_1B2C434C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<OZDynamicVertex>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<OZDynamicVertex>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<OZDynamicVertex>,std::reverse_iterator<OZDynamicVertex*>,std::reverse_iterator<OZDynamicVertex*>,std::reverse_iterator<OZDynamicVertex*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<OZDynamicVertex>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x456C797DD49C35)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(944 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<OZDynamicVertex>,std::reverse_iterator<OZDynamicVertex*>,std::reverse_iterator<OZDynamicVertex*>,std::reverse_iterator<OZDynamicVertex*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  OZDynamicVertex *v12;

  v10 = 0;
  v11 = a7 - 944;
  while (a3 + v10 != a5)
  {
    v12 = (OZDynamicVertex *)(v11 + v10);
    v10 -= 944;
    OZDynamicVertex::OZDynamicVertex(v12, (const OZDynamicVertex *)(v10 + a3));
  }
  return a6;
}

uint64_t std::__split_buffer<OZDynamicVertex>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 944;
    (**(void (***)(uint64_t))(i - 944))(i - 944);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_1B2C43744(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  uint64_t v10;

  PCString::~PCString(&a10);
  MEMORY[0x1B5E29170](v10, 0x10E1C400C70C378);
  _Unwind_Resume(a1);
}

void sub_1B2C43840(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

void sub_1B2C4395C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

void sub_1B2C43A74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  uint64_t v10;

  PCString::~PCString(&a10);
  MEMORY[0x1B5E29170](v10, 0x10E1C400C70C378);
  _Unwind_Resume(a1);
}

void OZSpline::OZSpline(OZSpline *this, OZSplineState *a2)
{
  OZInterpolators *v3;

  *((_DWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_1E6555DC8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_QWORD *)this + 6) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 21) = a2;
  *((_BYTE *)this + 144) = 0;
  v3 = (OZInterpolators *)operator new();
  OZInterpolators::OZInterpolators(v3);
  *((_BYTE *)this + 145) = 1;
  *((_BYTE *)this + 112) = 1;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 15) = 0;
  *(_OWORD *)((char *)this + 40) = *((_OWORD *)this + 1);
  *(_OWORD *)((char *)this + 72) = *(_OWORD *)((char *)this + 88);
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 19) = v3;
  *((_QWORD *)this + 20) = 0;
}

void sub_1B2C43B58(_Unwind_Exception *a1)
{
  _QWORD *v1;
  PCSpinLock *v2;
  uint64_t v3;
  void **v4;
  uint64_t v5;
  void *v7;
  void *v8;

  v5 = v3;
  MEMORY[0x1B5E29170](v5, 0x20C40960023A9);
  v7 = (void *)v1[11];
  if (v7)
  {
    v1[12] = v7;
    operator delete(v7);
  }
  v8 = *v4;
  if (*v4)
  {
    v1[3] = v8;
    operator delete(v8);
  }
  PCSpinLock::~PCSpinLock(v2);
  _Unwind_Resume(a1);
}

void OZSpline::OZSpline(OZSpline *this, const OZSpline *a2, OZSplineState *a3)
{
  void **v5;
  uint64_t v6;
  os_unfair_lock_s *v7;
  OZInterpolators *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  os_unfair_lock_s *v27;

  *(_QWORD *)this = &off_1E6555DC8;
  *((_DWORD *)this + 2) = 0;
  *((_OWORD *)this + 1) = 0u;
  v5 = (void **)((char *)this + 16);
  *((_OWORD *)this + 2) = 0u;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 13) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = a3;
  v6 = *((_QWORD *)a2 + 20);
  if (!v6 || (v7 = *(os_unfair_lock_s **)(v6 + 48)) == 0)
    v7 = (os_unfair_lock_s *)((char *)a2 + 8);
  PCSpinLock::lock(v7);
  *((_BYTE *)this + 144) = *((_BYTE *)a2 + 144);
  if (*((_QWORD *)a2 + 19))
  {
    v8 = (OZInterpolators *)operator new();
    OZInterpolators::OZInterpolators(v8, *((const OZInterpolators **)a2 + 19));
  }
  else
  {
    v8 = 0;
  }
  *((_QWORD *)this + 19) = v8;
  *((_BYTE *)this + 145) = 1;
  v9 = *((_QWORD *)a2 + 2);
  v10 = *((_QWORD *)a2 + 3);
  if (v9 != v10)
  {
    v11 = (_QWORD *)*((_QWORD *)a2 + 5);
    std::vector<void *>::reserve(v5, (v10 - v9) >> 3);
    for (; v11 != *((_QWORD **)a2 + 6); ++v11)
    {
      v12 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v11 + 216))(*v11);
      v13 = v12;
      v15 = (uint64_t *)*((_QWORD *)this + 3);
      v14 = *((_QWORD *)this + 4);
      if ((unint64_t)v15 >= v14)
      {
        v17 = ((char *)v15 - (_BYTE *)*v5) >> 3;
        if ((unint64_t)(v17 + 1) >> 61)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v18 = v14 - (_QWORD)*v5;
        v19 = v18 >> 2;
        if (v18 >> 2 <= (unint64_t)(v17 + 1))
          v19 = v17 + 1;
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
          v20 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v20 = v19;
        if (v20)
          v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 32, v20);
        else
          v21 = 0;
        v22 = (uint64_t *)&v21[8 * v17];
        *v22 = v13;
        v16 = v22 + 1;
        v24 = (char *)*((_QWORD *)this + 2);
        v23 = (char *)*((_QWORD *)this + 3);
        if (v23 != v24)
        {
          do
          {
            v25 = *((_QWORD *)v23 - 1);
            v23 -= 8;
            *--v22 = v25;
          }
          while (v23 != v24);
          v23 = (char *)*v5;
        }
        *((_QWORD *)this + 2) = v22;
        *((_QWORD *)this + 3) = v16;
        *((_QWORD *)this + 4) = &v21[8 * v20];
        if (v23)
          operator delete(v23);
      }
      else
      {
        *v15 = v12;
        v16 = v15 + 1;
      }
      *((_QWORD *)this + 3) = v16;
    }
  }
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)a2 + 120);
  *((_QWORD *)this + 17) = *((_QWORD *)a2 + 17);
  *(_OWORD *)((char *)this + 40) = *((_OWORD *)this + 1);
  *((_BYTE *)this + 112) = *((_BYTE *)a2 + 112);
  *(_OWORD *)((char *)this + 72) = *(_OWORD *)((char *)this + 88);
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  OZSpline::refreshValidVerticesList(this);
  v26 = *((_QWORD *)a2 + 20);
  if (!v26 || (v27 = *(os_unfair_lock_s **)(v26 + 48)) == 0)
    v27 = (os_unfair_lock_s *)((char *)a2 + 8);
  PCSpinLock::unlock(v27);
}

void sub_1B2C43DE4(_Unwind_Exception *a1)
{
  PCSpinLock *v1;
  _QWORD *v2;
  void **v3;
  void *v5;
  void *v6;

  v5 = (void *)v2[11];
  if (v5)
  {
    v2[12] = v5;
    operator delete(v5);
  }
  v6 = *v3;
  if (*v3)
  {
    v2[3] = v6;
    operator delete(v6);
  }
  PCSpinLock::~PCSpinLock(v1);
  _Unwind_Resume(a1);
}

void OZSpline::preSplineAccess(OZSpline *this, int a2)
{
  uint64_t v2;
  os_unfair_lock_s *v3;

  if (a2)
  {
    v2 = *((_QWORD *)this + 20);
    if (!v2 || (v3 = *(os_unfair_lock_s **)(v2 + 48)) == 0)
      v3 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::lock(v3);
  }
}

void OZSpline::refreshValidVerticesList(OZSpline *this)
{
  uint64_t v2;
  char **v3;
  _QWORD *v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;

  v2 = *((_QWORD *)this + 20);
  if ((!v2 || !*(_BYTE *)(v2 + 56)) && *((_BYTE *)this + 112))
  {
    v3 = (char **)((char *)this + 88);
    *((_QWORD *)this + 12) = *((_QWORD *)this + 11);
    std::vector<void *>::reserve((void **)this + 11, (uint64_t)(*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 3);
    v4 = (_QWORD *)*((_QWORD *)this + 5);
    if (*((_QWORD *)this + 6) > (unint64_t)v4)
    {
      v5 = MEMORY[0x1E0CA2E68];
      do
      {
        if ((*(unsigned int (**)(_QWORD, uint64_t))(*(_QWORD *)*v4 + 136))(*v4, v5))
        {
          v7 = (_QWORD *)*((_QWORD *)this + 12);
          v6 = *((_QWORD *)this + 13);
          if ((unint64_t)v7 >= v6)
          {
            v9 = ((char *)v7 - *v3) >> 3;
            if ((unint64_t)(v9 + 1) >> 61)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v10 = v6 - (_QWORD)*v3;
            v11 = v10 >> 2;
            if (v10 >> 2 <= (unint64_t)(v9 + 1))
              v11 = v9 + 1;
            if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
              v12 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v12 = v11;
            if (v12)
              v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 104, v12);
            else
              v13 = 0;
            v14 = &v13[8 * v9];
            *(_QWORD *)v14 = *v4;
            v8 = v14 + 8;
            v16 = (char *)*((_QWORD *)this + 11);
            v15 = (char *)*((_QWORD *)this + 12);
            if (v15 != v16)
            {
              do
              {
                v17 = *((_QWORD *)v15 - 1);
                v15 -= 8;
                *((_QWORD *)v14 - 1) = v17;
                v14 -= 8;
              }
              while (v15 != v16);
              v15 = *v3;
            }
            *((_QWORD *)this + 11) = v14;
            *((_QWORD *)this + 12) = v8;
            *((_QWORD *)this + 13) = &v13[8 * v12];
            if (v15)
              operator delete(v15);
          }
          else
          {
            *v7 = *v4;
            v8 = v7 + 1;
          }
          *((_QWORD *)this + 12) = v8;
        }
        ++v4;
      }
      while ((unint64_t)v4 < *((_QWORD *)this + 6));
    }
    v18 = (uint64_t *)*((_QWORD *)this + 11);
    v19 = (uint64_t *)*((_QWORD *)this + 12);
    if (v18 == v19)
    {
      v20 = 0;
      *((_QWORD *)this + 7) = 0;
    }
    else
    {
      *((_QWORD *)this + 7) = *(v19 - 1);
      v20 = *v18;
    }
    *((_QWORD *)this + 8) = v20;
    *((_QWORD *)this + 9) = v18;
    *((_QWORD *)this + 10) = v19;
  }
}

void OZSpline::postSplineAccess(OZSpline *this, int a2)
{
  uint64_t v2;
  os_unfair_lock_s *v3;

  if (a2)
  {
    v2 = *((_QWORD *)this + 20);
    if (!v2 || (v3 = *(os_unfair_lock_s **)(v2 + 48)) == 0)
      v3 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::unlock(v3);
  }
}

void OZSpline::~OZSpline(OZSpline *this)
{
  uint64_t v2;
  os_unfair_lock_s *v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  OZInterpolators *v7;
  uint64_t v8;
  os_unfair_lock_s *v9;
  void *v10;
  void *v11;

  *(_QWORD *)this = &off_1E6555DC8;
  v2 = *((_QWORD *)this + 20);
  if (!v2 || (v3 = *(os_unfair_lock_s **)(v2 + 48)) == 0)
    v3 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v3);
  v5 = *((_QWORD *)this + 2);
  for (i = *((_QWORD *)this + 3); v5 != i; *((_QWORD *)this + 3) = i)
  {
    v6 = *(_QWORD *)(i - 8);
    if (v6)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      i = *((_QWORD *)this + 3);
    }
    *(_QWORD *)(i - 8) = 0;
    v5 = *((_QWORD *)this + 2);
    i = *((_QWORD *)this + 3) - 8;
  }
  v7 = (OZInterpolators *)*((_QWORD *)this + 19);
  if (v7)
  {
    OZInterpolators::~OZInterpolators(v7);
    MEMORY[0x1B5E29170]();
  }
  *((_QWORD *)this + 19) = 0;
  v8 = *((_QWORD *)this + 20);
  if (!v8 || (v9 = *(os_unfair_lock_s **)(v8 + 48)) == 0)
    v9 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v9);
  v10 = (void *)*((_QWORD *)this + 11);
  if (v10)
  {
    *((_QWORD *)this + 12) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 2);
  if (v11)
  {
    *((_QWORD *)this + 3) = v11;
    operator delete(v11);
  }
  PCSpinLock::~PCSpinLock((PCSpinLock *)this + 2);
}

{
  OZSpline::~OZSpline(this);
  JUMPOUT(0x1B5E29170);
}

void OZSpline::copy(OZSpline *this, OZSpline *a2, void *a3, void *a4)
{
  void **VertexIter;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  char **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  char *v40;
  uint64_t *v41;
  char *v42;
  char *v43;
  char *v44;
  uint64_t v45;
  OZInterpolators *v46;
  OZInterpolators *v47;
  uint64_t v48;

  *((_BYTE *)this + 144) = *((_BYTE *)a2 + 144);
  *((_BYTE *)this + 145) = 1;
  VertexIter = OZSpline::getVertexIter(a2, a3);
  v9 = OZSpline::getVertexIter(a2, a4);
  v11 = *((_QWORD *)this + 2);
  v10 = *((_QWORD *)this + 3);
  v12 = (char **)((char *)this + 16);
  while (v11 != v10)
  {
    v13 = *(_QWORD *)(v10 - 8);
    if (v13)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
      v10 = *((_QWORD *)this + 3);
    }
    *(_QWORD *)(v10 - 8) = 0;
    v11 = *((_QWORD *)this + 2);
    v10 = *((_QWORD *)this + 3) - 8;
    *((_QWORD *)this + 3) = v10;
  }
  v14 = *((_QWORD *)a2 + 2);
  v15 = *((_QWORD *)a2 + 3);
  if (v14 != v15 && a3 != 0 && a4 != 0)
  {
    std::vector<void *>::reserve((void **)this + 2, (v15 - v14) >> 3);
    for (; VertexIter != v9; ++VertexIter)
    {
      v18 = (*(uint64_t (**)(void *))(*(_QWORD *)*VertexIter + 216))(*VertexIter);
      v19 = v18;
      v21 = (uint64_t *)*((_QWORD *)this + 3);
      v20 = *((_QWORD *)this + 4);
      if ((unint64_t)v21 >= v20)
      {
        v23 = ((char *)v21 - *v12) >> 3;
        if ((unint64_t)(v23 + 1) >> 61)
          goto LABEL_51;
        v24 = v20 - (_QWORD)*v12;
        v25 = v24 >> 2;
        if (v24 >> 2 <= (unint64_t)(v23 + 1))
          v25 = v23 + 1;
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8)
          v26 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v26 = v25;
        if (v26)
          v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 32, v26);
        else
          v27 = 0;
        v28 = (uint64_t *)&v27[8 * v23];
        *v28 = v19;
        v22 = v28 + 1;
        v30 = (char *)*((_QWORD *)this + 2);
        v29 = (char *)*((_QWORD *)this + 3);
        if (v29 != v30)
        {
          do
          {
            v31 = *((_QWORD *)v29 - 1);
            v29 -= 8;
            *--v28 = v31;
          }
          while (v29 != v30);
          v29 = *v12;
        }
        *((_QWORD *)this + 2) = v28;
        *((_QWORD *)this + 3) = v22;
        *((_QWORD *)this + 4) = &v27[8 * v26];
        if (v29)
          operator delete(v29);
      }
      else
      {
        *v21 = v18;
        v22 = v21 + 1;
      }
      *((_QWORD *)this + 3) = v22;
    }
    v32 = (*(uint64_t (**)(void *))(*(_QWORD *)*v9 + 216))(*v9);
    v33 = *((_QWORD *)this + 4);
    v34 = (uint64_t *)*((_QWORD *)this + 3);
    if ((unint64_t)v34 >= v33)
    {
      v36 = ((char *)v34 - *v12) >> 3;
      if ((unint64_t)(v36 + 1) >> 61)
LABEL_51:
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v37 = v33 - (_QWORD)*v12;
      v38 = v37 >> 2;
      if (v37 >> 2 <= (unint64_t)(v36 + 1))
        v38 = v36 + 1;
      if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8)
        v39 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v39 = v38;
      if (v39)
        v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 32, v39);
      else
        v40 = 0;
      v41 = (uint64_t *)&v40[8 * v36];
      v42 = &v40[8 * v39];
      *v41 = v32;
      v35 = v41 + 1;
      v44 = (char *)*((_QWORD *)this + 2);
      v43 = (char *)*((_QWORD *)this + 3);
      if (v43 != v44)
      {
        do
        {
          v45 = *((_QWORD *)v43 - 1);
          v43 -= 8;
          *--v41 = v45;
        }
        while (v43 != v44);
        v43 = *v12;
      }
      *((_QWORD *)this + 2) = v41;
      *((_QWORD *)this + 3) = v35;
      *((_QWORD *)this + 4) = v42;
      if (v43)
        operator delete(v43);
    }
    else
    {
      *v34 = v32;
      v35 = v34 + 1;
    }
    *((_QWORD *)this + 3) = v35;
  }
  v46 = (OZInterpolators *)*((_QWORD *)this + 19);
  if (v46)
  {
    OZInterpolators::~OZInterpolators(v46);
    MEMORY[0x1B5E29170]();
  }
  *((_QWORD *)this + 19) = 0;
  v47 = (OZInterpolators *)operator new();
  OZInterpolators::OZInterpolators(v47, *((const OZInterpolators **)a2 + 19));
  *((_QWORD *)this + 19) = v47;
  *(_OWORD *)((char *)this + 40) = *((_OWORD *)this + 1);
  *((_BYTE *)this + 112) = *((_BYTE *)a2 + 112);
  v48 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 12) = v48;
  *((_QWORD *)this + 9) = v48;
  *((_QWORD *)this + 10) = v48;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  OZSpline::refreshValidVerticesList(this);
}

void sub_1B2C44410(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x20C40960023A9);
  _Unwind_Resume(a1);
}

void **OZSpline::getVertexIter(OZSpline *this, void *a2)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  void **v8;
  void **v9;

  v2 = (void **)*((_QWORD *)this + 5);
  v3 = *((_QWORD *)this + 15);
  v4 = *((_QWORD *)this + 2);
  v5 = *((_QWORD *)this + 3) - v4;
  if (v3 < (unint64_t)(v5 >> 3) && *(void **)(v4 + 8 * v3) == a2)
  {
    v2 += v3;
  }
  else
  {
    v6 = v3 - 1;
    if (v3 >= 1 && *(void **)(v4 + 8 * v6) == a2)
    {
      v2 += v6;
      *((_QWORD *)this + 15) = v6;
    }
    else
    {
      v7 = v3 + 1;
      if (v7 < v5 >> 3 && *(void **)(v4 + 8 * v7) == a2)
      {
        v2 += v7;
        *((_QWORD *)this + 15) = v7;
      }
      else
      {
        v8 = (void **)*((_QWORD *)this + 6);
        v9 = (void **)*((_QWORD *)this + 5);
        if (v8 != v2)
        {
          while (*v9 != a2)
          {
            if (++v9 == v8)
            {
              v9 = (void **)*((_QWORD *)this + 6);
              break;
            }
          }
        }
        *((_QWORD *)this + 15) = v9 - v2;
        if (v9 != v8)
          return v9;
      }
    }
  }
  return v2;
}

void OZSpline::operator=(OZSpline *a1, os_unfair_lock_s *a2)
{
  uint64_t v4;
  os_unfair_lock_s *v5;
  void **v6;
  void **v7;
  void *v8;
  void *v9;
  OZSpline *v10;
  OZSpline *v11;
  uint64_t v12;
  os_unfair_lock_s *v13;

  v4 = *(_QWORD *)&a2[40]._os_unfair_lock_opaque;
  if (!v4 || (v5 = *(os_unfair_lock_s **)(v4 + 48)) == 0)
    v5 = a2 + 2;
  PCSpinLock::lock(v5);
  v6 = *(void ***)&a2[4]._os_unfair_lock_opaque;
  v7 = *(void ***)&a2[6]._os_unfair_lock_opaque;
  if (v6 == v7)
  {
    v10 = a1;
    v11 = (OZSpline *)a2;
    v8 = 0;
    v9 = 0;
  }
  else
  {
    v8 = *v6;
    v9 = *(v7 - 1);
    v10 = a1;
    v11 = (OZSpline *)a2;
  }
  OZSpline::copy(v10, v11, v8, v9);
  v12 = *(_QWORD *)&a2[40]._os_unfair_lock_opaque;
  if (!v12 || (v13 = *(os_unfair_lock_s **)(v12 + 48)) == 0)
    v13 = a2 + 2;
  PCSpinLock::unlock(v13);
}

BOOL OZSpline::operator==(uint64_t a1, uint64_t a2)
{
  const void *v4;
  uint64_t v5;
  size_t v6;
  const void *v7;
  uint64_t v8;

  v5 = a1 + 16;
  v4 = *(const void **)(a1 + 16);
  v6 = *(_QWORD *)(v5 + 8) - (_QWORD)v4;
  v8 = a2 + 16;
  v7 = *(const void **)(a2 + 16);
  return v6 == *(_QWORD *)(v8 + 8) - (_QWORD)v7
      && !memcmp(v4, v7, v6)
      && *(unsigned __int8 *)(a1 + 144) == *(unsigned __int8 *)(a2 + 144)
      && (OZInterpolators::operator==(*(unint64_t **)(a1 + 152), *(unint64_t **)(a2 + 152)) & 1) != 0;
}

void OZSpline::setInterpolation(OZSpline *this, uint64_t a2)
{
  uint64_t v4;
  os_unfair_lock_s *v5;
  _QWORD *i;
  uint64_t Interpolator;
  uint64_t v8;
  os_unfair_lock_s *v9;

  if ((_DWORD)a2 != 100)
  {
    v4 = *((_QWORD *)this + 20);
    if (!v4 || (v5 = *(os_unfair_lock_s **)(v4 + 48)) == 0)
      v5 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::lock(v5);
    for (i = (_QWORD *)*((_QWORD *)this + 5); i != *((_QWORD **)this + 6); ++i)
    {
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(*(_QWORD *)*i + 184))(*i, 2)
        || **((_BYTE **)this + 21))
      {
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*i + 200))(*i, a2);
      }
    }
    Interpolator = OZInterpolators::getInterpolator(*((OZInterpolators **)this + 19), a2);
    (*(void (**)(uint64_t, OZSpline *, _QWORD))(*(_QWORD *)Interpolator + 16))(Interpolator, this, MEMORY[0x1E0CA2E68]);
    v8 = *((_QWORD *)this + 20);
    if (!v8 || (v9 = *(os_unfair_lock_s **)(v8 + 48)) == 0)
      v9 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::unlock(v9);
  }
}

uint64_t OZSpline::getInterpolation(OZSpline *this, unsigned int *a2, BOOL *a3, BOOL *a4)
{
  uint64_t *v8;
  _QWORD *v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  int v13;
  uint64_t Interpolator;

  if (*((_QWORD *)this + 2) == *((_QWORD *)this + 3))
  {
    v13 = *(_DWORD *)(*((_QWORD *)this + 21) + 32);
  }
  else
  {
    v8 = (uint64_t *)*((_QWORD *)this + 5);
    v10 = *v8;
    v9 = v8 + 1;
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 208))(v10);
    *a2 = v11;
    if (v9 == *((_QWORD **)this + 6))
    {
      v13 = v11;
      goto LABEL_10;
    }
    while (1)
    {
      v12 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v9 + 208))(*v9);
      if (v12 != *a2)
        break;
      v13 = v12;
      if (++v9 == *((_QWORD **)this + 6))
        goto LABEL_10;
    }
    v13 = 100;
  }
  *a2 = v13;
LABEL_10:
  if (a3)
    *a3 = OZSpline::interpolatorUsesTangents((OZInterpolators **)this, v13, 0);
  if (a4)
  {
    Interpolator = OZInterpolators::getInterpolator(*((OZInterpolators **)this + 19), *a2);
    *a4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)Interpolator + 64))(Interpolator) ^ 1;
  }
  return 1;
}

uint64_t OZSpline::interpolatorUsesTangents(OZInterpolators **this, int a2, void *a3)
{
  uint64_t Interpolator;
  OZInterpolators *v6;
  uint64_t v7;

  Interpolator = OZInterpolators::getInterpolator(this[19], a2);
  v6 = this[20];
  if (v6)
  {
    v7 = *((_QWORD *)v6 + 5);
    if (v7)
    {
      if ((*(unsigned int (**)(uint64_t, OZInterpolators **, void *))(*(_QWORD *)v7 + 112))(v7, this, a3))
        Interpolator = v7;
    }
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)Interpolator + 56))(Interpolator);
}

void OZSpline::setExtrapolation(OZSpline *this, int a2, int a3)
{
  uint64_t v6;
  os_unfair_lock_s *v7;
  uint64_t v8;
  uint64_t v9;
  os_unfair_lock_s *v10;

  v6 = *((_QWORD *)this + 20);
  if (!v6 || (v7 = *(os_unfair_lock_s **)(v6 + 48)) == 0)
    v7 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v7);
  v8 = 36;
  if (a3)
    v8 = 40;
  v9 = *((_QWORD *)this + 20);
  *(_DWORD *)(*((_QWORD *)this + 21) + v8) = a2;
  if (!v9 || (v10 = *(os_unfair_lock_s **)(v9 + 48)) == 0)
    v10 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v10);
}

uint64_t OZSpline::getExtrapolation(OZSpline *this, int a2)
{
  uint64_t v2;

  v2 = 40;
  if (!a2)
    v2 = 36;
  return *(unsigned int *)(*((_QWORD *)this + 21) + v2);
}

void OZSpline::getRangeU(OZSpline *this@<X0>, const CMTime *a2@<X1>, CMTime *a3@<X8>)
{
  CMTime *v6;
  uint64_t v7;
  os_unfair_lock_s *v8;
  uint64_t Interpolator;
  uint64_t v10;
  os_unfair_lock_s *v11;
  CMTime v12;
  CMTime v13;
  __int128 v14;
  CMTimeEpoch v15;
  unsigned int v16;
  CMTime time2;
  CMTime time1;

  v6 = (CMTime *)MEMORY[0x1E0CA2E68];
  *(_OWORD *)&a3->value = *MEMORY[0x1E0CA2E68];
  a3->epoch = v6->epoch;
  v16 = 0;
  v7 = *((_QWORD *)this + 20);
  if (!v7 || (v8 = *(os_unfair_lock_s **)(v7 + 48)) == 0)
    v8 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v8);
  (*(void (**)(OZSpline *, unsigned int *, _QWORD, _QWORD))(*(_QWORD *)this + 16))(this, &v16, 0, 0);
  OZSpline::getMaxValueU(this, a2, 0, (uint64_t)&v13);
  OZSpline::getMinValueU(this, a2, 0, (uint64_t)&v12);
  time1 = v13;
  time2 = v12;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v14);
  *(_OWORD *)&a3->value = v14;
  a3->epoch = v15;
  Interpolator = OZInterpolators::getInterpolator(*((OZInterpolators **)this + 19), v16);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)Interpolator + 64))(Interpolator))
  {
    if (*((_BYTE *)this + 144))
    {
      time1 = *a3;
      time2 = *v6;
      if (CMTimeCompare(&time1, &time2))
      {
        OZSpline::getStep(this, &v13);
        time1 = *a3;
        time2 = v13;
        PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v14);
        *(_OWORD *)&a3->value = v14;
        a3->epoch = v15;
      }
    }
  }
  v10 = *((_QWORD *)this + 20);
  if (!v10 || (v11 = *(os_unfair_lock_s **)(v10 + 48)) == 0)
    v11 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v11);
}

__n128 OZSpline::getMaxValueU@<Q0>(OZSpline *this@<X0>, const CMTime *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  os_unfair_lock_s *v9;
  uint64_t v10;
  os_unfair_lock_s *v11;
  void *v12;
  uint64_t v13;
  OZInterpolators *v14;
  int v15;
  uint64_t Interpolator;
  __n128 result;
  uint64_t v18;
  os_unfair_lock_s *v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  void *v23;

  v23 = 0;
  if (a3)
  {
    v8 = *((_QWORD *)this + 20);
    if (!v8 || (v9 = *(os_unfair_lock_s **)(v8 + 48)) == 0)
      v9 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::lock(v9);
    if ((OZSpline::getLastValidVertex(this, &v23, a2) & 1) == 0)
    {
      v10 = *((_QWORD *)this + 20);
      if (!v10 || (v11 = *(os_unfair_lock_s **)(v10 + 48)) == 0)
        v11 = (os_unfair_lock_s *)((char *)this + 8);
      PCSpinLock::unlock(v11);
      goto LABEL_16;
    }
  }
  else if (!OZSpline::getLastValidVertex(this, &v23, a2))
  {
LABEL_16:
    v20 = MEMORY[0x1E0CA2E68];
    result = *(__n128 *)MEMORY[0x1E0CA2E68];
    *(_OWORD *)a4 = *MEMORY[0x1E0CA2E68];
    *(_QWORD *)(a4 + 16) = *(_QWORD *)(v20 + 16);
    return result;
  }
  v12 = v23;
  v13 = *((_QWORD *)v23 + 4);
  *(_OWORD *)a4 = *((_OWORD *)v23 + 1);
  *(_QWORD *)(a4 + 16) = v13;
  v14 = (OZInterpolators *)*((_QWORD *)this + 19);
  v15 = (*(uint64_t (**)(void *))(*(_QWORD *)v12 + 208))(v12);
  Interpolator = OZInterpolators::getInterpolator(v14, v15);
  (*(void (**)(__int128 *__return_ptr, uint64_t, OZSpline *, const CMTime *, uint64_t))(*(_QWORD *)Interpolator
                                                                                               + 72))(&v21, Interpolator, this, a2, a4);
  result.n128_u64[0] = v21;
  *(_OWORD *)a4 = v21;
  *(_QWORD *)(a4 + 16) = v22;
  if (a3)
  {
    v18 = *((_QWORD *)this + 20);
    if (!v18 || (v19 = *(os_unfair_lock_s **)(v18 + 48)) == 0)
      v19 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::unlock(v19);
  }
  return result;
}

void OZSpline::getMinValueU(OZSpline *this@<X0>, const CMTime *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  os_unfair_lock_s *v10;
  void *v11;
  uint64_t v12;
  OZInterpolators *v13;
  int v14;
  uint64_t Interpolator;
  uint64_t v16;
  os_unfair_lock_s *v17;
  __int128 v18;
  uint64_t v19;
  void *v20;

  v20 = 0;
  v8 = MEMORY[0x1E0CA2E68];
  *(_OWORD *)a4 = *MEMORY[0x1E0CA2E68];
  *(_QWORD *)(a4 + 16) = *(_QWORD *)(v8 + 16);
  if (a3)
  {
    v9 = *((_QWORD *)this + 20);
    if (!v9 || (v10 = *(os_unfair_lock_s **)(v9 + 48)) == 0)
      v10 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::lock(v10);
  }
  if (OZSpline::getFirstValidVertex(this, &v20, a2))
  {
    v11 = v20;
    v12 = *((_QWORD *)v20 + 4);
    *(_OWORD *)a4 = *((_OWORD *)v20 + 1);
    *(_QWORD *)(a4 + 16) = v12;
    v13 = (OZInterpolators *)*((_QWORD *)this + 19);
    v14 = (*(uint64_t (**)(void *))(*(_QWORD *)v11 + 208))(v11);
    Interpolator = OZInterpolators::getInterpolator(v13, v14);
    (*(void (**)(__int128 *__return_ptr, uint64_t, OZSpline *, const CMTime *, uint64_t))(*(_QWORD *)Interpolator
                                                                                                 + 80))(&v18, Interpolator, this, a2, a4);
    *(_OWORD *)a4 = v18;
    *(_QWORD *)(a4 + 16) = v19;
  }
  if (a3)
  {
    v16 = *((_QWORD *)this + 20);
    if (!v16 || (v17 = *(os_unfair_lock_s **)(v16 + 48)) == 0)
      v17 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::unlock(v17);
  }
}

CMTime *OZSpline::getStep@<X0>(OZSpline *this@<X0>, CMTime *a2@<X8>)
{
  _BYTE *v2;
  int32_t v3;
  OZSplineNode *v4;

  v2 = (_BYTE *)*((_QWORD *)this + 21);
  if (*v2)
  {
    v3 = 1;
    return CMTimeMake(a2, 1, v3);
  }
  v4 = (OZSplineNode *)*((_QWORD *)this + 20);
  if (!v4 || !v2[4])
  {
    v3 = 30;
    return CMTimeMake(a2, 1, v3);
  }
  return OZSplineNode::getFrameDuration(v4, a2);
}

BOOL OZSpline::getFirstValidVertex(OZSpline *this, void **a2, const CMTime *a3)
{
  void *v6;
  _BOOL8 result;
  _QWORD *v8;

  if (a2)
    *a2 = 0;
  if (*((_BYTE *)this + 112))
  {
    v6 = (void *)*((_QWORD *)this + 8);
    result = v6 != 0;
    if (a2)
LABEL_5:
      *a2 = v6;
  }
  else
  {
    v8 = (_QWORD *)*((_QWORD *)this + 5);
    if (*((_QWORD **)this + 6) == v8)
    {
      return 0;
    }
    else
    {
      while (!(*(unsigned int (**)(_QWORD, const CMTime *))(*(_QWORD *)*v8 + 136))(*v8, a3))
      {
        if (++v8 == *((_QWORD **)this + 6))
          return 0;
      }
      if (a2)
      {
        v6 = (void *)*v8;
        result = 1;
        goto LABEL_5;
      }
      return 1;
    }
  }
  return result;
}

uint64_t OZSpline::getLastValidVertex(OZSpline *this, void **a2, const CMTime *a3)
{
  void *v6;
  uint64_t result;
  uint64_t v8;
  int32_t v9;
  CMTime v10;
  CMTime v11;
  CMTime v12;
  CMTime v13;
  CMTime v14;

  if (a2)
    *a2 = 0;
  if (*((_BYTE *)this + 112))
  {
    v6 = (void *)*((_QWORD *)this + 7);
    if (v6)
    {
      if (a2)
        *a2 = v6;
      return 1;
    }
    if (a2)
    {
      result = 0;
      *a2 = 0;
      return result;
    }
    return 0;
  }
  v8 = *((_QWORD *)this + 3);
  if (*((_QWORD *)this + 2) == v8)
    return 0;
  memset(&v12, 0, sizeof(v12));
  v11 = *(CMTime *)(*(_QWORD *)(v8 - 8) + 16);
  if (**((_BYTE **)this + 21))
    v9 = 1;
  else
    v9 = 100;
  CMTimeMake(&v10, 1, v9);
  v14 = v11;
  v13 = v10;
  PC_CMTimeSaferAdd(&v14, &v13, (uint64_t)&v12);
  return OZSpline::getPreviousValidVertex(this, &v12, a2, a3, 0);
}

double OZSpline::getMaxValueV(OZSpline *this, const CMTime *a2, CMTime *a3)
{
  double v6;
  void *v7;
  __int128 v8;
  const CMTime *v9;
  double v10;
  BOOL v11;
  void *v12;
  __int128 v14;
  void *v16;

  v16 = 0;
  if (!OZSpline::getFirstValidVertex(this, &v16, MEMORY[0x1E0CA2E68]))
    return -1.79769313e308;
  v6 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v16 + 24))(v16, a2);
  if (v6 <= -1.79769313e308)
  {
    v7 = v16;
    v6 = -1.79769313e308;
  }
  else
  {
    v7 = v16;
    if (a3)
    {
      v8 = *((_OWORD *)v16 + 1);
      a3->epoch = *((_QWORD *)v16 + 4);
      *(_OWORD *)&a3->value = v8;
    }
  }
  if (OZSpline::getNextValidVertex((void ***)this, v7, &v16, MEMORY[0x1E0CA2E68]))
  {
    v9 = (const CMTime *)MEMORY[0x1E0CA2E68];
    do
    {
      v10 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v16 + 24))(v16, a2);
      v11 = v10 <= v6;
      if (v10 > v6)
        v6 = v10;
      v12 = v16;
      if (!v11 && a3 != 0)
      {
        v14 = *((_OWORD *)v16 + 1);
        a3->epoch = *((_QWORD *)v16 + 4);
        *(_OWORD *)&a3->value = v14;
        v6 = v10;
      }
    }
    while ((OZSpline::getNextValidVertex((void ***)this, v12, &v16, v9) & 1) != 0);
  }
  return v6;
}

uint64_t OZSpline::getNextValidVertex(void ***this, void *a2, void **a3, const CMTime *a4)
{
  void **ValidVertexIter;
  void **v7;
  void **v8;
  uint64_t result;
  void **VertexIter;

  if (*((_BYTE *)this + 112))
  {
    ValidVertexIter = OZSpline::getValidVertexIter((OZSpline *)this, a2);
    v7 = this[10];
    v8 = ValidVertexIter + 1;
    if (v7 == ValidVertexIter || v8 == v7)
    {
      result = 0;
      if (a3)
        *a3 = 0;
    }
    else
    {
      if (a3)
        *a3 = *v8;
      return 1;
    }
  }
  else
  {
    VertexIter = OZSpline::getVertexIter((OZSpline *)this, a2);
    return OZSpline::getNextValidVertex((OZSpline *)this, &VertexIter, a3, (uint64_t)a4);
  }
  return result;
}

double OZSpline::getMaxValueVWithTangents(OZSpline *this, const CMTime *a2, CMTime *a3)
{
  double v6;
  const CMTime *v7;
  double v8;
  double v9;
  double v10;
  double v11;
  CMTimeEpoch v12;
  double v13;
  CMTimeEpoch v14;
  double v15;
  double v16;
  double v17;
  CMTimeEpoch v18;
  double v19;
  BOOL v20;
  CMTimeEpoch v21;
  double v22;
  void *v24;
  double v25;
  double v26;

  v25 = 0.0;
  v26 = 0.0;
  v24 = 0;
  if (!OZSpline::getFirstValidVertex(this, &v24, MEMORY[0x1E0CA2E68]))
    return -1.79769313e308;
  v6 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v24 + 24))(v24, a2);
  v7 = (const CMTime *)MEMORY[0x1E0CA2E68];
  (*(void (**)(void *, _QWORD, double *, _QWORD))(*(_QWORD *)v24 + 56))(v24, 0, &v26, MEMORY[0x1E0CA2E68]);
  (*(void (**)(void *, _QWORD, double *, const CMTime *))(*(_QWORD *)v24 + 64))(v24, 0, &v25, v7);
  v8 = v26 * 3.0 * 4.0;
  v9 = v25 * 3.0 * 4.0;
  v25 = v9;
  v26 = v8;
  v10 = v6 + v8;
  v11 = -1.79769313e308;
  if (v6 + v8 > -1.79769313e308)
  {
    if (!a3)
    {
      v13 = v6 + v9;
      if (v13 <= v10)
        goto LABEL_11;
      goto LABEL_10;
    }
    v12 = *((_QWORD *)v24 + 4);
    *(_OWORD *)&a3->value = *((_OWORD *)v24 + 1);
    a3->epoch = v12;
    v11 = v6 + v8;
  }
  v13 = v6 + v9;
  v10 = v11;
  if (v13 <= v11)
    goto LABEL_11;
  if (a3)
  {
    v14 = *((_QWORD *)v24 + 4);
    *(_OWORD *)&a3->value = *((_OWORD *)v24 + 1);
    a3->epoch = v14;
  }
LABEL_10:
  v10 = v13;
LABEL_11:
  if (OZSpline::getNextValidVertex((void ***)this, v24, &v24, MEMORY[0x1E0CA2E68]))
  {
    while (1)
    {
      v15 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v24 + 24))(v24, a2);
      (*(void (**)(void *, _QWORD, double *, const CMTime *))(*(_QWORD *)v24 + 56))(v24, 0, &v26, v7);
      (*(void (**)(void *, _QWORD, double *, const CMTime *))(*(_QWORD *)v24 + 64))(v24, 0, &v25, v7);
      v16 = v25 * 3.0 * 4.0;
      v25 = v16;
      v26 = v26 * 3.0 * 4.0;
      v17 = v15 + v26;
      if (v15 + v26 <= v10)
        goto LABEL_15;
      if (a3)
        break;
      v22 = v15 + v16;
      if (v22 > v17)
        v10 = v22;
      else
        v10 = v15 + v26;
LABEL_23:
      if ((OZSpline::getNextValidVertex((void ***)this, v24, &v24, v7) & 1) == 0)
        return v10;
    }
    v18 = *((_QWORD *)v24 + 4);
    *(_OWORD *)&a3->value = *((_OWORD *)v24 + 1);
    a3->epoch = v18;
    v10 = v17;
LABEL_15:
    v19 = v15 + v16;
    if (v19 <= v10)
    {
      v20 = 1;
    }
    else
    {
      v10 = v19;
      v20 = a3 == 0;
    }
    if (!v20)
    {
      v21 = *((_QWORD *)v24 + 4);
      *(_OWORD *)&a3->value = *((_OWORD *)v24 + 1);
      a3->epoch = v21;
      v10 = v19;
    }
    goto LABEL_23;
  }
  return v10;
}

double OZSpline::getMinValueV(OZSpline *this, const CMTime *a2, CMTime *a3)
{
  double v6;
  void *v7;
  __int128 v8;
  const CMTime *v9;
  double v10;
  BOOL v11;
  void *v12;
  __int128 v14;
  void *v16;

  v16 = 0;
  if (!OZSpline::getFirstValidVertex(this, &v16, MEMORY[0x1E0CA2E68]))
    return 1.79769313e308;
  v6 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v16 + 24))(v16, a2);
  if (v6 >= 1.79769313e308)
  {
    v7 = v16;
    v6 = 1.79769313e308;
  }
  else
  {
    v7 = v16;
    if (a3)
    {
      v8 = *((_OWORD *)v16 + 1);
      a3->epoch = *((_QWORD *)v16 + 4);
      *(_OWORD *)&a3->value = v8;
    }
  }
  if (OZSpline::getNextValidVertex((void ***)this, v7, &v16, MEMORY[0x1E0CA2E68]))
  {
    v9 = (const CMTime *)MEMORY[0x1E0CA2E68];
    do
    {
      v10 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v16 + 24))(v16, a2);
      v11 = v10 < v6;
      if (v10 < v6)
        v6 = v10;
      v12 = v16;
      if (v11 && a3 != 0)
      {
        v14 = *((_OWORD *)v16 + 1);
        a3->epoch = *((_QWORD *)v16 + 4);
        *(_OWORD *)&a3->value = v14;
        v6 = v10;
      }
    }
    while ((OZSpline::getNextValidVertex((void ***)this, v12, &v16, v9) & 1) != 0);
  }
  return v6;
}

double OZSpline::getMinValueVWithTangents(OZSpline *this, const CMTime *a2, CMTime *a3)
{
  double v6;
  const CMTime *v7;
  double v8;
  double v9;
  double v10;
  double v11;
  CMTimeEpoch v12;
  double v13;
  CMTimeEpoch v14;
  double v15;
  double v16;
  double v17;
  CMTimeEpoch v18;
  double v19;
  BOOL v20;
  CMTimeEpoch v21;
  double v22;
  void *v24;
  double v25;
  double v26;

  v25 = 0.0;
  v26 = 0.0;
  v24 = 0;
  if (!OZSpline::getFirstValidVertex(this, &v24, MEMORY[0x1E0CA2E68]))
    return 1.79769313e308;
  v6 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v24 + 24))(v24, a2);
  v7 = (const CMTime *)MEMORY[0x1E0CA2E68];
  (*(void (**)(void *, _QWORD, double *, _QWORD))(*(_QWORD *)v24 + 56))(v24, 0, &v26, MEMORY[0x1E0CA2E68]);
  (*(void (**)(void *, _QWORD, double *, const CMTime *))(*(_QWORD *)v24 + 64))(v24, 0, &v25, v7);
  v8 = v26 * 3.0 * 4.0;
  v9 = v25 * 3.0 * 4.0;
  v25 = v9;
  v26 = v8;
  v10 = v6 + v8;
  v11 = 1.79769313e308;
  if (v6 + v8 < 1.79769313e308)
  {
    if (!a3)
    {
      v13 = v6 + v9;
      if (v13 >= v10)
        goto LABEL_11;
      goto LABEL_10;
    }
    v12 = *((_QWORD *)v24 + 4);
    *(_OWORD *)&a3->value = *((_OWORD *)v24 + 1);
    a3->epoch = v12;
    v11 = v6 + v8;
  }
  v13 = v6 + v9;
  v10 = v11;
  if (v13 >= v11)
    goto LABEL_11;
  if (a3)
  {
    v14 = *((_QWORD *)v24 + 4);
    *(_OWORD *)&a3->value = *((_OWORD *)v24 + 1);
    a3->epoch = v14;
  }
LABEL_10:
  v10 = v13;
LABEL_11:
  if (OZSpline::getNextValidVertex((void ***)this, v24, &v24, MEMORY[0x1E0CA2E68]))
  {
    while (1)
    {
      v15 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v24 + 24))(v24, a2);
      (*(void (**)(void *, _QWORD, double *, const CMTime *))(*(_QWORD *)v24 + 56))(v24, 0, &v26, v7);
      (*(void (**)(void *, _QWORD, double *, const CMTime *))(*(_QWORD *)v24 + 64))(v24, 0, &v25, v7);
      v16 = v25 * 3.0 * 4.0;
      v25 = v16;
      v26 = v26 * 3.0 * 4.0;
      v17 = v15 + v26;
      if (v15 + v26 >= v10)
        goto LABEL_15;
      if (a3)
        break;
      v22 = v15 + v16;
      if (v22 < v17)
        v10 = v22;
      else
        v10 = v15 + v26;
LABEL_23:
      if ((OZSpline::getNextValidVertex((void ***)this, v24, &v24, v7) & 1) == 0)
        return v10;
    }
    v18 = *((_QWORD *)v24 + 4);
    *(_OWORD *)&a3->value = *((_OWORD *)v24 + 1);
    a3->epoch = v18;
    v10 = v17;
LABEL_15:
    v19 = v15 + v16;
    if (v19 >= v10)
    {
      v20 = 1;
    }
    else
    {
      v10 = v19;
      v20 = a3 == 0;
    }
    if (!v20)
    {
      v21 = *((_QWORD *)v24 + 4);
      *(_OWORD *)&a3->value = *((_OWORD *)v24 + 1);
      a3->epoch = v21;
      v10 = v19;
    }
    goto LABEL_23;
  }
  return v10;
}

void OZSpline::offsetSpline(OZSpline *this, const CMTime *a2, double a3, double a4, double a5, int a6, int a7, const CMTime *a8)
{
  uint64_t v16;
  os_unfair_lock_s *v17;
  double v18;
  double v19;
  double v20;
  double v21;
  uint64_t *i;
  double v23;
  double v24;
  double v25;
  double v26;
  BOOL v28;
  double v29;
  double v30;
  uint64_t *v32;
  __n128 v33;
  uint64_t v34;
  int NextValidVertex;
  __n128 v36;
  double v37;
  __n128 v38;
  __n128 v39;
  uint64_t v40;
  os_unfair_lock_s *v41;
  void *v42;
  void *v43;

  v16 = *((_QWORD *)this + 20);
  if (!v16 || (v17 = *(os_unfair_lock_s **)(v16 + 48)) == 0)
    v17 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v17);
  v18 = a3
      - (*(double (**)(OZSpline *, const CMTime *, _QWORD, _QWORD))(*(_QWORD *)this + 240))(this, a2, MEMORY[0x1E0CA2E68], 0);
  if (a6)
  {
    v42 = 0;
    v43 = 0;
    v19 = v18;
    if (OZSpline::getPreviousValidVertex(this, a2, &v43, MEMORY[0x1E0CA2E68], 0))
    {
      v20 = v18 + (*(double (**)(void *, const CMTime *))(*(_QWORD *)v43 + 24))(v43, a8);
      v21 = a4 - v20;
      if (v20 <= a4)
        v21 = -0.0;
      if (v20 >= a5)
        v19 = v18 + v21;
      else
        v19 = v18 + a5 - v20;
    }
    NextValidVertex = OZSpline::getNextValidVertex(this, a2, &v42, MEMORY[0x1E0CA2E68], 0);
    v36.n128_f64[0] = v18;
    if (NextValidVertex)
    {
      v36.n128_f64[0] = v18
                      + (*(double (**)(void *, const CMTime *, double))(*(_QWORD *)v42 + 24))(v42, a8, v18);
      v37 = a4 - v36.n128_f64[0];
      if (v36.n128_f64[0] <= a4)
        v37 = -0.0;
      if (v36.n128_f64[0] >= a5)
      {
        v36.n128_f64[0] = v18 + v37;
        if (!a7)
        {
LABEL_45:
          if (v43)
          {
            v38.n128_f64[0] = v18
                            + (*(double (**)(void *, const CMTime *, __n128))(*(_QWORD *)v43 + 24))(v43, a8, v36);
            if (v38.n128_f64[0] > a4)
              v38.n128_f64[0] = a4;
            if (v38.n128_f64[0] < a5)
              v38.n128_f64[0] = a5;
            (*(void (**)(void *, const CMTime *, __n128))(*(_QWORD *)v43 + 32))(v43, a8, v38);
          }
          if (v42)
          {
            v39.n128_f64[0] = v18
                            + (*(double (**)(void *, const CMTime *, __n128))(*(_QWORD *)v42 + 24))(v42, a8, v36);
            if (v39.n128_f64[0] > a4)
              v39.n128_f64[0] = a4;
            if (v39.n128_f64[0] < a5)
              v39.n128_f64[0] = a5;
            (*(void (**)(void *, const CMTime *, __n128))(*(_QWORD *)v42 + 32))(v42, a8, v39);
          }
          goto LABEL_57;
        }
LABEL_41:
        if (fabs(v19) < fabs(v18))
          v18 = v19;
        if (fabs(v36.n128_f64[0]) < fabs(v18))
          v18 = v36.n128_f64[0];
        goto LABEL_45;
      }
      v36.n128_f64[0] = v18 + a5 - v36.n128_f64[0];
    }
    if (!a7)
      goto LABEL_45;
    goto LABEL_41;
  }
  if ((a7 & 1) != 0)
  {
    for (i = (uint64_t *)*((_QWORD *)this + 5); i != *((uint64_t **)this + 6); ++i)
    {
      v23 = (*(double (**)(uint64_t, const CMTime *))(*(_QWORD *)*i + 24))(*i, a8);
      v24 = v18 + v23;
      v25 = fabs(v18);
      v26 = vabdd_f64(a4, v23);
      if (v18 + v23 > a4 && v25 > v26)
        v18 = a4 - v23;
      v28 = v24 < a5;
      v29 = fabs(v18);
      v30 = vabdd_f64(v23, a5);
      if (v28 && v29 > v30)
        v18 = a5 - v23;
    }
  }
  else
  {
    i = (uint64_t *)*((_QWORD *)this + 6);
  }
  v32 = (uint64_t *)*((_QWORD *)this + 5);
  if (i != v32)
  {
    do
    {
      v33.n128_f64[0] = v18 + (*(double (**)(uint64_t, const CMTime *))(*(_QWORD *)*v32 + 24))(*v32, a8);
      if (v33.n128_f64[0] > a4)
        v33.n128_f64[0] = a4;
      if (v33.n128_f64[0] < a5)
        v33.n128_f64[0] = a5;
      v34 = *v32++;
      (*(void (**)(uint64_t, const CMTime *, __n128))(*(_QWORD *)v34 + 32))(v34, a8, v33);
    }
    while (v32 != *((uint64_t **)this + 6));
  }
LABEL_57:
  v40 = *((_QWORD *)this + 20);
  if (!v40 || (v41 = *(os_unfair_lock_s **)(v40 + 48)) == 0)
    v41 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v41);
}

uint64_t OZSpline::getPreviousValidVertex(OZSpline *this, const CMTime *a2, void **a3, const CMTime *a4, int a5)
{
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  char v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  void *v21;
  CMTimeEpoch v22;
  CMTimeEpoch v23;
  CMTimeEpoch v24;
  CMTime time2;
  CMTime time1;

  if (a3)
    *a3 = 0;
  v10 = *((_QWORD *)this + 3);
  if (*((_QWORD *)this + 2) == v10)
    return 0;
  v11 = (uint64_t *)*((_QWORD *)this + 5);
  if (*((uint64_t **)this + 6) != v11)
  {
    v12 = (uint64_t *)*((_QWORD *)this + 5);
    while (1)
    {
      if ((*(unsigned int (**)(uint64_t, const CMTime *))(*(_QWORD *)*v12 + 136))(*v12, a4))
      {
        v22 = *(_QWORD *)(*v12 + 32);
        *(_OWORD *)&time1.value = *(_OWORD *)(*v12 + 16);
        time1.epoch = v22;
        time2 = *a2;
        if (CMTimeCompare(&time1, &time2) < 0)
        {
          v11 = v12;
        }
        else
        {
          if (v12 == *((uint64_t **)this + 5))
          {
            result = 0;
LABEL_33:
            if (!a3)
              return result;
            v21 = 0;
            goto LABEL_30;
          }
          if (!a5)
            goto LABEL_27;
          v13 = v12 + 1;
          do
          {
            v14 = v13;
            v15 = *v13++;
            v16 = (*(uint64_t (**)(uint64_t, const CMTime *))(*(_QWORD *)v15 + 136))(v15, a4);
            v17 = (uint64_t *)*((_QWORD *)this + 6);
          }
          while ((v16 & 1) == 0 && v14 != v17);
          if (v14 == v17)
          {
LABEL_27:
            result = (*(uint64_t (**)(uint64_t, const CMTime *))(*(_QWORD *)*v11 + 136))(*v11, a4);
            if ((_DWORD)result)
            {
              if (!a3)
                return 1;
              goto LABEL_29;
            }
            goto LABEL_33;
          }
          v18 = *(v13 - 1);
          v12 = v13 - 1;
          v23 = *(_QWORD *)(v18 + 32);
          *(_OWORD *)&time1.value = *(_OWORD *)(v18 + 16);
          time1.epoch = v23;
          time2 = *a2;
          v11 = v12;
          if (!CMTimeCompare(&time1, &time2))
          {
            v11 = v12;
            if (a3)
              goto LABEL_29;
            return 1;
          }
        }
      }
      if (++v12 == *((uint64_t **)this + 6))
      {
        v10 = *((_QWORD *)this + 3);
        break;
      }
    }
  }
  v19 = *(_QWORD *)(v10 - 8);
  v24 = *(_QWORD *)(v19 + 32);
  *(_OWORD *)&time1.value = *(_OWORD *)(v19 + 16);
  time1.epoch = v24;
  time2 = *a2;
  if (CMTimeCompare(&time1, &time2) < 0
    && (*(unsigned int (**)(_QWORD, const CMTime *))(**(_QWORD **)(*((_QWORD *)this + 3) - 8) + 136))(*(_QWORD *)(*((_QWORD *)this + 3) - 8), a4))
  {
    if (!a3)
      return 1;
    v11 = (uint64_t *)(*((_QWORD *)this + 3) - 8);
  }
  else
  {
    result = (*(uint64_t (**)(uint64_t, const CMTime *))(*(_QWORD *)*v11 + 136))(*v11, a4);
    if (!a3 || !(_DWORD)result)
      return result;
  }
LABEL_29:
  v21 = (void *)*v11;
  result = 1;
LABEL_30:
  *a3 = v21;
  return result;
}

uint64_t OZSpline::getNextValidVertex(OZSpline *this, const CMTime *a2, void **a3, const CMTime *a4, int a5)
{
  _QWORD *v9;
  uint64_t v10;
  int v11;
  CMTime *v12;
  int v13;
  uint64_t v14;
  CMTimeEpoch v16;
  CMTimeEpoch v17;
  CMTime time2;
  CMTime time1;

  v9 = (_QWORD *)*((_QWORD *)this + 5);
  if (a3)
    *a3 = 0;
  if (*((_QWORD *)this + 2) == *((_QWORD *)this + 3) || *((_QWORD **)this + 6) == v9)
    return 0;
  v10 = 0;
  v11 = a5 ^ 1;
  v12 = (CMTime *)MEMORY[0x1E0CA2E68];
  while (!(*(unsigned int (**)(_QWORD, const CMTime *))(*(_QWORD *)*v9 + 136))(*v9, a4))
  {
    v14 = v10;
LABEL_15:
    ++v9;
    v10 = v14;
    if (v9 == *((_QWORD **)this + 6))
      return 0;
  }
  v16 = *(_QWORD *)(*v9 + 32);
  *(_OWORD *)&time1.value = *(_OWORD *)(*v9 + 16);
  time1.epoch = v16;
  time2 = *a2;
  if (CMTimeCompare(&time1, &time2) < 1)
  {
    v17 = *(_QWORD *)(*v9 + 32);
    *(_OWORD *)&time1.value = *(_OWORD *)(*v9 + 16);
    time1.epoch = v17;
    time2 = *v12;
    v13 = CMTimeCompare(&time1, &time2) ? 1 : v11;
    v14 = v13 ^ 1 | v10;
    if ((v13 & 1) != 0 || ((v10 ^ 1) & 1) != 0)
      goto LABEL_15;
  }
  if (a3)
    *a3 = (void *)*v9;
  return 1;
}

uint64_t OZSpline::createSegment(OZSpline *this, const CMTime *a2, const CMTime *a3, const CMTime *a4, int a5)
{
  uint64_t v10;
  os_unfair_lock_s *v11;
  uint64_t v12;
  os_unfair_lock_s *v13;
  uint64_t v14;
  CMTime *v15;
  int32_t v16;
  CMTime *v17;
  uint64_t v18;
  os_unfair_lock_s *v19;
  uint64_t v20;
  double v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  double v25;
  _BYTE v27[24];
  CMTime v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  CMTime v33;
  CMTime time2;
  CMTime time1;

  v10 = *((_QWORD *)this + 20);
  if (!v10 || (v11 = *(os_unfair_lock_s **)(v10 + 48)) == 0)
    v11 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v11);
  v33 = *a4;
  v31 = 0;
  v32 = 0;
  v29 = 0;
  v30 = 0;
  OZSpline::getVertexHandle(this, a2, &v32, 0);
  OZSpline::getVertexHandle(this, a3, &v31, 0);
  time1 = *a2;
  time2 = v33;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v28);
  OZSpline::getVertexHandle(this, &v28, &v30, 0);
  time1 = *a3;
  time2 = v33;
  PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v28);
  OZSpline::getVertexHandle(this, &v28, &v29, 0);
  if (v32 && v31 && v30 && v29
    || (time1 = *a2,
        v15 = (CMTime *)MEMORY[0x1E0CA2E28],
        time2 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E28],
        v16 = CMTimeCompare(&time1, &time2),
        v17 = (CMTime *)MEMORY[0x1E0CA2E30],
        !v16)
    && (time1 = *a3, time2 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E30], !CMTimeCompare(&time1, &time2)))
  {
    v12 = *((_QWORD *)this + 20);
    if (!v12 || (v13 = *(os_unfair_lock_s **)(v12 + 48)) == 0)
      v13 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::unlock(v13);
    return 0;
  }
  else
  {
    v18 = *((_QWORD *)this + 20);
    if (!v18 || (v19 = *(os_unfair_lock_s **)(v18 + 48)) == 0)
      v19 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::unlock(v19);
    time1 = *a2;
    time2 = *v15;
    v20 = 0;
    if (CMTimeCompare(&time1, &time2) && !v30)
    {
      time1 = *a2;
      time2 = v33;
      PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v28);
      time1 = *a2;
      time2 = v33;
      v21 = PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)v27);
      v22 = MEMORY[0x1E0CA2E68];
      (*(void (**)(OZSpline *, _BYTE *, _QWORD, _QWORD, double))(*(_QWORD *)this + 240))(this, v27, MEMORY[0x1E0CA2E68], 0, v21);
      v20 = (*(uint64_t (**)(OZSpline *, CMTime *, uint64_t, uint64_t))(*(_QWORD *)this + 192))(this, &v28, v22, 1);
      (*(void (**)(OZSpline *, const CMTime *, uint64_t, _QWORD))(*(_QWORD *)this + 240))(this, a2, v22, 0);
      (*(void (**)(OZSpline *, const CMTime *, uint64_t, uint64_t))(*(_QWORD *)this + 192))(this, a2, v22, 1);
    }
    time1 = *a3;
    time2 = *v17;
    v23 = 0;
    if (CMTimeCompare(&time1, &time2) && !v29)
    {
      v24 = MEMORY[0x1E0CA2E68];
      (*(void (**)(OZSpline *, const CMTime *, _QWORD, _QWORD))(*(_QWORD *)this + 240))(this, a3, MEMORY[0x1E0CA2E68], 0);
      v23 = (*(uint64_t (**)(OZSpline *, const CMTime *, uint64_t, uint64_t))(*(_QWORD *)this + 192))(this, a3, v24, 1);
      time1 = *a3;
      time2 = v33;
      PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v28);
      time1 = *a3;
      time2 = v33;
      v25 = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)v27);
      (*(void (**)(OZSpline *, _BYTE *, uint64_t, _QWORD, double))(*(_QWORD *)this + 240))(this, v27, v24, 0, v25);
      (*(void (**)(OZSpline *, CMTime *, uint64_t, uint64_t))(*(_QWORD *)this + 192))(this, &v28, v24, 1);
    }
    if (a5)
    {
      if (v20)
      {
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v20 + 200))(v20, 15);
        (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v20 + 48))(v20, MEMORY[0x1E0CA2E68], 1.0);
      }
      if (v23)
      {
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v23 + 200))(v23, 15);
        (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v23 + 48))(v23, MEMORY[0x1E0CA2E68], 1.0);
      }
      return 1;
    }
    if (v20)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v20 + 200))(v20, 1);
    if (!v23)
      return 1;
    v14 = 1;
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v23 + 200))(v23, 1);
  }
  return v14;
}

BOOL OZSpline::getVertexHandle(OZSpline *this, const CMTime *a2, void **a3, int a4)
{
  uint64_t v8;
  os_unfair_lock_s *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int32_t v13;
  _BOOL8 v14;
  uint64_t v15;
  os_unfair_lock_s *v16;
  CMTimeEpoch v18;
  CMTime time2;
  CMTime time1;

  if (a4)
  {
    v8 = *((_QWORD *)this + 20);
    if (!v8 || (v9 = *(os_unfair_lock_s **)(v8 + 48)) == 0)
      v9 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::lock(v9);
  }
  v10 = *((_QWORD *)this + 5);
  if (*((_QWORD *)this + 6) == v10)
  {
    v14 = 0;
    if (!a4)
      return v14;
  }
  else
  {
    v11 = v10 + 8;
    while (1)
    {
      v12 = *(_QWORD *)(v11 - 8);
      v18 = *(_QWORD *)(v12 + 32);
      *(_OWORD *)&time1.value = *(_OWORD *)(v12 + 16);
      time1.epoch = v18;
      time2 = *a2;
      v13 = CMTimeCompare(&time1, &time2);
      if (!v13)
      {
        if (a3)
          break;
      }
      if (v11 != *((_QWORD *)this + 6))
      {
        v11 += 8;
        if (v13)
          continue;
      }
      v14 = v13 == 0;
      if (a4)
        goto LABEL_17;
      return v14;
    }
    *a3 = *(void **)(v11 - 8);
    v14 = 1;
    if (!a4)
      return v14;
  }
LABEL_17:
  v15 = *((_QWORD *)this + 20);
  if (!v15 || (v16 = *(os_unfair_lock_s **)(v15 + 48)) == 0)
    v16 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v16);
  return v14;
}

uint64_t OZSpline::setVertexSpeed(OZSpline *this, void *a2, int a3)
{
  uint64_t v4;

  if (!a2)
    return 0;
  switch(a3)
  {
    case 0:
      v4 = 1;
      (*(void (**)(void *, uint64_t))(*(_QWORD *)a2 + 200))(a2, 1);
      return v4;
    case 1:
      (*(void (**)(void *, uint64_t))(*(_QWORD *)a2 + 200))(a2, 17);
      goto LABEL_8;
    case 2:
      (*(void (**)(void *, uint64_t))(*(_QWORD *)a2 + 200))(a2, 16);
      goto LABEL_8;
    case 3:
      (*(void (**)(void *, uint64_t))(*(_QWORD *)a2 + 200))(a2, 15);
LABEL_8:
      (*(void (**)(void *, _QWORD, double))(*(_QWORD *)a2 + 48))(a2, MEMORY[0x1E0CA2E68], 1.0);
      v4 = 1;
      break;
    default:
      return 0;
  }
  return v4;
}

void OZSpline::setClosed(OZSpline *this, char a2, void *a3)
{
  uint64_t v6;
  os_unfair_lock_s *v7;
  void **VertexIter;
  void **v9;
  char **v10;
  void **v11;
  void **v12;
  char *v13;
  void **v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  uint64_t v28;
  char *v29;
  char *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  os_unfair_lock_s *v42;
  char v43;
  char *__p;
  char *v45;
  char *v46;

  v6 = *((_QWORD *)this + 20);
  if (!v6 || (v7 = *(os_unfair_lock_s **)(v6 + 48)) == 0)
    v7 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v7);
  if ((a2 & 1) == 0 && a3 && *((_BYTE *)this + 144))
  {
    v43 = a2;
    __p = 0;
    v45 = 0;
    v46 = 0;
    VertexIter = OZSpline::getVertexIter(this, a3);
    v9 = VertexIter;
    v11 = (void **)*((_QWORD *)this + 2);
    v12 = (void **)*((_QWORD *)this + 3);
    v10 = (char **)((char *)this + 16);
    if (v12 == VertexIter)
    {
      v13 = 0;
    }
    else
    {
      v13 = 0;
      v14 = VertexIter;
      do
      {
        if (v13 >= v46)
        {
          v15 = (v13 - __p) >> 3;
          if ((unint64_t)(v15 + 1) >> 61)
LABEL_71:
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v16 = (v46 - __p) >> 2;
          if (v16 <= v15 + 1)
            v16 = v15 + 1;
          if ((unint64_t)(v46 - __p) >= 0x7FFFFFFFFFFFFFF8)
            v17 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v17 = v16;
          if (v17)
            v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v46, v17);
          else
            v18 = 0;
          v19 = &v18[8 * v15];
          *(_QWORD *)v19 = *v14;
          v13 = v19 + 8;
          v20 = v45;
          if (v45 != __p)
          {
            do
            {
              v21 = *((_QWORD *)v20 - 1);
              v20 -= 8;
              *((_QWORD *)v19 - 1) = v21;
              v19 -= 8;
            }
            while (v20 != __p);
            v20 = __p;
          }
          __p = v19;
          v46 = &v18[8 * v17];
          if (v20)
            operator delete(v20);
        }
        else
        {
          *(_QWORD *)v13 = *v14;
          v13 += 8;
        }
        v45 = v13;
        ++v14;
      }
      while (v14 != v12);
    }
    for (; v11 != v9; ++v11)
    {
      if (v13 >= v46)
      {
        v22 = (v13 - __p) >> 3;
        if ((unint64_t)(v22 + 1) >> 61)
          goto LABEL_71;
        v23 = (v46 - __p) >> 2;
        if (v23 <= v22 + 1)
          v23 = v22 + 1;
        if ((unint64_t)(v46 - __p) >= 0x7FFFFFFFFFFFFFF8)
          v24 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v24 = v23;
        if (v24)
          v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v46, v24);
        else
          v25 = 0;
        v26 = &v25[8 * v22];
        *(_QWORD *)v26 = *v11;
        v13 = v26 + 8;
        v27 = v45;
        if (v45 != __p)
        {
          do
          {
            v28 = *((_QWORD *)v27 - 1);
            v27 -= 8;
            *((_QWORD *)v26 - 1) = v28;
            v26 -= 8;
          }
          while (v27 != __p);
          v27 = __p;
        }
        __p = v26;
        v46 = &v25[8 * v24];
        if (v27)
          operator delete(v27);
      }
      else
      {
        *(_QWORD *)v13 = *v11;
        v13 += 8;
      }
      v45 = v13;
    }
    v29 = __p;
    v30 = (char *)*((_QWORD *)this + 2);
    *((_QWORD *)this + 3) = v30;
    if (__p != v13)
    {
      v31 = (_QWORD *)((char *)this + 32);
      do
      {
        if ((unint64_t)v30 >= *v31)
        {
          v32 = (v30 - *v10) >> 3;
          if ((unint64_t)(v32 + 1) >> 61)
            goto LABEL_71;
          v33 = *v31 - (_QWORD)*v10;
          v34 = v33 >> 2;
          if (v33 >> 2 <= (unint64_t)(v32 + 1))
            v34 = v32 + 1;
          if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
            v35 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v35 = v34;
          if (v35)
            v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 32, v35);
          else
            v36 = 0;
          v37 = &v36[8 * v32];
          *(_QWORD *)v37 = *(_QWORD *)v29;
          v30 = v37 + 8;
          v39 = (char *)*((_QWORD *)this + 2);
          v38 = (char *)*((_QWORD *)this + 3);
          if (v38 != v39)
          {
            do
            {
              v40 = *((_QWORD *)v38 - 1);
              v38 -= 8;
              *((_QWORD *)v37 - 1) = v40;
              v37 -= 8;
            }
            while (v38 != v39);
            v38 = *v10;
          }
          *((_QWORD *)this + 2) = v37;
          *((_QWORD *)this + 3) = v30;
          *((_QWORD *)this + 4) = &v36[8 * v35];
          if (v38)
            operator delete(v38);
        }
        else
        {
          *(_QWORD *)v30 = *(_QWORD *)v29;
          v30 += 8;
        }
        *((_QWORD *)this + 3) = v30;
        v29 += 8;
      }
      while (v29 != v45);
    }
    OZSpline::reparametrize((uint64_t)this);
    a2 = v43;
    if (__p)
      operator delete(__p);
  }
  *((_BYTE *)this + 144) = a2;
  *((_BYTE *)this + 145) = 1;
  *(_OWORD *)((char *)this + 40) = *((_OWORD *)this + 1);
  OZSpline::refreshValidVerticesList(this);
  v41 = *((_QWORD *)this + 20);
  if (!v41 || (v42 = *(os_unfair_lock_s **)(v41 + 48)) == 0)
    v42 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v42);
}

void sub_1B2C466B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t OZSpline::reparametrize(uint64_t this)
{
  uint64_t *v1;
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CMTime v7;

  v1 = *(uint64_t **)(this + 40);
  if (*(uint64_t **)(this + 48) != v1)
  {
    v2 = this;
    v3 = 0;
    do
    {
      v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)*v1 + 168))(*v1);
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)*v1 + 160))(*v1, 2);
      v5 = *v1;
      OZFigTimeForChannelSeconds(&v7, (double)v3, 0x40000);
      (*(void (**)(uint64_t, CMTime *))(*(_QWORD *)v5 + 16))(v5, &v7);
      v6 = *v1++;
      this = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 176))(v6, v4);
      ++v3;
    }
    while (v1 != *(uint64_t **)(v2 + 48));
  }
  return this;
}

void OZSpline::setDirty(OZSpline *this, char a2)
{
  if ((a2 & 1) != 0)
  {
    *((_BYTE *)this + 145) = 1;
    *(_OWORD *)((char *)this + 40) = *((_OWORD *)this + 1);
    OZSpline::refreshValidVerticesList(this);
  }
  else
  {
    *((_BYTE *)this + 145) = 0;
  }
}

BOOL OZSpline::getFirstValidVertexWithLock(OZSpline *this, void **a2, const CMTime *a3)
{
  uint64_t v6;
  os_unfair_lock_s *v7;
  _BOOL8 FirstValidVertex;
  uint64_t v9;
  os_unfair_lock_s *v10;

  v6 = *((_QWORD *)this + 20);
  if (!v6 || (v7 = *(os_unfair_lock_s **)(v6 + 48)) == 0)
    v7 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v7);
  FirstValidVertex = OZSpline::getFirstValidVertex(this, a2, a3);
  v9 = *((_QWORD *)this + 20);
  if (!v9 || (v10 = *(os_unfair_lock_s **)(v9 + 48)) == 0)
    v10 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v10);
  return FirstValidVertex;
}

uint64_t OZSpline::getLastValidVertexWithLock(OZSpline *this, void **a2, const CMTime *a3)
{
  uint64_t v6;
  os_unfair_lock_s *v7;
  uint64_t LastValidVertex;
  uint64_t v9;
  os_unfair_lock_s *v10;

  v6 = *((_QWORD *)this + 20);
  if (!v6 || (v7 = *(os_unfair_lock_s **)(v6 + 48)) == 0)
    v7 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v7);
  LastValidVertex = OZSpline::getLastValidVertex(this, a2, a3);
  v9 = *((_QWORD *)this + 20);
  if (!v9 || (v10 = *(os_unfair_lock_s **)(v9 + 48)) == 0)
    v10 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v10);
  return LastValidVertex;
}

uint64_t OZSpline::getNextValidVertexWithLock(OZSpline *this, void *a2, void **a3, const CMTime *a4)
{
  uint64_t v8;
  os_unfair_lock_s *v9;
  uint64_t NextValidVertex;
  uint64_t v11;
  os_unfair_lock_s *v12;

  v8 = *((_QWORD *)this + 20);
  if (!v8 || (v9 = *(os_unfair_lock_s **)(v8 + 48)) == 0)
    v9 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v9);
  NextValidVertex = OZSpline::getNextValidVertex((void ***)this, a2, a3, a4);
  v11 = *((_QWORD *)this + 20);
  if (!v11 || (v12 = *(os_unfair_lock_s **)(v11 + 48)) == 0)
    v12 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v12);
  return NextValidVertex;
}

uint64_t OZSpline::getPreviousValidVertexWithLock(OZSpline *this, void *a2, void **a3, const CMTime *a4)
{
  uint64_t v8;
  os_unfair_lock_s *v9;
  uint64_t PreviousValidVertex;
  uint64_t v11;
  os_unfair_lock_s *v12;

  v8 = *((_QWORD *)this + 20);
  if (!v8 || (v9 = *(os_unfair_lock_s **)(v8 + 48)) == 0)
    v9 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v9);
  PreviousValidVertex = OZSpline::getPreviousValidVertex(this, a2, a3, a4);
  v11 = *((_QWORD *)this + 20);
  if (!v11 || (v12 = *(os_unfair_lock_s **)(v11 + 48)) == 0)
    v12 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v12);
  return PreviousValidVertex;
}

uint64_t OZSpline::getPreviousValidVertex(OZSpline *this, void *a2, void **a3, const CMTime *a4)
{
  void **ValidVertexIter;
  uint64_t result;
  void **VertexIter;

  if (*((_BYTE *)this + 112))
  {
    ValidVertexIter = OZSpline::getValidVertexIter(this, a2);
    if (*((void ***)this + 9) == ValidVertexIter)
    {
      result = 0;
      if (a3)
        *a3 = 0;
    }
    else
    {
      if (a3)
        *a3 = *(ValidVertexIter - 1);
      return 1;
    }
  }
  else
  {
    VertexIter = OZSpline::getVertexIter(this, a2);
    return OZSpline::getPreviousValidVertex(this, &VertexIter, a3, (uint64_t)a4);
  }
  return result;
}

uint64_t OZSpline::getNextValidVertex(OZSpline *this, void ***a2, _QWORD *a3, uint64_t a4)
{
  void **v8;
  void **v9;
  void **ValidVertexIter;
  void **v11;
  void **v12;
  uint64_t result;
  void *v15;
  void *v16;
  __int128 v17;
  CMTimeEpoch v18;
  CMTimeEpoch v19;
  CMTime time2;
  CMTime time1;

  v8 = *a2;
  if (a3)
    *a3 = 0;
  v9 = (void **)*((_QWORD *)this + 6);
  if (*a2 == v9)
    return 0;
  if (!*((_BYTE *)this + 112))
  {
    v12 = v8 + 1;
    if (v8 + 1 != v9)
    {
      while (1)
      {
        if ((*(unsigned int (**)(void *, uint64_t))(*(_QWORD *)*v12 + 136))(*v12, a4))
        {
          v19 = *((_QWORD *)*v12 + 4);
          v16 = **a2;
          v17 = *((_OWORD *)v16 + 1);
          v18 = *((_QWORD *)v16 + 4);
          *(_OWORD *)&time1.value = *((_OWORD *)*v12 + 1);
          time1.epoch = v19;
          *(_OWORD *)&time2.value = v17;
          time2.epoch = v18;
          if (CMTimeCompare(&time1, &time2))
            break;
        }
        if (++v12 == *((void ***)this + 6))
          return 0;
      }
      goto LABEL_17;
    }
    return 0;
  }
  ValidVertexIter = OZSpline::getValidVertexIter(this, **a2);
  v11 = (void **)*((_QWORD *)this + 10);
  v12 = ValidVertexIter + 1;
  if (v11 == ValidVertexIter || v12 == v11)
  {
    result = 0;
    if (!a3)
      return result;
    v15 = 0;
    goto LABEL_19;
  }
LABEL_17:
  if (a3)
  {
    v15 = *v12;
    result = 1;
LABEL_19:
    *a3 = v15;
    return result;
  }
  return 1;
}

uint64_t OZSpline::getPreviousValidVertex(OZSpline *this, void ***a2, _QWORD *a3, uint64_t a4)
{
  void **v8;
  void **v9;
  void **ValidVertexIter;
  void *v11;
  void **v12;
  void *v13;
  void *v14;
  __int128 v15;
  uint64_t result;
  void *v17;
  __int128 v18;
  int32_t v19;
  CMTimeEpoch v20;
  CMTimeEpoch v21;
  CMTimeEpoch v22;
  CMTimeEpoch v23;
  CMTimeEpoch v24;
  CMTimeEpoch v25;
  CMTime v26;
  CMTime time2;
  CMTime time1;

  if (a3)
    *a3 = 0;
  v8 = *a2;
  v9 = (void **)*((_QWORD *)this + 5);
  if (*a2 == v9)
    return 0;
  if (*((_BYTE *)this + 112))
  {
    ValidVertexIter = OZSpline::getValidVertexIter(this, *v8);
    if (*((void ***)this + 9) != ValidVertexIter)
    {
      if (!a3)
        return 1;
      v11 = *(ValidVertexIter - 1);
LABEL_8:
      *a3 = v11;
      return 1;
    }
    if (a3)
    {
      result = 0;
      *a3 = 0;
      return result;
    }
    return 0;
  }
  *(_OWORD *)&v26.value = *MEMORY[0x1E0CA2E28];
  v26.epoch = *(_QWORD *)(MEMORY[0x1E0CA2E28] + 16);
  v12 = v8 - 1;
  if (v12 == v9)
  {
    v13 = 0;
    if (!a3)
      goto LABEL_19;
  }
  else
  {
    v13 = 0;
    v9 = v12;
    do
    {
      if (v13)
      {
        v22 = *((_QWORD *)*v9 + 4);
        *(_OWORD *)&time1.value = *((_OWORD *)*v9 + 1);
        time1.epoch = v22;
        time2 = v26;
        if (CMTimeCompare(&time1, &time2))
        {
          if (a3)
            *a3 = v13;
          return 1;
        }
      }
      if ((*(unsigned int (**)(void *, uint64_t))(*(_QWORD *)*v9 + 136))(*v9, a4))
      {
        v23 = *((_QWORD *)*v9 + 4);
        v14 = **a2;
        v15 = *((_OWORD *)v14 + 1);
        v20 = *((_QWORD *)v14 + 4);
        *(_OWORD *)&time1.value = *((_OWORD *)*v9 + 1);
        time1.epoch = v23;
        *(_OWORD *)&time2.value = v15;
        time2.epoch = v20;
        if (CMTimeCompare(&time1, &time2))
        {
          v13 = *v9;
          *(_OWORD *)&v26.value = *((_OWORD *)*v9 + 1);
          v26.epoch = *((_QWORD *)*v9 + 4);
        }
      }
      --v9;
    }
    while (v9 != *((void ***)this + 5));
    if (!a3)
      goto LABEL_19;
  }
  *a3 = v13;
LABEL_19:
  if (v13)
  {
    v24 = *((_QWORD *)*v9 + 4);
    *(_OWORD *)&time1.value = *((_OWORD *)*v9 + 1);
    time1.epoch = v24;
    time2 = v26;
    if (CMTimeCompare(&time1, &time2))
      return 1;
  }
  result = (*(uint64_t (**)(void *, uint64_t))(*(_QWORD *)*v9 + 136))(*v9, a4);
  if ((_DWORD)result)
  {
    v25 = *((_QWORD *)*v9 + 4);
    v17 = **a2;
    v18 = *((_OWORD *)v17 + 1);
    v21 = *((_QWORD *)v17 + 4);
    *(_OWORD *)&time1.value = *((_OWORD *)*v9 + 1);
    time1.epoch = v25;
    *(_OWORD *)&time2.value = v18;
    time2.epoch = v21;
    v19 = CMTimeCompare(&time1, &time2);
    result = v19 != 0;
    if (a3)
    {
      if (v19)
      {
        v11 = *v9;
        goto LABEL_8;
      }
    }
  }
  return result;
}

uint64_t OZSpline::getNextValidVertexWithLock(OZSpline *this, const CMTime *a2, void **a3, const CMTime *a4, int a5)
{
  uint64_t v10;
  os_unfair_lock_s *v11;
  uint64_t NextValidVertex;
  uint64_t v13;
  os_unfair_lock_s *v14;

  v10 = *((_QWORD *)this + 20);
  if (!v10 || (v11 = *(os_unfair_lock_s **)(v10 + 48)) == 0)
    v11 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v11);
  NextValidVertex = OZSpline::getNextValidVertex(this, a2, a3, a4, a5);
  v13 = *((_QWORD *)this + 20);
  if (!v13 || (v14 = *(os_unfair_lock_s **)(v13 + 48)) == 0)
    v14 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v14);
  return NextValidVertex;
}

uint64_t OZSpline::getPreviousValidVertexWithLock(OZSpline *this, const CMTime *a2, void **a3, const CMTime *a4, int a5)
{
  uint64_t v10;
  os_unfair_lock_s *v11;
  uint64_t PreviousValidVertex;
  uint64_t v13;
  os_unfair_lock_s *v14;

  v10 = *((_QWORD *)this + 20);
  if (!v10 || (v11 = *(os_unfair_lock_s **)(v10 + 48)) == 0)
    v11 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v11);
  PreviousValidVertex = OZSpline::getPreviousValidVertex(this, a2, a3, a4, a5);
  v13 = *((_QWORD *)this + 20);
  if (!v13 || (v14 = *(os_unfair_lock_s **)(v13 + 48)) == 0)
    v14 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v14);
  return PreviousValidVertex;
}

void **OZSpline::getValidVertexIter(OZSpline *this, void *a2)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  void **v8;
  void **v9;

  v2 = (void **)*((_QWORD *)this + 9);
  v3 = *((_QWORD *)this + 16);
  v4 = *((_QWORD *)this + 11);
  v5 = *((_QWORD *)this + 12) - v4;
  if (v3 < (unint64_t)(v5 >> 3) && *(void **)(v4 + 8 * v3) == a2)
  {
    v2 += v3;
  }
  else
  {
    v6 = v3 - 1;
    if (v3 >= 1 && *(void **)(v4 + 8 * v6) == a2)
    {
      v2 += v6;
      *((_QWORD *)this + 16) = v6;
    }
    else
    {
      v7 = v3 + 1;
      if (v7 < v5 >> 3 && *(void **)(v4 + 8 * v7) == a2)
      {
        v2 += v7;
        *((_QWORD *)this + 16) = v7;
      }
      else
      {
        v8 = (void **)*((_QWORD *)this + 10);
        v9 = (void **)*((_QWORD *)this + 9);
        if (v8 != v2)
        {
          while (*v9 != a2)
          {
            if (++v9 == v8)
            {
              v9 = (void **)*((_QWORD *)this + 10);
              break;
            }
          }
        }
        *((_QWORD *)this + 16) = v9 - v2;
        if (v9 != v8)
          return v9;
      }
    }
  }
  return v2;
}

CMTime *OZSpline::getSmallDeltaU@<X0>(OZSpline *this@<X0>, CMTime *a2@<X8>)
{
  int32_t v2;

  if (**((_BYTE **)this + 21))
    v2 = 1;
  else
    v2 = 100;
  return CMTimeMake(a2, 1, v2);
}

uint64_t OZSpline::getFirstVertex(OZSpline *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 2);
  if (v1 == *((_QWORD *)this + 3))
    return 0;
  else
    return *(_QWORD *)v1;
}

uint64_t OZSpline::getPreviousVertex(OZSpline *this, void *a2)
{
  void **VertexIter;

  VertexIter = OZSpline::getVertexIter(this, a2);
  if (*((void ***)this + 5) == VertexIter)
    return 0;
  else
    return (uint64_t)*(VertexIter - 1);
}

void *OZSpline::getNextVertex(void ***this, void *a2)
{
  void **VertexIter;
  void **v4;

  VertexIter = OZSpline::getVertexIter((OZSpline *)this, a2);
  v4 = this[6];
  if (v4 == VertexIter || VertexIter + 1 == v4)
    return 0;
  else
    return VertexIter[1];
}

uint64_t OZSpline::getNextVertex(OZSpline *this, const CMTime *a2)
{
  uint64_t v3;
  int v5;
  CMTime *v6;
  _BOOL4 v7;
  CMTimeEpoch v9;
  CMTimeEpoch v10;
  CMTime time2;
  CMTime time1;

  if (*((_QWORD *)this + 2) == *((_QWORD *)this + 3))
    return 0;
  v3 = *((_QWORD *)this + 5);
  if (*((_QWORD *)this + 6) == v3)
    return 0;
  v5 = 0;
  v6 = (CMTime *)MEMORY[0x1E0CA2E68];
  while (1)
  {
    v9 = *(_QWORD *)(*(_QWORD *)v3 + 32);
    *(_OWORD *)&time1.value = *(_OWORD *)(*(_QWORD *)v3 + 16);
    time1.epoch = v9;
    time2 = *a2;
    if (CMTimeCompare(&time1, &time2) > 0)
      break;
    v10 = *(_QWORD *)(*(_QWORD *)v3 + 32);
    *(_OWORD *)&time1.value = *(_OWORD *)(*(_QWORD *)v3 + 16);
    time1.epoch = v10;
    time2 = *v6;
    v7 = CMTimeCompare(&time1, &time2) == 0;
    if ((v7 & v5 & 1) != 0)
      break;
    v5 |= v7;
    v3 += 8;
    if (v3 == *((_QWORD *)this + 6))
      return 0;
  }
  return *(_QWORD *)v3;
}

uint64_t OZSpline::findVertex(OZSpline *this, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  const CMTime *v16;
  OZSpline *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  const CMTime *v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  const CMTime *v29;
  _BOOL4 v30;
  char *v31;
  unint64_t v32;
  const CMTime *v33;
  char *v34;
  CMTimeEpoch v35;
  CMTimeEpoch v36;
  CMTime v37;
  CMTime time2;
  CMTime time1;

  if (!a4)
    return 0;
  v6 = a2;
  if (a3 - a2 <= 1)
  {
    v8 = *((_QWORD *)this + 2);
    if (*(char **)(v8 + 8 * a2) != a4)
      return *(_QWORD *)(v8 + 8 * a3) == (_QWORD)a4;
    return 1;
  }
  if (a3 < a2)
    return 0;
  v10 = *((_QWORD *)this + 2);
  if (*(char **)(v10 + 8 * a2) == a4)
    return 1;
  if (*(char **)(v10 + 8 * a3) == a4)
    return 1;
  v11 = (uint64_t)((double)(a3 - a2) * 0.5 + (double)a2);
  v12 = *(_QWORD *)(v10 + 8 * v11);
  if ((char *)v12 == a4)
    return 1;
  v37 = *(CMTime *)(a4 + 16);
  v13 = *(_OWORD *)(v12 + 16);
  v35 = *(_QWORD *)(v12 + 32);
  time1 = *(CMTime *)(a4 + 16);
  *(_OWORD *)&time2.value = v13;
  time2.epoch = v35;
  if (CMTimeCompare(&time1, &time2) < 0)
  {
    v17 = this;
    v18 = v6;
    v19 = v11;
    return OZSpline::findVertex(v17, v18, v19, a4);
  }
  v14 = *(_QWORD *)(*((_QWORD *)this + 2) + 8 * v11);
  v15 = *(_OWORD *)(v14 + 16);
  v36 = *(_QWORD *)(v14 + 32);
  time1 = v37;
  *(_OWORD *)&time2.value = v15;
  time2.epoch = v36;
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    v17 = this;
    v18 = v11;
    v19 = a3;
    return OZSpline::findVertex(v17, v18, v19, a4);
  }
  v20 = *(_QWORD *)(*((_QWORD *)this + 2) + 8 * v6);
  v21 = *(_OWORD *)(v20 + 16);
  time1.epoch = *(_QWORD *)(v20 + 32);
  *(_OWORD *)&time1.value = v21;
  if (PCMath::equal((PCMath *)&v37, &time1, MEMORY[0x1E0CA2E68], v16))
    goto LABEL_19;
  v23 = *(_QWORD *)(*((_QWORD *)this + 2) + 8 * v11);
  v24 = *(_OWORD *)(v23 + 16);
  time1.epoch = *(_QWORD *)(v23 + 32);
  *(_OWORD *)&time1.value = v24;
  v6 = v11;
  if (PCMath::equal((PCMath *)&v37, &time1, MEMORY[0x1E0CA2E68], v22)
    || (v25 = *(_QWORD *)(*((_QWORD *)this + 2) + 8 * a3),
        v26 = *(_OWORD *)(v25 + 16),
        time1.epoch = *(_QWORD *)(v25 + 32),
        *(_OWORD *)&time1.value = v26,
        result = PCMath::equal((PCMath *)&v37, &time1, MEMORY[0x1E0CA2E68], v22),
        v6 = a3,
        (_DWORD)result))
  {
LABEL_19:
    v27 = *((_QWORD *)this + 2);
    v28 = v6 - 1;
    v29 = (const CMTime *)MEMORY[0x1E0CA2E68];
    while (v28 + 1 >= 1)
    {
      time1 = *(CMTime *)(*(_QWORD *)(v27 + 8 * v28) + 16);
      v30 = PCMath::equal((PCMath *)&v37, &time1, v29, v22);
      v27 = *((_QWORD *)this + 2);
      if (!v30)
        break;
      v31 = *(char **)(v27 + 8 * v28--);
      if (v31 == a4)
        return 1;
    }
    v32 = v6 + 1;
    v33 = (const CMTime *)MEMORY[0x1E0CA2E68];
    while (v32 < (*((_QWORD *)this + 3) - v27) >> 3)
    {
      time1 = *(CMTime *)(*(_QWORD *)(v27 + 8 * v32) + 16);
      result = PCMath::equal((PCMath *)&v37, &time1, v33, v22);
      if (!(_DWORD)result)
        return result;
      v27 = *((_QWORD *)this + 2);
      v34 = *(char **)(v27 + 8 * v32++);
      if (v34 == a4)
        return 1;
    }
    return 0;
  }
  return result;
}

uint64_t OZSpline::isValidHandle(OZSpline *this, char *a2)
{
  uint64_t v4;
  os_unfair_lock_s *v5;
  uint64_t v6;
  uint64_t Vertex;
  uint64_t v8;
  os_unfair_lock_s *v9;

  v4 = *((_QWORD *)this + 20);
  if (!v4 || (v5 = *(os_unfair_lock_s **)(v4 + 48)) == 0)
    v5 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v5);
  v6 = *((_QWORD *)this + 3) - *((_QWORD *)this + 2);
  if (v6)
    Vertex = OZSpline::findVertex(this, 0, (v6 >> 3) - 1, a2);
  else
    Vertex = 0;
  v8 = *((_QWORD *)this + 20);
  if (!v8 || (v9 = *(os_unfair_lock_s **)(v8 + 48)) == 0)
    v9 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v9);
  return Vertex;
}

uint64_t OZSpline::lockSpline(uint64_t this, int a2)
{
  _QWORD **v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  v2 = *(_QWORD ***)(this + 40);
  if (*(_QWORD ***)(this + 48) != v2)
  {
    v3 = this;
    if (a2)
      v4 = 19;
    else
      v4 = 20;
    do
    {
      v5 = *v2++;
      this = (*(uint64_t (**)(void))(*v5 + 8 * v4))();
    }
    while (v2 != *(_QWORD ***)(v3 + 48));
  }
  return this;
}

uint64_t OZSpline::getNumberOfValidVertices(OZSpline *this, const CMTime *a2)
{
  uint64_t v3;
  const CMTime *v4;
  void *v6;

  v6 = 0;
  OZSpline::getFirstValidVertex(this, &v6, a2);
  if (!v6)
    return 0;
  LODWORD(v3) = 0;
  v4 = (const CMTime *)MEMORY[0x1E0CA2E68];
  do
    v3 = (v3 + 1);
  while ((OZSpline::getNextValidVertex((void ***)this, v6, &v6, v4) & 1) != 0);
  return v3;
}

double OZSpline::getVertexValue(OZSpline *this, const CMTime *a2, const CMTime *a3, uint64_t a4)
{
  uint64_t v8;
  double v9;
  uint64_t v10;
  os_unfair_lock_s *v11;
  uint64_t Interpolator;
  char v13;
  uint64_t v14;
  os_unfair_lock_s *v15;
  void **v17;
  unint64_t v18;
  void **v19;
  char *v20;
  OZSpline *v21;
  const CMTime *v22;
  const CMTime *v23;
  int v24;
  void **v25;
  void **v26;
  OZInterpolators *v27;
  int v28;
  uint64_t v29;
  OZInterpolators *v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  void *v36;
  OZSpline *v37;
  const CMTime *v38;
  OZInterpolators *v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  os_unfair_lock_s *v43;
  OZSpline *v44;
  const CMTime *v45;
  const CMTime *v46;
  void *v47;
  void *v48;
  void *v49;
  uint64_t v50;
  CMTime v51;
  void **v52;
  CMTime v53;
  double v54;
  void *v55;
  void *v56;
  void *v57;
  CMTime time2;
  CMTime time1;

  v56 = 0;
  v57 = 0;
  v55 = 0;
  v8 = *((_QWORD *)this + 20);
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 96))(v8);
  else
    v9 = 0.0;
  v54 = v9;
  if ((_DWORD)a4)
  {
    v10 = *((_QWORD *)this + 20);
    if (!v10 || (v11 = *(os_unfair_lock_s **)(v10 + 48)) == 0)
      v11 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::lock(v11);
  }
  Interpolator = OZInterpolators::getInterpolator(*((OZInterpolators **)this + 19), *(_DWORD *)(*((_QWORD *)this + 21) + 32));
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)Interpolator + 64))(Interpolator) & 1) == 0)
  {
    time2.value = 0;
    LODWORD(v53.value) = 1;
    if ((_DWORD)a4)
    {
      v14 = *((_QWORD *)this + 20);
      if (!v14 || (v15 = *(os_unfair_lock_s **)(v14 + 48)) == 0)
        v15 = (os_unfair_lock_s *)((char *)this + 8);
      PCSpinLock::unlock(v15);
    }
    CMTimeMake(&time1, 1, 1);
    (*(void (**)(OZSpline *, const CMTime *, CMTime *, CMTime *, _QWORD, CMTime *, const CMTime *, uint64_t))(*(_QWORD *)this + 72))(this, a2, &time1, &v53, 0, &time2, a3, a4);
    return *(double *)&time2.value;
  }
  OZSpline::getMinValueU(this, MEMORY[0x1E0CA2E68], 0, (uint64_t)&v53);
  time1 = *a2;
  time2 = v53;
  if (CMTimeCompare(&time1, &time2) < 0 && !*((_BYTE *)this + 144))
  {
    if (!OZSpline::getFirstValidVertex(this, &v57, a3))
      goto LABEL_63;
    v20 = (char *)v57;
    v21 = this;
    v22 = a3;
    v23 = a2;
    v24 = 1;
    goto LABEL_33;
  }
  memset(&v53, 0, sizeof(v53));
  OZSpline::getMaxValueU(this, MEMORY[0x1E0CA2E68], 0, (uint64_t)&v53);
  time1 = *a2;
  time2 = v53;
  if (CMTimeCompare(&time1, &time2) <= 0)
  {
    if (!*(_BYTE *)(*((_QWORD *)this + 21) + 4) || (time1 = *a2, time2 = v53, CMTimeCompare(&time1, &time2) < 0))
    {
      v13 = 0;
      goto LABEL_24;
    }
  }
  if (!*((_BYTE *)this + 144))
  {
    if (!OZSpline::getLastValidVertex(this, &v56, a3))
      goto LABEL_63;
    v20 = (char *)v56;
    v21 = this;
    v22 = a3;
    v23 = a2;
    v24 = 0;
LABEL_33:
    OZSpline::extrapolate(v21, v20, v22, v23, &v54, v24);
    goto LABEL_63;
  }
  v13 = 1;
LABEL_24:
  v17 = (void **)*((_QWORD *)this + 5);
  v18 = *((_QWORD *)this + 17);
  if (v18 < (uint64_t)(*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 3)
  {
    v19 = &v17[v18];
    v52 = v19;
    if (v18)
    {
      v51 = *(CMTime *)((char *)*v19 + 16);
      time1 = *a2;
      time2 = v51;
      v17 = v19;
      if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
      {
        if ((v13 & 1) != 0)
        {
LABEL_52:
          if (!OZSpline::getLastValidVertex(this, &v55, a3))
            goto LABEL_61;
          v33 = *((_QWORD *)this + 17);
          if (v33 <= 0)
            v34 = 0;
          else
            v34 = v33 - 1;
          *((_QWORD *)this + 17) = v34;
          if (*((_BYTE *)this + 144))
          {
            v57 = v55;
            OZSpline::getFirstValidVertex(this, &v56, a3);
            v36 = v56;
            v35 = v57;
            v37 = this;
            v38 = a3;
          }
          else
          {
            v39 = (OZInterpolators *)*((_QWORD *)this + 19);
            v40 = (*(uint64_t (**)(void *))(*(_QWORD *)v55 + 208))(v55);
            v41 = OZInterpolators::getInterpolator(v39, v40);
            if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v41 + 64))(v41) & 1) != 0)
              goto LABEL_61;
            v35 = v55;
            v56 = v55;
            v57 = v55;
            v37 = this;
            v38 = a3;
            v36 = v55;
          }
          OZSpline::interpolate(v37, v38, v35, v36, a2, &v54, 0);
LABEL_61:
          if ((*((_QWORD *)this + 17) & 0x8000000000000000) != 0)
            goto LABEL_62;
          goto LABEL_63;
        }
        goto LABEL_36;
      }
      v17 = (void **)*((_QWORD *)this + 5);
    }
  }
  *((_QWORD *)this + 17) = 0;
  v52 = v17;
  v19 = v17;
  if ((v13 & 1) != 0)
    goto LABEL_52;
LABEL_36:
  if (v19 == *((void ***)this + 6))
    goto LABEL_52;
  v25 = v19 + 1;
  while (1)
  {
    v26 = v17;
    v17 = v25;
    memset(&v51, 0, sizeof(v51));
    v51 = *(CMTime *)((char *)*v19 + 16);
    time1 = v51;
    time2 = *a2;
    if (CMTimeCompare(&time1, &time2)
      || !(*(unsigned int (**)(void *, const CMTime *))(*(_QWORD *)*v19 + 136))(*v19, a3))
    {
      break;
    }
    if (v19 == *((void ***)this + 5))
    {
      v30 = (OZInterpolators *)*((_QWORD *)this + 19);
      v31 = (*(uint64_t (**)(void *))(*(_QWORD *)*v26 + 208))(*v26);
      v32 = OZInterpolators::getInterpolator(v30, v31);
      if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v32 + 64))(v32) & 1) != 0)
      {
        v47 = *v26;
        goto LABEL_72;
      }
      if (v26 + 1 != *((void ***)this + 6))
      {
        v48 = *v26;
        v49 = v26[1];
        goto LABEL_74;
      }
    }
    else
    {
      v27 = (OZInterpolators *)*((_QWORD *)this + 19);
      v28 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*(v26 - 1) + 208))(*(v26 - 1));
      v29 = OZInterpolators::getInterpolator(v27, v28);
      if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v29 + 64))(v29) & 1) != 0)
      {
        v47 = *v19;
LABEL_72:
        v54 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)v47 + 24))(v47, a3);
        goto LABEL_76;
      }
      if (v26 + 1 != *((void ***)this + 6))
      {
        v48 = *v19;
        v49 = v26[1];
LABEL_74:
        v46 = &v51;
        v44 = this;
        v45 = a3;
        goto LABEL_75;
      }
    }
LABEL_51:
    v52 = ++v19;
    ++*((_QWORD *)this + 17);
    v25 = v17 + 1;
    if (v19 == *((void ***)this + 6))
      goto LABEL_52;
  }
  time1 = v51;
  time2 = *a2;
  if (CMTimeCompare(&time1, &time2) < 1)
    goto LABEL_51;
  if (!(*(unsigned int (**)(void *, const CMTime *))(*(_QWORD *)*v19 + 136))(*v19, a3))
    goto LABEL_51;
  if (!OZSpline::getPreviousValidVertex(this, &v52, &v57, (uint64_t)a3))
    goto LABEL_51;
  v49 = *v19;
  v56 = v49;
  if (!v49)
    goto LABEL_51;
  v48 = v57;
  v44 = this;
  v45 = a3;
  v46 = a2;
LABEL_75:
  OZSpline::interpolate(v44, v45, v48, v49, v46, &v54, 0);
LABEL_76:
  v50 = *((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = v50;
  if (v50 < 0)
LABEL_62:
    *((_QWORD *)this + 17) = 0;
LABEL_63:
  if ((_DWORD)a4)
  {
    v42 = *((_QWORD *)this + 20);
    if (!v42 || (v43 = *(os_unfair_lock_s **)(v42 + 48)) == 0)
      v43 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::unlock(v43);
  }
  return v54;
}

void OZSpline::extrapolate(OZSpline *this, char *a2, const CMTime *a3, const CMTime *a4, double *a5, int a6)
{
  const CMTime *v12;
  uint64_t v13;
  double v14;
  __n128 v15;
  int32_t v16;
  double v17;
  double v18;
  double v19;
  int32_t v20;
  double v21;
  double v22;
  CMTime *v23;
  __n128 v24;
  CMTimeEpoch epoch;
  double v26;
  uint64_t v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  int32_t v33;
  double v34;
  double v35;
  double v36;
  int32_t v37;
  double Seconds;
  double v39;
  double v40;
  double v41;
  CMTimeEpoch v42;
  CMTimeEpoch v43;
  __int128 v44;
  __n128 v45;
  double v46;
  double v47;
  double v48;
  int32_t v49;
  CMTime *v50;
  CMTime v51;
  CMTime v52;
  CMTime v53;
  CMTime time;
  CMTime v55;
  CMTime v56;
  CMTime v57;
  CMTime v58;
  CMTime v59;
  CMTime v60;
  CMTime v61;
  CMTime v62;
  CMTime v63;
  CMTime v64;
  CMTime v65;
  CMTime v66;
  CMTime v67;
  CMTime v68;
  CMTime v69;
  CMTime time2;
  CMTime time1;

  memset(&v66, 0, sizeof(v66));
  v12 = (const CMTime *)MEMORY[0x1E0CA2E68];
  OZSpline::getMaxValueU(this, MEMORY[0x1E0CA2E68], 0, (uint64_t)&v66);
  memset(&v65, 0, sizeof(v65));
  OZSpline::getMinValueU(this, v12, 0, (uint64_t)&v65);
  memset(&v64, 0, sizeof(v64));
  time1 = v66;
  time2 = v65;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v64);
  time1 = v66;
  time2 = v65;
  if (CMTimeCompare(&time1, &time2))
  {
    v13 = *((_QWORD *)this + 21);
    if (!a6)
    {
      switch(*(_DWORD *)(v13 + 36))
      {
        case 0:
          memset(&v69, 0, sizeof(v69));
          OZSpline::getStep(this, &v69);
          if (!*(_BYTE *)(*((_QWORD *)this + 21) + 4))
            goto LABEL_4;
          time1 = v64;
          time2 = v69;
          if (CMTimeCompare(&time1, &time2) < 0)
            goto LABEL_4;
          memset(&v68, 0, sizeof(v68));
          time1 = *(CMTime *)(a2 + 16);
          time2 = v69;
          v15.n128_f64[0] = PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v68);
          v14 = (*(double (**)(OZSpline *, CMTime *, const CMTime *, _QWORD, __n128))(*(_QWORD *)this + 240))(this, &v68, a3, 0, v15);
          goto LABEL_56;
        case 1:
          if (!(*(unsigned int (**)(char *))(*(_QWORD *)a2 + 208))(a2))
            goto LABEL_4;
          memset(&v69, 0, sizeof(v69));
          v68 = *(CMTime *)(a2 + 16);
          if (**((_BYTE **)this + 21))
            v33 = 1;
          else
            v33 = 100;
          CMTimeMake(&v67, 1, v33);
          time1 = v68;
          time2 = v67;
          v34 = PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v69);
          v35 = (*(double (**)(char *, const CMTime *, double))(*(_QWORD *)a2 + 24))(a2, a3, v34);
          v36 = v35
              - (*(double (**)(OZSpline *, CMTime *, const CMTime *, _QWORD))(*(_QWORD *)this + 240))(this, &v69, a3, 0);
          if (**((_BYTE **)this + 21))
            v37 = 1;
          else
            v37 = 100;
          CMTimeMake(&v63, 1, v37);
          Seconds = CMTimeGetSeconds(&v63);
          if (Seconds == 0.0)
            v39 = dbl_1B3556840[v36 > 0.0];
          else
            v39 = v36 / Seconds;
          time2 = *(CMTime *)(a2 + 16);
          time1 = *a4;
          PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v68);
          operator*(&v68, &v62, v39);
          v23 = &v62;
LABEL_34:
          v40 = CMTimeGetSeconds(v23);
          (*(void (**)(char *, const CMTime *))(*(_QWORD *)a2 + 24))(a2, a3);
          goto LABEL_42;
        case 2:
          memset(&v68, 0, sizeof(v68));
          OZSpline::getStep(this, &v68);
          if (!*(_BYTE *)(*((_QWORD *)this + 21) + 4)
            || (time1 = v64, time2 = v68, CMTimeCompare(&time1, &time2) < 0))
          {
            memset(&v69, 0, sizeof(v69));
            time1 = *a4;
            time2 = v65;
            PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v67);
            operator/((__int128 *)&v67.value, (uint64_t)&v64, (uint64_t)&v69);
            v56 = v69;
            if (((uint64_t)CMTimeGetSeconds(&v56) & 1) != 0)
            {
              CMTimeMake(&v60, 1, 1);
              time1 = v69;
              time2 = v60;
              PC_CMTimeFloorToSampleDuration(&time1, &time2, (uint64_t)&v61);
              time1 = v69;
              time2 = v61;
              PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v67);
              v69 = v67;
              operator*((__int128 *)&v69.value, (uint64_t)&v64, (uint64_t)&v61);
              time1 = v66;
              time2 = v61;
              PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v67);
            }
            else
            {
              CMTimeMake(&v60, 1, 1);
              time1 = v69;
              time2 = v60;
              PC_CMTimeFloorToSampleDuration(&time1, &time2, (uint64_t)&v61);
              time1 = v69;
              time2 = v61;
              PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v67);
              v69 = v67;
              operator*((__int128 *)&v69.value, (uint64_t)&v64, (uint64_t)&v61);
              time1 = v61;
              time2 = v65;
              PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v67);
            }
            v69 = v67;
            PCMath::clamp(&v69, &v65, &v66, (uint64_t)&time1);
            v24 = *(__n128 *)&time1.value;
            *(_OWORD *)&v69.value = *(_OWORD *)&time1.value;
            epoch = time1.epoch;
LABEL_54:
            v69.epoch = epoch;
LABEL_55:
            v14 = (*(double (**)(OZSpline *, CMTime *, const CMTime *, _QWORD, __n128))(*(_QWORD *)this
                                                                                                 + 240))(this, &v69, a3, 0, v24);
          }
          else
          {
            time1 = v64;
            time2 = v68;
            if (CMTimeCompare(&time1, &time2) <= 0)
            {
              *(_OWORD *)&v67.value = *(_OWORD *)&v12->value;
              v42 = v12->epoch;
            }
            else
            {
              time1 = v65;
              time2 = v64;
              PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v69);
              time1 = *a4;
              time2 = v69;
              PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v67);
              memset(&v61, 0, sizeof(v61));
              time1 = v64;
              time2 = v68;
              PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v61);
              operator*(&v61, &time2, 2.0);
              PCMath::mod((PCMath *)&v67, &time2, &time1);
              v67 = time1;
              time2 = v61;
              if (CMTimeCompare(&time1, &time2) < 0)
              {
                time1 = v67;
                time2 = v68;
                PC_CMTimeFloorToSampleDuration(&time1, &time2, (uint64_t)&v57);
                operator*(&v57, 2, &v58);
                time1 = v61;
                time2 = v58;
                PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v59);
                time1 = v59;
                time2 = v68;
                PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v60);
                time2 = v67;
                v69 = v60;
                PC_CMTimeSaferAdd(&time2, &v69, (uint64_t)&time1);
                *(_OWORD *)&v67.value = *(_OWORD *)&time1.value;
                v42 = time1.epoch;
              }
              else
              {
                time1 = v67;
                time2 = v61;
                PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v60);
                time1 = v60;
                time2 = v68;
                PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v69);
                *(_OWORD *)&v67.value = *(_OWORD *)&v69.value;
                v42 = v69.epoch;
              }
            }
            v67.epoch = v42;
            *(_OWORD *)&time2.value = *(_OWORD *)&v67.value;
            time2.epoch = v42;
            v69 = v65;
            PC_CMTimeSaferAdd(&time2, &v69, (uint64_t)&time1);
            v67 = time1;
            v14 = (*(double (**)(OZSpline *, CMTime *, const CMTime *, _QWORD, __n128))(*(_QWORD *)this
                                                                                                 + 240))(this, &v67, a3, 0, *(__n128 *)&time1.value);
          }
          goto LABEL_56;
        case 3:
          memset(&v61, 0, sizeof(v61));
          time1 = *a4;
          time2 = v65;
          PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v59);
          memset(&v60, 0, sizeof(v60));
          operator/((__int128 *)&v59.value, (uint64_t)&v64, (uint64_t)&v60);
          CMTimeMake(&v67, 1, 1);
          time1 = v60;
          time2 = v67;
          PC_CMTimeFloorToSampleDuration(&time1, &time2, (uint64_t)&v68);
          time1 = v60;
          time2 = v68;
          PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v69);
          operator*((__int128 *)&v69.value, (uint64_t)&v64, (uint64_t)&time1);
          v60 = time1;
          v43 = time1.epoch;
          v44 = *(_OWORD *)&time1.value;
          time1 = v65;
          *(_OWORD *)&time2.value = v44;
          time2.epoch = v43;
          v45.n128_f64[0] = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v61);
          v14 = (*(double (**)(OZSpline *, CMTime *, const CMTime *, _QWORD, __n128))(*(_QWORD *)this + 240))(this, &v61, a3, 0, v45);
          goto LABEL_56;
        case 4:
          memset(&v69, 0, sizeof(v69));
          time1 = *a4;
          time2 = v65;
          PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v68);
          operator/((__int128 *)&v68.value, (uint64_t)&v64, (uint64_t)&v69);
          v55 = v69;
          v46 = CMTimeGetSeconds(&v55);
          CMTimeMake(&v67, (uint64_t)v46, 1);
          time1 = v69;
          time2 = v67;
          PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v68);
          v69 = v68;
          operator*((__int128 *)&v69.value, (uint64_t)&v64, (uint64_t)&v67);
          time1 = v67;
          time2 = v65;
          PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v68);
          v69 = v68;
          v47 = (double)(uint64_t)v46;
          v48 = (*(double (**)(char *, const CMTime *))(*(_QWORD *)a2 + 24))(a2, a3);
          v40 = (v48
               - (*(double (**)(OZSpline *, CMTime *, _QWORD, _QWORD))(*(_QWORD *)this + 240))(this, &v65, MEMORY[0x1E0CA2E68], 0))* v47;
          v41 = (*(double (**)(OZSpline *, CMTime *, const CMTime *, _QWORD))(*(_QWORD *)this + 240))(this, &v69, a3, 0);
LABEL_42:
          v14 = v40 + v41;
          goto LABEL_56;
        default:
          return;
      }
    }
    switch(*(_DWORD *)(v13 + 40))
    {
      case 0:
        goto LABEL_4;
      case 1:
        memset(&v69, 0, sizeof(v69));
        v68 = *(CMTime *)(a2 + 16);
        if (*(_BYTE *)v13)
          v16 = 1;
        else
          v16 = 100;
        CMTimeMake(&v67, 1, v16);
        time1 = v68;
        time2 = v67;
        v17 = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v69);
        v18 = (*(double (**)(OZSpline *, CMTime *, const CMTime *, _QWORD, double))(*(_QWORD *)this + 240))(this, &v69, a3, 0, v17);
        v19 = v18 - (*(double (**)(char *, const CMTime *))(*(_QWORD *)a2 + 24))(a2, a3);
        if (**((_BYTE **)this + 21))
          v20 = 1;
        else
          v20 = 100;
        CMTimeMake(&time, 1, v20);
        v21 = CMTimeGetSeconds(&time);
        if (v21 == 0.0)
          v22 = dbl_1B3556830[v19 < 0.0];
        else
          v22 = v19 / v21;
        time2 = *(CMTime *)(a2 + 16);
        time1 = *a4;
        PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v68);
        operator*(&v68, &v53, v22);
        v23 = &v53;
        goto LABEL_34;
      case 2:
        memset(&v69, 0, sizeof(v69));
        time1 = v65;
        time2 = *a4;
        PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v68);
        operator/((__int128 *)&v68.value, (uint64_t)&v64, (uint64_t)&v69);
        v52 = v69;
        if (((uint64_t)CMTimeGetSeconds(&v52) & 1) != 0)
        {
          CMTimeMake(&v61, 1, 1);
          time1 = v69;
          time2 = v61;
          PC_CMTimeFloorToSampleDuration(&time1, &time2, (uint64_t)&v67);
          time1 = v69;
          time2 = v67;
          PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v68);
          v69 = v68;
          operator*((__int128 *)&v69.value, (uint64_t)&v64, (uint64_t)&v67);
          time1 = v66;
          time2 = v67;
          PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v68);
        }
        else
        {
          CMTimeMake(&v61, 1, 1);
          time1 = v69;
          time2 = v61;
          PC_CMTimeFloorToSampleDuration(&time1, &time2, (uint64_t)&v67);
          time1 = v69;
          time2 = v67;
          PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v68);
          v69 = v68;
          operator*((__int128 *)&v69.value, (uint64_t)&v64, (uint64_t)&v67);
          time1 = v67;
          time2 = v65;
          PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v68);
        }
        v69 = v68;
        time1 = v68;
        time2 = v65;
        if (CMTimeCompare(&time1, &time2) < 0)
        {
          v50 = &v65;
        }
        else
        {
          time1 = v69;
          time2 = v66;
          v49 = CMTimeCompare(&time1, &time2);
          v50 = &v69;
          if (v49 > 0)
            v50 = &v66;
        }
        v24 = *(__n128 *)&v50->value;
        v69.epoch = v50->epoch;
        *(__n128 *)&v69.value = v24;
        goto LABEL_55;
      case 3:
        memset(&v69, 0, sizeof(v69));
        time1 = v65;
        time2 = *a4;
        PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v68);
        operator/((__int128 *)&v68.value, (uint64_t)&v64, (uint64_t)&v69);
        CMTimeMake(&v61, 1, 1);
        time1 = v69;
        time2 = v61;
        PC_CMTimeFloorToSampleDuration(&time1, &time2, (uint64_t)&v67);
        time1 = v69;
        time2 = v67;
        PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v68);
        v69 = v68;
        operator*((__int128 *)&v69.value, (uint64_t)&v64, (uint64_t)&v67);
        time1 = v66;
        time2 = v67;
        PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v68);
        v24 = *(__n128 *)&v68.value;
        *(_OWORD *)&v69.value = *(_OWORD *)&v68.value;
        epoch = v68.epoch;
        goto LABEL_54;
      case 4:
        memset(&v69, 0, sizeof(v69));
        time1 = v65;
        time2 = *a4;
        PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v68);
        operator/((__int128 *)&v68.value, (uint64_t)&v64, (uint64_t)&v69);
        v51 = v69;
        v26 = CMTimeGetSeconds(&v51);
        CMTimeMake(&v67, (uint64_t)v26, 1);
        time1 = v69;
        time2 = v67;
        PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v68);
        v69 = v68;
        operator*((__int128 *)&v69.value, (uint64_t)&v64, (uint64_t)&v67);
        time1 = v66;
        time2 = v67;
        PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v68);
        v69 = v68;
        v27 = MEMORY[0x1E0CA2E68];
        v28 = (*(double (**)(OZSpline *, CMTime *, _QWORD, _QWORD))(*(_QWORD *)this + 240))(this, &v66, MEMORY[0x1E0CA2E68], 0);
        v29 = v28 - (*(double (**)(char *, uint64_t))(*(_QWORD *)a2 + 24))(a2, v27);
        v30 = (double)(uint64_t)v26;
        v31 = (*(double (**)(OZSpline *, CMTime *, uint64_t, _QWORD))(*(_QWORD *)this + 240))(this, &v66, v27, 0);
        v32 = v29 + (v31 - (*(double (**)(char *, const CMTime *))(*(_QWORD *)a2 + 24))(a2, a3)) * v30;
        v14 = (*(double (**)(OZSpline *, CMTime *, const CMTime *, _QWORD))(*(_QWORD *)this + 240))(this, &v69, a3, 0)- v32;
        goto LABEL_56;
      default:
        return;
    }
  }
  else
  {
LABEL_4:
    (*(void (**)(char *, const CMTime *))(*(_QWORD *)a2 + 24))(a2, a3);
LABEL_56:
    *a5 = v14;
  }
}

void OZSpline::interpolate(OZSpline *this, const CMTime *a2, void *a3, void *a4, const CMTime *a5, double *a6, uint64_t a7)
{
  uint64_t v14;
  uint64_t Interpolator;
  int v16;

  v14 = *((_QWORD *)this + 20);
  if (!v14
    || (Interpolator = *(_QWORD *)(v14 + 40)) == 0
    || !(*(unsigned int (**)(uint64_t, OZSpline *, void *))(*(_QWORD *)Interpolator + 112))(Interpolator, this, a3))
  {
    v16 = (*(uint64_t (**)(void *))(*(_QWORD *)a3 + 208))(a3);
    Interpolator = OZInterpolators::getInterpolator(*((OZInterpolators **)this + 19), v16);
    if ((*(unsigned int (**)(uint64_t, OZSpline *))(*(_QWORD *)Interpolator + 88))(Interpolator, this))
      (*(void (**)(uint64_t, OZSpline *, const CMTime *))(*(_QWORD *)Interpolator + 16))(Interpolator, this, a2);
  }
  *a6 = (*(double (**)(uint64_t, OZSpline *, const CMTime *, void *, void *, const CMTime *, _QWORD, uint64_t))(*(_QWORD *)Interpolator + 24))(Interpolator, this, a2, a3, a4, a5, **((unsigned __int8 **)this + 21), a7);
}

double OZSpline::getDerivativeValue(OZSpline *this, const CMTime *a2, const CMTime *a3, int a4)
{
  uint64_t v8;
  os_unfair_lock_s *v9;
  uint64_t v10;
  os_unfair_lock_s *v11;
  int32_t v12;
  double result;
  void **v14;
  unint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  os_unfair_lock_s *v20;
  CMTimeEpoch v21;
  CMTimeEpoch v22;
  void **v23;
  CMTime v24;
  double v25;
  void *v26;
  CMTime time2;
  CMTime time1;

  v25 = 0.0;
  v26 = 0;
  if (a4)
  {
    v8 = *((_QWORD *)this + 20);
    if (!v8 || (v9 = *(os_unfair_lock_s **)(v8 + 48)) == 0)
      v9 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::lock(v9);
    if (*((_QWORD *)this + 2) == *((_QWORD *)this + 3))
    {
      v10 = *((_QWORD *)this + 20);
      if (!v10 || (v11 = *(os_unfair_lock_s **)(v10 + 48)) == 0)
        v11 = (os_unfair_lock_s *)((char *)this + 8);
      PCSpinLock::unlock(v11);
      return 0.0;
    }
  }
  else if (*((_QWORD *)this + 2) == *((_QWORD *)this + 3))
  {
    return 0.0;
  }
  OZSpline::getMinValueU(this, MEMORY[0x1E0CA2E68], 0, (uint64_t)&v24);
  time1 = *a2;
  time2 = v24;
  if (CMTimeCompare(&time1, &time2) < 0)
    return 0.0;
  memset(&v24, 0, sizeof(v24));
  OZSpline::getMaxValueU(this, MEMORY[0x1E0CA2E68], 0, (uint64_t)&v24);
  time1 = *a2;
  time2 = v24;
  v12 = CMTimeCompare(&time1, &time2);
  result = 0.0;
  if (v12 <= 0)
  {
    v14 = (void **)*((_QWORD *)this + 5);
    v23 = v14;
    v15 = *((_QWORD *)this + 17);
    if (v15 < (uint64_t)(*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 3)
    {
      v14 += v15;
      v23 = v14;
    }
    v16 = *((_OWORD *)*v14 + 1);
    v21 = *((_QWORD *)*v14 + 4);
    time1 = *a2;
    *(_OWORD *)&time2.value = v16;
    time2.epoch = v21;
    if (CMTimeCompare(&time1, &time2) < 0)
    {
      *((_QWORD *)this + 17) = 0;
      v14 = (void **)*((_QWORD *)this + 5);
      v23 = v14;
    }
    if (v14 == *((void ***)this + 6))
    {
      v17 = *((_QWORD *)this + 17);
    }
    else
    {
      while (1)
      {
        v22 = *((_QWORD *)*v14 + 4);
        *(_OWORD *)&time1.value = *((_OWORD *)*v14 + 1);
        time1.epoch = v22;
        time2 = *a2;
        if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0
          && (*(unsigned int (**)(void *, const CMTime *))(*(_QWORD *)*v14 + 136))(*v14, a3)
          && OZSpline::getPreviousValidVertex(this, &v23, &v26, (uint64_t)a3)
          && *v14)
        {
          break;
        }
        v23 = ++v14;
        v17 = *((_QWORD *)this + 17) + 1;
        *((_QWORD *)this + 17) = v17;
        if (v14 == *((void ***)this + 6))
          goto LABEL_27;
      }
      OZSpline::interpolate(this, a3, v26, *v14, a2, &v25, 1);
      v17 = *((_QWORD *)this + 17) + 1;
    }
LABEL_27:
    if (v17 <= 0)
      v18 = 0;
    else
      v18 = v17 - 1;
    *((_QWORD *)this + 17) = v18;
    if (a4)
    {
      v19 = *((_QWORD *)this + 20);
      if (!v19 || (v20 = *(os_unfair_lock_s **)(v19 + 48)) == 0)
        v20 = (os_unfair_lock_s *)((char *)this + 8);
      PCSpinLock::unlock(v20);
    }
    return v25;
  }
  return result;
}

uint64_t OZSpline::isDirty(OZSpline *this)
{
  return *((unsigned __int8 *)this + 145);
}

void OZSpline::reserveMemoryForKeypoints(void **this, int a2)
{
  if (a2)
    std::vector<void *>::reserve(this + 2, a2);
}

uint64_t OZSpline::sampleSpline(OZSpline *this, const CMTime *a2, CMTime *a3, int32_t *a4, CMTime *a5, double *a6, const CMTime *a7, char a8)
{
  uint64_t v16;
  os_unfair_lock_s *v17;
  uint64_t Interpolator;
  double v19;
  __int128 v20;
  unsigned int v21;
  double v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  void **v27;
  void **v28;
  void *v29;
  void *v30;
  __int128 v31;
  unsigned int v32;
  const CMTime *v33;
  __int128 v34;
  double v35;
  double v36;
  double v37;
  double v38;
  unsigned int v39;
  __int128 v40;
  __int128 v41;
  int v42;
  double Seconds;
  unsigned int v44;
  unsigned int v45;
  double v46;
  __int128 v47;
  uint64_t v48;
  os_unfair_lock_s *v49;
  CMTime v51;
  CMTime time;
  void *v53;
  void *v54;
  CMTime v55;
  CMTime v56;
  CMTime v57;
  CMTime v58;
  CMTime v59;
  int v60;
  CMTime time2;
  CMTime time1;

  v60 = 0;
  v16 = *((_QWORD *)this + 20);
  if (!v16 || (v17 = *(os_unfair_lock_s **)(v16 + 48)) == 0)
    v17 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v17);
  (*(void (**)(OZSpline *, int *, _QWORD, _QWORD))(*(_QWORD *)this + 16))(this, &v60, 0, 0);
  if (**((_BYTE **)this + 21))
  {
    Interpolator = OZInterpolators::getInterpolator(*((OZInterpolators **)this + 19), v60);
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)Interpolator + 64))(Interpolator) & 1) == 0)
    {
      memset(&v59, 0, sizeof(v59));
      operator*(a3, *a4, &v59);
      memset(&v58, 0, sizeof(v58));
      time1 = *a2;
      time2 = v59;
      PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v58);
      v24 = OZInterpolators::getInterpolator(*((OZInterpolators **)this + 19), v60);
      (*(void (**)(CMTime *__return_ptr, uint64_t, OZSpline *, const CMTime *, CMTime *))(*(_QWORD *)v24 + 72))(&time1, v24, this, a7, &v58);
      v58 = time1;
      memset(&v57, 0, sizeof(v57));
      v25 = OZInterpolators::getInterpolator(*((OZInterpolators **)this + 19), v60);
      (*(void (**)(CMTime *__return_ptr, uint64_t, OZSpline *, const CMTime *, const CMTime *))(*(_QWORD *)v25 + 80))(&v57, v25, this, a7, a2);
      memset(&v56, 0, sizeof(v56));
      time1 = v58;
      time2 = v57;
      PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v55);
      operator*(&v55, &v56, 1.0 / (double)(*a4 - 1));
      if (*a4)
      {
        v26 = 0;
        do
        {
          operator*(&v56, v26, &time1);
          v59 = time1;
          if (a6)
          {
            v28 = (void **)*((_QWORD *)this + 2);
            v27 = (void **)*((_QWORD *)this + 3);
            if (v28 == v27)
            {
              v29 = 0;
              v30 = 0;
            }
            else
            {
              v29 = *v28;
              v30 = *(v27 - 1);
            }
            time1 = v57;
            time2 = v59;
            PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v55);
            OZSpline::interpolate(this, a7, v29, v30, &v55, a6++, 0);
          }
          if (a5)
          {
            time1 = v57;
            time2 = v59;
            PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v55);
            v31 = *(_OWORD *)&v55.value;
            a5->epoch = v55.epoch;
            *(_OWORD *)&a5->value = v31;
            ++a5;
          }
          ++v26;
        }
        while (v26 < *a4);
      }
      goto LABEL_75;
    }
  }
  if ((a8 & 1) == 0)
  {
    if (*a4)
    {
      v21 = 0;
      do
      {
        memset(&v59, 0, sizeof(v59));
        operator*(a3, v21, &v59);
        if (a6)
        {
          time1 = *a2;
          time2 = v59;
          v22 = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v58);
          *a6++ = (*(double (**)(OZSpline *, CMTime *, const CMTime *, _QWORD, double))(*(_QWORD *)this
                                                                                                 + 240))(this, &v58, a7, 0, v22);
        }
        if (a5)
        {
          time1 = *a2;
          time2 = v59;
          PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v58);
          v23 = *(_OWORD *)&v58.value;
          a5->epoch = v58.epoch;
          *(_OWORD *)&a5->value = v23;
          ++a5;
        }
        ++v21;
      }
      while (v21 < *a4);
    }
    goto LABEL_75;
  }
  if (OZSpline::getNumberOfValidVertices(this, a7) > 1)
  {
    v53 = 0;
    v54 = 0;
    v59 = *a2;
    v58 = v59;
    operator*(a3, *a4, &v56);
    time1 = *a2;
    time2 = v56;
    PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v57);
    time1 = v58;
    time2 = v57;
    v32 = 0;
    if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
    {
LABEL_74:
      *a4 = v32;
      goto LABEL_75;
    }
    v33 = (const CMTime *)MEMORY[0x1E0CA2E68];
    while (1)
    {
      if (!OZSpline::getNextValidVertex(this, &v59, &v53, v33, 0))
        goto LABEL_40;
      v34 = *((_OWORD *)v53 + 1);
      v58.epoch = *((_QWORD *)v53 + 4);
      *(_OWORD *)&v58.value = v34;
      *(_OWORD *)&time1.value = v34;
      time1.epoch = v58.epoch;
      time2 = v57;
      if (CMTimeCompare(&time1, &time2) >= 1)
      {
        time1 = v58;
        time2 = v57;
        PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v56);
        time1 = v56;
        time2 = *a3;
        if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
LABEL_40:
          v58 = v57;
      }
      if (!OZSpline::getVertexHandle(this, &v59, &v54, 0)
        && !OZSpline::getPreviousValidVertex(this, &v59, &v54, v33, 0))
      {
        break;
      }
      if (!v53)
      {
        v39 = *(_DWORD *)(*((_QWORD *)this + 21) + 36);
LABEL_54:
        if (v39 < 2)
          goto LABEL_55;
        goto LABEL_66;
      }
      time1.value = 0;
      time2.value = 0;
      v56.value = 0;
      v55.value = 0;
      (*(void (**)(OZSpline *, void *, CMTime *, CMTime *, const CMTime *, _QWORD))(*(_QWORD *)this + 128))(this, v53, &time1, &time2, v33, 0);
      (*(void (**)(OZSpline *, void *, CMTime *, CMTime *, const CMTime *, _QWORD))(*(_QWORD *)this + 136))(this, v54, &v56, &v55, v33, 0);
      v35 = *(double *)&time1.value;
      v36 = *(double *)&time2.value;
      v37 = *(double *)&v56.value;
      v38 = *(double *)&v55.value;
      if ((*(unsigned int (**)(void *))(*(_QWORD *)v54 + 208))(v54) == 1
        || (*(unsigned int (**)(void *))(*(_QWORD *)v54 + 208))(v54) == 4
        && fabs(v35) < 0.0000001
        && fabs(v36) < 0.0000001
        && fabs(v37) < 0.0000001
        && fabs(v38) < 0.0000001)
      {
LABEL_55:
        if (a6)
        {
          if (!v32)
            *a6++ = (*(double (**)(OZSpline *, CMTime *, const CMTime *, _QWORD))(*(_QWORD *)this + 240))(this, &v59, a7, 0);
          *a6++ = (*(double (**)(OZSpline *, CMTime *, const CMTime *, _QWORD))(*(_QWORD *)this + 240))(this, &v58, a7, 0);
        }
        if (a5)
        {
          if (!v32)
          {
            v40 = *(_OWORD *)&v59.value;
            a5->epoch = v59.epoch;
            *(_OWORD *)&a5->value = v40;
            ++a5;
          }
          v41 = *(_OWORD *)&v58.value;
          a5->epoch = v58.epoch;
          *(_OWORD *)&a5->value = v41;
          ++a5;
        }
        if (v32)
          v42 = 1;
        else
          v42 = 2;
        goto LABEL_73;
      }
LABEL_66:
      time1 = v58;
      time2 = v59;
      PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&time);
      Seconds = CMTimeGetSeconds(&time);
      v51 = *a3;
      v44 = (Seconds / CMTimeGetSeconds(&v51));
      v45 = v32 != 0;
      v42 = v44 - v45;
      if (v44 > v45)
      {
        do
        {
          memset(&v56, 0, sizeof(v56));
          operator*(a3, v45, &v56);
          if (a6)
          {
            time1 = v59;
            time2 = v56;
            v46 = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v55);
            *a6++ = (*(double (**)(OZSpline *, CMTime *, const CMTime *, _QWORD, double))(*(_QWORD *)this + 240))(this, &v55, a7, 0, v46);
          }
          if (a5)
          {
            time1 = v59;
            time2 = v56;
            PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v55);
            v47 = *(_OWORD *)&v55.value;
            a5->epoch = v55.epoch;
            *(_OWORD *)&a5->value = v47;
            ++a5;
          }
          ++v45;
        }
        while (v44 != v45);
      }
      v33 = (const CMTime *)MEMORY[0x1E0CA2E68];
LABEL_73:
      v32 += v42;
      v59 = v58;
      time1 = v58;
      time2 = v57;
      if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
        goto LABEL_74;
    }
    if (!v53)
      goto LABEL_66;
    v39 = *(_DWORD *)(*((_QWORD *)this + 21) + 40);
    goto LABEL_54;
  }
  if (a6)
  {
    *a6 = (*(double (**)(OZSpline *, const CMTime *, const CMTime *, _QWORD))(*(_QWORD *)this + 240))(this, a2, a7, 0);
    if (*a4 >= 2)
    {
      operator*(a3, *a4 - 1, &v58);
      time1 = *a2;
      time2 = v58;
      v19 = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v59);
      a6[1] = (*(double (**)(OZSpline *, CMTime *, const CMTime *, _QWORD, double))(*(_QWORD *)this + 240))(this, &v59, a7, 0, v19);
    }
  }
  if (a5)
  {
    v20 = *(_OWORD *)&a2->value;
    a5->epoch = a2->epoch;
    *(_OWORD *)&a5->value = v20;
    if (*a4 < 2)
      goto LABEL_75;
    operator*(a3, *a4 - 1, &v58);
    time1 = *a2;
    time2 = v58;
    PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v59);
    a5[1] = v59;
  }
  if (*a4 >= 2)
    *a4 = 2;
LABEL_75:
  v48 = *((_QWORD *)this + 20);
  if (!v48 || (v49 = *(os_unfair_lock_s **)(v48 + 48)) == 0)
    v49 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v49);
  return 1;
}

uint64_t OZSpline::sampleSplineDerivatives(OZSpline *this, const CMTime *a2, CMTime *a3, unsigned int *a4, CMTime *a5, double *a6, const CMTime *a7)
{
  uint64_t v14;
  os_unfair_lock_s *v15;
  unsigned int v16;
  double v17;
  __int128 v18;
  uint64_t v19;
  os_unfair_lock_s *v20;
  __int128 v22;
  CMTimeEpoch v23;
  CMTime v24;
  int v25;
  CMTime v26;
  CMTime v27;

  v25 = 0;
  v14 = *((_QWORD *)this + 20);
  if (!v14 || (v15 = *(os_unfair_lock_s **)(v14 + 48)) == 0)
    v15 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v15);
  (*(void (**)(OZSpline *, int *, _QWORD, _QWORD))(*(_QWORD *)this + 16))(this, &v25, 0, 0);
  if (*a4)
  {
    v16 = 0;
    do
    {
      memset(&v24, 0, sizeof(v24));
      operator*(a3, v16, &v24);
      if (a6)
      {
        v27 = *a2;
        v26 = v24;
        v17 = PC_CMTimeSaferAdd(&v27, &v26, (uint64_t)&v22);
        *a6++ = (*(double (**)(OZSpline *, __int128 *, const CMTime *, _QWORD, double))(*(_QWORD *)this
                                                                                                 + 248))(this, &v22, a7, 0, v17);
      }
      if (a5)
      {
        v27 = *a2;
        v26 = v24;
        PC_CMTimeSaferAdd(&v27, &v26, (uint64_t)&v22);
        v18 = v22;
        a5->epoch = v23;
        *(_OWORD *)&a5->value = v18;
        ++a5;
      }
      ++v16;
    }
    while (v16 < *a4);
  }
  v19 = *((_QWORD *)this + 20);
  if (!v19 || (v20 = *(os_unfair_lock_s **)(v19 + 48)) == 0)
    v20 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v20);
  return 1;
}

uint64_t OZSpline::sampleSplineDerivatives(os_unfair_lock_s *a1, CMTime *a2, CMTime *a3, unsigned int *a4, void **a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14;
  os_unfair_lock_s *v15;
  unsigned int v16;
  double v17;
  double v18;
  double v19;
  unint64_t v20;
  double *v21;
  double *v22;
  double *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  double *v29;
  uint64_t v30;
  char *v31;
  char *v32;
  __int128 v33;
  char *v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  __int128 v41;
  char *v42;
  char *v43;
  char *v44;
  __int128 v45;
  uint64_t v46;
  os_unfair_lock_s *v47;
  __int128 v49;
  uint64_t v50;
  CMTime v51;
  int v52;
  CMTime v53;
  CMTime v54;

  v52 = 0;
  v14 = *(_QWORD *)&a1[40]._os_unfair_lock_opaque;
  if (!v14 || (v15 = *(os_unfair_lock_s **)(v14 + 48)) == 0)
    v15 = a1 + 2;
  PCSpinLock::lock(v15);
  (*(void (**)(os_unfair_lock_s *, int *, _QWORD, _QWORD))(*(_QWORD *)&a1->_os_unfair_lock_opaque + 16))(a1, &v52, 0, 0);
  if (*a4)
  {
    v16 = 0;
    do
    {
      memset(&v51, 0, sizeof(v51));
      operator*(a3, v16, &v51);
      if (a6)
      {
        v54 = *a2;
        v53 = v51;
        v17 = PC_CMTimeSaferAdd(&v54, &v53, (uint64_t)&v49);
        v18 = (*(double (**)(os_unfair_lock_s *, __int128 *, uint64_t, _QWORD, double))(*(_QWORD *)&a1->_os_unfair_lock_opaque
                                                                                                + 248))(a1, &v49, a7, 0, v17);
        v19 = v18;
        v21 = *(double **)(a6 + 8);
        v20 = *(_QWORD *)(a6 + 16);
        if ((unint64_t)v21 >= v20)
        {
          v23 = *(double **)a6;
          v24 = ((uint64_t)v21 - *(_QWORD *)a6) >> 3;
          v25 = v24 + 1;
          if ((unint64_t)(v24 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v26 = v20 - (_QWORD)v23;
          if (v26 >> 2 > v25)
            v25 = v26 >> 2;
          if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8)
            v27 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v27 = v25;
          if (v27)
          {
            v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a6 + 16, v27);
            v23 = *(double **)a6;
            v21 = *(double **)(a6 + 8);
          }
          else
          {
            v28 = 0;
          }
          v29 = (double *)&v28[8 * v24];
          *v29 = v19;
          v22 = v29 + 1;
          while (v21 != v23)
          {
            v30 = *((_QWORD *)v21-- - 1);
            *((_QWORD *)v29-- - 1) = v30;
          }
          *(_QWORD *)a6 = v29;
          *(_QWORD *)(a6 + 8) = v22;
          *(_QWORD *)(a6 + 16) = &v28[8 * v27];
          if (v23)
            operator delete(v23);
        }
        else
        {
          *v21 = v18;
          v22 = v21 + 1;
        }
        *(_QWORD *)(a6 + 8) = v22;
      }
      if (a5)
      {
        v54 = *a2;
        v53 = v51;
        PC_CMTimeSaferAdd(&v54, &v53, (uint64_t)&v49);
        v32 = (char *)a5[1];
        v31 = (char *)a5[2];
        if (v32 >= v31)
        {
          v35 = 0xAAAAAAAAAAAAAAABLL * ((v32 - (_BYTE *)*a5) >> 3);
          v36 = v35 + 1;
          if (v35 + 1 > 0xAAAAAAAAAAAAAAALL)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v37 = 0xAAAAAAAAAAAAAAABLL * ((v31 - (_BYTE *)*a5) >> 3);
          if (2 * v37 > v36)
            v36 = 2 * v37;
          if (v37 >= 0x555555555555555)
            v38 = 0xAAAAAAAAAAAAAAALL;
          else
            v38 = v36;
          if (v38)
            v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a5 + 2), v38);
          else
            v39 = 0;
          v40 = &v39[24 * v35];
          v41 = v49;
          *((_QWORD *)v40 + 2) = v50;
          *(_OWORD *)v40 = v41;
          v43 = (char *)*a5;
          v42 = (char *)a5[1];
          v44 = v40;
          if (v42 != *a5)
          {
            do
            {
              v45 = *(_OWORD *)(v42 - 24);
              *((_QWORD *)v44 - 1) = *((_QWORD *)v42 - 1);
              *(_OWORD *)(v44 - 24) = v45;
              v44 -= 24;
              v42 -= 24;
            }
            while (v42 != v43);
            v42 = (char *)*a5;
          }
          v34 = v40 + 24;
          *a5 = v44;
          a5[1] = v40 + 24;
          a5[2] = &v39[24 * v38];
          if (v42)
            operator delete(v42);
        }
        else
        {
          v33 = v49;
          *((_QWORD *)v32 + 2) = v50;
          *(_OWORD *)v32 = v33;
          v34 = v32 + 24;
        }
        a5[1] = v34;
      }
      ++v16;
    }
    while (v16 < *a4);
  }
  v46 = *(_QWORD *)&a1[40]._os_unfair_lock_opaque;
  if (!v46 || (v47 = *(os_unfair_lock_s **)(v46 + 48)) == 0)
    v47 = a1 + 2;
  PCSpinLock::unlock(v47);
  return 1;
}

void std::vector<double>::push_back[abi:ne180100](uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;

  v4 = a1 + 16;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD **)(a1 + 8);
  if ((unint64_t)v6 >= v5)
  {
    v8 = *(_QWORD **)a1;
    v9 = ((uint64_t)v6 - *(_QWORD *)a1) >> 3;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v11 = v5 - (_QWORD)v8;
    if (v11 >> 2 > v10)
      v10 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v4, v12);
      v8 = *(_QWORD **)a1;
      v6 = *(_QWORD **)(a1 + 8);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[8 * v9];
    v15 = &v13[8 * v12];
    *(_QWORD *)v14 = *a2;
    v7 = v14 + 8;
    while (v6 != v8)
    {
      v16 = *--v6;
      *((_QWORD *)v14 - 1) = v16;
      v14 -= 8;
    }
    *(_QWORD *)a1 = v14;
    *(_QWORD *)(a1 + 8) = v7;
    *(_QWORD *)(a1 + 16) = v15;
    if (v8)
      operator delete(v8);
  }
  else
  {
    *v6 = *a2;
    v7 = v6 + 1;
  }
  *(_QWORD *)(a1 + 8) = v7;
}

BOOL OZSpline::sampleSplineSegments(os_unfair_lock_s *a1, CMTime *a2, CMTime *a3, CMTime *a4, char **a5, double **a6)
{
  uint64_t v12;
  os_unfair_lock_s *v13;
  int32_t v14;
  uint64_t Interpolator;
  double v16;
  double v17;
  unint64_t v18;
  double *v19;
  double *v20;
  char *v21;
  char *v22;
  __int128 v23;
  char *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char *v29;
  const CMTime *v30;
  const CMTime *v31;
  __int128 v32;
  const CMTime *v33;
  unsigned int v34;
  char *v35;
  double v36;
  double v37;
  unint64_t v38;
  double *v39;
  double *v40;
  double v41;
  int v42;
  int32_t v43;
  const CMTime *v44;
  double v45;
  double v46;
  double v47;
  unint64_t v48;
  double *v49;
  double *v50;
  double *v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  char *v56;
  char *v57;
  double *v58;
  uint64_t v59;
  char *v60;
  char *v61;
  __int128 v62;
  char *v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  char *v68;
  char *v69;
  __int128 v70;
  char *v71;
  char *v72;
  char *v73;
  __int128 v74;
  double *v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  char *v81;
  double *v82;
  uint64_t v83;
  char *v84;
  char *v85;
  __int128 v86;
  char *v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  char *v92;
  char *v93;
  __int128 v94;
  char *v95;
  char *v96;
  char *v97;
  __int128 v98;
  double v99;
  double v100;
  unint64_t v101;
  double *v102;
  double *v103;
  double *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  char *v109;
  double *v110;
  uint64_t v111;
  char *v112;
  char *v113;
  __int128 v114;
  char *v115;
  unint64_t v116;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  char *v120;
  char *v121;
  __int128 v122;
  char *v123;
  char *v124;
  char *v125;
  __int128 v126;
  char *v127;
  double Seconds;
  char *v129;
  char *v130;
  __int128 v131;
  char *v132;
  char *v133;
  __int128 v134;
  double v135;
  double v136;
  unint64_t v137;
  double *v138;
  double *v139;
  double *v140;
  uint64_t v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  char *v145;
  double *v146;
  char *v147;
  uint64_t v148;
  double *v149;
  uint64_t v150;
  unint64_t v151;
  uint64_t v152;
  unint64_t v153;
  char *v154;
  double *v155;
  char *v156;
  uint64_t v157;
  double v158;
  double v159;
  unint64_t v160;
  double *v161;
  double *v162;
  double *v163;
  uint64_t v164;
  unint64_t v165;
  uint64_t v166;
  unint64_t v167;
  char *v168;
  double *v169;
  char *v170;
  uint64_t v171;
  char *v172;
  char *v173;
  __int128 v174;
  char *v175;
  unint64_t v176;
  unint64_t v177;
  unint64_t v178;
  unint64_t v179;
  char *v180;
  char *v181;
  char *v182;
  __int128 v183;
  char *v184;
  char *v185;
  __int128 v186;
  char *v187;
  char *v188;
  __int128 v189;
  char *v190;
  unint64_t v191;
  unint64_t v192;
  unint64_t v193;
  unint64_t v194;
  char *v195;
  char *v196;
  char *v197;
  __int128 v198;
  char *v199;
  char *v200;
  __int128 v201;
  uint64_t v202;
  os_unfair_lock_s *v203;
  uint64_t v205;
  uint64_t v206;
  __int128 v207;
  uint64_t v208;
  CMTime v209;
  CMTime v210;
  CMTime time;
  CMTime v212;
  CMTime v213;
  void *v214;
  void *v215;
  CMTime v216;
  CMTime v217;
  int v218;
  CMTime time2;
  CMTime time1;

  v218 = 0;
  v12 = *(_QWORD *)&a1[40]._os_unfair_lock_opaque;
  if (!v12 || (v13 = *(os_unfair_lock_s **)(v12 + 48)) == 0)
    v13 = a1 + 2;
  PCSpinLock::lock(v13);
  a5[1] = *a5;
  a6[1] = *a6;
  (*(void (**)(os_unfair_lock_s *, int *, _QWORD, _QWORD))(*(_QWORD *)&a1->_os_unfair_lock_opaque + 16))(a1, &v218, 0, 0);
  time1 = *a3;
  time2 = *a2;
  v14 = CMTimeCompare(&time1, &time2);
  if ((v14 & 0x80000000) == 0)
  {
    time1 = *a2;
    time2 = *a3;
    if (!CMTimeCompare(&time1, &time2)
      || (time1 = *a4, time2 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68], CMTimeCompare(&time1, &time2) <= 0))
    {
      v21 = a5[2];
      v22 = a5[1];
      if (v22 >= v21)
      {
        v25 = 0xAAAAAAAAAAAAAAABLL * ((v22 - *a5) >> 3);
        v26 = v25 + 1;
        if (v25 + 1 > 0xAAAAAAAAAAAAAAALL)
          goto LABEL_252;
        v27 = 0xAAAAAAAAAAAAAAABLL * ((v21 - *a5) >> 3);
        if (2 * v27 > v26)
          v26 = 2 * v27;
        if (v27 >= 0x555555555555555)
          v28 = 0xAAAAAAAAAAAAAAALL;
        else
          v28 = v26;
        if (v28)
          v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a5 + 2), v28);
        else
          v29 = 0;
        v129 = &v29[24 * v25];
        v130 = &v29[24 * v28];
        v131 = *(_OWORD *)&a2->value;
        *((_QWORD *)v129 + 2) = a2->epoch;
        *(_OWORD *)v129 = v131;
        v24 = v129 + 24;
        v133 = *a5;
        v132 = a5[1];
        if (v132 != *a5)
        {
          do
          {
            v134 = *(_OWORD *)(v132 - 24);
            *((_QWORD *)v129 - 1) = *((_QWORD *)v132 - 1);
            *(_OWORD *)(v129 - 24) = v134;
            v129 -= 24;
            v132 -= 24;
          }
          while (v132 != v133);
          v132 = *a5;
        }
        *a5 = v129;
        a5[1] = v24;
        a5[2] = v130;
        if (v132)
          operator delete(v132);
      }
      else
      {
        v23 = *(_OWORD *)&a2->value;
        *((_QWORD *)v22 + 2) = a2->epoch;
        *(_OWORD *)v22 = v23;
        v24 = v22 + 24;
      }
      a5[1] = v24;
      v135 = (*(double (**)(os_unfair_lock_s *, CMTime *, _QWORD, _QWORD))(*(_QWORD *)&a1->_os_unfair_lock_opaque
                                                                                    + 240))(a1, a2, MEMORY[0x1E0CA2E68], 0);
      v136 = v135;
      v137 = (unint64_t)a6[2];
      v138 = a6[1];
      if ((unint64_t)v138 >= v137)
      {
        v140 = *a6;
        v141 = v138 - *a6;
        v142 = v141 + 1;
        if ((unint64_t)(v141 + 1) >> 61)
          goto LABEL_251;
        v143 = v137 - (_QWORD)v140;
        if (v143 >> 2 > v142)
          v142 = v143 >> 2;
        if ((unint64_t)v143 >= 0x7FFFFFFFFFFFFFF8)
          v144 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v144 = v142;
        if (v144)
        {
          v145 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a6 + 2), v144);
          v140 = *a6;
          v138 = a6[1];
        }
        else
        {
          v145 = 0;
        }
        v146 = (double *)&v145[8 * v141];
        v147 = &v145[8 * v144];
        *v146 = v136;
        v139 = v146 + 1;
        while (v138 != v140)
        {
          v148 = *((_QWORD *)v138-- - 1);
          *((_QWORD *)v146-- - 1) = v148;
        }
        *a6 = v146;
        a6[1] = v139;
        a6[2] = (double *)v147;
        if (v140)
          operator delete(v140);
      }
      else
      {
        *v138 = v135;
        v139 = v138 + 1;
      }
      a6[1] = v139;
      return v14 >= 0;
    }
    if (**(_BYTE **)&a1[42]._os_unfair_lock_opaque)
    {
      Interpolator = OZInterpolators::getInterpolator(*(OZInterpolators **)&a1[38]._os_unfair_lock_opaque, v218);
      if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)Interpolator + 64))(Interpolator) & 1) == 0)
      {
        time1 = *a3;
        time2 = *a2;
        PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v217);
        Seconds = CMTimeGetSeconds(&v217);
        v216 = *a4;
        LODWORD(time1.value) = (Seconds / CMTimeGetSeconds(&v216));
        (*(void (**)(os_unfair_lock_s *, CMTime *, CMTime *, CMTime *, char **, double **, _QWORD, _QWORD))(*(_QWORD *)&a1->_os_unfair_lock_opaque + 48))(a1, a2, a4, &time1, a5, a6, MEMORY[0x1E0CA2E68], 0);
        goto LABEL_246;
      }
    }
    if (OZSpline::getNumberOfValidVertices((OZSpline *)a1, MEMORY[0x1E0CA2E68]) <= 1)
    {
      v16 = (*(double (**)(os_unfair_lock_s *, CMTime *, _QWORD, _QWORD))(*(_QWORD *)&a1->_os_unfair_lock_opaque
                                                                                   + 240))(a1, a2, MEMORY[0x1E0CA2E68], 0);
      v17 = v16;
      v18 = (unint64_t)a6[2];
      v19 = a6[1];
      if ((unint64_t)v19 >= v18)
      {
        v149 = *a6;
        v150 = v19 - *a6;
        v151 = v150 + 1;
        if ((unint64_t)(v150 + 1) >> 61)
          goto LABEL_251;
        v152 = v18 - (_QWORD)v149;
        if (v152 >> 2 > v151)
          v151 = v152 >> 2;
        if ((unint64_t)v152 >= 0x7FFFFFFFFFFFFFF8)
          v153 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v153 = v151;
        if (v153)
        {
          v154 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a6 + 2), v153);
          v149 = *a6;
          v19 = a6[1];
        }
        else
        {
          v154 = 0;
        }
        v155 = (double *)&v154[8 * v150];
        v156 = &v154[8 * v153];
        *v155 = v17;
        v20 = v155 + 1;
        while (v19 != v149)
        {
          v157 = *((_QWORD *)v19-- - 1);
          *((_QWORD *)v155-- - 1) = v157;
        }
        *a6 = v155;
        a6[1] = v20;
        a6[2] = (double *)v156;
        if (v149)
          operator delete(v149);
      }
      else
      {
        *v19 = v16;
        v20 = v19 + 1;
      }
      a6[1] = v20;
      time1 = *a2;
      time2 = *a3;
      if (!CMTimeCompare(&time1, &time2))
        goto LABEL_212;
      v158 = (*(double (**)(os_unfair_lock_s *, CMTime *, _QWORD, _QWORD))(*(_QWORD *)&a1->_os_unfair_lock_opaque
                                                                                    + 240))(a1, a3, MEMORY[0x1E0CA2E68], 0);
      v159 = v158;
      v161 = a6[1];
      v160 = (unint64_t)a6[2];
      if ((unint64_t)v161 < v160)
      {
        *v161 = v158;
        v162 = v161 + 1;
LABEL_211:
        a6[1] = v162;
LABEL_212:
        v172 = a5[2];
        v173 = a5[1];
        if (v173 >= v172)
        {
          v176 = 0xAAAAAAAAAAAAAAABLL * ((v173 - *a5) >> 3);
          v177 = v176 + 1;
          if (v176 + 1 > 0xAAAAAAAAAAAAAAALL)
            goto LABEL_252;
          v178 = 0xAAAAAAAAAAAAAAABLL * ((v172 - *a5) >> 3);
          if (2 * v178 > v177)
            v177 = 2 * v178;
          if (v178 >= 0x555555555555555)
            v179 = 0xAAAAAAAAAAAAAAALL;
          else
            v179 = v177;
          if (v179)
            v180 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a5 + 2), v179);
          else
            v180 = 0;
          v181 = &v180[24 * v176];
          v182 = &v180[24 * v179];
          v183 = *(_OWORD *)&a2->value;
          *((_QWORD *)v181 + 2) = a2->epoch;
          *(_OWORD *)v181 = v183;
          v175 = v181 + 24;
          v185 = *a5;
          v184 = a5[1];
          if (v184 != *a5)
          {
            do
            {
              v186 = *(_OWORD *)(v184 - 24);
              *((_QWORD *)v181 - 1) = *((_QWORD *)v184 - 1);
              *(_OWORD *)(v181 - 24) = v186;
              v181 -= 24;
              v184 -= 24;
            }
            while (v184 != v185);
            v184 = *a5;
          }
          *a5 = v181;
          a5[1] = v175;
          a5[2] = v182;
          if (v184)
            operator delete(v184);
        }
        else
        {
          v174 = *(_OWORD *)&a2->value;
          *((_QWORD *)v173 + 2) = a2->epoch;
          *(_OWORD *)v173 = v174;
          v175 = v173 + 24;
        }
        a5[1] = v175;
        time1 = *a2;
        time2 = *a3;
        if (!CMTimeCompare(&time1, &time2))
          goto LABEL_246;
        v188 = a5[1];
        v187 = a5[2];
        if (v188 < v187)
        {
          v189 = *(_OWORD *)&a3->value;
          *((_QWORD *)v188 + 2) = a3->epoch;
          *(_OWORD *)v188 = v189;
          v190 = v188 + 24;
LABEL_245:
          a5[1] = v190;
LABEL_246:
          v202 = *(_QWORD *)&a1[40]._os_unfair_lock_opaque;
          if (!v202 || (v203 = *(os_unfair_lock_s **)(v202 + 48)) == 0)
            v203 = a1 + 2;
          PCSpinLock::unlock(v203);
          return v14 >= 0;
        }
        v191 = 0xAAAAAAAAAAAAAAABLL * ((v188 - *a5) >> 3);
        v192 = v191 + 1;
        if (v191 + 1 <= 0xAAAAAAAAAAAAAAALL)
        {
          v193 = 0xAAAAAAAAAAAAAAABLL * ((v187 - *a5) >> 3);
          if (2 * v193 > v192)
            v192 = 2 * v193;
          if (v193 >= 0x555555555555555)
            v194 = 0xAAAAAAAAAAAAAAALL;
          else
            v194 = v192;
          if (v194)
            v195 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a5 + 2), v194);
          else
            v195 = 0;
          v196 = &v195[24 * v191];
          v197 = &v195[24 * v194];
          v198 = *(_OWORD *)&a3->value;
          *((_QWORD *)v196 + 2) = a3->epoch;
          *(_OWORD *)v196 = v198;
          v190 = v196 + 24;
          v200 = *a5;
          v199 = a5[1];
          if (v199 != *a5)
          {
            do
            {
              v201 = *(_OWORD *)(v199 - 24);
              *((_QWORD *)v196 - 1) = *((_QWORD *)v199 - 1);
              *(_OWORD *)(v196 - 24) = v201;
              v196 -= 24;
              v199 -= 24;
            }
            while (v199 != v200);
            v199 = *a5;
          }
          *a5 = v196;
          a5[1] = v190;
          a5[2] = v197;
          if (v199)
            operator delete(v199);
          goto LABEL_245;
        }
LABEL_252:
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      v163 = *a6;
      v164 = v161 - *a6;
      v165 = v164 + 1;
      if (!((unint64_t)(v164 + 1) >> 61))
      {
        v166 = v160 - (_QWORD)v163;
        if (v166 >> 2 > v165)
          v165 = v166 >> 2;
        if ((unint64_t)v166 >= 0x7FFFFFFFFFFFFFF8)
          v167 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v167 = v165;
        if (v167)
        {
          v168 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a6 + 2), v167);
          v163 = *a6;
          v161 = a6[1];
        }
        else
        {
          v168 = 0;
        }
        v169 = (double *)&v168[8 * v164];
        v170 = &v168[8 * v167];
        *v169 = v159;
        v162 = v169 + 1;
        while (v161 != v163)
        {
          v171 = *((_QWORD *)v161-- - 1);
          *((_QWORD *)v169-- - 1) = v171;
        }
        *a6 = v169;
        a6[1] = v162;
        a6[2] = (double *)v170;
        if (v163)
          operator delete(v163);
        goto LABEL_211;
      }
LABEL_251:
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    v214 = 0;
    v215 = 0;
    v213 = *a2;
    v212 = v213;
    time1 = *a2;
    time2 = *a3;
    if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
    {
LABEL_152:
      v127 = a5[1];
      if (v127 != *a5 && !PCMath::equal((PCMath *)(v127 - 24), a3, MEMORY[0x1E0CA2E68], v30))
      {
        time1.value = (*(double (**)(os_unfair_lock_s *, CMTime *, _QWORD, _QWORD))(*(_QWORD *)&a1->_os_unfair_lock_opaque
                                                                                             + 240))(a1, a3, MEMORY[0x1E0CA2E68], 0);
        std::vector<double>::push_back[abi:ne180100]((uint64_t)a6, &time1);
        std::vector<CMTime>::push_back[abi:ne180100]((void **)a5, (__int128 *)&a3->value);
      }
      goto LABEL_246;
    }
    v205 = (uint64_t)(a5 + 2);
    v206 = (uint64_t)(a6 + 2);
    v31 = (const CMTime *)MEMORY[0x1E0CA2E68];
    while (1)
    {
      if (!OZSpline::getNextValidVertex((OZSpline *)a1, &v213, &v214, v31, 0)
        || (v32 = *((_OWORD *)v214 + 1),
            v212.epoch = *((_QWORD *)v214 + 4),
            *(_OWORD *)&v212.value = v32,
            *(_OWORD *)&time1.value = v32,
            time1.epoch = v212.epoch,
            time2 = *a3,
            CMTimeCompare(&time1, &time2) >= 1))
      {
        v212 = *a3;
      }
      if (!OZSpline::getVertexHandle((OZSpline *)a1, &v213, &v215, 0)
        && !OZSpline::getPreviousValidVertex((OZSpline *)a1, &v213, &v215, v31, 0))
      {
        break;
      }
      if (!v214)
      {
        v34 = *(_DWORD *)(*(_QWORD *)&a1[42]._os_unfair_lock_opaque + 36);
LABEL_40:
        if (v34 < 2)
          goto LABEL_41;
        goto LABEL_45;
      }
      if ((*(unsigned int (**)(void *))(*(_QWORD *)v215 + 208))(v215) == 1
        || (*(unsigned int (**)(void *))(*(_QWORD *)v215 + 208))(v215) == 4
        && (time1.value = 0,
            time2.value = 0,
            v209.value = 0,
            *(_QWORD *)&v207 = 0,
            (*(void (**)(void *, CMTime *, CMTime *, const CMTime *))(*(_QWORD *)v214 + 56))(v214, &time1, &v209, v31), (*(void (**)(void *, CMTime *, __int128 *, const CMTime *))(*(_QWORD *)v215 + 64))(v215, &time2, &v207, v31), fabs(*(double *)&time1.value) < 0.0000001)&& fabs(*(double *)&time2.value) < 0.0000001&& fabs(*(double *)&v209.value) < 0.0000001&& fabs(*(double *)&v207) < 0.0000001)
      {
LABEL_41:
        v35 = a5[1];
        if (v35 == *a5 || !PCMath::equal((PCMath *)(v35 - 24), &v213, v31, v33))
        {
          v36 = (*(double (**)(os_unfair_lock_s *, CMTime *, const CMTime *, _QWORD))(*(_QWORD *)&a1->_os_unfair_lock_opaque
                                                                                               + 240))(a1, &v213, v31, 0);
          v37 = v36;
          v39 = a6[1];
          v38 = (unint64_t)a6[2];
          if ((unint64_t)v39 >= v38)
          {
            v76 = *a6;
            v77 = v39 - *a6;
            v78 = v77 + 1;
            if ((unint64_t)(v77 + 1) >> 61)
              goto LABEL_251;
            v79 = v38 - (_QWORD)v76;
            if (v79 >> 2 > v78)
              v78 = v79 >> 2;
            if ((unint64_t)v79 >= 0x7FFFFFFFFFFFFFF8)
              v80 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v80 = v78;
            if (v80)
            {
              v81 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v206, v80);
              v76 = *a6;
              v39 = a6[1];
            }
            else
            {
              v81 = 0;
            }
            v82 = (double *)&v81[8 * v77];
            *v82 = v37;
            v40 = v82 + 1;
            while (v39 != v76)
            {
              v83 = *((_QWORD *)v39-- - 1);
              *((_QWORD *)v82-- - 1) = v83;
            }
            *a6 = v82;
            a6[1] = v40;
            a6[2] = (double *)&v81[8 * v80];
            if (v76)
              operator delete(v76);
          }
          else
          {
            *v39 = v36;
            v40 = v39 + 1;
          }
          a6[1] = v40;
          v85 = a5[1];
          v84 = a5[2];
          if (v85 >= v84)
          {
            v88 = 0xAAAAAAAAAAAAAAABLL * ((v85 - *a5) >> 3);
            v89 = v88 + 1;
            if (v88 + 1 > 0xAAAAAAAAAAAAAAALL)
              goto LABEL_252;
            v90 = 0xAAAAAAAAAAAAAAABLL * ((v84 - *a5) >> 3);
            if (2 * v90 > v89)
              v89 = 2 * v90;
            if (v90 >= 0x555555555555555)
              v91 = 0xAAAAAAAAAAAAAAALL;
            else
              v91 = v89;
            if (v91)
              v92 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>(v205, v91);
            else
              v92 = 0;
            v93 = &v92[24 * v88];
            v94 = *(_OWORD *)&v213.value;
            *((_QWORD *)v93 + 2) = v213.epoch;
            *(_OWORD *)v93 = v94;
            v96 = *a5;
            v95 = a5[1];
            v97 = v93;
            if (v95 != *a5)
            {
              do
              {
                v98 = *(_OWORD *)(v95 - 24);
                *((_QWORD *)v97 - 1) = *((_QWORD *)v95 - 1);
                *(_OWORD *)(v97 - 24) = v98;
                v97 -= 24;
                v95 -= 24;
              }
              while (v95 != v96);
              v95 = *a5;
            }
            v87 = v93 + 24;
            *a5 = v97;
            a5[1] = v93 + 24;
            a5[2] = &v92[24 * v91];
            if (v95)
              operator delete(v95);
          }
          else
          {
            v86 = *(_OWORD *)&v213.value;
            *((_QWORD *)v85 + 2) = v213.epoch;
            *(_OWORD *)v85 = v86;
            v87 = v85 + 24;
          }
          a5[1] = v87;
        }
        v99 = (*(double (**)(os_unfair_lock_s *, CMTime *, const CMTime *, _QWORD))(*(_QWORD *)&a1->_os_unfair_lock_opaque
                                                                                             + 240))(a1, &v212, v31, 0);
        v100 = v99;
        v102 = a6[1];
        v101 = (unint64_t)a6[2];
        if ((unint64_t)v102 >= v101)
        {
          v104 = *a6;
          v105 = v102 - *a6;
          v106 = v105 + 1;
          if ((unint64_t)(v105 + 1) >> 61)
            goto LABEL_251;
          v107 = v101 - (_QWORD)v104;
          if (v107 >> 2 > v106)
            v106 = v107 >> 2;
          if ((unint64_t)v107 >= 0x7FFFFFFFFFFFFFF8)
            v108 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v108 = v106;
          if (v108)
          {
            v109 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v206, v108);
            v104 = *a6;
            v102 = a6[1];
          }
          else
          {
            v109 = 0;
          }
          v110 = (double *)&v109[8 * v105];
          *v110 = v100;
          v103 = v110 + 1;
          while (v102 != v104)
          {
            v111 = *((_QWORD *)v102-- - 1);
            *((_QWORD *)v110-- - 1) = v111;
          }
          *a6 = v110;
          a6[1] = v103;
          a6[2] = (double *)&v109[8 * v108];
          if (v104)
            operator delete(v104);
        }
        else
        {
          *v102 = v99;
          v103 = v102 + 1;
        }
        a6[1] = v103;
        v113 = a5[1];
        v112 = a5[2];
        if (v113 >= v112)
        {
          v116 = 0xAAAAAAAAAAAAAAABLL * ((v113 - *a5) >> 3);
          v117 = v116 + 1;
          if (v116 + 1 > 0xAAAAAAAAAAAAAAALL)
            goto LABEL_252;
          v118 = 0xAAAAAAAAAAAAAAABLL * ((v112 - *a5) >> 3);
          if (2 * v118 > v117)
            v117 = 2 * v118;
          if (v118 >= 0x555555555555555)
            v119 = 0xAAAAAAAAAAAAAAALL;
          else
            v119 = v117;
          if (v119)
            v120 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>(v205, v119);
          else
            v120 = 0;
          v121 = &v120[24 * v116];
          v122 = *(_OWORD *)&v212.value;
          *((_QWORD *)v121 + 2) = v212.epoch;
          *(_OWORD *)v121 = v122;
          v124 = *a5;
          v123 = a5[1];
          v125 = v121;
          if (v123 != *a5)
          {
            do
            {
              v126 = *(_OWORD *)(v123 - 24);
              *((_QWORD *)v125 - 1) = *((_QWORD *)v123 - 1);
              *(_OWORD *)(v125 - 24) = v126;
              v125 -= 24;
              v123 -= 24;
            }
            while (v123 != v124);
            v123 = *a5;
          }
          v115 = v121 + 24;
          *a5 = v125;
          a5[1] = v121 + 24;
          a5[2] = &v120[24 * v119];
          if (v123)
            operator delete(v123);
        }
        else
        {
          v114 = *(_OWORD *)&v212.value;
          *((_QWORD *)v113 + 2) = v212.epoch;
          *(_OWORD *)v113 = v114;
          v115 = v113 + 24;
        }
        a5[1] = v115;
        goto LABEL_151;
      }
LABEL_45:
      time1 = v212;
      time2 = v213;
      PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&time);
      v41 = CMTimeGetSeconds(&time);
      v210 = *a4;
      v42 = (int)(v41 / CMTimeGetSeconds(&v210));
      if ((v42 & 0x80000000) == 0)
      {
        v43 = 0;
        do
        {
          memset(&v209, 0, sizeof(v209));
          operator*(a4, v43, &v209);
          if (!v43)
          {
            v57 = a5[1];
            if (v57 != *a5 && PCMath::equal((PCMath *)(v57 - 24), &v213, v31, v44))
              continue;
          }
          time1 = v213;
          time2 = v209;
          v45 = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v207);
          v46 = (*(double (**)(os_unfair_lock_s *, __int128 *, const CMTime *, _QWORD, double))(*(_QWORD *)&a1->_os_unfair_lock_opaque + 240))(a1, &v207, v31, 0, v45);
          v47 = v46;
          v49 = a6[1];
          v48 = (unint64_t)a6[2];
          if ((unint64_t)v49 >= v48)
          {
            v51 = *a6;
            v52 = v49 - *a6;
            v53 = v52 + 1;
            if ((unint64_t)(v52 + 1) >> 61)
              goto LABEL_251;
            v54 = v48 - (_QWORD)v51;
            if (v54 >> 2 > v53)
              v53 = v54 >> 2;
            if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8)
              v55 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v55 = v53;
            if (v55)
            {
              v56 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v206, v55);
              v51 = *a6;
              v49 = a6[1];
            }
            else
            {
              v56 = 0;
            }
            v58 = (double *)&v56[8 * v52];
            *v58 = v47;
            v50 = v58 + 1;
            while (v49 != v51)
            {
              v59 = *((_QWORD *)v49-- - 1);
              *((_QWORD *)v58-- - 1) = v59;
            }
            *a6 = v58;
            a6[1] = v50;
            a6[2] = (double *)&v56[8 * v55];
            if (v51)
              operator delete(v51);
          }
          else
          {
            *v49 = v46;
            v50 = v49 + 1;
          }
          a6[1] = v50;
          time1 = v213;
          time2 = v209;
          PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v207);
          v61 = a5[1];
          v60 = a5[2];
          if (v61 >= v60)
          {
            v64 = 0xAAAAAAAAAAAAAAABLL * ((v61 - *a5) >> 3);
            v65 = v64 + 1;
            if (v64 + 1 > 0xAAAAAAAAAAAAAAALL)
              goto LABEL_252;
            v66 = 0xAAAAAAAAAAAAAAABLL * ((v60 - *a5) >> 3);
            if (2 * v66 > v65)
              v65 = 2 * v66;
            if (v66 >= 0x555555555555555)
              v67 = 0xAAAAAAAAAAAAAAALL;
            else
              v67 = v65;
            if (v67)
              v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>(v205, v67);
            else
              v68 = 0;
            v69 = &v68[24 * v64];
            v70 = v207;
            *((_QWORD *)v69 + 2) = v208;
            *(_OWORD *)v69 = v70;
            v72 = *a5;
            v71 = a5[1];
            v73 = v69;
            if (v71 != *a5)
            {
              do
              {
                v74 = *(_OWORD *)(v71 - 24);
                *((_QWORD *)v73 - 1) = *((_QWORD *)v71 - 1);
                *(_OWORD *)(v73 - 24) = v74;
                v73 -= 24;
                v71 -= 24;
              }
              while (v71 != v72);
              v71 = *a5;
            }
            v63 = v69 + 24;
            *a5 = v73;
            a5[1] = v69 + 24;
            a5[2] = &v68[24 * v67];
            if (v71)
              operator delete(v71);
          }
          else
          {
            v62 = v207;
            *((_QWORD *)v61 + 2) = v208;
            *(_OWORD *)v61 = v62;
            v63 = v61 + 24;
          }
          a5[1] = v63;
        }
        while (v43++ != v42);
      }
LABEL_151:
      v213 = v212;
      time1 = v212;
      time2 = *a3;
      if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
        goto LABEL_152;
    }
    if (!v214)
      goto LABEL_45;
    v34 = *(_DWORD *)(*(_QWORD *)&a1[42]._os_unfair_lock_opaque + 40);
    goto LABEL_40;
  }
  return v14 >= 0;
}

void std::vector<CMTime>::push_back[abi:ne180100](void **a1, __int128 *a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  unint64_t v7;
  __int128 v8;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  __int128 v17;
  char *v18;
  char *v19;
  __int128 v20;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= (unint64_t)v6)
  {
    v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (_QWORD)*a1) >> 3);
    v11 = v10 + 1;
    if (v10 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v12 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (_BYTE *)*a1) >> 3);
    if (2 * v12 > v11)
      v11 = 2 * v12;
    if (v12 >= 0x555555555555555)
      v13 = 0xAAAAAAAAAAAAAAALL;
    else
      v13 = v11;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>(v4, v13);
    else
      v14 = 0;
    v15 = &v14[24 * v10];
    v16 = &v14[24 * v13];
    v17 = *a2;
    *((_QWORD *)v15 + 2) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v15 = v17;
    v9 = v15 + 24;
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_OWORD *)(v18 - 24);
        *((_QWORD *)v15 - 1) = *((_QWORD *)v18 - 1);
        *(_OWORD *)(v15 - 24) = v20;
        v15 -= 24;
        v18 -= 24;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v15;
    a1[1] = v9;
    a1[2] = v16;
    if (v18)
      operator delete(v18);
  }
  else
  {
    v8 = *a2;
    *(_QWORD *)(v7 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v7 = v8;
    v9 = (char *)(v7 + 24);
  }
  a1[1] = v9;
}

uint64_t OZSpline::sampleSpline(uint64_t a1, CMTime *a2, CMTime *a3, int32_t *a4, void **a5, uint64_t a6, const CMTime *a7, char a8)
{
  uint64_t v15;
  os_unfair_lock_s *v16;
  uint64_t v17;
  double v18;
  double v19;
  unint64_t v20;
  double *v21;
  double *v22;
  unsigned int v23;
  double v24;
  double v25;
  double v26;
  unint64_t v27;
  double *v28;
  double *v29;
  double *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char *v35;
  double *v36;
  uint64_t v37;
  char *v38;
  char *v39;
  __int128 v40;
  char *v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  char *v46;
  char *v47;
  __int128 v48;
  char *v49;
  char *v50;
  char *v51;
  __int128 v52;
  uint64_t Interpolator;
  uint64_t v54;
  unsigned int v55;
  void **v56;
  void **v57;
  void *v58;
  void *v59;
  unint64_t v60;
  void **v61;
  _QWORD *v62;
  double *v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  char *v68;
  void **v69;
  void *v70;
  char *v71;
  char *v72;
  __int128 v73;
  char *v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  char *v79;
  char *v80;
  __int128 v81;
  char *v82;
  char *v83;
  char *v84;
  __int128 v85;
  int32_t v86;
  const CMTime *v87;
  __int128 v88;
  unsigned int v89;
  double v90;
  double v91;
  unint64_t v92;
  double *v93;
  double *v94;
  double Seconds;
  unsigned int v96;
  int32_t i;
  double v98;
  double v99;
  double v100;
  unint64_t v101;
  double *v102;
  double *v103;
  double *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  char *v109;
  double *v110;
  uint64_t v111;
  char *v112;
  char *v113;
  __int128 v114;
  char *v115;
  unint64_t v116;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  char *v120;
  char *v121;
  __int128 v122;
  char *v123;
  char *v124;
  char *v125;
  __int128 v126;
  double *v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  char *v132;
  double *v133;
  uint64_t v134;
  double v135;
  double v136;
  unint64_t v137;
  double *v138;
  double *v139;
  double *v140;
  uint64_t v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  char *v145;
  double *v146;
  uint64_t v147;
  char *v148;
  char *v149;
  __int128 v150;
  char *v151;
  unint64_t v152;
  unint64_t v153;
  unint64_t v154;
  unint64_t v155;
  char *v156;
  char *v157;
  __int128 v158;
  char *v159;
  char *v160;
  char *v161;
  __int128 v162;
  char *v163;
  __int128 v164;
  char *v165;
  unint64_t v166;
  unint64_t v167;
  unint64_t v168;
  unint64_t v169;
  char *v170;
  char *v171;
  __int128 v172;
  char *v173;
  char *v174;
  char *v175;
  __int128 v176;
  double *v177;
  uint64_t v178;
  unint64_t v179;
  uint64_t v180;
  unint64_t v181;
  char *v182;
  double *v183;
  char *v184;
  uint64_t v185;
  double v186;
  double v187;
  double v188;
  unint64_t v189;
  double *v190;
  double *v191;
  double *v192;
  uint64_t v193;
  unint64_t v194;
  uint64_t v195;
  unint64_t v196;
  char *v197;
  double *v198;
  char *v199;
  uint64_t v200;
  char *v201;
  char *v202;
  __int128 v203;
  char *v204;
  unint64_t v205;
  unint64_t v206;
  unint64_t v207;
  unint64_t v208;
  char *v209;
  char *v210;
  char *v211;
  __int128 v212;
  char *v213;
  char *v214;
  __int128 v215;
  char *v216;
  char *v217;
  __int128 v218;
  char *v219;
  unint64_t v220;
  unint64_t v221;
  unint64_t v222;
  unint64_t v223;
  char *v224;
  char *v225;
  char *v226;
  __int128 v227;
  char *v228;
  char *v229;
  __int128 v230;
  uint64_t v231;
  os_unfair_lock_s *v232;
  uint64_t v234;
  uint64_t v235;
  CMTime v237;
  CMTime time;
  void *v239;
  void *v240;
  CMTime v241;
  CMTime v242;
  CMTime v243;
  CMTime v244;
  CMTime v245;
  int v246;
  CMTime time2;
  CMTime time1;

  v246 = 0;
  v15 = *(_QWORD *)(a1 + 160);
  if (!v15 || (v16 = *(os_unfair_lock_s **)(v15 + 48)) == 0)
    v16 = (os_unfair_lock_s *)(a1 + 8);
  PCSpinLock::lock(v16);
  (*(void (**)(uint64_t, int *, _QWORD, _QWORD))(*(_QWORD *)a1 + 16))(a1, &v246, 0, 0);
  if (**(_BYTE **)(a1 + 168)
    && (v17 = OZInterpolators::getInterpolator(*(OZInterpolators **)(a1 + 152), v246),
        ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v17 + 64))(v17) & 1) == 0))
  {
    memset(&v245, 0, sizeof(v245));
    operator*(a3, *a4, &v245);
    memset(&v244, 0, sizeof(v244));
    time1 = *a2;
    time2 = v245;
    PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v244);
    Interpolator = OZInterpolators::getInterpolator(*(OZInterpolators **)(a1 + 152), v246);
    (*(void (**)(CMTime *__return_ptr, uint64_t, uint64_t, const CMTime *, CMTime *))(*(_QWORD *)Interpolator
                                                                                             + 72))(&time1, Interpolator, a1, a7, &v244);
    v244 = time1;
    memset(&v243, 0, sizeof(v243));
    v54 = OZInterpolators::getInterpolator(*(OZInterpolators **)(a1 + 152), v246);
    (*(void (**)(CMTime *__return_ptr, uint64_t, uint64_t, const CMTime *, CMTime *))(*(_QWORD *)v54 + 80))(&v243, v54, a1, a7, a2);
    memset(&v242, 0, sizeof(v242));
    time1 = v244;
    time2 = v243;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v241);
    operator*(&v241, &v242, 1.0 / (double)(*a4 - 1));
    if (*a4)
    {
      v55 = 0;
      do
      {
        operator*(&v242, v55, &time1);
        v245 = time1;
        if (a6)
        {
          v57 = *(void ***)(a1 + 16);
          v56 = *(void ***)(a1 + 24);
          if (v57 == v56)
          {
            v58 = 0;
            v59 = 0;
          }
          else
          {
            v58 = *v57;
            v59 = *(v56 - 1);
          }
          v240 = 0;
          time1 = v243;
          time2 = v245;
          PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v241);
          OZSpline::interpolate((OZSpline *)a1, a7, v58, v59, &v241, (double *)&v240, 0);
          v61 = *(void ***)(a6 + 8);
          v60 = *(_QWORD *)(a6 + 16);
          if ((unint64_t)v61 >= v60)
          {
            v63 = *(double **)a6;
            v64 = ((uint64_t)v61 - *(_QWORD *)a6) >> 3;
            v65 = v64 + 1;
            if ((unint64_t)(v64 + 1) >> 61)
              goto LABEL_292;
            v66 = v60 - (_QWORD)v63;
            if (v66 >> 2 > v65)
              v65 = v66 >> 2;
            if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF8)
              v67 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v67 = v65;
            if (v67)
            {
              v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a6 + 16, v67);
              v63 = *(double **)a6;
              v61 = *(void ***)(a6 + 8);
            }
            else
            {
              v68 = 0;
            }
            v69 = (void **)&v68[8 * v64];
            *v69 = v240;
            v62 = v69 + 1;
            while (v61 != (void **)v63)
            {
              v70 = *--v61;
              *--v69 = v70;
            }
            *(_QWORD *)a6 = v69;
            *(_QWORD *)(a6 + 8) = v62;
            *(_QWORD *)(a6 + 16) = &v68[8 * v67];
            if (v63)
              operator delete(v63);
          }
          else
          {
            *v61 = v240;
            v62 = v61 + 1;
          }
          *(_QWORD *)(a6 + 8) = v62;
        }
        if (a5)
        {
          time1 = v243;
          time2 = v245;
          PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v241);
          v72 = (char *)a5[1];
          v71 = (char *)a5[2];
          if (v72 >= v71)
          {
            v75 = 0xAAAAAAAAAAAAAAABLL * ((v72 - (_BYTE *)*a5) >> 3);
            v76 = v75 + 1;
            if (v75 + 1 > 0xAAAAAAAAAAAAAAALL)
              goto LABEL_293;
            v77 = 0xAAAAAAAAAAAAAAABLL * ((v71 - (_BYTE *)*a5) >> 3);
            if (2 * v77 > v76)
              v76 = 2 * v77;
            if (v77 >= 0x555555555555555)
              v78 = 0xAAAAAAAAAAAAAAALL;
            else
              v78 = v76;
            if (v78)
              v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a5 + 2), v78);
            else
              v79 = 0;
            v80 = &v79[24 * v75];
            v81 = *(_OWORD *)&v241.value;
            *((_QWORD *)v80 + 2) = v241.epoch;
            *(_OWORD *)v80 = v81;
            v83 = (char *)*a5;
            v82 = (char *)a5[1];
            v84 = v80;
            if (v82 != *a5)
            {
              do
              {
                v85 = *(_OWORD *)(v82 - 24);
                *((_QWORD *)v84 - 1) = *((_QWORD *)v82 - 1);
                *(_OWORD *)(v84 - 24) = v85;
                v84 -= 24;
                v82 -= 24;
              }
              while (v82 != v83);
              v82 = (char *)*a5;
            }
            v74 = v80 + 24;
            *a5 = v84;
            a5[1] = v80 + 24;
            a5[2] = &v79[24 * v78];
            if (v82)
              operator delete(v82);
          }
          else
          {
            v73 = *(_OWORD *)&v241.value;
            *((_QWORD *)v72 + 2) = v241.epoch;
            *(_OWORD *)v72 = v73;
            v74 = v72 + 24;
          }
          a5[1] = v74;
        }
        ++v55;
      }
      while (v55 < *a4);
    }
  }
  else
  {
    if ((a8 & 1) != 0)
    {
      if (OZSpline::getNumberOfValidVertices((OZSpline *)a1, a7) <= 1)
      {
        if (!a6)
          goto LABEL_251;
        v18 = (*(double (**)(uint64_t, CMTime *, const CMTime *, _QWORD))(*(_QWORD *)a1 + 240))(a1, a2, a7, 0);
        v19 = v18;
        v20 = *(_QWORD *)(a6 + 16);
        v21 = *(double **)(a6 + 8);
        if ((unint64_t)v21 >= v20)
        {
          v177 = *(double **)a6;
          v178 = ((uint64_t)v21 - *(_QWORD *)a6) >> 3;
          v179 = v178 + 1;
          if ((unint64_t)(v178 + 1) >> 61)
            goto LABEL_292;
          v180 = v20 - (_QWORD)v177;
          if (v180 >> 2 > v179)
            v179 = v180 >> 2;
          if ((unint64_t)v180 >= 0x7FFFFFFFFFFFFFF8)
            v181 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v181 = v179;
          if (v181)
          {
            v182 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a6 + 16, v181);
            v177 = *(double **)a6;
            v21 = *(double **)(a6 + 8);
          }
          else
          {
            v182 = 0;
          }
          v183 = (double *)&v182[8 * v178];
          v184 = &v182[8 * v181];
          *v183 = v19;
          v22 = v183 + 1;
          while (v21 != v177)
          {
            v185 = *((_QWORD *)v21-- - 1);
            *((_QWORD *)v183-- - 1) = v185;
          }
          *(_QWORD *)a6 = v183;
          *(_QWORD *)(a6 + 8) = v22;
          *(_QWORD *)(a6 + 16) = v184;
          if (v177)
            operator delete(v177);
        }
        else
        {
          *v21 = v18;
          v22 = v21 + 1;
        }
        *(_QWORD *)(a6 + 8) = v22;
        if (*a4 < 2)
          goto LABEL_251;
        operator*(a3, *a4 - 1, &v244);
        time1 = *a2;
        time2 = v244;
        v186 = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v245);
        v187 = (*(double (**)(uint64_t, CMTime *, const CMTime *, _QWORD, double))(*(_QWORD *)a1 + 240))(a1, &v245, a7, 0, v186);
        v188 = v187;
        v190 = *(double **)(a6 + 8);
        v189 = *(_QWORD *)(a6 + 16);
        if ((unint64_t)v190 < v189)
        {
          *v190 = v187;
          v191 = v190 + 1;
LABEL_250:
          *(_QWORD *)(a6 + 8) = v191;
LABEL_251:
          if (!a5)
            goto LABEL_286;
          v201 = (char *)a5[2];
          v202 = (char *)a5[1];
          if (v202 >= v201)
          {
            v205 = 0xAAAAAAAAAAAAAAABLL * ((v202 - (_BYTE *)*a5) >> 3);
            v206 = v205 + 1;
            if (v205 + 1 > 0xAAAAAAAAAAAAAAALL)
              goto LABEL_293;
            v207 = 0xAAAAAAAAAAAAAAABLL * ((v201 - (_BYTE *)*a5) >> 3);
            if (2 * v207 > v206)
              v206 = 2 * v207;
            if (v207 >= 0x555555555555555)
              v208 = 0xAAAAAAAAAAAAAAALL;
            else
              v208 = v206;
            if (v208)
              v209 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a5 + 2), v208);
            else
              v209 = 0;
            v210 = &v209[24 * v205];
            v211 = &v209[24 * v208];
            v212 = *(_OWORD *)&a2->value;
            *((_QWORD *)v210 + 2) = a2->epoch;
            *(_OWORD *)v210 = v212;
            v204 = v210 + 24;
            v214 = (char *)*a5;
            v213 = (char *)a5[1];
            if (v213 != *a5)
            {
              do
              {
                v215 = *(_OWORD *)(v213 - 24);
                *((_QWORD *)v210 - 1) = *((_QWORD *)v213 - 1);
                *(_OWORD *)(v210 - 24) = v215;
                v210 -= 24;
                v213 -= 24;
              }
              while (v213 != v214);
              v213 = (char *)*a5;
            }
            *a5 = v210;
            a5[1] = v204;
            a5[2] = v211;
            if (v213)
              operator delete(v213);
          }
          else
          {
            v203 = *(_OWORD *)&a2->value;
            *((_QWORD *)v202 + 2) = a2->epoch;
            *(_OWORD *)v202 = v203;
            v204 = v202 + 24;
          }
          a5[1] = v204;
          if (*a4 < 2)
            goto LABEL_288;
          operator*(a3, *a4 - 1, &v244);
          time1 = *a2;
          time2 = v244;
          PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v245);
          v217 = (char *)a5[1];
          v216 = (char *)a5[2];
          if (v217 < v216)
          {
            v218 = *(_OWORD *)&v245.value;
            *((_QWORD *)v217 + 2) = v245.epoch;
            *(_OWORD *)v217 = v218;
            v219 = v217 + 24;
LABEL_285:
            a5[1] = v219;
LABEL_286:
            if (*a4 >= 2)
              *a4 = 2;
            goto LABEL_288;
          }
          v220 = 0xAAAAAAAAAAAAAAABLL * ((v217 - (_BYTE *)*a5) >> 3);
          v221 = v220 + 1;
          if (v220 + 1 <= 0xAAAAAAAAAAAAAAALL)
          {
            v222 = 0xAAAAAAAAAAAAAAABLL * ((v216 - (_BYTE *)*a5) >> 3);
            if (2 * v222 > v221)
              v221 = 2 * v222;
            if (v222 >= 0x555555555555555)
              v223 = 0xAAAAAAAAAAAAAAALL;
            else
              v223 = v221;
            if (v223)
              v224 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a5 + 2), v223);
            else
              v224 = 0;
            v225 = &v224[24 * v220];
            v226 = &v224[24 * v223];
            v227 = *(_OWORD *)&v245.value;
            *((_QWORD *)v225 + 2) = v245.epoch;
            *(_OWORD *)v225 = v227;
            v219 = v225 + 24;
            v229 = (char *)*a5;
            v228 = (char *)a5[1];
            if (v228 != *a5)
            {
              do
              {
                v230 = *(_OWORD *)(v228 - 24);
                *((_QWORD *)v225 - 1) = *((_QWORD *)v228 - 1);
                *(_OWORD *)(v225 - 24) = v230;
                v225 -= 24;
                v228 -= 24;
              }
              while (v228 != v229);
              v228 = (char *)*a5;
            }
            *a5 = v225;
            a5[1] = v219;
            a5[2] = v226;
            if (v228)
              operator delete(v228);
            goto LABEL_285;
          }
LABEL_293:
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        v192 = *(double **)a6;
        v193 = ((uint64_t)v190 - *(_QWORD *)a6) >> 3;
        v194 = v193 + 1;
        if (!((unint64_t)(v193 + 1) >> 61))
        {
          v195 = v189 - (_QWORD)v192;
          if (v195 >> 2 > v194)
            v194 = v195 >> 2;
          if ((unint64_t)v195 >= 0x7FFFFFFFFFFFFFF8)
            v196 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v196 = v194;
          if (v196)
          {
            v197 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a6 + 16, v196);
            v192 = *(double **)a6;
            v190 = *(double **)(a6 + 8);
          }
          else
          {
            v197 = 0;
          }
          v198 = (double *)&v197[8 * v193];
          v199 = &v197[8 * v196];
          *v198 = v188;
          v191 = v198 + 1;
          while (v190 != v192)
          {
            v200 = *((_QWORD *)v190-- - 1);
            *((_QWORD *)v198-- - 1) = v200;
          }
          *(_QWORD *)a6 = v198;
          *(_QWORD *)(a6 + 8) = v191;
          *(_QWORD *)(a6 + 16) = v199;
          if (v192)
            operator delete(v192);
          goto LABEL_250;
        }
LABEL_292:
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      v239 = 0;
      v240 = 0;
      v245 = *a2;
      v244 = v245;
      operator*(a3, *a4 - 1, &v242);
      time1 = *a2;
      time2 = v242;
      PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v243);
      time1 = v244;
      time2 = v243;
      v86 = 0;
      if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
      {
LABEL_218:
        *a4 = v86;
        goto LABEL_288;
      }
      v234 = (uint64_t)(a5 + 2);
      v235 = a6 + 16;
      v87 = (const CMTime *)MEMORY[0x1E0CA2E68];
      while (1)
      {
        if (!OZSpline::getNextValidVertex((OZSpline *)a1, &v245, &v239, v87, 0)
          || (v88 = *((_OWORD *)v239 + 1),
              v244.epoch = *((_QWORD *)v239 + 4),
              *(_OWORD *)&v244.value = v88,
              *(_OWORD *)&time1.value = v88,
              time1.epoch = v244.epoch,
              time2 = v243,
              CMTimeCompare(&time1, &time2) >= 1))
        {
          v244 = v243;
        }
        if (!OZSpline::getVertexHandle((OZSpline *)a1, &v245, &v240, 0)
          && !OZSpline::getPreviousValidVertex((OZSpline *)a1, &v245, &v240, v87, 0))
        {
          break;
        }
        if (!v239)
          goto LABEL_104;
        if ((*(unsigned int (**)(void *))(*(_QWORD *)v240 + 208))(v240) == 1)
          goto LABEL_108;
        if (!v239)
        {
LABEL_104:
          v89 = *(_DWORD *)(*(_QWORD *)(a1 + 168) + 36);
LABEL_107:
          if (v89 < 2)
          {
LABEL_108:
            if (a6)
            {
              v90 = (*(double (**)(uint64_t, CMTime *, const CMTime *, _QWORD))(*(_QWORD *)a1 + 240))(a1, &v245, a7, 0);
              v91 = v90;
              v93 = *(double **)(a6 + 8);
              v92 = *(_QWORD *)(a6 + 16);
              if ((unint64_t)v93 >= v92)
              {
                v127 = *(double **)a6;
                v128 = ((uint64_t)v93 - *(_QWORD *)a6) >> 3;
                v129 = v128 + 1;
                if ((unint64_t)(v128 + 1) >> 61)
                  goto LABEL_292;
                v130 = v92 - (_QWORD)v127;
                if (v130 >> 2 > v129)
                  v129 = v130 >> 2;
                if ((unint64_t)v130 >= 0x7FFFFFFFFFFFFFF8)
                  v131 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v131 = v129;
                if (v131)
                {
                  v132 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v235, v131);
                  v127 = *(double **)a6;
                  v93 = *(double **)(a6 + 8);
                }
                else
                {
                  v132 = 0;
                }
                v133 = (double *)&v132[8 * v128];
                *v133 = v91;
                v94 = v133 + 1;
                while (v93 != v127)
                {
                  v134 = *((_QWORD *)v93-- - 1);
                  *((_QWORD *)v133-- - 1) = v134;
                }
                *(_QWORD *)a6 = v133;
                *(_QWORD *)(a6 + 8) = v94;
                *(_QWORD *)(a6 + 16) = &v132[8 * v131];
                if (v127)
                  operator delete(v127);
              }
              else
              {
                *v93 = v90;
                v94 = v93 + 1;
              }
              *(_QWORD *)(a6 + 8) = v94;
              v135 = (*(double (**)(uint64_t, CMTime *, const CMTime *, _QWORD))(*(_QWORD *)a1 + 240))(a1, &v244, a7, 0);
              v136 = v135;
              v138 = *(double **)(a6 + 8);
              v137 = *(_QWORD *)(a6 + 16);
              if ((unint64_t)v138 >= v137)
              {
                v140 = *(double **)a6;
                v141 = ((uint64_t)v138 - *(_QWORD *)a6) >> 3;
                v142 = v141 + 1;
                if ((unint64_t)(v141 + 1) >> 61)
                  goto LABEL_292;
                v143 = v137 - (_QWORD)v140;
                if (v143 >> 2 > v142)
                  v142 = v143 >> 2;
                if ((unint64_t)v143 >= 0x7FFFFFFFFFFFFFF8)
                  v144 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v144 = v142;
                if (v144)
                {
                  v145 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v235, v144);
                  v140 = *(double **)a6;
                  v138 = *(double **)(a6 + 8);
                }
                else
                {
                  v145 = 0;
                }
                v146 = (double *)&v145[8 * v141];
                *v146 = v136;
                v139 = v146 + 1;
                while (v138 != v140)
                {
                  v147 = *((_QWORD *)v138-- - 1);
                  *((_QWORD *)v146-- - 1) = v147;
                }
                *(_QWORD *)a6 = v146;
                *(_QWORD *)(a6 + 8) = v139;
                *(_QWORD *)(a6 + 16) = &v145[8 * v144];
                if (v140)
                  operator delete(v140);
              }
              else
              {
                *v138 = v135;
                v139 = v138 + 1;
              }
              *(_QWORD *)(a6 + 8) = v139;
            }
            if (a5)
            {
              v149 = (char *)a5[1];
              v148 = (char *)a5[2];
              if (v149 >= v148)
              {
                v152 = 0xAAAAAAAAAAAAAAABLL * ((v149 - (_BYTE *)*a5) >> 3);
                v153 = v152 + 1;
                if (v152 + 1 > 0xAAAAAAAAAAAAAAALL)
                  goto LABEL_293;
                v154 = 0xAAAAAAAAAAAAAAABLL * ((v148 - (_BYTE *)*a5) >> 3);
                if (2 * v154 > v153)
                  v153 = 2 * v154;
                if (v154 >= 0x555555555555555)
                  v155 = 0xAAAAAAAAAAAAAAALL;
                else
                  v155 = v153;
                if (v155)
                  v156 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>(v234, v155);
                else
                  v156 = 0;
                v157 = &v156[24 * v152];
                v158 = *(_OWORD *)&v245.value;
                *((_QWORD *)v157 + 2) = v245.epoch;
                *(_OWORD *)v157 = v158;
                v160 = (char *)*a5;
                v159 = (char *)a5[1];
                v161 = v157;
                if (v159 != *a5)
                {
                  do
                  {
                    v162 = *(_OWORD *)(v159 - 24);
                    *((_QWORD *)v161 - 1) = *((_QWORD *)v159 - 1);
                    *(_OWORD *)(v161 - 24) = v162;
                    v161 -= 24;
                    v159 -= 24;
                  }
                  while (v159 != v160);
                  v159 = (char *)*a5;
                }
                v151 = v157 + 24;
                *a5 = v161;
                a5[1] = v157 + 24;
                a5[2] = &v156[24 * v155];
                if (v159)
                  operator delete(v159);
              }
              else
              {
                v150 = *(_OWORD *)&v245.value;
                *((_QWORD *)v149 + 2) = v245.epoch;
                *(_OWORD *)v149 = v150;
                v151 = v149 + 24;
              }
              a5[1] = v151;
              v163 = (char *)a5[2];
              if (v151 >= v163)
              {
                v166 = 0xAAAAAAAAAAAAAAABLL * ((v151 - (_BYTE *)*a5) >> 3);
                v167 = v166 + 1;
                if (v166 + 1 > 0xAAAAAAAAAAAAAAALL)
                  goto LABEL_293;
                v168 = 0xAAAAAAAAAAAAAAABLL * ((v163 - (_BYTE *)*a5) >> 3);
                if (2 * v168 > v167)
                  v167 = 2 * v168;
                if (v168 >= 0x555555555555555)
                  v169 = 0xAAAAAAAAAAAAAAALL;
                else
                  v169 = v167;
                if (v169)
                  v170 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>(v234, v169);
                else
                  v170 = 0;
                v171 = &v170[24 * v166];
                v172 = *(_OWORD *)&v244.value;
                *((_QWORD *)v171 + 2) = v244.epoch;
                *(_OWORD *)v171 = v172;
                v174 = (char *)*a5;
                v173 = (char *)a5[1];
                v175 = v171;
                if (v173 != *a5)
                {
                  do
                  {
                    v176 = *(_OWORD *)(v173 - 24);
                    *((_QWORD *)v175 - 1) = *((_QWORD *)v173 - 1);
                    *(_OWORD *)(v175 - 24) = v176;
                    v175 -= 24;
                    v173 -= 24;
                  }
                  while (v173 != v174);
                  v173 = (char *)*a5;
                }
                v165 = v171 + 24;
                *a5 = v175;
                a5[1] = v171 + 24;
                a5[2] = &v170[24 * v169];
                if (v173)
                  operator delete(v173);
              }
              else
              {
                v164 = *(_OWORD *)&v244.value;
                *((_QWORD *)v151 + 2) = v244.epoch;
                *(_OWORD *)v151 = v164;
                v165 = v151 + 24;
              }
              a5[1] = v165;
            }
            v96 = 2;
            goto LABEL_217;
          }
        }
LABEL_111:
        time1 = v244;
        time2 = v245;
        PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&time);
        Seconds = CMTimeGetSeconds(&time);
        v237 = *a3;
        v96 = (Seconds / CMTimeGetSeconds(&v237));
        if (v96)
        {
          for (i = 0; i != v96; ++i)
          {
            memset(&v242, 0, sizeof(v242));
            operator*(a3, i, &v242);
            if (a6)
            {
              time1 = v245;
              time2 = v242;
              v98 = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v241);
              v99 = (*(double (**)(uint64_t, CMTime *, const CMTime *, _QWORD, double))(*(_QWORD *)a1 + 240))(a1, &v241, a7, 0, v98);
              v100 = v99;
              v102 = *(double **)(a6 + 8);
              v101 = *(_QWORD *)(a6 + 16);
              if ((unint64_t)v102 >= v101)
              {
                v104 = *(double **)a6;
                v105 = ((uint64_t)v102 - *(_QWORD *)a6) >> 3;
                v106 = v105 + 1;
                if ((unint64_t)(v105 + 1) >> 61)
                  goto LABEL_292;
                v107 = v101 - (_QWORD)v104;
                if (v107 >> 2 > v106)
                  v106 = v107 >> 2;
                if ((unint64_t)v107 >= 0x7FFFFFFFFFFFFFF8)
                  v108 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v108 = v106;
                if (v108)
                {
                  v109 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v235, v108);
                  v104 = *(double **)a6;
                  v102 = *(double **)(a6 + 8);
                }
                else
                {
                  v109 = 0;
                }
                v110 = (double *)&v109[8 * v105];
                *v110 = v100;
                v103 = v110 + 1;
                while (v102 != v104)
                {
                  v111 = *((_QWORD *)v102-- - 1);
                  *((_QWORD *)v110-- - 1) = v111;
                }
                *(_QWORD *)a6 = v110;
                *(_QWORD *)(a6 + 8) = v103;
                *(_QWORD *)(a6 + 16) = &v109[8 * v108];
                if (v104)
                  operator delete(v104);
              }
              else
              {
                *v102 = v99;
                v103 = v102 + 1;
              }
              *(_QWORD *)(a6 + 8) = v103;
            }
            if (a5)
            {
              time1 = v245;
              time2 = v242;
              PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v241);
              v113 = (char *)a5[1];
              v112 = (char *)a5[2];
              if (v113 >= v112)
              {
                v116 = 0xAAAAAAAAAAAAAAABLL * ((v113 - (_BYTE *)*a5) >> 3);
                v117 = v116 + 1;
                if (v116 + 1 > 0xAAAAAAAAAAAAAAALL)
                  goto LABEL_293;
                v118 = 0xAAAAAAAAAAAAAAABLL * ((v112 - (_BYTE *)*a5) >> 3);
                if (2 * v118 > v117)
                  v117 = 2 * v118;
                if (v118 >= 0x555555555555555)
                  v119 = 0xAAAAAAAAAAAAAAALL;
                else
                  v119 = v117;
                if (v119)
                  v120 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>(v234, v119);
                else
                  v120 = 0;
                v121 = &v120[24 * v116];
                v122 = *(_OWORD *)&v241.value;
                *((_QWORD *)v121 + 2) = v241.epoch;
                *(_OWORD *)v121 = v122;
                v124 = (char *)*a5;
                v123 = (char *)a5[1];
                v125 = v121;
                if (v123 != *a5)
                {
                  do
                  {
                    v126 = *(_OWORD *)(v123 - 24);
                    *((_QWORD *)v125 - 1) = *((_QWORD *)v123 - 1);
                    *(_OWORD *)(v125 - 24) = v126;
                    v125 -= 24;
                    v123 -= 24;
                  }
                  while (v123 != v124);
                  v123 = (char *)*a5;
                }
                v115 = v121 + 24;
                *a5 = v125;
                a5[1] = v121 + 24;
                a5[2] = &v120[24 * v119];
                if (v123)
                  operator delete(v123);
              }
              else
              {
                v114 = *(_OWORD *)&v241.value;
                *((_QWORD *)v113 + 2) = v241.epoch;
                *(_OWORD *)v113 = v114;
                v115 = v113 + 24;
              }
              a5[1] = v115;
            }
          }
          v87 = (const CMTime *)MEMORY[0x1E0CA2E68];
        }
LABEL_217:
        v86 += v96;
        v245 = v244;
        time1 = v244;
        time2 = v243;
        if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
          goto LABEL_218;
      }
      if (!v239)
        goto LABEL_111;
      v89 = *(_DWORD *)(*(_QWORD *)(a1 + 168) + 40);
      goto LABEL_107;
    }
    if (*a4)
    {
      v23 = 0;
      do
      {
        memset(&v245, 0, sizeof(v245));
        operator*(a3, v23, &v245);
        if (a6)
        {
          time1 = *a2;
          time2 = v245;
          v24 = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v244);
          v25 = (*(double (**)(uint64_t, CMTime *, const CMTime *, _QWORD, double))(*(_QWORD *)a1 + 240))(a1, &v244, a7, 0, v24);
          v26 = v25;
          v28 = *(double **)(a6 + 8);
          v27 = *(_QWORD *)(a6 + 16);
          if ((unint64_t)v28 >= v27)
          {
            v30 = *(double **)a6;
            v31 = ((uint64_t)v28 - *(_QWORD *)a6) >> 3;
            v32 = v31 + 1;
            if ((unint64_t)(v31 + 1) >> 61)
              goto LABEL_292;
            v33 = v27 - (_QWORD)v30;
            if (v33 >> 2 > v32)
              v32 = v33 >> 2;
            if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
              v34 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v34 = v32;
            if (v34)
            {
              v35 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a6 + 16, v34);
              v30 = *(double **)a6;
              v28 = *(double **)(a6 + 8);
            }
            else
            {
              v35 = 0;
            }
            v36 = (double *)&v35[8 * v31];
            *v36 = v26;
            v29 = v36 + 1;
            while (v28 != v30)
            {
              v37 = *((_QWORD *)v28-- - 1);
              *((_QWORD *)v36-- - 1) = v37;
            }
            *(_QWORD *)a6 = v36;
            *(_QWORD *)(a6 + 8) = v29;
            *(_QWORD *)(a6 + 16) = &v35[8 * v34];
            if (v30)
              operator delete(v30);
          }
          else
          {
            *v28 = v25;
            v29 = v28 + 1;
          }
          *(_QWORD *)(a6 + 8) = v29;
        }
        if (a5)
        {
          time1 = *a2;
          time2 = v245;
          PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v244);
          v39 = (char *)a5[1];
          v38 = (char *)a5[2];
          if (v39 >= v38)
          {
            v42 = 0xAAAAAAAAAAAAAAABLL * ((v39 - (_BYTE *)*a5) >> 3);
            v43 = v42 + 1;
            if (v42 + 1 > 0xAAAAAAAAAAAAAAALL)
              goto LABEL_293;
            v44 = 0xAAAAAAAAAAAAAAABLL * ((v38 - (_BYTE *)*a5) >> 3);
            if (2 * v44 > v43)
              v43 = 2 * v44;
            if (v44 >= 0x555555555555555)
              v45 = 0xAAAAAAAAAAAAAAALL;
            else
              v45 = v43;
            if (v45)
              v46 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)(a5 + 2), v45);
            else
              v46 = 0;
            v47 = &v46[24 * v42];
            v48 = *(_OWORD *)&v244.value;
            *((_QWORD *)v47 + 2) = v244.epoch;
            *(_OWORD *)v47 = v48;
            v50 = (char *)*a5;
            v49 = (char *)a5[1];
            v51 = v47;
            if (v49 != *a5)
            {
              do
              {
                v52 = *(_OWORD *)(v49 - 24);
                *((_QWORD *)v51 - 1) = *((_QWORD *)v49 - 1);
                *(_OWORD *)(v51 - 24) = v52;
                v51 -= 24;
                v49 -= 24;
              }
              while (v49 != v50);
              v49 = (char *)*a5;
            }
            v41 = v47 + 24;
            *a5 = v51;
            a5[1] = v47 + 24;
            a5[2] = &v46[24 * v45];
            if (v49)
              operator delete(v49);
          }
          else
          {
            v40 = *(_OWORD *)&v244.value;
            *((_QWORD *)v39 + 2) = v244.epoch;
            *(_OWORD *)v39 = v40;
            v41 = v39 + 24;
          }
          a5[1] = v41;
        }
        ++v23;
      }
      while (v23 < *a4);
    }
  }
LABEL_288:
  v231 = *(_QWORD *)(a1 + 160);
  if (!v231 || (v232 = *(os_unfair_lock_s **)(v231 + 48)) == 0)
    v232 = (os_unfair_lock_s *)(a1 + 8);
  PCSpinLock::unlock(v232);
  return 1;
}

uint64_t OZSpline::sampleSplineSegment(OZSpline *this, const CMTime *a2, CMTime *a3, unsigned int *a4, CMTime *a5, double *a6, const CMTime *a7, int a8)
{
  uint64_t v16;
  os_unfair_lock_s *v17;
  uint64_t Interpolator;
  unsigned int v19;
  double v20;
  __int128 v21;
  void **v22;
  void **v23;
  void *v24;
  unsigned int v25;
  BOOL v26;
  int v27;
  __int128 v28;
  uint64_t v29;
  os_unfair_lock_s *v30;
  int v32;
  void *v33;
  CMTime v34;
  CMTime v35;
  unsigned int v36;
  CMTime v37;
  CMTime v38;

  v36 = 0;
  if (a8)
  {
    v16 = *((_QWORD *)this + 20);
    if (!v16 || (v17 = *(os_unfair_lock_s **)(v16 + 48)) == 0)
      v17 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::lock(v17);
  }
  (*(void (**)(OZSpline *, unsigned int *, _QWORD, _QWORD))(*(_QWORD *)this + 16))(this, &v36, 0, 0);
  v32 = a8;
  if (**((_BYTE **)this + 21)
    && (Interpolator = OZInterpolators::getInterpolator(*((OZInterpolators **)this + 19), v36),
        ((*(uint64_t (**)(uint64_t))(*(_QWORD *)Interpolator + 64))(Interpolator) & 1) == 0))
  {
    v23 = (void **)*((_QWORD *)this + 2);
    v22 = (void **)*((_QWORD *)this + 3);
    if (v23 == v22)
    {
      v33 = 0;
      v24 = 0;
    }
    else
    {
      v33 = *v23;
      v24 = *(v22 - 1);
    }
    if (*a4)
    {
      v25 = 0;
      if (v33)
        v26 = v24 == 0;
      else
        v26 = 1;
      v27 = !v26;
      do
      {
        memset(&v35, 0, sizeof(v35));
        operator*(a3, v25, &v35);
        if (a6)
        {
          if (v27)
          {
            v38 = *a2;
            v37 = v35;
            PC_CMTimeSaferAdd(&v38, &v37, (uint64_t)&v34);
            OZSpline::interpolate(this, a7, v33, v24, &v34, a6, 0);
          }
          ++a6;
        }
        if (a5)
        {
          v38 = *a2;
          v37 = v35;
          PC_CMTimeSaferAdd(&v38, &v37, (uint64_t)&v34);
          v28 = *(_OWORD *)&v34.value;
          a5->epoch = v34.epoch;
          *(_OWORD *)&a5->value = v28;
          ++a5;
        }
        ++v25;
      }
      while (v25 < *a4);
    }
  }
  else if (*a4)
  {
    v19 = 0;
    do
    {
      memset(&v35, 0, sizeof(v35));
      operator*(a3, v19, &v35);
      if (a6)
      {
        v38 = *a2;
        v37 = v35;
        v20 = PC_CMTimeSaferAdd(&v38, &v37, (uint64_t)&v34);
        *a6++ = (*(double (**)(OZSpline *, CMTime *, const CMTime *, _QWORD, double))(*(_QWORD *)this + 240))(this, &v34, a7, 0, v20);
      }
      if (a5)
      {
        v38 = *a2;
        v37 = v35;
        PC_CMTimeSaferAdd(&v38, &v37, (uint64_t)&v34);
        v21 = *(_OWORD *)&v34.value;
        a5->epoch = v34.epoch;
        *(_OWORD *)&a5->value = v21;
        ++a5;
      }
      ++v19;
    }
    while (v19 < *a4);
  }
  if (v32)
  {
    v29 = *((_QWORD *)this + 20);
    if (!v29 || (v30 = *(os_unfair_lock_s **)(v29 + 48)) == 0)
      v30 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::unlock(v30);
  }
  return 1;
}

uint64_t OZSpline::getVertex(OZSpline *this, const CMTime *a2, double *a3, const CMTime *a4)
{
  _QWORD *v4;
  int32_t v9;
  CMTimeEpoch v11;
  CMTime time2;
  CMTime time1;

  v4 = (_QWORD *)*((_QWORD *)this + 5);
  if (*((_QWORD **)this + 6) == v4)
    return 0;
  while (1)
  {
    v11 = *(_QWORD *)(*v4 + 32);
    *(_OWORD *)&time1.value = *(_OWORD *)(*v4 + 16);
    time1.epoch = v11;
    time2 = *a2;
    v9 = CMTimeCompare(&time1, &time2);
    if (a3)
    {
      if (!v9)
        break;
    }
    if (++v4 == *((_QWORD **)this + 6))
      return 0;
  }
  *a3 = (*(double (**)(_QWORD, const CMTime *))(*(_QWORD *)*v4 + 24))(*v4, a4);
  return 1;
}

uint64_t OZSpline::getAllVerticesHandles(os_unfair_lock_s *a1, void **a2)
{
  uint64_t v4;
  os_unfair_lock_s *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  os_unfair_lock_s *v22;
  CMTime v24;
  CMTime v25;
  CMTime time2;
  CMTime time1;

  v4 = *(_QWORD *)&a1[40]._os_unfair_lock_opaque;
  if (!v4 || (v5 = *(os_unfair_lock_s **)(v4 + 48)) == 0)
    v5 = a1 + 2;
  PCSpinLock::lock(v5);
  v6 = *(uint64_t **)&a1[4]._os_unfair_lock_opaque;
  *(_OWORD *)&v25.value = *MEMORY[0x1E0CA2E68];
  v25.epoch = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
  if (v6 != *(uint64_t **)&a1[12]._os_unfair_lock_opaque)
  {
    v7 = *(uint64_t **)&a1[4]._os_unfair_lock_opaque;
    while (1)
    {
      v8 = *v7;
      *(_OWORD *)&v24.value = *(_OWORD *)(*v7 + 16);
      v24.epoch = *(_QWORD *)(*v7 + 32);
      if (v6 == v7)
        goto LABEL_9;
      time1 = v25;
      time2 = v24;
      if (CMTimeCompare(&time1, &time2))
        break;
LABEL_26:
      if (++v7 == *(uint64_t **)&a1[12]._os_unfair_lock_opaque)
        goto LABEL_27;
    }
    v8 = *v7;
LABEL_9:
    *(_OWORD *)&v25.value = *(_OWORD *)(v8 + 16);
    v25.epoch = *(_QWORD *)(v8 + 32);
    v10 = a2[1];
    v9 = (unint64_t)a2[2];
    if ((unint64_t)v10 >= v9)
    {
      v12 = ((char *)v10 - (_BYTE *)*a2) >> 3;
      if ((unint64_t)(v12 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v13 = v9 - (_QWORD)*a2;
      v14 = v13 >> 2;
      if (v13 >> 2 <= (unint64_t)(v12 + 1))
        v14 = v12 + 1;
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a2 + 2), v15);
      else
        v16 = 0;
      v17 = &v16[8 * v12];
      *(_QWORD *)v17 = v8;
      v11 = v17 + 8;
      v19 = (char *)*a2;
      v18 = (char *)a2[1];
      if (v18 != *a2)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *((_QWORD *)v17 - 1) = v20;
          v17 -= 8;
        }
        while (v18 != v19);
        v18 = (char *)*a2;
      }
      *a2 = v17;
      a2[1] = v11;
      a2[2] = &v16[8 * v15];
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v10 = v8;
      v11 = v10 + 1;
    }
    a2[1] = v11;
    goto LABEL_26;
  }
LABEL_27:
  v21 = *(_QWORD *)&a1[40]._os_unfair_lock_opaque;
  if (!v21 || (v22 = *(os_unfair_lock_s **)(v21 + 48)) == 0)
    v22 = a1 + 2;
  PCSpinLock::unlock(v22);
  return 1;
}

uint64_t OZSpline::getAllValidVerticesHandles(os_unfair_lock_s *a1, void **a2, uint64_t a3)
{
  uint64_t v6;
  os_unfair_lock_s *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  os_unfair_lock_s *v24;
  CMTime v26;
  CMTime v27;
  CMTime time2;
  CMTime time1;

  v6 = *(_QWORD *)&a1[40]._os_unfair_lock_opaque;
  if (!v6 || (v7 = *(os_unfair_lock_s **)(v6 + 48)) == 0)
    v7 = a1 + 2;
  PCSpinLock::lock(v7);
  *(_OWORD *)&v27.value = *MEMORY[0x1E0CA2E68];
  v27.epoch = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
  v8 = *(uint64_t **)&a1[10]._os_unfair_lock_opaque;
  if (*(uint64_t **)&a1[12]._os_unfair_lock_opaque != v8)
  {
    while (1)
    {
      v9 = *v8;
      *(_OWORD *)&v26.value = *(_OWORD *)(*v8 + 16);
      v26.epoch = *(_QWORD *)(*v8 + 32);
      if (*(uint64_t **)&a1[10]._os_unfair_lock_opaque == v8)
        goto LABEL_8;
      time1 = v27;
      time2 = v26;
      if (CMTimeCompare(&time1, &time2))
        break;
LABEL_26:
      if (++v8 == *(uint64_t **)&a1[12]._os_unfair_lock_opaque)
        goto LABEL_27;
    }
    v9 = *v8;
LABEL_8:
    *(_OWORD *)&v27.value = *(_OWORD *)&v26.value;
    v27.epoch = v26.epoch;
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 136))(v9, a3))
    {
      v10 = *v8;
      v12 = a2[1];
      v11 = (unint64_t)a2[2];
      if ((unint64_t)v12 >= v11)
      {
        v14 = ((char *)v12 - (_BYTE *)*a2) >> 3;
        if ((unint64_t)(v14 + 1) >> 61)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v15 = v11 - (_QWORD)*a2;
        v16 = v15 >> 2;
        if (v15 >> 2 <= (unint64_t)(v14 + 1))
          v16 = v14 + 1;
        if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
          v17 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v17 = v16;
        if (v17)
          v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a2 + 2), v17);
        else
          v18 = 0;
        v19 = &v18[8 * v14];
        *(_QWORD *)v19 = v10;
        v13 = v19 + 8;
        v21 = (char *)*a2;
        v20 = (char *)a2[1];
        if (v20 != *a2)
        {
          do
          {
            v22 = *((_QWORD *)v20 - 1);
            v20 -= 8;
            *((_QWORD *)v19 - 1) = v22;
            v19 -= 8;
          }
          while (v20 != v21);
          v20 = (char *)*a2;
        }
        *a2 = v19;
        a2[1] = v13;
        a2[2] = &v18[8 * v17];
        if (v20)
          operator delete(v20);
      }
      else
      {
        *v12 = v10;
        v13 = v12 + 1;
      }
      a2[1] = v13;
    }
    goto LABEL_26;
  }
LABEL_27:
  v23 = *(_QWORD *)&a1[40]._os_unfair_lock_opaque;
  if (!v23 || (v24 = *(os_unfair_lock_s **)(v23 + 48)) == 0)
    v24 = a1 + 2;
  PCSpinLock::unlock(v24);
  return 1;
}

uint64_t OZSpline::getVerticesTimeAndValue(os_unfair_lock_s *a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  os_unfair_lock_s *v11;
  __int128 v12;
  __int128 v13;
  uint64_t *v14;
  uint64_t v15;
  CMTimeEpoch v16;
  uint64_t v17;
  uint64_t v18;
  CMTimeEpoch v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  int32_t v25;
  uint64_t v26;
  uint64_t v27;
  double v28;
  int v29;
  int v30;
  char *v31;
  char *v32;
  char *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  __int128 v43;
  __int128 v44;
  int32_t v45;
  uint64_t v46;
  os_unfair_lock_s *v47;
  CMTime v49;
  CMTimeRange range;
  CMTime v51;
  CMTime v52;
  CMTime v53;
  CMTime time2;
  CMTime time1;

  v10 = *(_QWORD *)&a1[40]._os_unfair_lock_opaque;
  if (!v10 || (v11 = *(os_unfair_lock_s **)(v10 + 48)) == 0)
    v11 = a1 + 2;
  PCSpinLock::lock(v11);
  v12 = *(_OWORD *)(a2 + 16);
  v52 = *(CMTime *)a2;
  memset(&v51, 0, sizeof(v51));
  v13 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)&range.start.value = *(_OWORD *)a2;
  *(_OWORD *)&range.start.epoch = v12;
  *(_OWORD *)&range.duration.timescale = v13;
  CMTimeRangeGetEnd(&v51, &range);
  if (a4)
  {
    v14 = *(uint64_t **)&a1[4]._os_unfair_lock_opaque;
    if (v14 == *(uint64_t **)&a1[6]._os_unfair_lock_opaque)
    {
      *(_OWORD *)&time1.value = *MEMORY[0x1E0CA2E18];
      v16 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
    }
    else
    {
      v15 = *v14;
      *(_OWORD *)&time1.value = *(_OWORD *)(v15 + 16);
      v16 = *(_QWORD *)(v15 + 32);
    }
    time1.epoch = v16;
    *(_OWORD *)a4 = *(_OWORD *)&time1.value;
    *(_QWORD *)(a4 + 16) = v16;
  }
  if (a5)
  {
    v17 = *(_QWORD *)&a1[6]._os_unfair_lock_opaque;
    if (*(_QWORD *)&a1[4]._os_unfair_lock_opaque == v17)
    {
      *(_OWORD *)&time1.value = *MEMORY[0x1E0CA2E18];
      v19 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
    }
    else
    {
      v18 = *(_QWORD *)(v17 - 8);
      *(_OWORD *)&time1.value = *(_OWORD *)(v18 + 16);
      v19 = *(_QWORD *)(v18 + 32);
    }
    time1.epoch = v19;
    *(_OWORD *)a5 = *(_OWORD *)&time1.value;
    *(_QWORD *)(a5 + 16) = v19;
  }
  v20 = *(_QWORD **)&a1[10]._os_unfair_lock_opaque;
  v21 = *(_QWORD *)&a1[12]._os_unfair_lock_opaque - (_QWORD)v20;
  if (v21)
  {
    v22 = v21 >> 3;
    do
    {
      while (1)
      {
        v23 = v22 >> 1;
        v24 = &v20[v22 >> 1];
        if (*v24)
          break;
        v22 >>= 1;
        if (!v23)
          goto LABEL_25;
      }
      v53 = *(CMTime *)(*v24 + 16);
      time1 = v53;
      time2 = v52;
      v25 = CMTimeCompare(&time1, &time2);
      if (v25 < 0)
        v22 += ~v23;
      else
        v22 >>= 1;
      if (v25 < 0)
        v20 = v24 + 1;
    }
    while (v22);
LABEL_25:
    if (v20 != *(_QWORD **)&a1[10]._os_unfair_lock_opaque && v20 != *(_QWORD **)&a1[12]._os_unfair_lock_opaque)
    {
      v53 = *(CMTime *)(*v20 + 16);
      time1 = v53;
      time2 = v52;
      if (CMTimeCompare(&time1, &time2) <= 0)
        v26 = 0;
      else
        v26 = -1;
      v20 += v26;
    }
  }
  if (v20 != *(_QWORD **)&a1[12]._os_unfair_lock_opaque)
  {
    v27 = MEMORY[0x1E0CA2E68];
    do
    {
      *(_OWORD *)&v49.value = *(_OWORD *)(*v20 + 16);
      v49.epoch = *(_QWORD *)(*v20 + 32);
      v28 = (*(double (**)(_QWORD, uint64_t))(*(_QWORD *)*v20 + 24))(*v20, v27);
      v29 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v20 + 208))(*v20);
      v30 = v29;
      v31 = (char *)a3[1];
      v32 = (char *)a3[2];
      if (v31 >= v32)
      {
        v34 = 0xCCCCCCCCCCCCCCCDLL * ((v31 - (_BYTE *)*a3) >> 3);
        v35 = v34 + 1;
        if (v34 + 1 > 0x666666666666666)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v36 = 0xCCCCCCCCCCCCCCCDLL * ((v32 - (_BYTE *)*a3) >> 3);
        if (2 * v36 > v35)
          v35 = 2 * v36;
        if (v36 >= 0x333333333333333)
          v37 = 0x666666666666666;
        else
          v37 = v35;
        if (v37)
          v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<CMTime,std::pair<double,unsigned int>>>>((uint64_t)(a3 + 2), v37);
        else
          v38 = 0;
        v39 = &v38[40 * v34];
        *((_QWORD *)v39 + 2) = v49.epoch;
        *(_OWORD *)v39 = *(_OWORD *)&v49.value;
        *((double *)v39 + 3) = v28;
        *((_DWORD *)v39 + 8) = v30;
        v41 = (char *)*a3;
        v40 = (char *)a3[1];
        v42 = v39;
        if (v40 != *a3)
        {
          do
          {
            v43 = *(_OWORD *)(v40 - 40);
            v44 = *(_OWORD *)(v40 - 24);
            *((_QWORD *)v42 - 1) = *((_QWORD *)v40 - 1);
            *(_OWORD *)(v42 - 24) = v44;
            *(_OWORD *)(v42 - 40) = v43;
            v42 -= 40;
            v40 -= 40;
          }
          while (v40 != v41);
          v40 = (char *)*a3;
        }
        v33 = v39 + 40;
        *a3 = v42;
        a3[1] = v39 + 40;
        a3[2] = &v38[40 * v37];
        if (v40)
          operator delete(v40);
      }
      else
      {
        *(_OWORD *)v31 = *(_OWORD *)&v49.value;
        *((_QWORD *)v31 + 2) = v49.epoch;
        *((double *)v31 + 3) = v28;
        *((_DWORD *)v31 + 8) = v29;
        v33 = v31 + 40;
      }
      a3[1] = v33;
      ++v20;
      time1 = v49;
      time2 = v51;
      v45 = CMTimeCompare(&time1, &time2);
    }
    while (v20 != *(_QWORD **)&a1[12]._os_unfair_lock_opaque && v45 < 0);
  }
  v46 = *(_QWORD *)&a1[40]._os_unfair_lock_opaque;
  if (!v46 || (v47 = *(os_unfair_lock_s **)(v46 + 48)) == 0)
    v47 = a1 + 2;
  PCSpinLock::unlock(v47);
  return 1;
}

BOOL OZSpline::getVertex(OZSpline *this, void *a2, CMTime *a3, double *a4, const CMTime *a5)
{
  __int128 v6;

  if (a2)
  {
    if (a3)
    {
      v6 = *((_OWORD *)a2 + 1);
      a3->epoch = *((_QWORD *)a2 + 4);
      *(_OWORD *)&a3->value = v6;
    }
    if (a4)
      *a4 = (*(double (**)(void *, const CMTime *))(*(_QWORD *)a2 + 24))(a2, a5);
  }
  return a2 != 0;
}

BOOL OZSpline::setVertexValue(OZSpline *this, void *a2, double a3, const CMTime *a4)
{
  uint64_t v8;
  os_unfair_lock_s *v9;
  uint64_t v10;
  os_unfair_lock_s *v11;

  if (a2)
  {
    v8 = *((_QWORD *)this + 20);
    if (!v8 || (v9 = *(os_unfair_lock_s **)(v8 + 48)) == 0)
      v9 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::lock(v9);
    (*(void (**)(void *, const CMTime *, double))(*(_QWORD *)a2 + 32))(a2, a4, a3);
    v10 = *((_QWORD *)this + 20);
    if (!v10 || (v11 = *(os_unfair_lock_s **)(v10 + 48)) == 0)
      v11 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::unlock(v11);
  }
  return a2 != 0;
}

void OZSpline::setAllVerticesValues(OZSpline *this, double a2, const CMTime *a3)
{
  uint64_t v6;
  os_unfair_lock_s *v7;
  uint64_t *i;
  uint64_t v9;
  uint64_t v10;
  os_unfair_lock_s *v11;

  v6 = *((_QWORD *)this + 20);
  if (!v6 || (v7 = *(os_unfair_lock_s **)(v6 + 48)) == 0)
    v7 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v7);
  for (i = (uint64_t *)*((_QWORD *)this + 5); i != *((uint64_t **)this + 6); ++i)
  {
    v9 = *i;
    (*(void (**)(uint64_t, const CMTime *, double))(*(_QWORD *)v9 + 32))(v9, a3, a2);
  }
  v10 = *((_QWORD *)this + 20);
  if (!v10 || (v11 = *(os_unfair_lock_s **)(v10 + 48)) == 0)
    v11 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v11);
}

BOOL OZSpline::setVertex(OZSpline *this, char *a2, const CMTime *a3, double a4, const CMTime *a5)
{
  uint64_t v10;
  os_unfair_lock_s *v11;
  _BOOL8 v12;
  void **VertexIter;
  void **v14;
  char *v15;
  void **v16;
  char **v17;
  int64_t v18;
  char *v19;
  _QWORD *v20;
  unint64_t v21;
  char **v22;
  _QWORD *v23;
  uint64_t v24;
  os_unfair_lock_s *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  char **v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  uint64_t v38;
  CMTime v40;
  CMTime v41;
  CMTimeEpoch v42;
  CMTimeEpoch v43;
  char *v44;
  CMTime time2;
  CMTime time1;

  v10 = *((_QWORD *)this + 20);
  if (!v10 || (v11 = *(os_unfair_lock_s **)(v10 + 48)) == 0)
    v11 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v11);
  v44 = a2;
  v12 = a2 != 0;
  if (a2)
  {
    time2 = *(CMTime *)(a2 + 16);
    time1 = *a3;
    if (!CMTimeCompare(&time1, &time2))
    {
      (*(void (**)(char *, const CMTime *, double))(*(_QWORD *)v44 + 32))(v44, a5, a4);
      *((_BYTE *)this + 145) = 1;
      *(_OWORD *)((char *)this + 40) = *((_OWORD *)this + 1);
      OZSpline::refreshValidVerticesList(this);
      v24 = *((_QWORD *)this + 20);
      if (!v24 || (v25 = *(os_unfair_lock_s **)(v24 + 48)) == 0)
        v25 = (os_unfair_lock_s *)((char *)this + 8);
      v12 = 1;
      goto LABEL_48;
    }
    VertexIter = OZSpline::getVertexIter(this, a2);
    v14 = VertexIter;
    v15 = (char *)*((_QWORD *)this + 2);
    v16 = (void **)*((_QWORD *)this + 3);
    v17 = (char **)((char *)this + 16);
    v18 = (char *)v16 - (char *)(VertexIter + 1);
    if (v16 != VertexIter + 1)
    {
      memmove(VertexIter, VertexIter + 1, (char *)v16 - (char *)(VertexIter + 1));
      v15 = *v17;
    }
    *((_QWORD *)this + 3) = (char *)v14 + v18;
    *((_BYTE *)this + 145) = 1;
    *((_QWORD *)this + 5) = v15;
    *((_QWORD *)this + 6) = (char *)v14 + v18;
    OZSpline::refreshValidVerticesList(this);
    (*(void (**)(char *, const CMTime *))(*(_QWORD *)v44 + 16))(v44, a3);
    (*(void (**)(char *, const CMTime *, double))(*(_QWORD *)v44 + 32))(v44, a5, a4);
    v19 = (char *)*((_QWORD *)this + 5);
    if (*((char **)this + 6) != v19)
    {
      v20 = (_QWORD *)*((_QWORD *)this + 5);
      while (1)
      {
        v42 = *(_QWORD *)(*v20 + 32);
        *(_OWORD *)&v40.value = *((_OWORD *)v44 + 1);
        v40.epoch = *((_QWORD *)v44 + 4);
        *(_OWORD *)&time1.value = *(_OWORD *)(*v20 + 16);
        time1.epoch = v42;
        time2 = v40;
        if (!CMTimeCompare(&time1, &time2))
          break;
        v43 = *(_QWORD *)(*v20 + 32);
        *(_OWORD *)&v41.value = *((_OWORD *)v44 + 1);
        v41.epoch = *((_QWORD *)v44 + 4);
        *(_OWORD *)&time1.value = *(_OWORD *)(*v20 + 16);
        time1.epoch = v43;
        time2 = v41;
        if (CMTimeCompare(&time1, &time2) >= 1)
        {
          std::vector<OZVertex *>::insert((uint64_t)this + 16, v19, (char *)&v44);
          *((_BYTE *)this + 145) = 1;
          v32 = *((_QWORD *)this + 2);
          v23 = (_QWORD *)*((_QWORD *)this + 3);
          goto LABEL_43;
        }
        ++v20;
        v19 += 8;
        if (v20 == *((_QWORD **)this + 6))
          goto LABEL_13;
      }
      if (((*(uint64_t (**)(_QWORD))(*(_QWORD *)*v20 + 168))(*v20) & 2) == 0)
        (*(void (**)(_QWORD, const CMTime *, double))(*(_QWORD *)*v20 + 32))(*v20, a5, a4);
      if (v44)
        (*(void (**)(char *))(*(_QWORD *)v44 + 8))(v44);
      *((_BYTE *)this + 145) = 1;
      *(_OWORD *)((char *)this + 40) = *((_OWORD *)this + 1);
      OZSpline::refreshValidVerticesList(this);
      v31 = *((_QWORD *)this + 20);
      if (v31)
      {
        v25 = *(os_unfair_lock_s **)(v31 + 48);
        if (v25)
        {
          v12 = 0;
          goto LABEL_48;
        }
      }
      v12 = 0;
      goto LABEL_47;
    }
LABEL_13:
    v21 = *((_QWORD *)this + 4);
    v22 = (char **)*((_QWORD *)this + 3);
    if ((unint64_t)v22 >= v21)
    {
      v26 = ((char *)v22 - *v17) >> 3;
      if ((unint64_t)(v26 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v27 = v21 - (_QWORD)*v17;
      v28 = v27 >> 2;
      if (v27 >> 2 <= (unint64_t)(v26 + 1))
        v28 = v26 + 1;
      if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8)
        v29 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v29 = v28;
      if (v29)
        v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 32, v29);
      else
        v30 = 0;
      v33 = (char **)&v30[8 * v26];
      v34 = &v30[8 * v29];
      *v33 = v44;
      v23 = v33 + 1;
      v36 = (char *)*((_QWORD *)this + 2);
      v35 = (char *)*((_QWORD *)this + 3);
      if (v35 != v36)
      {
        do
        {
          v37 = (char *)*((_QWORD *)v35 - 1);
          v35 -= 8;
          *--v33 = v37;
        }
        while (v35 != v36);
        v35 = *v17;
      }
      *((_QWORD *)this + 2) = v33;
      *((_QWORD *)this + 3) = v23;
      *((_QWORD *)this + 4) = v34;
      if (v35)
        operator delete(v35);
    }
    else
    {
      *v22 = v44;
      v23 = v22 + 1;
    }
    *((_QWORD *)this + 3) = v23;
    *((_BYTE *)this + 145) = 1;
    v32 = *((_QWORD *)this + 2);
LABEL_43:
    *((_QWORD *)this + 5) = v32;
    *((_QWORD *)this + 6) = v23;
    OZSpline::refreshValidVerticesList(this);
    if (*((_QWORD *)this + 3) - *((_QWORD *)this + 2) == 8)
      (*(void (**)(OZSpline *, char *, _QWORD, _QWORD))(*(_QWORD *)this + 304))(this, v44, MEMORY[0x1E0CA2E68], 0);
  }
  v38 = *((_QWORD *)this + 20);
  if (!v38 || (v25 = *(os_unfair_lock_s **)(v38 + 48)) == 0)
LABEL_47:
    v25 = (os_unfair_lock_s *)((char *)this + 8);
LABEL_48:
  PCSpinLock::unlock(v25);
  return v12;
}

char *std::vector<OZVertex *>::insert(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  void *__p;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v13 = *(char **)a1;
    v14 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 3) + 1;
    if (v14 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v15 = __src - v13;
    v16 = (__src - v13) >> 3;
    v17 = v7 - (_QWORD)v13;
    if (v17 >> 2 > v14)
      v14 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v14;
    v30 = a1 + 16;
    if (v18)
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a1 + 16, v18);
    else
      v19 = 0;
    v20 = &v19[8 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4)
          v22 = 1;
        else
          v22 = v15 >> 2;
        v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8, v22);
        v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[8 * v24];
        if (v19)
          operator delete(v19);
      }
      else
      {
        v21 = v16 + 2;
        if (v16 >= -1)
          v21 = v16 + 1;
        v20 -= 8 * (v21 >> 1);
        v27 = v20;
      }
    }
    *(_QWORD *)v20 = *(_QWORD *)v3;
    v28 = v20 + 8;
    v4 = std::vector<OZChannelBase *>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27)
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_QWORD *)__src = *(_QWORD *)a3;
    *(_QWORD *)(a1 + 8) = __src + 8;
  }
  else
  {
    v9 = __src + 8;
    v10 = v6 - 8;
    v11 = *(_QWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_QWORD *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    if (v4 <= v3)
      v3 += 8 * (*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    *(_QWORD *)v4 = *(_QWORD *)v3;
  }
  return v4;
}

void sub_1B2C4D848(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

char *OZSpline::moveVertex(OZSpline *this, char *a2, const CMTime *a3, const CMTime *a4, char a5, char a6, int a7)
{
  uint64_t v13;
  os_unfair_lock_s *v14;
  uint64_t v15;
  uint64_t v16;
  os_unfair_lock_s *v17;
  const CMTime *v19;
  void **VertexIter;
  void **v21;
  void **v22;
  int64_t v23;
  uint64_t v24;
  __int128 v25;
  CMTimeEpoch v26;
  uint64_t v27;
  __int128 v28;
  char *v29;
  char **v30;
  __int128 v31;
  __int128 v32;
  unint64_t v33;
  char **v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char *v41;
  char **v42;
  char *v43;
  char *v44;
  char *v45;
  char *v46;
  char *v47;
  uint64_t v48;
  os_unfair_lock_s *v49;
  CMTimeEpoch v50;
  uint64_t v51;
  __int128 v52;
  CMTimeEpoch v53;
  CMTimeEpoch v54;
  CMTimeEpoch v55;
  CMTimeEpoch v56;
  CMTimeEpoch v57;
  CMTime v58;
  void *v59;
  void *v60;
  CMTime v61;
  CMTime v62;
  char *v63;
  CMTime time2;
  CMTime time1;

  v62 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  v61 = *a3;
  if (!a2)
    return 0;
  v13 = *((_QWORD *)this + 20);
  if (!v13 || (v14 = *(os_unfair_lock_s **)(v13 + 48)) == 0)
    v14 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::lock(v14);
  if (((*(uint64_t (**)(char *))(*(_QWORD *)a2 + 168))(a2) & 2) != 0
    || (time2 = *(CMTime *)(a2 + 16), time1 = v61, !CMTimeCompare(&time1, &time2))
    || ((*(uint64_t (**)(char *, const CMTime *))(*(_QWORD *)a2 + 136))(a2, a4) & 1) == 0)
  {
    v16 = *((_QWORD *)this + 20);
    if (!v16 || (v17 = *(os_unfair_lock_s **)(v16 + 48)) == 0)
      v17 = (os_unfair_lock_s *)((char *)this + 8);
    PCSpinLock::unlock(v17);
    return 0;
  }
  if ((a5 & 1) != 0)
  {
    v15 = (*(uint64_t (**)(char *))(*(_QWORD *)a2 + 216))(a2);
    v63 = (char *)v15;
  }
  else
  {
    v59 = 0;
    v60 = 0;
    v19 = (const CMTime *)MEMORY[0x1E0CA2E68];
    OZSpline::getPreviousValidVertex(this, a2, &v60, MEMORY[0x1E0CA2E68]);
    OZSpline::getNextValidVertex((void ***)this, a2, &v59, v19);
    v63 = a2;
    v62 = *(CMTime *)(a2 + 16);
    (*(void (**)(char *, CMTime *))(*(_QWORD *)a2 + 16))(a2, &v61);
    VertexIter = OZSpline::getVertexIter(this, a2);
    v21 = VertexIter;
    v22 = (void **)*((_QWORD *)this + 3);
    v23 = (char *)v22 - (char *)(VertexIter + 1);
    if (v22 != VertexIter + 1)
      memmove(VertexIter, VertexIter + 1, (char *)v22 - (char *)(VertexIter + 1));
    v24 = *((_QWORD *)this + 2);
    *((_QWORD *)this + 3) = (char *)v21 + v23;
    *((_BYTE *)this + 145) = 1;
    *((_QWORD *)this + 5) = v24;
    *((_QWORD *)this + 6) = (char *)v21 + v23;
    OZSpline::refreshValidVerticesList(this);
    if (!v60 || (v58 = *(CMTime *)((char *)v60 + 16), time1 = v61, time2 = v58, CMTimeCompare(&time1, &time2) >= 1))
    {
      if (!v59)
        goto LABEL_30;
      v25 = *((_OWORD *)v59 + 1);
      v55 = *((_QWORD *)v59 + 4);
      time1 = v61;
      *(_OWORD *)&time2.value = v25;
      time2.epoch = v55;
      if (CMTimeCompare(&time1, &time2) < 0)
        goto LABEL_30;
    }
    if (!a7)
    {
      (*(void (**)(char *, uint64_t))(*(_QWORD *)v63 + 152))(v63, 256);
      goto LABEL_30;
    }
    if (v60 && (v58 = *(CMTime *)((char *)v60 + 16), time1 = v61, time2 = v58, CMTimeCompare(&time1, &time2) <= 0))
    {
      v50 = *((_QWORD *)v60 + 4);
      v51 = *((_QWORD *)this + 21);
      v52 = *(_OWORD *)(v51 + 8);
      v54 = *(_QWORD *)(v51 + 24);
      *(_OWORD *)&time1.value = *((_OWORD *)v60 + 1);
      time1.epoch = v50;
      *(_OWORD *)&time2.value = v52;
      time2.epoch = v54;
      PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v58);
    }
    else
    {
      if (!v59)
        goto LABEL_30;
      v58 = *(CMTime *)((char *)v59 + 16);
      time1 = v61;
      time2 = v58;
      if (CMTimeCompare(&time1, &time2) < 0)
        goto LABEL_30;
      v26 = *((_QWORD *)v59 + 4);
      v27 = *((_QWORD *)this + 21);
      v28 = *(_OWORD *)(v27 + 8);
      v53 = *(_QWORD *)(v27 + 24);
      *(_OWORD *)&time1.value = *((_OWORD *)v59 + 1);
      time1.epoch = v26;
      *(_OWORD *)&time2.value = v28;
      time2.epoch = v53;
      PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v58);
    }
    v61 = v58;
    v15 = (uint64_t)v63;
  }
  (*(void (**)(uint64_t, CMTime *))(*(_QWORD *)v15 + 16))(v15, &v61);
LABEL_30:
  v29 = (char *)*((_QWORD *)this + 5);
  if (*((char **)this + 6) == v29)
  {
LABEL_35:
    time1 = v61;
    time2 = v62;
    if (CMTimeCompare(&time1, &time2))
      OZSpline::scaleTangentsAroundPoint((uint64_t)this, &v61, &v62, a4);
    v33 = *((_QWORD *)this + 4);
    v34 = (char **)*((_QWORD *)this + 3);
    if ((unint64_t)v34 >= v33)
    {
      v36 = *((_QWORD *)this + 2);
      v37 = ((uint64_t)v34 - v36) >> 3;
      if ((unint64_t)(v37 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v38 = v33 - v36;
      v39 = v38 >> 2;
      if (v38 >> 2 <= (unint64_t)(v37 + 1))
        v39 = v37 + 1;
      if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8)
        v40 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v40 = v39;
      if (v40)
        v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 32, v40);
      else
        v41 = 0;
      v42 = (char **)&v41[8 * v37];
      v43 = &v41[8 * v40];
      *v42 = v63;
      v35 = v42 + 1;
      v45 = (char *)*((_QWORD *)this + 2);
      v44 = (char *)*((_QWORD *)this + 3);
      if (v44 != v45)
      {
        do
        {
          v46 = (char *)*((_QWORD *)v44 - 1);
          v44 -= 8;
          *--v42 = v46;
        }
        while (v44 != v45);
        v44 = (char *)*((_QWORD *)this + 2);
      }
      *((_QWORD *)this + 2) = v42;
      *((_QWORD *)this + 3) = v35;
      *((_QWORD *)this + 4) = v43;
      if (v44)
        operator delete(v44);
    }
    else
    {
      *v34 = v63;
      v35 = v34 + 1;
    }
    *((_QWORD *)this + 3) = v35;
    *((_BYTE *)this + 145) = 1;
    *((_QWORD *)this + 5) = *((_QWORD *)this + 2);
    *((_QWORD *)this + 6) = v35;
LABEL_61:
    OZSpline::refreshValidVerticesList(this);
    v47 = v63;
    time1 = v61;
    time2 = v62;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v58);
    OZSpline::scaleTangentsAfterInsertion(this, v47, &v58, a4);
  }
  else
  {
    v30 = (char **)*((_QWORD *)this + 5);
    while (1)
    {
      v58 = *(CMTime *)(*v30 + 16);
      v31 = *((_OWORD *)v63 + 1);
      v56 = *((_QWORD *)v63 + 4);
      time1 = v58;
      *(_OWORD *)&time2.value = v31;
      time2.epoch = v56;
      if (!CMTimeCompare(&time1, &time2))
        break;
      v58 = *(CMTime *)(*v30 + 16);
      v32 = *((_OWORD *)v63 + 1);
      v57 = *((_QWORD *)v63 + 4);
      time1 = v58;
      *(_OWORD *)&time2.value = v32;
      time2.epoch = v57;
      if (CMTimeCompare(&time1, &time2) >= 1)
      {
        time1 = v61;
        time2 = v62;
        if (CMTimeCompare(&time1, &time2))
          OZSpline::scaleTangentsAroundPoint((uint64_t)this, &v61, &v62, a4);
        std::vector<OZVertex *>::insert((uint64_t)this + 16, v29, (char *)&v63);
        *((_BYTE *)this + 145) = 1;
        *(_OWORD *)((char *)this + 40) = *((_OWORD *)this + 1);
        goto LABEL_61;
      }
      ++v30;
      v29 += 8;
      if (v30 == *((char ***)this + 6))
        goto LABEL_35;
    }
    if ((a6 & 1) != 0)
    {
      if (v63)
        (*(void (**)(char *))(*(_QWORD *)v63 + 8))(v63);
      v63 = 0;
      *((_BYTE *)this + 145) = 1;
      *(_OWORD *)((char *)this + 40) = *((_OWORD *)this + 1);
      OZSpline::refreshValidVerticesList(this);
      v63 = *v30;
    }
    else
    {
      (*(void (**)(char *, uint64_t))(*(_QWORD *)*v30 + 152))(*v30, 256);
      time1 = v61;
      time2 = v62;
      if (CMTimeCompare(&time1, &time2))
        OZSpline::scaleTangentsAroundPoint((uint64_t)this, &v61, &v62, a4);
      std::vector<OZVertex *>::insert((uint64_t)this + 16, v29, (char *)&v63);
      *((_BYTE *)this + 145) = 1;
      *(_OWORD *)((char *)this + 40) = *((_OWORD *)this + 1);
      OZSpline::refreshValidVerticesList(this);
    }
  }
  v48 = *((_QWORD *)this + 20);
  if (!v48 || (v49 = *(os_unfair_lock_s **)(v48 + 48)) == 0)
    v49 = (os_unfair_lock_s *)((char *)this + 8);
  PCSpinLock::unlock(v49);
  return v63;
}

uint64_t OZSpline::scaleTangentsAroundPoint(uint64_t this, const CMTime *a2, const CMTime *a3, const CMTime *a4)
{
  CMTime *v4;
  OZSpline *v8;
  double v9;
  __n128 v10;
  __n128 v11;
  __n128 v12;
  __n128 v13;
  int32_t v14;
  double v15;
  double v16;
  int32_t v17;
  double v18;
  double Seconds;
  CMTime v20;
  CMTime v21;
  CMTime v22;
  CMTime v23;
  CMTime v24;
  CMTime v25;
  CMTime time;
  CMTime v27;
  CMTime v28;
  void *v29;
  void *v30;
  CMTime v31;
  double v32;
  double v33;
  CMTime time2;
  CMTime time1;

  v32 = 0.0;
  v33 = 0.0;
  v4 = (CMTime *)MEMORY[0x1E0CA2E68];
  v31 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  v29 = 0;
  v30 = 0;
  if (*(_BYTE *)(*(_QWORD *)(this + 168) + 2))
  {
    v8 = (OZSpline *)this;
    if (OZSpline::getNextValidVertex((OZSpline *)this, a3, &v29, a4, 0))
    {
      if (OZSpline::getPreviousValidVertex(v8, v29, &v30, v4))
      {
        v28 = *(CMTime *)((char *)v30 + 16);
        time1 = *a3;
        time2 = v28;
        this = CMTimeCompare(&time1, &time2);
        if ((_DWORD)this)
        {
          v27 = *(CMTime *)((char *)v29 + 16);
          time1 = *a3;
          time2 = v27;
          this = CMTimeCompare(&time1, &time2);
          if ((_DWORD)this)
          {
            (*(void (**)(void *, double *, double *, const CMTime *))(*(_QWORD *)v30 + 64))(v30, &v33, &v32, a4);
            v28 = *(CMTime *)((char *)v29 + 16);
            v27 = *(CMTime *)((char *)v30 + 16);
            time1 = v28;
            time2 = v27;
            PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v31);
            v27 = *(CMTime *)((char *)v30 + 16);
            time1 = *a3;
            time2 = v27;
            PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v28);
            operator/((__int128 *)&v31.value, (uint64_t)&v28, (uint64_t)&time);
            v9 = fabs(CMTimeGetSeconds(&time));
            (*(void (**)(void *, const CMTime *, double, double))(*(_QWORD *)v30 + 80))(v30, a4, v9 * v33, v9 * v32);
            (*(void (**)(void *, double *, double *, const CMTime *))(*(_QWORD *)v29 + 56))(v29, &v33, &v32, a4);
            v27 = *(CMTime *)((char *)v29 + 16);
            v25 = *(CMTime *)((char *)v30 + 16);
            time1 = v27;
            time2 = v25;
            PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v28);
            v31 = v28;
            v27 = *(CMTime *)((char *)v29 + 16);
            time1 = *a3;
            time2 = v27;
            PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v28);
            operator/((__int128 *)&v31.value, (uint64_t)&v28, (uint64_t)&v24);
            v10.n128_f64[0] = CMTimeGetSeconds(&v24);
            goto LABEL_18;
          }
        }
      }
      else
      {
        v28 = *(CMTime *)((char *)v29 + 16);
        time1 = *a3;
        time2 = v28;
        this = CMTimeCompare(&time1, &time2);
        if ((_DWORD)this)
        {
          (*(void (**)(void *, double *, double *, const CMTime *))(*(_QWORD *)v29 + 56))(v29, &v33, &v32, a4);
          v11.n128_u64[0] = 0;
          if (fabs(v33) < 0.0000001)
            goto LABEL_19;
          v27 = *(CMTime *)((char *)v29 + 16);
          time1 = *a3;
          time2 = v27;
          PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v28);
          time1 = v28;
          time2 = *v4;
          v17 = CMTimeCompare(&time1, &time2);
          v18 = 0.0277777778 / v33;
          if (!v17)
          {
            v11.n128_f64[0] = fabs(v18);
            goto LABEL_19;
          }
          v27 = *(CMTime *)((char *)v29 + 16);
          time1 = *a3;
          time2 = v27;
          PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v28);
          operator*(&v28, &v23, v18);
          Seconds = CMTimeGetSeconds(&v23);
          v27 = *(CMTime *)((char *)v29 + 16);
          time1 = *a2;
          time2 = v27;
          PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v28);
          operator*(&v28, &v22, v18);
          v10.n128_f64[0] = CMTimeGetSeconds(&v22);
          v11.n128_u64[0] = 0;
          if (vabdd_f64(0.0, fabs(Seconds)) < 0.0000001)
          {
LABEL_19:
            v10.n128_f64[0] = v11.n128_f64[0] * v33;
            v11.n128_f64[0] = v11.n128_f64[0] * v32;
            return (*(uint64_t (**)(__n128, __n128))(*(_QWORD *)v29 + 72))(v10, v11);
          }
          v10.n128_f64[0] = v10.n128_f64[0] / Seconds;
LABEL_18:
          v11.n128_f64[0] = fabs(v10.n128_f64[0]);
          goto LABEL_19;
        }
      }
    }
    else
    {
      this = OZSpline::getPreviousValidVertex(v8, a3, &v30, a4, 0);
      if ((_DWORD)this)
      {
        v28 = *(CMTime *)((char *)v30 + 16);
        time1 = *a3;
        time2 = v28;
        this = CMTimeCompare(&time1, &time2);
        if ((_DWORD)this)
        {
          (*(void (**)(void *, double *, double *, const CMTime *))(*(_QWORD *)v30 + 64))(v30, &v33, &v32, a4);
          v13.n128_u64[0] = 0;
          if (fabs(v33) >= 0.0000001)
          {
            v27 = *(CMTime *)((char *)v30 + 16);
            time1 = *a3;
            time2 = v27;
            PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v28);
            time1 = v28;
            time2 = *v4;
            v14 = CMTimeCompare(&time1, &time2);
            v15 = 0.0277777778 / v33;
            if (v14)
            {
              v27 = *(CMTime *)((char *)v30 + 16);
              time1 = *a3;
              time2 = v27;
              PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v28);
              operator*(&v28, &v21, v15);
              v16 = CMTimeGetSeconds(&v21);
              v27 = *(CMTime *)((char *)v30 + 16);
              time1 = *a2;
              time2 = v27;
              PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v28);
              operator*(&v28, &v20, v15);
              v12.n128_f64[0] = CMTimeGetSeconds(&v20);
              v13.n128_u64[0] = 0;
              if (vabdd_f64(0.0, fabs(v16)) >= 0.0000001)
                v13.n128_f64[0] = fabs(v12.n128_f64[0] / v16);
            }
            else
            {
              v13.n128_f64[0] = fabs(v15);
            }
          }
          v12.n128_f64[0] = v13.n128_f64[0] * v33;
          v13.n128_f64[0] = v13.n128_f64[0] * v32;
          return (*(uint64_t (**)(__n128, __n128))(*(_QWORD *)v30 + 80))(v12, v13);
        }
      }
    }
  }
  return this;
}

