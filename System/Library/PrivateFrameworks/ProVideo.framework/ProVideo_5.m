void sub_1B2A24F10(_Unwind_Exception *a1)
{
  HGObject *v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *((_QWORD *)v1 + 9) = v4;
    operator delete(v4);
  }
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGTransform::HGTransform(HGTransform *this)
{
  uint64_t v1;

  HGObject::HGObject(this);
  *(_QWORD *)v1 = off_1E651FBB8;
  *(_OWORD *)(v1 + 56) = 0u;
  *(_OWORD *)(v1 + 88) = 0u;
  *(_OWORD *)(v1 + 24) = 0u;
  *(_OWORD *)(v1 + 40) = 0u;
  *(_OWORD *)(v1 + 72) = 0u;
  *(_OWORD *)(v1 + 104) = 0u;
  *(_OWORD *)(v1 + 120) = 0u;
  *(_QWORD *)(v1 + 16) = 0x3FF0000000000000;
  *(_QWORD *)(v1 + 56) = 0x3FF0000000000000;
  *(_QWORD *)(v1 + 96) = 0x3FF0000000000000;
  *(_QWORD *)(v1 + 136) = 0x3FF0000000000000;
}

void HGTransform::~HGTransform(HGTransform *this)
{
  void *v1;

  HGObject::~HGObject(this);
  HGObject::operator delete(v1);
}

float64x2_t HGTransform::GetMatrixf(float64x2_t *this, float32x4_t *a2)
{
  float32x4_t v2;
  float64x2_t result;
  float32x4_t v4;

  v2 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[3]), this[4]);
  *a2 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[1]), this[2]);
  a2[1] = v2;
  result = this[8];
  v4 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[7]), result);
  a2[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[5]), this[6]);
  a2[3] = v4;
  return result;
}

double HGTransform::GetMatrixd(HGTransform *this, double *a2)
{
  double result;

  *a2 = *((double *)this + 2);
  a2[1] = *((double *)this + 3);
  a2[2] = *((double *)this + 4);
  a2[3] = *((double *)this + 5);
  a2[4] = *((double *)this + 6);
  a2[5] = *((double *)this + 7);
  a2[6] = *((double *)this + 8);
  a2[7] = *((double *)this + 9);
  a2[8] = *((double *)this + 10);
  a2[9] = *((double *)this + 11);
  a2[10] = *((double *)this + 12);
  a2[11] = *((double *)this + 13);
  a2[12] = *((double *)this + 14);
  a2[13] = *((double *)this + 15);
  a2[14] = *((double *)this + 16);
  result = *((double *)this + 17);
  a2[15] = result;
  return result;
}

float64x2_t HGTransform::GetMatrixfloat4x4(float64x2_t *this, simd::float4x4 *a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float64x2_t result;
  float32x4_t v5;

  v2 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[3]), this[4]);
  v3 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[5]), this[6]);
  result = this[8];
  v5 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[7]), result);
  a2->columns[0] = (simd_float4)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[1]), this[2]);
  a2->columns[1] = (simd_float4)v2;
  a2->columns[2] = (simd_float4)v3;
  a2->columns[3] = (simd_float4)v5;
  return result;
}

uint64_t HGTransform::GetMatrixPtr(HGTransform *this)
{
  return (uint64_t)this + 16;
}

double HGTransform::LoadIdentity(HGTransform *this)
{
  double result;

  result = 0.0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_QWORD *)this + 2) = 0x3FF0000000000000;
  *((_QWORD *)this + 7) = 0x3FF0000000000000;
  *((_QWORD *)this + 12) = 0x3FF0000000000000;
  *((_QWORD *)this + 17) = 0x3FF0000000000000;
  return result;
}

float64x2_t HGTransform::LoadColumnf(HGTransform *this, float32x2_t *a2, int a3)
{
  float64x2_t *v3;
  float64x2_t result;
  float64x2_t v5;

  v3 = (float64x2_t *)((char *)this + 32 * a3);
  result = vcvtq_f64_f32(*a2);
  v5 = vcvtq_f64_f32(a2[1]);
  v3[1] = result;
  v3[2] = v5;
  return result;
}

float64x2_t HGTransform::LoadMatrixf(float64x2_t *this, float32x2_t *a2)
{
  float64x2_t v2;
  float64x2_t v3;
  float64x2_t v4;
  float64x2_t result;
  float64x2_t v6;

  v2 = vcvtq_f64_f32(a2[1]);
  this[1] = vcvtq_f64_f32(*a2);
  this[2] = v2;
  v3 = vcvtq_f64_f32(a2[3]);
  this[3] = vcvtq_f64_f32(a2[2]);
  this[4] = v3;
  v4 = vcvtq_f64_f32(a2[5]);
  this[5] = vcvtq_f64_f32(a2[4]);
  this[6] = v4;
  result = vcvtq_f64_f32(a2[6]);
  v6 = vcvtq_f64_f32(a2[7]);
  this[7] = result;
  this[8] = v6;
  return result;
}

double HGTransform::LoadMatrixd(HGTransform *this, double *a2)
{
  double result;

  *((double *)this + 2) = *a2;
  *((double *)this + 3) = a2[1];
  *((double *)this + 4) = a2[2];
  *((double *)this + 5) = a2[3];
  *((double *)this + 6) = a2[4];
  *((double *)this + 7) = a2[5];
  *((double *)this + 8) = a2[6];
  *((double *)this + 9) = a2[7];
  *((double *)this + 10) = a2[8];
  *((double *)this + 11) = a2[9];
  *((double *)this + 12) = a2[10];
  *((double *)this + 13) = a2[11];
  *((double *)this + 14) = a2[12];
  *((double *)this + 15) = a2[13];
  *((double *)this + 16) = a2[14];
  result = a2[15];
  *((double *)this + 17) = result;
  return result;
}

uint64_t HGTransform::LoadMatrixfloat4x4(HGTransform *this, const simd::float4x4 *a2)
{
  simd_float4 v2;
  simd_float4 v3;
  _OWORD v5[4];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v2 = a2->columns[1];
  v5[0] = a2->columns[0];
  v5[1] = v2;
  v3 = a2->columns[3];
  v5[2] = a2->columns[2];
  v5[3] = v3;
  return (*(uint64_t (**)(HGTransform *, _OWORD *))(*(_QWORD *)this + 64))(this, v5);
}

uint64_t HGTransform::LoadMatrixdouble4x4(HGTransform *this, const simd::double4x4 *a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  _OWORD v7[8];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v2 = *(_OWORD *)&a2->columns[0].f64[2];
  v7[0] = *(_OWORD *)a2->columns[0].f64;
  v7[1] = v2;
  v3 = *(_OWORD *)&a2->columns[1].f64[2];
  v7[2] = *(_OWORD *)a2->columns[1].f64;
  v7[3] = v3;
  v4 = *(_OWORD *)&a2->columns[2].f64[2];
  v7[4] = *(_OWORD *)a2->columns[2].f64;
  v7[5] = v4;
  v5 = *(_OWORD *)&a2->columns[3].f64[2];
  v7[6] = *(_OWORD *)a2->columns[3].f64;
  v7[7] = v5;
  return (*(uint64_t (**)(HGTransform *, _OWORD *))(*(_QWORD *)this + 72))(this, v7);
}

__n128 HGTransform::LoadTransform(HGTransform *this, const HGTransform *a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __n128 result;
  __int128 v6;
  __int128 v7;

  v2 = *((_OWORD *)a2 + 1);
  v3 = *((_OWORD *)a2 + 2);
  v4 = *((_OWORD *)a2 + 4);
  *((_OWORD *)this + 3) = *((_OWORD *)a2 + 3);
  *((_OWORD *)this + 4) = v4;
  *((_OWORD *)this + 1) = v2;
  *((_OWORD *)this + 2) = v3;
  result = *((__n128 *)a2 + 5);
  v6 = *((_OWORD *)a2 + 6);
  v7 = *((_OWORD *)a2 + 8);
  *((_OWORD *)this + 7) = *((_OWORD *)a2 + 7);
  *((_OWORD *)this + 8) = v7;
  *((__n128 *)this + 5) = result;
  *((_OWORD *)this + 6) = v6;
  return result;
}

double HGTransform::LoadOrtho(HGTransform *this, float a2, float a3, float a4, float a5, float a6, float a7)
{
  double result;

  (*(void (**)(HGTransform *))(*(_QWORD *)this + 56))(this);
  *((double *)this + 2) = 2.0 / (float)(a3 - a2);
  *((double *)this + 7) = 2.0 / (float)(a5 - a4);
  *((double *)this + 12) = -2.0 / (float)(a7 - a6);
  *((double *)this + 14) = (float)((float)-(float)(a2 + a3) / (float)(a3 - a2));
  *((double *)this + 15) = (float)((float)-(float)(a4 + a5) / (float)(a5 - a4));
  result = (float)((float)-(float)(a6 + a7) / (float)(a7 - a6));
  *((double *)this + 16) = result;
  return result;
}

double HGTransform::LoadFrustum(HGTransform *this, float a2, float a3, float a4, float a5, float a6, float a7)
{
  double result;

  (*(void (**)(HGTransform *))(*(_QWORD *)this + 56))(this);
  *((double *)this + 2) = (float)((float)(a6 + a6) / (float)(a3 - a2));
  *((double *)this + 7) = (float)((float)(a6 + a6) / (float)(a5 - a4));
  *((double *)this + 10) = (float)((float)(a2 + a3) / (float)(a3 - a2));
  *((double *)this + 11) = (float)((float)(a4 + a5) / (float)(a5 - a4));
  *((_QWORD *)this + 15) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((double *)this + 12) = (float)((float)-(float)(a6 + a7) / (float)(a7 - a6));
  *((double *)this + 16) = (float)((float)((float)(a7 * -2.0) * a6) / (float)(a7 - a6));
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_OWORD *)this + 4) = 0u;
  result = -1.0;
  *(_OWORD *)((char *)this + 104) = xmmword_1B3058A90;
  *((_QWORD *)this + 17) = 0;
  return result;
}

void HGTransform::Translate(HGTransform *this, double a2, double a3, double a4)
{
  _QWORD v8[3];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  double v17;
  double v18;
  uint64_t v19;

  HGObject::HGObject((HGObject *)v8);
  v13 = 0;
  v9 = 0u;
  v10 = 0u;
  v12 = 0u;
  v8[0] = off_1E651FBB8;
  v8[2] = 0x3FF0000000000000;
  v11 = 0x3FF0000000000000uLL;
  v14 = 0x3FF0000000000000;
  v15 = 0;
  v19 = 0x3FF0000000000000;
  v16 = a2;
  v17 = a3;
  v18 = a4;
  (*(void (**)(HGTransform *, _QWORD *))(*(_QWORD *)this + 192))(this, v8);
  HGObject::~HGObject((HGObject *)v8);
}

void sub_1B2A25524(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGObject::~HGObject((HGObject *)&a9);
  _Unwind_Resume(a1);
}

void HGTransform::Rotate(HGTransform *this, double a2, double a3, double a4, double a5)
{
  double v9;
  float v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  float v17;
  double v18;
  double v19;
  double v20;
  double v21;
  _QWORD v22[13];
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v9 = a2 * 0.0174532925;
  v10 = sin(a2 * 0.0174532925);
  if (v10 != 0.0)
  {
    v11 = a3 * a3;
    v12 = a4 * a4;
    v13 = a5 * a5;
    v14 = a3 * a3 + a4 * a4 + a5 * a5;
    if (v14 != 1.0)
    {
      if (v14 == 0.0)
        return;
      v15 = sqrt(v14);
      a3 = a3 / v15;
      a4 = a4 / v15;
      a5 = a5 / v15;
      v11 = v11 / v14;
      v12 = v12 / v14;
      v13 = v13 / v14;
    }
    v16 = v10;
    v17 = cos(v9);
    v18 = v17;
    HGObject::HGObject((HGObject *)v22);
    v22[0] = off_1E651FBB8;
    v22[5] = 0;
    v22[9] = 0;
    v23 = 0u;
    v24 = 0u;
    v25 = 0x3FF0000000000000;
    v19 = (1.0 - v18) * (a4 * a3);
    *(double *)&v22[2] = (1.0 - v18) * v11 + v18;
    *(double *)&v22[3] = v19 - a5 * v16;
    v20 = (1.0 - v18) * (a5 * a3);
    *(double *)&v22[4] = a4 * v16 + v20;
    v21 = (1.0 - v18) * (a5 * a4);
    *(double *)&v22[6] = a5 * v16 + v19;
    *(double *)&v22[7] = (1.0 - v18) * v12 + v18;
    *(double *)&v22[8] = v21 - a3 * v16;
    *(double *)&v22[10] = v20 - a4 * v16;
    *(double *)&v22[11] = v21 + a3 * v16;
    *(double *)&v22[12] = (1.0 - v18) * v13 + v18;
    (*(void (**)(HGTransform *, _QWORD *))(*(_QWORD *)this + 192))(this, v22);
    HGObject::~HGObject((HGObject *)v22);
  }
}

void sub_1B2A256C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGObject::~HGObject((HGObject *)&a9);
  _Unwind_Resume(a1);
}

void HGTransform::Shear(HGTransform *this, double a2, double a3, double a4, double a5)
{
  __double2 v9;
  float sinval;
  float cosval;
  double v12;
  double v13;
  double v14;
  BOOL v15;
  double v16;
  _QWORD v17[3];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v9 = __sincos_stret(a2 * 0.0174532925);
  sinval = v9.__sinval;
  if (sinval != 0.0)
  {
    cosval = v9.__cosval;
    if (cosval != 0.0)
    {
      v12 = a3 * a3;
      v13 = a3 * a3 + a4 * a4 + a5 * a5;
      if (v13 != 1.0)
      {
        if (v13 == 0.0)
          return;
        a3 = a3 / sqrt(v13);
        v12 = v12 / v13;
      }
      v14 = sinval;
      HGObject::HGObject((HGObject *)v17);
      v15 = a3 < 0.0 && v12 == 1.0;
      v22 = 0;
      v19 = 0u;
      v18 = 0u;
      v21 = 0u;
      v24 = 0u;
      v25 = 0u;
      v17[0] = off_1E651FBB8;
      v17[2] = 0x3FF0000000000000;
      v20 = 0x3FF0000000000000uLL;
      v23 = 0x3FF0000000000000;
      v26 = 0x3FF0000000000000;
      v16 = -v14;
      if (v15)
        v16 = v14;
      *((double *)&v19 + 1) = v16 / *(float *)&v9.__cosval;
      (*(void (**)(HGTransform *, _QWORD *))(*(_QWORD *)this + 192))(this, v17);
      HGObject::~HGObject((HGObject *)v17);
    }
  }
}

void sub_1B2A25804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGObject::~HGObject((HGObject *)&a9);
  _Unwind_Resume(a1);
}

void HGTransform::Scale(HGTransform *this, double a2, double a3, double a4)
{
  _QWORD v8[3];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  double v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  HGObject::HGObject((HGObject *)v8);
  v8[0] = off_1E651FBB8;
  v13 = 0;
  v9 = 0u;
  v10 = 0u;
  v12 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0x3FF0000000000000;
  *(double *)&v8[2] = a2;
  v11 = *(unint64_t *)&a3;
  v14 = a4;
  (*(void (**)(HGTransform *, _QWORD *))(*(_QWORD *)this + 192))(this, v8);
  HGObject::~HGObject((HGObject *)v8);
}

void sub_1B2A258BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGObject::~HGObject((HGObject *)&a9);
  _Unwind_Resume(a1);
}

void HGTransform::Perspective(HGTransform *this, double a2, double a3)
{
  float v6;
  double v7;
  _QWORD v8[3];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  double v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  HGObject::HGObject((HGObject *)v8);
  v13 = 0;
  v9 = 0u;
  v10 = 0u;
  v12 = 0u;
  v15 = 0u;
  v16 = 0u;
  v8[0] = off_1E651FBB8;
  v8[2] = 0x3FF0000000000000;
  v11 = 0x3FF0000000000000uLL;
  v14 = 1.0;
  v17 = 0x3FF0000000000000;
  v6 = tan(a2 * 0.00872664626);
  v7 = v6 + v6;
  if (v7 != 0.0)
  {
    v14 = a3 / v7 + 1.0;
    *(double *)&v15 = -v7 / a3;
    *((double *)&v16 + 1) = -v14;
    (*(void (**)(HGTransform *, _QWORD *))(*(_QWORD *)this + 192))(this, v8);
  }
  HGObject::~HGObject((HGObject *)v8);
}

void sub_1B2A259AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGObject::~HGObject((HGObject *)&a9);
  _Unwind_Resume(a1);
}

float64x2_t HGTransform::Multiply(float64x2_t *this, float64x2_t *a2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  float64x2_t v6;
  float64x2_t v7;
  double v8;
  double v9;
  double v10;
  float64x2_t v11;
  float64x2_t v12;
  double v13;
  double v14;
  double v15;
  float64x2_t v16;
  float64x2_t v17;
  double v18;
  double v19;
  double v20;
  float64x2_t v21;
  float64x2_t result;

  if (a2)
  {
    v2 = this[1].f64[0];
    v3 = this[1].f64[1];
    v4 = this[2].f64[0];
    v5 = this[2].f64[1];
    v6 = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[1], v2), vmulq_n_f64(a2[3], v3)), vmulq_n_f64(a2[5], v4)), vmulq_n_f64(a2[7], v5));
    v7 = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[2], v2), vmulq_n_f64(a2[4], v3)), vmulq_n_f64(a2[6], v4)), vmulq_n_f64(a2[8], v5));
    this[1] = v6;
    this[2] = v7;
    v7.f64[0] = this[3].f64[0];
    v8 = this[3].f64[1];
    v9 = this[4].f64[0];
    v10 = this[4].f64[1];
    v11 = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[1], v7.f64[0]), vmulq_n_f64(a2[3], v8)), vmulq_n_f64(a2[5], v9)), vmulq_n_f64(a2[7], v10));
    v12 = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[2], v7.f64[0]), vmulq_n_f64(a2[4], v8)), vmulq_n_f64(a2[6], v9)), vmulq_n_f64(a2[8], v10));
    this[3] = v11;
    this[4] = v12;
    v12.f64[0] = this[5].f64[0];
    v13 = this[5].f64[1];
    v14 = this[6].f64[0];
    v15 = this[6].f64[1];
    v16 = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[1], v12.f64[0]), vmulq_n_f64(a2[3], v13)), vmulq_n_f64(a2[5], v14)), vmulq_n_f64(a2[7], v15));
    v17 = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[2], v12.f64[0]), vmulq_n_f64(a2[4], v13)), vmulq_n_f64(a2[6], v14)), vmulq_n_f64(a2[8], v15));
    this[5] = v16;
    this[6] = v17;
    v17.f64[0] = this[7].f64[0];
    v18 = this[7].f64[1];
    v19 = this[8].f64[0];
    v20 = this[8].f64[1];
    v21 = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[1], v17.f64[0]), vmulq_n_f64(a2[3], v18)), vmulq_n_f64(a2[5], v19)), vmulq_n_f64(a2[7], v20));
    result = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[2], v17.f64[0]), vmulq_n_f64(a2[4], v18)), vmulq_n_f64(a2[6], v19)), vmulq_n_f64(a2[8], v20));
    this[7] = v21;
    this[8] = result;
  }
  return result;
}

double HGTransform::PreMultiply(HGTransform *this, const HGTransform *a2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double result;
  double v31;
  double v32;
  double v33;

  if (a2)
  {
    v2 = *((double *)this + 2);
    v3 = *((double *)this + 3);
    v4 = *((double *)this + 6);
    v5 = *((double *)this + 7);
    v6 = *((double *)this + 10);
    v7 = *((double *)this + 11);
    v8 = *((double *)this + 14);
    v9 = *((double *)this + 15);
    v10 = v2 * *((double *)a2 + 2) + v4 * *((double *)a2 + 3) + v6 * *((double *)a2 + 4) + v8 * *((double *)a2 + 5);
    v11 = v2 * *((double *)a2 + 6) + v4 * *((double *)a2 + 7) + v6 * *((double *)a2 + 8) + v8 * *((double *)a2 + 9);
    v12 = v2 * *((double *)a2 + 10) + v4 * *((double *)a2 + 11) + v6 * *((double *)a2 + 12) + v8 * *((double *)a2 + 13);
    v13 = v2 * *((double *)a2 + 14) + v4 * *((double *)a2 + 15) + v6 * *((double *)a2 + 16) + v8 * *((double *)a2 + 17);
    *((double *)this + 2) = v10;
    *((double *)this + 6) = v11;
    *((double *)this + 10) = v12;
    *((double *)this + 14) = v13;
    v14 = v3 * *((double *)a2 + 2) + v5 * *((double *)a2 + 3) + v7 * *((double *)a2 + 4) + v9 * *((double *)a2 + 5);
    v15 = v3 * *((double *)a2 + 6) + v5 * *((double *)a2 + 7) + v7 * *((double *)a2 + 8) + v9 * *((double *)a2 + 9);
    v16 = v3 * *((double *)a2 + 10) + v5 * *((double *)a2 + 11) + v7 * *((double *)a2 + 12) + v9 * *((double *)a2 + 13);
    v17 = v3 * *((double *)a2 + 14) + v5 * *((double *)a2 + 15) + v7 * *((double *)a2 + 16) + v9 * *((double *)a2 + 17);
    *((double *)this + 3) = v14;
    *((double *)this + 7) = v15;
    *((double *)this + 11) = v16;
    *((double *)this + 15) = v17;
    v18 = *((double *)this + 4);
    v19 = *((double *)this + 5);
    v20 = *((double *)this + 8);
    v21 = *((double *)this + 9);
    v22 = *((double *)this + 12);
    v23 = *((double *)this + 13);
    v24 = *((double *)this + 16);
    v25 = *((double *)this + 17);
    v26 = v18 * *((double *)a2 + 2) + v20 * *((double *)a2 + 3) + v22 * *((double *)a2 + 4) + v24 * *((double *)a2 + 5);
    v27 = v18 * *((double *)a2 + 6) + v20 * *((double *)a2 + 7) + v22 * *((double *)a2 + 8) + v24 * *((double *)a2 + 9);
    v28 = v18 * *((double *)a2 + 10)
        + v20 * *((double *)a2 + 11)
        + v22 * *((double *)a2 + 12)
        + v24 * *((double *)a2 + 13);
    v29 = v18 * *((double *)a2 + 14)
        + v20 * *((double *)a2 + 15)
        + v22 * *((double *)a2 + 16)
        + v24 * *((double *)a2 + 17);
    *((double *)this + 4) = v26;
    *((double *)this + 8) = v27;
    *((double *)this + 12) = v28;
    *((double *)this + 16) = v29;
    result = v19 * *((double *)a2 + 2)
           + v21 * *((double *)a2 + 3)
           + v23 * *((double *)a2 + 4)
           + v25 * *((double *)a2 + 5);
    v31 = v19 * *((double *)a2 + 6) + v21 * *((double *)a2 + 7) + v23 * *((double *)a2 + 8) + v25 * *((double *)a2 + 9);
    v32 = v19 * *((double *)a2 + 10)
        + v21 * *((double *)a2 + 11)
        + v23 * *((double *)a2 + 12)
        + v25 * *((double *)a2 + 13);
    v33 = v19 * *((double *)a2 + 14)
        + v21 * *((double *)a2 + 15)
        + v23 * *((double *)a2 + 16)
        + v25 * *((double *)a2 + 17);
    *((double *)this + 5) = result;
    *((double *)this + 9) = v31;
    *((double *)this + 13) = v32;
    *((double *)this + 17) = v33;
  }
  return result;
}

float64x2_t *HGTransform::Transform(float64x2_t *this, float32x4_t *a2, const float *a3, int a4)
{
  float64x2_t v4;
  float64x2_t v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  float32x4_t *v15;
  const float *v16;
  uint64_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  int v25;
  float32x4x4_t v26;
  float32x4x4_t v27;

  if (a4 >= 1)
  {
    v5 = this[1];
    v4 = this[2];
    v7 = this[3];
    v6 = this[4];
    v9 = this[5];
    v8 = this[6];
    v11 = this[7];
    v10 = this[8];
    if (a4 < 4
      || ((v12 = 16 * (a4 - 1) + 16, (char *)a3 + v12 > (char *)a2)
        ? (v13 = (char *)a2 + v12 > (char *)a3)
        : (v13 = 0),
          v13))
    {
      LODWORD(v14) = 0;
      v15 = a2;
      v16 = a3;
    }
    else
    {
      v14 = a4 & 0xFFFFFFFC;
      v15 = &a2[v14];
      v16 = &a3[4 * v14];
      v17 = v14;
      do
      {
        v27 = vld4q_f32(a3);
        a3 += 16;
        v18 = vcvt_hight_f64_f32(v27.val[0]);
        v19 = vcvtq_f64_f32(*(float32x2_t *)v27.val[0].f32);
        v20 = vcvt_hight_f64_f32(v27.val[1]);
        v21 = vcvtq_f64_f32(*(float32x2_t *)v27.val[1].f32);
        v22 = vcvtq_f64_f32(*(float32x2_t *)v27.val[2].f32);
        v23 = vcvt_hight_f64_f32(v27.val[2]);
        v24 = vcvt_hight_f64_f32(v27.val[3]);
        v27.val[0] = (float32x4_t)vcvtq_f64_f32(*(float32x2_t *)v27.val[3].f32);
        v26.val[0] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v19, v5.f64[0]), vmulq_n_f64(v21, v7.f64[0])), vmulq_n_f64(v22, v9.f64[0])), vmulq_n_f64((float64x2_t)v27.val[0], v11.f64[0]))), vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v18, v5.f64[0]), vmulq_n_f64(v20, v7.f64[0])), vmulq_n_f64(v23, v9.f64[0])), vmulq_n_f64(v24, v11.f64[0])));
        v26.val[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vaddq_f64(vaddq_f64(vmulq_laneq_f64(v19, v5, 1), vmulq_laneq_f64(v21, v7, 1)), vmulq_laneq_f64(v22, v9, 1)), vmulq_laneq_f64((float64x2_t)v27.val[0], v11, 1))), vaddq_f64(vaddq_f64(vaddq_f64(vmulq_laneq_f64(v18, v5, 1), vmulq_laneq_f64(v20, v7, 1)), vmulq_laneq_f64(v23, v9, 1)), vmulq_laneq_f64(v24, v11, 1)));
        v26.val[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v19, v4.f64[0]), vmulq_n_f64(v21, v6.f64[0])), vmulq_n_f64(v22, v8.f64[0])), vmulq_n_f64((float64x2_t)v27.val[0], v10.f64[0]))), vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v18, v4.f64[0]), vmulq_n_f64(v20, v6.f64[0])), vmulq_n_f64(v23, v8.f64[0])), vmulq_n_f64(v24, v10.f64[0])));
        v26.val[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vaddq_f64(vaddq_f64(vmulq_laneq_f64(v19, v4, 1), vmulq_laneq_f64(v21, v6, 1)), vmulq_laneq_f64(v22, v8, 1)), vmulq_laneq_f64((float64x2_t)v27.val[0], v10, 1))), vaddq_f64(vaddq_f64(vaddq_f64(vmulq_laneq_f64(v18, v4, 1), vmulq_laneq_f64(v20, v6, 1)), vmulq_laneq_f64(v23, v8, 1)), vmulq_laneq_f64(v24, v10, 1)));
        vst4q_f32(a2->f32, v26);
        a2 += 4;
        v17 -= 4;
      }
      while (v17);
      if (v14 == a4)
        return this;
    }
    v25 = a4 - v14;
    do
    {
      *v15++ = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v5, *v16), vmulq_n_f64(v7, v16[1])), vmulq_n_f64(v9, v16[2])), vmulq_n_f64(v11, v16[3]))), vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v4, *v16), vmulq_n_f64(v6, v16[1])), vmulq_n_f64(v8, v16[2])), vmulq_n_f64(v10, v16[3])));
      v16 += 4;
      --v25;
    }
    while (v25);
  }
  return this;
}

float32x2_t HGTransform::Project(float64x2_t *this, float32x2_t *a2, int a3, int a4)
{
  float32x2_t result;

  result = vcvt_f32_f64(vdivq_f64(vaddq_f64(this[7], vaddq_f64(vmulq_n_f64(this[1], (double)a3), vmulq_n_f64(this[3], (double)a4))), (float64x2_t)vdupq_lane_s64(COERCE__INT64(this[8].f64[1] + this[2].f64[1] * (double)a3 + this[4].f64[1] * (double)a4), 0)));
  *a2 = result;
  return result;
}

double *HGTransform::Invert(double *this)
{
  uint64_t v1;
  double *v2;
  double v3;
  double *v4;
  double v5;
  double *v6;
  double v7;
  double *v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double *v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  int v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  double v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  _DWORD v65[4];
  uint64_t v66;

  v1 = 0;
  v66 = *MEMORY[0x1E0C80C00];
  v2 = this + 2;
  v3 = this[2];
  v4 = this + 6;
  v5 = this[6];
  v6 = this + 10;
  v7 = this[10];
  v8 = this + 14;
  v9 = this[14];
  v10 = this[3];
  v11 = this[7];
  v12 = this[8];
  v13 = this[11];
  v14 = this[12];
  v16 = this[15];
  v15 = this[16];
  v18 = this[4];
  v17 = this[5];
  v19 = this[9];
  v20 = this[13];
  v21 = this + 2;
  v22 = 1.0;
  v23 = 1.0;
  v24 = 1.0;
  v25 = 1.0;
  v26 = this[17];
  do
  {
    v27 = fabs(v25 * v3);
    v28 = fabs(v24 * v10);
    v29 = fabs(v18 * v23);
    v30 = fabs(v17 * v22);
    if (v27 < v28)
      v31 = v28;
    else
      v31 = v27;
    if (v29 < v30)
      v32 = v30;
    else
      v32 = v29;
    if (v31 <= v32)
    {
      if (v29 <= v30)
      {
        if (v17 * v22 == 0.0)
        {
LABEL_21:
          this[2] = 1.0;
          *(_OWORD *)(this + 3) = 0u;
          *(_OWORD *)(this + 5) = 0u;
          this[7] = 1.0;
          *((_OWORD *)this + 4) = 0u;
          *((_OWORD *)this + 5) = 0u;
          this[12] = 1.0;
          *(_OWORD *)(this + 13) = 0u;
          *(_OWORD *)(this + 15) = 0u;
          this[17] = 1.0;
          return this;
        }
        v54 = v19 / v17;
        v19 = v20 / v17;
        v20 = v26 / v17;
        v55 = v19 * v3;
        v56 = v26 / v17 * v3;
        v26 = 1.0 / v17;
        v57 = 1.0 / v17 * v3;
        v3 = v5 - v54 * v3;
        v5 = v7 - v55;
        v7 = v9 - v56;
        v46 = v11 - v54 * v10;
        v11 = v13 - v19 * v10;
        v13 = v16 - v20 * v10;
        v58 = v18 * v19;
        v59 = v18 * v20;
        v60 = v18 * v26;
        v18 = v12 - v18 * v54;
        v12 = v14 - v58;
        v22 = 0.0;
        v9 = 0.0 - v57;
        v16 = 0.0 - v26 * v10;
        v14 = v15 - v59;
        v33 = 3;
        v15 = 0.0 - v60;
        v17 = v54;
        v8 = v2;
      }
      else
      {
        if (v18 * v23 == 0.0)
          goto LABEL_21;
        v42 = v12 / v18;
        v12 = v14 / v18;
        v14 = v15 / v18;
        v43 = v12 * v3;
        v44 = v15 / v18 * v3;
        v15 = 1.0 / v18;
        v45 = 1.0 / v18 * v3;
        v3 = v5 - v42 * v3;
        v5 = v7 - v43;
        v7 = v9 - v44;
        v46 = v11 - v42 * v10;
        v11 = v13 - v12 * v10;
        v13 = v16 - v14 * v10;
        v47 = v19 - v42 * v17;
        v19 = v20 - v12 * v17;
        v23 = 0.0;
        v9 = 0.0 - v45;
        v16 = 0.0 - v15 * v10;
        v20 = v26 - v17 * v14;
        v33 = 2;
        v18 = v42;
        v26 = 0.0 - v15 * v17;
        v17 = v47;
        v6 = v2;
      }
      v10 = v46;
    }
    else if (v27 <= v28)
    {
      if (v24 * v10 == 0.0)
        goto LABEL_21;
      v48 = v11 / v10;
      v11 = v13 / v10;
      v13 = v16 / v10;
      v49 = v11 * v3;
      v50 = v16 / v10 * v3;
      v16 = 1.0 / v10;
      v51 = 1.0 / v10 * v3;
      v3 = v5 - v48 * v3;
      v5 = v7 - v49;
      v7 = v9 - v50;
      v52 = v12 - v18 * v48;
      v12 = v14 - v18 * v11;
      v14 = v15 - v18 * v13;
      v53 = v19 - v17 * v48;
      v19 = v20 - v17 * v11;
      v24 = 0.0;
      v9 = 0.0 - v51;
      v15 = 0.0 - v18 * v16;
      v20 = v26 - v17 * v13;
      v33 = 1;
      v18 = v52;
      v26 = 0.0 - v17 * v16;
      v17 = v53;
      v4 = v2;
      v10 = v48;
    }
    else
    {
      if (v25 * v3 == 0.0)
        goto LABEL_21;
      v33 = 0;
      v34 = v5 / v3;
      v5 = v7 / v3;
      v35 = v10 * v34;
      v7 = v9 / v3;
      v36 = v10 * v5;
      v37 = v10 * (v9 / v3);
      v9 = 1.0 / v3;
      v38 = v10 * (1.0 / v3);
      v39 = v11 - v35;
      v11 = v13 - v36;
      v13 = v16 - v37;
      v40 = v12 - v18 * v34;
      v12 = v14 - v18 * v5;
      v14 = v15 - v18 * v7;
      v41 = v19 - v17 * v34;
      v19 = v20 - v17 * v5;
      v25 = 0.0;
      v16 = 0.0 - v38;
      v15 = 0.0 - v18 * v9;
      v20 = v26 - v17 * v7;
      v18 = v40;
      v26 = 0.0 - v17 * v9;
      v17 = v41;
      v21 = v2;
      v10 = v39;
      v3 = v34;
    }
    v65[v1++] = v33;
    v2 += 4;
  }
  while (v1 != 4);
  v61 = v65[1];
  v62 = v65[0];
  v63 = v65[2];
  v64 = v65[3];
  v21[v62] = v3;
  v61 *= 8;
  *(double *)((char *)v21 + v61) = v10;
  v63 *= 8;
  *(double *)((char *)v21 + v63) = v18;
  v64 *= 8;
  *(double *)((char *)v21 + v64) = v17;
  v4[v62] = v5;
  *(double *)((char *)v4 + v61) = v11;
  *(double *)((char *)v4 + v63) = v12;
  *(double *)((char *)v4 + v64) = v19;
  v6[v62] = v7;
  *(double *)((char *)v6 + v61) = v13;
  *(double *)((char *)v6 + v63) = v14;
  *(double *)((char *)v6 + v64) = v20;
  v8[v62] = v9;
  *(double *)((char *)v8 + v61) = v16;
  *(double *)((char *)v8 + v63) = v15;
  *(double *)((char *)v8 + v64) = v26;
  return this;
}

double HGTransform::Invert2D(HGTransform *this)
{
  double v1;
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double result;

  v2 = *((double *)this + 6);
  v1 = *((double *)this + 7);
  v3 = *((double *)this + 17);
  v4 = *((double *)this + 9);
  v6 = *((double *)this + 14);
  v5 = *((double *)this + 15);
  v7 = v1 * v3 - v4 * v5;
  v8 = *((double *)this + 5);
  v9 = v4 * v6 - v3 * v2;
  v10 = v5 * v2 - v1 * v6;
  v11 = *((double *)this + 2);
  v12 = *((double *)this + 3);
  v13 = v7 * v11 + v12 * v9 + v10 * v8;
  if (v13 == 0.0)
    v13 = 0.0000000596046448;
  v14 = (v1 * v11 - v2 * v12) / v13;
  v15 = fabs(v14);
  v16 = -0.0000000596046448;
  if (v14 >= 0.0)
    v16 = 0.0000000596046448;
  if (v15 <= 0.0000000596046448)
    v17 = v16;
  else
    v17 = (v1 * v11 - v2 * v12) / v13;
  *((double *)this + 2) = v7 / v13;
  *((double *)this + 3) = (v5 * v8 - v3 * v12) / v13;
  *((double *)this + 5) = (v4 * v12 - v1 * v8) / v13;
  *((double *)this + 6) = v9 / v13;
  *((double *)this + 7) = (v3 * v11 - v6 * v8) / v13;
  *((double *)this + 9) = (v2 * v8 - v4 * v11) / v13;
  *((double *)this + 14) = v10 / v13;
  *((double *)this + 15) = (v6 * v12 - v5 * v11) / v13;
  *((double *)this + 17) = v17;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  result = 1.0;
  *((_OWORD *)this + 6) = xmmword_1B304EED0;
  return result;
}

double HGTransform::Adjoint2D(HGTransform *this)
{
  double v1;
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double result;

  v2 = *((double *)this + 6);
  v1 = *((double *)this + 7);
  v3 = *((double *)this + 17);
  v4 = *((double *)this + 9);
  v6 = *((double *)this + 14);
  v5 = *((double *)this + 15);
  v7 = *((double *)this + 5);
  v9 = *((double *)this + 2);
  v8 = *((double *)this + 3);
  *((double *)this + 2) = v1 * v3 - v4 * v5;
  *((double *)this + 3) = v5 * v7 - v3 * v8;
  *((double *)this + 5) = v4 * v8 - v1 * v7;
  *((double *)this + 6) = v4 * v6 - v3 * v2;
  *((double *)this + 7) = v3 * v9 - v6 * v7;
  *((double *)this + 9) = v2 * v7 - v4 * v9;
  *((double *)this + 14) = v5 * v2 - v1 * v6;
  *((double *)this + 15) = v6 * v8 - v5 * v9;
  *((double *)this + 17) = v1 * v9 - v2 * v8;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  result = 1.0;
  *((_OWORD *)this + 6) = xmmword_1B304EED0;
  return result;
}

double HGTransform::Matrix2D(HGTransform *this)
{
  double result;

  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  result = 1.0;
  *((_OWORD *)this + 6) = xmmword_1B304EED0;
  return result;
}

BOOL HGTransform::IsIdentity(HGTransform *this)
{
  return *((double *)this + 2) == 1.0
      && *((double *)this + 3) == 0.0
      && *((double *)this + 4) == 0.0
      && *((double *)this + 5) == 0.0
      && *((double *)this + 6) == 0.0
      && *((double *)this + 7) == 1.0
      && *((double *)this + 8) == 0.0
      && *((double *)this + 9) == 0.0
      && *((double *)this + 10) == 0.0
      && *((double *)this + 11) == 0.0
      && *((double *)this + 12) == 1.0
      && *((double *)this + 13) == 0.0
      && *((double *)this + 14) == 0.0
      && *((double *)this + 15) == 0.0
      && *((double *)this + 16) == 0.0
      && *((double *)this + 17) == 1.0;
}

BOOL HGTransform::IsEqual(HGTransform *this, HGTransform *a2)
{
  return a2
      && *((double *)this + 2) == *((double *)a2 + 2)
      && *((double *)this + 3) == *((double *)a2 + 3)
      && *((double *)this + 4) == *((double *)a2 + 4)
      && *((double *)this + 5) == *((double *)a2 + 5)
      && *((double *)this + 6) == *((double *)a2 + 6)
      && *((double *)this + 7) == *((double *)a2 + 7)
      && *((double *)this + 8) == *((double *)a2 + 8)
      && *((double *)this + 9) == *((double *)a2 + 9)
      && *((double *)this + 10) == *((double *)a2 + 10)
      && *((double *)this + 11) == *((double *)a2 + 11)
      && *((double *)this + 12) == *((double *)a2 + 12)
      && *((double *)this + 13) == *((double *)a2 + 13)
      && *((double *)this + 14) == *((double *)a2 + 14)
      && *((double *)this + 15) == *((double *)a2 + 15)
      && *((double *)this + 16) == *((double *)a2 + 16)
      && *((double *)this + 17) == *((double *)a2 + 17);
}

BOOL HGTransform::IsXYFlipAndOrIntegerTranslation(HGTransform *this)
{
  _BOOL4 v1;
  double v2;
  double v4;
  _BOOL4 v5;
  double v6;
  float v7;
  double v8;
  float v9;

  v1 = *((double *)this + 3) != 0.0
    || *((double *)this + 4) != 0.0
    || *((double *)this + 5) != 0.0
    || *((double *)this + 6) != 0.0
    || *((double *)this + 8) != 0.0
    || *((double *)this + 9) != 0.0
    || *((double *)this + 10) != 0.0
    || *((double *)this + 11) != 0.0
    || *((double *)this + 12) != 1.0
    || *((double *)this + 13) != 0.0
    || *((double *)this + 16) != 0.0
    || *((double *)this + 17) != 1.0;
  v2 = *((double *)this + 2);
  if (v2 != 1.0 && v2 != -1.0)
    return 0;
  v4 = *((double *)this + 7);
  v5 = v4 != 1.0;
  if (v4 == -1.0)
    v5 = 0;
  if (v1 || v5)
    return 0;
  v6 = *((double *)this + 14);
  v7 = v6;
  if (vabdd_f64((double)(int)llroundf(v7), v6) >= 0.00100000005)
    return 0;
  v8 = *((double *)this + 15);
  v9 = v8;
  return vabdd_f64((double)(int)llroundf(v9), v8) < 0.00100000005;
}

BOOL HGTransform::HasPerspective(HGTransform *this)
{
  return fabs(*((double *)this + 5)) >= 0.00000381469727
      || fabs(*((double *)this + 9)) >= 0.00000381469727
      || fabs(*((double *)this + 13)) >= 0.00000381469727
      || vabdd_f64(1.0, *((double *)this + 17)) >= 0.00000381469727;
}

double HGTransform::Transpose(HGTransform *this)
{
  float v1;
  float v2;
  double v3;
  uint64_t v4;
  uint64_t v5;
  double v6;
  double v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  double result;

  v1 = *((double *)this + 3);
  v2 = *((double *)this + 4);
  v3 = *((double *)this + 5);
  v4 = *((_QWORD *)this + 10);
  v5 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 3) = *((_QWORD *)this + 6);
  *((_QWORD *)this + 4) = v4;
  v6 = *((double *)this + 13);
  *((_QWORD *)this + 5) = *((_QWORD *)this + 14);
  *((double *)this + 6) = v1;
  v7 = *((double *)this + 9);
  v8 = *((double *)this + 8);
  *((double *)this + 10) = v2;
  *((double *)this + 11) = v8;
  v9 = *((_QWORD *)this + 15);
  v10 = *((_QWORD *)this + 16);
  *((_QWORD *)this + 8) = v5;
  *((_QWORD *)this + 9) = v9;
  *(float *)&v9 = v3;
  *((_QWORD *)this + 13) = v10;
  *((double *)this + 14) = *(float *)&v9;
  *(float *)&v9 = v7;
  result = *(float *)&v9;
  *(float *)&v10 = v6;
  *((double *)this + 15) = result;
  *((double *)this + 16) = *(float *)&v10;
  return result;
}

uint64_t HGTransformUtils::GetDOD(HGTransformUtils *this, const HGTransform *a2, HGRect a3, float a4, float a5)
{
  uint64_t v7;
  _BOOL8 v11;
  unsigned int v12;
  _BOOL4 v13;
  int v14;
  char v15;
  char v16;
  float *v17;
  float *v18;
  float v19;
  float v20;
  float v21;
  int v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  char v26;
  unsigned int v27;
  float32x2_t *v28;
  float32x2_t *v29;
  float v30;
  float32x2_t *v31;
  float32x2_t v32;
  float v33;
  __int32 *v34;
  __int32 v35;
  float v36;
  float32x2_t *v37;
  float32x2_t *v38;
  float v39;
  float32x2_t v40;
  unsigned int v41;
  float v42;
  float *v43;
  float *v44;
  float v45;
  float v46;
  float v47;
  unsigned int v48;
  float *v49;
  int v50;
  unsigned int v51;
  float *v52;
  float *v53;
  unsigned int v54;
  float32x2_t *v55;
  float v56;
  float v57;
  float32x2_t *v58;
  float32x2_t *v59;
  float v60;
  float32x2_t v61;
  float v62;
  float *v63;
  float *v64;
  float v65;
  float v66;
  float v67;
  float *v68;
  float *v69;
  float *v70;
  float v71;
  float v72;
  float v73;
  unsigned int v74;
  float *v75;
  float *v76;
  uint64_t v77;
  float v78;
  float v79;
  const float *v80;
  int8x16_t v81;
  float32x2_t *v82;
  uint64_t v83;
  const float *v84;
  float32x2_t v85;
  float v86;
  float v87;
  float v88;
  float v89;
  int32x2_t v90;
  float v91;
  int32x2_t v92;
  float v93;
  int32x2_t v94;
  int32x2_t v95;
  float v96;
  float v97;
  float v98;
  float v99;
  uint64_t v100;
  float v101;
  float v102;
  uint64_t v103;
  float v104;
  float v105;
  uint64_t v106;
  float v107;
  float v108;
  uint64_t v109;
  uint64_t v110;
  float32x4x3_t v111;

  v7 = *(_QWORD *)&a3.var0;
  v110 = *MEMORY[0x1E0C80C00];
  if (HGRectIsNull((uint64_t)a2, *(uint64_t *)&a3.var0))
    return 0;
  if (!(*(unsigned int (**)(HGTransformUtils *))(*(_QWORD *)this + 224))(this))
    a4 = a4 + 0.00024414;
  v98 = (float)(int)a2 - a4;
  v99 = (float)SHIDWORD(a2) - a4;
  v100 = 0x3F80000000000000;
  v101 = a4 + (float)(int)v7;
  v102 = v99;
  v103 = 0x3F80000000000000;
  v104 = v101;
  v105 = a4 + (float)SHIDWORD(v7);
  v106 = 0x3F80000000000000;
  v107 = v98;
  v108 = v105;
  v109 = 0x3F80000000000000;
  (*(void (**)(HGTransformUtils *, float *, float *, uint64_t))(*(_QWORD *)this + 208))(this, &v98, &v98, 4);
  v11 = *((float *)&v100 + 1) < a5;
  v12 = (4 * (*((float *)&v106 + 1) < a5)) | (2 * (*((float *)&v103 + 1) < a5)) | (8 * (*((float *)&v109 + 1) < a5)) | v11;
  if (v12 == 15)
    return 0;
  if (!v12)
    return HGRectMake4f(v11, fminf(v98 / *((float *)&v100 + 1), fminf(v101 / *((float *)&v103 + 1), fminf(v104 / *((float *)&v106 + 1), v107 / *((float *)&v109 + 1)))), fminf(v99 / *((float *)&v100 + 1), fminf(v102 / *((float *)&v103 + 1), fminf(v105 / *((float *)&v106 + 1), v108 / *((float *)&v109 + 1)))), fmaxf(v98 / *((float *)&v100 + 1), fmaxf(v101 / *((float *)&v103 + 1), fmaxf(v104 / *((float *)&v106 + 1), v107 / *((float *)&v109 + 1)))), fmaxf(v99 / *((float *)&v100 + 1), fmaxf(v102 / *((float *)&v103 + 1), fmaxf(v105 / *((float *)&v106 + 1), v108 / *((float *)&v109 + 1)))));
  v13 = *((float *)&v103 + 1) >= a5;
  if (*((float *)&v100 + 1) >= a5)
    v13 = 1;
  v14 = *((float *)&v106 + 1) >= a5 || v13;
  if (*((float *)&v106 + 1) < a5)
    v15 = 3;
  else
    v15 = 2;
  if (*((float *)&v109 + 1) >= a5)
    v14 = 1;
  if (!v13)
    LOBYTE(v11) = v15;
  if (v14)
    v16 = v11;
  else
    v16 = 4;
  if (((v12 >> ((v16 + 1) & 3)) & 1) != 0)
  {
    v17 = &v98 + 4 * ((v16 + 1) & 3);
    v18 = &v98 + 4 * (v16 & 3);
    v19 = (float)(a5 - v17[3]) / (float)(v18[3] - v17[3]);
    v20 = v17[1];
    v21 = v18[1];
    *(float *)v90.i32 = *v17 + (float)(v19 * (float)(*v18 - *v17));
    v22 = 1;
    *(float *)&v90.i32[1] = v20 + (float)(v19 * (float)(v21 - v20));
    v91 = a5;
    v23 = (v16 + 2) & 3;
    if (((v12 >> v23) & 1) != 0)
      goto LABEL_25;
LABEL_30:
    if (v22)
    {
      v37 = (float32x2_t *)(&v98 + 4 * ((v16 + 1) & 3));
      v38 = (float32x2_t *)(&v98 + 4 * v23);
      v39 = v38[1].f32[1];
      v40 = *v38;
      v92 = (int32x2_t)vadd_f32(*v37, vmul_n_f32(vsub_f32(*v38, *v37), (float)(a5 - v37[1].f32[1]) / (float)(v39 - v37[1].f32[1])));
      v93 = a5;
      v41 = 2;
      v42 = v40.f32[1];
    }
    else
    {
      v52 = &v98 + 4 * v23;
      v40.f32[0] = *v52;
      v42 = v52[1];
      v39 = v52[3];
      v41 = 1;
    }
    v24 = 0;
    v48 = v41;
    v90.i32[3 * v41] = v40.i32[0];
LABEL_37:
    v53 = (float *)&v90 + 3 * v48;
    v53[1] = v42;
    v53[2] = v39;
    v25 = v41 + 1;
    v26 = v16 - 1;
    v27 = (v16 - 1) & 3;
    if (((v12 >> ((v16 - 1) & 3)) & 1) == 0)
      goto LABEL_27;
    goto LABEL_38;
  }
  v22 = 0;
  v34 = (__int32 *)(&v98 + 4 * ((v16 + 1) & 3));
  v35 = v34[1];
  v36 = *((float *)v34 + 3);
  v90.i32[0] = *v34;
  v90.i32[1] = v35;
  v91 = v36;
  v23 = (v16 + 2) & 3;
  if (((v12 >> v23) & 1) == 0)
    goto LABEL_30;
LABEL_25:
  if (!v22)
  {
    v43 = &v98 + 4 * v23;
    v44 = &v98 + 4 * ((v16 + 1) & 3);
    v45 = (float)(a5 - v43[3]) / (float)(v44[3] - v43[3]);
    v46 = v43[1];
    v47 = v44[1];
    *(float *)v92.i32 = *v43 + (float)(v45 * (float)(*v44 - *v43));
    v48 = 1;
    v42 = v46 + (float)(v45 * (float)(v47 - v46));
    v39 = a5;
    v41 = 1;
    v24 = 1;
    goto LABEL_37;
  }
  v24 = 1;
  v25 = 1;
  v26 = v16 - 1;
  v27 = (v16 - 1) & 3;
  if (((v12 >> ((v16 - 1) & 3)) & 1) == 0)
  {
LABEL_27:
    if (v24)
    {
      v28 = (float32x2_t *)(&v98 + 4 * ((v16 + 2) & 3));
      v29 = (float32x2_t *)(&v98 + 4 * v27);
      v30 = v29[1].f32[1];
      v31 = (float32x2_t *)((char *)&v90 + 12 * v25);
      v32 = *v29;
      *v31 = vadd_f32(*v28, vmul_n_f32(vsub_f32(*v29, *v28), (float)(a5 - v28[1].f32[1]) / (float)(v30 - v28[1].f32[1])));
      v31[1].f32[0] = a5;
      LODWORD(v25) = v25 + 1;
      v33 = v32.f32[1];
    }
    else
    {
      v49 = &v98 + 4 * v27;
      v32.f32[0] = *v49;
      v33 = v49[1];
      v30 = v49[3];
    }
    v50 = 0;
    v51 = v25;
    v90.i32[3 * v25] = v32.i32[0];
LABEL_43:
    v68 = (float *)&v90 + 3 * v51;
    v68[1] = v33;
    v68[2] = v30;
    v25 = (v25 + 1);
    v54 = v16 & 3;
    if (((v12 >> v54) & 1) != 0)
      goto LABEL_44;
LABEL_40:
    if (v50)
    {
      v55 = (float32x2_t *)(&v98 + 4 * (v26 & 3));
      v56 = v55[1].f32[1];
      v57 = a5 - v56;
      v58 = (float32x2_t *)(&v98 + 4 * v54);
      v59 = (float32x2_t *)((char *)&v90 + 12 * v25);
      v59[1].f32[0] = a5;
      a5 = v58[1].f32[1];
      v60 = v57 / (float)(a5 - v56);
      v61 = *v58;
      *v59 = vadd_f32(*v55, vmul_n_f32(vsub_f32(*v58, *v55), v60));
      LODWORD(v25) = v25 + 1;
      v62 = v61.f32[1];
    }
    else
    {
      v75 = &v98 + 4 * v54;
      v61.f32[0] = *v75;
      v62 = v75[1];
      a5 = v75[3];
    }
    v74 = v25;
    v90.i32[3 * v25] = v61.i32[0];
    goto LABEL_48;
  }
LABEL_38:
  if (!v24)
  {
    v63 = &v98 + 4 * v27;
    v64 = &v98 + 4 * ((v16 + 2) & 3);
    v65 = (float)(a5 - v63[3]) / (float)(v64[3] - v63[3]);
    v66 = v63[1];
    v67 = v64[1];
    *(float *)&v90.i32[3 * v25] = *v63 + (float)(v65 * (float)(*v64 - *v63));
    v51 = v25;
    v33 = v66 + (float)(v65 * (float)(v67 - v66));
    v50 = 1;
    v30 = a5;
    goto LABEL_43;
  }
  v50 = 1;
  v54 = v16 & 3;
  if (((v12 >> v54) & 1) == 0)
    goto LABEL_40;
LABEL_44:
  if (v50)
    goto LABEL_49;
  v69 = &v98 + 4 * v54;
  v70 = &v98 + 4 * (v26 & 3);
  v71 = (float)(a5 - v69[3]) / (float)(v70[3] - v69[3]);
  v72 = v69[1];
  v73 = v70[1];
  *(float *)&v90.i32[3 * v25] = *v69 + (float)(v71 * (float)(*v70 - *v69));
  v74 = v25;
  v62 = v72 + (float)(v71 * (float)(v73 - v72));
LABEL_48:
  v76 = (float *)&v90 + 3 * v74;
  v76[1] = v62;
  v76[2] = a5;
  v25 = (v25 + 1);
LABEL_49:
  if ((int)v25 <= 0)
  {
    v79 = *(float *)&v90.i32[1];
    v78 = *(float *)v90.i32;
    goto LABEL_59;
  }
  if (v25 >= 4)
  {
    v80 = (const float *)&v90;
    v111 = vld3q_f32(v80);
    v77 = v25 & 0x7C;
    v81 = (int8x16_t)vdivq_f32(v111.val[0], v111.val[2]);
    v111.val[0] = vdivq_f32(v111.val[1], v111.val[2]);
    v90 = vzip1_s32(*(int32x2_t *)v81.i8, *(int32x2_t *)v111.val[0].f32);
    v92 = vzip2_s32(*(int32x2_t *)v81.i8, *(int32x2_t *)v111.val[0].f32);
    v111.val[0].i64[0] = vextq_s8((int8x16_t)v111.val[0], (int8x16_t)v111.val[0], 8uLL).u64[0];
    v111.val[1].i64[0] = vextq_s8(v81, v81, 8uLL).u64[0];
    v94 = vzip1_s32(*(int32x2_t *)v111.val[1].f32, *(int32x2_t *)v111.val[0].f32);
    v95 = vzip2_s32(*(int32x2_t *)v111.val[1].f32, *(int32x2_t *)v111.val[0].f32);
    if (v77 == v25)
      goto LABEL_56;
  }
  else
  {
    v77 = 0;
  }
  v82 = (float32x2_t *)((char *)&v90 + 12 * v77);
  v83 = v25 - v77;
  do
  {
    v84 = (const float *)&v82[1];
    v85 = vld1_dup_f32(v84);
    *v82 = vdiv_f32(*v82, v85);
    v82 = (float32x2_t *)((char *)v82 + 12);
    --v83;
  }
  while (v83);
LABEL_56:
  v79 = *(float *)&v90.i32[1];
  v78 = *(float *)v90.i32;
  if ((int)v25 >= 2)
  {
    v86 = fminf(*(float *)v90.i32, *(float *)v92.i32);
    v87 = fminf(*(float *)&v90.i32[1], *(float *)&v92.i32[1]);
    v88 = fmaxf(*(float *)v90.i32, *(float *)v92.i32);
    v89 = fmaxf(*(float *)&v90.i32[1], *(float *)&v92.i32[1]);
    if ((_DWORD)v25 == 2)
    {
      v78 = v86;
      v79 = v87;
    }
    else
    {
      v78 = fminf(v86, *(float *)v94.i32);
      v79 = fminf(v87, *(float *)&v94.i32[1]);
      v88 = fmaxf(v88, *(float *)v94.i32);
      v89 = fmaxf(v89, *(float *)&v94.i32[1]);
      if ((_DWORD)v25 != 3)
      {
        v78 = fminf(v78, *(float *)v95.i32);
        v79 = fminf(v79, *(float *)&v95.i32[1]);
        v88 = fmaxf(v88, *(float *)v95.i32);
        v89 = fmaxf(v89, *(float *)&v95.i32[1]);
        if ((_DWORD)v25 != 4)
        {
          v78 = fminf(v78, v96);
          v79 = fminf(v79, v97);
          v88 = fmaxf(v88, v96);
          v89 = fmaxf(v89, v97);
          if ((_DWORD)v25 != 5)
          {
            v78 = fminf(v78, v98);
            v79 = fminf(v79, v99);
            v88 = fmaxf(v88, v98);
            v89 = fmaxf(v89, v99);
            if ((_DWORD)v25 != 6)
            {
              v78 = fminf(v78, *((float *)&v100 + 1));
              v79 = fminf(v79, v101);
              v88 = fmaxf(v88, *((float *)&v100 + 1));
              v89 = fmaxf(v89, v101);
            }
          }
        }
      }
    }
    return HGRectMake4f(v25, v78 - a4, v79 - a4, a4 + v88, a4 + v89);
  }
LABEL_59:
  v88 = v78;
  v89 = v79;
  return HGRectMake4f(v25, v78 - a4, v79 - a4, a4 + v88, a4 + v89);
}

uint64_t HGTransformUtils::GetROI(HGTransformUtils *this, unint64_t a2, HGRect a3, float a4, float a5)
{
  int var0;
  int v8;
  unint64_t v10;
  int var1;
  int v12;
  uint64_t v13;
  unsigned int v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  _BOOL4 v21;
  int v22;
  char v23;
  char v24;
  float *v25;
  float *v26;
  float v27;
  float v28;
  float v29;
  int v30;
  unsigned int v31;
  int v32;
  char v33;
  unsigned int v34;
  float32x2_t *v35;
  float32x2_t *v36;
  float v37;
  float32x2_t *v38;
  float32x2_t v39;
  float v40;
  __int32 *v41;
  __int32 v42;
  float v43;
  float32x2_t *v44;
  float32x2_t *v45;
  float v46;
  float32x2_t v47;
  unsigned int v48;
  float v49;
  float *v50;
  float *v51;
  float v52;
  float v53;
  float v54;
  unsigned int v55;
  float *v56;
  int v57;
  unsigned int v58;
  float *v59;
  float *v60;
  unsigned int v61;
  float32x2_t *v62;
  float v63;
  float v64;
  float32x2_t *v65;
  float32x2_t *v66;
  float v67;
  float32x2_t v68;
  float v69;
  float *v70;
  float *v71;
  float v72;
  float v73;
  float v74;
  float *v75;
  float *v76;
  float *v77;
  float v78;
  float v79;
  float v80;
  unsigned int v81;
  float *v82;
  float *v83;
  uint64_t v84;
  float v85;
  float v86;
  const float *v87;
  int8x16_t v88;
  float32x2_t *v89;
  uint64_t v90;
  const float *v91;
  float32x2_t v92;
  float v93;
  float v94;
  float v95;
  int32x2_t v96;
  float v97;
  int32x2_t v98;
  float v99;
  int32x2_t v100;
  int32x2_t v101;
  float v102;
  float v103;
  float v104;
  float v105;
  uint64_t v106;
  float v107;
  float v108;
  uint64_t v109;
  float v110;
  float v111;
  uint64_t v112;
  float v113;
  float v114;
  uint64_t v115;
  uint64_t v116;
  float32x4x3_t v117;

  var0 = a3.var0;
  v8 = a2;
  v116 = *MEMORY[0x1E0C80C00];
  v10 = HIDWORD(a2);
  var1 = a3.var1;
  v12 = (*(uint64_t (**)(HGTransformUtils *))(*(_QWORD *)this + 224))(this);
  v104 = (float)v8 + 0.5;
  v105 = (float)(int)v10 + 0.5;
  v106 = 0x3F80000000000000;
  v107 = (float)var0 + -0.5;
  v108 = v105;
  v109 = 0x3F80000000000000;
  v110 = v107;
  v111 = (float)var1 + -0.5;
  v112 = 0x3F80000000000000;
  v113 = v104;
  v114 = v111;
  v115 = 0x3F80000000000000;
  (*(void (**)(HGTransformUtils *, float *, float *, uint64_t))(*(_QWORD *)this + 208))(this, &v104, &v104, 4);
  v13 = *((float *)&v106 + 1) < a5;
  v14 = (4 * (*((float *)&v112 + 1) < a5)) | (2 * (*((float *)&v109 + 1) < a5)) | (8 * (*((float *)&v115 + 1) < a5)) | v13;
  if (v12)
    v15 = a4;
  else
    v15 = a4 + 0.00024414;
  if (v14 == 15)
    return 0;
  if (v14)
  {
    v21 = *((float *)&v109 + 1) >= a5;
    if (*((float *)&v106 + 1) >= a5)
      v21 = 1;
    v22 = *((float *)&v112 + 1) >= a5 || v21;
    if (*((float *)&v112 + 1) < a5)
      v23 = 3;
    else
      v23 = 2;
    if (*((float *)&v115 + 1) >= a5)
      v22 = 1;
    if (!v21)
      LOBYTE(v13) = v23;
    if (v22)
      v24 = v13;
    else
      v24 = 4;
    if (((v14 >> ((v24 + 1) & 3)) & 1) != 0)
    {
      v25 = &v104 + 4 * ((v24 + 1) & 3);
      v26 = &v104 + 4 * (v24 & 3);
      v27 = (float)(a5 - v25[3]) / (float)(v26[3] - v25[3]);
      v28 = v25[1];
      v29 = v26[1];
      *(float *)v96.i32 = *v25 + (float)(v27 * (float)(*v26 - *v25));
      v30 = 1;
      *(float *)&v96.i32[1] = v28 + (float)(v27 * (float)(v29 - v28));
      v97 = a5;
      v31 = (v24 + 2) & 3;
      if (((v14 >> v31) & 1) != 0)
      {
LABEL_25:
        if (v30)
        {
          v32 = 1;
          v13 = 1;
          v33 = v24 - 1;
          v34 = (v24 - 1) & 3;
          if (((v14 >> ((v24 - 1) & 3)) & 1) == 0)
          {
LABEL_27:
            if (v32)
            {
              v35 = (float32x2_t *)(&v104 + 4 * ((v24 + 2) & 3));
              v36 = (float32x2_t *)(&v104 + 4 * v34);
              v37 = v36[1].f32[1];
              v38 = (float32x2_t *)((char *)&v96 + 12 * v13);
              v39 = *v36;
              *v38 = vadd_f32(*v35, vmul_n_f32(vsub_f32(*v36, *v35), (float)(a5 - v35[1].f32[1]) / (float)(v37 - v35[1].f32[1])));
              v38[1].f32[0] = a5;
              LODWORD(v13) = v13 + 1;
              v40 = v39.f32[1];
            }
            else
            {
              v56 = &v104 + 4 * v34;
              v39.f32[0] = *v56;
              v40 = v56[1];
              v37 = v56[3];
            }
            v57 = 0;
            v58 = v13;
            v96.i32[3 * v13] = v39.i32[0];
            goto LABEL_43;
          }
LABEL_38:
          if (v32)
          {
            v57 = 1;
            v61 = v24 & 3;
            if (((v14 >> v61) & 1) != 0)
            {
LABEL_44:
              if (v57)
                goto LABEL_49;
              v76 = &v104 + 4 * v61;
              v77 = &v104 + 4 * (v33 & 3);
              v78 = (float)(a5 - v76[3]) / (float)(v77[3] - v76[3]);
              v79 = v76[1];
              v80 = v77[1];
              *(float *)&v96.i32[3 * v13] = *v76 + (float)(v78 * (float)(*v77 - *v76));
              v81 = v13;
              v69 = v79 + (float)(v78 * (float)(v80 - v79));
LABEL_48:
              v83 = (float *)&v96 + 3 * v81;
              v83[1] = v69;
              v83[2] = a5;
              v13 = (v13 + 1);
LABEL_49:
              if ((int)v13 <= 0)
              {
                v86 = *(float *)&v96.i32[1];
                v85 = *(float *)v96.i32;
                goto LABEL_59;
              }
              if (v13 >= 4)
              {
                v87 = (const float *)&v96;
                v117 = vld3q_f32(v87);
                v84 = v13 & 0x7C;
                v88 = (int8x16_t)vdivq_f32(v117.val[0], v117.val[2]);
                v117.val[0] = vdivq_f32(v117.val[1], v117.val[2]);
                v96 = vzip1_s32(*(int32x2_t *)v88.i8, *(int32x2_t *)v117.val[0].f32);
                v98 = vzip2_s32(*(int32x2_t *)v88.i8, *(int32x2_t *)v117.val[0].f32);
                v117.val[0].i64[0] = vextq_s8((int8x16_t)v117.val[0], (int8x16_t)v117.val[0], 8uLL).u64[0];
                v117.val[1].i64[0] = vextq_s8(v88, v88, 8uLL).u64[0];
                v100 = vzip1_s32(*(int32x2_t *)v117.val[1].f32, *(int32x2_t *)v117.val[0].f32);
                v101 = vzip2_s32(*(int32x2_t *)v117.val[1].f32, *(int32x2_t *)v117.val[0].f32);
                if (v84 == v13)
                  goto LABEL_56;
              }
              else
              {
                v84 = 0;
              }
              v89 = (float32x2_t *)((char *)&v96 + 12 * v84);
              v90 = v13 - v84;
              do
              {
                v91 = (const float *)&v89[1];
                v92 = vld1_dup_f32(v91);
                *v89 = vdiv_f32(*v89, v92);
                v89 = (float32x2_t *)((char *)v89 + 12);
                --v90;
              }
              while (v90);
LABEL_56:
              v86 = *(float *)&v96.i32[1];
              v85 = *(float *)v96.i32;
              if ((int)v13 >= 2)
              {
                v93 = fminf(*(float *)v96.i32, *(float *)v98.i32);
                v94 = fminf(*(float *)&v96.i32[1], *(float *)&v98.i32[1]);
                v95 = fmaxf(*(float *)v96.i32, *(float *)v98.i32);
                v16 = fmaxf(*(float *)&v96.i32[1], *(float *)&v98.i32[1]);
                if ((_DWORD)v13 == 2)
                {
                  v85 = v93;
                  v86 = v94;
                }
                else
                {
                  v85 = fminf(v93, *(float *)v100.i32);
                  v86 = fminf(v94, *(float *)&v100.i32[1]);
                  v95 = fmaxf(v95, *(float *)v100.i32);
                  v16 = fmaxf(v16, *(float *)&v100.i32[1]);
                  if ((_DWORD)v13 != 3)
                  {
                    v85 = fminf(v85, *(float *)v101.i32);
                    v86 = fminf(v86, *(float *)&v101.i32[1]);
                    v95 = fmaxf(v95, *(float *)v101.i32);
                    v16 = fmaxf(v16, *(float *)&v101.i32[1]);
                    if ((_DWORD)v13 != 4)
                    {
                      v85 = fminf(v85, v102);
                      v86 = fminf(v86, v103);
                      v95 = fmaxf(v95, v102);
                      v16 = fmaxf(v16, v103);
                      if ((_DWORD)v13 != 5)
                      {
                        v85 = fminf(v85, v104);
                        v86 = fminf(v86, v105);
                        v95 = fmaxf(v95, v104);
                        v16 = fmaxf(v16, v105);
                        if ((_DWORD)v13 != 6)
                        {
                          v85 = fminf(v85, *((float *)&v106 + 1));
                          v86 = fminf(v86, v107);
                          v95 = fmaxf(v95, *((float *)&v106 + 1));
                          v16 = fmaxf(v16, v107);
                        }
                      }
                    }
                  }
                }
                goto LABEL_60;
              }
LABEL_59:
              v95 = v85;
              v16 = v86;
LABEL_60:
              v17 = v85 - v15;
              v18 = v86 - v15;
              v19 = v15 + v95;
              return HGRectMake4f(v13, v17, v18, v19, v15 + v16);
            }
LABEL_40:
            if (v57)
            {
              v62 = (float32x2_t *)(&v104 + 4 * (v33 & 3));
              v63 = v62[1].f32[1];
              v64 = a5 - v63;
              v65 = (float32x2_t *)(&v104 + 4 * v61);
              v66 = (float32x2_t *)((char *)&v96 + 12 * v13);
              v66[1].f32[0] = a5;
              a5 = v65[1].f32[1];
              v67 = v64 / (float)(a5 - v63);
              v68 = *v65;
              *v66 = vadd_f32(*v62, vmul_n_f32(vsub_f32(*v65, *v62), v67));
              LODWORD(v13) = v13 + 1;
              v69 = v68.f32[1];
            }
            else
            {
              v82 = &v104 + 4 * v61;
              v68.f32[0] = *v82;
              v69 = v82[1];
              a5 = v82[3];
            }
            v81 = v13;
            v96.i32[3 * v13] = v68.i32[0];
            goto LABEL_48;
          }
          v70 = &v104 + 4 * v34;
          v71 = &v104 + 4 * ((v24 + 2) & 3);
          v72 = (float)(a5 - v70[3]) / (float)(v71[3] - v70[3]);
          v73 = v70[1];
          v74 = v71[1];
          *(float *)&v96.i32[3 * v13] = *v70 + (float)(v72 * (float)(*v71 - *v70));
          v58 = v13;
          v40 = v73 + (float)(v72 * (float)(v74 - v73));
          v57 = 1;
          v37 = a5;
LABEL_43:
          v75 = (float *)&v96 + 3 * v58;
          v75[1] = v40;
          v75[2] = v37;
          v13 = (v13 + 1);
          v61 = v24 & 3;
          if (((v14 >> v61) & 1) != 0)
            goto LABEL_44;
          goto LABEL_40;
        }
        v50 = &v104 + 4 * v31;
        v51 = &v104 + 4 * ((v24 + 1) & 3);
        v52 = (float)(a5 - v50[3]) / (float)(v51[3] - v50[3]);
        v53 = v50[1];
        v54 = v51[1];
        *(float *)v98.i32 = *v50 + (float)(v52 * (float)(*v51 - *v50));
        v55 = 1;
        v49 = v53 + (float)(v52 * (float)(v54 - v53));
        v46 = a5;
        v48 = 1;
        v32 = 1;
LABEL_37:
        v60 = (float *)&v96 + 3 * v55;
        v60[1] = v49;
        v60[2] = v46;
        v13 = v48 + 1;
        v33 = v24 - 1;
        v34 = (v24 - 1) & 3;
        if (((v14 >> ((v24 - 1) & 3)) & 1) == 0)
          goto LABEL_27;
        goto LABEL_38;
      }
    }
    else
    {
      v30 = 0;
      v41 = (__int32 *)(&v104 + 4 * ((v24 + 1) & 3));
      v42 = v41[1];
      v43 = *((float *)v41 + 3);
      v96.i32[0] = *v41;
      v96.i32[1] = v42;
      v97 = v43;
      v31 = (v24 + 2) & 3;
      if (((v14 >> v31) & 1) != 0)
        goto LABEL_25;
    }
    if (v30)
    {
      v44 = (float32x2_t *)(&v104 + 4 * ((v24 + 1) & 3));
      v45 = (float32x2_t *)(&v104 + 4 * v31);
      v46 = v45[1].f32[1];
      v47 = *v45;
      v98 = (int32x2_t)vadd_f32(*v44, vmul_n_f32(vsub_f32(*v45, *v44), (float)(a5 - v44[1].f32[1]) / (float)(v46 - v44[1].f32[1])));
      v99 = a5;
      v48 = 2;
      v49 = v47.f32[1];
    }
    else
    {
      v59 = &v104 + 4 * v31;
      v47.f32[0] = *v59;
      v49 = v59[1];
      v46 = v59[3];
      v48 = 1;
    }
    v32 = 0;
    v55 = v48;
    v96.i32[3 * v48] = v47.i32[0];
    goto LABEL_37;
  }
  v104 = v104 / *((float *)&v106 + 1);
  v105 = v105 / *((float *)&v106 + 1);
  v107 = v107 / *((float *)&v109 + 1);
  v108 = v108 / *((float *)&v109 + 1);
  v110 = v110 / *((float *)&v112 + 1);
  v111 = v111 / *((float *)&v112 + 1);
  v113 = v113 / *((float *)&v115 + 1);
  v114 = v114 / *((float *)&v115 + 1);
  v16 = fmaxf(v105, fmaxf(v108, fmaxf(v111, v114)));
  v17 = fminf(v104, fminf(v107, fminf(v110, v113))) - v15;
  v18 = fminf(v105, fminf(v108, fminf(v111, v114))) - v15;
  v19 = v15 + fmaxf(v104, fmaxf(v107, fmaxf(v110, v113)));
  return HGRectMake4f(v13, v17, v18, v19, v15 + v16);
}

float HGTransformUtils::MinW(HGTransformUtils *this)
{
  return 0.000001;
}

void HGBuffer::HGBuffer(HGBuffer *this, HGRect a2, HGBitmap *a3)
{
  _QWORD *v3;

  HGBitmap::HGBitmap((HGBitmap *)this, a2, a3);
  *v3 = off_1E651FCF8;
}

_QWORD *HGBuffer::HGBuffer(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  _QWORD *result;

  result = (_QWORD *)HGBitmap::HGBitmap(a1, a2, a3, a4);
  *result = off_1E651FCF8;
  return result;
}

_QWORD *HGBuffer::HGBuffer(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  _QWORD *result;

  result = (_QWORD *)HGBitmap::HGBitmap(a1, a2, a3, a4, a5);
  *result = off_1E651FCF8;
  return result;
}

void HGBuffer::~HGBuffer(HGBitmap *this, void *a2)
{
  void *v2;

  HGBitmap::~HGBitmap(this, a2);
  HGObject::operator delete(v2);
}

BOOL HGProgramDescriptor::IsMergeable(HGProgramDescriptor *this)
{
  uint64_t v1;
  int v2;

  if ((*((char *)this + 87) & 0x80000000) == 0)
  {
    v1 = *((unsigned __int8 *)this + 87);
    v2 = *((char *)this + 111);
    if ((v2 & 0x80000000) == 0)
      goto LABEL_3;
LABEL_6:
    if (*((_QWORD *)this + 12))
      return v1 != 0;
    goto LABEL_7;
  }
  v1 = *((_QWORD *)this + 9);
  v2 = *((char *)this + 111);
  if (v2 < 0)
    goto LABEL_6;
LABEL_3:
  if ((_BYTE)v2)
    return v1 != 0;
LABEL_7:
  if (*((char *)this + 183) < 0)
    return v1 && *((_QWORD *)this + 21) != 0;
  else
    return v1 && *((_BYTE *)this + 183) != 0;
}

BOOL HGProgramDescriptor::IsComplete(HGProgramDescriptor *this)
{
  int v1;

  if (*((char *)this + 87) < 0)
  {
    if (*((_QWORD *)this + 9))
      goto LABEL_3;
  }
  else if (*((_BYTE *)this + 87))
  {
LABEL_3:
    if (*((char *)this + 111) < 0)
    {
      if (*((_QWORD *)this + 12))
        return 1;
    }
    else if (*((_BYTE *)this + 111))
    {
      return 1;
    }
    v1 = *((char *)this + 183);
    if (v1 < 0)
      return *((_QWORD *)this + 21) != 0;
    return (_BYTE)v1 != 0;
  }
  if (*((char *)this + 63) < 0)
  {
    if (!*((_QWORD *)this + 6))
      return 0;
  }
  else if (!*((_BYTE *)this + 63))
  {
    return 0;
  }
  if (*((char *)this + 111) < 0)
  {
    if (*((_QWORD *)this + 12))
      return 1;
  }
  else if (*((_BYTE *)this + 111))
  {
    return 1;
  }
  v1 = *((char *)this + 159);
  if (v1 < 0)
    return *((_QWORD *)this + 18) != 0;
  return (_BYTE)v1 != 0;
}

uint64_t HGProgramDescriptor::IsConcatenated(HGProgramDescriptor *this)
{
  uint64_t v1;
  int v2;
  BOOL v3;
  BOOL v4;
  uint64_t i;

  if (*((char *)this + 87) < 0)
  {
    v1 = *((_QWORD *)this + 9);
    v2 = *((char *)this + 111);
    if ((v2 & 0x80000000) == 0)
    {
LABEL_3:
      if ((_BYTE)v2)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else
  {
    v1 = *((unsigned __int8 *)this + 87);
    v2 = *((char *)this + 111);
    if ((v2 & 0x80000000) == 0)
      goto LABEL_3;
  }
  if (*((_QWORD *)this + 12))
  {
LABEL_4:
    if (!v1)
      return 0;
    goto LABEL_20;
  }
LABEL_8:
  if (*((char *)this + 183) < 0)
  {
    if (v1)
      v4 = *((_QWORD *)this + 21) == 0;
    else
      v4 = 1;
    if (v4)
      return 0;
  }
  else
  {
    if (v1)
      v3 = *((_BYTE *)this + 183) == 0;
    else
      v3 = 1;
    if (v3)
      return 0;
  }
LABEL_20:
  for (i = *((_QWORD *)this + 14); i != *((_QWORD *)this + 15); i += 16)
  {
    if (!*(_DWORD *)i && *(_QWORD *)(i + 8))
      return 1;
  }
  return 0;
}

__n128 HGProgramDescriptor::SetReturnBinding(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_DWORD *)(a1 + 184) = *(_DWORD *)a2;
  std::string::operator=((std::string *)(a1 + 192), (const std::string *)(a2 + 8));
  result = *(__n128 *)(a2 + 32);
  *(__n128 *)(a1 + 216) = result;
  return result;
}

void HGProgramDescriptor::SetArgumentBindings(uint64_t a1, uint64_t *a2)
{
  void **v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  int v14;
  uint64_t v15;

  v4 = (void **)(a1 + 232);
  if (v4 != (void **)a2)
    std::vector<HGBinding>::__assign_with_size[abi:ne180100]<HGBinding*,HGBinding*>(v4, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 4));
  v5 = a2[1] - *a2;
  if (v5)
  {
    v6 = 0;
    v7 = v5 / 48;
    if (v7 <= 1)
      v8 = 1;
    else
      v8 = v7;
    while (1)
    {
      v9 = *(_DWORD *)(*a2 + v6);
      if (v9 == 9)
        break;
      if (v9 != 10)
        goto LABEL_9;
      v14 = 1;
      v15 = 0;
      v10 = *(_QWORD *)(a1 + 120);
      if (v10 < *(_QWORD *)(a1 + 128))
      {
        *(_DWORD *)v10 = 1;
LABEL_8:
        *(_QWORD *)(v10 + 8) = 0;
        *(_QWORD *)(a1 + 120) = v10 + 16;
        goto LABEL_9;
      }
      v11 = std::vector<std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>>::__push_back_slow_path<std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>>((void **)(a1 + 112), (uint64_t)&v14);
      v12 = v15;
      *(_QWORD *)(a1 + 120) = v11;
      if (v12)
        goto LABEL_14;
LABEL_9:
      v6 += 48;
      if (!--v8)
        return;
    }
    v14 = 2;
    v15 = 0;
    v10 = *(_QWORD *)(a1 + 120);
    if (v10 >= *(_QWORD *)(a1 + 128))
    {
      v13 = std::vector<std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>>::__push_back_slow_path<std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>>((void **)(a1 + 112), (uint64_t)&v14);
      v12 = v15;
      *(_QWORD *)(a1 + 120) = v13;
      if (!v12)
        goto LABEL_9;
LABEL_14:
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
      goto LABEL_9;
    }
    *(_DWORD *)v10 = 2;
    goto LABEL_8;
  }
}

void sub_1B2A27CE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(exception_object);
}

void HGProgramDescriptor::SetStageInBindings(uint64_t a1, uint64_t *a2)
{
  void **v2;

  v2 = (void **)(a1 + 256);
  if (v2 != (void **)a2)
    std::vector<HGBinding>::__assign_with_size[abi:ne180100]<HGBinding*,HGBinding*>(v2, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 4));
}

_QWORD *HGProgramDescriptor::SetInput(_QWORD *result, unint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD **v9;

  v3 = result[14];
  if (a2 < (result[15] - v3) >> 4)
  {
    v5 = (_QWORD *)*a3;
    if (*a3)
    {
      v6 = result;
      (*(void (**)(_QWORD))(*v5 + 16))(*a3);
      v7 = v6[14];
      v8 = 16 * a2;
      *(_DWORD *)(v7 + v8) = 0;
      v9 = (_QWORD **)(v7 + 16 * a2 + 8);
      result = *(_QWORD **)(v7 + v8 + 8);
      if (result == v5)
        return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v5 + 24))(v5);
    }
    else
    {
      *(_DWORD *)(v3 + 16 * a2) = 0;
      v9 = (_QWORD **)(v3 + 16 * a2 + 8);
      result = *v9;
      if (!*v9)
        return result;
    }
    if (result)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 24))(result);
    *v9 = v5;
  }
  return result;
}

void sub_1B2A27E10(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

_QWORD *HGProgramDescriptor::SetInput(_QWORD *result, unint64_t a2, int a3)
{
  uint64_t v3;
  _QWORD **v4;

  v3 = result[14];
  if (a2 < (result[15] - v3) >> 4)
  {
    *(_DWORD *)(v3 + 16 * a2) = a3;
    v4 = (_QWORD **)(v3 + 16 * a2 + 8);
    result = *v4;
    if (*v4)
    {
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 24))(result);
      *v4 = 0;
    }
  }
  return result;
}

std::string *HGProgramDescriptor::EncodeShaderDeclarations(std::string *result, std::string *this)
{
  uint64_t v3;
  std::string::pointer data;
  int v5;
  BOOL v6;
  BOOL v7;
  std::string::size_type v8;
  void **v9;
  std::string::size_type v10;
  std::string *v11;
  __int128 v12;
  void **v13;
  std::string::size_type v14;
  std::string v15;
  void *__p[2];
  int64_t v17;

  v3 = (uint64_t)result;
  if (result[3].__r_.__value_.__s.__data_[15] < 0)
  {
    data = result[3].__r_.__value_.__l.__data_;
    v5 = result[4].__r_.__value_.__s.__data_[15];
    if ((v5 & 0x80000000) == 0)
    {
LABEL_3:
      if ((_BYTE)v5)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else
  {
    data = (std::string::pointer)result[3].__r_.__value_.__s.__data_[15];
    v5 = result[4].__r_.__value_.__s.__data_[15];
    if ((v5 & 0x80000000) == 0)
      goto LABEL_3;
  }
  if (result[4].__r_.__value_.__r.__words[0])
  {
LABEL_4:
    if (!data)
      return result;
LABEL_18:
    if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v8 = 1046;
    else
      v8 = (this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) + 1023;
    std::string::reserve(this, v8);
    HGMetalUtils::stringForMetalHeader((uint64_t)__p);
    if (v17 >= 0)
      v9 = __p;
    else
      v9 = (void **)__p[0];
    if (v17 >= 0)
      v10 = HIBYTE(v17);
    else
      v10 = (std::string::size_type)__p[1];
    std::string::append(this, (const std::string::value_type *)v9, v10);
    if (SHIBYTE(v17) < 0)
      operator delete(__p[0]);
    std::string::append(this, "struct FragmentOut {\n");
    *((_BYTE *)&v15.__r_.__value_.__s + 23) = 4;
    strcpy((char *)&v15, "    ");
    v11 = std::string::append(&v15, "float4 color0 [[ color(0) ]];\n");
    v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v17 = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    if (v17 >= 0)
      v13 = __p;
    else
      v13 = (void **)__p[0];
    if (v17 >= 0)
      v14 = HIBYTE(v17);
    else
      v14 = (std::string::size_type)__p[1];
    std::string::append(this, (const std::string::value_type *)v13, v14);
    if (SHIBYTE(v17) < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(v15.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_37;
    }
    else if ((SHIBYTE(v15.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_37:
      std::string::append(this, "};\n\n");
      std::string::append(this, "extern \"C\" {\n");
      HGProgramDescriptor::privateEncodeShaderDeclarations(v3, this);
      return std::string::append(this, "}\n");
    }
    operator delete(v15.__r_.__value_.__l.__data_);
    goto LABEL_37;
  }
LABEL_8:
  if (result[7].__r_.__value_.__s.__data_[15] < 0)
  {
    if (data)
      v7 = result[7].__r_.__value_.__r.__words[0] == 0;
    else
      v7 = 1;
    if (!v7)
      goto LABEL_18;
  }
  else
  {
    if (data)
      v6 = result[7].__r_.__value_.__s.__data_[15] == 0;
    else
      v6 = 1;
    if (!v6)
      goto LABEL_18;
  }
  return result;
}

void sub_1B2A28078(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

std::string *HGProgramDescriptor::privateEncodeShaderDeclarations(uint64_t a1, std::string *a2)
{
  int *v4;
  int *v5;
  uint64_t v6;
  int v7;
  int v8;
  size_t v9;
  unint64_t v10;
  void **p_dst;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  const std::string::value_type *v15;
  std::string::size_type v16;
  int v17;
  size_t v18;
  unint64_t v19;
  void **v20;
  uint64_t v21;
  uint64_t v22;
  const void *v23;
  const std::string::value_type *v24;
  std::string::size_type v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  int v29;
  const std::string::value_type *v30;
  std::string::size_type v31;
  unsigned int v32;
  uint64_t i;
  unsigned int v34;
  int v35;
  const std::string::value_type *v36;
  std::string::size_type v37;
  unsigned int v38;
  void **__dst;
  std::string::size_type v41;
  int64_t v42;

  v4 = *(int **)(a1 + 112);
  v5 = *(int **)(a1 + 120);
  while (v4 != v5)
  {
    v6 = *((_QWORD *)v4 + 1);
    if (v6)
    {
      v7 = *v4;
      (*(void (**)(_QWORD))(*(_QWORD *)v6 + 16))(*((_QWORD *)v4 + 1));
      if (!v7)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
        HGProgramDescriptor::privateEncodeShaderDeclarations(v6, a2);
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
      }
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
    }
    v4 += 4;
  }
  std::string::append(a2, "[[ visible ]] ");
  v8 = *(char *)(a1 + 215);
  if (v8 >= 0)
    v9 = *(unsigned __int8 *)(a1 + 215);
  else
    v9 = *(_QWORD *)(a1 + 200);
  v10 = v9 + 1;
  if (v9 + 1 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_77;
  if (v10 >= 0x17)
  {
    v12 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17)
      v12 = v10 | 7;
    v13 = v12 + 1;
    p_dst = (void **)operator new(v12 + 1);
    v41 = v9 + 1;
    v42 = v13 | 0x8000000000000000;
    __dst = p_dst;
  }
  else
  {
    v41 = 0;
    v42 = 0;
    __dst = 0;
    p_dst = (void **)&__dst;
    HIBYTE(v42) = v9 + 1;
    if (!v9)
      goto LABEL_22;
  }
  if (v8 >= 0)
    v14 = (const void *)(a1 + 192);
  else
    v14 = *(const void **)(a1 + 192);
  memmove(p_dst, v14, v9);
LABEL_22:
  *(_WORD *)((char *)p_dst + v9) = 32;
  if (v42 >= 0)
    v15 = (const std::string::value_type *)&__dst;
  else
    v15 = (const std::string::value_type *)__dst;
  if (v42 >= 0)
    v16 = HIBYTE(v42);
  else
    v16 = v41;
  std::string::append(a2, v15, v16);
  if (SHIBYTE(v42) < 0)
    operator delete(__dst);
  v17 = *(char *)(a1 + 87);
  if (v17 >= 0)
    v18 = *(unsigned __int8 *)(a1 + 87);
  else
    v18 = *(_QWORD *)(a1 + 72);
  v19 = v18 + 1;
  if (v18 + 1 > 0x7FFFFFFFFFFFFFF7)
LABEL_77:
    std::string::__throw_length_error[abi:ne180100]();
  if (v19 >= 0x17)
  {
    v21 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17)
      v21 = v19 | 7;
    v22 = v21 + 1;
    v20 = (void **)operator new(v21 + 1);
    v41 = v18 + 1;
    v42 = v22 | 0x8000000000000000;
    __dst = v20;
  }
  else
  {
    v41 = 0;
    v42 = 0;
    __dst = 0;
    v20 = (void **)&__dst;
    HIBYTE(v42) = v18 + 1;
    if (!v18)
      goto LABEL_44;
  }
  if (v17 >= 0)
    v23 = (const void *)(a1 + 64);
  else
    v23 = *(const void **)(a1 + 64);
  memmove(v20, v23, v18);
LABEL_44:
  *(_WORD *)((char *)v20 + v18) = 40;
  if (v42 >= 0)
    v24 = (const std::string::value_type *)&__dst;
  else
    v24 = (const std::string::value_type *)__dst;
  if (v42 >= 0)
    v25 = HIBYTE(v42);
  else
    v25 = v41;
  std::string::append(a2, v24, v25);
  if (SHIBYTE(v42) < 0)
    operator delete(__dst);
  v27 = *(_QWORD *)(a1 + 232);
  v26 = *(_QWORD *)(a1 + 240);
  if (v27 != v26)
  {
    std::string::append(a2, "");
    v28 = *(_DWORD *)(v27 + 36) - 1;
    if (v28 <= 3)
      std::string::append(a2, off_1E651FD68[v28]);
    v29 = *(char *)(v27 + 31);
    if (v29 >= 0)
      v30 = (const std::string::value_type *)(v27 + 8);
    else
      v30 = *(const std::string::value_type **)(v27 + 8);
    if (v29 >= 0)
      v31 = *(unsigned __int8 *)(v27 + 31);
    else
      v31 = *(_QWORD *)(v27 + 16);
    std::string::append(a2, v30, v31);
    v32 = *(_DWORD *)(v27 + 36) - 1;
    if (v32 <= 3)
      std::string::append(a2, off_1E651FD88[v32]);
    for (i = v27 + 48; i != v26; i += 48)
    {
      std::string::append(a2, ", ");
      v34 = *(_DWORD *)(i + 36) - 1;
      if (v34 <= 3)
        std::string::append(a2, off_1E651FD68[v34]);
      v35 = *(char *)(i + 31);
      if (v35 >= 0)
        v36 = (const std::string::value_type *)(i + 8);
      else
        v36 = *(const std::string::value_type **)(i + 8);
      if (v35 >= 0)
        v37 = *(unsigned __int8 *)(i + 31);
      else
        v37 = *(_QWORD *)(i + 16);
      std::string::append(a2, v36, v37);
      v38 = *(_DWORD *)(i + 36) - 1;
      if (v38 <= 3)
        std::string::append(a2, off_1E651FD88[v38]);
    }
  }
  return std::string::append(a2, ");\n");
}

void sub_1B2A28464(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

std::string *HGProgramDescriptor::EncodeShaderBufferStruct(std::string *result, std::string *this)
{
  std::string::__raw *v3;
  std::string::pointer data;
  int v5;
  std::string::size_type v6;
  BOOL v7;
  BOOL v8;
  unint64_t v9;

  v3 = (std::string::__raw *)result;
  if (result[3].__r_.__value_.__s.__data_[15] < 0)
  {
    data = result[3].__r_.__value_.__l.__data_;
    v5 = result[4].__r_.__value_.__s.__data_[15];
    if ((v5 & 0x80000000) == 0)
    {
LABEL_3:
      if ((_BYTE)v5)
        goto LABEL_4;
      goto LABEL_12;
    }
  }
  else
  {
    data = (std::string::pointer)result[3].__r_.__value_.__s.__data_[15];
    v5 = result[4].__r_.__value_.__s.__data_[15];
    if ((v5 & 0x80000000) == 0)
      goto LABEL_3;
  }
  if (result[4].__r_.__value_.__r.__words[0])
  {
LABEL_4:
    if (!data)
      return result;
    goto LABEL_5;
  }
LABEL_12:
  if (result[7].__r_.__value_.__s.__data_[15] < 0)
  {
    if (data)
      v8 = result[7].__r_.__value_.__r.__words[0] == 0;
    else
      v8 = 1;
    if (!v8)
      goto LABEL_5;
  }
  else
  {
    if (data)
      v7 = result[7].__r_.__value_.__s.__data_[15] == 0;
    else
      v7 = 1;
    if (!v7)
    {
LABEL_5:
      if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v6 = 278;
      else
        v6 = (this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) + 255;
      std::string::reserve(this, v6);
      std::string::append(this, "struct ShaderParameters {\n");
      v9 = 0;
      HGProgramDescriptor::privateEncodeShaderBufferStruct(v3, this, &v9);
      return std::string::append(this, "};\n");
    }
  }
  return result;
}

void HGProgramDescriptor::privateEncodeShaderBufferStruct(_QWORD *a1, std::string *a2, unint64_t *a3)
{
  int *v6;
  int *v7;
  int v8;
  uint64_t v9;
  BOOL v10;
  std::string *v11;
  __int128 v12;
  uint64_t i;
  std::string *v14;
  __int128 v15;
  int v16;
  const std::string::value_type *v17;
  std::string::size_type v18;
  std::string *v19;
  __int128 v20;
  std::string *v21;
  __int128 v22;
  const std::string::value_type *v23;
  std::string::size_type v24;
  std::string *v25;
  __int128 v26;
  std::string *v27;
  std::string::size_type size;
  unsigned int v29;
  std::string *v30;
  __int128 v31;
  std::string *v32;
  __int128 v33;
  std::string *v34;
  std::string::size_type v35;
  std::string v36;
  std::string v37;
  std::string v38;
  std::string v39;
  std::string v40;
  __int128 v41;
  int64_t v42;

  v6 = (int *)a1[14];
  v7 = (int *)a1[15];
  while (v6 != v7)
  {
    v8 = *v6;
    v9 = *((_QWORD *)v6 + 1);
    if (v9)
      (*(void (**)(_QWORD))(*(_QWORD *)v9 + 16))(*((_QWORD *)v6 + 1));
    if (v8 != 2)
    {
      if (v8)
        v10 = 1;
      else
        v10 = v9 == 0;
      if (!v10)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 16))(v9);
        HGProgramDescriptor::privateEncodeShaderBufferStruct(v9, a2, a3);
        ++*a3;
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
LABEL_2:
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
        goto LABEL_3;
      }
      ++*a3;
    }
    if (v9)
      goto LABEL_2;
LABEL_3:
    v6 += 4;
  }
  std::to_string(&v40, *a3);
  v11 = std::string::insert(&v40, 0, "r");
  v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v42 = v11->__r_.__value_.__r.__words[2];
  v41 = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v40.__r_.__value_.__l.__data_);
  for (i = a1[29]; i != a1[30]; i += 48)
  {
    if (*(_DWORD *)i == 2 && *(_DWORD *)(i + 40))
    {
      *((_BYTE *)&v36.__r_.__value_.__s + 23) = 4;
      strcpy((char *)&v36, "    ");
      v14 = std::string::append(&v36, "alignas(16) ");
      v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      v37.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v37.__r_.__value_.__l.__data_ = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      v16 = *(char *)(i + 31);
      if (v16 >= 0)
        v17 = (const std::string::value_type *)(i + 8);
      else
        v17 = *(const std::string::value_type **)(i + 8);
      if (v16 >= 0)
        v18 = *(unsigned __int8 *)(i + 31);
      else
        v18 = *(_QWORD *)(i + 16);
      v19 = std::string::append(&v37, v17, v18);
      v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
      v38.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v20;
      v19->__r_.__value_.__l.__size_ = 0;
      v19->__r_.__value_.__r.__words[2] = 0;
      v19->__r_.__value_.__r.__words[0] = 0;
      v21 = std::string::append(&v38, " buffer_");
      v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
      v39.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v22;
      v21->__r_.__value_.__l.__size_ = 0;
      v21->__r_.__value_.__r.__words[2] = 0;
      v21->__r_.__value_.__r.__words[0] = 0;
      if (v42 >= 0)
        v23 = (const std::string::value_type *)&v41;
      else
        v23 = (const std::string::value_type *)v41;
      if (v42 >= 0)
        v24 = HIBYTE(v42);
      else
        v24 = *((_QWORD *)&v41 + 1);
      v25 = std::string::append(&v39, v23, v24);
      v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      v40.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v27 = &v40;
      else
        v27 = (std::string *)v40.__r_.__value_.__r.__words[0];
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v40.__r_.__value_.__r.__words[2]);
      else
        size = v40.__r_.__value_.__l.__size_;
      std::string::append(a2, (const std::string::value_type *)v27, size);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v40.__r_.__value_.__l.__data_);
        if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_49;
LABEL_43:
        if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_44;
LABEL_50:
        operator delete(v38.__r_.__value_.__l.__data_);
        if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_51;
LABEL_45:
        if ((SHIBYTE(v36.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_46;
LABEL_52:
        operator delete(v36.__r_.__value_.__l.__data_);
        v29 = *(_DWORD *)(i + 40);
        if (v29 < 2)
        {
LABEL_62:
          std::string::append(a2, ";\n");
          break;
        }
      }
      else
      {
        if ((SHIBYTE(v39.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_43;
LABEL_49:
        operator delete(v39.__r_.__value_.__l.__data_);
        if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_50;
LABEL_44:
        if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_45;
LABEL_51:
        operator delete(v37.__r_.__value_.__l.__data_);
        if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_52;
LABEL_46:
        v29 = *(_DWORD *)(i + 40);
        if (v29 < 2)
          goto LABEL_62;
      }
      std::to_string(&v38, v29);
      v30 = std::string::insert(&v38, 0, "[");
      v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
      v39.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v31;
      v30->__r_.__value_.__l.__size_ = 0;
      v30->__r_.__value_.__r.__words[2] = 0;
      v30->__r_.__value_.__r.__words[0] = 0;
      v32 = std::string::append(&v39, "]");
      v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
      v40.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v33;
      v32->__r_.__value_.__l.__size_ = 0;
      v32->__r_.__value_.__r.__words[2] = 0;
      v32->__r_.__value_.__r.__words[0] = 0;
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v34 = &v40;
      else
        v34 = (std::string *)v40.__r_.__value_.__r.__words[0];
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v35 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
      else
        v35 = v40.__r_.__value_.__l.__size_;
      std::string::append(a2, (const std::string::value_type *)v34, v35);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v40.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v39.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_61;
      }
      else if ((SHIBYTE(v39.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_61:
        if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_62;
LABEL_68:
        operator delete(v38.__r_.__value_.__l.__data_);
        goto LABEL_62;
      }
      operator delete(v39.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_62;
      goto LABEL_68;
    }
  }
  if (SHIBYTE(v42) < 0)
    operator delete((void *)v41);
}

void sub_1B2A28998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  uint64_t v42;

  if (a42 < 0)
  {
    operator delete(__p);
    if (a35 < 0)
    {
LABEL_5:
      operator delete(a30);
      if ((a28 & 0x80000000) == 0)
      {
LABEL_9:
        if (*(char *)(v42 - 73) < 0)
        {
          operator delete(*(void **)(v42 - 96));
          _Unwind_Resume(a1);
        }
        _Unwind_Resume(a1);
      }
LABEL_8:
      operator delete(a23);
      goto LABEL_9;
    }
  }
  else if (a35 < 0)
  {
    goto LABEL_5;
  }
  if ((a28 & 0x80000000) == 0)
    goto LABEL_9;
  goto LABEL_8;
}

void HGProgramDescriptor::EncodeShaderFunction(uint64_t a1, std::string *this)
{
  uint64_t v4;
  int v5;
  BOOL v6;
  BOOL v7;
  std::string::size_type v8;
  char *v9;
  __int128 v10;
  std::string *v11;
  __int128 v12;
  _QWORD *v13;
  const std::string::value_type *v14;
  const std::string::value_type *v15;
  const std::string::value_type *v16;
  int v17;
  const std::string::value_type *v18;
  std::string::size_type v19;
  std::string *v20;
  __int128 v21;
  std::string *v22;
  __int128 v23;
  std::string *v24;
  std::string::size_type size;
  std::string *v26;
  __int128 v27;
  std::string *p_dst;
  std::string::size_type v29;
  const char **v30;
  int v31;
  const char *v32;
  size_t v33;
  std::string::size_type v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  size_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  std::string *v44;
  std::string *v45;
  std::string::size_type v46;
  char *v47;
  char *v48;
  std::string *v49;
  std::string::size_type v50;
  unsigned int v51;
  int v52;
  const std::string::value_type *v53;
  std::string::size_type v54;
  unsigned int v55;
  int v56;
  size_t v57;
  unint64_t v58;
  void *v59;
  int v60;
  size_t v61;
  unint64_t v62;
  char *v63;
  int v64;
  size_t v65;
  unint64_t v66;
  char *v67;
  int v68;
  size_t v69;
  unint64_t v70;
  void *v71;
  uint64_t v72;
  uint64_t v73;
  const void *v74;
  std::string *v75;
  std::string::size_type v76;
  std::string *v77;
  __int128 v78;
  std::string *v79;
  std::string::size_type v80;
  std::string *v81;
  __int128 v82;
  std::string *v83;
  __int128 v84;
  std::string *v85;
  std::string::size_type v86;
  uint64_t v87;
  uint64_t v88;
  const void *v89;
  std::string *v90;
  __int128 v91;
  std::string *v92;
  std::string::size_type v93;
  uint64_t v94;
  uint64_t v95;
  const void *v96;
  std::string *v97;
  __int128 v98;
  uint64_t v99;
  uint64_t v100;
  const void *v101;
  std::string *v102;
  std::string::size_type v103;
  std::string *v104;
  __int128 v105;
  std::string *v106;
  std::string::size_type v107;
  std::string *v108;
  __int128 v109;
  std::string *v110;
  __int128 v111;
  std::string *v112;
  std::string::size_type v113;
  std::string *v114;
  std::string::size_type v115;
  char v116;
  std::string *v117;
  __int128 v118;
  std::string *v119;
  std::string::size_type v120;
  uint64_t v121;
  uint64_t v122;
  std::string *v123;
  __int128 v124;
  std::string *v125;
  std::string::size_type v126;
  std::string *v127;
  __int128 v128;
  std::string *v129;
  std::string::size_type v130;
  std::string *v131;
  __int128 v132;
  std::string *v133;
  __int128 v134;
  std::string *v135;
  std::string::size_type v136;
  std::string *v137;
  __int128 v138;
  std::string *v139;
  std::string::size_type v140;
  int v141;
  size_t v142;
  int v143;
  size_t v144;
  unint64_t v145;
  char *v146;
  std::string *v147;
  char *v148;
  std::string *v149;
  std::string *v150;
  std::string::size_type v151;
  std::string *v152;
  __int128 v153;
  std::string *v154;
  std::string::size_type v155;
  void **v156;
  uint64_t v157;
  uint64_t v158;
  void *v159;
  char *v160;
  char *v161;
  char *v162;
  void **v163;
  std::string *v164;
  uint64_t v165;
  std::string v166;
  std::string v167;
  std::string v168;
  std::string v169;
  std::string v170;
  std::string __dst;
  std::string v172;
  std::string v173;
  char v174;
  uint64_t v175;
  uint64_t v176;
  __int128 v177;
  _OWORD v178[2];
  __int128 v179;
  char *v180;
  char *v181;
  unint64_t v182;
  std::string v183;
  uint64_t v184;

  v184 = *MEMORY[0x1E0C80C00];
  if (*(char *)(a1 + 87) < 0)
  {
    v4 = *(_QWORD *)(a1 + 72);
    v5 = *(char *)(a1 + 111);
    if ((v5 & 0x80000000) == 0)
    {
LABEL_3:
      if ((_BYTE)v5)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else
  {
    v4 = *(unsigned __int8 *)(a1 + 87);
    v5 = *(char *)(a1 + 111);
    if ((v5 & 0x80000000) == 0)
      goto LABEL_3;
  }
  if (*(_QWORD *)(a1 + 96))
  {
LABEL_4:
    if (!v4)
      return;
    goto LABEL_19;
  }
LABEL_8:
  if (*(char *)(a1 + 183) < 0)
  {
    if (v4)
      v7 = *(_QWORD *)(a1 + 168) == 0;
    else
      v7 = 1;
    if (v7)
      return;
  }
  else
  {
    if (v4)
      v6 = *(_BYTE *)(a1 + 183) == 0;
    else
      v6 = 1;
    if (v6)
      return;
  }
LABEL_19:
  if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v8 = 2070;
  else
    v8 = (this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) + 2047;
  std::string::reserve(this, v8);
  v180 = 0;
  v181 = 0;
  v182 = 0;
  LODWORD(v178[0]) = 7;
  HIBYTE(v178[1]) = 10;
  strcpy((char *)v178 + 8, "VertexData");
  v179 = xmmword_1B3050DF0;
  v9 = std::vector<HGBinding>::__push_back_slow_path<HGBinding>(&v180, (uint64_t)v178);
  v181 = v9;
  if (SHIBYTE(v178[1]) < 0)
  {
    operator delete(*((void **)&v178[0] + 1));
    v9 = v181;
  }
  LODWORD(v178[0]) = 2;
  HIBYTE(v178[1]) = 16;
  strcpy((char *)v178 + 8, "ShaderParameters");
  v179 = xmmword_1B309DFF0;
  if ((unint64_t)v9 >= v182)
  {
    v181 = std::vector<HGBinding>::__push_back_slow_path<HGBinding>(&v180, (uint64_t)v178);
    if (SHIBYTE(v178[1]) < 0)
      operator delete(*((void **)&v178[0] + 1));
  }
  else
  {
    *(_DWORD *)v9 = 2;
    v10 = *(_OWORD *)((char *)v178 + 8);
    *((_QWORD *)v9 + 3) = *((_QWORD *)&v178[1] + 1);
    *(_OWORD *)(v9 + 8) = v10;
    v178[1] = 0uLL;
    *((_QWORD *)&v178[0] + 1) = 0;
    *((_OWORD *)v9 + 2) = v179;
    v181 = v9 + 48;
  }
  memset(v178, 0, sizeof(v178));
  LODWORD(v179) = 1065353216;
  v177 = 0uLL;
  v175 = 0;
  v176 = 0;
  v174 = 0;
  memset(&v173, 0, sizeof(v173));
  std::string::reserve(&v173, 0x400uLL);
  std::string::append(&v173, "{\n");
  HGProgramDescriptor::privateEncodeShaderFunction(a1, &v173, (uint64_t)&v180, (uint64_t)v178, (unint64_t *)&v177 + 1, &v177, &v176, &v175, &v174);
  *((_BYTE *)&v169.__r_.__value_.__s + 23) = 4;
  strcpy((char *)&v169, "    ");
  v11 = std::string::append(&v169, "return ");
  v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v170.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v170.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  v183.__r_.__value_.__r.__words[0] = (std::string::size_type)&v177 + 8;
  v13 = std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t)v178, (unint64_t *)&v177 + 1, (uint64_t)&std::piecewise_construct, (uint64_t **)&v183);
  v16 = (const std::string::value_type *)v13[3];
  v14 = (const std::string::value_type *)(v13 + 3);
  v15 = v16;
  v17 = v14[23];
  if (v17 >= 0)
    v18 = v14;
  else
    v18 = v15;
  if (v17 >= 0)
    v19 = *((unsigned __int8 *)v14 + 23);
  else
    v19 = *((_QWORD *)v14 + 1);
  v20 = std::string::append(&v170, v18, v19);
  v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  __dst.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  v22 = std::string::append(&__dst, ";\n");
  v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  v172.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v172.__r_.__value_.__l.__data_ = v23;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  if ((v172.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v24 = &v172;
  else
    v24 = (std::string *)v172.__r_.__value_.__r.__words[0];
  if ((v172.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v172.__r_.__value_.__r.__words[2]);
  else
    size = v172.__r_.__value_.__l.__size_;
  std::string::append(&v173, (const std::string::value_type *)v24, size);
  if (SHIBYTE(v172.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v172.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_42:
      if ((SHIBYTE(v170.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_43;
LABEL_89:
      operator delete(v170.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v169.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_44;
      goto LABEL_90;
    }
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_42;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
  if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_89;
LABEL_43:
  if ((SHIBYTE(v169.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_44;
LABEL_90:
  operator delete(v169.__r_.__value_.__l.__data_);
LABEL_44:
  std::string::append(&v173, "};");
  memset(&v172, 0, sizeof(v172));
  std::string::reserve(&v172, 0x400uLL);
  std::operator+<char>();
  v26 = std::string::append(&v170, " ");
  v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  __dst.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_dst = &__dst;
  else
    p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v29 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  else
    v29 = __dst.__r_.__value_.__l.__size_;
  std::string::append(&v172, (const std::string::value_type *)p_dst, v29);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v170.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_52:
      v30 = (const char **)(a1 + 40);
      v31 = *(char *)(a1 + 63);
      if ((v31 & 0x80000000) == 0)
        goto LABEL_53;
LABEL_93:
      if (*(_QWORD *)(a1 + 48))
      {
        v32 = *v30;
        v33 = strlen(*v30);
        if (v33 <= 0x7FFFFFFFFFFFFFF7)
          goto LABEL_57;
      }
      else
      {
        v32 = "fragmentFunc";
        v33 = strlen("fragmentFunc");
        if (v33 <= 0x7FFFFFFFFFFFFFF7)
          goto LABEL_57;
      }
LABEL_95:
      std::string::__throw_length_error[abi:ne180100]();
    }
  }
  else if ((SHIBYTE(v170.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_52;
  }
  operator delete(v170.__r_.__value_.__l.__data_);
  v30 = (const char **)(a1 + 40);
  v31 = *(char *)(a1 + 63);
  if (v31 < 0)
    goto LABEL_93;
LABEL_53:
  if (v31)
    v32 = (const char *)v30;
  else
    v32 = "fragmentFunc";
  v33 = strlen(v32);
  if (v33 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_95;
LABEL_57:
  v34 = v33;
  v164 = this;
  if (v33 >= 0x17)
  {
    v36 = (v33 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v33 | 7) != 0x17)
      v36 = v33 | 7;
    v37 = v36 + 1;
    v35 = operator new(v36 + 1);
    __dst.__r_.__value_.__l.__size_ = v34;
    __dst.__r_.__value_.__r.__words[2] = v37 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v35;
    goto LABEL_63;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v33;
  v35 = &__dst;
  if (v33)
LABEL_63:
    memmove(v35, v32, v34);
  *((_BYTE *)v35 + v34) = 0;
  v38 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v39 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  else
    v39 = __dst.__r_.__value_.__l.__size_;
  v40 = v39 + 1;
  if (v39 + 1 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  if (v40 >= 0x17)
  {
    v42 = (v40 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v40 | 7) != 0x17)
      v42 = v40 | 7;
    v43 = v42 + 1;
    v41 = (char *)operator new(v42 + 1);
    v170.__r_.__value_.__l.__size_ = v39 + 1;
    v170.__r_.__value_.__r.__words[2] = v43 | 0x8000000000000000;
    v170.__r_.__value_.__r.__words[0] = (std::string::size_type)v41;
  }
  else
  {
    memset(&v170, 0, sizeof(v170));
    v41 = (char *)&v170;
    *((_BYTE *)&v170.__r_.__value_.__s + 23) = v39 + 1;
    if (!v39)
      goto LABEL_78;
  }
  if (v38 >= 0)
    v44 = &__dst;
  else
    v44 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  memmove(v41, v44, v39);
LABEL_78:
  *(_WORD *)&v41[v39] = 40;
  if ((v170.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v45 = &v170;
  else
    v45 = (std::string *)v170.__r_.__value_.__r.__words[0];
  if ((v170.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v46 = HIBYTE(v170.__r_.__value_.__r.__words[2]);
  else
    v46 = v170.__r_.__value_.__l.__size_;
  std::string::append(&v172, (const std::string::value_type *)v45, v46);
  if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v170.__r_.__value_.__l.__data_);
    *((_BYTE *)&v170.__r_.__value_.__s + 23) = 0;
    v170.__r_.__value_.__s.__data_[0] = 0;
    v47 = v180;
    v48 = v181;
    if (v180 == v181)
      goto LABEL_256;
    goto LABEL_97;
  }
  *((_BYTE *)&v170.__r_.__value_.__s + 23) = 0;
  v170.__r_.__value_.__s.__data_[0] = 0;
  v47 = v180;
  v48 = v181;
  if (v180 != v181)
  {
LABEL_97:
    v165 = 0;
    while (2)
    {
      if ((v170.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v49 = &v170;
      else
        v49 = (std::string *)v170.__r_.__value_.__r.__words[0];
      if ((v170.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v50 = HIBYTE(v170.__r_.__value_.__r.__words[2]);
      else
        v50 = v170.__r_.__value_.__l.__size_;
      std::string::append(&v172, (const std::string::value_type *)v49, v50);
      switch(*(_DWORD *)v47)
      {
        case 2:
          v51 = *((_DWORD *)v47 + 9) - 1;
          if (v51 <= 3)
            std::string::append(&v172, off_1E651FD68[v51]);
          v52 = v47[31];
          if (v52 >= 0)
            v53 = v47 + 8;
          else
            v53 = (const std::string::value_type *)*((_QWORD *)v47 + 1);
          if (v52 >= 0)
            v54 = v47[31];
          else
            v54 = *((_QWORD *)v47 + 2);
          std::string::append(&v172, v53, v54);
          v55 = *((_DWORD *)v47 + 9) - 1;
          if (v55 <= 3)
            std::string::append(&v172, off_1E651FD88[v55]);
          std::string::append(&v172, "shaderParams [[ buffer(0) ]]");
          goto LABEL_240;
        case 5:
          v60 = v47[31];
          if (v60 >= 0)
            v61 = v47[31];
          else
            v61 = *((_QWORD *)v47 + 2);
          v62 = v61 + 1;
          if (v61 + 1 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          if (v62 >= 0x17)
          {
            v87 = (v62 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v62 | 7) != 0x17)
              v87 = v62 | 7;
            v88 = v87 + 1;
            v63 = (char *)operator new(v87 + 1);
            v183.__r_.__value_.__l.__size_ = v61 + 1;
            v183.__r_.__value_.__r.__words[2] = v88 | 0x8000000000000000;
            v183.__r_.__value_.__r.__words[0] = (std::string::size_type)v63;
          }
          else
          {
            memset(&v183, 0, sizeof(v183));
            v63 = (char *)&v183;
            *((_BYTE *)&v183.__r_.__value_.__s + 23) = v61 + 1;
            if (!v61)
            {
LABEL_184:
              *(_WORD *)&v63[v61] = 32;
              v90 = std::string::append(&v183, "position [[ position ]]");
              v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
              v169.__r_.__value_.__r.__words[2] = v90->__r_.__value_.__r.__words[2];
              *(_OWORD *)&v169.__r_.__value_.__l.__data_ = v91;
              v90->__r_.__value_.__l.__size_ = 0;
              v90->__r_.__value_.__r.__words[2] = 0;
              v90->__r_.__value_.__r.__words[0] = 0;
              if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v92 = &v169;
              else
                v92 = (std::string *)v169.__r_.__value_.__r.__words[0];
              if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v93 = HIBYTE(v169.__r_.__value_.__r.__words[2]);
              else
                v93 = v169.__r_.__value_.__l.__size_;
              goto LABEL_203;
            }
          }
          if (v60 >= 0)
            v89 = v47 + 8;
          else
            v89 = (const void *)*((_QWORD *)v47 + 1);
          memmove(v63, v89, v61);
          goto LABEL_184;
        case 6:
          v56 = v47[31];
          if (v56 >= 0)
            v57 = v47[31];
          else
            v57 = *((_QWORD *)v47 + 2);
          v58 = v57 + 8;
          if (v57 + 8 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          if (v58 >= 0x17)
          {
            v72 = (v58 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v58 | 7) != 0x17)
              v72 = v58 | 7;
            v73 = v72 + 1;
            v59 = operator new(v72 + 1);
            v183.__r_.__value_.__l.__size_ = v57 + 8;
            v183.__r_.__value_.__r.__words[2] = v73 | 0x8000000000000000;
            v183.__r_.__value_.__r.__words[0] = (std::string::size_type)v59;
          }
          else
          {
            memset(&v183, 0, sizeof(v183));
            v59 = &v183;
            *((_BYTE *)&v183.__r_.__value_.__s + 23) = v57 + 8;
            if (!v57)
              goto LABEL_152;
          }
          if (v56 >= 0)
            v74 = v47 + 8;
          else
            v74 = (const void *)*((_QWORD *)v47 + 1);
          memmove(v59, v74, v57);
LABEL_152:
          strcpy((char *)v59 + v57, " sampler");
          std::to_string(&v168, BYTE4(v165));
          if ((v168.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v75 = &v168;
          else
            v75 = (std::string *)v168.__r_.__value_.__r.__words[0];
          if ((v168.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v76 = HIBYTE(v168.__r_.__value_.__r.__words[2]);
          else
            v76 = v168.__r_.__value_.__l.__size_;
          v77 = std::string::append(&v183, (const std::string::value_type *)v75, v76);
          v78 = *(_OWORD *)&v77->__r_.__value_.__l.__data_;
          v169.__r_.__value_.__r.__words[2] = v77->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v169.__r_.__value_.__l.__data_ = v78;
          v77->__r_.__value_.__l.__size_ = 0;
          v77->__r_.__value_.__r.__words[2] = 0;
          v77->__r_.__value_.__r.__words[0] = 0;
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v79 = &v169;
          else
            v79 = (std::string *)v169.__r_.__value_.__r.__words[0];
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v80 = HIBYTE(v169.__r_.__value_.__r.__words[2]);
          else
            v80 = v169.__r_.__value_.__l.__size_;
          std::string::append(&v172, (const std::string::value_type *)v79, v80);
          if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v169.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_166:
              if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_167;
              goto LABEL_246;
            }
          }
          else if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_166;
          }
          operator delete(v168.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_167;
LABEL_246:
          operator delete(v183.__r_.__value_.__l.__data_);
LABEL_167:
          std::to_string(&v168, BYTE4(v165));
          v81 = std::string::insert(&v168, 0, " [[ sampler(");
          v82 = *(_OWORD *)&v81->__r_.__value_.__l.__data_;
          v183.__r_.__value_.__r.__words[2] = v81->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v183.__r_.__value_.__l.__data_ = v82;
          v81->__r_.__value_.__l.__size_ = 0;
          v81->__r_.__value_.__r.__words[2] = 0;
          v81->__r_.__value_.__r.__words[0] = 0;
          v83 = std::string::append(&v183, ") ]]");
          v84 = *(_OWORD *)&v83->__r_.__value_.__l.__data_;
          v169.__r_.__value_.__r.__words[2] = v83->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v169.__r_.__value_.__l.__data_ = v84;
          v83->__r_.__value_.__l.__size_ = 0;
          v83->__r_.__value_.__r.__words[2] = 0;
          v83->__r_.__value_.__r.__words[0] = 0;
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v85 = &v169;
          else
            v85 = (std::string *)v169.__r_.__value_.__r.__words[0];
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v86 = HIBYTE(v169.__r_.__value_.__r.__words[2]);
          else
            v86 = v169.__r_.__value_.__l.__size_;
          std::string::append(&v172, (const std::string::value_type *)v85, v86);
          if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v169.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_175:
              if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_176;
              goto LABEL_252;
            }
          }
          else if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_175;
          }
          operator delete(v183.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_176;
LABEL_252:
          operator delete(v168.__r_.__value_.__l.__data_);
LABEL_176:
          ++BYTE4(v165);
          goto LABEL_240;
        case 7:
          v64 = v47[31];
          if (v64 >= 0)
            v65 = v47[31];
          else
            v65 = *((_QWORD *)v47 + 2);
          v66 = v65 + 1;
          if (v65 + 1 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          if (v66 >= 0x17)
          {
            v94 = (v66 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v66 | 7) != 0x17)
              v94 = v66 | 7;
            v95 = v94 + 1;
            v67 = (char *)operator new(v94 + 1);
            v183.__r_.__value_.__l.__size_ = v65 + 1;
            v183.__r_.__value_.__r.__words[2] = v95 | 0x8000000000000000;
            v183.__r_.__value_.__r.__words[0] = (std::string::size_type)v67;
          }
          else
          {
            memset(&v183, 0, sizeof(v183));
            v67 = (char *)&v183;
            *((_BYTE *)&v183.__r_.__value_.__s + 23) = v65 + 1;
            if (!v65)
              goto LABEL_197;
          }
          if (v64 >= 0)
            v96 = v47 + 8;
          else
            v96 = (const void *)*((_QWORD *)v47 + 1);
          memmove(v67, v96, v65);
LABEL_197:
          *(_WORD *)&v67[v65] = 32;
          v97 = std::string::append(&v183, "vdata [[ stage_in ]]");
          v98 = *(_OWORD *)&v97->__r_.__value_.__l.__data_;
          v169.__r_.__value_.__r.__words[2] = v97->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v169.__r_.__value_.__l.__data_ = v98;
          v97->__r_.__value_.__l.__size_ = 0;
          v97->__r_.__value_.__r.__words[2] = 0;
          v97->__r_.__value_.__r.__words[0] = 0;
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v92 = &v169;
          else
            v92 = (std::string *)v169.__r_.__value_.__r.__words[0];
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v93 = HIBYTE(v169.__r_.__value_.__r.__words[2]);
          else
            v93 = v169.__r_.__value_.__l.__size_;
LABEL_203:
          std::string::append(&v172, (const std::string::value_type *)v92, v93);
          if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v169.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_240;
          }
          else if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_240;
          }
          operator delete(v183.__r_.__value_.__l.__data_);
          goto LABEL_240;
        case 9:
          v68 = v47[31];
          if (v68 >= 0)
            v69 = v47[31];
          else
            v69 = *((_QWORD *)v47 + 2);
          v70 = v69 + 8;
          if (v69 + 8 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          if (v70 >= 0x17)
          {
            v99 = (v70 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v70 | 7) != 0x17)
              v99 = v70 | 7;
            v100 = v99 + 1;
            v71 = operator new(v99 + 1);
            v183.__r_.__value_.__l.__size_ = v69 + 8;
            v183.__r_.__value_.__r.__words[2] = v100 | 0x8000000000000000;
            v183.__r_.__value_.__r.__words[0] = (std::string::size_type)v71;
          }
          else
          {
            memset(&v183, 0, sizeof(v183));
            v71 = &v183;
            *((_BYTE *)&v183.__r_.__value_.__s + 23) = v69 + 8;
            if (!v69)
              goto LABEL_215;
          }
          if (v68 >= 0)
            v101 = v47 + 8;
          else
            v101 = (const void *)*((_QWORD *)v47 + 1);
          memmove(v71, v101, v69);
LABEL_215:
          strcpy((char *)v71 + v69, " texture");
          std::to_string(&v168, v165);
          if ((v168.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v102 = &v168;
          else
            v102 = (std::string *)v168.__r_.__value_.__r.__words[0];
          if ((v168.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v103 = HIBYTE(v168.__r_.__value_.__r.__words[2]);
          else
            v103 = v168.__r_.__value_.__l.__size_;
          v104 = std::string::append(&v183, (const std::string::value_type *)v102, v103);
          v105 = *(_OWORD *)&v104->__r_.__value_.__l.__data_;
          v169.__r_.__value_.__r.__words[2] = v104->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v169.__r_.__value_.__l.__data_ = v105;
          v104->__r_.__value_.__l.__size_ = 0;
          v104->__r_.__value_.__r.__words[2] = 0;
          v104->__r_.__value_.__r.__words[0] = 0;
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v106 = &v169;
          else
            v106 = (std::string *)v169.__r_.__value_.__r.__words[0];
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v107 = HIBYTE(v169.__r_.__value_.__r.__words[2]);
          else
            v107 = v169.__r_.__value_.__l.__size_;
          std::string::append(&v172, (const std::string::value_type *)v106, v107);
          if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v169.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_229:
              if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_230;
              goto LABEL_249;
            }
          }
          else if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_229;
          }
          operator delete(v168.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_230;
LABEL_249:
          operator delete(v183.__r_.__value_.__l.__data_);
LABEL_230:
          std::to_string(&v168, v165);
          v108 = std::string::insert(&v168, 0, " [[ texture(");
          v109 = *(_OWORD *)&v108->__r_.__value_.__l.__data_;
          v183.__r_.__value_.__r.__words[2] = v108->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v183.__r_.__value_.__l.__data_ = v109;
          v108->__r_.__value_.__l.__size_ = 0;
          v108->__r_.__value_.__r.__words[2] = 0;
          v108->__r_.__value_.__r.__words[0] = 0;
          v110 = std::string::append(&v183, ") ]]");
          v111 = *(_OWORD *)&v110->__r_.__value_.__l.__data_;
          v169.__r_.__value_.__r.__words[2] = v110->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v169.__r_.__value_.__l.__data_ = v111;
          v110->__r_.__value_.__l.__size_ = 0;
          v110->__r_.__value_.__r.__words[2] = 0;
          v110->__r_.__value_.__r.__words[0] = 0;
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v112 = &v169;
          else
            v112 = (std::string *)v169.__r_.__value_.__r.__words[0];
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v113 = HIBYTE(v169.__r_.__value_.__r.__words[2]);
          else
            v113 = v169.__r_.__value_.__l.__size_;
          std::string::append(&v172, (const std::string::value_type *)v112, v113);
          if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v169.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_238:
              if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_239;
              goto LABEL_255;
            }
          }
          else if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_238;
          }
          operator delete(v183.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_239;
LABEL_255:
          operator delete(v168.__r_.__value_.__l.__data_);
LABEL_239:
          LOBYTE(v165) = v165 + 1;
LABEL_240:
          *((_BYTE *)&v169.__r_.__value_.__s + 23) = 4;
          strcpy((char *)&v169, "    ");
          v114 = std::string::insert(&v169, 0, ",\n");
          v115 = v114->__r_.__value_.__r.__words[0];
          v183.__r_.__value_.__r.__words[0] = v114->__r_.__value_.__l.__size_;
          *(std::string::size_type *)((char *)v183.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v114->__r_.__value_.__r.__words[1] + 7);
          v116 = HIBYTE(v114->__r_.__value_.__r.__words[2]);
          v114->__r_.__value_.__l.__size_ = 0;
          v114->__r_.__value_.__r.__words[2] = 0;
          v114->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v170.__r_.__value_.__l.__data_);
          v170.__r_.__value_.__r.__words[0] = v115;
          v170.__r_.__value_.__l.__size_ = v183.__r_.__value_.__r.__words[0];
          *(std::string::size_type *)((char *)&v170.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v183.__r_.__value_.__r.__words + 7);
          *((_BYTE *)&v170.__r_.__value_.__s + 23) = v116;
          if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v169.__r_.__value_.__l.__data_);
          v47 += 48;
          if (v47 != v48)
            continue;
          goto LABEL_256;
        default:
          goto LABEL_240;
      }
    }
  }
LABEL_256:
  std::string::append(&v172, ")\n");
  memset(&v169, 0, sizeof(v169));
  std::string::reserve(&v169, 0x400uLL);
  std::string::append(&v169, "struct VertexData {\n");
  *((_BYTE *)&v168.__r_.__value_.__s + 23) = 4;
  strcpy((char *)&v168, "    ");
  v117 = std::string::append(&v168, "float4 _position [[ position ]];\n");
  v118 = *(_OWORD *)&v117->__r_.__value_.__l.__data_;
  v183.__r_.__value_.__r.__words[2] = v117->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v183.__r_.__value_.__l.__data_ = v118;
  v117->__r_.__value_.__l.__size_ = 0;
  v117->__r_.__value_.__r.__words[2] = 0;
  v117->__r_.__value_.__r.__words[0] = 0;
  if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v119 = &v183;
  else
    v119 = (std::string *)v183.__r_.__value_.__r.__words[0];
  if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v120 = HIBYTE(v183.__r_.__value_.__r.__words[2]);
  else
    v120 = v183.__r_.__value_.__l.__size_;
  std::string::append(&v169, (const std::string::value_type *)v119, v120);
  if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_264;
LABEL_267:
    operator delete(v168.__r_.__value_.__l.__data_);
    v121 = v177;
    if (!(_QWORD)v177)
      goto LABEL_303;
    goto LABEL_268;
  }
  operator delete(v183.__r_.__value_.__l.__data_);
  if (SHIBYTE(v168.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_267;
LABEL_264:
  v121 = v177;
  if ((_QWORD)v177)
  {
LABEL_268:
    v122 = 0;
    while (1)
    {
      *((_BYTE *)&v167.__r_.__value_.__s + 23) = 4;
      strcpy((char *)&v167, "    ");
      v123 = std::string::append(&v167, "float4 _texcoord");
      v124 = *(_OWORD *)&v123->__r_.__value_.__l.__data_;
      v168.__r_.__value_.__r.__words[2] = v123->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v168.__r_.__value_.__l.__data_ = v124;
      v123->__r_.__value_.__l.__size_ = 0;
      v123->__r_.__value_.__r.__words[2] = 0;
      v123->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v166, v122);
      if ((v166.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v125 = &v166;
      else
        v125 = (std::string *)v166.__r_.__value_.__r.__words[0];
      if ((v166.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v126 = HIBYTE(v166.__r_.__value_.__r.__words[2]);
      else
        v126 = v166.__r_.__value_.__l.__size_;
      v127 = std::string::append(&v168, (const std::string::value_type *)v125, v126);
      v128 = *(_OWORD *)&v127->__r_.__value_.__l.__data_;
      v183.__r_.__value_.__r.__words[2] = v127->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v183.__r_.__value_.__l.__data_ = v128;
      v127->__r_.__value_.__l.__size_ = 0;
      v127->__r_.__value_.__r.__words[2] = 0;
      v127->__r_.__value_.__r.__words[0] = 0;
      if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v129 = &v183;
      else
        v129 = (std::string *)v183.__r_.__value_.__r.__words[0];
      if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v130 = HIBYTE(v183.__r_.__value_.__r.__words[2]);
      else
        v130 = v183.__r_.__value_.__l.__size_;
      std::string::append(&v169, (const std::string::value_type *)v129, v130);
      if (SHIBYTE(v183.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v183.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v166.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_285:
          if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_286;
          goto LABEL_298;
        }
      }
      else if ((SHIBYTE(v166.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_285;
      }
      operator delete(v166.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_286:
        if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_299;
        goto LABEL_287;
      }
LABEL_298:
      operator delete(v168.__r_.__value_.__l.__data_);
      if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
LABEL_299:
        operator delete(v167.__r_.__value_.__l.__data_);
LABEL_287:
      std::to_string(&v167, v122);
      v131 = std::string::insert(&v167, 0, " [[ user(texcoord");
      v132 = *(_OWORD *)&v131->__r_.__value_.__l.__data_;
      v168.__r_.__value_.__r.__words[2] = v131->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v168.__r_.__value_.__l.__data_ = v132;
      v131->__r_.__value_.__l.__size_ = 0;
      v131->__r_.__value_.__r.__words[2] = 0;
      v131->__r_.__value_.__r.__words[0] = 0;
      v133 = std::string::append(&v168, ") ]];\n");
      v134 = *(_OWORD *)&v133->__r_.__value_.__l.__data_;
      v183.__r_.__value_.__r.__words[2] = v133->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v183.__r_.__value_.__l.__data_ = v134;
      v133->__r_.__value_.__l.__size_ = 0;
      v133->__r_.__value_.__r.__words[2] = 0;
      v133->__r_.__value_.__r.__words[0] = 0;
      if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v135 = &v183;
      else
        v135 = (std::string *)v183.__r_.__value_.__r.__words[0];
      if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v136 = HIBYTE(v183.__r_.__value_.__r.__words[2]);
      else
        v136 = v183.__r_.__value_.__l.__size_;
      std::string::append(&v169, (const std::string::value_type *)v135, v136);
      if (SHIBYTE(v183.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v183.__r_.__value_.__l.__data_);
        if (SHIBYTE(v168.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_269;
LABEL_301:
        if ((SHIBYTE(v167.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_270;
LABEL_302:
        operator delete(v167.__r_.__value_.__l.__data_);
        if (v121 == ++v122)
          break;
      }
      else
      {
        if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_301;
LABEL_269:
        operator delete(v168.__r_.__value_.__l.__data_);
        if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_302;
LABEL_270:
        if (v121 == ++v122)
          break;
      }
    }
  }
LABEL_303:
  if (!v174)
    goto LABEL_312;
  *((_BYTE *)&v168.__r_.__value_.__s + 23) = 4;
  strcpy((char *)&v168, "    ");
  v137 = std::string::append(&v168, "float4 _color [[ user(primary) ]];\n");
  v138 = *(_OWORD *)&v137->__r_.__value_.__l.__data_;
  v183.__r_.__value_.__r.__words[2] = v137->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v183.__r_.__value_.__l.__data_ = v138;
  v137->__r_.__value_.__l.__size_ = 0;
  v137->__r_.__value_.__r.__words[2] = 0;
  v137->__r_.__value_.__r.__words[0] = 0;
  if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v139 = &v183;
  else
    v139 = (std::string *)v183.__r_.__value_.__r.__words[0];
  if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v140 = HIBYTE(v183.__r_.__value_.__r.__words[2]);
  else
    v140 = v183.__r_.__value_.__l.__size_;
  std::string::append(&v169, (const std::string::value_type *)v139, v140);
  if (SHIBYTE(v183.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v183.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_312;
  }
  else if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_312;
  }
  operator delete(v168.__r_.__value_.__l.__data_);
LABEL_312:
  std::string::append(&v169, "};\n");
  v141 = SHIBYTE(v169.__r_.__value_.__r.__words[2]);
  if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v142 = HIBYTE(v169.__r_.__value_.__r.__words[2]);
  else
    v142 = v169.__r_.__value_.__l.__size_;
  v143 = SHIBYTE(v172.__r_.__value_.__r.__words[2]);
  if ((v172.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v144 = HIBYTE(v172.__r_.__value_.__r.__words[2]);
  else
    v144 = v172.__r_.__value_.__l.__size_;
  v145 = v144 + v142;
  if (v144 + v142 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  if (v145 <= 0x16)
  {
    memset(&v168, 0, sizeof(v168));
    v146 = (char *)&v168;
    *((_BYTE *)&v168.__r_.__value_.__s + 23) = v144 + v142;
    if (!v142)
      goto LABEL_325;
    goto LABEL_321;
  }
  v157 = (v145 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v145 | 7) != 0x17)
    v157 = v145 | 7;
  v158 = v157 + 1;
  v146 = (char *)operator new(v157 + 1);
  v168.__r_.__value_.__l.__size_ = v144 + v142;
  v168.__r_.__value_.__r.__words[2] = v158 | 0x8000000000000000;
  v168.__r_.__value_.__r.__words[0] = (std::string::size_type)v146;
  if (v142)
  {
LABEL_321:
    if (v141 >= 0)
      v147 = &v169;
    else
      v147 = (std::string *)v169.__r_.__value_.__r.__words[0];
    memmove(v146, v147, v142);
  }
LABEL_325:
  v148 = &v146[v142];
  if (v144)
  {
    if (v143 >= 0)
      v149 = &v172;
    else
      v149 = (std::string *)v172.__r_.__value_.__r.__words[0];
    memmove(v148, v149, v144);
  }
  v148[v144] = 0;
  if ((v173.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v150 = &v173;
  else
    v150 = (std::string *)v173.__r_.__value_.__r.__words[0];
  if ((v173.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v151 = HIBYTE(v173.__r_.__value_.__r.__words[2]);
  else
    v151 = v173.__r_.__value_.__l.__size_;
  v152 = std::string::append(&v168, (const std::string::value_type *)v150, v151);
  v153 = *(_OWORD *)&v152->__r_.__value_.__l.__data_;
  v183.__r_.__value_.__r.__words[2] = v152->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v183.__r_.__value_.__l.__data_ = v153;
  v152->__r_.__value_.__l.__size_ = 0;
  v152->__r_.__value_.__r.__words[2] = 0;
  v152->__r_.__value_.__r.__words[0] = 0;
  if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v154 = &v183;
  else
    v154 = (std::string *)v183.__r_.__value_.__r.__words[0];
  if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v155 = HIBYTE(v183.__r_.__value_.__r.__words[2]);
  else
    v155 = v183.__r_.__value_.__l.__size_;
  std::string::append(v164, (const std::string::value_type *)v154, v155);
  if (SHIBYTE(v183.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v183.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_344:
      if ((SHIBYTE(v169.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_345;
      goto LABEL_357;
    }
  }
  else if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_344;
  }
  operator delete(v168.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v169.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_345:
    if ((SHIBYTE(v170.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_346;
    goto LABEL_358;
  }
LABEL_357:
  operator delete(v169.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v170.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_346:
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_347;
    goto LABEL_359;
  }
LABEL_358:
  operator delete(v170.__r_.__value_.__l.__data_);
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_347:
    if ((SHIBYTE(v172.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_348;
    goto LABEL_360;
  }
LABEL_359:
  operator delete(__dst.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v172.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_348:
    if ((SHIBYTE(v173.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_349;
    goto LABEL_361;
  }
LABEL_360:
  operator delete(v172.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v173.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_349:
    v156 = *(void ***)&v178[1];
    if (!*(_QWORD *)&v178[1])
      goto LABEL_362;
    do
    {
LABEL_368:
      v163 = (void **)*v156;
      if (*((char *)v156 + 47) < 0)
        operator delete(v156[3]);
      operator delete(v156);
      v156 = v163;
    }
    while (v163);
    goto LABEL_362;
  }
LABEL_361:
  operator delete(v173.__r_.__value_.__l.__data_);
  v156 = *(void ***)&v178[1];
  if (*(_QWORD *)&v178[1])
    goto LABEL_368;
LABEL_362:
  v159 = *(void **)&v178[0];
  *(_QWORD *)&v178[0] = 0;
  if (v159)
    operator delete(v159);
  v160 = v180;
  if (v180)
  {
    v161 = v181;
    v162 = v180;
    if (v181 != v180)
    {
      do
      {
        if (*(v161 - 17) < 0)
          operator delete(*((void **)v161 - 5));
        v161 -= 48;
      }
      while (v161 != v160);
      v162 = v180;
    }
    v181 = v160;
    operator delete(v162);
  }
}

void sub_1B2A29F98(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 177) < 0)
  {
    operator delete(*(void **)(v1 - 200));
    std::vector<HGBinding>::~vector[abi:ne180100]((void **)(v1 - 152));
    _Unwind_Resume(a1);
  }
  std::vector<HGBinding>::~vector[abi:ne180100]((void **)(v1 - 152));
  _Unwind_Resume(a1);
}

void sub_1B2A2A3A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if ((a32 & 0x80000000) == 0)
    JUMPOUT(0x1B2A2A358);
  JUMPOUT(0x1B2A2A350);
}

void HGProgramDescriptor::privateEncodeShaderFunction(uint64_t a1, std::string *a2, uint64_t a3, uint64_t a4, unint64_t *a5, __int128 *a6, _QWORD *a7, uint64_t *a8, _BYTE *a9)
{
  unint64_t *v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 *v24;
  uint64_t v25;
  uint64_t v26;
  __int128 *v27;
  uint64_t v28;
  uint64_t v29;
  __int128 *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  std::string *v49;
  const std::string::value_type **v50;
  __int128 v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  std::string *v60;
  const std::string::value_type **v61;
  __int128 v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  std::string *v66;
  __int128 v67;
  std::string *v68;
  __int128 v69;
  std::string *v70;
  __int128 v71;
  const std::string::value_type *v72;
  std::string::size_type v73;
  std::string *v74;
  __int128 v75;
  std::string *v76;
  __int128 v77;
  std::string *v78;
  std::string::size_type size;
  void *v80;
  std::string *v81;
  __int128 v82;
  std::string *v83;
  std::string::size_type v84;
  std::string *v85;
  __int128 v86;
  std::string *v87;
  __int128 v88;
  const std::string::value_type *v89;
  std::string::size_type v90;
  std::string *v91;
  __int128 v92;
  std::string *v93;
  __int128 v94;
  const std::string::value_type *v95;
  std::string::size_type v96;
  std::string *v97;
  __int128 v98;
  std::string *v99;
  __int128 v100;
  const std::string::value_type *v101;
  std::string::size_type v102;
  std::string *v103;
  __int128 v104;
  std::string *v105;
  __int128 v106;
  const std::string::value_type *v107;
  std::string::size_type v108;
  unint64_t v109;
  __int128 v110;
  char *v111;
  int v112;
  __int128 v113;
  char *v114;
  int v115;
  uint64_t v116;
  uint64_t v117;
  std::string *v118;
  __int128 v119;
  int v120;
  const std::string::value_type *v121;
  std::string::size_type v122;
  std::string *v123;
  __int128 v124;
  std::string *v125;
  __int128 v126;
  std::string *v127;
  std::string::size_type v128;
  std::string *v129;
  __int128 v130;
  std::string *v131;
  __int128 v132;
  const std::string::value_type *v133;
  std::string::size_type v134;
  int v135;
  size_t v136;
  unint64_t v137;
  char *p_dst;
  uint64_t v139;
  uint64_t v140;
  const void *v141;
  std::string *v142;
  std::string::size_type v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  unint64_t v148;
  uint64_t v149;
  const char *v150;
  const std::string::value_type *v151;
  std::string *v152;
  std::string::size_type v153;
  uint64_t v154;
  uint64_t v155;
  int v156;
  BOOL v157;
  std::string *v158;
  std::string::size_type v159;
  std::string *v160;
  __int128 v161;
  std::string *v162;
  std::string::size_type v163;
  _QWORD *v164;
  const std::string::value_type *v165;
  const std::string::value_type *v166;
  const std::string::value_type *v167;
  int v168;
  const std::string::value_type *v169;
  std::string::size_type v170;
  uint64_t v171;
  _DWORD *v172;
  const char *v173;
  int v174;
  std::string *v175;
  __int128 v176;
  std::string *v177;
  std::string::size_type v178;
  std::string *v179;
  __int128 v180;
  void *v181;
  void **v182;
  void **v183;
  unint64_t v184;
  unint64_t v185;
  uint64_t v186;
  void *v187;
  void **v188;
  void **v189;
  unint64_t v190;
  unint64_t v191;
  uint64_t v192;
  void *v193;
  void **v194;
  void **v195;
  unint64_t v196;
  unint64_t v197;
  uint64_t v198;
  void *v199;
  unint64_t __val;
  std::string v206;
  _BYTE v207[32];
  __int128 v208;
  std::string v209;
  std::string v210;
  std::string __dst;
  std::string v212;
  void *__p;
  _QWORD *v214;
  _QWORD *v215;
  __int128 v216;
  __int128 v217;
  __int128 v218;
  __int128 v219;
  __int128 v220;
  __int128 v221;
  __int128 v222;
  __int128 v223;
  __int128 v224;

  v9 = a5;
  v223 = 0u;
  v224 = 0u;
  v221 = 0u;
  v222 = 0u;
  v219 = 0u;
  v220 = 0u;
  v217 = 0u;
  v218 = 0u;
  v216 = 0u;
  v13 = *(_QWORD *)(a1 + 232);
  v12 = *(_QWORD *)(a1 + 240);
  v214 = 0;
  v215 = 0;
  __p = 0;
  v14 = v12 - v13;
  if (v14)
  {
    v15 = v14 / 48;
    if ((unint64_t)(v14 / 48) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v17 = operator new(8 * v15);
    __p = v17;
    v215 = &v17[v15];
    bzero(v17, 8 * v15);
    v18 = 0;
    v19 = 0;
    v214 = v215;
    if (v15 <= 1)
      v20 = 1;
    else
      v20 = v15;
    while (1)
    {
      v21 = *(_QWORD *)(a1 + 232);
      switch(*(_DWORD *)(v21 + v18))
      {
        case 5:
          *v17 = -1;
          goto LABEL_7;
        case 6:
          if (*((_QWORD *)&v218 + 1))
          {
            v25 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)&v216 + 1) + (((unint64_t)v218 >> 6) & 0x3FFFFFFFFFFFFF8))
                            + 8 * (v218 & 0x1FF));
            *(_QWORD *)&v218 = v218 + 1;
            --*((_QWORD *)&v218 + 1);
            if ((unint64_t)v218 < 0x400)
              goto LABEL_51;
            operator delete(**((void ***)&v216 + 1));
            *((_QWORD *)&v216 + 1) += 8;
            v26 = -512;
            v27 = &v218;
          }
          else
          {
            v41 = *((_QWORD *)&v222 + 1);
            v25 = *a8;
            if ((_QWORD)v223 == *((_QWORD *)&v222 + 1))
              v42 = 0;
            else
              v42 = (((_QWORD)v223 - *((_QWORD *)&v222 + 1)) << 6) - 1;
            v43 = *((_QWORD *)&v224 + 1) + v224;
            if (v42 == *((_QWORD *)&v224 + 1) + (_QWORD)v224)
            {
              std::deque<unsigned long>::__add_back_capacity(&v222);
              v41 = *((_QWORD *)&v222 + 1);
              v43 = *((_QWORD *)&v224 + 1) + v224;
            }
            v44 = *((_QWORD *)&v219 + 1);
            v45 = (((_QWORD)v220 - *((_QWORD *)&v219 + 1)) << 6) - 1;
            v157 = (_QWORD)v220 == *((_QWORD *)&v219 + 1);
            *(_QWORD *)(*(_QWORD *)(v41 + ((v43 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v43 & 0x1FF)) = *(_QWORD *)a6;
            ++*((_QWORD *)&v224 + 1);
            if (v157)
              v46 = 0;
            else
              v46 = v45;
            v47 = *((_QWORD *)&v221 + 1) + v221;
            if (v46 == *((_QWORD *)&v221 + 1) + (_QWORD)v221)
            {
              std::deque<unsigned long>::__add_back_capacity(&v219);
              v44 = *((_QWORD *)&v219 + 1);
              v47 = *((_QWORD *)&v221 + 1) + v221;
            }
            *(_QWORD *)(*(_QWORD *)(v44 + ((v47 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v47 & 0x1FF)) = *a7;
            ++*((_QWORD *)&v221 + 1);
            ++*a7;
            ++*a8;
            v27 = a6;
            v26 = 1;
          }
          *(_QWORD *)v27 += v26;
LABEL_51:
          *v17 = v25;
          v48 = *(_QWORD *)(a3 + 8);
          if (v48 >= *(_QWORD *)(a3 + 16))
          {
            *(_QWORD *)(a3 + 8) = std::vector<HGBinding>::__push_back_slow_path<HGBinding const&>((char **)a3, v21 + v18);
          }
          else
          {
            *(_DWORD *)v48 = *(_DWORD *)(v21 + v18);
            v49 = (std::string *)(v48 + 8);
            v50 = (const std::string::value_type **)(v21 + v18 + 8);
            if (*(char *)(v21 + v18 + 31) < 0)
            {
              std::string::__init_copy_ctor_external(v49, *v50, *(_QWORD *)(v21 + v18 + 16));
            }
            else
            {
              v51 = *(_OWORD *)v50;
              *(_QWORD *)(v48 + 24) = *(_QWORD *)(v21 + v18 + 24);
              *(_OWORD *)&v49->__r_.__value_.__l.__data_ = v51;
            }
            *(_OWORD *)(v48 + 32) = *(_OWORD *)(v21 + v18 + 32);
            *(_QWORD *)(a3 + 8) = v48 + 48;
            *(_QWORD *)(a3 + 8) = v48 + 48;
          }
          goto LABEL_7;
        case 8:
          if (*((_QWORD *)&v224 + 1))
          {
            v22 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)&v222 + 1) + (((unint64_t)v224 >> 6) & 0x3FFFFFFFFFFFFF8))
                            + 8 * (v224 & 0x1FF));
            *(_QWORD *)&v224 = v224 + 1;
            --*((_QWORD *)&v224 + 1);
            if ((unint64_t)v224 < 0x400)
            {
LABEL_38:
              *v17 = v22;
              goto LABEL_7;
            }
            operator delete(**((void ***)&v222 + 1));
            *((_QWORD *)&v222 + 1) += 8;
            v23 = -512;
            v24 = &v224;
          }
          else
          {
            v34 = *((_QWORD *)&v219 + 1);
            v22 = *(_QWORD *)a6;
            if ((_QWORD)v220 == *((_QWORD *)&v219 + 1))
              v35 = 0;
            else
              v35 = (((_QWORD)v220 - *((_QWORD *)&v219 + 1)) << 6) - 1;
            v36 = *((_QWORD *)&v221 + 1) + v221;
            if (v35 == *((_QWORD *)&v221 + 1) + (_QWORD)v221)
            {
              std::deque<unsigned long>::__add_back_capacity(&v219);
              v34 = *((_QWORD *)&v219 + 1);
              v36 = *((_QWORD *)&v221 + 1) + v221;
            }
            v37 = *((_QWORD *)&v216 + 1);
            v38 = (((_QWORD)v217 - *((_QWORD *)&v216 + 1)) << 6) - 1;
            v157 = (_QWORD)v217 == *((_QWORD *)&v216 + 1);
            *(_QWORD *)(*(_QWORD *)(v34 + ((v36 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v36 & 0x1FF)) = *a7;
            ++*((_QWORD *)&v221 + 1);
            if (v157)
              v39 = 0;
            else
              v39 = v38;
            v40 = *((_QWORD *)&v218 + 1) + v218;
            if (v39 == *((_QWORD *)&v218 + 1) + (_QWORD)v218)
            {
              std::deque<unsigned long>::__add_back_capacity(&v216);
              v37 = *((_QWORD *)&v216 + 1);
              v40 = *((_QWORD *)&v218 + 1) + v218;
            }
            *(_QWORD *)(*(_QWORD *)(v37 + ((v40 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v40 & 0x1FF)) = *a8;
            ++*((_QWORD *)&v218 + 1);
            ++*a7;
            ++*a8;
            v24 = a6;
            v23 = 1;
          }
          *(_QWORD *)v24 += v23;
          goto LABEL_38;
        case 9:
          if (*((_QWORD *)&v221 + 1))
          {
            v28 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)&v219 + 1) + (((unint64_t)v221 >> 6) & 0x3FFFFFFFFFFFFF8))
                            + 8 * (v221 & 0x1FF));
            *(_QWORD *)&v221 = v221 + 1;
            --*((_QWORD *)&v221 + 1);
            if ((unint64_t)v221 < 0x400)
            {
LABEL_67:
              *v17 = v28;
              v59 = *(_QWORD *)(a3 + 8);
              if (v59 >= *(_QWORD *)(a3 + 16))
              {
                v63 = std::vector<HGBinding>::__push_back_slow_path<HGBinding const&>((char **)a3, v21 + v18);
              }
              else
              {
                *(_DWORD *)v59 = *(_DWORD *)(v21 + v18);
                v60 = (std::string *)(v59 + 8);
                v61 = (const std::string::value_type **)(v21 + v18 + 8);
                if (*(char *)(v21 + v18 + 31) < 0)
                {
                  std::string::__init_copy_ctor_external(v60, *v61, *(_QWORD *)(v21 + v18 + 16));
                }
                else
                {
                  v62 = *(_OWORD *)v61;
                  *(_QWORD *)(v59 + 24) = *(_QWORD *)(v21 + v18 + 24);
                  *(_OWORD *)&v60->__r_.__value_.__l.__data_ = v62;
                }
                *(_OWORD *)(v59 + 32) = *(_OWORD *)(v21 + v18 + 32);
                v63 = v59 + 48;
                *(_QWORD *)(a3 + 8) = v59 + 48;
              }
              *(_QWORD *)(a3 + 8) = v63;
              ++v19;
              goto LABEL_7;
            }
            operator delete(**((void ***)&v219 + 1));
            *((_QWORD *)&v219 + 1) += 8;
            v29 = -512;
            v30 = &v221;
          }
          else
          {
            v52 = *((_QWORD *)&v222 + 1);
            v28 = *a7;
            if ((_QWORD)v223 == *((_QWORD *)&v222 + 1))
              v53 = 0;
            else
              v53 = (((_QWORD)v223 - *((_QWORD *)&v222 + 1)) << 6) - 1;
            v54 = *((_QWORD *)&v224 + 1) + v224;
            if (v53 == *((_QWORD *)&v224 + 1) + (_QWORD)v224)
            {
              std::deque<unsigned long>::__add_back_capacity(&v222);
              v52 = *((_QWORD *)&v222 + 1);
              v54 = *((_QWORD *)&v224 + 1) + v224;
            }
            v55 = *((_QWORD *)&v216 + 1);
            v56 = (((_QWORD)v217 - *((_QWORD *)&v216 + 1)) << 6) - 1;
            v157 = (_QWORD)v217 == *((_QWORD *)&v216 + 1);
            *(_QWORD *)(*(_QWORD *)(v52 + ((v54 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v54 & 0x1FF)) = *(_QWORD *)a6;
            ++*((_QWORD *)&v224 + 1);
            if (v157)
              v57 = 0;
            else
              v57 = v56;
            v58 = *((_QWORD *)&v218 + 1) + v218;
            if (v57 == *((_QWORD *)&v218 + 1) + (_QWORD)v218)
            {
              std::deque<unsigned long>::__add_back_capacity(&v216);
              v55 = *((_QWORD *)&v216 + 1);
              v58 = *((_QWORD *)&v218 + 1) + v218;
            }
            *(_QWORD *)(*(_QWORD *)(v55 + ((v58 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v58 & 0x1FF)) = *a8;
            ++*((_QWORD *)&v218 + 1);
            ++*a7;
            ++*a8;
            v30 = a6;
            v29 = 1;
          }
          *(_QWORD *)v30 += v29;
          goto LABEL_67;
        case 0xA:
          v31 = *(_QWORD *)(a1 + 112) + 16 * v19;
          v32 = *(_DWORD *)v31;
          v33 = *(_QWORD *)(v31 + 8);
          if (v33)
            (*(void (**)(uint64_t))(*(_QWORD *)v33 + 16))(v33);
          if (v32 == 3)
          {
            std::to_string(&v212, *a5);
            v68 = std::string::insert(&v212, 0, "r");
            v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
            *(_QWORD *)&v207[16] = *((_QWORD *)&v68->__r_.__value_.__l + 2);
            *(_OWORD *)v207 = v69;
            v68->__r_.__value_.__l.__size_ = 0;
            v68->__r_.__value_.__r.__words[2] = 0;
            v68->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v212.__r_.__value_.__l.__data_);
            *v17 = *a5;
            *((_BYTE *)&v209.__r_.__value_.__s + 23) = 4;
            strcpy((char *)&v209, "    ");
            v70 = std::string::append(&v209, "float4 ");
            v71 = *(_OWORD *)&v70->__r_.__value_.__l.__data_;
            v210.__r_.__value_.__r.__words[2] = v70->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v210.__r_.__value_.__l.__data_ = v71;
            v70->__r_.__value_.__l.__size_ = 0;
            v70->__r_.__value_.__r.__words[2] = 0;
            v70->__r_.__value_.__r.__words[0] = 0;
            if (v207[23] >= 0)
              v72 = v207;
            else
              v72 = *(const std::string::value_type **)v207;
            if (v207[23] >= 0)
              v73 = v207[23];
            else
              v73 = *(_QWORD *)&v207[8];
            v74 = std::string::append(&v210, v72, v73);
            v75 = *(_OWORD *)&v74->__r_.__value_.__l.__data_;
            __dst.__r_.__value_.__r.__words[2] = v74->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v75;
            v74->__r_.__value_.__l.__size_ = 0;
            v74->__r_.__value_.__r.__words[2] = 0;
            v74->__r_.__value_.__r.__words[0] = 0;
            v76 = std::string::append(&__dst, " = ");
            v77 = *(_OWORD *)&v76->__r_.__value_.__l.__data_;
            v212.__r_.__value_.__r.__words[2] = v76->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v212.__r_.__value_.__l.__data_ = v77;
            v76->__r_.__value_.__l.__size_ = 0;
            v76->__r_.__value_.__r.__words[2] = 0;
            v76->__r_.__value_.__r.__words[0] = 0;
            if ((v212.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v78 = &v212;
            else
              v78 = (std::string *)v212.__r_.__value_.__r.__words[0];
            if ((v212.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              size = HIBYTE(v212.__r_.__value_.__r.__words[2]);
            else
              size = v212.__r_.__value_.__l.__size_;
            std::string::append(a2, (const std::string::value_type *)v78, size);
            if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_90;
LABEL_161:
              operator delete(__dst.__r_.__value_.__l.__data_);
              if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
                goto LABEL_162;
LABEL_91:
              if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_92;
LABEL_163:
              operator delete(v209.__r_.__value_.__l.__data_);
              goto LABEL_92;
            }
            operator delete(v212.__r_.__value_.__l.__data_);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
              goto LABEL_161;
LABEL_90:
            if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_91;
LABEL_162:
            operator delete(v210.__r_.__value_.__l.__data_);
            if (SHIBYTE(v209.__r_.__value_.__r.__words[2]) < 0)
              goto LABEL_163;
LABEL_92:
            std::string::append(a2, "float4(0.0, 0.0, 0.0, 0.0);\n");
            if ((v207[23] & 0x80000000) != 0)
            {
              v80 = *(void **)v207;
              goto LABEL_157;
            }
            goto LABEL_158;
          }
          if (v32 == 1)
          {
            v64 = (*a7)++;
            v65 = (*a8)++;
            __val = (*(_QWORD *)a6)++;
            std::to_string((std::string *)v207, *a5);
            v66 = std::string::insert((std::string *)v207, 0, "r");
            v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
            v212.__r_.__value_.__r.__words[2] = v66->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v212.__r_.__value_.__l.__data_ = v67;
            v66->__r_.__value_.__l.__size_ = 0;
            v66->__r_.__value_.__r.__words[2] = 0;
            v66->__r_.__value_.__r.__words[0] = 0;
            if ((v207[23] & 0x80000000) != 0)
            {
              operator delete(*(void **)v207);
              *(_QWORD *)v207 = *a5;
              if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0)
                goto LABEL_101;
LABEL_73:
              *(std::string *)&v207[8] = v212;
            }
            else
            {
              *(_QWORD *)v207 = *a5;
              if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_73;
LABEL_101:
              std::string::__init_copy_ctor_external((std::string *)&v207[8], v212.__r_.__value_.__l.__data_, v212.__r_.__value_.__l.__size_);
            }
            std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long const,std::string>>(a4, (unint64_t *)v207, (uint64_t)v207);
            if ((v207[31] & 0x80000000) != 0)
              operator delete(*(void **)&v207[8]);
            *v17 = *a5;
            *((_BYTE *)&v209.__r_.__value_.__s + 23) = 4;
            strcpy((char *)&v209, "    ");
            v81 = std::string::append(&v209, "float4 ");
            v82 = *(_OWORD *)&v81->__r_.__value_.__l.__data_;
            v210.__r_.__value_.__r.__words[2] = v81->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v210.__r_.__value_.__l.__data_ = v82;
            v81->__r_.__value_.__l.__size_ = 0;
            v81->__r_.__value_.__r.__words[2] = 0;
            v81->__r_.__value_.__r.__words[0] = 0;
            if ((v212.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v83 = &v212;
            else
              v83 = (std::string *)v212.__r_.__value_.__r.__words[0];
            if ((v212.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v84 = HIBYTE(v212.__r_.__value_.__r.__words[2]);
            else
              v84 = v212.__r_.__value_.__l.__size_;
            v85 = std::string::append(&v210, (const std::string::value_type *)v83, v84);
            v86 = *(_OWORD *)&v85->__r_.__value_.__l.__data_;
            __dst.__r_.__value_.__r.__words[2] = v85->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v86;
            v85->__r_.__value_.__l.__size_ = 0;
            v85->__r_.__value_.__r.__words[2] = 0;
            v85->__r_.__value_.__r.__words[0] = 0;
            v87 = std::string::append(&__dst, " = ");
            v88 = *(_OWORD *)&v87->__r_.__value_.__l.__data_;
            *(_QWORD *)&v207[16] = *((_QWORD *)&v87->__r_.__value_.__l + 2);
            *(_OWORD *)v207 = v88;
            v87->__r_.__value_.__l.__size_ = 0;
            v87->__r_.__value_.__r.__words[2] = 0;
            v87->__r_.__value_.__r.__words[0] = 0;
            if (v207[23] >= 0)
              v89 = v207;
            else
              v89 = *(const std::string::value_type **)v207;
            if (v207[23] >= 0)
              v90 = v207[23];
            else
              v90 = *(_QWORD *)&v207[8];
            std::string::append(a2, v89, v90);
            if ((v207[23] & 0x80000000) == 0)
            {
              if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_118;
LABEL_165:
              operator delete(__dst.__r_.__value_.__l.__data_);
              if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
                goto LABEL_166;
LABEL_119:
              if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_120;
LABEL_167:
              operator delete(v209.__r_.__value_.__l.__data_);
              goto LABEL_120;
            }
            operator delete(*(void **)v207);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
              goto LABEL_165;
LABEL_118:
            if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_119;
LABEL_166:
            operator delete(v210.__r_.__value_.__l.__data_);
            if (SHIBYTE(v209.__r_.__value_.__r.__words[2]) < 0)
              goto LABEL_167;
LABEL_120:
            std::to_string(&v210, v64);
            v91 = std::string::insert(&v210, 0, "texture");
            v92 = *(_OWORD *)&v91->__r_.__value_.__l.__data_;
            __dst.__r_.__value_.__r.__words[2] = v91->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v92;
            v91->__r_.__value_.__l.__size_ = 0;
            v91->__r_.__value_.__r.__words[2] = 0;
            v91->__r_.__value_.__r.__words[0] = 0;
            v93 = std::string::append(&__dst, ".sample(");
            v94 = *(_OWORD *)&v93->__r_.__value_.__l.__data_;
            *(_QWORD *)&v207[16] = *((_QWORD *)&v93->__r_.__value_.__l + 2);
            *(_OWORD *)v207 = v94;
            v93->__r_.__value_.__l.__size_ = 0;
            v93->__r_.__value_.__r.__words[2] = 0;
            v93->__r_.__value_.__r.__words[0] = 0;
            if (v207[23] >= 0)
              v95 = v207;
            else
              v95 = *(const std::string::value_type **)v207;
            if (v207[23] >= 0)
              v96 = v207[23];
            else
              v96 = *(_QWORD *)&v207[8];
            std::string::append(a2, v95, v96);
            if ((v207[23] & 0x80000000) != 0)
            {
              operator delete(*(void **)v207);
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                goto LABEL_169;
LABEL_128:
              if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
LABEL_170:
                operator delete(v210.__r_.__value_.__l.__data_);
            }
            else
            {
              if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_128;
LABEL_169:
              operator delete(__dst.__r_.__value_.__l.__data_);
              if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
                goto LABEL_170;
            }
            std::to_string(&v210, v65);
            v97 = std::string::insert(&v210, 0, "sampler");
            v98 = *(_OWORD *)&v97->__r_.__value_.__l.__data_;
            __dst.__r_.__value_.__r.__words[2] = v97->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v98;
            v97->__r_.__value_.__l.__size_ = 0;
            v97->__r_.__value_.__r.__words[2] = 0;
            v97->__r_.__value_.__r.__words[0] = 0;
            v99 = std::string::append(&__dst, ", ");
            v100 = *(_OWORD *)&v99->__r_.__value_.__l.__data_;
            *(_QWORD *)&v207[16] = *((_QWORD *)&v99->__r_.__value_.__l + 2);
            *(_OWORD *)v207 = v100;
            v99->__r_.__value_.__l.__size_ = 0;
            v99->__r_.__value_.__r.__words[2] = 0;
            v99->__r_.__value_.__r.__words[0] = 0;
            if (v207[23] >= 0)
              v101 = v207;
            else
              v101 = *(const std::string::value_type **)v207;
            if (v207[23] >= 0)
              v102 = v207[23];
            else
              v102 = *(_QWORD *)&v207[8];
            std::string::append(a2, v101, v102);
            if ((v207[23] & 0x80000000) != 0)
            {
              operator delete(*(void **)v207);
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                goto LABEL_172;
LABEL_137:
              if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
LABEL_173:
                operator delete(v210.__r_.__value_.__l.__data_);
            }
            else
            {
              if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_137;
LABEL_172:
              operator delete(__dst.__r_.__value_.__l.__data_);
              if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
                goto LABEL_173;
            }
            std::to_string(&v210, __val);
            v103 = std::string::insert(&v210, 0, "vdata._texcoord");
            v104 = *(_OWORD *)&v103->__r_.__value_.__l.__data_;
            __dst.__r_.__value_.__r.__words[2] = v103->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v104;
            v103->__r_.__value_.__l.__size_ = 0;
            v103->__r_.__value_.__r.__words[2] = 0;
            v103->__r_.__value_.__r.__words[0] = 0;
            v105 = std::string::append(&__dst, ".xy);\n");
            v106 = *(_OWORD *)&v105->__r_.__value_.__l.__data_;
            *(_QWORD *)&v207[16] = *((_QWORD *)&v105->__r_.__value_.__l + 2);
            *(_OWORD *)v207 = v106;
            v105->__r_.__value_.__l.__size_ = 0;
            v105->__r_.__value_.__r.__words[2] = 0;
            v105->__r_.__value_.__r.__words[0] = 0;
            if (v207[23] >= 0)
              v107 = v207;
            else
              v107 = *(const std::string::value_type **)v207;
            if (v207[23] >= 0)
              v108 = v207[23];
            else
              v108 = *(_QWORD *)&v207[8];
            std::string::append(a2, v107, v108);
            if ((v207[23] & 0x80000000) != 0)
            {
              operator delete(*(void **)v207);
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                goto LABEL_175;
LABEL_146:
              if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
LABEL_176:
                operator delete(v210.__r_.__value_.__l.__data_);
            }
            else
            {
              if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_146;
LABEL_175:
              operator delete(__dst.__r_.__value_.__l.__data_);
              if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
                goto LABEL_176;
            }
            *(_DWORD *)v207 = 9;
            v207[31] = 18;
            strcpy(&v207[8], "texture2d< float >");
            v208 = xmmword_1B3050DF0;
            v109 = *(_QWORD *)(a3 + 8);
            if (v109 >= *(_QWORD *)(a3 + 16))
            {
              v111 = std::vector<HGBinding>::__push_back_slow_path<HGBinding>((char **)a3, (uint64_t)v207);
              v112 = v207[31];
              *(_QWORD *)(a3 + 8) = v111;
              if (v112 < 0)
              {
                operator delete(*(void **)&v207[8]);
                v111 = *(char **)(a3 + 8);
              }
            }
            else
            {
              *(_DWORD *)v109 = 9;
              v110 = *(_OWORD *)&v207[8];
              *(_QWORD *)(v109 + 24) = *(_QWORD *)&v207[24];
              *(_OWORD *)(v109 + 8) = v110;
              memset(&v207[8], 0, 24);
              *(_OWORD *)(v109 + 32) = v208;
              v111 = (char *)(v109 + 48);
              *(_QWORD *)(a3 + 8) = v109 + 48;
            }
            *(_DWORD *)v207 = 6;
            v207[31] = 7;
            strcpy(&v207[8], "sampler");
            v208 = xmmword_1B3050DF0;
            if ((unint64_t)v111 >= *(_QWORD *)(a3 + 16))
            {
              v114 = std::vector<HGBinding>::__push_back_slow_path<HGBinding>((char **)a3, (uint64_t)v207);
              v115 = v207[31];
              *(_QWORD *)(a3 + 8) = v114;
              if (v115 < 0)
              {
                operator delete(*(void **)&v207[8]);
                if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  goto LABEL_158;
              }
              else if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
                goto LABEL_158;
              }
            }
            else
            {
              *(_DWORD *)v111 = 6;
              v113 = *(_OWORD *)&v207[8];
              *((_QWORD *)v111 + 3) = *(_QWORD *)&v207[24];
              *(_OWORD *)(v111 + 8) = v113;
              memset(&v207[8], 0, 24);
              *((_OWORD *)v111 + 2) = v208;
              *(_QWORD *)(a3 + 8) = v111 + 48;
              if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_158;
            }
            v80 = (void *)v212.__r_.__value_.__r.__words[0];
LABEL_157:
            operator delete(v80);
LABEL_158:
            ++v19;
            ++*a5;
            if (v33)
              goto LABEL_159;
            goto LABEL_7;
          }
          if (v32)
            goto LABEL_158;
          if (v33)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v33 + 16))(v33);
            HGProgramDescriptor::privateEncodeShaderFunction(v33, a2, a3, a4, a5, a6, a7, a8, a9);
            *v17 = *a5;
            (*(void (**)(uint64_t))(*(_QWORD *)v33 + 24))(v33);
            ++v19;
            ++*a5;
LABEL_159:
            (*(void (**)(uint64_t))(*(_QWORD *)v33 + 24))(v33);
            goto LABEL_7;
          }
          ++v19;
          ++*a5;
LABEL_7:
          v18 += 48;
          ++v17;
          if (!--v20)
          {
            v116 = *((_QWORD *)&v224 + 1);
            v117 = *((_QWORD *)&v218 + 1);
            v14 = *((_QWORD *)&v221 + 1);
            v9 = a5;
            goto LABEL_181;
          }
          break;
        case 0xB:
          *v17 = -1;
          *a9 = 1;
          goto LABEL_7;
        default:
          goto LABEL_7;
      }
    }
  }
  v117 = 0;
  v116 = 0;
LABEL_181:
  *(_QWORD *)a6 -= v116;
  *a8 -= v117;
  *a7 -= v14;
  std::to_string((std::string *)v207, *v9);
  v118 = std::string::insert((std::string *)v207, 0, "r");
  v119 = *(_OWORD *)&v118->__r_.__value_.__l.__data_;
  v212.__r_.__value_.__r.__words[2] = v118->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v212.__r_.__value_.__l.__data_ = v119;
  v118->__r_.__value_.__l.__size_ = 0;
  v118->__r_.__value_.__r.__words[2] = 0;
  v118->__r_.__value_.__r.__words[0] = 0;
  if ((v207[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)v207);
    *(_QWORD *)v207 = *v9;
    if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_183;
  }
  else
  {
    *(_QWORD *)v207 = *v9;
    if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_183:
      *(std::string *)&v207[8] = v212;
      goto LABEL_186;
    }
  }
  std::string::__init_copy_ctor_external((std::string *)&v207[8], v212.__r_.__value_.__l.__data_, v212.__r_.__value_.__l.__size_);
LABEL_186:
  std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long const,std::string>>(a4, (unint64_t *)v207, (uint64_t)v207);
  if ((v207[31] & 0x80000000) != 0)
    operator delete(*(void **)&v207[8]);
  *((_BYTE *)&v206.__r_.__value_.__s + 23) = 4;
  strcpy((char *)&v206, "    ");
  v120 = *(char *)(a1 + 215);
  if (v120 >= 0)
    v121 = (const std::string::value_type *)(a1 + 192);
  else
    v121 = *(const std::string::value_type **)(a1 + 192);
  if (v120 >= 0)
    v122 = *(unsigned __int8 *)(a1 + 215);
  else
    v122 = *(_QWORD *)(a1 + 200);
  v123 = std::string::append(&v206, v121, v122);
  v124 = *(_OWORD *)&v123->__r_.__value_.__l.__data_;
  v209.__r_.__value_.__r.__words[2] = v123->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v209.__r_.__value_.__l.__data_ = v124;
  v123->__r_.__value_.__l.__size_ = 0;
  v123->__r_.__value_.__r.__words[2] = 0;
  v123->__r_.__value_.__r.__words[0] = 0;
  v125 = std::string::append(&v209, " ");
  v126 = *(_OWORD *)&v125->__r_.__value_.__l.__data_;
  v210.__r_.__value_.__r.__words[2] = v125->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v210.__r_.__value_.__l.__data_ = v126;
  v125->__r_.__value_.__l.__size_ = 0;
  v125->__r_.__value_.__r.__words[2] = 0;
  v125->__r_.__value_.__r.__words[0] = 0;
  if ((v212.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v127 = &v212;
  else
    v127 = (std::string *)v212.__r_.__value_.__r.__words[0];
  if ((v212.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v128 = HIBYTE(v212.__r_.__value_.__r.__words[2]);
  else
    v128 = v212.__r_.__value_.__l.__size_;
  v129 = std::string::append(&v210, (const std::string::value_type *)v127, v128);
  v130 = *(_OWORD *)&v129->__r_.__value_.__l.__data_;
  __dst.__r_.__value_.__r.__words[2] = v129->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v130;
  v129->__r_.__value_.__l.__size_ = 0;
  v129->__r_.__value_.__r.__words[2] = 0;
  v129->__r_.__value_.__r.__words[0] = 0;
  v131 = std::string::append(&__dst, " = ");
  v132 = *(_OWORD *)&v131->__r_.__value_.__l.__data_;
  *(_QWORD *)&v207[16] = *((_QWORD *)&v131->__r_.__value_.__l + 2);
  *(_OWORD *)v207 = v132;
  v131->__r_.__value_.__l.__size_ = 0;
  v131->__r_.__value_.__r.__words[2] = 0;
  v131->__r_.__value_.__r.__words[0] = 0;
  if (v207[23] >= 0)
    v133 = v207;
  else
    v133 = *(const std::string::value_type **)v207;
  if (v207[23] >= 0)
    v134 = v207[23];
  else
    v134 = *(_QWORD *)&v207[8];
  std::string::append(a2, v133, v134);
  if ((v207[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)v207);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_208:
      if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_209;
      goto LABEL_215;
    }
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_208;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_209:
    if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_210;
    goto LABEL_216;
  }
LABEL_215:
  operator delete(v210.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_210:
    if ((SHIBYTE(v206.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_211;
LABEL_217:
    operator delete(v206.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_212;
    goto LABEL_218;
  }
LABEL_216:
  operator delete(v209.__r_.__value_.__l.__data_);
  if (SHIBYTE(v206.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_217;
LABEL_211:
  if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_212:
    *(std::string *)v207 = v212;
    goto LABEL_219;
  }
LABEL_218:
  std::string::__init_copy_ctor_external((std::string *)v207, v212.__r_.__value_.__l.__data_, v212.__r_.__value_.__l.__size_);
LABEL_219:
  v135 = *(char *)(a1 + 87);
  if (v135 >= 0)
    v136 = *(unsigned __int8 *)(a1 + 87);
  else
    v136 = *(_QWORD *)(a1 + 72);
  v137 = v136 + 1;
  if (v136 + 1 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (v137 >= 0x17)
  {
    v139 = (v137 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v137 | 7) != 0x17)
      v139 = v137 | 7;
    v140 = v139 + 1;
    p_dst = (char *)operator new(v139 + 1);
    __dst.__r_.__value_.__l.__size_ = v136 + 1;
    __dst.__r_.__value_.__r.__words[2] = v140 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = (char *)&__dst;
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v136 + 1;
    if (!v136)
      goto LABEL_233;
  }
  if (v135 >= 0)
    v141 = (const void *)(a1 + 64);
  else
    v141 = *(const void **)(a1 + 64);
  memmove(p_dst, v141, v136);
LABEL_233:
  *(_WORD *)&p_dst[v136] = 40;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v142 = &__dst;
  else
    v142 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v143 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  else
    v143 = __dst.__r_.__value_.__l.__size_;
  std::string::append(a2, (const std::string::value_type *)v142, v143);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = 0;
    __dst.__r_.__value_.__s.__data_[0] = 0;
    v144 = *(_QWORD *)(a1 + 240) - *(_QWORD *)(a1 + 232);
    if (!v144)
      goto LABEL_323;
LABEL_243:
    v145 = 0;
    v146 = 0;
    v147 = 0;
    v148 = v144 / 48;
    if (v148 <= 1)
      v149 = 1;
    else
      v149 = v148;
    v150 = "vdata._color";
    while (2)
    {
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v152 = &__dst;
      else
        v152 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v153 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      else
        v153 = __dst.__r_.__value_.__l.__size_;
      std::string::append(a2, (const std::string::value_type *)v152, v153);
      MEMORY[0x1B5E28D80](&__dst, ", ");
      v154 = *(_QWORD *)(a1 + 232);
      v151 = v150;
      switch(*(_DWORD *)(v154 + v145))
      {
        case 2:
          v155 = v154 + v145;
          v156 = *(_DWORD *)(v154 + v145 + 36);
          if (!*(_DWORD *)(v155 + 40))
          {
            if (((v156 - 1) & 0xFFFFFFFD) != 0)
              v151 = "0";
            else
              v151 = "0x0";
            goto LABEL_248;
          }
          v157 = v156 == 4 || v156 == 2;
          if (v157)
          {
            std::operator+<char>();
            if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v158 = &v210;
            else
              v158 = (std::string *)v210.__r_.__value_.__r.__words[0];
            if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v159 = HIBYTE(v210.__r_.__value_.__r.__words[2]);
            else
              v159 = v210.__r_.__value_.__l.__size_;
          }
          else
          {
            std::operator+<char>();
            if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v158 = &v210;
            else
              v158 = (std::string *)v210.__r_.__value_.__r.__words[0];
            if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v159 = HIBYTE(v210.__r_.__value_.__r.__words[2]);
            else
              v159 = v210.__r_.__value_.__l.__size_;
          }
          std::string::append(a2, (const std::string::value_type *)v158, v159);
          if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v210.__r_.__value_.__l.__data_);
          v151 = "[0]";
          if (*(_DWORD *)(v155 + 40) > 1u)
            goto LABEL_248;
          goto LABEL_249;
        case 5:
          v151 = "vdata._position";
          goto LABEL_248;
        case 6:
          std::to_string(&v209, *((_QWORD *)__p + v147));
          v175 = std::string::insert(&v209, 0, "sampler");
          v176 = *(_OWORD *)&v175->__r_.__value_.__l.__data_;
          v210.__r_.__value_.__r.__words[2] = v175->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v210.__r_.__value_.__l.__data_ = v176;
          v175->__r_.__value_.__l.__size_ = 0;
          v175->__r_.__value_.__r.__words[2] = 0;
          v175->__r_.__value_.__r.__words[0] = 0;
          if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v177 = &v210;
          else
            v177 = (std::string *)v210.__r_.__value_.__r.__words[0];
          if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v178 = HIBYTE(v210.__r_.__value_.__r.__words[2]);
          else
            v178 = v210.__r_.__value_.__l.__size_;
          goto LABEL_303;
        case 8:
          std::to_string(&v209, *((_QWORD *)__p + v147));
          v179 = std::string::insert(&v209, 0, "vdata._texcoord");
          v180 = *(_OWORD *)&v179->__r_.__value_.__l.__data_;
          v210.__r_.__value_.__r.__words[2] = v179->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v210.__r_.__value_.__l.__data_ = v180;
          v179->__r_.__value_.__l.__size_ = 0;
          v179->__r_.__value_.__r.__words[2] = 0;
          v179->__r_.__value_.__r.__words[0] = 0;
          if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v177 = &v210;
          else
            v177 = (std::string *)v210.__r_.__value_.__r.__words[0];
          if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v178 = HIBYTE(v210.__r_.__value_.__r.__words[2]);
          else
            v178 = v210.__r_.__value_.__l.__size_;
LABEL_303:
          std::string::append(a2, (const std::string::value_type *)v177, v178);
          if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v210.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_249;
          }
          else if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_249;
          }
          operator delete(v209.__r_.__value_.__l.__data_);
          goto LABEL_249;
        case 9:
          std::to_string(&v209, *((_QWORD *)__p + v147));
          v160 = std::string::insert(&v209, 0, "texture");
          v161 = *(_OWORD *)&v160->__r_.__value_.__l.__data_;
          v210.__r_.__value_.__r.__words[2] = v160->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v210.__r_.__value_.__l.__data_ = v161;
          v160->__r_.__value_.__l.__size_ = 0;
          v160->__r_.__value_.__r.__words[2] = 0;
          v160->__r_.__value_.__r.__words[0] = 0;
          if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v162 = &v210;
          else
            v162 = (std::string *)v210.__r_.__value_.__r.__words[0];
          if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v163 = HIBYTE(v210.__r_.__value_.__r.__words[2]);
          else
            v163 = v210.__r_.__value_.__l.__size_;
          std::string::append(a2, (const std::string::value_type *)v162, v163);
          if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v210.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_277;
          }
          else if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_277;
          }
          operator delete(v209.__r_.__value_.__l.__data_);
LABEL_277:
          ++v146;
LABEL_249:
          ++v147;
          v145 += 48;
          if (v149 != v147)
            continue;
          goto LABEL_323;
        case 0xA:
          v209.__r_.__value_.__r.__words[0] = 0;
          v209.__r_.__value_.__r.__words[0] = *((_QWORD *)__p + v147);
          v210.__r_.__value_.__r.__words[0] = (std::string::size_type)&v209;
          v164 = std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(a4, (unint64_t *)&v209, (uint64_t)&std::piecewise_construct, (uint64_t **)&v210);
          v167 = (const std::string::value_type *)v164[3];
          v165 = (const std::string::value_type *)(v164 + 3);
          v166 = v167;
          v168 = v165[23];
          if (v168 >= 0)
            v169 = v165;
          else
            v169 = v166;
          if (v168 >= 0)
            v170 = *((unsigned __int8 *)v165 + 23);
          else
            v170 = *((_QWORD *)v165 + 1);
          std::string::append(a2, v169, v170);
          v171 = *(_QWORD *)(a1 + 112) + 16 * v146;
          v172 = *(_DWORD **)(v171 + 8);
          if (v172)
          {
            v173 = v150;
            v174 = *(_DWORD *)v171;
            (*(void (**)(_DWORD *))(*(_QWORD *)v172 + 16))(v172);
            if (!v174)
            {
              (*(void (**)(_DWORD *))(*(_QWORD *)v172 + 16))(v172);
              if (v172[46] == 4)
                std::string::append(a2, ".color0");
              (*(void (**)(_DWORD *))(*(_QWORD *)v172 + 24))(v172);
            }
            (*(void (**)(_DWORD *))(*(_QWORD *)v172 + 24))(v172);
            v150 = v173;
          }
          ++v146;
          goto LABEL_249;
        case 0xB:
LABEL_248:
          std::string::append(a2, v151);
          goto LABEL_249;
        default:
          goto LABEL_249;
      }
    }
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = 0;
  __dst.__r_.__value_.__s.__data_[0] = 0;
  v144 = *(_QWORD *)(a1 + 240) - *(_QWORD *)(a1 + 232);
  if (v144)
    goto LABEL_243;
LABEL_323:
  std::string::append(a2, ");\n");
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    if ((v207[23] & 0x80000000) == 0)
    {
LABEL_325:
      if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_326;
      goto LABEL_335;
    }
  }
  else if ((v207[23] & 0x80000000) == 0)
  {
    goto LABEL_325;
  }
  operator delete(*(void **)v207);
  if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_326:
    v181 = __p;
    if (!__p)
      goto LABEL_328;
    goto LABEL_327;
  }
LABEL_335:
  operator delete(v212.__r_.__value_.__l.__data_);
  v181 = __p;
  if (__p)
LABEL_327:
    operator delete(v181);
LABEL_328:
  v182 = (void **)*((_QWORD *)&v216 + 1);
  v183 = (void **)v217;
  *((_QWORD *)&v218 + 1) = 0;
  v184 = v217 - *((_QWORD *)&v216 + 1);
  if ((_QWORD)v217 - *((_QWORD *)&v216 + 1) >= 0x11uLL)
  {
    do
    {
      operator delete(*v182);
      v183 = (void **)v217;
      v182 = (void **)(*((_QWORD *)&v216 + 1) + 8);
      *((_QWORD *)&v216 + 1) = v182;
      v184 = v217 - (_QWORD)v182;
    }
    while ((_QWORD)v217 - (_QWORD)v182 > 0x10uLL);
  }
  v185 = v184 >> 3;
  if (v185 == 1)
  {
    v186 = 256;
    goto LABEL_338;
  }
  if (v185 == 2)
  {
    v186 = 512;
LABEL_338:
    *(_QWORD *)&v218 = v186;
  }
  if (v182 != v183)
  {
    do
    {
      v187 = *v182++;
      operator delete(v187);
    }
    while (v182 != v183);
    if ((_QWORD)v217 != *((_QWORD *)&v216 + 1))
      *(_QWORD *)&v217 = v217 + ((*((_QWORD *)&v216 + 1) - v217 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if ((_QWORD)v216)
    operator delete((void *)v216);
  v188 = (void **)*((_QWORD *)&v219 + 1);
  v189 = (void **)v220;
  *((_QWORD *)&v221 + 1) = 0;
  v190 = v220 - *((_QWORD *)&v219 + 1);
  if ((_QWORD)v220 - *((_QWORD *)&v219 + 1) >= 0x11uLL)
  {
    do
    {
      operator delete(*v188);
      v189 = (void **)v220;
      v188 = (void **)(*((_QWORD *)&v219 + 1) + 8);
      *((_QWORD *)&v219 + 1) = v188;
      v190 = v220 - (_QWORD)v188;
    }
    while ((_QWORD)v220 - (_QWORD)v188 > 0x10uLL);
  }
  v191 = v190 >> 3;
  if (v191 == 1)
  {
    v192 = 256;
    goto LABEL_351;
  }
  if (v191 == 2)
  {
    v192 = 512;
LABEL_351:
    *(_QWORD *)&v221 = v192;
  }
  if (v188 != v189)
  {
    do
    {
      v193 = *v188++;
      operator delete(v193);
    }
    while (v188 != v189);
    if ((_QWORD)v220 != *((_QWORD *)&v219 + 1))
      *(_QWORD *)&v220 = v220 + ((*((_QWORD *)&v219 + 1) - v220 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if ((_QWORD)v219)
    operator delete((void *)v219);
  v194 = (void **)*((_QWORD *)&v222 + 1);
  v195 = (void **)v223;
  *((_QWORD *)&v224 + 1) = 0;
  v196 = v223 - *((_QWORD *)&v222 + 1);
  if ((_QWORD)v223 - *((_QWORD *)&v222 + 1) >= 0x11uLL)
  {
    do
    {
      operator delete(*v194);
      v195 = (void **)v223;
      v194 = (void **)(*((_QWORD *)&v222 + 1) + 8);
      *((_QWORD *)&v222 + 1) = v194;
      v196 = v223 - (_QWORD)v194;
    }
    while ((_QWORD)v223 - (_QWORD)v194 > 0x10uLL);
  }
  v197 = v196 >> 3;
  if (v197 == 1)
  {
    v198 = 256;
    goto LABEL_364;
  }
  if (v197 == 2)
  {
    v198 = 512;
LABEL_364:
    *(_QWORD *)&v224 = v198;
  }
  if (v194 != v195)
  {
    do
    {
      v199 = *v194++;
      operator delete(v199);
    }
    while (v194 != v195);
    if ((_QWORD)v223 != *((_QWORD *)&v222 + 1))
      *(_QWORD *)&v223 = v223 + ((*((_QWORD *)&v222 + 1) - v223 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if ((_QWORD)v222)
    operator delete((void *)v222);
}

void sub_1B2A2BD0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50,void *a51)
{
  uint64_t v51;
  uint64_t v52;

  if (a50 < 0)
    operator delete(__p);
  if (v51)
    (*(void (**)(uint64_t))(*(_QWORD *)v51 + 24))(v51);
  if (a51)
    operator delete(a51);
  std::deque<unsigned long>::~deque[abi:ne180100]((_QWORD *)(v52 - 240));
  std::deque<unsigned long>::~deque[abi:ne180100]((_QWORD *)(v52 - 192));
  std::deque<unsigned long>::~deque[abi:ne180100]((_QWORD *)(v52 - 144));
  _Unwind_Resume(a1);
}

const char *HGProgramDescriptor::GetFragmentFunctionName(HGProgramDescriptor *this)
{
  if (*((char *)this + 63) < 0)
  {
    if (*((_QWORD *)this + 6))
      return (const char *)*((_QWORD *)this + 5);
    else
      return "fragmentFunc";
  }
  else if (*((_BYTE *)this + 63))
  {
    return (char *)this + 40;
  }
  else
  {
    return "fragmentFunc";
  }
}

uint64_t std::unordered_map<unsigned long,std::string>::~unordered_map[abi:ne180100](uint64_t a1)
{
  void **v2;
  void *v3;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      v5 = (void **)*v2;
      if (*((char *)v2 + 47) < 0)
        operator delete(v2[3]);
      operator delete(v2);
      v2 = v5;
    }
    while (v5);
  }
  v3 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v3)
    operator delete(v3);
  return a1;
}

void **std::vector<HGBinding>::~vector[abi:ne180100](void **a1)
{
  void **v2;
  void **v3;
  void *v4;

  v2 = (void **)*a1;
  if (*a1)
  {
    v3 = (void **)a1[1];
    v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((char *)v3 - 17) < 0)
          operator delete(*(v3 - 5));
        v3 -= 6;
      }
      while (v3 != v2);
      v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void HGProgramDescriptor::EncodeShaderProgram(uint64_t a1, std::string *this, char *a3)
{
  uint64_t v5;
  int v6;
  BOOL v7;
  std::string::size_type v8;
  void **v9;
  void *v10;
  void **v11;
  char v12;
  const std::string::value_type *v13;
  std::string::size_type v14;
  _QWORD *v15;
  void *__p[2];
  void *v17[2];
  int v18;

  if (*(char *)(a1 + 87) < 0)
  {
    v5 = *(_QWORD *)(a1 + 72);
    v6 = *(char *)(a1 + 111);
    if ((v6 & 0x80000000) == 0)
    {
LABEL_3:
      if ((_BYTE)v6)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else
  {
    v5 = *(unsigned __int8 *)(a1 + 87);
    v6 = *(char *)(a1 + 111);
    if ((v6 & 0x80000000) == 0)
      goto LABEL_3;
  }
  if (*(_QWORD *)(a1 + 96))
  {
LABEL_4:
    v7 = 1;
    if (!v5)
      goto LABEL_23;
    goto LABEL_12;
  }
LABEL_8:
  if (*(char *)(a1 + 183) < 0)
  {
    v7 = *(_QWORD *)(a1 + 168) != 0;
    if (!v5)
      goto LABEL_23;
  }
  else
  {
    v7 = *(_BYTE *)(a1 + 183) != 0;
    if (!v5)
      goto LABEL_23;
  }
LABEL_12:
  if (v7)
  {
    if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v8 = 2070;
    else
      v8 = (this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) + 2047;
    std::string::reserve(this, v8);
    *(_OWORD *)__p = 0u;
    *(_OWORD *)v17 = 0u;
    v18 = 1065353216;
    HGProgramDescriptor::privateEncodeShaderProgram((uint64_t *)a1, this, (uint64_t)__p);
    v9 = (void **)v17[0];
    if (v17[0])
    {
      do
      {
        v11 = (void **)*v9;
        if (*((char *)v9 + 39) < 0)
          operator delete(v9[2]);
        operator delete(v9);
        v9 = v11;
      }
      while (v11);
    }
    v10 = __p[0];
    __p[0] = 0;
    if (v10)
      operator delete(v10);
    return;
  }
LABEL_23:
  v12 = *(_BYTE *)(a1 + 159);
  if (v12 < 0)
  {
    if (*(_QWORD *)(a1 + 144))
      goto LABEL_25;
  }
  else if (*(_BYTE *)(a1 + 159))
  {
LABEL_25:
    if (v12 >= 0)
      v13 = (const std::string::value_type *)(a1 + 136);
    else
      v13 = *(const std::string::value_type **)(a1 + 136);
    if (v12 >= 0)
      v14 = *(unsigned __int8 *)(a1 + 159);
    else
      v14 = *(_QWORD *)(a1 + 144);
    std::string::append(this, v13, v14);
    return;
  }
  v15 = (_QWORD *)(a1 + 40);
  if (*(char *)(a1 + 63) < 0)
    v15 = (_QWORD *)*v15;
  HGLogger::warning((HGLogger *)"Missing fragment shader for %s\n", (const char *)this, a3, v15);
}

void sub_1B2A2C4B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::unordered_map<std::string,BOOL>::~unordered_map[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *HGProgramDescriptor::privateEncodeShaderProgram(uint64_t *result, std::string *a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  size_t v11;
  unint64_t v12;
  char *p_p;
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  const std::string::value_type *v17;
  std::string::size_type v18;
  void *__p;
  std::string::size_type v20;
  int64_t v21;

  v5 = result;
  v6 = result[14];
  v7 = result[15];
  while (v6 != v7)
  {
    v8 = *(_QWORD *)(v6 + 8);
    if (v8)
    {
      v9 = *(_DWORD *)v6;
      (*(void (**)(_QWORD))(*(_QWORD *)v8 + 16))(*(_QWORD *)(v6 + 8));
      if (!v9)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
        HGProgramDescriptor::privateEncodeShaderProgram(v8, a2, a3);
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
      }
      result = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
    }
    v6 += 16;
  }
  if (*((char *)v5 + 183) < 0)
  {
    if (!v5[21])
      return result;
  }
  else if (!*((_BYTE *)v5 + 183))
  {
    return result;
  }
  __p = v5 + 8;
  result = std::__hash_table<std::__hash_value_type<std::string,BOOL>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,BOOL>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,BOOL>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,BOOL>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a3, (uint64_t)(v5 + 8), (uint64_t)&std::piecewise_construct, (__int128 **)&__p);
  if (!*((_BYTE *)result + 40))
  {
    v10 = *((char *)v5 + 183);
    if (v10 >= 0)
      v11 = *((unsigned __int8 *)v5 + 183);
    else
      v11 = v5[21];
    v12 = v11 + 1;
    if (v11 + 1 >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    if (v12 >= 0x17)
    {
      v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v12 | 7) != 0x17)
        v14 = v12 | 7;
      v15 = v14 + 1;
      p_p = (char *)operator new(v14 + 1);
      v20 = v11 + 1;
      v21 = v15 | 0x8000000000000000;
      __p = p_p;
    }
    else
    {
      v20 = 0;
      v21 = 0;
      __p = 0;
      p_p = (char *)&__p;
      HIBYTE(v21) = v11 + 1;
      if (!v11)
      {
LABEL_27:
        *(_WORD *)&p_p[v11] = 10;
        if (v21 >= 0)
          v17 = (const std::string::value_type *)&__p;
        else
          v17 = (const std::string::value_type *)__p;
        if (v21 >= 0)
          v18 = HIBYTE(v21);
        else
          v18 = v20;
        std::string::append(a2, v17, v18);
        if (SHIBYTE(v21) < 0)
          operator delete(__p);
        __p = v5 + 8;
        result = std::__hash_table<std::__hash_value_type<std::string,BOOL>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,BOOL>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,BOOL>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,BOOL>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a3, (uint64_t)(v5 + 8), (uint64_t)&std::piecewise_construct, (__int128 **)&__p);
        *((_BYTE *)result + 40) = 1;
        return result;
      }
    }
    if (v10 >= 0)
      v16 = v5 + 20;
    else
      v16 = (const void *)v5[20];
    memmove(p_p, v16, v11);
    goto LABEL_27;
  }
  return result;
}

void sub_1B2A2C6D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::unordered_map<std::string,BOOL>::~unordered_map[abi:ne180100](uint64_t a1)
{
  void **v2;
  void *v3;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      v5 = (void **)*v2;
      if (*((char *)v2 + 39) < 0)
        operator delete(v2[2]);
      operator delete(v2);
      v2 = v5;
    }
    while (v5);
  }
  v3 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v3)
    operator delete(v3);
  return a1;
}

_QWORD *HGProgramDescriptor::CopyDependencies(HGProgramDescriptor *this)
{
  _QWORD *v2;
  void **v3;
  void *v4;
  void **v6;
  void *__p[2];
  void *v8[2];
  int v9;

  *(_OWORD *)__p = 0u;
  *(_OWORD *)v8 = 0u;
  v9 = 1065353216;
  v2 = (_QWORD *)operator new();
  *v2 = 0;
  v2[1] = 0;
  v2[2] = 0;
  HGProgramDescriptor::privateGetDependencies((uint64_t *)this, (uint64_t)v2, (uint64_t)__p);
  v3 = (void **)v8[0];
  if (v8[0])
  {
    do
    {
      v6 = (void **)*v3;
      if (*((char *)v3 + 39) < 0)
        operator delete(v3[2]);
      operator delete(v3);
      v3 = v6;
    }
    while (v6);
  }
  v4 = __p[0];
  __p[0] = 0;
  if (v4)
    operator delete(v4);
  return v2;
}

void sub_1B2A2C850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unordered_map<std::string,BOOL>::~unordered_map[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t *HGProgramDescriptor::privateGetDependencies(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  std::string::size_type v11;
  char *v12;
  int v13;
  std::string v14;
  std::string __p;

  v5 = result;
  v6 = result[14];
  v7 = result[15];
  while (v6 != v7)
  {
    if (!*(_DWORD *)v6)
    {
      v8 = *(_QWORD *)(v6 + 8);
      if (v8)
      {
        (*(void (**)(_QWORD))(*(_QWORD *)v8 + 16))(*(_QWORD *)(v6 + 8));
        HGProgramDescriptor::privateGetDependencies(v8, a2, a3);
        result = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
      }
    }
    v6 += 16;
  }
  if (*((char *)v5 + 87) < 0)
  {
    if (!v5[9])
      return result;
  }
  else if (!*((_BYTE *)v5 + 87))
  {
    return result;
  }
  v14.__r_.__value_.__r.__words[0] = (std::string::size_type)(v5 + 8);
  result = std::__hash_table<std::__hash_value_type<std::string,BOOL>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,BOOL>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,BOOL>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,BOOL>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a3, (uint64_t)(v5 + 8), (uint64_t)&std::piecewise_construct, (__int128 **)&v14);
  if (!*((_BYTE *)result + 40))
  {
    if (*((char *)v5 + 111) < 0)
    {
      std::string::__init_copy_ctor_external(&v14, (const std::string::value_type *)v5[11], v5[12]);
      if ((*((char *)v5 + 87) & 0x80000000) == 0)
        goto LABEL_14;
    }
    else
    {
      v14 = *(std::string *)(v5 + 11);
      if ((*((char *)v5 + 87) & 0x80000000) == 0)
      {
LABEL_14:
        __p = *(std::string *)(v5 + 8);
LABEL_17:
        v9 = *(_QWORD *)(a2 + 8);
        if (v9 >= *(_QWORD *)(a2 + 16))
        {
          v12 = std::vector<HGProgramDescriptor::Dependency>::__push_back_slow_path<HGProgramDescriptor::Dependency>((void **)a2, (uint64_t)&v14);
          v13 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
          *(_QWORD *)(a2 + 8) = v12;
          if (v13 < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
        }
        else
        {
          v10 = *(_OWORD *)&v14.__r_.__value_.__l.__data_;
          *(_QWORD *)(v9 + 16) = *((_QWORD *)&v14.__r_.__value_.__l + 2);
          *(_OWORD *)v9 = v10;
          memset(&v14, 0, sizeof(v14));
          v11 = __p.__r_.__value_.__r.__words[2];
          *(_OWORD *)(v9 + 24) = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *(_QWORD *)(v9 + 40) = v11;
          memset(&__p, 0, sizeof(__p));
          *(_QWORD *)(a2 + 8) = v9 + 48;
        }
        if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v14.__r_.__value_.__l.__data_);
        v14.__r_.__value_.__r.__words[0] = (std::string::size_type)(v5 + 8);
        result = std::__hash_table<std::__hash_value_type<std::string,BOOL>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,BOOL>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,BOOL>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,BOOL>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a3, (uint64_t)(v5 + 8), (uint64_t)&std::piecewise_construct, (__int128 **)&v14);
        *((_BYTE *)result + 40) = 1;
        return result;
      }
    }
    std::string::__init_copy_ctor_external(&__p, (const std::string::value_type *)v5[8], v5[9]);
    goto LABEL_17;
  }
  return result;
}

void sub_1B2A2CA5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void HGProgramDescriptor::Dependency::~Dependency(void **this)
{
  if ((*((char *)this + 47) & 0x80000000) == 0)
  {
    if ((*((char *)this + 23) & 0x80000000) == 0)
      return;
LABEL_5:
    operator delete(*this);
    return;
  }
  operator delete(this[3]);
  if (*((char *)this + 23) < 0)
    goto LABEL_5;
}

uint64_t HGProgramDescriptor::GetSignature@<X0>(HGProgramDescriptor *this@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 20) = 0u;
  *(_OWORD *)(a2 + 4) = 0u;
  *(_DWORD *)a2 = 396048;
  *(_BYTE *)(a2 + 42) = 1;
  return HGProgramDescriptor::privateGetSignature((uint64_t)this, (HGLimits *)a2);
}

uint64_t HGProgramDescriptor::privateGetSignature(uint64_t this, HGLimits *a2)
{
  _QWORD *v3;
  int *v4;
  int *v5;
  int v6;
  HGProgramDescriptor *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  _DWORD *v16;
  _DWORD *v17;

  v3 = (_QWORD *)this;
  v4 = *(int **)(this + 112);
  v5 = *(int **)(this + 120);
  while (v4 != v5)
  {
    v6 = *v4;
    v7 = (HGProgramDescriptor *)*((_QWORD *)v4 + 1);
    if (v7)
      this = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v7 + 16))(*((_QWORD *)v4 + 1));
    if (v6 == 1)
    {
      ++*((_WORD *)a2 + 18);
      ++*((_BYTE *)a2 + 40);
LABEL_3:
      if (!v7)
        goto LABEL_5;
LABEL_4:
      this = (*(uint64_t (**)(HGProgramDescriptor *))(*(_QWORD *)v7 + 24))(v7);
      goto LABEL_5;
    }
    if (v6)
      goto LABEL_3;
    if (v7)
    {
      (*(void (**)(HGProgramDescriptor *))(*(_QWORD *)v7 + 16))(v7);
      HGProgramDescriptor::privateGetSignature(v7, a2);
      (*(void (**)(HGProgramDescriptor *))(*(_QWORD *)v7 + 24))(v7);
      goto LABEL_4;
    }
LABEL_5:
    v4 += 4;
  }
  v8 = v3[29];
  v9 = v3[30];
  if (v8 == v9)
  {
    v15 = *((_DWORD *)a2 + 11);
  }
  else
  {
    v10 = 0;
    v11 = *((unsigned __int16 *)a2 + 18);
    v12 = *((_DWORD *)a2 + 3);
    v13 = *((unsigned __int16 *)a2 + 16);
    v14 = *((unsigned __int16 *)a2 + 11);
    v15 = *((_DWORD *)a2 + 11);
    this = *((unsigned __int8 *)a2 + 40);
    do
    {
      switch(*(_DWORD *)v8)
      {
        case 2:
          v14 += *(unsigned __int16 *)(v8 + 40);
          *((_WORD *)a2 + 11) = v14;
          v15 += *(_DWORD *)(v8 + 44);
          *((_DWORD *)a2 + 11) = v15;
          break;
        case 3:
          *((_BYTE *)a2 + 41) = 1;
          break;
        case 7:
          v16 = (_DWORD *)v3[32];
          v17 = (_DWORD *)v3[33];
          while (v16 != v17)
          {
            if (*v16 == 8)
              *((_WORD *)a2 + 18) = ++v11;
            v16 += 12;
          }
          break;
        case 8:
          *((_WORD *)a2 + 18) = ++v11;
          break;
        case 9:
          this = (this + 1);
          *((_BYTE *)a2 + 40) = this;
          ++v10;
          break;
        case 0xA:
          v12 |= 1 << v10;
          *((_DWORD *)a2 + 3) = v12;
          ++v10;
          break;
        case 0xB:
          v13 |= 0x200u;
          *((_WORD *)a2 + 16) = v13;
          break;
        default:
          break;
      }
      v8 += 48;
    }
    while (v8 != v9);
  }
  *((_DWORD *)a2 + 11) = (v15 + 15) & 0xFFFFFFF0;
  return this;
}

void sub_1B2A2CD00(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void HGProgramDescriptor::SetFragmentFunctionName(HGProgramDescriptor *this, const char *a2)
{
  JUMPOUT(0x1B5E28D80);
}

void HGProgramDescriptor::SetVertexFunctionName(HGProgramDescriptor *this, const char *a2)
{
  JUMPOUT(0x1B5E28D80);
}

uint64_t HGProgramDescriptor::GetMetalLibPath(HGProgramDescriptor *this)
{
  uint64_t result;

  result = (uint64_t)this + 88;
  if (*((char *)this + 111) < 0)
    return *(_QWORD *)result;
  return result;
}

uint64_t HGProgramDescriptor::GetVertexFunctionName(HGProgramDescriptor *this)
{
  uint64_t result;

  result = (uint64_t)this + 16;
  if (*((char *)this + 39) < 0)
    return *(_QWORD *)result;
  return result;
}

unint64_t HGProgramDescriptor::GetHash(HGProgramDescriptor *this, const char *a2, char *a3)
{
  int v4;
  uint64_t v5;
  int v6;
  BOOL v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  HGProgramDescriptor *v14;
  std::string *v15;
  __int128 v16;
  uint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t v22;
  std::string *v23;
  __int128 v24;
  uint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t *v29;
  int64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  _BYTE *v35;
  unint64_t *v36;
  uint64_t v37;
  std::string *v38;
  __int128 v39;
  uint64_t *v40;
  unint64_t v41;
  int64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  std::string *v46;
  __int128 v47;
  uint64_t *v48;
  unint64_t v49;
  int64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  char *v54;
  int64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  char *v60;
  unint64_t *v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t *v65;
  _OWORD *v66;
  unint64_t *v67;
  uint64_t v68;
  __int128 v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t *v74;
  _OWORD *v75;
  unint64_t *v76;
  uint64_t v77;
  __int128 v78;
  unint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unint64_t *v83;
  _OWORD *v84;
  unint64_t *v85;
  uint64_t v86;
  __int128 v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  char *v93;
  char *v94;
  uint64_t v95;
  __int128 v96;
  unint64_t v97;
  uint64_t Hash;
  uint64_t v99;
  char *v100;
  char *v101;
  int64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  char *v107;
  uint64_t *v108;
  unint64_t v109;
  uint64_t v110;
  uint64_t v111;
  char *v112;
  char *v113;
  char *v114;
  uint64_t v115;
  __int128 v116;
  uint64_t v117;
  char v118;
  uint64_t *v119;
  unint64_t v120;
  unint64_t v121;
  uint64_t *v122;
  unint64_t v123;
  unint64_t v124;
  unint64_t *v125;
  unint64_t *v126;
  int64_t v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  _BYTE *v132;
  unint64_t *v133;
  char *v134;
  uint64_t v135;
  int64_t v136;
  _QWORD *v137;
  char v138;
  unint64_t v139;
  uint64_t *v140;
  unint64_t v141;
  unint64_t v142;
  unint64_t v143;
  char *v144;
  char *v145;
  char *v146;
  char *v147;
  int64_t v148;
  uint64_t v149;
  unint64_t v150;
  uint64_t v151;
  unint64_t v152;
  char *v153;
  unint64_t *v154;
  char *v155;
  int64_t v156;
  uint64_t *v157;
  unint64_t v158;
  int64_t v159;
  uint64_t v160;
  unint64_t v161;
  uint64_t v162;
  unint64_t v163;
  _BYTE *v164;
  int64_t v165;
  unint64_t v166;
  uint64_t v167;
  uint64_t v168;
  unint64_t *v169;
  _OWORD *v170;
  unint64_t *v171;
  uint64_t v172;
  __int128 v173;
  unint64_t v174;
  unint64_t v175;
  uint64_t v176;
  uint64_t v177;
  char *v178;
  char *v179;
  char *v180;
  uint64_t v181;
  __int128 v182;
  unint64_t v183;
  char *v184;
  uint64_t v185;
  unint64_t v187;
  uint64_t v188;
  uint64_t v189;
  unint64_t *v190;
  _OWORD *v191;
  unint64_t *v192;
  uint64_t v193;
  __int128 v194;
  unint64_t v195;
  uint64_t v196;
  std::string v197;
  void *__p[2];
  int64_t v199;
  void *v200;
  char *v201;
  char *v202;
  char v203;

  v4 = *((char *)this + 87);
  if (v4 < 0)
  {
    v5 = *((_QWORD *)this + 9);
    v6 = *((char *)this + 111);
    if ((v6 & 0x80000000) == 0)
    {
LABEL_3:
      if ((_BYTE)v6)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else
  {
    v5 = *((unsigned __int8 *)this + 87);
    v6 = *((char *)this + 111);
    if ((v6 & 0x80000000) == 0)
      goto LABEL_3;
  }
  if (*((_QWORD *)this + 12))
  {
LABEL_4:
    v7 = 1;
    if (!v5)
      goto LABEL_162;
LABEL_12:
    if (!v7)
      goto LABEL_162;
    v200 = 0;
    v201 = 0;
    v202 = 0;
    v8 = *((_QWORD *)this + 15) - *((_QWORD *)this + 14);
    if (v8)
    {
      v9 = 0;
      if ((unint64_t)(v8 >> 4) <= 1)
        v10 = 1;
      else
        v10 = v8 >> 4;
      v196 = v10;
      while (2)
      {
        v12 = *((_QWORD *)this + 14) + 16 * v9;
        v13 = *(_DWORD *)v12;
        v14 = *(HGProgramDescriptor **)(v12 + 8);
        if (v14)
          (*(void (**)(HGProgramDescriptor *))(*(_QWORD *)v14 + 16))(v14);
        switch(v13)
        {
          case 0:
            if (!v14)
              goto LABEL_21;
            (*(void (**)(HGProgramDescriptor *))(*(_QWORD *)v14 + 16))(v14);
            std::to_string(&v197, v9);
            v15 = std::string::insert(&v197, 0, "Pointer");
            v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
            v199 = v15->__r_.__value_.__r.__words[2];
            *(_OWORD *)__p = v16;
            v15->__r_.__value_.__l.__size_ = 0;
            v15->__r_.__value_.__r.__words[2] = 0;
            v15->__r_.__value_.__r.__words[0] = 0;
            if (v199 >= 0)
              v17 = (uint64_t *)__p;
            else
              v17 = (uint64_t *)__p[0];
            if (v199 >= 0)
              v18 = HIBYTE(v199);
            else
              v18 = (unint64_t)__p[1];
            v19 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v203, v17, v18);
            v20 = v19;
            v21 = v201;
            if (v201 < v202)
            {
              *(_QWORD *)v201 = v19;
              v22 = (uint64_t)(v21 + 8);
              goto LABEL_138;
            }
            v54 = (char *)v200;
            v55 = v201 - (_BYTE *)v200;
            v56 = (v201 - (_BYTE *)v200) >> 3;
            v57 = v56 + 1;
            if ((unint64_t)(v56 + 1) >> 61)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v58 = v202 - (_BYTE *)v200;
            if ((v202 - (_BYTE *)v200) >> 2 > v57)
              v57 = v58 >> 2;
            if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8)
              v59 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v59 = v57;
            if (v59)
            {
              if (v59 >> 61)
                std::__throw_bad_array_new_length[abi:ne180100]();
              v60 = (char *)operator new(8 * v59);
              v61 = (unint64_t *)&v60[8 * v56];
              *v61 = v20;
              v22 = (uint64_t)(v61 + 1);
              if (v21 == v54)
                goto LABEL_136;
            }
            else
            {
              v60 = 0;
              v61 = (unint64_t *)(8 * v56);
              *(_QWORD *)(8 * v56) = v20;
              v22 = 8 * v56 + 8;
              if (v21 == v54)
              {
LABEL_136:
                v200 = v61;
                v201 = (char *)v22;
                v202 = &v60[8 * v59];
                if (v54)
                  operator delete(v54);
LABEL_138:
                v201 = (char *)v22;
                if (SHIBYTE(v199) < 0)
                {
                  operator delete(__p[0]);
                  if ((SHIBYTE(v197.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                    goto LABEL_140;
                }
                else if ((SHIBYTE(v197.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                {
                  goto LABEL_140;
                }
                operator delete(v197.__r_.__value_.__l.__data_);
LABEL_140:
                Hash = HGProgramDescriptor::GetHash(v14);
                v99 = Hash;
                v100 = v201;
                if (v201 < v202)
                {
                  *(_QWORD *)v201 = Hash;
                  v11 = (uint64_t)(v100 + 8);
LABEL_19:
                  v10 = v196;
                  v201 = (char *)v11;
                  (*(void (**)(HGProgramDescriptor *))(*(_QWORD *)v14 + 24))(v14);
                  goto LABEL_20;
                }
                v101 = (char *)v200;
                v102 = v201 - (_BYTE *)v200;
                v103 = (v201 - (_BYTE *)v200) >> 3;
                v104 = v103 + 1;
                if ((unint64_t)(v103 + 1) >> 61)
                  std::vector<double>::__throw_length_error[abi:ne180100]();
                v105 = v202 - (_BYTE *)v200;
                if ((v202 - (_BYTE *)v200) >> 2 > v104)
                  v104 = v105 >> 2;
                if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFF8)
                  v106 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v106 = v104;
                if (v106)
                {
                  if (v106 >> 61)
                    std::__throw_bad_array_new_length[abi:ne180100]();
                  v107 = (char *)operator new(8 * v106);
                  v108 = (uint64_t *)&v107[8 * v103];
                  *v108 = v99;
                  v11 = (uint64_t)(v108 + 1);
                  if (v100 == v101)
                    goto LABEL_160;
                }
                else
                {
                  v107 = 0;
                  v108 = (uint64_t *)(8 * v103);
                  *(_QWORD *)(8 * v103) = v99;
                  v11 = 8 * v103 + 8;
                  if (v100 == v101)
                  {
LABEL_160:
                    v200 = v108;
                    v201 = (char *)v11;
                    v202 = &v107[8 * v106];
                    if (v101)
                      operator delete(v101);
                    goto LABEL_19;
                  }
                }
                v109 = v100 - 8 - v101;
                if (v109 < 0x58)
                  goto LABEL_293;
                if ((unint64_t)(v100 - &v107[v102]) < 0x20)
                  goto LABEL_293;
                v110 = (v109 >> 3) + 1;
                v111 = 8 * (v110 & 0x3FFFFFFFFFFFFFFCLL);
                v112 = &v100[-v111];
                v108 = (uint64_t *)((char *)v108 - v111);
                v113 = &v107[8 * v103 - 16];
                v114 = v100 - 16;
                v115 = v110 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  v116 = *(_OWORD *)v114;
                  *((_OWORD *)v113 - 1) = *((_OWORD *)v114 - 1);
                  *(_OWORD *)v113 = v116;
                  v113 -= 32;
                  v114 -= 32;
                  v115 -= 4;
                }
                while (v115);
                v100 = v112;
                if (v110 != (v110 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_293:
                  do
                  {
                    v117 = *((_QWORD *)v100 - 1);
                    v100 -= 8;
                    *--v108 = v117;
                  }
                  while (v100 != v101);
                }
                goto LABEL_160;
              }
            }
            v89 = v21 - 8 - v54;
            if (v89 < 0x58)
              goto LABEL_294;
            if ((unint64_t)(v21 - &v60[v55]) < 0x20)
              goto LABEL_294;
            v90 = (v89 >> 3) + 1;
            v91 = 8 * (v90 & 0x3FFFFFFFFFFFFFFCLL);
            v92 = &v21[-v91];
            v61 = (unint64_t *)((char *)v61 - v91);
            v93 = &v60[8 * v56 - 16];
            v94 = v21 - 16;
            v95 = v90 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v96 = *(_OWORD *)v94;
              *((_OWORD *)v93 - 1) = *((_OWORD *)v94 - 1);
              *(_OWORD *)v93 = v96;
              v93 -= 32;
              v94 -= 32;
              v95 -= 4;
            }
            while (v95);
            v21 = v92;
            if (v90 != (v90 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_294:
              do
              {
                v97 = *((_QWORD *)v21 - 1);
                v21 -= 8;
                *--v61 = v97;
              }
              while (v21 != v54);
            }
            goto LABEL_136;
          case 1:
            std::to_string(&v197, v9);
            v46 = std::string::insert(&v197, 0, "Sampler");
            v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
            v199 = v46->__r_.__value_.__r.__words[2];
            *(_OWORD *)__p = v47;
            v46->__r_.__value_.__l.__size_ = 0;
            v46->__r_.__value_.__r.__words[2] = 0;
            v46->__r_.__value_.__r.__words[0] = 0;
            if (v199 >= 0)
              v48 = (uint64_t *)__p;
            else
              v48 = (uint64_t *)__p[0];
            if (v199 >= 0)
              v49 = HIBYTE(v199);
            else
              v49 = (unint64_t)__p[1];
            v27 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v203, v48, v49);
            v28 = (unint64_t *)v201;
            if (v201 < v202)
              goto LABEL_75;
            v29 = (unint64_t *)v200;
            v50 = v201 - (_BYTE *)v200;
            v51 = (v201 - (_BYTE *)v200) >> 3;
            v52 = v51 + 1;
            if ((unint64_t)(v51 + 1) >> 61)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v53 = v202 - (_BYTE *)v200;
            if ((v202 - (_BYTE *)v200) >> 2 > v52)
              v52 = v53 >> 2;
            if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
              v34 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v34 = v52;
            if (!v34)
            {
              v35 = 0;
              v36 = (unint64_t *)(8 * v51);
              *(_QWORD *)(8 * v51) = v27;
              v37 = 8 * v51 + 8;
              if (v28 == v29)
                goto LABEL_125;
LABEL_119:
              v80 = (char *)(v28 - 1) - (char *)v29;
              if (v80 < 0x58)
                goto LABEL_295;
              if ((unint64_t)((char *)v28 - &v35[v50]) < 0x20)
                goto LABEL_295;
              v81 = (v80 >> 3) + 1;
              v82 = 8 * (v81 & 0x3FFFFFFFFFFFFFFCLL);
              v83 = &v28[v82 / 0xFFFFFFFFFFFFFFF8];
              v36 = (unint64_t *)((char *)v36 - v82);
              v84 = &v35[8 * v51 - 16];
              v85 = v28 - 2;
              v86 = v81 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v87 = *(_OWORD *)v85;
                *(v84 - 1) = *((_OWORD *)v85 - 1);
                *v84 = v87;
                v84 -= 2;
                v85 -= 4;
                v86 -= 4;
              }
              while (v86);
              v28 = v83;
              if (v81 != (v81 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_295:
                do
                {
                  v88 = *--v28;
                  *--v36 = v88;
                }
                while (v28 != v29);
              }
              goto LABEL_125;
            }
            if (v34 >> 61)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v35 = operator new(8 * v34);
            v36 = (unint64_t *)&v35[8 * v51];
            *v36 = v27;
            v37 = (uint64_t)(v36 + 1);
            if (v28 != v29)
              goto LABEL_119;
            goto LABEL_125;
          case 2:
            std::to_string(&v197, v9);
            v23 = std::string::insert(&v197, 0, "Ignore");
            v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
            v199 = v23->__r_.__value_.__r.__words[2];
            *(_OWORD *)__p = v24;
            v23->__r_.__value_.__l.__size_ = 0;
            v23->__r_.__value_.__r.__words[2] = 0;
            v23->__r_.__value_.__r.__words[0] = 0;
            if (v199 >= 0)
              v25 = (uint64_t *)__p;
            else
              v25 = (uint64_t *)__p[0];
            if (v199 >= 0)
              v26 = HIBYTE(v199);
            else
              v26 = (unint64_t)__p[1];
            v27 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v203, v25, v26);
            v28 = (unint64_t *)v201;
            if (v201 < v202)
              goto LABEL_75;
            v29 = (unint64_t *)v200;
            v30 = v201 - (_BYTE *)v200;
            v31 = (v201 - (_BYTE *)v200) >> 3;
            v32 = v31 + 1;
            if ((unint64_t)(v31 + 1) >> 61)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v33 = v202 - (_BYTE *)v200;
            if ((v202 - (_BYTE *)v200) >> 2 > v32)
              v32 = v33 >> 2;
            if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
              v34 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v34 = v32;
            if (!v34)
            {
              v35 = 0;
              v36 = (unint64_t *)(8 * v31);
              *(_QWORD *)(8 * v31) = v27;
              v37 = 8 * v31 + 8;
              if (v28 == v29)
                goto LABEL_125;
LABEL_103:
              v62 = (char *)(v28 - 1) - (char *)v29;
              if (v62 < 0x58)
                goto LABEL_296;
              if ((unint64_t)((char *)v28 - &v35[v30]) < 0x20)
                goto LABEL_296;
              v63 = (v62 >> 3) + 1;
              v64 = 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
              v65 = &v28[v64 / 0xFFFFFFFFFFFFFFF8];
              v36 = (unint64_t *)((char *)v36 - v64);
              v66 = &v35[8 * v31 - 16];
              v67 = v28 - 2;
              v68 = v63 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v69 = *(_OWORD *)v67;
                *(v66 - 1) = *((_OWORD *)v67 - 1);
                *v66 = v69;
                v66 -= 2;
                v67 -= 4;
                v68 -= 4;
              }
              while (v68);
              v28 = v65;
              if (v63 != (v63 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_296:
                do
                {
                  v70 = *--v28;
                  *--v36 = v70;
                }
                while (v28 != v29);
              }
              goto LABEL_125;
            }
            if (v34 >> 61)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v35 = operator new(8 * v34);
            v36 = (unint64_t *)&v35[8 * v31];
            *v36 = v27;
            v37 = (uint64_t)(v36 + 1);
            if (v28 != v29)
              goto LABEL_103;
            goto LABEL_125;
          case 3:
            std::to_string(&v197, v9);
            v38 = std::string::insert(&v197, 0, "Zero");
            v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
            v199 = v38->__r_.__value_.__r.__words[2];
            *(_OWORD *)__p = v39;
            v38->__r_.__value_.__l.__size_ = 0;
            v38->__r_.__value_.__r.__words[2] = 0;
            v38->__r_.__value_.__r.__words[0] = 0;
            if (v199 >= 0)
              v40 = (uint64_t *)__p;
            else
              v40 = (uint64_t *)__p[0];
            if (v199 >= 0)
              v41 = HIBYTE(v199);
            else
              v41 = (unint64_t)__p[1];
            v27 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v203, v40, v41);
            v28 = (unint64_t *)v201;
            if (v201 < v202)
            {
LABEL_75:
              *v28 = v27;
              v201 = (char *)(v28 + 1);
              if ((SHIBYTE(v199) & 0x80000000) == 0)
                goto LABEL_77;
LABEL_76:
              operator delete(__p[0]);
              goto LABEL_77;
            }
            v29 = (unint64_t *)v200;
            v42 = v201 - (_BYTE *)v200;
            v43 = (v201 - (_BYTE *)v200) >> 3;
            v44 = v43 + 1;
            if ((unint64_t)(v43 + 1) >> 61)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v45 = v202 - (_BYTE *)v200;
            if ((v202 - (_BYTE *)v200) >> 2 > v44)
              v44 = v45 >> 2;
            if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8)
              v34 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v34 = v44;
            if (!v34)
            {
              v35 = 0;
              v36 = (unint64_t *)(8 * v43);
              *(_QWORD *)(8 * v43) = v27;
              v37 = 8 * v43 + 8;
              if (v28 == v29)
                goto LABEL_125;
LABEL_111:
              v71 = (char *)(v28 - 1) - (char *)v29;
              if (v71 < 0x58)
                goto LABEL_297;
              if ((unint64_t)((char *)v28 - &v35[v42]) < 0x20)
                goto LABEL_297;
              v72 = (v71 >> 3) + 1;
              v73 = 8 * (v72 & 0x3FFFFFFFFFFFFFFCLL);
              v74 = &v28[v73 / 0xFFFFFFFFFFFFFFF8];
              v36 = (unint64_t *)((char *)v36 - v73);
              v75 = &v35[8 * v43 - 16];
              v76 = v28 - 2;
              v77 = v72 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v78 = *(_OWORD *)v76;
                *(v75 - 1) = *((_OWORD *)v76 - 1);
                *v75 = v78;
                v75 -= 2;
                v76 -= 4;
                v77 -= 4;
              }
              while (v77);
              v28 = v74;
              if (v72 != (v72 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_297:
                do
                {
                  v79 = *--v28;
                  *--v36 = v79;
                }
                while (v28 != v29);
              }
              goto LABEL_125;
            }
            if (v34 >> 61)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v35 = operator new(8 * v34);
            v36 = (unint64_t *)&v35[8 * v43];
            *v36 = v27;
            v37 = (uint64_t)(v36 + 1);
            if (v28 != v29)
              goto LABEL_111;
LABEL_125:
            v200 = v36;
            v201 = (char *)v37;
            v202 = &v35[8 * v34];
            if (v29)
              operator delete(v29);
            v10 = v196;
            v201 = (char *)v37;
            if (SHIBYTE(v199) < 0)
              goto LABEL_76;
LABEL_77:
            if (SHIBYTE(v197.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v197.__r_.__value_.__l.__data_);
              if (v14)
LABEL_20:
                (*(void (**)(HGProgramDescriptor *))(*(_QWORD *)v14 + 24))(v14);
            }
            else
            {
LABEL_78:
              if (v14)
                goto LABEL_20;
            }
LABEL_21:
            if (++v9 != v10)
              continue;
            LOBYTE(v4) = *((_BYTE *)this + 87);
            if ((v4 & 0x80) == 0)
              goto LABEL_172;
            goto LABEL_195;
          default:
            goto LABEL_78;
        }
      }
    }
    if ((v4 & 0x80) != 0)
    {
LABEL_195:
      if (!*((_QWORD *)this + 9))
        goto LABEL_196;
    }
    else
    {
LABEL_172:
      if (!(_BYTE)v4)
      {
LABEL_196:
        v138 = *((_BYTE *)this + 63);
        if (v138 < 0)
        {
          if (!*((_QWORD *)this + 6))
          {
LABEL_198:
            v139 = *((unsigned __int8 *)this + 111);
            if ((*((char *)this + 111) & 0x80000000) == 0)
              goto LABEL_199;
            goto LABEL_271;
          }
        }
        else if (!*((_BYTE *)this + 63))
        {
          goto LABEL_198;
        }
        if (v138 >= 0)
          v157 = (uint64_t *)((char *)this + 40);
        else
          v157 = (uint64_t *)*((_QWORD *)this + 5);
        if (v138 >= 0)
          v158 = *((unsigned __int8 *)this + 63);
        else
          v158 = *((_QWORD *)this + 6);
        v124 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)__p, v157, v158);
        v125 = (unint64_t *)v201;
        if (v201 < v202)
          goto LABEL_227;
        v126 = (unint64_t *)v200;
        v159 = v201 - (_BYTE *)v200;
        v160 = (v201 - (_BYTE *)v200) >> 3;
        v161 = v160 + 1;
        if ((unint64_t)(v160 + 1) >> 61)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v162 = v202 - (_BYTE *)v200;
        if ((v202 - (_BYTE *)v200) >> 2 > v161)
          v161 = v162 >> 2;
        if ((unint64_t)v162 >= 0x7FFFFFFFFFFFFFF8)
          v163 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v163 = v161;
        if (v163)
        {
          if (v163 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v164 = operator new(8 * v163);
          v133 = (unint64_t *)&v164[8 * v160];
          v134 = &v164[8 * v163];
          *v133 = v124;
          v135 = (uint64_t)(v133 + 1);
          v165 = (char *)v125 - (char *)v126;
          if (v125 == v126)
            goto LABEL_268;
          goto LABEL_262;
        }
        v164 = 0;
        v133 = (unint64_t *)(8 * v160);
        v134 = 0;
        *(_QWORD *)(8 * v160) = v124;
        v135 = 8 * v160 + 8;
        v165 = (char *)v125 - (char *)v126;
        if (v125 != v126)
        {
LABEL_262:
          v187 = v165 - 8;
          if (v187 < 0x58)
            goto LABEL_298;
          if ((unint64_t)((char *)v125 - v164 - v159) < 0x20)
            goto LABEL_298;
          v188 = (v187 >> 3) + 1;
          v189 = 8 * (v188 & 0x3FFFFFFFFFFFFFFCLL);
          v190 = &v125[v189 / 0xFFFFFFFFFFFFFFF8];
          v133 = (unint64_t *)((char *)v133 - v189);
          v191 = &v164[8 * v160 - 16];
          v192 = v125 - 2;
          v193 = v188 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v194 = *(_OWORD *)v192;
            *(v191 - 1) = *((_OWORD *)v192 - 1);
            *v191 = v194;
            v191 -= 2;
            v192 -= 4;
            v193 -= 4;
          }
          while (v193);
          v125 = v190;
          if (v188 != (v188 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_298:
            do
            {
              v195 = *--v125;
              *--v133 = v195;
            }
            while (v125 != v126);
          }
        }
LABEL_268:
        v200 = v133;
        v201 = (char *)v135;
        v202 = v134;
        if (v126)
          operator delete(v126);
LABEL_270:
        v201 = (char *)v135;
        v139 = *((unsigned __int8 *)this + 111);
        if ((*((char *)this + 111) & 0x80000000) == 0)
        {
LABEL_199:
          if (v139)
            goto LABEL_200;
          goto LABEL_272;
        }
LABEL_271:
        if (*((_QWORD *)this + 12))
        {
LABEL_200:
          if ((v139 & 0x80u) == 0)
            v140 = (uint64_t *)((char *)this + 88);
          else
            v140 = (uint64_t *)*((_QWORD *)this + 11);
          if ((v139 & 0x80u) == 0)
            v141 = v139;
          else
            v141 = *((_QWORD *)this + 12);
          v142 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)__p, v140, v141);
          v143 = v142;
          v144 = v201;
          if (v201 < v202)
          {
            *(_QWORD *)v201 = v142;
            v145 = v144 + 8;
            v146 = (char *)v200;
            if (v200 == v144 + 8)
              goto LABEL_273;
            goto LABEL_256;
          }
          v147 = (char *)v200;
          v148 = v201 - (_BYTE *)v200;
          v149 = (v201 - (_BYTE *)v200) >> 3;
          v150 = v149 + 1;
          if ((unint64_t)(v149 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v151 = v202 - (_BYTE *)v200;
          if ((v202 - (_BYTE *)v200) >> 2 > v150)
            v150 = v151 >> 2;
          if ((unint64_t)v151 >= 0x7FFFFFFFFFFFFFF8)
            v152 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v152 = v150;
          if (v152)
          {
            if (v152 >> 61)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v153 = (char *)operator new(8 * v152);
            v154 = (unint64_t *)&v153[8 * v149];
            v155 = &v153[8 * v152];
            *v154 = v143;
            v145 = (char *)(v154 + 1);
            v156 = v144 - v147;
            if (v144 == v147)
            {
LABEL_253:
              v200 = v154;
              v201 = v145;
              v202 = v155;
              if (v147)
                operator delete(v147);
              v146 = (char *)v200;
              if (v200 == v145)
              {
LABEL_273:
                v121 = 0;
                if (!v146)
                  return v121;
                goto LABEL_259;
              }
LABEL_256:
              v121 = 0;
              v184 = v146;
              do
              {
                v185 = *(_QWORD *)v184;
                v184 += 8;
                v121 ^= (v121 << 6) + (v121 >> 2) - 0x61C8864680B583EBLL + v185;
              }
              while (v184 != v145);
              if (!v146)
                return v121;
LABEL_259:
              v201 = v146;
              operator delete(v146);
              return v121;
            }
          }
          else
          {
            v153 = 0;
            v154 = (unint64_t *)(8 * v149);
            v155 = 0;
            *(_QWORD *)(8 * v149) = v143;
            v145 = (char *)(8 * v149 + 8);
            v156 = v144 - v147;
            if (v144 == v147)
              goto LABEL_253;
          }
          v175 = v156 - 8;
          if (v175 < 0x58)
            goto LABEL_299;
          if ((unint64_t)(v144 - v153 - v148) < 0x20)
            goto LABEL_299;
          v176 = (v175 >> 3) + 1;
          v177 = 8 * (v176 & 0x3FFFFFFFFFFFFFFCLL);
          v178 = &v144[-v177];
          v154 = (unint64_t *)((char *)v154 - v177);
          v179 = &v153[8 * v149 - 16];
          v180 = v144 - 16;
          v181 = v176 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v182 = *(_OWORD *)v180;
            *((_OWORD *)v179 - 1) = *((_OWORD *)v180 - 1);
            *(_OWORD *)v179 = v182;
            v179 -= 32;
            v180 -= 32;
            v181 -= 4;
          }
          while (v181);
          v144 = v178;
          if (v176 != (v176 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_299:
            do
            {
              v183 = *((_QWORD *)v144 - 1);
              v144 -= 8;
              *--v154 = v183;
            }
            while (v144 != v147);
          }
          goto LABEL_253;
        }
LABEL_272:
        v146 = (char *)v200;
        v145 = v201;
        if (v200 == v201)
          goto LABEL_273;
        goto LABEL_256;
      }
    }
    if ((v4 & 0x80u) == 0)
      v122 = (uint64_t *)((char *)this + 64);
    else
      v122 = (uint64_t *)*((_QWORD *)this + 8);
    if ((v4 & 0x80u) == 0)
      v123 = v4;
    else
      v123 = *((_QWORD *)this + 9);
    v124 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)__p, v122, v123);
    v125 = (unint64_t *)v201;
    if (v201 < v202)
    {
LABEL_227:
      *v125 = v124;
      v135 = (uint64_t)(v125 + 1);
      goto LABEL_270;
    }
    v126 = (unint64_t *)v200;
    v127 = v201 - (_BYTE *)v200;
    v128 = (v201 - (_BYTE *)v200) >> 3;
    v129 = v128 + 1;
    if ((unint64_t)(v128 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v130 = v202 - (_BYTE *)v200;
    if ((v202 - (_BYTE *)v200) >> 2 > v129)
      v129 = v130 >> 2;
    if ((unint64_t)v130 >= 0x7FFFFFFFFFFFFFF8)
      v131 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v131 = v129;
    if (v131)
    {
      if (v131 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v132 = operator new(8 * v131);
      v133 = (unint64_t *)&v132[8 * v128];
      v134 = &v132[8 * v131];
      *v133 = v124;
      v135 = (uint64_t)(v133 + 1);
      v136 = (char *)v125 - (char *)v126;
      if (v125 == v126)
        goto LABEL_268;
    }
    else
    {
      v132 = 0;
      v133 = (unint64_t *)(8 * v128);
      v134 = 0;
      *(_QWORD *)(8 * v128) = v124;
      v135 = 8 * v128 + 8;
      v136 = (char *)v125 - (char *)v126;
      if (v125 == v126)
        goto LABEL_268;
    }
    v166 = v136 - 8;
    if (v166 < 0x58)
      goto LABEL_300;
    if ((unint64_t)((char *)v125 - v132 - v127) < 0x20)
      goto LABEL_300;
    v167 = (v166 >> 3) + 1;
    v168 = 8 * (v167 & 0x3FFFFFFFFFFFFFFCLL);
    v169 = &v125[v168 / 0xFFFFFFFFFFFFFFF8];
    v133 = (unint64_t *)((char *)v133 - v168);
    v170 = &v132[8 * v128 - 16];
    v171 = v125 - 2;
    v172 = v167 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v173 = *(_OWORD *)v171;
      *(v170 - 1) = *((_OWORD *)v171 - 1);
      *v170 = v173;
      v170 -= 2;
      v171 -= 4;
      v172 -= 4;
    }
    while (v172);
    v125 = v169;
    if (v167 != (v167 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_300:
      do
      {
        v174 = *--v125;
        *--v133 = v174;
      }
      while (v125 != v126);
    }
    goto LABEL_268;
  }
LABEL_8:
  if (*((char *)this + 183) < 0)
  {
    v7 = *((_QWORD *)this + 21) != 0;
    if (!v5)
      goto LABEL_162;
    goto LABEL_12;
  }
  v7 = *((_BYTE *)this + 183) != 0;
  if (v5)
    goto LABEL_12;
LABEL_162:
  v118 = *((_BYTE *)this + 159);
  if (v118 < 0)
  {
    if (*((_QWORD *)this + 18))
      goto LABEL_164;
  }
  else if (*((_BYTE *)this + 159))
  {
LABEL_164:
    if (v118 >= 0)
      v119 = (uint64_t *)((char *)this + 136);
    else
      v119 = (uint64_t *)*((_QWORD *)this + 17);
    if (v118 >= 0)
      v120 = *((unsigned __int8 *)this + 159);
    else
      v120 = *((_QWORD *)this + 18);
    return std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v200, v119, v120);
  }
  v137 = (_QWORD *)((char *)this + 40);
  if (*((char *)this + 63) < 0)
    v137 = (_QWORD *)*v137;
  HGLogger::warning((HGLogger *)"Missing fragment shader for %s\n", a2, a3, v137);
  return 0;
}

void sub_1B2A2DC48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGProgramDescriptor::SetShaderProgram(HGProgramDescriptor *this, const char *a2)
{
  JUMPOUT(0x1B5E28D80);
}

void HGProgramDescriptor::SetVisibleShaderWithSource(HGProgramDescriptor *this, const char *a2, const char *a3)
{
  MEMORY[0x1B5E28D80]((char *)this + 64, a2);
  JUMPOUT(0x1B5E28D80);
}

void std::vector<HGBinding>::__assign_with_size[abi:ne180100]<HGBinding*,HGBinding*>(void **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  char *v9;
  char *v10;
  void *v11;
  void **v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  std::string *v18;
  const std::string::value_type **v19;
  void **v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  std::string *v27;
  const std::string::value_type **v28;

  v6 = a2;
  v8 = (uint64_t)a1[2];
  v9 = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - (uint64_t)*a1) >> 4) < a4)
  {
    if (v9)
    {
      v10 = (char *)a1[1];
      v11 = *a1;
      if (v10 != v9)
      {
        do
        {
          if (*(v10 - 17) < 0)
            operator delete(*((void **)v10 - 5));
          v10 -= 48;
        }
        while (v10 != v9);
        v11 = *a1;
      }
      a1[1] = v9;
      operator delete(v11);
      v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0x555555555555555)
      goto LABEL_46;
    v21 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 4);
    v22 = 2 * v21;
    if (2 * v21 <= a4)
      v22 = a4;
    v23 = v21 >= 0x2AAAAAAAAAAAAAALL ? 0x555555555555555 : v22;
    if (v23 > 0x555555555555555)
LABEL_46:
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v24 = 6 * v23;
    v20 = (void **)operator new(48 * v23);
    *a1 = v20;
    a1[1] = v20;
    a1[2] = &v20[v24];
    if (v6 != a3)
    {
      v25 = 0;
      do
      {
        v26 = v6 + v25;
        LODWORD(v20[v25 / 8]) = *(_DWORD *)(v6 + v25);
        v27 = (std::string *)&v20[v25 / 8 + 1];
        v28 = (const std::string::value_type **)(v6 + v25 + 8);
        if (*(char *)(v6 + v25 + 31) < 0)
        {
          std::string::__init_copy_ctor_external(v27, *v28, *(_QWORD *)(v26 + 16));
        }
        else
        {
          *(_OWORD *)&v27->__r_.__value_.__l.__data_ = *(_OWORD *)v28;
          v20[v25 / 8 + 3] = *(void **)(v6 + v25 + 24);
        }
        *(_OWORD *)&v20[v25 / 8 + 4] = *(_OWORD *)(v26 + 32);
        v25 += 48;
      }
      while (v26 + 48 != a3);
      v20 = (void **)((char *)v20 + v25);
    }
LABEL_38:
    a1[1] = v20;
    return;
  }
  v12 = (void **)a1[1];
  if (0xAAAAAAAAAAAAAAABLL * (((char *)v12 - v9) >> 4) >= a4)
  {
    if (a2 == a3)
    {
      v20 = (void **)*a1;
    }
    else
    {
      v20 = (void **)*a1;
      do
      {
        *(_DWORD *)v9 = *(_DWORD *)v6;
        std::string::operator=((std::string *)(v9 + 8), (const std::string *)(v6 + 8));
        *((_OWORD *)v9 + 2) = *(_OWORD *)(v6 + 32);
        v20 += 6;
        v6 += 48;
        v9 += 48;
      }
      while (v6 != a3);
      v12 = (void **)a1[1];
    }
    while (v12 != v20)
    {
      if (*((char *)v12 - 17) < 0)
        operator delete(*(v12 - 5));
      v12 -= 6;
    }
    goto LABEL_38;
  }
  v13 = a2 + 16 * (((char *)v12 - v9) >> 4);
  if (v12 != (void **)v9)
  {
    do
    {
      *(_DWORD *)v9 = *(_DWORD *)v6;
      std::string::operator=((std::string *)(v9 + 8), (const std::string *)(v6 + 8));
      *((_OWORD *)v9 + 2) = *(_OWORD *)(v6 + 32);
      v6 += 48;
      v9 += 48;
    }
    while (v6 != v13);
    v9 = (char *)a1[1];
  }
  v14 = v9;
  if (v13 != a3)
  {
    v15 = 0;
    do
    {
      v17 = v13 + v15;
      *(_DWORD *)&v9[v15] = *(_DWORD *)(v13 + v15);
      v18 = (std::string *)&v9[v15 + 8];
      v19 = (const std::string::value_type **)(v13 + v15 + 8);
      if (*(char *)(v13 + v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(v18, *v19, *(_QWORD *)(v17 + 16));
      }
      else
      {
        v16 = *(_OWORD *)v19;
        *(_QWORD *)&v9[v15 + 24] = *(_QWORD *)(v13 + v15 + 24);
        *(_OWORD *)&v18->__r_.__value_.__l.__data_ = v16;
      }
      *(_OWORD *)&v9[v15 + 32] = *(_OWORD *)(v17 + 32);
      v15 += 48;
    }
    while (v17 + 48 != a3);
    v14 = &v9[v15];
  }
  a1[1] = v14;
}

void sub_1B2A2E0E4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  for (; v3; v3 -= 48)
  {
    if (*(char *)(v2 + v3 - 17) < 0)
      operator delete(*(void **)(v2 + v3 - 40));
  }
  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(exception_object);
}

char *std::vector<std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>>::__push_back_slow_path<std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>>(void **a1, uint64_t a2)
{
  _BYTE *v3;
  _BYTE *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v4 = *a1;
  v3 = a1[1];
  v5 = (v3 - (_BYTE *)*a1) >> 4;
  v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) >> 60)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v7 = (_BYTE *)a1[2] - v4;
  if (v7 >> 3 > v6)
    v6 = v7 >> 3;
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF0)
    v6 = 0xFFFFFFFFFFFFFFFLL;
  if (v6 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v9 = 16 * v6;
  v10 = (char *)operator new(16 * v6);
  v11 = &v10[16 * v5];
  v12 = &v10[v9];
  *(_DWORD *)v11 = *(_DWORD *)a2;
  *((_QWORD *)v11 + 1) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  v13 = v11 + 16;
  if (v3 != v4)
  {
    v14 = 0;
    do
    {
      v15 = &v11[v14];
      *((_DWORD *)v15 - 4) = *(_DWORD *)&v3[v14 - 16];
      v16 = *(_QWORD *)&v3[v14 - 8];
      *((_QWORD *)v15 - 1) = v16;
      if (v16)
        (*(void (**)(uint64_t))(*(_QWORD *)v16 + 16))(v16);
      v14 -= 16;
    }
    while (&v3[v14] != v4);
    v11 += v14;
  }
  v17 = (char *)*a1;
  v18 = (char *)a1[1];
  *a1 = v11;
  a1[1] = v13;
  a1[2] = v12;
  while (v18 != v17)
  {
    v19 = *((_QWORD *)v18 - 1);
    if (v19)
      (*(void (**)(uint64_t))(*(_QWORD *)v19 + 24))(v19);
    v18 -= 16;
  }
  if (v17)
    operator delete(v17);
  return v13;
}

uint64_t std::__split_buffer<std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    while (1)
    {
      v4 = i - 16;
      *(_QWORD *)(a1 + 16) = i - 16;
      v5 = *(_QWORD *)(i - 8);
      if (v5)
        break;
      i -= 16;
      if (v4 == v3)
        goto LABEL_6;
    }
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  }
LABEL_6:
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

char *std::vector<HGBinding>::__push_back_slow_path<HGBinding>(char **a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  int v13;
  __int128 v14;
  char *v15;

  v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  v4 = v3 + 1;
  if (v3 + 1 > 0x555555555555555)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  if (0x5555555555555556 * ((a1[2] - *a1) >> 4) > v4)
    v4 = 0x5555555555555556 * ((a1[2] - *a1) >> 4);
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 4) >= 0x2AAAAAAAAAAAAAALL)
    v6 = 0x555555555555555;
  else
    v6 = v4;
  if (v6)
  {
    if (v6 > 0x555555555555555)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v7 = (char *)operator new(48 * v6);
  }
  else
  {
    v7 = 0;
  }
  v8 = &v7[48 * v3];
  v9 = &v7[48 * v6];
  *(_DWORD *)v8 = *(_DWORD *)a2;
  *(_OWORD *)(v8 + 8) = *(_OWORD *)(a2 + 8);
  *((_QWORD *)v8 + 3) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *((_OWORD *)v8 + 2) = *(_OWORD *)(a2 + 32);
  v10 = v8 + 48;
  v11 = *a1;
  v12 = a1[1];
  if (v12 == *a1)
  {
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
    if (!v12)
      return v10;
    goto LABEL_20;
  }
  do
  {
    v13 = *((_DWORD *)v12 - 12);
    v12 -= 48;
    *((_DWORD *)v8 - 12) = v13;
    v8 -= 48;
    v14 = *(_OWORD *)(v12 + 8);
    *((_QWORD *)v8 + 3) = *((_QWORD *)v12 + 3);
    *(_OWORD *)(v8 + 8) = v14;
    *((_QWORD *)v12 + 2) = 0;
    *((_QWORD *)v12 + 3) = 0;
    *((_QWORD *)v12 + 1) = 0;
    *((_OWORD *)v8 + 2) = *((_OWORD *)v12 + 2);
  }
  while (v12 != v11);
  v15 = *a1;
  v12 = a1[1];
  *a1 = v8;
  a1[1] = v10;
  a1[2] = v9;
  if (v12 != v15)
  {
    do
    {
      if (*(v12 - 17) < 0)
        operator delete(*((void **)v12 - 5));
      v12 -= 48;
    }
    while (v12 != v15);
    v12 = v15;
  }
  if (v12)
LABEL_20:
    operator delete(v12);
  return v10;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  _QWORD **v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  float v16;
  float v17;
  uint64_t v18;
  _QWORD *v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t prime;
  unint64_t v24;
  uint8x8_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        if (v9.u32[0] < 2uLL)
        {
          while (1)
          {
            v13 = v11[1];
            if (v13 == v7)
            {
              if (v11[2] == v7)
                return v11;
            }
            else if ((v13 & (v8 - 1)) != v4)
            {
              goto LABEL_23;
            }
            v11 = (_QWORD *)*v11;
            if (!v11)
              goto LABEL_23;
          }
        }
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == v7)
              return v11;
          }
          else
          {
            if (v12 >= v8)
              v12 %= v8;
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
LABEL_23:
  v14 = (_QWORD *)(a1 + 16);
  v11 = operator new(0x30uLL);
  *v11 = 0;
  v11[1] = v7;
  v15 = **a4;
  v11[4] = 0;
  v11[5] = 0;
  v11[2] = v15;
  v11[3] = 0;
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (v8 && (float)(v17 * (float)v8) >= v16)
  {
    v18 = *(_QWORD *)a1;
    v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
    if (v19)
    {
LABEL_26:
      *v11 = *v19;
LABEL_61:
      *v19 = v11;
      goto LABEL_62;
    }
  }
  else
  {
    v20 = 1;
    if (v8 >= 3)
      v20 = (v8 & (v8 - 1)) != 0;
    v21 = v20 | (2 * v8);
    v22 = vcvtps_u32_f32(v16 / v17);
    if (v21 <= v22)
      prime = v22;
    else
      prime = v21;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
      v8 = *(_QWORD *)(a1 + 8);
    }
    if (prime > v8)
      goto LABEL_37;
    if (prime < v8)
    {
      v24 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v8 < 3 || (v25 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        v24 = std::__next_prime(v24);
      }
      else
      {
        v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2)
          v24 = v26;
      }
      if (prime <= v24)
        prime = v24;
      if (prime < v8)
LABEL_37:
        std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__do_rehash<true>(a1, prime);
    }
    v8 = *(_QWORD *)(a1 + 8);
    v27 = v8 - 1;
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
      {
        v4 = v7 % v8;
        v18 = *(_QWORD *)a1;
        v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * (v7 % v8));
        if (v19)
          goto LABEL_26;
      }
      else
      {
        v4 = v7;
        v18 = *(_QWORD *)a1;
        v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v7);
        if (v19)
          goto LABEL_26;
      }
    }
    else
    {
      v4 = v27 & v7;
      v18 = *(_QWORD *)a1;
      v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * (v27 & v7));
      if (v19)
        goto LABEL_26;
    }
  }
  *v11 = *v14;
  *v14 = v11;
  *(_QWORD *)(v18 + 8 * v4) = v14;
  if (*v11)
  {
    v28 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v28 >= v8)
        v28 %= v8;
    }
    else
    {
      v28 &= v8 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v28);
    goto LABEL_61;
  }
LABEL_62:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_1B2A2E840(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::string>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::string>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((_BYTE *)a1 + 16) && *(char *)(v2 + 47) < 0)
      operator delete(*(void **)(v2 + 24));
    operator delete((void *)v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;

  if (!a2)
  {
    v15 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v15)
      operator delete(v15);
    *(_QWORD *)(a1 + 8) = 0;
    return;
  }
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v4 = operator new(8 * a2);
  v5 = *(void **)a1;
  *(_QWORD *)a1 = v4;
  if (v5)
    operator delete(v5);
  v6 = 0;
  *(_QWORD *)(a1 + 8) = a2;
  do
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
  while (a2 != v6);
  v8 = a1 + 16;
  v7 = *(_QWORD **)(a1 + 16);
  if (v7)
  {
    v9 = v7[1];
    v10 = a2 - 1;
    if ((a2 & (a2 - 1)) == 0)
    {
      v11 = v9 & v10;
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v11) = v8;
      while (1)
      {
        v12 = (_QWORD *)*v7;
        if (!*v7)
          break;
        v13 = v12[1] & v10;
        if (v13 == v11)
        {
          v7 = (_QWORD *)*v7;
        }
        else if (*(_QWORD *)(*(_QWORD *)a1 + 8 * v13))
        {
          *v7 = *v12;
          v14 = 8 * v13;
          *v12 = **(_QWORD **)(*(_QWORD *)a1 + v14);
          **(_QWORD **)(*(_QWORD *)a1 + v14) = v12;
        }
        else
        {
          *(_QWORD *)(*(_QWORD *)a1 + 8 * v13) = v7;
          v7 = v12;
          v11 = v13;
        }
      }
      return;
    }
    if (v9 >= a2)
      v9 %= a2;
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v9) = v8;
    v16 = (_QWORD *)*v7;
    if (*v7)
    {
      while (1)
      {
        v18 = v16[1];
        if (v18 >= a2)
          v18 %= a2;
        if (v18 == v9)
          goto LABEL_25;
        if (*(_QWORD *)(*(_QWORD *)a1 + 8 * v18))
        {
          *v7 = *v16;
          v17 = 8 * v18;
          *v16 = **(_QWORD **)(*(_QWORD *)a1 + v17);
          **(_QWORD **)(*(_QWORD *)a1 + v17) = v16;
          v16 = v7;
LABEL_25:
          v7 = v16;
          v16 = (_QWORD *)*v16;
          if (!v16)
            return;
        }
        else
        {
          *(_QWORD *)(*(_QWORD *)a1 + 8 * v18) = v7;
          v7 = v16;
          v16 = (_QWORD *)*v16;
          v9 = v18;
          if (!v16)
            return;
        }
      }
    }
  }
}

uint64_t std::vector<HGBinding>::__push_back_slow_path<HGBinding const&>(char **a1, uint64_t a2)
{
  char *v3;
  char *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v8;
  _OWORD *v9;
  char *v10;
  std::string *v11;
  uint64_t v12;
  int v13;
  __int128 v14;
  char *v15;
  void **v16;
  BOOL v17;
  char *v19;

  v3 = *a1;
  v4 = a1[1];
  v5 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 4);
  v6 = v5 + 1;
  if (v5 + 1 > 0x555555555555555)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  if (0x5555555555555556 * ((a1[2] - v3) >> 4) > v6)
    v6 = 0x5555555555555556 * ((a1[2] - v3) >> 4);
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 4) >= 0x2AAAAAAAAAAAAAALL)
    v8 = 0x555555555555555;
  else
    v8 = v6;
  if (v8)
  {
    if (v8 > 0x555555555555555)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v9 = operator new(48 * v8);
  }
  else
  {
    v9 = 0;
  }
  v10 = (char *)&v9[3 * v5];
  v19 = (char *)&v9[3 * v8];
  *(_DWORD *)v10 = *(_DWORD *)a2;
  v11 = (std::string *)(v10 + 8);
  if (*(char *)(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)(a2 + 8), *(_QWORD *)(a2 + 16));
    v3 = *a1;
    v4 = a1[1];
    v10 = (char *)&v9[3 * v5];
  }
  else
  {
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 8);
    *((_QWORD *)v10 + 3) = *(_QWORD *)(a2 + 24);
  }
  v9[3 * v5 + 2] = *(_OWORD *)(a2 + 32);
  v12 = (uint64_t)&v9[3 * v5 + 3];
  if (v4 == v3)
  {
    v15 = v3;
  }
  else
  {
    do
    {
      v13 = *((_DWORD *)v4 - 12);
      v4 -= 48;
      *((_DWORD *)v10 - 12) = v13;
      v10 -= 48;
      v14 = *(_OWORD *)(v4 + 8);
      *((_QWORD *)v10 + 3) = *((_QWORD *)v4 + 3);
      *(_OWORD *)(v10 + 8) = v14;
      *((_QWORD *)v4 + 2) = 0;
      *((_QWORD *)v4 + 3) = 0;
      *((_QWORD *)v4 + 1) = 0;
      *((_OWORD *)v10 + 2) = *((_OWORD *)v4 + 2);
    }
    while (v4 != v3);
    v15 = *a1;
    v3 = a1[1];
  }
  *a1 = v10;
  a1[1] = (char *)v12;
  a1[2] = v19;
  if (v3 != v15)
  {
    v16 = (void **)(v3 - 48);
    do
    {
      if (*((char *)v16 + 31) < 0)
        operator delete(v16[1]);
      v17 = v16 == (void **)v15;
      v16 -= 6;
    }
    while (!v17);
    v3 = v15;
  }
  if (v3)
    operator delete(v3);
  return v12;
}

void sub_1B2A2EC2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<HGBinding>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long const,std::string>>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  char *v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  float v14;
  float v15;
  uint64_t v16;
  _QWORD *v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t prime;
  int8x8_t v22;
  unint64_t v23;
  uint8x8_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v6 >= v7)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = (char *)*v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            v12 = *((_QWORD *)v10 + 1);
            if (v12 == v6)
            {
              if (*((_QWORD *)v10 + 2) == v6)
                return v10;
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_23;
            }
            v10 = *(char **)v10;
            if (!v10)
              goto LABEL_23;
          }
        }
        do
        {
          v11 = *((_QWORD *)v10 + 1);
          if (v11 == v6)
          {
            if (*((_QWORD *)v10 + 2) == v6)
              return v10;
          }
          else
          {
            if (v11 >= v7)
              v11 %= v7;
            if (v11 != v3)
              break;
          }
          v10 = *(char **)v10;
        }
        while (v10);
      }
    }
  }
LABEL_23:
  v13 = (_QWORD *)(a1 + 16);
  v10 = (char *)operator new(0x30uLL);
  *(_QWORD *)v10 = 0;
  *((_QWORD *)v10 + 1) = v6;
  *((_QWORD *)v10 + 2) = *(_QWORD *)a3;
  *(_OWORD *)(v10 + 24) = *(_OWORD *)(a3 + 8);
  *((_QWORD *)v10 + 5) = *(_QWORD *)(a3 + 24);
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    v16 = *(_QWORD *)a1;
    v17 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v17)
    {
LABEL_26:
      *(_QWORD *)v10 = *v17;
LABEL_61:
      *v17 = v10;
      goto LABEL_62;
    }
  }
  else
  {
    v18 = 1;
    if (v7 >= 3)
      v18 = (v7 & (v7 - 1)) != 0;
    v19 = v18 | (2 * v7);
    v20 = vcvtps_u32_f32(v14 / v15);
    if (v19 <= v20)
      prime = v20;
    else
      prime = v19;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
    }
    v22 = *(int8x8_t *)(a1 + 8);
    if (prime > *(_QWORD *)&v22)
      goto LABEL_37;
    if (prime < *(_QWORD *)&v22)
    {
      v23 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(_QWORD *)&v22 < 3uLL || (v24 = (uint8x8_t)vcnt_s8(v22), v24.i16[0] = vaddlv_u8(v24), v24.u32[0] > 1uLL))
      {
        v23 = std::__next_prime(v23);
      }
      else
      {
        v25 = 1 << -(char)__clz(v23 - 1);
        if (v23 >= 2)
          v23 = v25;
      }
      if (prime <= v23)
        prime = v23;
      if (prime < *(_QWORD *)&v22)
LABEL_37:
        std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__do_rehash<true>(a1, prime);
    }
    v7 = *(_QWORD *)(a1 + 8);
    v26 = v7 - 1;
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
      {
        v3 = v6 % v7;
        v16 = *(_QWORD *)a1;
        v17 = *(_QWORD **)(*(_QWORD *)a1 + 8 * (v6 % v7));
        if (v17)
          goto LABEL_26;
      }
      else
      {
        v3 = v6;
        v16 = *(_QWORD *)a1;
        v17 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v6);
        if (v17)
          goto LABEL_26;
      }
    }
    else
    {
      v3 = v26 & v6;
      v16 = *(_QWORD *)a1;
      v17 = *(_QWORD **)(*(_QWORD *)a1 + 8 * (v26 & v6));
      if (v17)
        goto LABEL_26;
    }
  }
  *(_QWORD *)v10 = *v13;
  *v13 = v10;
  *(_QWORD *)(v16 + 8 * v3) = v13;
  if (*(_QWORD *)v10)
  {
    v27 = *(_QWORD *)(*(_QWORD *)v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v27 >= v7)
        v27 %= v7;
    }
    else
    {
      v27 &= v7 - 1;
    }
    v17 = (_QWORD *)(*(_QWORD *)a1 + 8 * v27);
    goto LABEL_61;
  }
LABEL_62:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_1B2A2EF6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::string>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<std::string,BOOL>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,BOOL>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,BOOL>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,BOOL>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, uint64_t a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _BYTE *v6;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  uint64_t **v14;
  uint64_t *v15;
  char v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  std::string *v27;
  __int128 *v28;
  __int128 v29;
  float v30;
  float v31;
  _QWORD *v32;
  _QWORD *v33;
  _BOOL8 v34;
  unint64_t v35;
  unint64_t v36;
  size_t prime;
  int8x8_t v38;
  unint64_t v39;
  uint8x8_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  _QWORD v45[2];
  char v46;

  v6 = (_BYTE *)a2;
  v8 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v9 = v8;
  }
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)v45, (uint64_t *)a2, v9);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      v4 = v10;
      if (v10 >= v12)
        v4 = v10 % v12;
    }
    else
    {
      v4 = (v12 - 1) & v10;
    }
    v14 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      v15 = *v14;
      if (*v14)
      {
        v16 = v6[23];
        if (v16 >= 0)
          v17 = v6[23];
        else
          v17 = *((_QWORD *)v6 + 1);
        if (v16 < 0)
          v6 = *(_BYTE **)v6;
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            v22 = v15[1];
            if (v22 == v11)
            {
              v23 = *((unsigned __int8 *)v15 + 39);
              if ((v23 & 0x80u) == 0)
                v24 = *((unsigned __int8 *)v15 + 39);
              else
                v24 = v15[3];
              if (v24 == v17)
              {
                if ((v23 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v15[2], v6, v15[3]))
                    return v15;
                }
                else
                {
                  if (!*((_BYTE *)v15 + 39))
                    return v15;
                  v25 = 0;
                  while (*((unsigned __int8 *)v15 + v25 + 16) == v6[v25])
                  {
                    if (v23 == ++v25)
                      return v15;
                  }
                }
              }
            }
            else if ((v22 & (v12 - 1)) != v4)
            {
              goto LABEL_51;
            }
            v15 = (uint64_t *)*v15;
            if (!v15)
              goto LABEL_51;
          }
        }
        do
        {
          v18 = v15[1];
          if (v18 == v11)
          {
            v19 = *((unsigned __int8 *)v15 + 39);
            if ((v19 & 0x80u) == 0)
              v20 = *((unsigned __int8 *)v15 + 39);
            else
              v20 = v15[3];
            if (v20 == v17)
            {
              if ((v19 & 0x80) != 0)
              {
                if (!memcmp((const void *)v15[2], v6, v15[3]))
                  return v15;
              }
              else
              {
                if (!*((_BYTE *)v15 + 39))
                  return v15;
                v21 = 0;
                while (*((unsigned __int8 *)v15 + v21 + 16) == v6[v21])
                {
                  if (v19 == ++v21)
                    return v15;
                }
              }
            }
          }
          else
          {
            if (v18 >= v12)
              v18 %= v12;
            if (v18 != v4)
              break;
          }
          v15 = (uint64_t *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_51:
  v26 = (char *)operator new(0x30uLL);
  v45[0] = v26;
  v45[1] = a1 + 16;
  v46 = 0;
  *(_QWORD *)v26 = 0;
  *((_QWORD *)v26 + 1) = v11;
  v27 = (std::string *)(v26 + 16);
  v28 = *a4;
  if (*((char *)*a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v27, *(const std::string::value_type **)v28, *((_QWORD *)v28 + 1));
  }
  else
  {
    v29 = *v28;
    *((_QWORD *)v26 + 4) = *((_QWORD *)v28 + 2);
    *(_OWORD *)&v27->__r_.__value_.__l.__data_ = v29;
  }
  v26[40] = 0;
  v46 = 1;
  v30 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v31 = *(float *)(a1 + 32);
  if (!v12 || (float)(v31 * (float)v12) < v30)
  {
    v34 = 1;
    if (v12 >= 3)
      v34 = (v12 & (v12 - 1)) != 0;
    v35 = v34 | (2 * v12);
    v36 = vcvtps_u32_f32(v30 / v31);
    if (v35 <= v36)
      prime = v36;
    else
      prime = v35;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
    }
    v38 = *(int8x8_t *)(a1 + 8);
    if (prime > *(_QWORD *)&v38)
      goto LABEL_68;
    if (prime < *(_QWORD *)&v38)
    {
      v39 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(_QWORD *)&v38 < 3uLL || (v40 = (uint8x8_t)vcnt_s8(v38), v40.i16[0] = vaddlv_u8(v40), v40.u32[0] > 1uLL))
      {
        v39 = std::__next_prime(v39);
      }
      else
      {
        v41 = 1 << -(char)__clz(v39 - 1);
        if (v39 >= 2)
          v39 = v41;
      }
      if (prime <= v39)
        prime = v39;
      if (prime < *(_QWORD *)&v38)
LABEL_68:
        std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__do_rehash<true>(a1, prime);
    }
    v12 = *(_QWORD *)(a1 + 8);
    v42 = v12 - 1;
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
      {
        v4 = v11 % v12;
        v32 = *(_QWORD **)(*(_QWORD *)a1 + 8 * (v11 % v12));
        v33 = (_QWORD *)v45[0];
        if (v32)
          goto LABEL_57;
      }
      else
      {
        v4 = v11;
        v32 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v11);
        v33 = (_QWORD *)v45[0];
        if (v32)
          goto LABEL_57;
      }
    }
    else
    {
      v4 = v42 & v11;
      v32 = *(_QWORD **)(*(_QWORD *)a1 + 8 * (v42 & v11));
      v33 = (_QWORD *)v45[0];
      if (v32)
        goto LABEL_57;
    }
LABEL_81:
    *v33 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v45[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v45[0])
    {
      v43 = *(_QWORD *)(*(_QWORD *)v45[0] + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v43 >= v12)
          v43 %= v12;
      }
      else
      {
        v43 &= v12 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v43) = v45[0];
    }
    goto LABEL_92;
  }
  v32 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  v33 = (_QWORD *)v45[0];
  if (!v32)
    goto LABEL_81;
LABEL_57:
  *v33 = *v32;
  *v32 = v45[0];
LABEL_92:
  v15 = (uint64_t *)v45[0];
  ++*(_QWORD *)(a1 + 24);
  return v15;
}

void sub_1B2A2F3C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A2F3D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((_BYTE *)a1 + 16) && *(char *)(v2 + 39) < 0)
      operator delete(*(void **)(v2 + 16));
    operator delete((void *)v2);
  }
  return a1;
}

char *std::vector<HGProgramDescriptor::Dependency>::__push_back_slow_path<HGProgramDescriptor::Dependency>(void **a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  __int128 v10;
  char *v11;
  char *v12;
  char *v13;
  __int128 v14;
  __int128 v15;
  char *v16;

  v3 = 0xAAAAAAAAAAAAAAABLL * (((_BYTE *)a1[1] - (_BYTE *)*a1) >> 4);
  v4 = v3 + 1;
  if (v3 + 1 > 0x555555555555555)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  if (0x5555555555555556 * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 4) > v4)
    v4 = 0x5555555555555556 * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 4);
  if (0xAAAAAAAAAAAAAAABLL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 4) >= 0x2AAAAAAAAAAAAAALL)
    v6 = 0x555555555555555;
  else
    v6 = v4;
  if (v6)
  {
    if (v6 > 0x555555555555555)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v7 = (char *)operator new(48 * v6);
  }
  else
  {
    v7 = 0;
  }
  v8 = &v7[48 * v3];
  *((_QWORD *)v8 + 2) = *(_QWORD *)(a2 + 16);
  *(_OWORD *)v8 = *(_OWORD *)a2;
  v9 = &v7[48 * v6];
  v10 = *(_OWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_OWORD *)(v8 + 24) = v10;
  *((_QWORD *)v8 + 5) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v11 = v8 + 48;
  v12 = (char *)*a1;
  v13 = (char *)a1[1];
  if (v13 == *a1)
  {
    *a1 = v8;
    a1[1] = v11;
    a1[2] = v9;
    if (!v13)
      return v11;
    goto LABEL_23;
  }
  do
  {
    v14 = *((_OWORD *)v13 - 3);
    *((_QWORD *)v8 - 4) = *((_QWORD *)v13 - 4);
    *((_OWORD *)v8 - 3) = v14;
    *((_QWORD *)v13 - 5) = 0;
    *((_QWORD *)v13 - 4) = 0;
    *((_QWORD *)v13 - 6) = 0;
    v15 = *(_OWORD *)(v13 - 24);
    *((_QWORD *)v8 - 1) = *((_QWORD *)v13 - 1);
    *(_OWORD *)(v8 - 24) = v15;
    v8 -= 48;
    *((_QWORD *)v13 - 2) = 0;
    *((_QWORD *)v13 - 1) = 0;
    *((_QWORD *)v13 - 3) = 0;
    v13 -= 48;
  }
  while (v13 != v12);
  v16 = (char *)*a1;
  v13 = (char *)a1[1];
  *a1 = v8;
  a1[1] = v11;
  a1[2] = v9;
  if (v13 != v16)
  {
    while (1)
    {
      if (*(v13 - 1) < 0)
      {
        operator delete(*((void **)v13 - 3));
        if (*(v13 - 25) < 0)
LABEL_20:
          operator delete(*((void **)v13 - 6));
      }
      else if (*(v13 - 25) < 0)
      {
        goto LABEL_20;
      }
      v13 -= 48;
      if (v13 == v16)
      {
        v13 = v16;
        break;
      }
    }
  }
  if (v13)
LABEL_23:
    operator delete(v13);
  return v11;
}

void HGComicEdges::HGComicEdges(HGComicEdges *this)
{
  uint64_t v1;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v1 = off_1E651FDB8;
  *(_QWORD *)(v1 + 408) = 0;
  *(_QWORD *)(v1 + 416) = 0;
  *(_DWORD *)(v1 + 16) |= 0x600u;
}

void HGComicEdges::~HGComicEdges(HGNode *this)
{
  void *v1;

  HGNode::~HGNode(this);
  HGObject::operator delete(v1);
}

uint64_t HGComicEdges::SetParameter(HGComicEdges *this, int a2, float a3, float a4, float a5, float a6)
{
  uint64_t result;

  switch(a2)
  {
    case 0:
      if (*((float *)this + 102) == a3)
        goto LABEL_11;
      *((float *)this + 102) = a3;
      result = 1;
      break;
    case 1:
      if (*((float *)this + 103) == a3)
        goto LABEL_11;
      *((float *)this + 103) = a3;
      result = 1;
      break;
    case 2:
      if (*((float *)this + 104) == a3)
        goto LABEL_11;
      *((float *)this + 104) = a3;
      result = 1;
      break;
    case 3:
      if (*((float *)this + 105) == a3)
      {
LABEL_11:
        result = 0;
      }
      else
      {
        *((float *)this + 105) = a3;
        result = 1;
      }
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HGComicEdges::IntermediateFormat()
{
  return 24;
}

uint64_t HGComicEdges::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

uint64_t HGComicEdges::GetROI@<X0>(uint64_t a1@<X0>, int a2@<W2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  HGRect v9;
  HGRect v10;
  HGRect v11;

  if (a2 == 1)
  {
    *(_QWORD *)&v9.var0 = a3;
    *(_QWORD *)&v9.var2 = a4;
    goto LABEL_5;
  }
  if (!a2)
  {
    LODWORD(a5) = vcvtps_s32_f32(*(float *)(a1 + 408) + *(float *)(a1 + 408));
    *(_QWORD *)&v10.var2 = a5 | (a5 << 32);
    *(_QWORD *)&v9.var0 = a3;
    *(_QWORD *)&v9.var2 = a4;
    v10.var0 = -(int)a5;
    v10.var1 = -(int)a5;
    HGRect::Grow(&v9, v10);
LABEL_5:
    v5 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    v7 = v6;
    *(_QWORD *)&v11.var0 = v5;
    *(_QWORD *)&v11.var2 = v7;
    HGRect::Grow(&v9, v11);
    return *(_QWORD *)&v9.var0;
  }
  return HGRectNull;
}

uint64_t HGComicEdges::RenderTile(HGComicEdges *this, HGTile *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v9;
  int v10;
  float32x4_t v11;
  float v12;
  float v13;
  float v14;
  uint64_t v15;
  float32x4_t v16;
  float32x4_t v17;
  uint64_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float v23;
  float32x4_t v24;
  uint64_t v28;
  uint64_t v29;
  float32x4_t v30;
  int32x4_t v31;
  float32x2_t v32;
  float32x4_t *v33;
  float32x4_t v34;
  uint64_t v35;
  uint64_t v36;
  int32x4_t v37;
  float32x2_t v38;
  float32x4_t *v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int32x4_t v44;
  float32x4_t v45;
  int32x4_t v46;
  float32x4_t v47;
  int8x16_t v48;
  float v49;
  int8x16_t v50;
  float v51;
  int8x16_t v52;
  _BOOL4 v53;
  unsigned int v55;
  __int32 v56;
  float32x4_t v57;
  uint64_t v58;
  float v59;
  float32x4_t v60;
  float32x4_t v61;
  int32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int32x4_t v65;
  float32x4_t v66;
  unint64_t v67;
  int8x16_t v68;
  float v69;
  float v70;
  float32x4_t v71;
  float32x4_t v72;
  int32x4_t v73;
  float32x2_t v74;
  float32x4_t *v75;
  float32x4_t v76;
  float32x4_t v77;
  int32x4_t v78;
  float32x4_t *v79;
  float32x4_t v80;
  int v81;
  float32x4_t v82;
  int v83;
  float v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float v89;
  float32x4_t v90;
  float v91;
  float32x4_t v92;

  v4 = HGTile::Renderer(a2);
  v5 = (*(uint64_t (**)(HGComicEdges *, uint64_t))(*(_QWORD *)this + 312))(this, v4);
  v6 = *((_DWORD *)a2 + 2) - *(_QWORD *)a2;
  v81 = *((_DWORD *)a2 + 3) - HIDWORD(*(_QWORD *)a2);
  if (v81 >= 1 && (int)v6 >= 1)
  {
    v9 = v5;
    v10 = 0;
    *(float32x2_t *)v11.f32 = vadd_f32(vcvt_f32_s32(*(int32x2_t *)a2), (float32x2_t)0x3F0000003F000000);
    v11.i64[1] = 0x3F80000000000000;
    v12 = *((float *)this + 102);
    v84 = *((float *)this + 103);
    v13 = v12 + v12;
    v14 = 1.0 / (float)(v12 * (float)(v12 + v12));
    v15 = *((_QWORD *)a2 + 2);
    v16 = (float32x4_t)xmmword_1B30516E0;
    v17 = v11;
    v87 = v11;
    do
    {
      v83 = v10;
      v18 = 0;
      v82 = v17;
      v19 = v17;
      do
      {
        v28 = *((_QWORD *)a2 + 12);
        v29 = *((int *)a2 + 26);
        v30 = vsubq_f32(v19, v11);
        if (v9)
        {
          v31 = vaddq_s32(vcvtq_s32_f32(v30), vcltzq_f32(v30));
          v32 = (float32x2_t)vsubq_f32(v30, vcvtq_f32_s32(v31)).u64[0];
          v33 = (float32x4_t *)(v28 + 16 * (v31.i32[0] + v31.i32[1] * (int)v29));
          v34 = vaddq_f32(*v33, vmulq_n_f32(vsubq_f32(v33[1], *v33), v32.f32[0]));
          v85 = vaddq_f32(v34, vmulq_lane_f32(vsubq_f32(vaddq_f32(v33[v29], vmulq_n_f32(vsubq_f32(v33[(int)v29 + 1], v33[v29]), v32.f32[0])), v34), v32, 1));
          v35 = *((_QWORD *)a2 + 10);
          v36 = *((int *)a2 + 22);
          v88 = v19;
          v37 = vaddq_s32(vcvtq_s32_f32(v30), vcltzq_f32(v30));
          v38 = (float32x2_t)vsubq_f32(v30, vcvtq_f32_s32(v37)).u64[0];
          v39 = (float32x4_t *)(v35 + 16 * (v37.i32[0] + v37.i32[1] * (int)v36));
          v40 = vaddq_f32(*v39, vmulq_n_f32(vsubq_f32(v39[1], *v39), v38.f32[0]));
          v41 = vaddq_f32(v40, vmulq_lane_f32(vsubq_f32(vaddq_f32(v39[v36], vmulq_n_f32(vsubq_f32(v39[(int)v36 + 1], v39[v36]), v38.f32[0])), v40), v38, 1));
        }
        else
        {
          v42.i64[0] = 0x3F0000003F000000;
          v42.i64[1] = 0x3F0000003F000000;
          v43 = vaddq_f32(v30, v42);
          v44 = vcvtq_s32_f32(v43);
          v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
          v85 = *(float32x4_t *)(v28 + 16 * (v43.i32[0] + v43.i32[1] * (int)v29));
          v35 = *((_QWORD *)a2 + 10);
          v36 = *((int *)a2 + 22);
          v88 = v19;
          v43.i64[0] = 0x3F0000003F000000;
          v43.i64[1] = 0x3F0000003F000000;
          v45 = vaddq_f32(v30, v43);
          v46 = vcvtq_s32_f32(v45);
          v45.i64[0] = vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)).u64[0];
          v41 = *(float32x4_t *)(v35 + 16 * (v45.i32[0] + v45.i32[1] * (int)v36));
        }
        v47 = v41;
        v91 = v41.f32[0];
        v48 = (int8x16_t)vmulq_f32(v41, v16);
        v49 = vaddv_f32(vadd_f32(*(float32x2_t *)v48.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v48, v48, 8uLL)));
        v50 = (int8x16_t)vmulq_f32(v47, (float32x4_t)xmmword_1B309E050);
        v51 = vaddv_f32(vadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL)));
        v52 = (int8x16_t)vmulq_f32(v47, (float32x4_t)xmmword_1B309E060);
        v53 = fabsf(atan2f(vaddv_f32(vadd_f32(*(float32x2_t *)v52.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL))), v51)+ -2.3) < 0.3;
        if (v49 > 0.8)
          v53 = 1;
        if (v49 < 0.4)
          v53 = 1;
        _ZF = !v53;
        if (v53)
          v55 = -1;
        else
          v55 = 0;
        *(float *)&v56 = v91;
        if (_ZF)
          *(float *)&v56 = v49;
        v57.i64[1] = 0;
        v57.i32[0] = v56;
        v57.i32[1] = v56;
        if (v13 < 1.0)
        {
          v20 = (float32x4_t)xmmword_1B3052100;
        }
        else
        {
          v86 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_n_s32(v55), (int8x16_t)xmmword_1B304F230, (int8x16_t)xmmword_1B30516E0);
          v58 = (int)v36 + 1;
          v20 = (float32x4_t)xmmword_1B3052100;
          v59 = 1.0;
          do
          {
            v90 = v20;
            v92 = v57;
            v69 = v59 * (float)-(float)(v59 * v59);
            v89 = expf(v69 * 0.5);
            v70 = expf(v14 * v69);
            v71.i64[1] = 0;
            v71.f32[0] = (float)((float)(v85.f32[2] + v85.f32[2]) + -1.0) * v59;
            v71.f32[1] = v59 * (float)-(float)((float)(v85.f32[1] + v85.f32[1]) + -1.0);
            v72 = vsubq_f32(vsubq_f32(v88, (float32x4_t)v71.u64[0]), v87);
            if (v9)
            {
              v73 = vaddq_s32(vcvtq_s32_f32(v72), vcltzq_f32(v72));
              v74 = (float32x2_t)vsubq_f32(v72, vcvtq_f32_s32(v73)).u64[0];
              v75 = (float32x4_t *)(v35 + 16 * (v73.i32[0] + v73.i32[1] * (int)v36));
              v76 = vaddq_f32(*v75, vmulq_n_f32(vsubq_f32(v75[1], *v75), v74.f32[0]));
              v63 = vaddq_f32(v76, vmulq_lane_f32(vsubq_f32(vaddq_f32(v75[v36], vmulq_n_f32(vsubq_f32(v75[v58], v75[v36]), v74.f32[0])), v76), v74, 1));
              v77 = vsubq_f32(vaddq_f32(v88, v71), v87);
              v78 = vaddq_s32(vcvtq_s32_f32(v77), vcltzq_f32(v77));
              v77.i64[0] = vsubq_f32(v77, vcvtq_f32_s32(v78)).u64[0];
              v79 = (float32x4_t *)(v35 + 16 * (v78.i32[0] + v78.i32[1] * (int)v36));
              v80 = vaddq_f32(*v79, vmulq_n_f32(vsubq_f32(v79[1], *v79), v77.f32[0]));
              v66 = vaddq_f32(v80, vmulq_lane_f32(vsubq_f32(vaddq_f32(v79[v36], vmulq_n_f32(vsubq_f32(v79[v58], v79[v36]), v77.f32[0])), v80), *(float32x2_t *)v77.f32, 1));
            }
            else
            {
              v60.i64[0] = 0x3F0000003F000000;
              v60.i64[1] = 0x3F0000003F000000;
              v61 = vaddq_f32(v72, v60);
              v62 = vcvtq_s32_f32(v61);
              v61.i64[0] = vaddq_s32(v62, vcgtq_f32(vcvtq_f32_s32(v62), v61)).u64[0];
              v63 = *(float32x4_t *)(v35 + 16 * (v61.i32[0] + v61.i32[1] * (int)v36));
              v64 = vaddq_f32(vsubq_f32(vaddq_f32(v88, v71), v87), v60);
              v65 = vcvtq_s32_f32(v64);
              v64.i64[0] = vaddq_s32(v65, vcgtq_f32(vcvtq_f32_s32(v65), v64)).u64[0];
              v66 = *(float32x4_t *)(v35 + 16 * (v64.i32[0] + v64.i32[1] * (int)v36));
            }
            v67 = __PAIR64__(LODWORD(v70), LODWORD(v89));
            v68 = (int8x16_t)vmulq_f32(v86, vaddq_f32(v63, v66));
            *(float32x2_t *)v68.i8 = vadd_f32(*(float32x2_t *)v68.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v68, v68, 8uLL));
            v20 = vaddq_f32(v90, (float32x4_t)v67);
            v57 = vaddq_f32(v92, vmulq_n_f32((float32x4_t)v67, vadd_f32(*(float32x2_t *)v68.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v68.i8, 1)).f32[0]));
            v59 = v59 + 1.0;
          }
          while (v59 <= v13);
        }
        v21.i64[0] = 0x3F0000003F000000;
        v21.i64[1] = 0x3F0000003F000000;
        v21.i64[0] = vmulq_f32(v57, vdivq_f32(v21, v20)).u64[0];
        _NF = (float)(v84 * (float)((float)(v21.f32[0] + vmuls_lane_f32(-0.99, *(float32x2_t *)v21.f32, 1)) * 300.0)) < 0.8;
        v23 = 0.0;
        if (!_NF)
          v23 = 1.0;
        v16 = (float32x4_t)xmmword_1B30516E0;
        v24 = v85;
        v24.f32[0] = v23;
        __asm { FMOV            V0.4S, #1.0 }
        *(float32x4_t *)(v15 + 16 * v18) = vmaxnmq_f32(vminnmq_f32(v24, _Q0), (float32x4_t)0);
        v11 = v87;
        v19 = vaddq_f32(v88, (float32x4_t)xmmword_1B304F230);
        ++v18;
      }
      while (v18 != v6);
      v17 = vaddq_f32(v82, (float32x4_t)xmmword_1B304F240);
      v15 += 16 * *((int *)a2 + 6);
      v10 = v83 + 1;
    }
    while (v83 + 1 != v81);
  }
  return 0;
}

HGComicEdges *HGComicEdges::GetOutput(HGComicEdges *this, HGRenderer *a2, char *a3)
{
  HGNode::SetParameter((HGNode *)this, 0, *((float *)this + 102), *((float *)this + 103), *((float *)this + 104), *((float *)this + 105), a3);
  return this;
}

const char *HGComicEdges::GetProgram(HGComicEdges *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) > 0x60B0F)
    return "//Metal1.0     \n"
           "//LEN=0000000c37\n"
           "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< half >      hg_Texture0 [[ texture(0) ]],\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]],\n"
           "                                  texture2d< half >      hg_Texture1 [[ texture(1) ]],\n"
           "                                  sampler                hg_Sampler1 [[ sampler(1) ]])\n"
           "{\n"
           "    const half sigma {static_cast<half>(hg_Params[0].x)};\n"
           "    const float prethreshold {hg_Params[0].y};\n"
           "    //const float threshold {hg_Params[0].z};\n"
           "    const float thesholdCoeffAdj {hg_Params[0].w};\n"
           "\n"
           "    const half sigma22 {1.0h / (2.0h * sigma * sigma)};\n"
           "    const half sigmax2 {2.0h * sigma};\n"
           "\n"
           "    const half alpha {hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).a};\n"
           "\n"
           "    const half2 gradient = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).yz;\n"
           "    const half2 dirPerpen {gradient.y * 2.0h - 1.0h, -(gradient.x * 2.0h - 1.0h)};\n"
           "\n"
           "    half3 lumaWeights {0.2126h, 0.7152h, 0.0722h};\n"
           "    constexpr half3 uWeights {-0.1146h, -0.3854h, 0.5000h};\n"
           "    constexpr half3 vWeights {0.5000h, -0.4542h, -0.0458h};\n"
           "    \n"
           "    const half3 srcRGB = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).rgb;\n"
           "    \n"
           "    const half srcY {dot(srcRGB, lumaWeights)};\n"
           "    const half srcU {dot(srcRGB, uWeights)};\n"
           "    const half srcV {dot(srcRGB, vWeights)};\n"
           "    \n"
           "    const half chromaAngle {atan2(srcV, srcU)};\n"
           "    \n"
           "    // if skintone found, then detect edges only on red channel to reduce wrinkles and shadows, otherwise use"
           " ITU Rec.709 luma for sky, trees, etc.\n"
           "    half luma = {srcY};\n"
           "    \n"
           "    if (abs(chromaAngle - 2.3h) < 0.3h || srcY > 0.8h || srcY < 0.4h)\n"
           "    {\n"
           "        luma = {srcRGB.r};\n"
           "        lumaWeights = {1.0h, 0.0h, 0.0h};\n"
           "    }\n"
           "\n"
           "    // edge detection using extended difference of gaussian thresholding\n"
           "    float2 acc {luma, luma};\n"
           "    half2 norma {0.5h, 0.5h};\n"
           "\n"
           "    for (half i {1.0h}; i <= sigmax2; i++)\n"
           "    {\n"
           "        const half2 coeff {exp(-i * i * i * 0.5h), exp(-i * i * i * sigma22)};\n"
           "        \n"
           "        const float2 uNeg = frag._texCoord0.xy - static_cast<float2>(i * dirPerpen);\n"
           "        const float2 uPos = frag._texCoord0.xy + static_cast<float2>(i * dirPerpen);\n"
           "        \n"
           "        const half3 pixel1 = hg_Texture0.sample(hg_Sampler0, uNeg).rgb;\n"
           "        const half3 pixel2 = hg_Texture0.sample(hg_Sampler0, uPos).rgb;\n"
           "\n"
           "        norma += coeff;\n"
           "        acc   += static_cast<float2>(coeff * dot((pixel1+pixel2), lumaWeights));\n"
           "    }\n"
           "\n"
           "    acc = acc * 0.5f / static_cast<float2>(norma);\n"
           "\n"
           "    const half total {static_cast<half>((acc.x  - acc.y * (0.99f + thesholdCoeffAdj)) * 300.0f * prethreshold"
           ")};\n"
           "\n"
           "    FragmentOut out {float4(step(0.8h, total), static_cast<float2>(gradient), alpha)};\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    out.color0 = clamp(out.color0, 0.0f, 1.0f);\n"
           "\n"
           "    return out;\n"
           "}\n"
           "//MD5=9d181266:b7bbbd77:46ccdefd:532fadfc\n"
           "//SIG=00000000:00000000:00000000:00000003:0021:0001:0000:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
    return "//GLfs1.0      \n"
           "//LEN=0000000ae7\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#define precision\n"
           "#define defaultp mediump\n"
           "#endif\n"
           "\n"
           "precision highp float;\n"
           "precision highp int;\n"
           "\n"
           "uniform defaultp sampler2DRect hg_Texture0; //BFFILTER\n"
           "uniform defaultp sampler2DRect hg_Texture1; //GAUSSFILTER\n"
           "\n"
           "uniform highp vec4 hg_ProgramLocal0;    // {.x == sigma, .y == prethreshold, .z == threshold, .w == threshold"
           " coeff adj}\n"
           "\n"
           "void main()\n"
           "{\n"
           "    float sigma = hg_ProgramLocal0.x;\n"
           "    float prethreshold = hg_ProgramLocal0.y;\n"
           "    float threshold = hg_ProgramLocal0.z;\n"
           "    float thresholdCoeffAdj = hg_ProgramLocal0.w;\n"
           "\n"
           "    float sigma22 = 1.0/ (2.0 * sigma  * sigma) ;\n"
           "    float sigmax2 = 2.0 * sigma ;\n"
           "\n"
           "    float alpha = texture2DRect(hg_Texture1, gl_TexCoord[1].xy).a;\n"
           "    vec2 gradient = texture2DRect(hg_Texture1, gl_TexCoord[1].xy).yz;\n"
           "    vec2 dirPerpen = vec2(gradient.y*2.0-1.0,  -(gradient.x*2.0-1.0));\n"
           "\n"
           "    vec3 lumaWeights = vec3( 0.2126,  0.7152, 0.0722);\n"
           "    vec3 uWeights    = vec3(-0.1146, -0.3854, 0.5000);\n"
           "    vec3 vWeights    = vec3( 0.5000, -0.4542,-0.0458);\n"
           "    vec3 srcRGB = texture2DRect( hg_Texture0, gl_TexCoord[0].xy).rgb;\n"
           "    float srcY = dot(srcRGB, lumaWeights);\n"
           "    float srcU = dot(srcRGB, uWeights);\n"
           "    float srcV = dot(srcRGB, vWeights);\n"
           "    float chromaAngle = atan(srcV, srcU);\n"
           "    \n"
           "    // if skintone found, then detect edges only on red channel to reduce wrinkles and shadows, otherwise use"
           " ITU Rec.709 luma for sky, trees, etc.\n"
           "    float luma = srcY;\n"
           "    \n"
           "    if (abs(chromaAngle - 2.3) < 0.3 || srcY > 0.8 || srcY < 0.4) \n"
           "    {\n"
           "        luma = srcRGB.r;\n"
           "        lumaWeights = vec3(1.0,0.0,0.0);\n"
           "    }\n"
           "\n"
           "    // edge detection using extended difference of gaussian thresholding\n"
           "    vec2 acc = vec2(luma, luma);\n"
           "    vec2 norma = vec2(0.5, 0.5);\n"
           "\n"
           "    for ( float i = 1.0; i <= sigmax2; i ++) \n"
           "    {\n"
           "        vec2 coeff = vec2( exp( -i*i*i*0.5), exp( -i*i*i* sigma22)); //primera  fija, segunda variable\n"
           "        \n"
           "        vec2 uNeg = gl_TexCoord[0].xy - i * dirPerpen;\n"
           "        vec2 uPos = gl_TexCoord[0].xy + i * dirPerpen;\n"
           "        \n"
           "        vec3 pixel1 = texture2DRect( hg_Texture0, uNeg).rgb;\n"
           "        vec3 pixel2 = texture2DRect( hg_Texture0, uPos).rgb;\n"
           "        norma += coeff;\n"
           "        acc   += coeff * dot((pixel1+pixel2), lumaWeights) ;\n"
           "    }\n"
           "\n"
           "    acc  = acc*0.5/norma;\n"
           "\n"
           "    float total =   (acc.x  - acc.y * (0.99 + thresholdCoeffAdj))* 300.0*prethreshold; //substract second pow"
           "3  from first pow3 and 'cranck' the result\n"
           "\n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    gl_FragColor = clamp(vec4( (step (0.8, total)),gradient, alpha), 0.0, 1.0);   // remove residual gray t"
           "ones     ADD GRADIENT INSIDE THE EDGES TEXTURE\n"
           "}\n"
           "//MD5=6b6ff578:2a238d62:fa69622e:3bf77bdd\n"
           "//SIG=00000000:00000000:00000000:00000000:0042:0001:0000:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  return 0;
}

uint64_t HGComicEdges::BindTexture(HGComicEdges *this, HGHandler *a2, uint64_t a3)
{
  HGHandler::TexCoord(a2, a3, 0, 0, 0);
  (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, a3, 0);
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  (*(void (**)(HGHandler *, uint64_t, uint64_t))(*(_QWORD *)a2 + 48))(a2, 1, 1);
  return 0;
}

uint64_t HGGPURenderer::Concatenate(HGRenderer *a1, _QWORD *a2, unsigned __int8 *a3, const char *a4)
{
  HGLimits *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  HGRenderer *v25;
  unint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  HGLimits *v35;
  _QWORD *v36;
  __int128 v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned __int8 v52;
  const char *v53;
  const char *v54;
  char *v55;
  unsigned __int8 v56;
  uint64_t v57;
  uint64_t v58;
  char v59;
  _QWORD *v60;
  const char *v61;
  const char *v62;
  char *v63;
  unsigned __int8 v64;
  BOOL v65;
  int v66;
  const char *v67;
  char *v68;
  _QWORD *v70;
  _QWORD *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unsigned __int8 v78;
  __int128 v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  unsigned int v98;
  HGShaderBinding *v99;
  HGRenderer *v100;
  int v101;
  char v102;
  char v103;
  __int16 v104;
  HGLimits *Limits;
  int v106;
  _BOOL4 v107;
  int v108;
  HGString::Digest *v109;
  _QWORD *v110;
  _BYTE v111[48];
  uint64_t v112;
  __int128 v113;
  __int128 v114;
  int v115;
  _OWORD v116[3];
  __int128 v117;
  char __str[256];
  _BYTE v119[136];
  uint64_t v120;

  v120 = *MEMORY[0x1E0C80C00];
  Limits = (HGLimits *)HGRenderer::GetLimits(a1, 393216);
  v103 = HGString::Digest::isunpremult((HGString::Digest *)a3);
  v8 = (HGLimits *)(a3 + 16);
  v109 = (HGString::Digest *)a3;
  v9 = a3[56];
  LODWORD(a3) = HGLimits::isglfs((HGLimits *)(a3 + 16)) != 0;
  v10 = (_DWORD)a3 - (HGLimits::isarbfp(v8) != 0);
  if (HGLimits::ismetal(v8))
    v13 = -2;
  else
    v13 = 0;
  if (!(v10 + v13))
    return 0xFFFFFFFFLL;
  v110 = a2;
  v100 = a1;
  if ((_DWORD)v9)
  {
    v14 = 0;
    v15 = 1;
    v106 = v10 + v13;
    do
    {
      if (v14 == (_DWORD)v9 - 1 && *((unsigned __int16 *)v109 + 26) <= v9)
        v15 = 1;
      *(_QWORD *)(a2[37] + 56 * v14) = 0;
      if (((1 << v14) & a4) != 0)
      {
        v16 = a2[10];
        if (!v16
          || (v17 = *(_QWORD *)(v16 + 8 * v14)) == 0
          || (v18 = *(_QWORD *)(v17 + 16)) == 0
          || (v19 = *(_QWORD *)(v18 + 144)) == 0
          || (v20 = *(_QWORD *)(v19 + 64)) == 0
          || (v15 & 1) == 0 && (*(unsigned __int8 *)(v20 + 56) > 1u || *(unsigned __int16 *)(v20 + 52) > 1u)
          || ((v107 = HGLimits::isglfs((HGLimits *)(v20 + 16)) != 0,
               v108 = v107 - (HGLimits::isarbfp((HGLimits *)(v20 + 16)) != 0),
               HGLimits::ismetal((HGLimits *)(v20 + 16)))
            ? (v21 = -2)
            : (v21 = 0),
              v108 + v21 != v106 || *(_BYTE *)(v20 + 58) != 1))
        {
          v15 = 0;
          a4 = (const char *)(a4 & ~(1 << v14));
        }
        a2 = v110;
      }
      ++v14;
    }
    while (v14 != v9);
  }
  v22 = a2[37];
  v23 = 0x6DB6DB6DB6DB6DB7 * ((a2[38] - v22) >> 3);
  v24 = v23 - v9;
  v25 = v100;
  if (v23 > v9)
  {
    v26 = v9;
    if (v24 < 2)
      goto LABEL_33;
    v26 = (v24 & 0xFFFFFFFFFFFFFFFELL) + v9;
    v27 = (_QWORD *)(v22 + 56 * v9);
    v28 = v24 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      *v27 = 0;
      v27[7] = 0;
      v27 += 14;
      v28 -= 2;
    }
    while (v28);
    if (v24 != (v24 & 0xFFFFFFFFFFFFFFFELL))
    {
LABEL_33:
      v29 = (_QWORD *)(v22 + 56 * v26);
      v30 = v23 - v26;
      do
      {
        *v29 = 0;
        v29 += 7;
        --v30;
      }
      while (v30);
    }
  }
  v99 = (HGShaderBinding *)((char *)a2 + 260);
  *((_DWORD *)a2 + 71) = 0;
  if (!(_DWORD)a4 || !a2[10])
  {
LABEL_105:
    if (!(*(unsigned int (**)(HGRenderer *, HGString::Digest *))(*(_QWORD *)v25 + 432))(v25, v109))
    {
      v110[8] = v109;
      HGShaderBinding::reset(v99);
      return 0;
    }
    v110[8] = 0;
    HGShaderBinding::reset(v99);
    return 0xFFFFFFFFLL;
  }
  memset(v119, 0, 128);
  v117 = 0u;
  memset(v116, 0, sizeof(v116));
  WORD2(v117) = *((_WORD *)v109 + 26);
  BYTE8(v117) = *((_BYTE *)v109 + 56);
  v115 = 0;
  v113 = 0u;
  v114 = 0u;
  v112 = 0;
  if (!(_DWORD)v9)
  {
    v98 = 0;
    v101 = 0;
    goto LABEL_76;
  }
  v31 = 0;
  v101 = 0;
  v98 = 0;
  v32 = 0;
  v33 = 16;
  v34 = 1;
  v35 = Limits;
  do
  {
    if ((_DWORD)v9 - 1 == v31 && *((unsigned __int16 *)v109 + 26) <= v9)
      v34 = 1;
    v38 = ((2 << v31) - 1) & a4;
    if (((1 << v31) & a4) != 0)
    {
      v39 = *(_QWORD *)(v110[10] + 8 * v31);
      if (v39)
      {
        v40 = *(_QWORD *)(v39 + 16);
        if (v40)
        {
          v41 = *(_QWORD *)(v40 + 144);
          v104 = WORD2(v117);
          v102 = BYTE8(v117);
          if (v41)
          {
            v11 = *(_QWORD *)(v41 + 64);
            if (v11)
            {
              if (*(unsigned __int16 *)(v11 + 52) + WORD2(v117) < *((unsigned __int16 *)v35 + 18)
                && *(unsigned __int8 *)(v11 + 56) + BYTE8(v117) < *((unsigned __int8 *)v35 + 40))
              {
                v42 = 1 - v32;
                if (HGString::Digest::push((HGString::Digest *)&v119[64 * (1 - v32)], (HGShaderBinding *)(v110[37] + v33), (const HGString::Digest *)&v119[64 * v32], (const HGString::Digest *)v11, (v34 & 1) == 0, 0) == -1|| HGString::Digest::pop((HGString::Digest *)v116, (HGShaderBinding *)&v113, (const HGString::Digest *)&v119[64 * (1 - v32)], v109, ((2 << v31) - 1) & a4, Limits) == -1)
                {
                  v35 = Limits;
                }
                else
                {
                  v43 = (*(uint64_t (**)(HGRenderer *, _OWORD *, _QWORD, uint64_t *))(*(_QWORD *)v100 + 416))(v100, v116, 0, &v112);
                  if (v43 == -1)
                    goto LABEL_62;
                  v35 = Limits;
                  if (!v43)
                  {
                    v36 = v110;
                    v110[8] = v112;
                    v37 = v114;
                    *(_OWORD *)v99 = v113;
                    *(_OWORD *)((char *)a2 + 276) = v37;
                    *((_DWORD *)a2 + 73) = v115;
                    v98 = ((2 << v31) - 1) & a4;
                    goto LABEL_41;
                  }
                  v101 |= (1 << v31) & a4;
                  if (v43 > -2)
                    goto LABEL_64;
                }
              }
            }
          }
          WORD2(v117) = v104;
          BYTE8(v117) = v102;
          a4 = (const char *)(a4 & ~(1 << v31));
        }
      }
    }
    if ((a4 & ~v38) != 0)
    {
      HGString::Digest::push((HGString::Digest *)&v119[64 * v32], (const HGString::Digest *)&v119[64 * v32], v35);
      v34 = 0;
      v42 = v32;
LABEL_62:
      v36 = v110;
      v35 = Limits;
      goto LABEL_41;
    }
    v34 = 0;
    v42 = v32;
LABEL_64:
    v36 = v110;
LABEL_41:
    ++v31;
    v33 += 56;
    v32 = v42;
  }
  while (v9 != v31);
  v25 = v100;
  if (!(_DWORD)a4)
    goto LABEL_105;
  if ((_DWORD)a4 != v98)
  {
LABEL_76:
    v52 = atomic_load(HGLogger::_enabled);
    if ((v52 & 1) != 0)
      HGLogger::log((HGLogger *)"concat", (const char *)1, (HGLogger *)"testing concat chain:\n", (const char *)v11, v12);
    HGLogger::indent(1);
    v53 = (const char *)(*(uint64_t (**)(_QWORD *))(*v110 + 48))(v110);
    snprintf(__str, 0x100uLL, "node = %p (%s)\n", v110, v53);
    v56 = atomic_load(HGLogger::_enabled);
    if ((v56 & 1) != 0)
      HGLogger::log((HGLogger *)"concat", (const char *)1, (HGLogger *)"%s", v54, v55, __str);
    HGString::HGString((HGString *)v111);
    if ((_DWORD)v9)
    {
      v57 = 0;
      v58 = 16;
      v59 = 1;
      do
      {
        if ((_DWORD)v9 - 1 == v57 && *((unsigned __int16 *)v109 + 26) <= v9)
          v59 = 1;
        if (((a4 >> v57) & 1) != 0)
        {
          v60 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)(v110[10] + 8 * v57) + 16) + 144);
          v61 = (const char *)(*(uint64_t (**)(_QWORD *))(*v60 + 48))(v60);
          snprintf(__str, 0x100uLL, "input #%d = %p (%s)\n", v57, v60, v61);
          v64 = atomic_load(HGLogger::_enabled);
          if ((v64 & 1) != 0)
            HGLogger::log((HGLogger *)"concat", (const char *)1, (HGLogger *)"%s", v62, v63, __str);
          HGString::push((HGString *)v111, (HGShaderBinding *)(v110[37] + v58), (const HGString *)(v60[8] + 64), v103, (v59 & 1) == 0, 0);
        }
        else if (((a4 >> v57) & 0xFFFFFFFE) != 0)
        {
          HGString::push((HGString *)v111, 0);
          v59 = 0;
        }
        ++v57;
        v58 += 56;
      }
      while (v9 != v57);
    }
    HGLogger::indent(0xFFFFFFFFLL);
    v25 = v100;
    while (1)
    {
      if ((int)v9 >= 1)
      {
        while (((a4 >> v9) & 1) == 0)
        {
          v65 = __OFSUB__((_DWORD)v9, 1);
          LODWORD(v9) = v9 - 1;
          if (((int)v9 < 0) ^ v65 | ((_DWORD)v9 == 0))
          {
            LODWORD(v9) = 0;
            break;
          }
        }
      }
      v66 = 1 << v9;
      if (HGString::pop((HGString *)v111, (HGShaderBinding *)&v113, (HGString::Digest *)((char *)v109 + 64), a4, 0) != -1&& (v66 & v101) == 0&& !(*(unsigned int (**)(HGRenderer *, _BYTE *, _QWORD, uint64_t *))(*(_QWORD *)v100 + 408))(v100, v111, 0, &v112))
      {
        v78 = atomic_load(HGLogger::_enabled);
        if ((v78 & 1) != 0)
          HGLogger::log((HGLogger *)"concat", (const char *)1, (HGLogger *)"concat chain OK!!\n", v67, v68);
        v70 = v110;
        v110[8] = v112;
        v79 = v114;
        *(_OWORD *)v99 = v113;
        *((_OWORD *)v99 + 1) = v79;
        *((_DWORD *)v99 + 8) = v115;
        if ((a4 & 1) != 0)
        {
          v85 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v110[10] + 16) + 144);
          v71 = (_QWORD *)v110[37];
          *v71 = v85;
          v80 = *(_QWORD *)(v85 + 64);
        }
        else
        {
          v80 = 0;
          v71 = (_QWORD *)v110[37];
        }
        v71[1] = v80;
        if ((a4 & 2) != 0)
        {
          v87 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v110[10] + 8) + 16) + 144);
          v71[7] = v87;
          v86 = *(_QWORD *)(v87 + 64);
        }
        else
        {
          v86 = 0;
        }
        v71[8] = v86;
        if ((a4 & 4) != 0)
        {
          v89 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v110[10] + 16) + 16) + 144);
          v71[14] = v89;
          v88 = *(_QWORD *)(v89 + 64);
        }
        else
        {
          v88 = 0;
        }
        v71[15] = v88;
        if ((a4 & 8) != 0)
        {
          v91 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v110[10] + 24) + 16) + 144);
          v71[21] = v91;
          v90 = *(_QWORD *)(v91 + 64);
        }
        else
        {
          v90 = 0;
        }
        v71[22] = v90;
        if ((a4 & 0x10) != 0)
        {
          v93 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v110[10] + 32) + 16) + 144);
          v71[28] = v93;
          v92 = *(_QWORD *)(v93 + 64);
        }
        else
        {
          v92 = 0;
        }
        v71[29] = v92;
        if ((a4 & 0x20) != 0)
        {
          v95 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v110[10] + 40) + 16) + 144);
          v71[35] = v95;
          v94 = *(_QWORD *)(v95 + 64);
        }
        else
        {
          v94 = 0;
        }
        v71[36] = v94;
        if ((a4 & 0x40) != 0)
        {
          v97 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v110[10] + 48) + 16) + 144);
          v71[42] = v97;
          v96 = *(_QWORD *)(v97 + 64);
        }
        else
        {
          v96 = 0;
        }
        v71[43] = v96;
        if ((a4 & 0x80) != 0)
          goto LABEL_129;
        goto LABEL_158;
      }
      a4 = (const char *)(a4 & ~v66);
      if (!(_DWORD)a4)
      {
        HGString::~HGString((HGString *)v111);
        goto LABEL_105;
      }
      if ((_DWORD)a4 == v98)
        break;
      HGString::undo((HGString *)v111);
    }
    if ((v98 & 1) != 0)
    {
      v70 = v110;
      v81 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v110[10] + 16) + 144);
      v71 = (_QWORD *)v110[37];
      *v71 = v81;
      v71[1] = *(_QWORD *)(v81 + 64);
      if ((v98 & 2) == 0)
        goto LABEL_123;
LABEL_111:
      v72 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v70[10] + 8) + 16) + 144);
      v71[7] = v72;
      v71[8] = *(_QWORD *)(v72 + 64);
      if ((v98 & 4) != 0)
        goto LABEL_112;
LABEL_124:
      v71[15] = 0;
      if ((v98 & 8) == 0)
        goto LABEL_125;
LABEL_113:
      v74 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v70[10] + 24) + 16) + 144);
      v71[21] = v74;
      v71[22] = *(_QWORD *)(v74 + 64);
      if ((v98 & 0x10) != 0)
        goto LABEL_114;
LABEL_126:
      v71[29] = 0;
      if ((v98 & 0x20) == 0)
        goto LABEL_127;
LABEL_115:
      v76 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v70[10] + 40) + 16) + 144);
      v71[35] = v76;
      v71[36] = *(_QWORD *)(v76 + 64);
      if ((v98 & 0x40) != 0)
        goto LABEL_116;
LABEL_128:
      v71[43] = 0;
      if ((v98 & 0x80) != 0)
      {
LABEL_129:
        v82 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v70[10] + 56) + 16) + 144);
        v71[49] = v82;
        v83 = *(_QWORD *)(v82 + 64);
        goto LABEL_159;
      }
    }
    else
    {
      v70 = v110;
      v71 = (_QWORD *)v110[37];
      v71[1] = 0;
      if ((v98 & 2) != 0)
        goto LABEL_111;
LABEL_123:
      v71[8] = 0;
      if ((v98 & 4) == 0)
        goto LABEL_124;
LABEL_112:
      v73 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v70[10] + 16) + 16) + 144);
      v71[14] = v73;
      v71[15] = *(_QWORD *)(v73 + 64);
      if ((v98 & 8) != 0)
        goto LABEL_113;
LABEL_125:
      v71[22] = 0;
      if ((v98 & 0x10) == 0)
        goto LABEL_126;
LABEL_114:
      v75 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v70[10] + 32) + 16) + 144);
      v71[28] = v75;
      v71[29] = *(_QWORD *)(v75 + 64);
      if ((v98 & 0x20) != 0)
        goto LABEL_115;
LABEL_127:
      v71[36] = 0;
      if ((v98 & 0x40) == 0)
        goto LABEL_128;
LABEL_116:
      v77 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v70[10] + 48) + 16) + 144);
      v71[42] = v77;
      v71[43] = *(_QWORD *)(v77 + 64);
      if ((v98 & 0x80) != 0)
        goto LABEL_129;
    }
LABEL_158:
    v83 = 0;
LABEL_159:
    v71[50] = v83;
    HGString::~HGString((HGString *)v111);
    return 1;
  }
  if ((a4 & 1) != 0)
  {
    v84 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v36[10] + 16) + 144);
    v44 = (_QWORD *)v36[37];
    *v44 = v84;
    v44[1] = *(_QWORD *)(v84 + 64);
    if ((a4 & 2) == 0)
      goto LABEL_131;
LABEL_69:
    v45 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v36[10] + 8) + 16) + 144);
    v44[7] = v45;
    v44[8] = *(_QWORD *)(v45 + 64);
    if ((a4 & 4) != 0)
      goto LABEL_70;
LABEL_132:
    v44[15] = 0;
    if ((a4 & 8) == 0)
      goto LABEL_133;
LABEL_71:
    v47 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v36[10] + 24) + 16) + 144);
    v44[21] = v47;
    v44[22] = *(_QWORD *)(v47 + 64);
    if ((a4 & 0x10) != 0)
      goto LABEL_72;
LABEL_134:
    v44[29] = 0;
    if ((a4 & 0x20) == 0)
      goto LABEL_135;
LABEL_73:
    v49 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v36[10] + 40) + 16) + 144);
    v44[35] = v49;
    v44[36] = *(_QWORD *)(v49 + 64);
    if ((a4 & 0x40) != 0)
      goto LABEL_74;
LABEL_136:
    v44[43] = 0;
    if ((a4 & 0x80) == 0)
      goto LABEL_137;
LABEL_75:
    v51 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v36[10] + 56) + 16) + 144);
    v44[49] = v51;
    v44[50] = *(_QWORD *)(v51 + 64);
  }
  else
  {
    v44 = (_QWORD *)v36[37];
    v44[1] = 0;
    if ((a4 & 2) != 0)
      goto LABEL_69;
LABEL_131:
    v44[8] = 0;
    if ((a4 & 4) == 0)
      goto LABEL_132;
LABEL_70:
    v46 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v36[10] + 16) + 16) + 144);
    v44[14] = v46;
    v44[15] = *(_QWORD *)(v46 + 64);
    if ((a4 & 8) != 0)
      goto LABEL_71;
LABEL_133:
    v44[22] = 0;
    if ((a4 & 0x10) == 0)
      goto LABEL_134;
LABEL_72:
    v48 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v36[10] + 32) + 16) + 144);
    v44[28] = v48;
    v44[29] = *(_QWORD *)(v48 + 64);
    if ((a4 & 0x20) != 0)
      goto LABEL_73;
LABEL_135:
    v44[36] = 0;
    if ((a4 & 0x40) == 0)
      goto LABEL_136;
LABEL_74:
    v50 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v36[10] + 48) + 16) + 144);
    v44[42] = v50;
    v44[43] = *(_QWORD *)(v50 + 64);
    if ((a4 & 0x80) != 0)
      goto LABEL_75;
LABEL_137:
    v44[50] = 0;
  }
  return 1;
}

void sub_1B2A30AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A30AE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A30AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::Concatenate(HGGPURenderer *this, HGNode *a2, unsigned int a3)
{
  unint64_t i;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL IsMergeable;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  _QWORD *v18;
  HGShaderBinding *v19;
  uint64_t *v20;
  __n128 v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  HGProgramDescriptor *v27;
  BOOL v28;
  uint64_t v29;
  __int16 v30;
  char v31;
  int v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  _BOOL4 v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  HGProgramDescriptor *v51;
  uint64_t v52;
  __int16 v53;
  char v54;
  int v55;
  int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  HGProgramDescriptor *v60;
  int v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  _DWORD *v68;
  uint64_t v69;
  uint64_t v70;
  int v72;
  int v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  uint32x2_t v77[4];
  unsigned __int16 v78;
  unsigned __int8 v79;
  HGProgramDescriptor *v80;
  HGProgramDescriptor *v81[2];
  __int128 v82;
  __int128 v83;
  char v84[36];
  unsigned __int16 v85;
  unsigned __int8 v86;
  HGProgramDescriptor *v87;

  HGNode::GetProgramDescriptor(a2, &v87);
  HGProgramDescriptor::GetSignature(v87, (uint64_t)v84);
  if (v86)
  {
    for (i = 0; i < v86; ++i)
    {
      if ((a3 & (1 << i)) != 0)
      {
        v7 = *((_QWORD *)a2 + 10);
        if (!v7)
          goto LABEL_3;
        v8 = *(_QWORD *)(v7 + 8 * i);
        if (!v8)
          goto LABEL_3;
        v9 = *(_QWORD *)(v8 + 16);
        if (!v9)
          goto LABEL_3;
        HGNode::GetProgramDescriptor(*(HGNode **)(v9 + 144), v81);
        if (!v81[0])
          goto LABEL_3;
        IsMergeable = HGProgramDescriptor::IsMergeable(v81[0]);
        if (v81[0])
          (*(void (**)(HGProgramDescriptor *))(*(_QWORD *)v81[0] + 24))(v81[0]);
        if (!IsMergeable)
LABEL_3:
          a3 &= ~(1 << i);
      }
      v6 = v86;
    }
  }
  else
  {
    v6 = 0;
  }
  v11 = *((_QWORD *)a2 + 37);
  v12 = *((_QWORD *)a2 + 38) - v11;
  if (v12)
  {
    v13 = v12 / 56;
    if (v13 <= 1)
      v13 = 1;
    if (v13 < 2)
    {
      v14 = 0;
LABEL_23:
      v17 = v13 - v14;
      v18 = (_QWORD *)(v11 + 56 * v14);
      do
      {
        *v18 = 0;
        v18 += 7;
        --v17;
      }
      while (v17);
      goto LABEL_25;
    }
    v14 = v13 & 0xFFFFFFFFFFFFFFFELL;
    v15 = v13 & 0xFFFFFFFFFFFFFFFELL;
    v16 = (_QWORD *)*((_QWORD *)a2 + 37);
    do
    {
      *v16 = 0;
      v16[7] = 0;
      v16 += 14;
      v15 -= 2;
    }
    while (v15);
    if (v13 != v14)
      goto LABEL_23;
  }
LABEL_25:
  v19 = (HGShaderBinding *)((char *)a2 + 260);
  *((_DWORD *)a2 + 71) = 0;
  if (!a3 || (v20 = (uint64_t *)*((_QWORD *)a2 + 10)) == 0)
  {
LABEL_75:
    v21.n128_f64[0] = HGShaderBinding::reset(v19);
    v59 = 0;
    v60 = v87;
    if (!v87)
      return v59;
    goto LABEL_89;
  }
  v21.n128_u64[1] = 0;
  v82 = 0u;
  v83 = 0u;
  *(_OWORD *)v81 = 0u;
  if (!v6)
  {
    v32 = 0;
LABEL_78:
    v38 = 0;
    v39 = BYTE4(v83) - v32;
    goto LABEL_79;
  }
  v73 = v85;
  if ((a3 & 1) != 0)
  {
    v22 = *v20;
    if (v22)
    {
      v23 = *(_QWORD *)(v22 + 16);
      if (v23)
      {
        HGNode::GetProgramDescriptor(*(HGNode **)(v23 + 144), &v80);
        HGProgramDescriptor::GetSignature(v80, (uint64_t)v77);
        v24 = BYTE8(v83);
        if (v6 + v79 + BYTE8(v83) <= 8 && (v25 = BYTE4(v83), v73 + v78 + BYTE4(v83) <= 8))
        {
          v33 = BYTE10(v83);
          v34 = WORD3(v82);
          v35 = HIDWORD(v83);
          v36 = *((_QWORD *)a2 + 37);
          *(_QWORD *)(v36 + 16) = 0;
          *(_DWORD *)(v36 + 24) = v25;
          *(_DWORD *)(v36 + 28) = v33;
          *(_DWORD *)(v36 + 32) = v34;
          *(_DWORD *)(v36 + 36) = v35;
          *(_DWORD *)(v36 + 40) = v24;
          *(_QWORD *)(v36 + 44) = 0xFFFFFFFFLL;
          HGProgramDescriptor::SetInput(v87, 0, &v80);
          v75 = 0u;
          v76 = 0u;
          v74 = 0u;
          merge(v77, (int8x8_t *)v81, (int8x8_t *)&v74, 0, 1);
          *(_OWORD *)v81 = v74;
          v82 = v75;
          v21.n128_u64[1] = *((_QWORD *)&v76 + 1);
          v83 = v76;
          v26 = 1;
          v27 = v80;
          if (!v80)
            goto LABEL_41;
        }
        else
        {
          v26 = 0;
          a3 &= ~1u;
          v27 = v80;
          if (!v80)
          {
LABEL_41:
            v72 = v26;
            v28 = (a3 & 1) == 0;
            if ((a3 & 1) != 0)
              goto LABEL_42;
            goto LABEL_36;
          }
        }
        (*(void (**)(HGProgramDescriptor *))(*(_QWORD *)v27 + 24))(v27);
        goto LABEL_41;
      }
    }
  }
  v72 = 0;
  v28 = (a3 & 1) == 0;
  if ((a3 & 1) != 0)
    goto LABEL_42;
LABEL_36:
  v29 = *((_QWORD *)a2 + 37);
  *(_QWORD *)(v29 + 16) = 0;
  *(_QWORD *)(v29 + 24) = 0;
  *(_DWORD *)(v29 + 40) = 0;
  *(_QWORD *)(v29 + 32) = 0;
  *(_QWORD *)(v29 + 44) = 0xFFFFFFFFLL;
  v30 = ++WORD2(v83);
  v31 = ++BYTE8(v83);
  ++BYTE11(v83);
  ++BYTE10(v83);
  if (WORD2(v83) <= 0xFFu)
    WORD2(v83) = (v30 << 12) | ((v31 & 0xF) << 8) | v30;
LABEL_42:
  if (v6 != 1)
  {
    v37 = 0;
    v40 = -1;
    v41 = 72;
    v42 = 1;
    v43 = v6;
    while (1)
    {
      v45 = v42 != v86 - 1 || v85 > v86;
      v46 = 1 << v42;
      if ((a3 & (1 << v42)) == 0)
        goto LABEL_66;
      v47 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * v42);
      if (!v47)
        goto LABEL_66;
      v48 = *(_QWORD *)(v47 + 16);
      if (!v48)
        goto LABEL_66;
      HGNode::GetProgramDescriptor(*(HGNode **)(v48 + 144), &v80);
      HGProgramDescriptor::GetSignature(v80, (uint64_t)v77);
      v49 = BYTE8(v83);
      if ((int)(v43 + v40 + v79 + BYTE8(v83)) <= 8)
      {
        v50 = BYTE4(v83);
        if (v73 + v40 + v78 + BYTE4(v83) < 9 && (!v45 || v79 <= 1u && v78 < 2u))
          break;
      }
      a3 &= ~v46;
      v51 = v80;
      if (v80)
        goto LABEL_65;
LABEL_66:
      if ((a3 & v46) == 0)
      {
        v52 = *((_QWORD *)a2 + 37) + v41;
        *(_QWORD *)v52 = 0;
        *(_QWORD *)(v52 + 8) = 0;
        *(_DWORD *)(v52 + 24) = 0;
        *(_QWORD *)(v52 + 16) = 0;
        *(_QWORD *)(v52 + 28) = 0xFFFFFFFFLL;
        v53 = ++WORD2(v83);
        v54 = ++BYTE8(v83);
        ++BYTE11(v83);
        ++BYTE10(v83);
        if (WORD2(v83) <= 0xFFu)
          WORD2(v83) = (v53 << 12) | ((v54 & 0xF) << 8) | v53;
        if (!v28)
          v37 = v42;
        v28 = 1;
      }
      ++v42;
      v41 += 56;
      --v40;
      if (v43 == v42)
        goto LABEL_44;
    }
    v55 = BYTE10(v83);
    v56 = WORD3(v82);
    v57 = HIDWORD(v83);
    v58 = *((_QWORD *)a2 + 37) + v41;
    *(_QWORD *)v58 = 0;
    *(_DWORD *)(v58 + 8) = v50;
    *(_DWORD *)(v58 + 12) = v55;
    *(_DWORD *)(v58 + 16) = v56;
    *(_DWORD *)(v58 + 20) = v57;
    *(_DWORD *)(v58 + 24) = v49;
    *(_QWORD *)(v58 + 28) = 0xFFFFFFFFLL;
    HGProgramDescriptor::SetInput(v87, v42, &v80);
    v75 = 0u;
    v76 = 0u;
    v74 = 0u;
    merge(v77, (int8x8_t *)v81, (int8x8_t *)&v74, v45, 1);
    *(_OWORD *)v81 = v74;
    v82 = v75;
    v21.n128_u64[1] = *((_QWORD *)&v76 + 1);
    v83 = v76;
    ++v72;
    v51 = v80;
    if (!v80)
      goto LABEL_66;
LABEL_65:
    (*(void (**)(HGProgramDescriptor *))(*(_QWORD *)v51 + 24))(v51);
    goto LABEL_66;
  }
  v37 = 0;
LABEL_44:
  if (!a3)
  {
    v19 = (HGShaderBinding *)((char *)a2 + 260);
    goto LABEL_75;
  }
  if (!v28)
  {
    v19 = (HGShaderBinding *)((char *)a2 + 260);
    v32 = v72;
    goto LABEL_78;
  }
  v19 = (HGShaderBinding *)((char *)a2 + 260);
  if (WORD2(v83) > 0xFFu)
  {
    v38 = (HIBYTE(WORD2(v83)) & 0xF) + ~v37;
    v39 = ~v37 + (WORD2(v83) >> 12);
  }
  else
  {
    v38 = BYTE8(v83) - v37;
    v39 = BYTE4(v83) - v37;
  }
LABEL_79:
  v61 = WORD3(v82);
  v62 = HIDWORD(v83);
  *(_QWORD *)v19 = 0;
  *((_DWORD *)a2 + 67) = v39;
  *((_DWORD *)a2 + 68) = 0;
  *((_DWORD *)a2 + 69) = v61;
  *((_DWORD *)a2 + 70) = v62;
  *((_DWORD *)a2 + 71) = v38;
  v21.n128_u64[0] = 0xFFFFFFFFLL;
  *((_QWORD *)a2 + 36) = 0xFFFFFFFFLL;
  v64 = *((_QWORD *)a2 + 37);
  v63 = *((_QWORD *)a2 + 38);
  v65 = v63 - v64;
  if (v63 != v64)
  {
    v66 = 0;
    v67 = v65 / 56;
    if (v67 <= 1)
      v67 = 1;
    v68 = (_DWORD *)(v64 + 36);
    do
    {
      while (1)
      {
        if (((a3 >> v66) & 1) != 0)
        {
          v69 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * v66);
          if (v69)
          {
            v70 = *(_QWORD *)(v69 + 16);
            if (v70)
              break;
          }
        }
        *(v68 - 1) = v61;
        *v68 = v62;
        ++v66;
        v68 += 14;
        if (v67 == v66)
          goto LABEL_88;
      }
      *(_QWORD *)(v68 - 9) = *(_QWORD *)(v70 + 144);
      ++v66;
      v68 += 14;
    }
    while (v67 != v66);
  }
LABEL_88:
  v59 = 1;
  v60 = v87;
  if (v87)
LABEL_89:
    (*(void (**)(HGProgramDescriptor *, __n128))(*(_QWORD *)v60 + 24))(v60, v21);
  return v59;
}

void sub_1B2A3116C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  uint64_t v27;
  uint64_t v29;

  if (a26)
    (*(void (**)(uint64_t))(*(_QWORD *)a26 + 24))(a26);
  v29 = *(_QWORD *)(v27 - 112);
  if (v29)
    (*(void (**)(uint64_t))(*(_QWORD *)v29 + 24))(v29);
  _Unwind_Resume(exception_object);
}

uint64_t HGColorGamma::RenderTile()
{
  return 0;
}

void HGColorGamma::HGColorGamma(HGColorGamma *this)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  char *v10;
  uint64_t v16;
  char *v17;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v2 = off_1E6520020;
  *(_QWORD *)(v2 + 544) = 0;
  *(_OWORD *)(v2 + 416) = 0u;
  *(_OWORD *)(v2 + 432) = 0u;
  *(_OWORD *)(v2 + 448) = 0u;
  *(_OWORD *)(v2 + 464) = 0u;
  *(_OWORD *)(v2 + 480) = 0u;
  *(_OWORD *)(v2 + 496) = 0u;
  *(_OWORD *)(v2 + 512) = 0u;
  *(_QWORD *)(v2 + 528) = 0;
  *(_OWORD *)(v2 + 560) = 0u;
  *(_OWORD *)(v2 + 576) = 0u;
  *(_OWORD *)(v2 + 592) = 0u;
  *(_OWORD *)(v2 + 608) = 0u;
  *(_OWORD *)(v2 + 624) = 0u;
  *(_OWORD *)(v2 + 640) = 0u;
  *(_OWORD *)(v2 + 656) = 0u;
  *(_OWORD *)(v2 + 672) = 0u;
  *(_OWORD *)(v2 + 688) = 0u;
  *(_OWORD *)(v2 + 704) = 0u;
  *(_OWORD *)(v2 + 720) = 0u;
  *(_OWORD *)(v2 + 729) = 0u;
  *(_OWORD *)(v2 + 752) = 0u;
  *(_WORD *)(v2 + 745) = 257;
  *(_DWORD *)(v2 + 1172) = 65793;
  *(_QWORD *)(v2 + 1156) = 0xBF00000040000000;
  *(_DWORD *)(v2 + 1152) = 1024;
  *(_QWORD *)(v2 + 1164) = 0x100000320;
  *(_WORD *)(v2 + 1024) = 0;
  *(_BYTE *)(v2 + 1026) = 0;
  *(_DWORD *)(v2 + 1036) = 1;
  *(_OWORD *)(v2 + 1040) = HGRectInfinite;
  *(_QWORD *)(v2 + 1056) = 0;
  *(_DWORD *)(v2 + 1064) = 0;
  *(_QWORD *)(v2 + 408) = 0;
  *(_BYTE *)(v2 + 880) = 0;
  HGNode::ClearBits((HGNode *)v2, v3, v4);
  *((_BYTE *)this + 745) = 1;
  HGNode::ClearBits((HGNode *)this, v5, v6);
  *((_BYTE *)this + 745) = 1;
  *((_OWORD *)this + 56) = xmmword_1B304F230;
  *((_OWORD *)this + 57) = xmmword_1B304F240;
  *((_OWORD *)this + 58) = xmmword_1B304F250;
  *((_OWORD *)this + 59) = xmmword_1B304EFF0;
  HGNode::ClearBits((HGNode *)this, v7, v8);
  *((_BYTE *)this + 745) = 1;
  *((_OWORD *)this + 60) = xmmword_1B304F230;
  *((_OWORD *)this + 61) = xmmword_1B304F240;
  *((_OWORD *)this + 62) = xmmword_1B304F250;
  *((_OWORD *)this + 63) = xmmword_1B304EFF0;
  HGNode::ClearBits((HGNode *)this, v9, v10);
  *((_BYTE *)this + 745) = 1;
  *(_QWORD *)((char *)this + 1028) = 0;
  __asm { FMOV            V0.4S, #1.0 }
  *((_OWORD *)this + 48) = _Q0;
  *((_OWORD *)this + 49) = 0u;
  *((_OWORD *)this + 50) = 0u;
  *((_OWORD *)this + 51) = 0u;
  *((_OWORD *)this + 52) = 0u;
  *((_OWORD *)this + 53) = 0u;
  *((_OWORD *)this + 54) = 0u;
  *((_BYTE *)this + 880) = 1;
  HGColorGamma::SetYCbCrBiasAndScale((HGNode *)this, v16, v17);
  *((_QWORD *)this + 147) = 0;
}

void sub_1B2A3139C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

double HGColorGamma::SetConversionPreset(uint64_t a1, uint64_t a2, char *a3)
{
  int v3;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  char *v10;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  __int128 v20;
  uint64_t v21;
  char *v22;
  float v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  int *v29;
  uint64_t v30;
  char *v31;
  __int128 v32;
  uint64_t v33;
  char *v34;
  float v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  char *v42;
  float v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  float v52;
  uint64_t v53;
  char *v54;
  int v55;
  double result;
  __int128 v57;

  v3 = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(_BYTE *)(a1 + 745) = 1;
  switch(v3)
  {
    case 0:
      HGNode::ClearBits((HGNode *)a1, v5, v6);
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B304F230;
      *(_OWORD *)(a1 + 912) = xmmword_1B304F240;
      *(_OWORD *)(a1 + 928) = xmmword_1B304F250;
      *(_OWORD *)(a1 + 944) = xmmword_1B304EFF0;
      HGNode::ClearBits((HGNode *)a1, v7, v8);
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 960) = xmmword_1B304F230;
      *(_OWORD *)(a1 + 976) = xmmword_1B304F240;
      *(_OWORD *)(a1 + 992) = xmmword_1B304F250;
      *(_OWORD *)(a1 + 1008) = xmmword_1B304EFF0;
      HGNode::ClearBits((HGNode *)a1, v9, v10);
      *(_BYTE *)(a1 + 745) = 1;
      *(_QWORD *)(a1 + 1028) = 0;
      __asm { FMOV            V0.4S, #1.0 }
      *(_OWORD *)(a1 + 768) = _Q0;
      *(_OWORD *)(a1 + 784) = 0u;
      *(_OWORD *)(a1 + 800) = 0u;
      *(_OWORD *)(a1 + 816) = 0u;
      *(_OWORD *)(a1 + 832) = 0u;
      *(_OWORD *)(a1 + 848) = 0u;
      *(_OWORD *)(a1 + 864) = 0u;
      *(_BYTE *)(a1 + 880) = 1;
      break;
    case 1:
      HGNode::ClearBits((HGNode *)a1, v5, v6);
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B309E0F0;
      *(_OWORD *)(a1 + 912) = xmmword_1B309E100;
      v57 = xmmword_1B304EFF0;
      *(_OWORD *)(a1 + 928) = xmmword_1B309E110;
      *(_OWORD *)(a1 + 944) = xmmword_1B304EFF0;
      HGNode::ClearBits((HGNode *)a1, v16, v17);
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 960) = xmmword_1B304F230;
      *(_OWORD *)(a1 + 976) = xmmword_1B304F240;
      v20 = xmmword_1B304F250;
      goto LABEL_5;
    case 2:
      HGNode::ClearBits((HGNode *)a1, v5, v6);
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B309E0F0;
      *(_OWORD *)(a1 + 912) = xmmword_1B309E100;
      v57 = xmmword_1B304EFF0;
      *(_OWORD *)(a1 + 928) = xmmword_1B309E110;
      *(_OWORD *)(a1 + 944) = xmmword_1B304EFF0;
      HGNode::ClearBits((HGNode *)a1, v21, v22);
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 960) = xmmword_1B309E120;
      *(_OWORD *)(a1 + 976) = xmmword_1B309E130;
      v20 = xmmword_1B309E140;
LABEL_5:
      *(_OWORD *)(a1 + 992) = v20;
      *(_OWORD *)(a1 + 1008) = v57;
      HGNode::ClearBits((HGNode *)a1, v18, v19);
      *(_BYTE *)(a1 + 745) = 1;
      *(_QWORD *)(a1 + 1028) = 6;
      __asm { FMOV            V0.4S, #1.0 }
      *(_OWORD *)(a1 + 768) = _Q0;
      *(_OWORD *)(a1 + 784) = 0u;
      *(_OWORD *)(a1 + 800) = 0u;
      *(_OWORD *)(a1 + 816) = 0u;
      *(_OWORD *)(a1 + 832) = 0u;
      *(_OWORD *)(a1 + 848) = 0u;
      *(_OWORD *)(a1 + 864) = 0u;
      *(_BYTE *)(a1 + 880) = 1;
      HGNode::ClearBits((HGNode *)a1, v25, v26);
      *(_BYTE *)(a1 + 745) = 1;
      v24 = 2.16 - -1.14;
      *(float *)(a1 + 1156) = v24;
      *(float *)(a1 + 1160) = -1.14;
      v29 = &HGAYCCToneCurveToLinearLUTInfo::s_1DLUTnumBins;
      goto LABEL_11;
    case 3:
      HGNode::ClearBits((HGNode *)a1, v5, v6);
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B304F230;
      *(_OWORD *)(a1 + 912) = xmmword_1B304F240;
      v32 = xmmword_1B304F250;
      goto LABEL_8;
    case 4:
      HGNode::ClearBits((HGNode *)a1, v5, v6);
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B309E0A0;
      *(_OWORD *)(a1 + 912) = xmmword_1B309E0B0;
      v32 = xmmword_1B309E0C0;
LABEL_8:
      *(_OWORD *)(a1 + 928) = v32;
      *(_OWORD *)(a1 + 944) = xmmword_1B304EFF0;
      HGNode::ClearBits((HGNode *)a1, v30, v31);
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 960) = xmmword_1B30516E0;
      *(_OWORD *)(a1 + 976) = xmmword_1B309E0D0;
      *(_OWORD *)(a1 + 992) = xmmword_1B309E0E0;
      *(_OWORD *)(a1 + 1008) = xmmword_1B304EFF0;
      HGNode::ClearBits((HGNode *)a1, v33, v34);
      *(_BYTE *)(a1 + 745) = 1;
      *(_QWORD *)(a1 + 1028) = 7;
      __asm { FMOV            V0.4S, #1.0 }
      *(_OWORD *)(a1 + 768) = _Q0;
      *(_OWORD *)(a1 + 784) = 0u;
      *(_OWORD *)(a1 + 800) = 0u;
      *(_OWORD *)(a1 + 816) = 0u;
      *(_OWORD *)(a1 + 832) = 0u;
      *(_OWORD *)(a1 + 848) = 0u;
      *(_OWORD *)(a1 + 864) = 0u;
      *(_BYTE *)(a1 + 880) = 1;
      HGNode::ClearBits((HGNode *)a1, v37, v38);
      *(_BYTE *)(a1 + 745) = 1;
      v36 = 1.42 - -0.18;
      *(float *)(a1 + 1156) = v36;
      *(float *)(a1 + 1160) = -0.18;
      v29 = &HGLinearToAYCCToneCurveLUTInfo::s_1DLUTnumBins;
      goto LABEL_11;
    case 5:
      HGNode::ClearBits((HGNode *)a1, v5, v6);
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B304F230;
      *(_OWORD *)(a1 + 912) = xmmword_1B304F240;
      *(_OWORD *)(a1 + 928) = xmmword_1B304F250;
      *(_OWORD *)(a1 + 944) = xmmword_1B304EFF0;
      HGNode::ClearBits((HGNode *)a1, v39, v40);
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 960) = xmmword_1B304F230;
      *(_OWORD *)(a1 + 976) = xmmword_1B304F240;
      *(_OWORD *)(a1 + 992) = xmmword_1B304F250;
      *(_OWORD *)(a1 + 1008) = xmmword_1B304EFF0;
      HGNode::ClearBits((HGNode *)a1, v41, v42);
      *(_BYTE *)(a1 + 745) = 1;
      *(_QWORD *)(a1 + 1028) = 8;
      __asm { FMOV            V0.4S, #1.0 }
      *(_OWORD *)(a1 + 768) = _Q0;
      *(_OWORD *)(a1 + 784) = 0u;
      *(_OWORD *)(a1 + 800) = 0u;
      *(_OWORD *)(a1 + 816) = 0u;
      *(_OWORD *)(a1 + 832) = 0u;
      *(_OWORD *)(a1 + 848) = 0u;
      *(_OWORD *)(a1 + 864) = 0u;
      *(_BYTE *)(a1 + 880) = 1;
      HGNode::ClearBits((HGNode *)a1, v45, v46);
      *(_BYTE *)(a1 + 745) = 1;
      v44 = 1.252941 - -0.752941;
      *(float *)(a1 + 1156) = v44;
      *(float *)(a1 + 1160) = -0.752941;
      v29 = &HG_ERsRGBToneCurveToLinearLUTInfo::s_1DLUTnumBins;
      goto LABEL_11;
    case 6:
      HGNode::ClearBits((HGNode *)a1, v5, v6);
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B304F230;
      *(_OWORD *)(a1 + 912) = xmmword_1B304F240;
      *(_OWORD *)(a1 + 928) = xmmword_1B304F250;
      *(_OWORD *)(a1 + 944) = xmmword_1B304EFF0;
      HGNode::ClearBits((HGNode *)a1, v47, v48);
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 960) = xmmword_1B304F230;
      *(_OWORD *)(a1 + 976) = xmmword_1B304F240;
      *(_OWORD *)(a1 + 992) = xmmword_1B304F250;
      *(_OWORD *)(a1 + 1008) = xmmword_1B304EFF0;
      HGNode::ClearBits((HGNode *)a1, v49, v50);
      *(_BYTE *)(a1 + 745) = 1;
      *(_QWORD *)(a1 + 1028) = 9;
      __asm { FMOV            V0.4S, #1.0 }
      *(_OWORD *)(a1 + 768) = _Q0;
      *(_OWORD *)(a1 + 784) = 0u;
      *(_OWORD *)(a1 + 800) = 0u;
      *(_OWORD *)(a1 + 816) = 0u;
      *(_OWORD *)(a1 + 832) = 0u;
      *(_OWORD *)(a1 + 848) = 0u;
      *(_OWORD *)(a1 + 864) = 0u;
      *(_BYTE *)(a1 + 880) = 1;
      HGNode::ClearBits((HGNode *)a1, v53, v54);
      *(_BYTE *)(a1 + 745) = 1;
      v52 = 1.67496694 - -0.527113747;
      *(float *)(a1 + 1156) = v52;
      *(float *)(a1 + 1160) = -0.527113747;
      v29 = &HGLinearToERsRGBToneCurveLUTInfo::s_1DLUTnumBins;
LABEL_11:
      v55 = *v29;
      HGNode::ClearBits((HGNode *)a1, v27, v28);
      *(_BYTE *)(a1 + 745) = 1;
      *(_DWORD *)(a1 + 1152) = v55;
      break;
    default:
      break;
  }
  *(_QWORD *)&result = HGColorGamma::SetYCbCrBiasAndScale((HGNode *)a1, v5, v6).n128_u64[0];
  return result;
}

uint64_t HGColorGamma::ReleaseNodes(HGColorGamma *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t result;

  v2 = *((_QWORD *)this + 53);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    *((_QWORD *)this + 53) = 0;
  }
  v3 = *((_QWORD *)this + 54);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
    *((_QWORD *)this + 54) = 0;
  }
  v4 = *((_QWORD *)this + 57);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
    *((_QWORD *)this + 57) = 0;
  }
  v5 = *((_QWORD *)this + 55);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    *((_QWORD *)this + 55) = 0;
  }
  v6 = *((_QWORD *)this + 56);
  if (v6)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
    *((_QWORD *)this + 56) = 0;
  }
  v7 = *((_QWORD *)this + 58);
  if (v7)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
    *((_QWORD *)this + 58) = 0;
  }
  v8 = *((_QWORD *)this + 80);
  if (v8)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
    *((_QWORD *)this + 80) = 0;
  }
  v9 = *((_QWORD *)this + 81);
  if (v9)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
    *((_QWORD *)this + 81) = 0;
  }
  v10 = *((_QWORD *)this + 82);
  if (v10)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
    *((_QWORD *)this + 82) = 0;
  }
  v11 = *((_QWORD *)this + 83);
  if (v11)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
    *((_QWORD *)this + 83) = 0;
  }
  v12 = *((_QWORD *)this + 84);
  if (v12)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
    *((_QWORD *)this + 84) = 0;
  }
  v13 = *((_QWORD *)this + 85);
  if (v13)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
    *((_QWORD *)this + 85) = 0;
  }
  v14 = *((_QWORD *)this + 86);
  if (v14)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
    *((_QWORD *)this + 86) = 0;
  }
  v15 = *((_QWORD *)this + 87);
  if (v15)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 24))(v15);
    *((_QWORD *)this + 87) = 0;
  }
  v16 = *((_QWORD *)this + 88);
  if (v16)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
    *((_QWORD *)this + 88) = 0;
  }
  v17 = *((_QWORD *)this + 89);
  if (v17)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
    *((_QWORD *)this + 89) = 0;
  }
  v18 = *((_QWORD *)this + 59);
  if (v18)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
    *((_QWORD *)this + 59) = 0;
  }
  v19 = *((_QWORD *)this + 60);
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 24))(v19);
    *((_QWORD *)this + 60) = 0;
  }
  v20 = *((_QWORD *)this + 62);
  if (v20)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 24))(v20);
    *((_QWORD *)this + 62) = 0;
  }
  v21 = *((_QWORD *)this + 61);
  if (v21)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
    *((_QWORD *)this + 61) = 0;
  }
  v22 = *((_QWORD *)this + 63);
  if (v22)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 24))(v22);
    *((_QWORD *)this + 63) = 0;
  }
  v23 = *((_QWORD *)this + 64);
  if (v23)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 24))(v23);
    *((_QWORD *)this + 64) = 0;
  }
  v24 = *((_QWORD *)this + 65);
  if (v24)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v24 + 24))(v24);
    *((_QWORD *)this + 65) = 0;
  }
  v25 = *((_QWORD *)this + 70);
  if (v25)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v25 + 24))(v25);
    *((_QWORD *)this + 70) = 0;
  }
  v26 = *((_QWORD *)this + 71);
  if (v26)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v26 + 24))(v26);
    *((_QWORD *)this + 71) = 0;
  }
  v27 = *((_QWORD *)this + 66);
  if (v27)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 24))(v27);
    *((_QWORD *)this + 66) = 0;
  }
  v28 = *((_QWORD *)this + 68);
  if (v28)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v28 + 24))(v28);
    *((_QWORD *)this + 68) = 0;
  }
  v29 = *((_QWORD *)this + 72);
  if (v29)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v29 + 24))(v29);
    *((_QWORD *)this + 72) = 0;
  }
  v30 = *((_QWORD *)this + 73);
  if (v30)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v30 + 24))(v30);
    *((_QWORD *)this + 73) = 0;
  }
  v31 = *((_QWORD *)this + 74);
  if (v31)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v31 + 24))(v31);
    *((_QWORD *)this + 74) = 0;
  }
  v32 = *((_QWORD *)this + 75);
  if (v32)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v32 + 24))(v32);
    *((_QWORD *)this + 75) = 0;
  }
  v33 = *((_QWORD *)this + 76);
  if (v33)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v33 + 24))(v33);
    *((_QWORD *)this + 76) = 0;
  }
  v34 = *((_QWORD *)this + 77);
  if (v34)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v34 + 24))(v34);
    *((_QWORD *)this + 77) = 0;
  }
  v35 = *((_QWORD *)this + 79);
  if (v35)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v35 + 24))(v35);
    *((_QWORD *)this + 79) = 0;
  }
  v36 = *((_QWORD *)this + 78);
  if (v36)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v36 + 24))(v36);
    *((_QWORD *)this + 78) = 0;
  }
  v37 = *((_QWORD *)this + 90);
  if (v37)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v37 + 24))(v37);
    *((_QWORD *)this + 90) = 0;
  }
  v38 = *((_QWORD *)this + 91);
  if (v38)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v38 + 24))(v38);
    *((_QWORD *)this + 91) = 0;
  }
  v39 = *((_QWORD *)this + 92);
  if (v39)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v39 + 24))(v39);
    *((_QWORD *)this + 92) = 0;
  }
  result = *((_QWORD *)this + 51);
  if (result)
  {
    result = MEMORY[0x1B5E29170](result, 0x1000C4028F2CA5ALL);
    *((_QWORD *)this + 51) = 0;
  }
  return result;
}

void HGColorGamma::~HGColorGamma(HGColorGamma *this)
{
  *(_QWORD *)this = off_1E6520020;
  HGColorGamma::ReleaseNodes(this);
  HGNode::~HGNode((HGNode *)this);
}

{
  void *v2;

  *(_QWORD *)this = off_1E6520020;
  HGColorGamma::ReleaseNodes(this);
  HGNode::~HGNode((HGNode *)this);
  HGObject::operator delete(v2);
}

uint64_t HGColorGamma::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

uint64_t HGColorGamma::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3 || *(_QWORD *)(a1 + 416))
    return 0;
  else
    return a4;
}

HGColorGamma *HGColorGamma::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGColorGamma *v3;
  HGNode *Input;
  int8x16_t v5;
  int8x16_t v6;
  int8x16_t v7;
  char *v8;
  _OWORD *v9;
  HGNode *v10;
  uint64_t v11;
  uint64_t v12;
  HGNode *v13;
  HgcColorGamma_2vuy_yxzx_expand *v14;
  int v15;
  int BitmapFormat;
  HGNode *v17;
  int v18;
  int v19;
  HGHLG::OETF *HDRFunctionNode;
  int8x16_t v21;
  char v22;
  HGApply1DLUT *v23;
  uint64_t v24;
  HGRenderer *v25;
  HgcColorGamma_v210_yxzx_rgba_expand *v26;
  HGGamma *GammaUniformNode;
  HGNode *GammaFittedNode;
  char *v29;
  HgcColorGamma_chroma_upsample_f1 *v30;
  void (*v31)(HgcColorGamma_chroma_upsample_f1 *, _QWORD, HgcColorGamma_2vuy_yxzx_expand *);
  char *v32;
  int8x16_t v33;
  float32x4_t v39;
  int8x16_t v40;
  int8x16_t v42;
  HgcColorGamma_bias *v43;
  void (**v44)(HGCColorGamma_bias *__hidden);
  void (**v45)(HGCColorGamma_bias *__hidden);
  void (**v46)(HGCColorGamma_bias *__hidden);
  HgcColorGamma_chroma_upsample_f1 *v47;
  void (*v48)(HgcColorGamma_chroma_upsample_f1 *, _QWORD, HgcColorGamma_chroma_upsample_f1 *);
  HGColorMatrix *v49;
  char v50;
  char v51;
  HGColorMatrix *v52;
  HgcUnpremultiplySanitized *UnpremultiplyNode;
  HGColorMatrix *v54;
  uint64_t v55;
  HGColorMatrix *v56;
  HGColorMatrix *v57;
  HGColorMatrix *v58;
  uint64_t v59;
  uint64_t v60;
  HGColorMatrix *v61;
  char v62;
  HgcPremultiply *v63;
  HGColorMatrix *v64;
  HgcPremultiply *v65;
  int8x16_t v66;
  int8x16_t v68;
  int8x16_t v70;
  HgcColorGamma_bias *v71;
  void (**v72)(HGCColorGamma_bias *__hidden);
  void (**v73)(HGCColorGamma_bias *__hidden);
  char *v74;
  HGDither *v75;
  HGDither *v76;
  char *v77;
  HgcPixelFormatConversion_kV4B_WXYZ_output *PixelFormatConversion_kV4B_WXYZ_OutputNode;
  HgcPixelFormatConversion_kV4B_WXYZ_output *v79;
  HgcPixelFormatConversion_kV4S_WXYZ_output *PixelFormatConversion_kV4S_WXYZ_OutputNode;
  HgcPixelFormatConversion_kV4F_WXYZ_output *PixelFormatConversion_kV4F_WXYZ_OutputNode;
  HGCrop *v82;
  char *v83;
  char *v84;
  HgcColorGamma_chroma_downsample_f1 *v85;
  void (**v86)(HGCColorGamma_chroma_downsample_f1 *__hidden);
  HgcPixelFormatConversion_kV4B10Bit_BE_output *PixelFormatConversion_kV4B10Bit_BE_OutputNode;
  HgcPixelFormatConversion_kV4S_BE_WXYZ_output *PixelFormatConversion_kV4S_BE_WXYZ_OutputNode;
  char *v89;
  HgcColorGamma_2vuy_yxzx_collapse *v90;
  __n128 v92;
  float32x4_t v93;
  __n128 v94;
  float v95[6];
  HGNode *v96;

  v3 = (HGColorGamma *)this;
  Input = HGRenderer::GetInput(a2, this, 0);
  v96 = Input;
  if (!Input)
    return 0;
  if (*((_DWORD *)Input + 3) == 1112363084 && !*((_DWORD *)v3 + 257))
  {
    v5 = vmvnq_s8((int8x16_t)vceqq_f32(vmulq_f32(*((float32x4_t *)v3 + 48), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B3051560));
    *(int32x2_t *)v5.i8 = vpmin_s32(*(int32x2_t *)v5.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v5, v5, 8uLL));
    if (!vpmin_s32(*(int32x2_t *)v5.i8, *(int32x2_t *)v5.i8).u32[0])
    {
      v6 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 57), (float32x4_t)xmmword_1B304F240), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 56), (float32x4_t)xmmword_1B304F230)), vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 58), (float32x4_t)xmmword_1B304F250), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 59), (float32x4_t)xmmword_1B304EFF0))))));
      *(int32x2_t *)v6.i8 = vpmin_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
      if (!vpmin_s32(*(int32x2_t *)v6.i8, *(int32x2_t *)v6.i8).u32[0])
      {
        v7 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 61), (float32x4_t)xmmword_1B304F240), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 60), (float32x4_t)xmmword_1B304F230)), vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 62), (float32x4_t)xmmword_1B304F250), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 63), (float32x4_t)xmmword_1B304EFF0))))));
        *(int32x2_t *)v7.i8 = vpmin_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
        if (!vpmin_s32(*(int32x2_t *)v7.i8, *(int32x2_t *)v7.i8).u32[0])
          *((_QWORD *)v3 + 147) = Input;
      }
    }
  }
  HGColorGamma::ConcatenateWithUpstreamNode((HGNode *)v3, a2, &v96);
  if (*((_BYTE *)v3 + 745))
  {
    HGColorGamma::ReleaseNodes(v3);
    v9 = (_OWORD *)operator new();
    *v9 = 0u;
    v9[1] = 0u;
    v9[2] = 0u;
    v9[3] = 0u;
    v9[4] = 0u;
    v9[5] = 0u;
    v9[6] = 0u;
    v9[7] = 0u;
    v9[8] = 0u;
    v9[9] = 0u;
    v9[10] = 0u;
    v9[11] = 0u;
    v9[12] = 0u;
    v9[13] = 0u;
    v9[14] = 0u;
    v9[15] = 0u;
    v9[16] = 0u;
    v9[17] = 0u;
    v9[18] = 0u;
    *((_QWORD *)v3 + 51) = v9;
    HGColorGamma::ScaleParams((float32x4_t *)v3, v10, a2);
    *((_WORD *)v3 + 372) = 0;
    *((_BYTE *)v3 + 746) = 1;
  }
  else if (*((_BYTE *)v3 + 744)
         && !*((_BYTE *)v3 + 1024)
         && (*(unsigned int (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2))
  {
    *((_QWORD *)v3 + 52) = HGBitmapLoader::GetBitmapPtr((HGBitmapLoader *)v96);
    return v3;
  }
  if (!*((_BYTE *)v3 + 746))
  {
    (*(void (**)(_QWORD, _QWORD, HGNode *))(**((_QWORD **)v3 + 94) + 120))(*((_QWORD *)v3 + 94), 0, v96);
    return (HGColorGamma *)*((_QWORD *)v3 + 95);
  }
  *((_BYTE *)v3 + 746) = 0;
  v11 = *((int *)v3 + 265);
  if (v11 > 0x1A)
  {
    v12 = 1;
    v13 = v96;
    if (*((_DWORD *)v96 + 3) != 1112363084)
    {
LABEL_27:
      v15 = 0;
      v14 = 0;
LABEL_28:
      v17 = (HGNode *)*((_QWORD *)v3 + 94);
      if (v17)
      {
LABEL_29:
        if (*((_BYTE *)v3 + 1026))
          HGNode::SetSupportedFormatPrecisions(v17, (const char *)v12, v8);
      }
      goto LABEL_31;
    }
  }
  else
  {
    v12 = dword_1B309F468[v11];
    v13 = v96;
    if (*((_DWORD *)v96 + 3) != 1112363084)
      goto LABEL_27;
  }
  v14 = 0;
  v15 = 0;
  BitmapFormat = HGBitmapLoader::GetBitmapFormat((HGBitmapLoader *)v13);
  switch(BitmapFormat)
  {
    case 14:
      if (*((_DWORD *)v3 + 265) != 1)
        goto LABEL_27;
      if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) != 0)
        goto LABEL_80;
      v14 = (HgcColorGamma_2vuy_yxzx_expand *)*((_QWORD *)v3 + 59);
      if (!v14)
      {
        v14 = (HgcColorGamma_2vuy_yxzx_expand *)HGObject::operator new(0x1A0uLL);
        *(_OWORD *)v14 = 0u;
        *((_OWORD *)v14 + 1) = 0u;
        *((_OWORD *)v14 + 2) = 0u;
        *((_OWORD *)v14 + 3) = 0u;
        *((_OWORD *)v14 + 4) = 0u;
        *((_OWORD *)v14 + 5) = 0u;
        *((_OWORD *)v14 + 6) = 0u;
        *((_OWORD *)v14 + 7) = 0u;
        *((_OWORD *)v14 + 8) = 0u;
        *((_OWORD *)v14 + 9) = 0u;
        *((_OWORD *)v14 + 10) = 0u;
        *((_OWORD *)v14 + 11) = 0u;
        *((_OWORD *)v14 + 12) = 0u;
        *((_OWORD *)v14 + 13) = 0u;
        *((_OWORD *)v14 + 14) = 0u;
        *((_OWORD *)v14 + 15) = 0u;
        *((_OWORD *)v14 + 16) = 0u;
        *((_OWORD *)v14 + 17) = 0u;
        *((_OWORD *)v14 + 18) = 0u;
        *((_OWORD *)v14 + 19) = 0u;
        *((_OWORD *)v14 + 20) = 0u;
        *((_OWORD *)v14 + 21) = 0u;
        *((_OWORD *)v14 + 22) = 0u;
        *((_OWORD *)v14 + 23) = 0u;
        *((_OWORD *)v14 + 24) = 0u;
        *((_OWORD *)v14 + 25) = 0u;
        HgcColorGamma_2vuy_yxzx_expand::HgcColorGamma_2vuy_yxzx_expand(v14);
        *(_QWORD *)v14 = off_1E6520518;
        *((_QWORD *)v3 + 59) = v14;
      }
      goto LABEL_98;
    case 15:
      if (*((_DWORD *)v3 + 265) != 1)
        goto LABEL_27;
      goto LABEL_79;
    case 16:
      if (*((_DWORD *)v3 + 265) != 3)
        goto LABEL_27;
      goto LABEL_79;
    case 31:
      if (*((_DWORD *)v3 + 265) != 2)
        goto LABEL_27;
LABEL_79:
      if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) != 0)
      {
LABEL_80:
        v14 = 0;
        v15 = 1;
        v17 = (HGNode *)*((_QWORD *)v3 + 94);
        if (v17)
          goto LABEL_29;
      }
      else
      {
        if (BitmapFormat == 31)
        {
          v26 = HGColorGamma::m_Getv210_YXZXExpandNode(v3, v25);
        }
        else if (BitmapFormat == 15)
        {
          v26 = HGColorGamma::m_Get2vuy_XYXZExpandNode(v3);
        }
        else
        {
          v26 = HGColorGamma::m_Getv216_YXZXExpandNode(v3);
        }
        v14 = v26;
LABEL_98:
        (*(void (**)(HgcColorGamma_2vuy_yxzx_expand *, _QWORD, HGNode *))(*(_QWORD *)v14 + 120))(v14, 0, v13);
        *((_QWORD *)v3 + 94) = v14;
        v15 = 1;
        v17 = (HGNode *)v14;
        if (v14)
          goto LABEL_29;
      }
      break;
    default:
      goto LABEL_28;
  }
LABEL_31:
  switch(*((_DWORD *)v3 + 264))
  {
    case 0xE:
    case 0xF:
      if (*((_DWORD *)v3 + 266) == 1)
        goto LABEL_33;
      break;
    case 0x10:
      if (*((_DWORD *)v3 + 266) == 3)
        goto LABEL_33;
      break;
    case 0x1F:
      if (*((_DWORD *)v3 + 266) == 2)
LABEL_33:
        *((_BYTE *)v3 + 1173) = 1;
      break;
    default:
      break;
  }
  v18 = *((_DWORD *)v3 + 257);
  if (v18)
  {
    if (v18 > 4)
    {
      if (v18 >= 0xA)
      {
        HDRFunctionNode = HGColorGamma::m_GetHDRFunctionNode((uint64_t)v3, v18);
        goto LABEL_53;
      }
LABEL_61:
      v23 = (HGApply1DLUT *)*((_QWORD *)v3 + 80);
      if (!v23)
      {
        v23 = (HGApply1DLUT *)HGObject::operator new(0x1D0uLL);
        HGApply1DLUT::HGApply1DLUT(v23, *((_DWORD *)v3 + 288), *((float *)v3 + 289), *((float *)v3 + 290), 1, 1, 1, 0, 1, 1);
        LOBYTE(v24) = 0;
        *((_QWORD *)v3 + 80) = v23;
        if (v15)
          goto LABEL_102;
        goto LABEL_108;
      }
      goto LABEL_62;
    }
    v19 = *((_DWORD *)v3 + 292);
    if (v19 == 2)
    {
      switch(v18)
      {
        case 3:
          HDRFunctionNode = HGColorGamma::m_GetToneParamCurve3(v3);
          break;
        case 2:
          HDRFunctionNode = HGColorGamma::m_GetToneParamCurve2(v3);
          break;
        case 1:
          HDRFunctionNode = HGColorGamma::m_GetToneParamCurve1(v3);
          break;
        default:
          HDRFunctionNode = HGColorGamma::m_GetToneParamCurve4(v3);
          break;
      }
LABEL_53:
      v23 = HDRFunctionNode;
      LOBYTE(v24) = 0;
      if (v15)
        goto LABEL_102;
LABEL_108:
      v30 = v14;
      goto LABEL_109;
    }
LABEL_55:
    if (v19 >= 3 && *((_BYTE *)v3 + 880))
    {
      if (*((_BYTE *)v3 + 1172))
      {
        if (*((_BYTE *)v3 + 1173))
          v24 = v15 ^ 1u;
        else
          v24 = 0;
      }
      else
      {
        v24 = 0;
      }
      GammaFittedNode = (HGNode *)HGColorGamma::m_GetGammaFittedNode(v3);
      HGToneCurve::SetPremultiplyState(GammaFittedNode, v24, v29);
      v23 = HGColorGamma::m_GetGammaFittedNode(v3);
      if (!v15)
        goto LABEL_108;
      goto LABEL_102;
    }
    goto LABEL_61;
  }
  v21 = vmvnq_s8((int8x16_t)vceqq_f32(vmulq_f32(*((float32x4_t *)v3 + 48), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B3051560));
  *(int32x2_t *)v21.i8 = vpmin_s32(*(int32x2_t *)v21.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL));
  if (vpmin_s32(*(int32x2_t *)v21.i8, *(int32x2_t *)v21.i8).u32[0])
  {
    v19 = *((_DWORD *)v3 + 292);
    if ((v19 - 1) > 1)
      goto LABEL_55;
    if (*((_BYTE *)v3 + 1172))
    {
      v22 = *((_BYTE *)v3 + 1173) ? v15 : 1;
      if ((v22 & 1) == 0)
      {
        if (*((_BYTE *)v3 + 880))
          GammaUniformNode = HGColorGamma::m_GetGammaUniformNode(v3);
        else
          GammaUniformNode = HGColorGamma::m_GetGammaMCNode(v3);
        v23 = GammaUniformNode;
        LOBYTE(v24) = 1;
        if (!v15)
          goto LABEL_108;
        goto LABEL_102;
      }
    }
    v23 = (HGApply1DLUT *)*((_QWORD *)v3 + 57);
    if (v23)
    {
LABEL_62:
      LOBYTE(v24) = 0;
      if (v15)
        goto LABEL_102;
      goto LABEL_108;
    }
    v24 = (uint64_t)HGObject::operator new(0x1B0uLL);
    HGGamma::HGGamma((HGGamma *)v24);
    *((_QWORD *)v3 + 57) = v24;
    HGGamma::SetPremultiplyState(v24, 0);
    LOBYTE(v24) = 0;
    v23 = (HGApply1DLUT *)*((_QWORD *)v3 + 57);
    if (!v15)
      goto LABEL_108;
  }
  else
  {
    if (!*((_BYTE *)v3 + 1172))
    {
      LOBYTE(v24) = 0;
      v23 = 0;
      if (v15)
        goto LABEL_102;
      goto LABEL_108;
    }
    v23 = 0;
    if (*((_BYTE *)v3 + 1173))
      LOBYTE(v24) = v15 ^ 1;
    else
      LOBYTE(v24) = 0;
    if (!v15)
      goto LABEL_108;
  }
LABEL_102:
  if (!*((_BYTE *)v3 + 1026) || *((_DWORD *)v3 + 259) != 1)
    goto LABEL_108;
  v30 = (HgcColorGamma_chroma_upsample_f1 *)*((_QWORD *)v3 + 75);
  if (!v30)
  {
    v30 = (HgcColorGamma_chroma_upsample_f1 *)HGObject::operator new(0x1A0uLL);
    *(_OWORD *)v30 = 0u;
    *((_OWORD *)v30 + 1) = 0u;
    *((_OWORD *)v30 + 2) = 0u;
    *((_OWORD *)v30 + 3) = 0u;
    *((_OWORD *)v30 + 4) = 0u;
    *((_OWORD *)v30 + 5) = 0u;
    *((_OWORD *)v30 + 6) = 0u;
    *((_OWORD *)v30 + 7) = 0u;
    *((_OWORD *)v30 + 8) = 0u;
    *((_OWORD *)v30 + 9) = 0u;
    *((_OWORD *)v30 + 10) = 0u;
    *((_OWORD *)v30 + 11) = 0u;
    *((_OWORD *)v30 + 12) = 0u;
    *((_OWORD *)v30 + 13) = 0u;
    *((_OWORD *)v30 + 14) = 0u;
    *((_OWORD *)v30 + 15) = 0u;
    *((_OWORD *)v30 + 16) = 0u;
    *((_OWORD *)v30 + 17) = 0u;
    *((_OWORD *)v30 + 18) = 0u;
    *((_OWORD *)v30 + 19) = 0u;
    *((_OWORD *)v30 + 20) = 0u;
    *((_OWORD *)v30 + 21) = 0u;
    *((_OWORD *)v30 + 22) = 0u;
    *((_OWORD *)v30 + 23) = 0u;
    *((_OWORD *)v30 + 24) = 0u;
    *((_OWORD *)v30 + 25) = 0u;
    HgcColorGamma_chroma_upsample_f1::HgcColorGamma_chroma_upsample_f1(v30);
    *(_QWORD *)v30 = off_1E6521FC0;
    *((_QWORD *)v3 + 75) = v30;
  }
  v31 = *(void (**)(HgcColorGamma_chroma_upsample_f1 *, _QWORD, HgcColorGamma_2vuy_yxzx_expand *))(*(_QWORD *)v30 + 120);
  if (v14)
  {
    v31(v30, 0, v14);
  }
  else
  {
    v31(v30, 0, (HgcColorGamma_2vuy_yxzx_expand *)v13);
    *((_QWORD *)v3 + 94) = v30;
  }
  HGNode::SetSupportedFormatPrecisions((HGNode *)v30, (const char *)v12, v32);
LABEL_109:
  v33 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 57), (float32x4_t)xmmword_1B304F240), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 56), (float32x4_t)xmmword_1B304F230)), vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 58), (float32x4_t)xmmword_1B304F250), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 59), (float32x4_t)xmmword_1B304EFF0))))));
  *(int32x2_t *)v33.i8 = vpmin_s32(*(int32x2_t *)v33.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
  if (vpmin_s32(*(int32x2_t *)v33.i8, *(int32x2_t *)v33.i8).u32[0])
    __asm { FMOV            V2.4S, #1.0 }
  else
    _Q2 = *((float32x4_t *)v3 + 67);
  v39 = vmulq_f32(_Q2, *((float32x4_t *)v3 + 69));
  v40 = (int8x16_t)vceqzq_f32(v39);
  *(int32x2_t *)v40.i8 = vpmax_s32(*(int32x2_t *)v40.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v40, v40, 8uLL));
  if (!vpmax_s32(*(int32x2_t *)v40.i8, *(int32x2_t *)v40.i8).u32[0])
    goto LABEL_114;
  __asm { FMOV            V0.4S, #1.0 }
  v42 = vmvnq_s8((int8x16_t)vceqq_f32(_Q2, _Q0));
  *(int32x2_t *)v42.i8 = vpmin_s32(*(int32x2_t *)v42.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v42, v42, 8uLL));
  if (vpmin_s32(*(int32x2_t *)v42.i8, *(int32x2_t *)v42.i8).u32[0])
  {
LABEL_114:
    v43 = (HgcColorGamma_bias *)*((_QWORD *)v3 + 66);
    v92 = (__n128)_Q2;
    v93 = v39;
    if (v30)
    {
      if (v43)
      {
        v44 = *(void (***)(HGCColorGamma_bias *__hidden))v43;
      }
      else
      {
        v43 = (HgcColorGamma_bias *)HGObject::operator new(0x1A0uLL);
        *(_OWORD *)v43 = 0u;
        *((_OWORD *)v43 + 1) = 0u;
        *((_OWORD *)v43 + 2) = 0u;
        *((_OWORD *)v43 + 3) = 0u;
        *((_OWORD *)v43 + 4) = 0u;
        *((_OWORD *)v43 + 5) = 0u;
        *((_OWORD *)v43 + 6) = 0u;
        *((_OWORD *)v43 + 7) = 0u;
        *((_OWORD *)v43 + 8) = 0u;
        *((_OWORD *)v43 + 9) = 0u;
        *((_OWORD *)v43 + 10) = 0u;
        *((_OWORD *)v43 + 11) = 0u;
        *((_OWORD *)v43 + 12) = 0u;
        *((_OWORD *)v43 + 13) = 0u;
        *((_OWORD *)v43 + 14) = 0u;
        *((_OWORD *)v43 + 15) = 0u;
        *((_OWORD *)v43 + 16) = 0u;
        *((_OWORD *)v43 + 17) = 0u;
        *((_OWORD *)v43 + 18) = 0u;
        *((_OWORD *)v43 + 19) = 0u;
        *((_OWORD *)v43 + 20) = 0u;
        *((_OWORD *)v43 + 21) = 0u;
        *((_OWORD *)v43 + 22) = 0u;
        *((_OWORD *)v43 + 23) = 0u;
        *((_OWORD *)v43 + 24) = 0u;
        *((_OWORD *)v43 + 25) = 0u;
        HgcColorGamma_bias::HgcColorGamma_bias(v43);
        v44 = off_1E6521AF0;
        *(_QWORD *)v43 = off_1E6521AF0;
        *((_QWORD *)v3 + 66) = v43;
      }
      ((void (*)(HgcColorGamma_bias *, _QWORD, HgcColorGamma_chroma_upsample_f1 *))v44[15])(v43, 0, v30);
      v30 = (HgcColorGamma_chroma_upsample_f1 *)*((_QWORD *)v3 + 66);
      if (!v30)
      {
        v30 = (HgcColorGamma_chroma_upsample_f1 *)HGObject::operator new(0x1A0uLL);
        *(_OWORD *)v30 = 0u;
        *((_OWORD *)v30 + 1) = 0u;
        *((_OWORD *)v30 + 2) = 0u;
        *((_OWORD *)v30 + 3) = 0u;
        *((_OWORD *)v30 + 4) = 0u;
        *((_OWORD *)v30 + 5) = 0u;
        *((_OWORD *)v30 + 6) = 0u;
        *((_OWORD *)v30 + 7) = 0u;
        *((_OWORD *)v30 + 8) = 0u;
        *((_OWORD *)v30 + 9) = 0u;
        *((_OWORD *)v30 + 10) = 0u;
        *((_OWORD *)v30 + 11) = 0u;
        *((_OWORD *)v30 + 12) = 0u;
        *((_OWORD *)v30 + 13) = 0u;
        *((_OWORD *)v30 + 14) = 0u;
        *((_OWORD *)v30 + 15) = 0u;
        *((_OWORD *)v30 + 16) = 0u;
        *((_OWORD *)v30 + 17) = 0u;
        *((_OWORD *)v30 + 18) = 0u;
        *((_OWORD *)v30 + 19) = 0u;
        *((_OWORD *)v30 + 20) = 0u;
        *((_OWORD *)v30 + 21) = 0u;
        *((_OWORD *)v30 + 22) = 0u;
        *((_OWORD *)v30 + 23) = 0u;
        *((_OWORD *)v30 + 24) = 0u;
        *((_OWORD *)v30 + 25) = 0u;
        HgcColorGamma_bias::HgcColorGamma_bias(v30);
        v46 = off_1E6521AF0;
        *(_QWORD *)v30 = off_1E6521AF0;
        *((_QWORD *)v3 + 66) = v30;
LABEL_127:
        ((void (*)(HgcColorGamma_chroma_upsample_f1 *, _QWORD, float, float, float, float))v46[12])(v30, 0, -v93.f32[0], -v93.f32[1], -v93.f32[2], 0.0);
        (*(void (**)(HgcColorGamma_chroma_upsample_f1 *, uint64_t, __n128, float, float, float))(*(_QWORD *)v30 + 96))(v30, 1, v92, v92.n128_f32[1], v92.n128_f32[2], 1.0);
        goto LABEL_128;
      }
    }
    else
    {
      if (v43)
      {
        v45 = *(void (***)(HGCColorGamma_bias *__hidden))v43;
      }
      else
      {
        v43 = (HgcColorGamma_bias *)HGObject::operator new(0x1A0uLL);
        *(_OWORD *)v43 = 0u;
        *((_OWORD *)v43 + 1) = 0u;
        *((_OWORD *)v43 + 2) = 0u;
        *((_OWORD *)v43 + 3) = 0u;
        *((_OWORD *)v43 + 4) = 0u;
        *((_OWORD *)v43 + 5) = 0u;
        *((_OWORD *)v43 + 6) = 0u;
        *((_OWORD *)v43 + 7) = 0u;
        *((_OWORD *)v43 + 8) = 0u;
        *((_OWORD *)v43 + 9) = 0u;
        *((_OWORD *)v43 + 10) = 0u;
        *((_OWORD *)v43 + 11) = 0u;
        *((_OWORD *)v43 + 12) = 0u;
        *((_OWORD *)v43 + 13) = 0u;
        *((_OWORD *)v43 + 14) = 0u;
        *((_OWORD *)v43 + 15) = 0u;
        *((_OWORD *)v43 + 16) = 0u;
        *((_OWORD *)v43 + 17) = 0u;
        *((_OWORD *)v43 + 18) = 0u;
        *((_OWORD *)v43 + 19) = 0u;
        *((_OWORD *)v43 + 20) = 0u;
        *((_OWORD *)v43 + 21) = 0u;
        *((_OWORD *)v43 + 22) = 0u;
        *((_OWORD *)v43 + 23) = 0u;
        *((_OWORD *)v43 + 24) = 0u;
        *((_OWORD *)v43 + 25) = 0u;
        HgcColorGamma_bias::HgcColorGamma_bias(v43);
        v45 = off_1E6521AF0;
        *(_QWORD *)v43 = off_1E6521AF0;
        *((_QWORD *)v3 + 66) = v43;
      }
      ((void (*)(HgcColorGamma_bias *, _QWORD, HGNode *))v45[15])(v43, 0, v13);
      v30 = (HgcColorGamma_chroma_upsample_f1 *)*((_QWORD *)v3 + 66);
      if (!v30)
      {
        v30 = (HgcColorGamma_chroma_upsample_f1 *)HGObject::operator new(0x1A0uLL);
        *(_OWORD *)v30 = 0u;
        *((_OWORD *)v30 + 1) = 0u;
        *((_OWORD *)v30 + 2) = 0u;
        *((_OWORD *)v30 + 3) = 0u;
        *((_OWORD *)v30 + 4) = 0u;
        *((_OWORD *)v30 + 5) = 0u;
        *((_OWORD *)v30 + 6) = 0u;
        *((_OWORD *)v30 + 7) = 0u;
        *((_OWORD *)v30 + 8) = 0u;
        *((_OWORD *)v30 + 9) = 0u;
        *((_OWORD *)v30 + 10) = 0u;
        *((_OWORD *)v30 + 11) = 0u;
        *((_OWORD *)v30 + 12) = 0u;
        *((_OWORD *)v30 + 13) = 0u;
        *((_OWORD *)v30 + 14) = 0u;
        *((_OWORD *)v30 + 15) = 0u;
        *((_OWORD *)v30 + 16) = 0u;
        *((_OWORD *)v30 + 17) = 0u;
        *((_OWORD *)v30 + 18) = 0u;
        *((_OWORD *)v30 + 19) = 0u;
        *((_OWORD *)v30 + 20) = 0u;
        *((_OWORD *)v30 + 21) = 0u;
        *((_OWORD *)v30 + 22) = 0u;
        *((_OWORD *)v30 + 23) = 0u;
        *((_OWORD *)v30 + 24) = 0u;
        *((_OWORD *)v30 + 25) = 0u;
        HgcColorGamma_bias::HgcColorGamma_bias(v30);
        *(_QWORD *)v30 = off_1E6521AF0;
        *((_QWORD *)v3 + 66) = v30;
      }
      *((_QWORD *)v3 + 94) = v30;
    }
    v46 = *(void (***)(HGCColorGamma_bias *__hidden))v30;
    goto LABEL_127;
  }
LABEL_128:
  if (v15)
  {
    if (!*((_BYTE *)v3 + 1026) && *((_DWORD *)v3 + 259) == 1)
    {
      v47 = (HgcColorGamma_chroma_upsample_f1 *)*((_QWORD *)v3 + 75);
      if (!v47)
      {
        v47 = (HgcColorGamma_chroma_upsample_f1 *)HGObject::operator new(0x1A0uLL);
        *(_OWORD *)v47 = 0u;
        *((_OWORD *)v47 + 1) = 0u;
        *((_OWORD *)v47 + 2) = 0u;
        *((_OWORD *)v47 + 3) = 0u;
        *((_OWORD *)v47 + 4) = 0u;
        *((_OWORD *)v47 + 5) = 0u;
        *((_OWORD *)v47 + 6) = 0u;
        *((_OWORD *)v47 + 7) = 0u;
        *((_OWORD *)v47 + 8) = 0u;
        *((_OWORD *)v47 + 9) = 0u;
        *((_OWORD *)v47 + 10) = 0u;
        *((_OWORD *)v47 + 11) = 0u;
        *((_OWORD *)v47 + 12) = 0u;
        *((_OWORD *)v47 + 13) = 0u;
        *((_OWORD *)v47 + 14) = 0u;
        *((_OWORD *)v47 + 15) = 0u;
        *((_OWORD *)v47 + 16) = 0u;
        *((_OWORD *)v47 + 17) = 0u;
        *((_OWORD *)v47 + 18) = 0u;
        *((_OWORD *)v47 + 19) = 0u;
        *((_OWORD *)v47 + 20) = 0u;
        *((_OWORD *)v47 + 21) = 0u;
        *((_OWORD *)v47 + 22) = 0u;
        *((_OWORD *)v47 + 23) = 0u;
        *((_OWORD *)v47 + 24) = 0u;
        *((_OWORD *)v47 + 25) = 0u;
        HgcColorGamma_chroma_upsample_f1::HgcColorGamma_chroma_upsample_f1(v47);
        *(_QWORD *)v47 = off_1E6521FC0;
        *((_QWORD *)v3 + 75) = v47;
      }
      v48 = *(void (**)(HgcColorGamma_chroma_upsample_f1 *, _QWORD, HgcColorGamma_chroma_upsample_f1 *))(*(_QWORD *)v47 + 120);
      if (v30)
      {
        v48(v47, 0, v30);
        v49 = 0;
      }
      else
      {
        v48(v47, 0, (HgcColorGamma_chroma_upsample_f1 *)v13);
        v49 = 0;
        *((_QWORD *)v3 + 94) = v47;
      }
      v50 = 1;
      goto LABEL_144;
    }
    goto LABEL_141;
  }
  if (!*((_BYTE *)v3 + 1172) || (*((_BYTE *)v3 + 1173) ? (v51 = v24) : (v51 = 0), (v51 & 1) != 0))
  {
LABEL_141:
    v49 = 0;
    goto LABEL_142;
  }
  UnpremultiplyNode = HGColorGamma::m_GetUnpremultiplyNode(v3);
  v49 = UnpremultiplyNode;
  if (!UnpremultiplyNode)
  {
LABEL_142:
    v50 = 1;
    if (v30)
      goto LABEL_143;
    goto LABEL_155;
  }
  if (*((_BYTE *)v3 + 1174))
  {
    (*(void (**)(void))(*(_QWORD *)UnpremultiplyNode + 120))();
    v50 = 0;
    if (!v30)
      *((_QWORD *)v3 + 94) = v49;
    v47 = v49;
LABEL_144:
    v52 = (HGColorMatrix *)*((_QWORD *)v3 + 53);
    if (!v52)
    {
      v52 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
      HGColorMatrix::HGColorMatrix(v52);
      *((_QWORD *)v3 + 53) = v52;
    }
    (*(void (**)(HGColorMatrix *, _QWORD, HgcColorGamma_chroma_upsample_f1 *))(*(_QWORD *)v52 + 120))(v52, 0, v47);
    if ((v50 & 1) != 0)
      goto LABEL_162;
    goto LABEL_161;
  }
  v50 = 0;
  if (v30)
  {
LABEL_143:
    v47 = v30;
    goto LABEL_144;
  }
LABEL_155:
  v54 = (HGColorMatrix *)*((_QWORD *)v3 + 53);
  if (!v54)
  {
    v54 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
    HGColorMatrix::HGColorMatrix(v54);
    *((_QWORD *)v3 + 53) = v54;
  }
  (*(void (**)(HGColorMatrix *, _QWORD, HGNode *))(*(_QWORD *)v54 + 120))(v54, 0, v13);
  v55 = *((_QWORD *)v3 + 53);
  if (v55)
  {
    *((_QWORD *)v3 + 94) = v55;
    if ((v50 & 1) != 0)
      goto LABEL_162;
  }
  else
  {
    v56 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
    HGColorMatrix::HGColorMatrix(v56);
    *((_QWORD *)v3 + 53) = v56;
    *((_QWORD *)v3 + 94) = v56;
    if ((v50 & 1) != 0)
      goto LABEL_162;
  }
LABEL_161:
  if (!*((_BYTE *)v3 + 1174))
  {
    v64 = (HGColorMatrix *)*((_QWORD *)v3 + 53);
    if (!v64)
    {
      v64 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
      HGColorMatrix::HGColorMatrix(v64);
      *((_QWORD *)v3 + 53) = v64;
    }
    (*(void (**)(HGColorMatrix *, _QWORD, HGColorMatrix *))(*(_QWORD *)v49 + 120))(v49, 0, v64);
    if (!v23)
      goto LABEL_171;
LABEL_164:
    (*(void (**)(HGApply1DLUT *, _QWORD, HGColorMatrix *))(*(_QWORD *)v23 + 120))(v23, 0, v49);
    v57 = (HGColorMatrix *)*((_QWORD *)v3 + 54);
    if (!v57)
    {
      v57 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
      HGColorMatrix::HGColorMatrix(v57);
      *((_QWORD *)v3 + 54) = v57;
    }
    (*(void (**)(HGColorMatrix *, _QWORD, HGApply1DLUT *))(*(_QWORD *)v57 + 120))(v57, 0, v23);
    v58 = (HGColorMatrix *)*((_QWORD *)v3 + 54);
    if (v58)
      goto LABEL_167;
    goto LABEL_174;
  }
LABEL_162:
  v49 = (HGColorMatrix *)*((_QWORD *)v3 + 53);
  if (!v49)
  {
    v49 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
    HGColorMatrix::HGColorMatrix(v49);
    *((_QWORD *)v3 + 53) = v49;
    if (!v23)
      goto LABEL_171;
    goto LABEL_164;
  }
  if (v23)
    goto LABEL_164;
LABEL_171:
  v61 = (HGColorMatrix *)*((_QWORD *)v3 + 54);
  if (!v61)
  {
    v61 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
    HGColorMatrix::HGColorMatrix(v61);
    *((_QWORD *)v3 + 54) = v61;
  }
  (*(void (**)(HGColorMatrix *, _QWORD, HGColorMatrix *))(*(_QWORD *)v61 + 120))(v61, 0, v49);
  v58 = (HGColorMatrix *)*((_QWORD *)v3 + 54);
  if (v58)
  {
LABEL_167:
    v59 = *((int *)v3 + 266);
    if (v59 <= 0x1A)
      goto LABEL_168;
LABEL_175:
    v60 = 1;
    if ((v15 & 1) != 0)
      goto LABEL_194;
    goto LABEL_176;
  }
LABEL_174:
  v58 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
  HGColorMatrix::HGColorMatrix(v58);
  *((_QWORD *)v3 + 54) = v58;
  v59 = *((int *)v3 + 266);
  if (v59 > 0x1A)
    goto LABEL_175;
LABEL_168:
  v60 = dword_1B309F468[v59];
  if ((v15 & 1) != 0)
    goto LABEL_194;
LABEL_176:
  if (*((_BYTE *)v3 + 1172))
  {
    if (*((_BYTE *)v3 + 1173))
      v62 = v24;
    else
      v62 = 1;
    if ((v62 & 1) != 0)
      goto LABEL_194;
    v63 = (HgcPremultiply *)*((_QWORD *)v3 + 72);
    if (!v63)
    {
      v63 = (HgcPremultiply *)HGObject::operator new(0x1A0uLL);
      HgcPremultiply::HgcPremultiply(v63);
      *((_QWORD *)v3 + 72) = v63;
    }
    (*(void (**)(HgcPremultiply *, _QWORD, HGColorMatrix *))(*(_QWORD *)v63 + 120))(v63, 0, v58);
    v58 = (HGColorMatrix *)*((_QWORD *)v3 + 72);
    if (v58)
      goto LABEL_194;
  }
  else
  {
    if (!*((_BYTE *)v3 + 1173))
      goto LABEL_194;
    v65 = (HgcPremultiply *)*((_QWORD *)v3 + 72);
    if (!v65)
    {
      v65 = (HgcPremultiply *)HGObject::operator new(0x1A0uLL);
      HgcPremultiply::HgcPremultiply(v65);
      *((_QWORD *)v3 + 72) = v65;
    }
    (*(void (**)(HgcPremultiply *, _QWORD, HGColorMatrix *))(*(_QWORD *)v65 + 120))(v65, 0, v58);
    v58 = (HGColorMatrix *)*((_QWORD *)v3 + 72);
    if (v58)
      goto LABEL_194;
  }
  v58 = (HGColorMatrix *)HGObject::operator new(0x1A0uLL);
  HgcPremultiply::HgcPremultiply(v58);
  *((_QWORD *)v3 + 72) = v58;
LABEL_194:
  v66 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 61), (float32x4_t)xmmword_1B304F240), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 60), (float32x4_t)xmmword_1B304F230)), vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 62), (float32x4_t)xmmword_1B304F250), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 63), (float32x4_t)xmmword_1B304EFF0))))));
  *(int32x2_t *)v66.i8 = vpmin_s32(*(int32x2_t *)v66.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v66, v66, 8uLL));
  if (vpmin_s32(*(int32x2_t *)v66.i8, *(int32x2_t *)v66.i8).u32[0])
    __asm { FMOV            V2.4S, #1.0 }
  else
    _Q2 = *((float32x4_t *)v3 + 68);
  v68 = (int8x16_t)vceqzq_f32(*((float32x4_t *)v3 + 70));
  *(int32x2_t *)v68.i8 = vpmax_s32(*(int32x2_t *)v68.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v68, v68, 8uLL));
  if (!vpmax_s32(*(int32x2_t *)v68.i8, *(int32x2_t *)v68.i8).u32[0])
    goto LABEL_266;
  __asm { FMOV            V0.4S, #1.0 }
  v70 = vmvnq_s8((int8x16_t)vceqq_f32(_Q2, _Q0));
  *(int32x2_t *)v70.i8 = vpmin_s32(*(int32x2_t *)v70.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v70, v70, 8uLL));
  if (vpmin_s32(*(int32x2_t *)v70.i8, *(int32x2_t *)v70.i8).u32[0])
  {
LABEL_266:
    v94 = (__n128)_Q2;
    *(_OWORD *)v95 = *((_OWORD *)v3 + 70);
    v71 = (HgcColorGamma_bias *)*((_QWORD *)v3 + 68);
    if (v71)
    {
      v72 = *(void (***)(HGCColorGamma_bias *__hidden))v71;
    }
    else
    {
      v71 = (HgcColorGamma_bias *)HGObject::operator new(0x1A0uLL);
      *(_OWORD *)v71 = 0u;
      *((_OWORD *)v71 + 1) = 0u;
      *((_OWORD *)v71 + 2) = 0u;
      *((_OWORD *)v71 + 3) = 0u;
      *((_OWORD *)v71 + 4) = 0u;
      *((_OWORD *)v71 + 5) = 0u;
      *((_OWORD *)v71 + 6) = 0u;
      *((_OWORD *)v71 + 7) = 0u;
      *((_OWORD *)v71 + 8) = 0u;
      *((_OWORD *)v71 + 9) = 0u;
      *((_OWORD *)v71 + 10) = 0u;
      *((_OWORD *)v71 + 11) = 0u;
      *((_OWORD *)v71 + 12) = 0u;
      *((_OWORD *)v71 + 13) = 0u;
      *((_OWORD *)v71 + 14) = 0u;
      *((_OWORD *)v71 + 15) = 0u;
      *((_OWORD *)v71 + 16) = 0u;
      *((_OWORD *)v71 + 17) = 0u;
      *((_OWORD *)v71 + 18) = 0u;
      *((_OWORD *)v71 + 19) = 0u;
      *((_OWORD *)v71 + 20) = 0u;
      *((_OWORD *)v71 + 21) = 0u;
      *((_OWORD *)v71 + 22) = 0u;
      *((_OWORD *)v71 + 23) = 0u;
      *((_OWORD *)v71 + 24) = 0u;
      *((_OWORD *)v71 + 25) = 0u;
      HgcColorGamma_bias::HgcColorGamma_bias(v71);
      v72 = off_1E6521AF0;
      *(_QWORD *)v71 = off_1E6521AF0;
      *((_QWORD *)v3 + 68) = v71;
    }
    ((void (*)(HgcColorGamma_bias *, _QWORD, HGColorMatrix *))v72[15])(v71, 0, v58);
    v58 = (HGColorMatrix *)*((_QWORD *)v3 + 68);
    if (v58)
    {
      v73 = *(void (***)(HGCColorGamma_bias *__hidden))v58;
    }
    else
    {
      v58 = (HGColorMatrix *)HGObject::operator new(0x1A0uLL);
      *(_OWORD *)v58 = 0u;
      *((_OWORD *)v58 + 1) = 0u;
      *((_OWORD *)v58 + 2) = 0u;
      *((_OWORD *)v58 + 3) = 0u;
      *((_OWORD *)v58 + 4) = 0u;
      *((_OWORD *)v58 + 5) = 0u;
      *((_OWORD *)v58 + 6) = 0u;
      *((_OWORD *)v58 + 7) = 0u;
      *((_OWORD *)v58 + 8) = 0u;
      *((_OWORD *)v58 + 9) = 0u;
      *((_OWORD *)v58 + 10) = 0u;
      *((_OWORD *)v58 + 11) = 0u;
      *((_OWORD *)v58 + 12) = 0u;
      *((_OWORD *)v58 + 13) = 0u;
      *((_OWORD *)v58 + 14) = 0u;
      *((_OWORD *)v58 + 15) = 0u;
      *((_OWORD *)v58 + 16) = 0u;
      *((_OWORD *)v58 + 17) = 0u;
      *((_OWORD *)v58 + 18) = 0u;
      *((_OWORD *)v58 + 19) = 0u;
      *((_OWORD *)v58 + 20) = 0u;
      *((_OWORD *)v58 + 21) = 0u;
      *((_OWORD *)v58 + 22) = 0u;
      *((_OWORD *)v58 + 23) = 0u;
      *((_OWORD *)v58 + 24) = 0u;
      *((_OWORD *)v58 + 25) = 0u;
      HgcColorGamma_bias::HgcColorGamma_bias(v58);
      v73 = off_1E6521AF0;
      *(_QWORD *)v58 = off_1E6521AF0;
      *((_QWORD *)v3 + 68) = v58;
    }
    ((void (*)(HGColorMatrix *, _QWORD, float, float, float, float))v73[12])(v58, 0, -v95[0], -v95[1], -v95[2], -v95[3]);
    (*(void (**)(HGColorMatrix *, uint64_t, __n128, float, float, float))(*(_QWORD *)v58 + 96))(v58, 1, v94, v94.n128_f32[1], v94.n128_f32[2], v94.n128_f32[3]);
    if (*((_BYTE *)v3 + 1026))
      HGNode::SetSupportedFormatPrecisions((HGNode *)v58, (const char *)v60, v74);
  }
  if (*((_BYTE *)v3 + 1025))
  {
    v75 = (HGDither *)*((_QWORD *)v3 + 92);
    if (!v75)
    {
      v75 = (HGDither *)HGObject::operator new(0x1D0uLL);
      HGDither::HGDither(v75);
      *((_QWORD *)v3 + 92) = v75;
    }
    (*(void (**)(HGDither *, _QWORD, float, float, float, float))(*(_QWORD *)v75 + 96))(v75, 0, 0.0, 0.0, 0.0, 0.0);
    v76 = (HGDither *)*((_QWORD *)v3 + 92);
    if (!v76)
    {
      v76 = (HGDither *)HGObject::operator new(0x1D0uLL);
      HGDither::HGDither(v76);
      *((_QWORD *)v3 + 92) = v76;
    }
    (*(void (**)(HGDither *, _QWORD, HGColorMatrix *))(*(_QWORD *)v76 + 120))(v76, 0, v58);
    v58 = (HGColorMatrix *)*((_QWORD *)v3 + 92);
    if (!v58)
    {
      v58 = (HGColorMatrix *)HGObject::operator new(0x1D0uLL);
      HGDither::HGDither(v58);
      *((_QWORD *)v3 + 92) = v58;
    }
    if (*((_BYTE *)v3 + 1026))
      HGNode::SetSupportedFormatPrecisions((HGNode *)v58, (const char *)v60, v77);
  }
  switch(*((_DWORD *)v3 + 264))
  {
    case 0xE:
    case 0xF:
      if (*((_DWORD *)v3 + 266) == 1)
        goto LABEL_228;
      break;
    case 0x10:
      if (*((_DWORD *)v3 + 266) == 3)
        goto LABEL_228;
      break;
    case 0x16:
      if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) == 0)
      {
        PixelFormatConversion_kV4B_WXYZ_OutputNode = HGColorGamma::m_GetPixelFormatConversion_kV4B_WXYZ_OutputNode(v3);
        (*(void (**)(HgcPixelFormatConversion_kV4B_WXYZ_output *, _QWORD, HGColorMatrix *))(*(_QWORD *)PixelFormatConversion_kV4B_WXYZ_OutputNode + 120))(PixelFormatConversion_kV4B_WXYZ_OutputNode, 0, v58);
        v79 = HGColorGamma::m_GetPixelFormatConversion_kV4B_WXYZ_OutputNode(v3);
        goto LABEL_242;
      }
      break;
    case 0x1A:
      if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) == 0)
      {
        PixelFormatConversion_kV4S_WXYZ_OutputNode = HGColorGamma::m_GetPixelFormatConversion_kV4S_WXYZ_OutputNode(v3);
        (*(void (**)(HgcPixelFormatConversion_kV4S_WXYZ_output *, _QWORD, HGColorMatrix *))(*(_QWORD *)PixelFormatConversion_kV4S_WXYZ_OutputNode + 120))(PixelFormatConversion_kV4S_WXYZ_OutputNode, 0, v58);
        v79 = HGColorGamma::m_GetPixelFormatConversion_kV4S_WXYZ_OutputNode(v3);
        goto LABEL_242;
      }
      break;
    case 0x1D:
      if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) == 0)
      {
        PixelFormatConversion_kV4F_WXYZ_OutputNode = HGColorGamma::m_GetPixelFormatConversion_kV4F_WXYZ_OutputNode(v3);
        (*(void (**)(HgcPixelFormatConversion_kV4F_WXYZ_output *, _QWORD, HGColorMatrix *))(*(_QWORD *)PixelFormatConversion_kV4F_WXYZ_OutputNode + 120))(PixelFormatConversion_kV4F_WXYZ_OutputNode, 0, v58);
        v79 = HGColorGamma::m_GetPixelFormatConversion_kV4F_WXYZ_OutputNode(v3);
        goto LABEL_242;
      }
      break;
    case 0x1F:
      if (*((_DWORD *)v3 + 266) == 2)
      {
LABEL_228:
        if (*((_DWORD *)v3 + 259) == 1)
        {
          if (!HGRectIsInfinite(*((_QWORD *)v3 + 130), *((_QWORD *)v3 + 131)))
          {
            v82 = (HGCrop *)*((_QWORD *)v3 + 90);
            if (!v82)
            {
              v82 = (HGCrop *)HGObject::operator new(0x1A0uLL);
              HGCrop::HGCrop(v82);
              *((_QWORD *)v3 + 90) = v82;
            }
            (*(void (**)(HGCrop *, _QWORD, float, float, float, float))(*(_QWORD *)v82 + 96))(v82, 0, (float)*((int *)v3 + 260), (float)*((int *)v3 + 261), (float)*((int *)v3 + 262), (float)*((int *)v3 + 263));
            (*(void (**)(HGCrop *, _QWORD, HGColorMatrix *))(*(_QWORD *)v82 + 120))(v82, 0, v58);
            v58 = (HGColorMatrix *)*((_QWORD *)v3 + 91);
            if (!v58)
            {
              v58 = (HGColorMatrix *)HGObject::operator new(0x1D0uLL);
              HGTextureWrap::HGTextureWrap(v58);
              *((_QWORD *)v3 + 91) = v58;
            }
            HGTextureWrap::SetTextureWrapMode((uint64_t)v58, (const char *)1, v83);
            (*(void (**)(HGColorMatrix *, _QWORD, HGCrop *))(*(_QWORD *)v58 + 120))(v58, 0, v82);
            if (*((_BYTE *)v3 + 1026))
              HGNode::SetSupportedFormatPrecisions((HGNode *)v58, (const char *)v60, v84);
          }
          v85 = (HgcColorGamma_chroma_downsample_f1 *)*((_QWORD *)v3 + 74);
          if (v85)
          {
            v86 = *(void (***)(HGCColorGamma_chroma_downsample_f1 *__hidden))v85;
          }
          else
          {
            v85 = (HgcColorGamma_chroma_downsample_f1 *)HGObject::operator new(0x1A0uLL);
            *(_OWORD *)v85 = 0u;
            *((_OWORD *)v85 + 1) = 0u;
            *((_OWORD *)v85 + 2) = 0u;
            *((_OWORD *)v85 + 3) = 0u;
            *((_OWORD *)v85 + 4) = 0u;
            *((_OWORD *)v85 + 5) = 0u;
            *((_OWORD *)v85 + 6) = 0u;
            *((_OWORD *)v85 + 7) = 0u;
            *((_OWORD *)v85 + 8) = 0u;
            *((_OWORD *)v85 + 9) = 0u;
            *((_OWORD *)v85 + 10) = 0u;
            *((_OWORD *)v85 + 11) = 0u;
            *((_OWORD *)v85 + 12) = 0u;
            *((_OWORD *)v85 + 13) = 0u;
            *((_OWORD *)v85 + 14) = 0u;
            *((_OWORD *)v85 + 15) = 0u;
            *((_OWORD *)v85 + 16) = 0u;
            *((_OWORD *)v85 + 17) = 0u;
            *((_OWORD *)v85 + 18) = 0u;
            *((_OWORD *)v85 + 19) = 0u;
            *((_OWORD *)v85 + 20) = 0u;
            *((_OWORD *)v85 + 21) = 0u;
            *((_OWORD *)v85 + 22) = 0u;
            *((_OWORD *)v85 + 23) = 0u;
            *((_OWORD *)v85 + 24) = 0u;
            *((_OWORD *)v85 + 25) = 0u;
            HgcColorGamma_chroma_downsample_f1::HgcColorGamma_chroma_downsample_f1(v85);
            v86 = off_1E6521D58;
            *(_QWORD *)v85 = off_1E6521D58;
            *((_QWORD *)v3 + 74) = v85;
          }
          ((void (*)(HgcColorGamma_chroma_downsample_f1 *, _QWORD, HGColorMatrix *))v86[15])(v85, 0, v58);
          v58 = (HGColorMatrix *)*((_QWORD *)v3 + 74);
          if (!v58)
          {
            v58 = (HGColorMatrix *)HGObject::operator new(0x1A0uLL);
            *(_OWORD *)v58 = 0u;
            *((_OWORD *)v58 + 1) = 0u;
            *((_OWORD *)v58 + 2) = 0u;
            *((_OWORD *)v58 + 3) = 0u;
            *((_OWORD *)v58 + 4) = 0u;
            *((_OWORD *)v58 + 5) = 0u;
            *((_OWORD *)v58 + 6) = 0u;
            *((_OWORD *)v58 + 7) = 0u;
            *((_OWORD *)v58 + 8) = 0u;
            *((_OWORD *)v58 + 9) = 0u;
            *((_OWORD *)v58 + 10) = 0u;
            *((_OWORD *)v58 + 11) = 0u;
            *((_OWORD *)v58 + 12) = 0u;
            *((_OWORD *)v58 + 13) = 0u;
            *((_OWORD *)v58 + 14) = 0u;
            *((_OWORD *)v58 + 15) = 0u;
            *((_OWORD *)v58 + 16) = 0u;
            *((_OWORD *)v58 + 17) = 0u;
            *((_OWORD *)v58 + 18) = 0u;
            *((_OWORD *)v58 + 19) = 0u;
            *((_OWORD *)v58 + 20) = 0u;
            *((_OWORD *)v58 + 21) = 0u;
            *((_OWORD *)v58 + 22) = 0u;
            *((_OWORD *)v58 + 23) = 0u;
            *((_OWORD *)v58 + 24) = 0u;
            *((_OWORD *)v58 + 25) = 0u;
            HgcColorGamma_chroma_downsample_f1::HgcColorGamma_chroma_downsample_f1(v58);
            *(_QWORD *)v58 = off_1E6521D58;
            *((_QWORD *)v3 + 74) = v58;
          }
          if (*((_BYTE *)v3 + 1026))
            HGNode::SetSupportedFormatPrecisions((HGNode *)v58, (const char *)v60, v89);
        }
        if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) == 0)
        {
          v90 = 0;
          switch(*((_DWORD *)v3 + 264))
          {
            case 0xE:
              v90 = (HgcColorGamma_2vuy_yxzx_collapse *)*((_QWORD *)v3 + 76);
              if (!v90)
              {
                v90 = (HgcColorGamma_2vuy_yxzx_collapse *)HGObject::operator new(0x1A0uLL);
                *(_OWORD *)v90 = 0u;
                *((_OWORD *)v90 + 1) = 0u;
                *((_OWORD *)v90 + 2) = 0u;
                *((_OWORD *)v90 + 3) = 0u;
                *((_OWORD *)v90 + 4) = 0u;
                *((_OWORD *)v90 + 5) = 0u;
                *((_OWORD *)v90 + 6) = 0u;
                *((_OWORD *)v90 + 7) = 0u;
                *((_OWORD *)v90 + 8) = 0u;
                *((_OWORD *)v90 + 9) = 0u;
                *((_OWORD *)v90 + 10) = 0u;
                *((_OWORD *)v90 + 11) = 0u;
                *((_OWORD *)v90 + 12) = 0u;
                *((_OWORD *)v90 + 13) = 0u;
                *((_OWORD *)v90 + 14) = 0u;
                *((_OWORD *)v90 + 15) = 0u;
                *((_OWORD *)v90 + 16) = 0u;
                *((_OWORD *)v90 + 17) = 0u;
                *((_OWORD *)v90 + 18) = 0u;
                *((_OWORD *)v90 + 19) = 0u;
                *((_OWORD *)v90 + 20) = 0u;
                *((_OWORD *)v90 + 21) = 0u;
                *((_OWORD *)v90 + 22) = 0u;
                *((_OWORD *)v90 + 23) = 0u;
                *((_OWORD *)v90 + 24) = 0u;
                *((_OWORD *)v90 + 25) = 0u;
                HgcColorGamma_2vuy_yxzx_collapse::HgcColorGamma_2vuy_yxzx_collapse(v90);
                *(_QWORD *)v90 = off_1E6522228;
                *((_QWORD *)v3 + 76) = v90;
              }
              break;
            case 0xF:
              v90 = (HgcColorGamma_2vuy_yxzx_collapse *)*((_QWORD *)v3 + 77);
              if (!v90)
              {
                v90 = (HgcColorGamma_2vuy_yxzx_collapse *)HGObject::operator new(0x1A0uLL);
                *(_OWORD *)v90 = 0u;
                *((_OWORD *)v90 + 1) = 0u;
                *((_OWORD *)v90 + 2) = 0u;
                *((_OWORD *)v90 + 3) = 0u;
                *((_OWORD *)v90 + 4) = 0u;
                *((_OWORD *)v90 + 5) = 0u;
                *((_OWORD *)v90 + 6) = 0u;
                *((_OWORD *)v90 + 7) = 0u;
                *((_OWORD *)v90 + 8) = 0u;
                *((_OWORD *)v90 + 9) = 0u;
                *((_OWORD *)v90 + 10) = 0u;
                *((_OWORD *)v90 + 11) = 0u;
                *((_OWORD *)v90 + 12) = 0u;
                *((_OWORD *)v90 + 13) = 0u;
                *((_OWORD *)v90 + 14) = 0u;
                *((_OWORD *)v90 + 15) = 0u;
                *((_OWORD *)v90 + 16) = 0u;
                *((_OWORD *)v90 + 17) = 0u;
                *((_OWORD *)v90 + 18) = 0u;
                *((_OWORD *)v90 + 19) = 0u;
                *((_OWORD *)v90 + 20) = 0u;
                *((_OWORD *)v90 + 21) = 0u;
                *((_OWORD *)v90 + 22) = 0u;
                *((_OWORD *)v90 + 23) = 0u;
                *((_OWORD *)v90 + 24) = 0u;
                *((_OWORD *)v90 + 25) = 0u;
                HgcColorGamma_2vuy_xyxz_collapse::HgcColorGamma_2vuy_xyxz_collapse(v90);
                *(_QWORD *)v90 = off_1E6522490;
                *((_QWORD *)v3 + 77) = v90;
              }
              break;
            case 0x10:
              v90 = (HgcColorGamma_2vuy_yxzx_collapse *)*((_QWORD *)v3 + 78);
              if (!v90)
              {
                v90 = (HgcColorGamma_2vuy_yxzx_collapse *)HGObject::operator new(0x1A0uLL);
                *(_OWORD *)v90 = 0u;
                *((_OWORD *)v90 + 1) = 0u;
                *((_OWORD *)v90 + 2) = 0u;
                *((_OWORD *)v90 + 3) = 0u;
                *((_OWORD *)v90 + 4) = 0u;
                *((_OWORD *)v90 + 5) = 0u;
                *((_OWORD *)v90 + 6) = 0u;
                *((_OWORD *)v90 + 7) = 0u;
                *((_OWORD *)v90 + 8) = 0u;
                *((_OWORD *)v90 + 9) = 0u;
                *((_OWORD *)v90 + 10) = 0u;
                *((_OWORD *)v90 + 11) = 0u;
                *((_OWORD *)v90 + 12) = 0u;
                *((_OWORD *)v90 + 13) = 0u;
                *((_OWORD *)v90 + 14) = 0u;
                *((_OWORD *)v90 + 15) = 0u;
                *((_OWORD *)v90 + 16) = 0u;
                *((_OWORD *)v90 + 17) = 0u;
                *((_OWORD *)v90 + 18) = 0u;
                *((_OWORD *)v90 + 19) = 0u;
                *((_OWORD *)v90 + 20) = 0u;
                *((_OWORD *)v90 + 21) = 0u;
                *((_OWORD *)v90 + 22) = 0u;
                *((_OWORD *)v90 + 23) = 0u;
                *((_OWORD *)v90 + 24) = 0u;
                *((_OWORD *)v90 + 25) = 0u;
                HgcColorGamma_v216_yxzx_collapse::HgcColorGamma_v216_yxzx_collapse(v90);
                *(_QWORD *)v90 = off_1E6522960;
                *((_QWORD *)v3 + 78) = v90;
              }
              break;
            case 0x1F:
              v90 = (HgcColorGamma_2vuy_yxzx_collapse *)*((_QWORD *)v3 + 79);
              if (!v90)
              {
                v90 = (HgcColorGamma_2vuy_yxzx_collapse *)HGObject::operator new(0x1A0uLL);
                HgcColorGamma_v210_yxzx_rgba_collapse::HgcColorGamma_v210_yxzx_rgba_collapse(v90);
                *(_QWORD *)v90 = off_1E65226F8;
                *((_QWORD *)v3 + 79) = v90;
              }
              break;
            default:
              break;
          }
          (*(void (**)(HgcColorGamma_2vuy_yxzx_collapse *, _QWORD, HGColorMatrix *))(*(_QWORD *)v90 + 120))(v90, 0, v58);
          v58 = v90;
        }
      }
      break;
    case 0x20:
      if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) == 0)
      {
        PixelFormatConversion_kV4B10Bit_BE_OutputNode = HGColorGamma::m_GetPixelFormatConversion_kV4B10Bit_BE_OutputNode(v3);
        (*(void (**)(HgcPixelFormatConversion_kV4B10Bit_BE_output *, _QWORD, HGColorMatrix *))(*(_QWORD *)PixelFormatConversion_kV4B10Bit_BE_OutputNode + 120))(PixelFormatConversion_kV4B10Bit_BE_OutputNode, 0, v58);
        v79 = HGColorGamma::m_GetPixelFormatConversion_kV4B10Bit_BE_OutputNode(v3);
        goto LABEL_242;
      }
      break;
    case 0x21:
      if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) == 0)
      {
        PixelFormatConversion_kV4S_BE_WXYZ_OutputNode = HGColorGamma::m_GetPixelFormatConversion_kV4S_BE_WXYZ_OutputNode(v3);
        (*(void (**)(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *, _QWORD, HGColorMatrix *))(*(_QWORD *)PixelFormatConversion_kV4S_BE_WXYZ_OutputNode + 120))(PixelFormatConversion_kV4S_BE_WXYZ_OutputNode, 0, v58);
        v79 = HGColorGamma::m_GetPixelFormatConversion_kV4S_BE_WXYZ_OutputNode(v3);
LABEL_242:
        v58 = v79;
      }
      break;
    default:
      break;
  }
  *((_QWORD *)v3 + 95) = v58;
  return v58;
}

void sub_1B2A332C8(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A332DC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A332F0(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A33304(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A33318(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A3332C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A33340(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A33354(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A33368(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A3337C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A33390(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A333A4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A333B8(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A333CC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A333E0(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A333F4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A33408(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A3341C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A33430(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A33444(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A33458(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A3346C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A33480(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A33494(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A334A8(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A334BC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A334D0(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A334E4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A334F8(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A3350C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A33520(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A33534(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A33548(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A3355C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorGamma::ConcatenateWithUpstreamNode(HGNode *this, HGRenderer *a2, HGNode **a3)
{
  uint64_t result;
  uint64_t v7;
  const char *v8;
  char *v9;
  HGNode *v10;
  char v11;
  int v12;
  int v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  __n128 v18;

  result = (uint64_t)*a3;
  if (*a3)
  {
    if (result)
    {
      v7 = result;
      result = HGRenderer::IsMergeable(a2, this, 0, 0);
      if ((_DWORD)result)
      {
        result = (*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2);
        if ((_DWORD)result)
        {
          v10 = *(HGNode **)(v7 + 1176);
          if (v10)
          {
            if (!*((_DWORD *)this + 264))
            {
              if ((*(_DWORD *)(v7 + 1060) - 1) > 2)
              {
                if (*((unsigned __int8 *)this + 1172) != *(unsigned __int8 *)(v7 + 1173))
                  HGLogger::warning((HGLogger *)"HGColorGamma concatenating with upstream node: inconsistent premultiplication states.\n", v8, v9);
                v11 = *(_BYTE *)(v7 + 1172);
                *((_BYTE *)this + 745) = 1;
                *((_BYTE *)this + 1172) = v11;
              }
              else
              {
                *((_WORD *)this + 586) = 0;
              }
              v12 = *(_DWORD *)(v7 + 1036);
              HGNode::ClearBits(this, (uint64_t)v8, v9);
              *((_BYTE *)this + 745) = 1;
              *((_DWORD *)this + 259) = v12;
              v13 = *(_DWORD *)(v7 + 1060);
              HGNode::ClearBits(this, v14, v15);
              *((_BYTE *)this + 745) = 1;
              *((_DWORD *)this + 265) = v13;
              v18 = HGColorGamma::SetYCbCrBiasAndScale(this, v16, v17);
              result = (*(uint64_t (**)(HGNode *, _QWORD, HGNode *, __n128))(*(_QWORD *)this + 120))(this, 0, v10, v18);
              *a3 = v10;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t HGColorGamma::ScaleParams(float32x4_t *this, HGNode *a2, HGRenderer *a3)
{
  char *v5;
  uint64_t v6;
  int v7;
  HgcToneParamCurve1AntiSymmetric *v8;
  int8x16_t v9;
  HGGamma *v10;
  HGToneCurve *v11;
  float *v12;
  char *v13;
  HGToneCurve *v14;
  unsigned __int8 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t LUTCache;
  HGBitmap *NewLUT;
  HGApply1DLUT *v25;
  __n128 v26;
  __n128 v27;
  __n128 v28;
  __n128 v29;
  uint64_t v30;
  HGGamma *v31;
  _DWORD *v32;
  HgcToneParamCurve3AntiSymmetric *v33;
  HgcToneParamCurve2AntiSymmetric *v34;
  HgcToneParamCurve4AntiSymmetric *v35;
  HgcToneParamCurve1AntiSymmetric *v36;
  HgcToneParamCurve3AntiSymmetric *v37;
  HgcToneParamCurve2AntiSymmetric *v38;
  HgcToneParamCurve4AntiSymmetric *v39;
  HgcToneParamCurve1AntiSymmetric *v40;
  HgcToneParamCurve3AntiSymmetric *v41;
  HgcToneParamCurve2AntiSymmetric *v42;
  HgcToneParamCurve4AntiSymmetric *v43;
  __n128 v44;
  __n128 v45;
  __n128 v46;
  __n128 v47;
  HgcToneParamCurve1AntiSymmetric *v48;
  HgcToneParamCurve3AntiSymmetric *v49;
  HgcToneParamCurve2AntiSymmetric *v50;
  HgcToneParamCurve4AntiSymmetric *v51;
  float *v52;
  __n128 v53;
  __n128 v54;
  __n128 v55;
  __n128 v56;
  HgcToneParamCurve3AntiSymmetric *v57;
  HgcToneParamCurve4AntiSymmetric *v58;
  _DWORD *v59;
  float *v60;
  HgcToneParamCurve4AntiSymmetric *v61;
  __n128 v62;
  __n128 v63;
  __n128 v64;
  __n128 v65;
  HgcToneParamCurve4AntiSymmetric *v66;
  _DWORD *v67;

  *(float32x4_t *)(this[25].i64[1] + 128) = this[48];
  *(float32x4_t *)(this[25].i64[1] + 144) = this[49];
  *(float32x4_t *)(this[25].i64[1] + 160) = this[50];
  *(float32x4_t *)(this[25].i64[1] + 176) = this[51];
  *(float32x4_t *)(this[25].i64[1] + 192) = this[52];
  *(float32x4_t *)(this[25].i64[1] + 208) = this[53];
  *(float32x4_t *)(this[25].i64[1] + 224) = this[54];
  *(_DWORD *)(this[25].i64[1] + 240) = this[64].i32[1];
  HGColorGamma::LoadMacroNodeParams(this);
  v6 = this[64].u32[1];
  if (!(_DWORD)v6)
  {
    v9 = vmvnq_s8((int8x16_t)vceqq_f32(vmulq_f32(this[48], (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B3051560));
    *(int32x2_t *)v9.i8 = vpmin_s32(*(int32x2_t *)v9.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL));
    if (vpmin_s32(*(int32x2_t *)v9.i8, *(int32x2_t *)v9.i8).u32[0])
    {
      v7 = this[73].i32[0];
      if ((v7 - 1) <= 1)
      {
        if (this[55].i8[0])
        {
          v10 = (HGGamma *)this[27].i64[1];
          if (!v10)
          {
            v10 = (HGGamma *)HGObject::operator new(0x1B0uLL);
            HGGamma::HGGamma(v10);
            this[27].i64[1] = (uint64_t)v10;
          }
        }
        else
        {
          v10 = (HGGamma *)this[28].i64[0];
          if (!v10)
          {
            v10 = (HGGamma *)HGObject::operator new(0x1C0uLL);
            HGGammaMC::HGGammaMC(v10);
            this[28].i64[0] = (uint64_t)v10;
          }
        }
        (*(void (**)(HGGamma *, _QWORD, float, float, float, float))(*(_QWORD *)v10 + 96))(v10, 0, *(float *)(this[25].i64[1] + 128), *(float *)(this[25].i64[1] + 132), *(float *)(this[25].i64[1] + 136), 1.0);
        v30 = this[28].i64[1];
        if (!v30)
        {
          v31 = (HGGamma *)HGObject::operator new(0x1B0uLL);
          HGGamma::HGGamma(v31);
          this[28].i64[1] = (uint64_t)v31;
          HGGamma::SetPremultiplyState((uint64_t)v31, 0);
          v30 = this[28].i64[1];
        }
        v32 = (_DWORD *)this[25].i64[1];
        v26.n128_u32[0] = v32[32];
        v27.n128_u32[0] = v32[33];
        v28.n128_u32[0] = v32[34];
        v29.n128_u32[0] = 1.0;
        (*(void (**)(uint64_t, _QWORD, __n128, __n128, __n128, __n128))(*(_QWORD *)v30 + 96))(v30, 0, v26, v27, v28, v29);
        return 0;
      }
      goto LABEL_17;
    }
    return 0;
  }
  if ((int)v6 > 4)
  {
    if (v6 <= 9)
      goto LABEL_24;
    return 0;
  }
  v7 = this[73].i32[0];
  if (v7 == 2)
  {
    if ((_DWORD)v6 == 3)
    {
      if (this[73].i8[7])
      {
        v33 = (HgcToneParamCurve3AntiSymmetric *)this[44].i64[0];
        if (!v33)
        {
          v33 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3AntiSymmetric::HgcToneParamCurve3AntiSymmetric(v33);
          this[44].i64[0] = (uint64_t)v33;
        }
      }
      else
      {
        v33 = (HgcToneParamCurve3AntiSymmetric *)this[42].i64[0];
        if (!v33)
        {
          v33 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3::HgcToneParamCurve3(v33);
          this[42].i64[0] = (uint64_t)v33;
        }
      }
      (*(void (**)(HgcToneParamCurve3AntiSymmetric *, _QWORD, float, float, float, float))(*(_QWORD *)v33 + 96))(v33, 0, *(float *)(this[25].i64[1] + 128), *(float *)(this[25].i64[1] + 132), *(float *)(this[25].i64[1] + 136), 1.0);
      if (this[73].i8[7])
      {
        v37 = (HgcToneParamCurve3AntiSymmetric *)this[44].i64[0];
        if (!v37)
        {
          v37 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3AntiSymmetric::HgcToneParamCurve3AntiSymmetric(v37);
          this[44].i64[0] = (uint64_t)v37;
        }
      }
      else
      {
        v37 = (HgcToneParamCurve3AntiSymmetric *)this[42].i64[0];
        if (!v37)
        {
          v37 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3::HgcToneParamCurve3(v37);
          this[42].i64[0] = (uint64_t)v37;
        }
      }
      (*(void (**)(HgcToneParamCurve3AntiSymmetric *, uint64_t, float, float, float, float))(*(_QWORD *)v37 + 96))(v37, 1, *(float *)(this[25].i64[1] + 144), *(float *)(this[25].i64[1] + 148), *(float *)(this[25].i64[1] + 152), 1.0);
      if (this[73].i8[7])
      {
        v41 = (HgcToneParamCurve3AntiSymmetric *)this[44].i64[0];
        if (!v41)
        {
          v41 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3AntiSymmetric::HgcToneParamCurve3AntiSymmetric(v41);
          this[44].i64[0] = (uint64_t)v41;
        }
      }
      else
      {
        v41 = (HgcToneParamCurve3AntiSymmetric *)this[42].i64[0];
        if (!v41)
        {
          v41 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3::HgcToneParamCurve3(v41);
          this[42].i64[0] = (uint64_t)v41;
        }
      }
      (*(void (**)(HgcToneParamCurve3AntiSymmetric *, uint64_t, float, float, float, float))(*(_QWORD *)v41 + 96))(v41, 2, *(float *)(this[25].i64[1] + 160), *(float *)(this[25].i64[1] + 164), *(float *)(this[25].i64[1] + 168), 1.0);
      if (this[73].i8[7])
      {
        v49 = (HgcToneParamCurve3AntiSymmetric *)this[44].i64[0];
        if (!v49)
        {
          v49 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3AntiSymmetric::HgcToneParamCurve3AntiSymmetric(v49);
          this[44].i64[0] = (uint64_t)v49;
        }
      }
      else
      {
        v49 = (HgcToneParamCurve3AntiSymmetric *)this[42].i64[0];
        if (!v49)
        {
          v49 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3::HgcToneParamCurve3(v49);
          this[42].i64[0] = (uint64_t)v49;
        }
      }
      (*(void (**)(HgcToneParamCurve3AntiSymmetric *, uint64_t, float, float, float, float))(*(_QWORD *)v49 + 96))(v49, 3, *(float *)(this[25].i64[1] + 176), *(float *)(this[25].i64[1] + 180), *(float *)(this[25].i64[1] + 184), 1.0);
      if (this[73].i8[7])
      {
        v57 = (HgcToneParamCurve3AntiSymmetric *)this[44].i64[0];
        if (!v57)
        {
          v57 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3AntiSymmetric::HgcToneParamCurve3AntiSymmetric(v57);
          this[44].i64[0] = (uint64_t)v57;
        }
      }
      else
      {
        v57 = (HgcToneParamCurve3AntiSymmetric *)this[42].i64[0];
        if (!v57)
        {
          v57 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3::HgcToneParamCurve3(v57);
          this[42].i64[0] = (uint64_t)v57;
        }
      }
      v59 = (_DWORD *)this[25].i64[1];
      v53.n128_u32[0] = v59[48];
      v54.n128_u32[0] = v59[49];
      v55.n128_u32[0] = v59[50];
    }
    else
    {
      if ((_DWORD)v6 != 2)
      {
        if ((_DWORD)v6 == 1)
        {
          if (this[73].i8[7])
          {
            v8 = (HgcToneParamCurve1AntiSymmetric *)this[43].i64[0];
            if (!v8)
            {
              v8 = (HgcToneParamCurve1AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1AntiSymmetric::HgcToneParamCurve1AntiSymmetric(v8);
              this[43].i64[0] = (uint64_t)v8;
            }
          }
          else
          {
            v8 = (HgcToneParamCurve1AntiSymmetric *)this[41].i64[0];
            if (!v8)
            {
              v8 = (HgcToneParamCurve1AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1::HgcToneParamCurve1(v8);
              this[41].i64[0] = (uint64_t)v8;
            }
          }
          (*(void (**)(HgcToneParamCurve1AntiSymmetric *, _QWORD, float, float, float, float))(*(_QWORD *)v8 + 96))(v8, 0, *(float *)(this[25].i64[1] + 128), *(float *)(this[25].i64[1] + 132), *(float *)(this[25].i64[1] + 136), 1.0);
          if (this[73].i8[7])
          {
            v36 = (HgcToneParamCurve1AntiSymmetric *)this[43].i64[0];
            if (!v36)
            {
              v36 = (HgcToneParamCurve1AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1AntiSymmetric::HgcToneParamCurve1AntiSymmetric(v36);
              this[43].i64[0] = (uint64_t)v36;
            }
          }
          else
          {
            v36 = (HgcToneParamCurve1AntiSymmetric *)this[41].i64[0];
            if (!v36)
            {
              v36 = (HgcToneParamCurve1AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1::HgcToneParamCurve1(v36);
              this[41].i64[0] = (uint64_t)v36;
            }
          }
          (*(void (**)(HgcToneParamCurve1AntiSymmetric *, uint64_t, float, float, float, float))(*(_QWORD *)v36 + 96))(v36, 1, *(float *)(this[25].i64[1] + 144), *(float *)(this[25].i64[1] + 148), *(float *)(this[25].i64[1] + 152), 1.0);
          if (this[73].i8[7])
          {
            v40 = (HgcToneParamCurve1AntiSymmetric *)this[43].i64[0];
            if (!v40)
            {
              v40 = (HgcToneParamCurve1AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1AntiSymmetric::HgcToneParamCurve1AntiSymmetric(v40);
              this[43].i64[0] = (uint64_t)v40;
            }
          }
          else
          {
            v40 = (HgcToneParamCurve1AntiSymmetric *)this[41].i64[0];
            if (!v40)
            {
              v40 = (HgcToneParamCurve1AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1::HgcToneParamCurve1(v40);
              this[41].i64[0] = (uint64_t)v40;
            }
          }
          (*(void (**)(HgcToneParamCurve1AntiSymmetric *, uint64_t, float, float, float, float))(*(_QWORD *)v40 + 96))(v40, 2, *(float *)(this[25].i64[1] + 160), *(float *)(this[25].i64[1] + 164), *(float *)(this[25].i64[1] + 168), 1.0);
          if (this[73].i8[7])
          {
            v48 = (HgcToneParamCurve1AntiSymmetric *)this[43].i64[0];
            if (!v48)
            {
              v48 = (HgcToneParamCurve1AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1AntiSymmetric::HgcToneParamCurve1AntiSymmetric(v48);
              this[43].i64[0] = (uint64_t)v48;
            }
          }
          else
          {
            v48 = (HgcToneParamCurve1AntiSymmetric *)this[41].i64[0];
            if (!v48)
            {
              v48 = (HgcToneParamCurve1AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1::HgcToneParamCurve1(v48);
              this[41].i64[0] = (uint64_t)v48;
            }
          }
          v52 = (float *)this[25].i64[1];
          v44.n128_f64[0] = -v52[40] / v52[36];
          v44.n128_f32[0] = v44.n128_f64[0];
          v45.n128_f64[0] = -v52[41] / v52[37];
          v45.n128_f32[0] = v45.n128_f64[0];
          v47.n128_f64[0] = v52[38];
          v46.n128_f64[0] = -v52[42] / v47.n128_f64[0];
          v46.n128_f32[0] = v46.n128_f64[0];
          v47.n128_u32[0] = 1.0;
          (*(void (**)(HgcToneParamCurve1AntiSymmetric *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)v48 + 96))(v48, 3, v44, v45, v46, v47);
        }
        else
        {
          if (this[73].i8[7])
          {
            v35 = (HgcToneParamCurve4AntiSymmetric *)this[44].i64[1];
            if (!v35)
            {
              v35 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v35);
              this[44].i64[1] = (uint64_t)v35;
            }
          }
          else
          {
            v35 = (HgcToneParamCurve4AntiSymmetric *)this[42].i64[1];
            if (!v35)
            {
              v35 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4::HgcToneParamCurve4(v35);
              this[42].i64[1] = (uint64_t)v35;
            }
          }
          (*(void (**)(HgcToneParamCurve4AntiSymmetric *, _QWORD, float, float, float, float))(*(_QWORD *)v35 + 96))(v35, 0, *(float *)(this[25].i64[1] + 128), *(float *)(this[25].i64[1] + 132), *(float *)(this[25].i64[1] + 136), 1.0);
          if (this[73].i8[7])
          {
            v39 = (HgcToneParamCurve4AntiSymmetric *)this[44].i64[1];
            if (!v39)
            {
              v39 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v39);
              this[44].i64[1] = (uint64_t)v39;
            }
          }
          else
          {
            v39 = (HgcToneParamCurve4AntiSymmetric *)this[42].i64[1];
            if (!v39)
            {
              v39 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4::HgcToneParamCurve4(v39);
              this[42].i64[1] = (uint64_t)v39;
            }
          }
          (*(void (**)(HgcToneParamCurve4AntiSymmetric *, uint64_t, float, float, float, float))(*(_QWORD *)v39 + 96))(v39, 1, *(float *)(this[25].i64[1] + 144), *(float *)(this[25].i64[1] + 148), *(float *)(this[25].i64[1] + 152), 1.0);
          if (this[73].i8[7])
          {
            v43 = (HgcToneParamCurve4AntiSymmetric *)this[44].i64[1];
            if (!v43)
            {
              v43 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v43);
              this[44].i64[1] = (uint64_t)v43;
            }
          }
          else
          {
            v43 = (HgcToneParamCurve4AntiSymmetric *)this[42].i64[1];
            if (!v43)
            {
              v43 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4::HgcToneParamCurve4(v43);
              this[42].i64[1] = (uint64_t)v43;
            }
          }
          (*(void (**)(HgcToneParamCurve4AntiSymmetric *, uint64_t, float, float, float, float))(*(_QWORD *)v43 + 96))(v43, 2, *(float *)(this[25].i64[1] + 160), *(float *)(this[25].i64[1] + 164), *(float *)(this[25].i64[1] + 168), 1.0);
          if (this[73].i8[7])
          {
            v51 = (HgcToneParamCurve4AntiSymmetric *)this[44].i64[1];
            if (!v51)
            {
              v51 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v51);
              this[44].i64[1] = (uint64_t)v51;
            }
          }
          else
          {
            v51 = (HgcToneParamCurve4AntiSymmetric *)this[42].i64[1];
            if (!v51)
            {
              v51 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4::HgcToneParamCurve4(v51);
              this[42].i64[1] = (uint64_t)v51;
            }
          }
          (*(void (**)(HgcToneParamCurve4AntiSymmetric *, uint64_t, float, float, float, float))(*(_QWORD *)v51 + 96))(v51, 3, *(float *)(this[25].i64[1] + 176), *(float *)(this[25].i64[1] + 180), *(float *)(this[25].i64[1] + 184), 1.0);
          if (this[73].i8[7])
          {
            v58 = (HgcToneParamCurve4AntiSymmetric *)this[44].i64[1];
            if (!v58)
            {
              v58 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v58);
              this[44].i64[1] = (uint64_t)v58;
            }
          }
          else
          {
            v58 = (HgcToneParamCurve4AntiSymmetric *)this[42].i64[1];
            if (!v58)
            {
              v58 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4::HgcToneParamCurve4(v58);
              this[42].i64[1] = (uint64_t)v58;
            }
          }
          (*(void (**)(HgcToneParamCurve4AntiSymmetric *, uint64_t, float, float, float, float))(*(_QWORD *)v58 + 96))(v58, 4, *(float *)(this[25].i64[1] + 192), *(float *)(this[25].i64[1] + 196), *(float *)(this[25].i64[1] + 200), 1.0);
          if (this[73].i8[7])
          {
            v61 = (HgcToneParamCurve4AntiSymmetric *)this[44].i64[1];
            if (!v61)
            {
              v61 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v61);
              this[44].i64[1] = (uint64_t)v61;
            }
          }
          else
          {
            v61 = (HgcToneParamCurve4AntiSymmetric *)this[42].i64[1];
            if (!v61)
            {
              v61 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4::HgcToneParamCurve4(v61);
              this[42].i64[1] = (uint64_t)v61;
            }
          }
          (*(void (**)(HgcToneParamCurve4AntiSymmetric *, uint64_t, float, float, float, float))(*(_QWORD *)v61 + 96))(v61, 5, *(float *)(this[25].i64[1] + 208), *(float *)(this[25].i64[1] + 212), *(float *)(this[25].i64[1] + 216), 1.0);
          if (this[73].i8[7])
          {
            v66 = (HgcToneParamCurve4AntiSymmetric *)this[44].i64[1];
            if (!v66)
            {
              v66 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v66);
              this[44].i64[1] = (uint64_t)v66;
            }
          }
          else
          {
            v66 = (HgcToneParamCurve4AntiSymmetric *)this[42].i64[1];
            if (!v66)
            {
              v66 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4::HgcToneParamCurve4(v66);
              this[42].i64[1] = (uint64_t)v66;
            }
          }
          v67 = (_DWORD *)this[25].i64[1];
          v62.n128_u32[0] = v67[56];
          v63.n128_u32[0] = v67[57];
          v64.n128_u32[0] = v67[58];
          v65.n128_u32[0] = 1.0;
          (*(void (**)(HgcToneParamCurve4AntiSymmetric *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)v66 + 96))(v66, 6, v62, v63, v64, v65);
        }
        return 0;
      }
      if (this[73].i8[7])
      {
        v34 = (HgcToneParamCurve2AntiSymmetric *)this[43].i64[1];
        if (!v34)
        {
          v34 = (HgcToneParamCurve2AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2AntiSymmetric::HgcToneParamCurve2AntiSymmetric(v34);
          this[43].i64[1] = (uint64_t)v34;
        }
      }
      else
      {
        v34 = (HgcToneParamCurve2AntiSymmetric *)this[41].i64[1];
        if (!v34)
        {
          v34 = (HgcToneParamCurve2AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2::HgcToneParamCurve2(v34);
          this[41].i64[1] = (uint64_t)v34;
        }
      }
      (*(void (**)(HgcToneParamCurve2AntiSymmetric *, _QWORD, float, float, float, float))(*(_QWORD *)v34 + 96))(v34, 0, *(float *)(this[25].i64[1] + 128), *(float *)(this[25].i64[1] + 132), *(float *)(this[25].i64[1] + 136), 1.0);
      if (this[73].i8[7])
      {
        v38 = (HgcToneParamCurve2AntiSymmetric *)this[43].i64[1];
        if (!v38)
        {
          v38 = (HgcToneParamCurve2AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2AntiSymmetric::HgcToneParamCurve2AntiSymmetric(v38);
          this[43].i64[1] = (uint64_t)v38;
        }
      }
      else
      {
        v38 = (HgcToneParamCurve2AntiSymmetric *)this[41].i64[1];
        if (!v38)
        {
          v38 = (HgcToneParamCurve2AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2::HgcToneParamCurve2(v38);
          this[41].i64[1] = (uint64_t)v38;
        }
      }
      (*(void (**)(HgcToneParamCurve2AntiSymmetric *, uint64_t, float, float, float, float))(*(_QWORD *)v38 + 96))(v38, 1, *(float *)(this[25].i64[1] + 144), *(float *)(this[25].i64[1] + 148), *(float *)(this[25].i64[1] + 152), 1.0);
      if (this[73].i8[7])
      {
        v42 = (HgcToneParamCurve2AntiSymmetric *)this[43].i64[1];
        if (!v42)
        {
          v42 = (HgcToneParamCurve2AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2AntiSymmetric::HgcToneParamCurve2AntiSymmetric(v42);
          this[43].i64[1] = (uint64_t)v42;
        }
      }
      else
      {
        v42 = (HgcToneParamCurve2AntiSymmetric *)this[41].i64[1];
        if (!v42)
        {
          v42 = (HgcToneParamCurve2AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2::HgcToneParamCurve2(v42);
          this[41].i64[1] = (uint64_t)v42;
        }
      }
      (*(void (**)(HgcToneParamCurve2AntiSymmetric *, uint64_t, float, float, float, float))(*(_QWORD *)v42 + 96))(v42, 2, *(float *)(this[25].i64[1] + 160), *(float *)(this[25].i64[1] + 164), *(float *)(this[25].i64[1] + 168), 1.0);
      if (this[73].i8[7])
      {
        v50 = (HgcToneParamCurve2AntiSymmetric *)this[43].i64[1];
        if (!v50)
        {
          v50 = (HgcToneParamCurve2AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2AntiSymmetric::HgcToneParamCurve2AntiSymmetric(v50);
          this[43].i64[1] = (uint64_t)v50;
        }
      }
      else
      {
        v50 = (HgcToneParamCurve2AntiSymmetric *)this[41].i64[1];
        if (!v50)
        {
          v50 = (HgcToneParamCurve2AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2::HgcToneParamCurve2(v50);
          this[41].i64[1] = (uint64_t)v50;
        }
      }
      (*(void (**)(HgcToneParamCurve2AntiSymmetric *, uint64_t, float, float, float, float))(*(_QWORD *)v50 + 96))(v50, 3, *(float *)(this[25].i64[1] + 176), *(float *)(this[25].i64[1] + 180), *(float *)(this[25].i64[1] + 184), 1.0);
      if (this[73].i8[7])
      {
        v57 = (HgcToneParamCurve3AntiSymmetric *)this[43].i64[1];
        if (!v57)
        {
          v57 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2AntiSymmetric::HgcToneParamCurve2AntiSymmetric(v57);
          this[43].i64[1] = (uint64_t)v57;
        }
      }
      else
      {
        v57 = (HgcToneParamCurve3AntiSymmetric *)this[41].i64[1];
        if (!v57)
        {
          v57 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2::HgcToneParamCurve2(v57);
          this[41].i64[1] = (uint64_t)v57;
        }
      }
      v60 = (float *)this[25].i64[1];
      v53.n128_f64[0] = -v60[40] / v60[36];
      v53.n128_f32[0] = v53.n128_f64[0];
      v54.n128_f64[0] = -v60[41] / v60[37];
      v54.n128_f32[0] = v54.n128_f64[0];
      v56.n128_f64[0] = v60[38];
      v55.n128_f64[0] = -v60[42] / v56.n128_f64[0];
      v55.n128_f32[0] = v55.n128_f64[0];
    }
    v56.n128_u32[0] = 1.0;
    (*(void (**)(HgcToneParamCurve3AntiSymmetric *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)v57 + 96))(v57, 4, v53, v54, v55, v56);
    return 0;
  }
LABEL_17:
  if (v7 < 3 || !this[55].i8[0])
  {
LABEL_24:
    if ((v16 & 1) == 0
    {
    }
    switch(this[64].i32[1])
    {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
        v17 = operator new();
        v18 = this[25].i64[1];
        HGColorGammaLUTInfo::HGColorGammaLUTInfo(v17, this[72].u32[0], *(_DWORD *)(v18 + 240), 1, this[72].f32[1], this[72].f32[2], *(__n128 *)(v18 + 128), *(int8x16_t *)(v18 + 144), *(int8x16_t *)(v18 + 160), *(int8x16_t *)(v18 + 176), *(__n128 *)(v18 + 192), *(int8x16_t *)(v18 + 208), v19, v20, v21, v22, *(int8x16_t *)(v18 + 224));
        break;
      case 5:
        switch(this[64].i32[2])
        {
          case 0:
            v17 = operator new();
            HGArriLogCDefaultToneCurveLUTInfo::HGArriLogCDefaultToneCurveLUTInfo(v17, this[72].u32[0], 0, 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 1:
            v17 = operator new();
            HGArriLogCDefaultToneCurveLUTInfo::HGArriLogCDefaultToneCurveLUTInfo(v17, this[72].u32[0], 1, 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 2:
            v17 = operator new();
            HGArriLogCLinearizationLUTInfo::HGArriLogCLinearizationLUTInfo(v17, this[72].u32[0], this[72].u32[3], 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 3:
            v17 = operator new();
            HGArriLogC4LinearizationLUTInfo::HGArriLogC4LinearizationLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 4:
            v17 = operator new();
            HGCanonLogToneCurveLUTInfo::HGCanonLogToneCurveLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 5:
            v17 = operator new();
            HGCanonLogLinearizationLUTInfo::HGCanonLogLinearizationLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 6:
            v17 = operator new();
            HGCanonLog2LinearizationLUTInfo::HGCanonLog2LinearizationLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 7:
            v17 = operator new();
            HGCanonLog3LinearizationLUTInfo::HGCanonLog3LinearizationLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 8:
            v17 = operator new();
            HGSonySLog2LinearizationLUTInfo::HGSonySLog2LinearizationLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 9:
            v17 = operator new();
            HGSonySLog3LinearizationLUTInfo::HGSonySLog3LinearizationLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 0xA:
            v17 = operator new();
            HGPanasonicVLogLinearizationLUTInfo::HGPanasonicVLogLinearizationLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 0xB:
            v17 = operator new();
            HGNikonNLogLinearizationLUTInfo::HGNikonNLogLinearizationLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 0xC:
            v17 = operator new();
            HGBMDFilmLinearizationLUTInfo::HGBMDFilmLinearizationLUTInfo(v17, this[72].u32[0], 0, 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 0xD:
            v17 = operator new();
            HGBMDFilmLinearizationLUTInfo::HGBMDFilmLinearizationLUTInfo(v17, this[72].u32[0], 1, 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 0xE:
            v17 = operator new();
            HGAppleLogLinearizationLUTInfo::HGAppleLogLinearizationLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 0xF:
            v17 = operator new();
            HGDJIDLogLinearizationLUTInfo::HGDJIDLogLinearizationLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 0x10:
            v17 = operator new();
            HGFujifilmFLogLinearizationLUTInfo::HGFujifilmFLogLinearizationLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
            break;
          case 0x11:
            v17 = operator new();
            HGFujifilmFLog2LinearizationLUTInfo::HGFujifilmFLog2LinearizationLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
            break;
          default:
            goto LABEL_49;
        }
        break;
      case 6:
        v17 = operator new();
        HGAYCCToneCurveToLinearLUTInfo::HGAYCCToneCurveToLinearLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
        break;
      case 7:
        v17 = operator new();
        HGLinearToAYCCToneCurveLUTInfo::HGLinearToAYCCToneCurveLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
        break;
      case 8:
        v17 = operator new();
        HG_ERsRGBToneCurveToLinearLUTInfo::HG_ERsRGBToneCurveToLinearLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
        break;
      case 9:
        v17 = operator new();
        HGLinearToERsRGBToneCurveLUTInfo::HGLinearToERsRGBToneCurveLUTInfo(v17, this[72].u32[0], 1, this[72].f32[1], this[72].f32[2]);
        break;
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
      case 0xE:
      case 0xF:
      case 0x10:
      case 0x11:
      case 0x12:
        v17 = operator new();
        HGAYCCToneCurveToLinearLUTInfo::HGAYCCToneCurveToLinearLUTInfo(v17, 16, 1, 1.0, 0.0);
        break;
      default:
LABEL_49:
        v17 = 0;
        break;
    }
    LUTCache = HGLUTCacheManager::getLUTCache(*((_QWORD *)a3 + 69), (unint64_t)&HGColorGamma::ScaleParams(HGNode *,HGRenderer *)::lutFactory);
    NewLUT = (HGBitmap *)HGLUTCache::getNewLUT(LUTCache, v17);
    v25 = (HGApply1DLUT *)this[40].i64[0];
    if (!v25)
    {
      v25 = (HGApply1DLUT *)HGObject::operator new(0x1D0uLL);
      HGApply1DLUT::HGApply1DLUT(v25, this[72].i32[0], this[72].f32[1], this[72].f32[2], 1, 1, 1, 0, 1, 1);
      this[40].i64[0] = (uint64_t)v25;
    }
    HGApply1DLUT::SetLUTBitmap(v25, NewLUT);
    (*(void (**)(HGBitmap *))(*(_QWORD *)NewLUT + 24))(NewLUT);
    if (v17)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
      return 0;
    }
    return 0;
  }
  v11 = (HGToneCurve *)this[29].i64[0];
  if (!v11)
  {
    v11 = (HGToneCurve *)HGObject::operator new(0x1E0uLL);
    HGToneCurve::HGToneCurve(v11);
    this[29].i64[0] = (uint64_t)v11;
    v6 = this[64].u32[1];
  }
  v12 = (float *)this[25].i64[1];
  HGToneCurve::SetToneCurveParams((uint64_t)v11, v6, v5, v12[32], v12[36], v12[40], v12[44], v12[48], v12[52], v12[56]);
  v14 = (HGToneCurve *)this[29].i64[0];
  if (!v14)
  {
    v14 = (HGToneCurve *)HGObject::operator new(0x1E0uLL);
    HGToneCurve::HGToneCurve(v14);
    this[29].i64[0] = (uint64_t)v14;
  }
  HGToneCurve::SetToneCurveQuality((uint64_t)v14, (this[73].i32[0] - 3), v13);
  return 0;
}

void sub_1B2A34844(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1081C40A1FA7B50);
  _Unwind_Resume(a1);
}

HgcColorGamma_2vuy_xyxz_expand *HGColorGamma::m_Get2vuy_XYXZExpandNode(HGColorGamma *this)
{
  HgcColorGamma_2vuy_xyxz_expand *v3;

  if (*((_QWORD *)this + 60))
    return (HgcColorGamma_2vuy_xyxz_expand *)*((_QWORD *)this + 60);
  v3 = (HgcColorGamma_2vuy_xyxz_expand *)HGObject::operator new(0x1A0uLL);
  *(_OWORD *)v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 13) = 0u;
  *((_OWORD *)v3 + 14) = 0u;
  *((_OWORD *)v3 + 15) = 0u;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  *((_OWORD *)v3 + 18) = 0u;
  *((_OWORD *)v3 + 19) = 0u;
  *((_OWORD *)v3 + 20) = 0u;
  *((_OWORD *)v3 + 21) = 0u;
  *((_OWORD *)v3 + 22) = 0u;
  *((_OWORD *)v3 + 23) = 0u;
  *((_OWORD *)v3 + 24) = 0u;
  *((_OWORD *)v3 + 25) = 0u;
  HgcColorGamma_2vuy_xyxz_expand::HgcColorGamma_2vuy_xyxz_expand(v3);
  *(_QWORD *)v3 = off_1E6520780;
  *((_QWORD *)this + 60) = v3;
  return v3;
}

void sub_1B2A34D94(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HgcColorGamma_v210_yxzx_rgba_expand *HGColorGamma::m_Getv210_YXZXExpandNode(HGColorGamma *this, HGRenderer *a2)
{
  HgcColorGamma_v210_yxzx_rgba_expand *v4;

  if (*((_QWORD *)this + 62))
    return (HgcColorGamma_v210_yxzx_rgba_expand *)*((_QWORD *)this + 62);
  v4 = (HgcColorGamma_v210_yxzx_rgba_expand *)HGObject::operator new(0x1A0uLL);
  HgcColorGamma_v210_yxzx_rgba_expand::HgcColorGamma_v210_yxzx_rgba_expand(v4);
  *(_QWORD *)v4 = off_1E65209E8;
  *((_QWORD *)this + 62) = v4;
  return v4;
}

void sub_1B2A34E00(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HgcColorGamma_v216_yxzx_expand *HGColorGamma::m_Getv216_YXZXExpandNode(HGColorGamma *this)
{
  HgcColorGamma_v216_yxzx_expand *v3;

  if (*((_QWORD *)this + 61))
    return (HgcColorGamma_v216_yxzx_expand *)*((_QWORD *)this + 61);
  v3 = (HgcColorGamma_v216_yxzx_expand *)HGObject::operator new(0x1A0uLL);
  *(_OWORD *)v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 13) = 0u;
  *((_OWORD *)v3 + 14) = 0u;
  *((_OWORD *)v3 + 15) = 0u;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  *((_OWORD *)v3 + 18) = 0u;
  *((_OWORD *)v3 + 19) = 0u;
  *((_OWORD *)v3 + 20) = 0u;
  *((_OWORD *)v3 + 21) = 0u;
  *((_OWORD *)v3 + 22) = 0u;
  *((_OWORD *)v3 + 23) = 0u;
  *((_OWORD *)v3 + 24) = 0u;
  *((_OWORD *)v3 + 25) = 0u;
  HgcColorGamma_v216_yxzx_expand::HgcColorGamma_v216_yxzx_expand(v3);
  *(_QWORD *)v3 = off_1E6520C50;
  *((_QWORD *)this + 61) = v3;
  return v3;
}

void sub_1B2A34EA4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGGamma *HGColorGamma::m_GetGammaUniformNode(HGColorGamma *this)
{
  HGGamma *v3;

  if (*((_QWORD *)this + 55))
    return (HGGamma *)*((_QWORD *)this + 55);
  v3 = (HGGamma *)HGObject::operator new(0x1B0uLL);
  HGGamma::HGGamma(v3);
  *((_QWORD *)this + 55) = v3;
  return v3;
}

void sub_1B2A34F04(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGGammaMC *HGColorGamma::m_GetGammaMCNode(HGColorGamma *this)
{
  HGGammaMC *v3;

  if (*((_QWORD *)this + 56))
    return (HGGammaMC *)*((_QWORD *)this + 56);
  v3 = (HGGammaMC *)HGObject::operator new(0x1C0uLL);
  HGGammaMC::HGGammaMC(v3);
  *((_QWORD *)this + 56) = v3;
  return v3;
}

void sub_1B2A34F64(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HgcToneParamCurve1AntiSymmetric *HGColorGamma::m_GetToneParamCurve1(HGColorGamma *this)
{
  uint64_t v2;
  HgcToneParamCurve1 *v4;
  HgcToneParamCurve1AntiSymmetric *v5;

  if (*((_BYTE *)this + 1175))
  {
    v2 = *((_QWORD *)this + 86);
    if (v2)
      return (HgcToneParamCurve1AntiSymmetric *)v2;
    v5 = (HgcToneParamCurve1AntiSymmetric *)HGObject::operator new(0x1A0uLL);
    HgcToneParamCurve1AntiSymmetric::HgcToneParamCurve1AntiSymmetric(v5);
    *((_QWORD *)this + 86) = v5;
    return v5;
  }
  else
  {
    v2 = *((_QWORD *)this + 82);
    if (v2)
      return (HgcToneParamCurve1AntiSymmetric *)v2;
    v4 = (HgcToneParamCurve1 *)HGObject::operator new(0x1A0uLL);
    HgcToneParamCurve1::HgcToneParamCurve1(v4);
    *((_QWORD *)this + 82) = v4;
    return v4;
  }
}

void sub_1B2A34FF8(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A3500C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HgcToneParamCurve2AntiSymmetric *HGColorGamma::m_GetToneParamCurve2(HGColorGamma *this)
{
  uint64_t v2;
  HgcToneParamCurve2 *v4;
  HgcToneParamCurve2AntiSymmetric *v5;

  if (*((_BYTE *)this + 1175))
  {
    v2 = *((_QWORD *)this + 87);
    if (v2)
      return (HgcToneParamCurve2AntiSymmetric *)v2;
    v5 = (HgcToneParamCurve2AntiSymmetric *)HGObject::operator new(0x1A0uLL);
    HgcToneParamCurve2AntiSymmetric::HgcToneParamCurve2AntiSymmetric(v5);
    *((_QWORD *)this + 87) = v5;
    return v5;
  }
  else
  {
    v2 = *((_QWORD *)this + 83);
    if (v2)
      return (HgcToneParamCurve2AntiSymmetric *)v2;
    v4 = (HgcToneParamCurve2 *)HGObject::operator new(0x1A0uLL);
    HgcToneParamCurve2::HgcToneParamCurve2(v4);
    *((_QWORD *)this + 83) = v4;
    return v4;
  }
}

void sub_1B2A350A0(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A350B4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HgcToneParamCurve3AntiSymmetric *HGColorGamma::m_GetToneParamCurve3(HGColorGamma *this)
{
  uint64_t v2;
  HgcToneParamCurve3 *v4;
  HgcToneParamCurve3AntiSymmetric *v5;

  if (*((_BYTE *)this + 1175))
  {
    v2 = *((_QWORD *)this + 88);
    if (v2)
      return (HgcToneParamCurve3AntiSymmetric *)v2;
    v5 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
    HgcToneParamCurve3AntiSymmetric::HgcToneParamCurve3AntiSymmetric(v5);
    *((_QWORD *)this + 88) = v5;
    return v5;
  }
  else
  {
    v2 = *((_QWORD *)this + 84);
    if (v2)
      return (HgcToneParamCurve3AntiSymmetric *)v2;
    v4 = (HgcToneParamCurve3 *)HGObject::operator new(0x1A0uLL);
    HgcToneParamCurve3::HgcToneParamCurve3(v4);
    *((_QWORD *)this + 84) = v4;
    return v4;
  }
}

void sub_1B2A35148(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A3515C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HgcToneParamCurve4AntiSymmetric *HGColorGamma::m_GetToneParamCurve4(HGColorGamma *this)
{
  uint64_t v2;
  HgcToneParamCurve4 *v4;
  HgcToneParamCurve4AntiSymmetric *v5;

  if (*((_BYTE *)this + 1175))
  {
    v2 = *((_QWORD *)this + 89);
    if (v2)
      return (HgcToneParamCurve4AntiSymmetric *)v2;
    v5 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
    HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v5);
    *((_QWORD *)this + 89) = v5;
    return v5;
  }
  else
  {
    v2 = *((_QWORD *)this + 85);
    if (v2)
      return (HgcToneParamCurve4AntiSymmetric *)v2;
    v4 = (HgcToneParamCurve4 *)HGObject::operator new(0x1A0uLL);
    HgcToneParamCurve4::HgcToneParamCurve4(v4);
    *((_QWORD *)this + 85) = v4;
    return v4;
  }
}

void sub_1B2A351F0(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A35204(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGToneCurve *HGColorGamma::m_GetGammaFittedNode(HGColorGamma *this)
{
  HGToneCurve *v3;

  if (*((_QWORD *)this + 58))
    return (HGToneCurve *)*((_QWORD *)this + 58);
  v3 = (HGToneCurve *)HGObject::operator new(0x1E0uLL);
  HGToneCurve::HGToneCurve(v3);
  *((_QWORD *)this + 58) = v3;
  return v3;
}

void sub_1B2A35264(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGHLG::OETF *HGColorGamma::m_GetHDRFunctionNode(uint64_t a1, int a2)
{
  HGHLG::OETF *result;
  HGHLG::OETF *v4;

  if (*(_QWORD *)(a1 + 648))
    return *(HGHLG::OETF **)(a1 + 648);
  switch(a2)
  {
    case 10:
      v4 = (HGHLG::OETF *)HGObject::operator new(0x1B0uLL);
      HGHLG::OETF::OETF(v4);
      goto LABEL_14;
    case 11:
      v4 = (HGHLG::OETF *)HGObject::operator new(0x1B0uLL);
      HGHLG::InverseOETF::InverseOETF(v4);
      goto LABEL_14;
    case 12:
      v4 = (HGHLG::OETF *)HGObject::operator new(0x1B0uLL);
      HGPQ::OETF::OETF(v4, 1, 100.0);
      goto LABEL_14;
    case 13:
      v4 = (HGHLG::OETF *)HGObject::operator new(0x1B0uLL);
      HGPQ::InverseOETF::InverseOETF(v4, 1, 100.0);
      goto LABEL_14;
    case 14:
      v4 = (HGHLG::OETF *)HGObject::operator new(0x1B0uLL);
      HGPQ::EOTF::EOTF((HGNode *)v4, 100.0);
      goto LABEL_14;
    case 15:
      v4 = (HGHLG::OETF *)HGObject::operator new(0x1B0uLL);
      HGPQ::InverseEOTF::InverseEOTF((HGNode *)v4, 100.0);
      goto LABEL_14;
    case 16:
      v4 = (HGHLG::OETF *)HGObject::operator new(0x1B0uLL);
      HGACEScct::Encode::Encode(v4);
      goto LABEL_14;
    case 17:
      v4 = (HGHLG::OETF *)HGObject::operator new(0x1B0uLL);
      HGACEScct::Decode::Decode(v4);
      goto LABEL_14;
    case 18:
      v4 = (HGHLG::OETF *)HGObject::operator new(0x1A0uLL);
      HGSony709_800_MLUT::HGSony709_800_MLUT(v4);
LABEL_14:
      *(_QWORD *)(a1 + 648) = v4;
      result = v4;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

void sub_1B2A353CC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A353E0(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A353F4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A35408(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A3541C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A35430(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A35444(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A35458(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A3546C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HgcUnpremultiplySanitized *HGColorGamma::m_GetUnpremultiplyNode(HGColorGamma *this)
{
  float v3;
  uint64_t v4;
  HgcUnpremultiplySanitized *v5;
  char v6;

  if (*((_QWORD *)this + 73))
    return (HgcUnpremultiplySanitized *)*((_QWORD *)this + 73);
  v3 = 2.5;
  switch(*((_DWORD *)this + 257))
  {
    case 5:
      v4 = *((int *)this + 258);
      v3 = 0.0;
      if (v4 < 0x12)
        v3 = flt_1B309F4D4[v4];
      goto LABEL_9;
    case 0xB:
      goto LABEL_9;
    case 0xD:
    case 0xE:
      v3 = 1.5;
      goto LABEL_9;
    case 0x11:
      v3 = 1.468;
LABEL_9:
      v5 = (HgcUnpremultiplySanitized *)HGObject::operator new(0x1A0uLL);
      HgcUnpremultiplySanitized::HgcUnpremultiplySanitized(v5);
      (*(void (**)(HgcUnpremultiplySanitized *, _QWORD, float, float, float, float))(*(_QWORD *)v5 + 96))(v5, 0, v3, 0.0, 0.0, 0.0);
      v6 = 0;
      break;
    default:
      v5 = (HgcUnpremultiplySanitized *)HGObject::operator new(0x1A0uLL);
      HgcUnpremultiply::HgcUnpremultiply(v5);
      v6 = 1;
      break;
  }
  *((_QWORD *)this + 73) = v5;
  *((_BYTE *)this + 1174) = v6;
  return v5;
}

void sub_1B2A3557C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A35590(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HgcPixelFormatConversion_kV4B10Bit_BE_output *HGColorGamma::m_GetPixelFormatConversion_kV4B10Bit_BE_OutputNode(HGColorGamma *this)
{
  HgcPixelFormatConversion_kV4B10Bit_BE_output *v3;

  if (*((_QWORD *)this + 71))
    return (HgcPixelFormatConversion_kV4B10Bit_BE_output *)*((_QWORD *)this + 71);
  v3 = (HgcPixelFormatConversion_kV4B10Bit_BE_output *)HGObject::operator new(0x1A0uLL);
  *(_OWORD *)v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 13) = 0u;
  *((_OWORD *)v3 + 14) = 0u;
  *((_OWORD *)v3 + 15) = 0u;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  *((_OWORD *)v3 + 18) = 0u;
  *((_OWORD *)v3 + 19) = 0u;
  *((_OWORD *)v3 + 20) = 0u;
  *((_OWORD *)v3 + 21) = 0u;
  *((_OWORD *)v3 + 22) = 0u;
  *((_OWORD *)v3 + 23) = 0u;
  *((_OWORD *)v3 + 24) = 0u;
  *((_OWORD *)v3 + 25) = 0u;
  HgcPixelFormatConversion_kV4B10Bit_BE_output::HgcPixelFormatConversion_kV4B10Bit_BE_output(v3);
  *(_QWORD *)v3 = off_1E6521888;
  *((_QWORD *)this + 71) = v3;
  return v3;
}

void sub_1B2A35634(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HgcPixelFormatConversion_kV4S_BE_WXYZ_output *HGColorGamma::m_GetPixelFormatConversion_kV4S_BE_WXYZ_OutputNode(HGColorGamma *this)
{
  HgcPixelFormatConversion_kV4S_BE_WXYZ_output *v3;

  if (*((_QWORD *)this + 70))
    return (HgcPixelFormatConversion_kV4S_BE_WXYZ_output *)*((_QWORD *)this + 70);
  v3 = (HgcPixelFormatConversion_kV4S_BE_WXYZ_output *)HGObject::operator new(0x1A0uLL);
  *(_OWORD *)v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 13) = 0u;
  *((_OWORD *)v3 + 14) = 0u;
  *((_OWORD *)v3 + 15) = 0u;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  *((_OWORD *)v3 + 18) = 0u;
  *((_OWORD *)v3 + 19) = 0u;
  *((_OWORD *)v3 + 20) = 0u;
  *((_OWORD *)v3 + 21) = 0u;
  *((_OWORD *)v3 + 22) = 0u;
  *((_OWORD *)v3 + 23) = 0u;
  *((_OWORD *)v3 + 24) = 0u;
  *((_OWORD *)v3 + 25) = 0u;
  HgcPixelFormatConversion_kV4S_BE_WXYZ_output::HgcPixelFormatConversion_kV4S_BE_WXYZ_output(v3);
  *(_QWORD *)v3 = off_1E6521620;
  *((_QWORD *)this + 70) = v3;
  return v3;
}

void sub_1B2A356D8(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HgcPixelFormatConversion_kV4B_WXYZ_output *HGColorGamma::m_GetPixelFormatConversion_kV4B_WXYZ_OutputNode(HGColorGamma *this)
{
  HgcPixelFormatConversion_kV4B_WXYZ_output *v3;

  if (*((_QWORD *)this + 63))
    return (HgcPixelFormatConversion_kV4B_WXYZ_output *)*((_QWORD *)this + 63);
  v3 = (HgcPixelFormatConversion_kV4B_WXYZ_output *)HGObject::operator new(0x200uLL);
  *(_OWORD *)v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 13) = 0u;
  *((_OWORD *)v3 + 14) = 0u;
  *((_OWORD *)v3 + 15) = 0u;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  *((_OWORD *)v3 + 18) = 0u;
  *((_OWORD *)v3 + 19) = 0u;
  *((_OWORD *)v3 + 20) = 0u;
  *((_OWORD *)v3 + 21) = 0u;
  *((_OWORD *)v3 + 22) = 0u;
  *((_OWORD *)v3 + 23) = 0u;
  *((_OWORD *)v3 + 24) = 0u;
  *((_OWORD *)v3 + 25) = 0u;
  *((_OWORD *)v3 + 26) = 0u;
  *((_OWORD *)v3 + 27) = 0u;
  *((_OWORD *)v3 + 28) = 0u;
  *((_OWORD *)v3 + 29) = 0u;
  *((_OWORD *)v3 + 30) = 0u;
  *((_OWORD *)v3 + 31) = 0u;
  HgcPixelFormatConversion_kV4B_WXYZ_output::HgcPixelFormatConversion_kV4B_WXYZ_output(v3);
  *(_QWORD *)v3 = off_1E6520EB8;
  *((_QWORD *)this + 63) = v3;
  return v3;
}

void sub_1B2A35788(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HgcPixelFormatConversion_kV4S_WXYZ_output *HGColorGamma::m_GetPixelFormatConversion_kV4S_WXYZ_OutputNode(HGColorGamma *this)
{
  HgcPixelFormatConversion_kV4S_WXYZ_output *v3;

  if (*((_QWORD *)this + 64))
    return (HgcPixelFormatConversion_kV4S_WXYZ_output *)*((_QWORD *)this + 64);
  v3 = (HgcPixelFormatConversion_kV4S_WXYZ_output *)HGObject::operator new(0x200uLL);
  *(_OWORD *)v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 13) = 0u;
  *((_OWORD *)v3 + 14) = 0u;
  *((_OWORD *)v3 + 15) = 0u;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  *((_OWORD *)v3 + 18) = 0u;
  *((_OWORD *)v3 + 19) = 0u;
  *((_OWORD *)v3 + 20) = 0u;
  *((_OWORD *)v3 + 21) = 0u;
  *((_OWORD *)v3 + 22) = 0u;
  *((_OWORD *)v3 + 23) = 0u;
  *((_OWORD *)v3 + 24) = 0u;
  *((_OWORD *)v3 + 25) = 0u;
  *((_OWORD *)v3 + 26) = 0u;
  *((_OWORD *)v3 + 27) = 0u;
  *((_OWORD *)v3 + 28) = 0u;
  *((_OWORD *)v3 + 29) = 0u;
  *((_OWORD *)v3 + 30) = 0u;
  *((_OWORD *)v3 + 31) = 0u;
  HgcPixelFormatConversion_kV4S_WXYZ_output::HgcPixelFormatConversion_kV4S_WXYZ_output(v3);
  *(_QWORD *)v3 = off_1E6521130;
  *((_QWORD *)this + 64) = v3;
  return v3;
}

void sub_1B2A35838(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HgcPixelFormatConversion_kV4F_WXYZ_output *HGColorGamma::m_GetPixelFormatConversion_kV4F_WXYZ_OutputNode(HGColorGamma *this)
{
  HgcPixelFormatConversion_kV4F_WXYZ_output *v3;

  if (*((_QWORD *)this + 65))
    return (HgcPixelFormatConversion_kV4F_WXYZ_output *)*((_QWORD *)this + 65);
  v3 = (HgcPixelFormatConversion_kV4F_WXYZ_output *)HGObject::operator new(0x200uLL);
  *(_OWORD *)v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 13) = 0u;
  *((_OWORD *)v3 + 14) = 0u;
  *((_OWORD *)v3 + 15) = 0u;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  *((_OWORD *)v3 + 18) = 0u;
  *((_OWORD *)v3 + 19) = 0u;
  *((_OWORD *)v3 + 20) = 0u;
  *((_OWORD *)v3 + 21) = 0u;
  *((_OWORD *)v3 + 22) = 0u;
  *((_OWORD *)v3 + 23) = 0u;
  *((_OWORD *)v3 + 24) = 0u;
  *((_OWORD *)v3 + 25) = 0u;
  *((_OWORD *)v3 + 26) = 0u;
  *((_OWORD *)v3 + 27) = 0u;
  *((_OWORD *)v3 + 28) = 0u;
  *((_OWORD *)v3 + 29) = 0u;
  *((_OWORD *)v3 + 30) = 0u;
  *((_OWORD *)v3 + 31) = 0u;
  HgcPixelFormatConversion_kV4F_WXYZ_output::HgcPixelFormatConversion_kV4F_WXYZ_output(v3);
  *(_QWORD *)v3 = off_1E65213A8;
  *((_QWORD *)this + 65) = v3;
  return v3;
}

void sub_1B2A358E8(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

_OWORD *HGColorGamma::LoadMacroNodeParams(_OWORD *this)
{
  _OWORD *v1;
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  int8x16_t v6;
  float32x4_t v7;
  HGColorMatrix *v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  int8x16_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  HGColorMatrix *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  uint64_t v24;

  v1 = this;
  v24 = *MEMORY[0x1E0C80C00];
  v3 = *((float32x4_t *)this + 56);
  v2 = *((float32x4_t *)this + 57);
  v5 = *((float32x4_t *)this + 58);
  v4 = *((float32x4_t *)this + 59);
  v6 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(v2, (float32x4_t)xmmword_1B304F240), (int8x16_t)vceqq_f32(v3, (float32x4_t)xmmword_1B304F230)), vandq_s8((int8x16_t)vceqq_f32(v5, (float32x4_t)xmmword_1B304F250), (int8x16_t)vceqq_f32(v4, (float32x4_t)xmmword_1B304EFF0))))));
  *(int32x2_t *)v6.i8 = vpmin_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  if (vpmin_s32(*(int32x2_t *)v6.i8, *(int32x2_t *)v6.i8).u32[0])
  {
    v7 = *((float32x4_t *)this + 67);
    v20 = vmulq_f32(v3, v7);
    v21 = vmulq_f32(v7, v2);
    v22 = vmulq_f32(v7, v5);
    v23 = vmulq_f32(v7, v4);
    v8 = (HGColorMatrix *)*((_QWORD *)this + 53);
    if (!v8)
    {
      v8 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
      HGColorMatrix::HGColorMatrix(v8);
      *((_QWORD *)v1 + 53) = v8;
    }
    this = HGColorMatrix::LoadMatrix(v8, &v20, 1);
  }
  v10 = *((float32x4_t *)v1 + 60);
  v9 = *((float32x4_t *)v1 + 61);
  v12 = *((float32x4_t *)v1 + 62);
  v11 = *((float32x4_t *)v1 + 63);
  v13 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(v9, (float32x4_t)xmmword_1B304F240), (int8x16_t)vceqq_f32(v10, (float32x4_t)xmmword_1B304F230)), vandq_s8((int8x16_t)vceqq_f32(v12, (float32x4_t)xmmword_1B304F250), (int8x16_t)vceqq_f32(v11, (float32x4_t)xmmword_1B304EFF0))))));
  *(int32x2_t *)v13.i8 = vpmin_s32(*(int32x2_t *)v13.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL));
  if (vpmin_s32(*(int32x2_t *)v13.i8, *(int32x2_t *)v13.i8).u32[0])
  {
    v14 = *((int8x16_t *)v1 + 68);
    *(int32x2_t *)v15.f32 = vdup_lane_s32(*(int32x2_t *)v14.i8, 0);
    *(int8x8_t *)&v15.u32[2] = vqtbl1_s8(v14, (int8x8_t)0xF0E0D0C03020100);
    v16 = vmulq_f32(v10, v15);
    *(int32x2_t *)v15.f32 = vdup_lane_s32(*(int32x2_t *)v14.i8, 1);
    *(int8x8_t *)&v15.u32[2] = vqtbl1_s8(v14, (int8x8_t)0xF0E0D0C07060504);
    v20 = v16;
    v21 = vmulq_f32(v9, v15);
    *(int8x8_t *)v17.f32 = vqtbl1_s8(v14, (int8x8_t)0xB0A09080B0A0908);
    *(int8x8_t *)&v17.u32[2] = vqtbl1_s8(v14, (int8x8_t)0xF0E0D0C0B0A0908);
    v18 = vmulq_f32(v12, v17);
    *(int8x8_t *)v17.f32 = vqtbl1_s8(v14, (int8x8_t)0xF0E0D0C0F0E0D0CLL);
    v17.i64[1] = v17.i64[0];
    v22 = v18;
    v23 = vmulq_f32(v11, v17);
    v19 = (HGColorMatrix *)*((_QWORD *)v1 + 54);
    if (!v19)
    {
      v19 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
      HGColorMatrix::HGColorMatrix(v19);
      *((_QWORD *)v1 + 54) = v19;
    }
    return HGColorMatrix::LoadMatrix(v19, &v20, 1);
  }
  return this;
}

void sub_1B2A35AF4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A35B08(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorGamma::PrepareOutputNode(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(result + 1036) == 1)
  {
    *(_QWORD *)(result + 1040) = a3;
    *(_QWORD *)(result + 1048) = a4;
  }
  return result;
}

char *HGColorGamma::label_B(HGColorGamma *this)
{
  return hgcolorgamma_span_read_label[*(int *)(*((_QWORD *)this + 51) + 288)];
}

uint64_t HGColorGamma::SetParameter(HGColorGamma *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

HGNode *HGColorGamma::SetFallbackMode(HGNode *this, uint64_t a2, char *a3)
{
  char v3;
  HGNode *result;

  v3 = a2;
  result = HGNode::ClearBits(this, a2, a3);
  *((_BYTE *)this + 745) = 1;
  *((_BYTE *)this + 1024) = v3;
  return result;
}

HGNode *HGColorGamma::SetToneQualityMode(uint64_t a1, uint64_t a2, char *a3)
{
  int v3;
  HGNode *result;

  v3 = a2;
  result = HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(_BYTE *)(a1 + 745) = 1;
  *(_DWORD *)(a1 + 1168) = v3;
  return result;
}

HGNode *HGColorGamma::SetInOut422FilterMode(uint64_t a1, uint64_t a2, char *a3)
{
  int v3;
  HGNode *result;

  v3 = a2;
  result = HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(_BYTE *)(a1 + 745) = 1;
  *(_DWORD *)(a1 + 1036) = v3;
  return result;
}

HGRect *HGColorGamma::SetInOut422FilterRect(HGRect *this, HGRect a2)
{
  this[65] = a2;
  return this;
}

double HGColorGamma::SetInputPixelFormat(uint64_t a1, uint64_t a2, char *a3)
{
  int v3;
  uint64_t v5;
  char *v6;
  double result;

  v3 = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(_BYTE *)(a1 + 745) = 1;
  *(_DWORD *)(a1 + 1060) = v3;
  *(_QWORD *)&result = HGColorGamma::SetYCbCrBiasAndScale((HGNode *)a1, v5, v6).n128_u64[0];
  return result;
}

__n128 HGColorGamma::SetYCbCrBiasAndScale(HGNode *this, uint64_t a2, char *a3)
{
  __int128 v5;
  uint64_t v10;
  char *v11;
  __n128 result;
  __int128 v13;
  uint64_t v14;
  char *v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __n128 v19;

  _Q0 = xmmword_1B309E150;
  v5 = xmmword_1B309E160;
  switch(*((_DWORD *)this + 265))
  {
    case 0:
      __asm { FMOV            V0.4S, #1.0; jumptable 00000001B2A35C70 case 0 }
      v5 = 0uLL;
      goto LABEL_8;
    case 1:
    case 5:
    case 8:
    case 0xA:
    case 0x10:
    case 0x17:
      goto LABEL_8;
    case 2:
      _Q0 = xmmword_1B309E1B0;
      v5 = xmmword_1B309E1C0;
      goto LABEL_8;
    case 3:
    case 6:
    case 0xC:
    case 0xE:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x19:
    case 0x1A:
      _Q0 = xmmword_1B309E190;
      v5 = xmmword_1B309E1A0;
      goto LABEL_8;
    case 4:
    case 7:
      v5 = xmmword_1B309E180;
      goto LABEL_8;
    case 9:
    case 0xB:
      v5 = xmmword_1B309E180;
      __asm { FMOV            V0.4S, #1.0 }
      goto LABEL_8;
    case 0xD:
    case 0xF:
    case 0x18:
      v5 = xmmword_1B309E170;
      __asm { FMOV            V0.4S, #1.0 }
LABEL_8:
      v16 = v5;
      v18 = _Q0;
      HGNode::ClearBits(this, a2, a3);
      *((_BYTE *)this + 745) = 1;
      *((_OWORD *)this + 69) = v16;
      HGNode::ClearBits(this, v10, v11);
      *((_BYTE *)this + 745) = 1;
      *((_OWORD *)this + 67) = v18;
      break;
    default:
      break;
  }
  result = (__n128)xmmword_1B309E1D0;
  v13 = xmmword_1B309E1E0;
  switch(*((_DWORD *)this + 266))
  {
    case 0:
      __asm { FMOV            V0.4S, #1.0; jumptable 00000001B2A35D30 case 0 }
      v13 = 0uLL;
      goto LABEL_16;
    case 1:
    case 5:
    case 8:
    case 0xA:
    case 0x10:
    case 0x17:
      goto LABEL_16;
    case 2:
      result = (__n128)xmmword_1B309E230;
      v13 = xmmword_1B309E240;
      goto LABEL_16;
    case 3:
    case 6:
    case 0xC:
    case 0xE:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x19:
    case 0x1A:
      result = (__n128)xmmword_1B309E210;
      v13 = xmmword_1B309E220;
      goto LABEL_16;
    case 4:
    case 7:
      v13 = xmmword_1B309E200;
      goto LABEL_16;
    case 9:
    case 0xB:
      v13 = xmmword_1B309E200;
      __asm { FMOV            V0.4S, #1.0 }
      goto LABEL_16;
    case 0xD:
    case 0xF:
    case 0x18:
      v13 = xmmword_1B309E1F0;
      __asm { FMOV            V0.4S, #1.0 }
LABEL_16:
      v17 = v13;
      v19 = result;
      HGNode::ClearBits(this, a2, a3);
      *((_BYTE *)this + 745) = 1;
      *((_OWORD *)this + 70) = v17;
      HGNode::ClearBits(this, v14, v15);
      *((_BYTE *)this + 745) = 1;
      result = v19;
      *((__n128 *)this + 68) = v19;
      break;
    default:
      return result;
  }
  return result;
}

double HGColorGamma::SetOutputPixelFormat(uint64_t a1, uint64_t a2, char *a3)
{
  int v3;
  int v4;
  uint64_t v6;
  char *v7;
  double result;

  v3 = (int)a3;
  v4 = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(_BYTE *)(a1 + 745) = 1;
  *(_DWORD *)(a1 + 1056) = v4;
  *(_DWORD *)(a1 + 1064) = v3;
  *(_QWORD *)&result = HGColorGamma::SetYCbCrBiasAndScale((HGNode *)a1, v6, v7).n128_u64[0];
  return result;
}

_BYTE *HGColorGamma::SetPremultiplyState(_BYTE *this, char a2, char a3)
{
  this[745] = 1;
  this[1172] = a2;
  this[1173] = a3;
  return this;
}

HGNode *HGColorGamma::Set1DLutScaleAndOffset(HGNode *this, float a2, float a3, uint64_t a4, char *a5)
{
  HGNode *result;

  result = HGNode::ClearBits(this, a4, a5);
  *((_BYTE *)this + 745) = 1;
  *((float *)this + 289) = a2;
  *((float *)this + 290) = a3;
  return result;
}

HGNode *HGColorGamma::SetARRILogCExposureIndex(HGNode *this, uint64_t a2, char *a3)
{
  int v3;
  HGNode *result;

  v3 = a2;
  result = HGNode::ClearBits(this, a2, a3);
  *((_BYTE *)this + 745) = 1;
  *((_DWORD *)this + 291) = v3;
  return result;
}

__n128 HGColorGamma::LoadMatrix1(uint64_t a1, uint64_t a2, char *a3)
{
  __n128 result;

  HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(_BYTE *)(a1 + 745) = 1;
  *(_OWORD *)(a1 + 896) = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 912) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 928) = *(_OWORD *)(a2 + 32);
  result = *(__n128 *)(a2 + 48);
  *(__n128 *)(a1 + 944) = result;
  return result;
}

__n128 HGColorGamma::LoadMatrix2(uint64_t a1, uint64_t a2, char *a3)
{
  __n128 result;

  HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(_BYTE *)(a1 + 745) = 1;
  *(_OWORD *)(a1 + 960) = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 976) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 992) = *(_OWORD *)(a2 + 32);
  result = *(__n128 *)(a2 + 48);
  *(__n128 *)(a1 + 1008) = result;
  return result;
}

HGNode *HGColorGamma::SetGammaFunction(uint64_t a1, uint64_t a2, char *a3, __n128 a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, int8x16_t a8, float32x4_t a9, float32x4_t a10)
{
  int v10;
  HGNode *result;
  float v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  float v23;
  int8x16_t v24;
  int8x16_t v25;
  float v26;
  float32x4_t v28;
  int8x16_t v29;
  int32x2_t v35;
  int32x2_t v36;
  int32x2_t v37;
  int32x2_t v38;
  BOOL v39;

  v10 = a2;
  result = HGNode::ClearBits((HGNode *)a1, a2, a3);
  v13 = a5.f32[0];
  v15 = (int8x16_t)a6;
  v14 = (int8x16_t)a7;
  *(_BYTE *)(a1 + 745) = 1;
  switch(v10)
  {
    case 1:
      v16 = (int8x16_t)vceqzq_f32(vmulq_f32(a6, (float32x4_t)xmmword_1B3051560));
      v17 = vandq_s8((int8x16_t)vceqq_f32(vmulq_f32(a5, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B3051560), (int8x16_t)vceqq_f32(vmulq_f32((float32x4_t)a4, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B3051560));
      goto LABEL_6;
    case 2:
      v18 = (int8x16_t)vceqq_f32(vmulq_f32((float32x4_t)a4, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B3051560);
      v19 = (int8x16_t)vceqq_f32(vmulq_f32(a5, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B3051560);
      v20 = (int8x16_t)vceqzq_f32(vmulq_f32(a6, (float32x4_t)xmmword_1B3051560));
      v21 = (int8x16_t)vceqzq_f32(vmulq_f32(a7, (float32x4_t)xmmword_1B3051560));
      goto LABEL_5;
    case 3:
      v18 = (int8x16_t)vceqq_f32(vmulq_f32((float32x4_t)a4, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B3051560);
      v19 = (int8x16_t)vceqq_f32(vmulq_f32(a5, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B3051560);
      v20 = (int8x16_t)vceqzq_f32(vmulq_f32(a6, (float32x4_t)xmmword_1B3051560));
      v21 = (int8x16_t)vceqq_f32(vmulq_f32(a7, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B3051560);
LABEL_5:
      v17 = vandq_s8(v19, v18);
      v16 = vandq_s8(v20, v21);
LABEL_6:
      v22 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(v17, v16))));
      *(int32x2_t *)v22.i8 = vpmin_s32(*(int32x2_t *)v22.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL));
      if (vpmin_s32(*(int32x2_t *)v22.i8, *(int32x2_t *)v22.i8).u32[0])
        goto LABEL_7;
      goto LABEL_10;
    case 4:
      v29 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8(vandq_s8((int8x16_t)vceqq_f32(vmulq_f32(a5, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B3051560), (int8x16_t)vceqq_f32(vmulq_f32((float32x4_t)a4, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B3051560)), vandq_s8((int8x16_t)vceqq_f32(vmulq_f32(a7, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B3051560), (int8x16_t)vceqzq_f32(vmulq_f32(vaddq_f32(a6, a9), (float32x4_t)xmmword_1B3051560)))), (int8x16_t)vceqzq_f32(vmulq_f32(a10, (float32x4_t)xmmword_1B3051560)))))), 0x1FuLL));
      *(int32x2_t *)v29.i8 = vpmin_s32(*(int32x2_t *)v29.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL));
      if (!vpmin_s32(*(int32x2_t *)v29.i8, *(int32x2_t *)v29.i8).u32[0])
        goto LABEL_10;
      goto LABEL_7;
    case 5:
LABEL_10:
      *(_QWORD *)(a1 + 1028) = 0;
      __asm { FMOV            V0.4S, #1.0 }
      v28.i64[0] = 0;
      v28.i32[2] = 0;
      *(_OWORD *)(a1 + 768) = _Q0;
      *(_OWORD *)(a1 + 784) = 0u;
      __asm { FMOV            V2.2S, #1.0 }
      v26 = 0.0;
      *(_OWORD *)(a1 + 800) = 0u;
      *(_OWORD *)(a1 + 816) = 0u;
      v23 = 0.0;
      v13 = 0.0;
      v24 = 0uLL;
      v25 = 0uLL;
      *(_OWORD *)(a1 + 832) = 0u;
      *(_OWORD *)(a1 + 848) = 0u;
      v14 = 0uLL;
      v15 = 0uLL;
      *(_OWORD *)(a1 + 864) = 0u;
      if (1.0 == *(float *)_D2.i32)
        goto LABEL_11;
      goto LABEL_24;
    default:
LABEL_7:
      *(_DWORD *)(a1 + 1028) = v10;
      *(_DWORD *)(a1 + 1032) = 0;
      *(__n128 *)(a1 + 768) = a4;
      *(float32x4_t *)(a1 + 784) = a5;
      *(float32x4_t *)(a1 + 800) = a6;
      *(float32x4_t *)(a1 + 816) = a7;
      v23 = a5.f32[1];
      v25 = a8;
      v24 = (int8x16_t)a9;
      *(int8x16_t *)(a1 + 832) = a8;
      *(float32x4_t *)(a1 + 848) = a9;
      v26 = a5.f32[2];
      _D2 = (int32x2_t)vextq_s8((int8x16_t)a4, (int8x16_t)a4, 4uLL).u64[0];
      v28 = a10;
      *(float32x4_t *)(a1 + 864) = a10;
      if (a4.n128_f32[0] != *(float *)_D2.i32)
        goto LABEL_24;
LABEL_11:
      if ((vceq_f32((float32x2_t)_D2, (float32x2_t)vdup_lane_s32(_D2, 1)).u8[0] & 1) != 0)
      {
        _ZF = v13 == v23 && v23 == v26;
        if (_ZF
          && (v35 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v15.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v15.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL))), (vand_s8((int8x8_t)v35, (int8x8_t)vdup_lane_s32(v35, 1)).u32[0] & 1) != 0)&& (v36 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v14.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v14.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL))), (vand_s8((int8x8_t)v36, (int8x8_t)vdup_lane_s32(v36, 1)).u32[0] & 1) != 0)&& (v37 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v25.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v25.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL))), (vand_s8((int8x8_t)v37, (int8x8_t)vdup_lane_s32(v37, 1)).u32[0] & 1) != 0)&& (v38 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v24.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v24.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL))), (vand_s8((int8x8_t)v38, (int8x8_t)vdup_lane_s32(v38, 1)).u32[0] & 1) != 0))
        {
          v39 = v28.f32[1] == v28.f32[2];
          if (v28.f32[0] != v28.f32[1])
            v39 = 0;
          *(_BYTE *)(a1 + 880) = v39;
        }
        else
        {
          *(_BYTE *)(a1 + 880) = 0;
        }
      }
      else
      {
LABEL_24:
        *(_BYTE *)(a1 + 880) = 0;
      }
      return result;
  }
}

HGNode *HGColorGamma::SetDitherMode(HGNode *this, uint64_t a2, char *a3)
{
  char v3;
  HGNode *result;

  v3 = a2;
  result = HGNode::ClearBits(this, a2, a3);
  *((_BYTE *)this + 745) = 1;
  *((_BYTE *)this + 1025) = v3;
  return result;
}

HGNode *HGColorGamma::SetFixedPointPrecisionMode(HGNode *this, uint64_t a2, char *a3)
{
  char v3;
  HGNode *result;

  v3 = a2;
  result = HGNode::ClearBits(this, a2, a3);
  *((_BYTE *)this + 745) = 1;
  *((_BYTE *)this + 1026) = v3;
  return result;
}

uint64_t HGColorGamma::SetAntiSymmetricToneCurves(uint64_t this, char a2)
{
  *(_BYTE *)(this + 1175) = a2;
  return this;
}

double HGColorGamma::SetConversion(uint64_t a1, uint64_t a2, char *a3, unsigned int a4, int a5)
{
  int v7;
  unsigned int v8;
  _OWORD *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;
  HGNode *v15;
  uint64_t v16;
  char *v17;
  int v23;
  double v24;
  uint64_t *v25;
  double v26;
  HGCanonLogToneCurveLUTInfo *v27;
  float v28;
  float v29;
  uint64_t v30;
  char *v31;
  unint64_t v32;
  char *v33;
  char *v34;
  _OWORD *v35;
  uint64_t v36;
  char *v37;
  double result;

  v7 = (int)a3;
  v8 = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(_BYTE *)(a1 + 745) = 1;
  v10 = (_OWORD *)((char *)&HGColorGamma::YCbCrToRGB + 64 * (unint64_t)v8);
  HGNode::ClearBits((HGNode *)a1, v11, v12);
  *(_BYTE *)(a1 + 745) = 1;
  *(_OWORD *)(a1 + 896) = *v10;
  *(_OWORD *)(a1 + 912) = v10[1];
  *(_OWORD *)(a1 + 928) = v10[2];
  *(_OWORD *)(a1 + 944) = xmmword_1B304EFF0;
  v15 = HGNode::ClearBits((HGNode *)a1, v13, v14);
  *(_BYTE *)(a1 + 745) = 1;
  *(_DWORD *)(a1 + 1028) = 5;
  *(_DWORD *)(a1 + 1032) = v7;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(a1 + 768) = _Q0;
  *(_OWORD *)(a1 + 784) = 0u;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_OWORD *)(a1 + 848) = 0u;
  *(_OWORD *)(a1 + 864) = 0u;
  *(_BYTE *)(a1 + 880) = 1;
  switch(v7)
  {
    case 0:
    case 1:
      v23 = 0;
      v24 = 0.0;
      v25 = &HGArriLogCDefaultToneCurveLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 2:
      v23 = 0;
      v24 = 0.0;
      v25 = &HGArriLogCLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 3:
      v24 = 0.0;
      v26 = 1.0;
      v23 = 2048;
      break;
    case 4:
      v24 = HGCanonLogToneCurveLUTInfo::kMinLogGamma((HGCanonLogToneCurveLUTInfo *)v15);
      v26 = HGCanonLogToneCurveLUTInfo::kMaxLogGamma(v27);
      v23 = 0;
      break;
    case 5:
      v23 = 0;
      v24 = -0.0730593607;
      v25 = &HGCanonLogLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 6:
      v23 = 0;
      v24 = -0.0730593607;
      v25 = &HGCanonLog2LinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 7:
      v23 = 0;
      v24 = -0.0730593607;
      v25 = &HGCanonLog3LinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 8:
      v23 = 0;
      v24 = -0.0730593607;
      v25 = &HGSonySLog2LinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 9:
      v23 = 0;
      v24 = 0.0;
      v25 = &HGSonySLog3LinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 10:
      v23 = 0;
      v24 = 0.0;
      v25 = &HGPanasonicVLogLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 11:
      v23 = 0;
      v24 = 0.0;
      v25 = &HGNikonNLogLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 12:
    case 13:
      v23 = 0;
      v24 = 0.0;
      v25 = &HGBMDFilmLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 14:
      v23 = 0;
      v24 = 0.0;
      v25 = &HGAppleLogLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 15:
      v23 = 0;
      v24 = 0.0;
      v25 = &HGDJIDLogLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 16:
      v23 = 0;
      v24 = 0.0;
      v25 = &HGFujifilmFLogLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 17:
      v23 = 0;
      v24 = 0.0;
      v25 = &HGFujifilmFLog2LinearizationLUTInfo::kMaxLogGamma;
LABEL_19:
      v26 = *(double *)v25;
      break;
    default:
      v23 = 0;
      v24 = 0.0;
      v26 = 0.0;
      break;
  }
  v28 = v26 - v24;
  HGNode::ClearBits((HGNode *)a1, v16, v17);
  *(_BYTE *)(a1 + 745) = 1;
  *(float *)(a1 + 1156) = v28;
  v29 = v24;
  *(float *)(a1 + 1160) = v29;
  if (v23)
  {
    HGNode::ClearBits((HGNode *)a1, v30, v31);
    *(_BYTE *)(a1 + 745) = 1;
    *(_DWORD *)(a1 + 1152) = v23;
  }
  v32 = (unint64_t)a4 << 6;
  v33 = (char *)&HGColorGamma::logGamutRGBToRec2020RGB + v32;
  v34 = (char *)&HGColorGamma::logGamutRGBToRec709RGB + v32;
  if (a5 == 3)
    v35 = v33;
  else
    v35 = v34;
  HGNode::ClearBits((HGNode *)a1, v30, v31);
  *(_BYTE *)(a1 + 745) = 1;
  *(_OWORD *)(a1 + 960) = *v35;
  *(_OWORD *)(a1 + 976) = v35[1];
  *(_OWORD *)(a1 + 992) = v35[2];
  *(_OWORD *)(a1 + 1008) = v35[3];
  *(_QWORD *)&result = HGColorGamma::SetYCbCrBiasAndScale((HGNode *)a1, v36, v37).n128_u64[0];
  return result;
}

uint64_t HGColorGamma::SetConversion(uint64_t a1, uint64_t a2, char *a3, unsigned int a4, unsigned int a5, int a6, unsigned int a7)
{
  int v11;
  unsigned int v12;
  uint64_t v14;
  char *v15;
  _OWORD *v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  uint64_t v21;
  char *v22;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  char *v31;
  __int128 v32;
  float *v33;
  float32x2_t *v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  float64x2_t v50;
  float64x2_t v51;
  float64x2_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  char *v57;
  double *v58;
  char *v59;
  double v60;
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double v68;
  double v69;
  double v70;
  double v71;
  double v72;
  double v73;
  float64x2_t v74;
  float64x2_t v75;
  __int128 v76;
  __int128 v77;
  uint64_t v78;
  char *v79;
  uint64_t *v81;
  uint64_t v82;
  _OWORD *v83;
  uint64_t *v84;
  uint64_t v85;
  double *v86;
  char *v87;
  double v88;
  double v89;
  double v90;
  double v91;
  double v92;
  double v93;
  double v94;
  double v95;
  double v96;
  double v97;
  double v98;
  double v99;
  double v100;
  double v101;
  float64x2_t v102;
  float64x2_t v103;
  __int128 v104;
  __int128 v105;
  _OWORD *v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;

  v11 = (int)a3;
  v12 = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(_BYTE *)(a1 + 745) = 1;
  if (a6 == 8)
  {
    if (!a7 && (v11 != 8 || !a4))
    {
      v16 = (_OWORD *)((char *)&HGColorGamma::YCbCrToRGB + 64 * (unint64_t)a4);
      HGNode::ClearBits((HGNode *)a1, v14, v15);
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = *v16;
      *(_OWORD *)(a1 + 912) = v16[1];
      *(_OWORD *)(a1 + 928) = v16[2];
      *(_OWORD *)(a1 + 944) = xmmword_1B304EFF0;
      switch(v11)
      {
        case 1:
          HGNode::ClearBits((HGNode *)a1, v17, v18);
          *(_BYTE *)(a1 + 745) = 1;
          *(_QWORD *)(a1 + 1028) = 0;
          _Q0 = xmmword_1B309E280;
          goto LABEL_38;
        case 8:
          HGNode::ClearBits((HGNode *)a1, v17, v18);
          *(_BYTE *)(a1 + 745) = 1;
          *(_QWORD *)(a1 + 1028) = 0;
          goto LABEL_37;
        case 13:
          HGColorGamma::SetGammaFunctionSRGBLinearize((HGNode *)a1, v17, v18);
          break;
        case 16:
          HGNode::ClearBits((HGNode *)a1, v17, v18);
          *(_BYTE *)(a1 + 745) = 1;
          v84 = (uint64_t *)(a1 + 1028);
          v85 = 13;
          goto LABEL_36;
        case 17:
          HGNode::ClearBits((HGNode *)a1, v17, v18);
          *(_BYTE *)(a1 + 745) = 1;
          *(_QWORD *)(a1 + 1028) = 0;
          _Q0 = xmmword_1B309E270;
          goto LABEL_38;
        case 18:
          HGNode::ClearBits((HGNode *)a1, v17, v18);
          *(_BYTE *)(a1 + 745) = 1;
          v84 = (uint64_t *)(a1 + 1028);
          v85 = 11;
LABEL_36:
          *v84 = v85;
LABEL_37:
          __asm { FMOV            V0.4S, #1.0 }
LABEL_38:
          *(_OWORD *)(a1 + 768) = _Q0;
          *(_OWORD *)(a1 + 784) = 0u;
          *(_OWORD *)(a1 + 800) = 0u;
          *(_OWORD *)(a1 + 816) = 0u;
          *(_OWORD *)(a1 + 832) = 0u;
          *(_OWORD *)(a1 + 848) = 0u;
          *(_OWORD *)(a1 + 864) = 0u;
          *(_BYTE *)(a1 + 880) = 1;
          break;
        default:
          break;
      }
      if (v12 == a5)
      {
        HGNode::ClearBits((HGNode *)a1, v17, v18);
        *(_BYTE *)(a1 + 745) = 1;
LABEL_43:
        *(_OWORD *)(a1 + 960) = xmmword_1B304F230;
        *(_OWORD *)(a1 + 976) = xmmword_1B304F240;
        v32 = xmmword_1B304F250;
        goto LABEL_44;
      }
      v86 = (double *)((char *)&HGColorGamma::XYZToRGB + 72 * a5);
      v87 = (char *)&HGColorGamma::RGBToXYZ + 72 * v12;
      v88 = v86[1];
      v89 = *((double *)v87 + 2);
      v90 = *((double *)v87 + 5);
      v91 = *((double *)v87 + 8);
      v92 = v86[2];
      v93 = v86[3];
      v94 = *v86 * v89 + v88 * v90 + v92 * v91;
      v95 = v86[4];
      v96 = v86[5];
      v97 = v89 * v93 + v90 * v95 + v91 * v96;
      v98 = v86[6];
      v99 = v86[7];
      v100 = v86[8];
      v101 = v89 * v98 + v90 * v99 + v91 * v100;
      *(float *)&v94 = v94;
      *(float *)&v90 = v97;
      v102 = *(float64x2_t *)(v87 + 24);
      v103 = *((float64x2_t *)v87 + 3);
      *(float32x2_t *)&v104 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(*(float64x2_t *)v87, *v86), vmulq_n_f64(v102, v88)), vmulq_n_f64(v103, v92)));
      *((_QWORD *)&v104 + 1) = LODWORD(v94);
      v112 = v104;
      *(float32x2_t *)&v104 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(*(float64x2_t *)v87, v93), vmulq_n_f64(v102, v95)), vmulq_n_f64(v103, v96)));
      *((_QWORD *)&v104 + 1) = LODWORD(v90);
      v109 = v104;
      *(float32x2_t *)&v105 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(*(float64x2_t *)v87, v98), vmulq_n_f64(v102, v99)), vmulq_n_f64(v103, v100)));
      *(float *)&v104 = v101;
      *((_QWORD *)&v105 + 1) = v104;
      v115 = v105;
      HGNode::ClearBits((HGNode *)a1, v17, v18);
      v32 = v115;
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 960) = v112;
      *(_OWORD *)(a1 + 976) = v109;
LABEL_44:
      *(_OWORD *)(a1 + 992) = v32;
      *(_OWORD *)(a1 + 1008) = xmmword_1B304EFF0;
      HGColorGamma::SetYCbCrBiasAndScale((HGNode *)a1, v30, v31);
      return 1;
    }
    return 0;
  }
  if (v11 == 8)
  {
    if (a4)
      return 0;
    if (v12 == a5)
    {
      v107 = xmmword_1B304F250;
      v110 = xmmword_1B304F240;
      v113 = xmmword_1B304F230;
    }
    else
    {
      v58 = (double *)((char *)&HGColorGamma::XYZToRGB + 72 * a5);
      v59 = (char *)&HGColorGamma::RGBToXYZ + 72 * v12;
      v60 = v58[1];
      v61 = *((double *)v59 + 2);
      v62 = *((double *)v59 + 5);
      v63 = *((double *)v59 + 8);
      v64 = v58[2];
      v65 = v58[3];
      v66 = *v58 * v61 + v60 * v62 + v64 * v63;
      v67 = v58[4];
      v68 = v58[5];
      v69 = v61 * v65 + v62 * v67 + v63 * v68;
      v70 = v58[6];
      v71 = v58[7];
      v72 = v58[8];
      v73 = v61 * v70 + v62 * v71;
      *(float *)&v66 = v66;
      *(float *)&v62 = v69;
      v74 = *(float64x2_t *)(v59 + 24);
      v75 = *((float64x2_t *)v59 + 3);
      *(float32x2_t *)&v76 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(*(float64x2_t *)v59, *v58), vmulq_n_f64(v74, v60)), vmulq_n_f64(v75, v64)));
      *((_QWORD *)&v76 + 1) = LODWORD(v66);
      v113 = v76;
      *(float32x2_t *)&v76 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(*(float64x2_t *)v59, v65), vmulq_n_f64(v74, v67)), vmulq_n_f64(v75, v68)));
      *((_QWORD *)&v76 + 1) = LODWORD(v62);
      v110 = v76;
      *(float32x2_t *)&v77 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(*(float64x2_t *)v59, v70), vmulq_n_f64(v74, v71)), vmulq_n_f64(v75, v72)));
      *(float *)&v76 = v73 + v63 * v72;
      *((_QWORD *)&v77 + 1) = v76;
      v107 = v77;
    }
    HGNode::ClearBits((HGNode *)a1, v14, v15);
    *(_BYTE *)(a1 + 745) = 1;
    *(_OWORD *)(a1 + 896) = v113;
    *(_OWORD *)(a1 + 912) = v110;
    *(_OWORD *)(a1 + 928) = v107;
    *(_OWORD *)(a1 + 944) = xmmword_1B304EFF0;
    switch(a6)
    {
      case 1:
        HGNode::ClearBits((HGNode *)a1, v78, v79);
        *(_BYTE *)(a1 + 745) = 1;
        *(_QWORD *)(a1 + 1028) = 0;
        _Q0 = xmmword_1B309E260;
        goto LABEL_29;
      case 13:
        HGColorGamma::SetGammaFunctionSRGBGamma((HGNode *)a1, v78, v79);
        break;
      case 16:
        HGNode::ClearBits((HGNode *)a1, v78, v79);
        *(_BYTE *)(a1 + 745) = 1;
        v81 = (uint64_t *)(a1 + 1028);
        v82 = 12;
        goto LABEL_28;
      case 17:
        HGNode::ClearBits((HGNode *)a1, v78, v79);
        *(_BYTE *)(a1 + 745) = 1;
        *(_QWORD *)(a1 + 1028) = 0;
        _Q0 = xmmword_1B309E250;
        goto LABEL_29;
      case 18:
        HGNode::ClearBits((HGNode *)a1, v78, v79);
        *(_BYTE *)(a1 + 745) = 1;
        v81 = (uint64_t *)(a1 + 1028);
        v82 = 10;
LABEL_28:
        *v81 = v82;
        __asm { FMOV            V0.4S, #1.0 }
LABEL_29:
        *(_OWORD *)(a1 + 768) = _Q0;
        *(_OWORD *)(a1 + 784) = 0u;
        *(_OWORD *)(a1 + 800) = 0u;
        *(_OWORD *)(a1 + 816) = 0u;
        *(_OWORD *)(a1 + 832) = 0u;
        *(_OWORD *)(a1 + 848) = 0u;
        *(_OWORD *)(a1 + 864) = 0u;
        *(_BYTE *)(a1 + 880) = 1;
        break;
      default:
        break;
    }
LABEL_30:
    v83 = (_OWORD *)((char *)&HGColorGamma::RGBToYCbCr + 64 * (unint64_t)a7);
    HGNode::ClearBits((HGNode *)a1, v78, v79);
    *(_BYTE *)(a1 + 745) = 1;
    *(_OWORD *)(a1 + 960) = *v83;
    *(_OWORD *)(a1 + 976) = v83[1];
    v32 = v83[2];
    goto LABEL_44;
  }
  result = 0;
  if (v12 == a5 && v11 == a6)
  {
    HGNode::ClearBits((HGNode *)a1, v14, v15);
    *(_BYTE *)(a1 + 745) = 1;
    *(_QWORD *)(a1 + 1028) = 0;
    __asm { FMOV            V0.4S, #1.0 }
    *(_OWORD *)(a1 + 768) = _Q0;
    *(_OWORD *)(a1 + 784) = 0u;
    *(_OWORD *)(a1 + 800) = 0u;
    *(_OWORD *)(a1 + 816) = 0u;
    *(_OWORD *)(a1 + 832) = 0u;
    *(_OWORD *)(a1 + 848) = 0u;
    *(_OWORD *)(a1 + 864) = 0u;
    *(_BYTE *)(a1 + 880) = 1;
    if (a4 == a7)
    {
      HGNode::ClearBits((HGNode *)a1, v21, v22);
      *(_BYTE *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B304F230;
      *(_OWORD *)(a1 + 912) = xmmword_1B304F240;
      *(_OWORD *)(a1 + 928) = xmmword_1B304F250;
      *(_OWORD *)(a1 + 944) = xmmword_1B304EFF0;
      HGNode::ClearBits((HGNode *)a1, v28, v29);
      *(_BYTE *)(a1 + 745) = 1;
      v32 = xmmword_1B304F250;
      *(_OWORD *)(a1 + 960) = xmmword_1B304F230;
      *(_OWORD *)(a1 + 976) = xmmword_1B304F240;
      goto LABEL_44;
    }
    if (a4)
    {
      if (a7)
      {
        v33 = (float *)((char *)&HGColorGamma::RGBToYCbCr + 64 * (unint64_t)a7);
        v34 = (float32x2_t *)((char *)&HGColorGamma::YCbCrToRGB + 64 * (unint64_t)a4);
        v35 = *v33;
        v36 = v33[1];
        v37 = v33[2];
        v38 = COERCE_FLOAT(*((_OWORD *)v33 + 1));
        v39 = COERCE_FLOAT(HIDWORD(*((_QWORD *)v33 + 2)));
        v40 = COERCE_FLOAT(*((_QWORD *)v33 + 3));
        v41 = COERCE_FLOAT(*((_OWORD *)v33 + 2));
        v42 = COERCE_FLOAT(HIDWORD(*((_QWORD *)v33 + 4)));
        v43 = COERCE_FLOAT(*((_QWORD *)v33 + 5));
        v44 = COERCE_FLOAT(*(_QWORD *)&v34[1]);
        v45 = COERCE_FLOAT(*(_QWORD *)&v34[3]);
        v46 = COERCE_FLOAT(*(_QWORD *)&v34[5]);
        v47 = v35 * v44 + v36 * v45 + v37 * v46;
        v48 = v38 * v44 + v39 * v45 + v40 * v46;
        v49 = v41 * v44 + v42 * v45 + v43 * v46;
        *(float *)&v45 = v47;
        *(float *)&v46 = v48;
        v50 = vcvtq_f64_f32(*v34);
        v51 = vcvtq_f64_f32(v34[2]);
        v52 = vcvtq_f64_f32(v34[4]);
        *(float32x2_t *)&v53 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v50, v35), vmulq_n_f64(v51, v36)), vmulq_n_f64(v52, v37)));
        *((_QWORD *)&v53 + 1) = LODWORD(v45);
        *(float32x2_t *)&v54 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v50, v38), vmulq_n_f64(v51, v39)), vmulq_n_f64(v52, v40)));
        *((_QWORD *)&v54 + 1) = LODWORD(v46);
        v111 = v54;
        v114 = v53;
        *(float32x2_t *)&v55 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v50, v41), vmulq_n_f64(v51, v42)), vmulq_n_f64(v52, v43)));
        *(float *)&v54 = v49;
        *((_QWORD *)&v55 + 1) = v54;
        v108 = v55;
        HGNode::ClearBits((HGNode *)a1, v21, v22);
        *(_BYTE *)(a1 + 745) = 1;
        *(_OWORD *)(a1 + 896) = v114;
        *(_OWORD *)(a1 + 912) = v111;
        *(_OWORD *)(a1 + 928) = v108;
      }
      else
      {
        v106 = (_OWORD *)((char *)&HGColorGamma::YCbCrToRGB + 64 * (unint64_t)a4);
        HGNode::ClearBits((HGNode *)a1, v21, v22);
        *(_BYTE *)(a1 + 745) = 1;
        *(_OWORD *)(a1 + 896) = *v106;
        *(_OWORD *)(a1 + 912) = v106[1];
        *(_OWORD *)(a1 + 928) = v106[2];
      }
      *(_OWORD *)(a1 + 944) = xmmword_1B304EFF0;
      HGNode::ClearBits((HGNode *)a1, v56, v57);
      *(_BYTE *)(a1 + 745) = 1;
      goto LABEL_43;
    }
    HGNode::ClearBits((HGNode *)a1, v21, v22);
    *(_BYTE *)(a1 + 745) = 1;
    *(_OWORD *)(a1 + 896) = xmmword_1B304F230;
    *(_OWORD *)(a1 + 912) = xmmword_1B304F240;
    *(_OWORD *)(a1 + 928) = xmmword_1B304F250;
    *(_OWORD *)(a1 + 944) = xmmword_1B304EFF0;
    goto LABEL_30;
  }
  return result;
}

HGNode *HGColorGamma::SetGammaFunctionSRGBLinearize(HGNode *this, uint64_t a2, char *a3)
{
  HGNode *result;
  int32x2_t v5;
  unsigned __int32 v6;
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  unsigned __int8 v15;
  int32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;

  result = HGNode::ClearBits(this, a2, a3);
  *((_BYTE *)this + 745) = 1;
  v5 = vpmin_s32((int32x2_t)-1, (int32x2_t)0xFFFFFFFFLL);
  v6 = vpmin_s32(v5, v5).u32[0];
  if (v6)
  {
    v7 = (int8x16_t)xmmword_1B309E2A0;
    *((_OWORD *)this + 49) = xmmword_1B309E290;
    *((_OWORD *)this + 50) = xmmword_1B309E2A0;
    v8 = (int8x16_t)xmmword_1B309E2B0;
    v9 = (int8x16_t)xmmword_1B309E2C0;
    *((_OWORD *)this + 51) = xmmword_1B309E2B0;
    *((_OWORD *)this + 52) = xmmword_1B309E2C0;
    *((_OWORD *)this + 53) = 0u;
    *((_OWORD *)this + 54) = 0u;
    _Q3 = xmmword_1B309E2D0;
    v6 = 3;
  }
  else
  {
    v9 = 0uLL;
    *((_OWORD *)this + 53) = 0u;
    *((_OWORD *)this + 54) = 0u;
    *((_OWORD *)this + 51) = 0u;
    *((_OWORD *)this + 52) = 0u;
    *((_OWORD *)this + 49) = 0u;
    *((_OWORD *)this + 50) = 0u;
    __asm { FMOV            V3.4S, #1.0 }
    v8 = 0uLL;
    v7 = 0uLL;
  }
  v15 = 0;
  *((_DWORD *)this + 257) = v6;
  *((_DWORD *)this + 258) = 0;
  *((_OWORD *)this + 48) = _Q3;
  v16 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL)));
  if ((vand_s8((int8x8_t)v16, (int8x8_t)vdup_lane_s32(v16, 1)).u8[0] & 1) == 0)
    goto LABEL_7;
  v17 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v8.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v8.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL)));
  if ((vand_s8((int8x8_t)v17, (int8x8_t)vdup_lane_s32(v17, 1)).u8[0] & 1) != 0)
  {
    v18 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v9.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v9.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL)));
    v15 = vand_s8((int8x8_t)v18, (int8x8_t)vdup_lane_s32(v18, 1)).u8[0];
LABEL_7:
    *((_BYTE *)this + 880) = v15 & 1;
    return result;
  }
  *((_BYTE *)this + 880) = 0;
  return result;
}

HGNode *HGColorGamma::SetGammaFunctionSRGBGamma(HGNode *this, uint64_t a2, char *a3)
{
  HGNode *result;
  int32x2_t v5;
  unsigned __int32 v6;
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  unsigned __int8 v15;
  int32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;

  result = HGNode::ClearBits(this, a2, a3);
  *((_BYTE *)this + 745) = 1;
  v5 = vpmin_s32((int32x2_t)-1, (int32x2_t)0xFFFFFFFFLL);
  v6 = vpmin_s32(v5, v5).u32[0];
  if (v6)
  {
    *((_OWORD *)this + 49) = xmmword_1B309E2E0;
    *((_OWORD *)this + 50) = 0u;
    v7 = (int8x16_t)xmmword_1B309E2F0;
    v8 = (int8x16_t)xmmword_1B309E300;
    *((_OWORD *)this + 51) = xmmword_1B309E2F0;
    *((_OWORD *)this + 52) = xmmword_1B309E300;
    v9 = (int8x16_t)xmmword_1B309E310;
    *((_OWORD *)this + 53) = xmmword_1B309E310;
    *((_OWORD *)this + 54) = 0u;
    _Q3 = xmmword_1B309E320;
    v6 = 4;
  }
  else
  {
    v9 = 0uLL;
    *((_OWORD *)this + 53) = 0u;
    *((_OWORD *)this + 54) = 0u;
    *((_OWORD *)this + 51) = 0u;
    *((_OWORD *)this + 52) = 0u;
    *((_OWORD *)this + 49) = 0u;
    *((_OWORD *)this + 50) = 0u;
    __asm { FMOV            V3.4S, #1.0 }
    v8 = 0uLL;
    v7 = 0uLL;
  }
  v15 = 0;
  *((_DWORD *)this + 257) = v6;
  *((_DWORD *)this + 258) = 0;
  *((_OWORD *)this + 48) = _Q3;
  v16 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL)));
  if ((vand_s8((int8x8_t)v16, (int8x8_t)vdup_lane_s32(v16, 1)).u8[0] & 1) == 0)
    goto LABEL_7;
  v17 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v8.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v8.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL)));
  if ((vand_s8((int8x8_t)v17, (int8x8_t)vdup_lane_s32(v17, 1)).u8[0] & 1) != 0)
  {
    v18 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v9.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v9.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL)));
    v15 = vand_s8((int8x8_t)v18, (int8x8_t)vdup_lane_s32(v18, 1)).u8[0];
LABEL_7:
    *((_BYTE *)this + 880) = v15 & 1;
    return result;
  }
  *((_BYTE *)this + 880) = 0;
  return result;
}

uint64_t HGColorGamma::TestConversion(int a1, int a2, int a3, int a4, int a5, int a6)
{
  uint64_t result;

  if (a5 == 8)
  {
    if (a6)
      return 0;
    return a2 != 8 || !a3;
  }
  if (a2 == 8)
    return !a3;
  result = 0;
  if (a1 == a4 && a2 == a5)
    return 1;
  return result;
}

void HGColorGammaLUTEntryFactory::~HGColorGammaLUTEntryFactory(HGColorGammaLUTEntryFactory *this)
{
  JUMPOUT(0x1B5E29170);
}

uint64_t HGColorGammaLUTEntryFactory::createLUTEntry(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  v5 = operator new();
  HGApplyNDLUTEntry::HGApplyNDLUTEntry(v5, a2, a3);
  return v5;
}

void sub_1B2A37114(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0xA1C40987D6AD5);
  _Unwind_Resume(a1);
}

void HGCColorGamma_2vuy_yxzx_expand::~HGCColorGamma_2vuy_yxzx_expand(HGNode *this)
{
  void *v1;

  HgcColorGamma_2vuy_yxzx_expand::~HgcColorGamma_2vuy_yxzx_expand(this);
  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_2vuy_yxzx_expand::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_2vuy_yxzx_expand::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4 & 0xFFFFFFFFFFFFFFFELL;
}

void HGCColorGamma_2vuy_xyxz_expand::~HGCColorGamma_2vuy_xyxz_expand(HGNode *this)
{
  void *v1;

  HgcColorGamma_2vuy_xyxz_expand::~HgcColorGamma_2vuy_xyxz_expand(this);
  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_2vuy_xyxz_expand::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_2vuy_xyxz_expand::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4 & 0xFFFFFFFFFFFFFFFELL;
}

void HGCColorGamma_v210_yxzx_rgba_expand::~HGCColorGamma_v210_yxzx_rgba_expand(HGNode *this)
{
  void *v1;

  HgcColorGamma_v210_yxzx_rgba_expand::~HgcColorGamma_v210_yxzx_rgba_expand(this);
  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_v210_yxzx_rgba_expand::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_v210_yxzx_rgba_expand::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v5;
  float v6;
  unsigned int v7;

  if (a3)
    return 0;
  HIDWORD(v5) = -1431655765 * a4 + 715827882;
  LODWORD(v5) = HIDWORD(v5);
  if ((v5 >> 1) < 0x2AAAAAAB)
  {
    v7 = a4;
  }
  else
  {
    v6 = (double)(int)a4 / 6.0;
    v7 = (int)(float)(floorf(v6) * 6.0);
  }
  return a4 & 0xFFFFFFFF00000000 | v7;
}

void HGCColorGamma_v216_yxzx_expand::~HGCColorGamma_v216_yxzx_expand(HGNode *this)
{
  void *v1;

  HgcColorGamma_v216_yxzx_expand::~HgcColorGamma_v216_yxzx_expand(this);
  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_v216_yxzx_expand::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_v216_yxzx_expand::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4 & 0xFFFFFFFFFFFFFFFELL;
}

void HGCPixelFormatConversion_kV4B_WXYZ_output::~HGCPixelFormatConversion_kV4B_WXYZ_output(HGCPixelFormatConversion_kV4B_WXYZ_output *this)
{
  void *v1;

  HgcPixelFormatConversion_kV4B_WXYZ_output::~HgcPixelFormatConversion_kV4B_WXYZ_output(this);
  HGObject::operator delete(v1);
}

uint64_t HGCPixelFormatConversion_kV4B_WXYZ_output::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCPixelFormatConversion_kV4B_WXYZ_output::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void HGCPixelFormatConversion_kV4S_WXYZ_output::~HGCPixelFormatConversion_kV4S_WXYZ_output(HGCPixelFormatConversion_kV4S_WXYZ_output *this)
{
  void *v1;

  HgcPixelFormatConversion_kV4S_WXYZ_output::~HgcPixelFormatConversion_kV4S_WXYZ_output(this);
  HGObject::operator delete(v1);
}

uint64_t HGCPixelFormatConversion_kV4S_WXYZ_output::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCPixelFormatConversion_kV4S_WXYZ_output::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void HGCPixelFormatConversion_kV4F_WXYZ_output::~HGCPixelFormatConversion_kV4F_WXYZ_output(HGCPixelFormatConversion_kV4F_WXYZ_output *this)
{
  void *v1;

  HgcPixelFormatConversion_kV4F_WXYZ_output::~HgcPixelFormatConversion_kV4F_WXYZ_output(this);
  HGObject::operator delete(v1);
}

uint64_t HGCPixelFormatConversion_kV4F_WXYZ_output::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCPixelFormatConversion_kV4F_WXYZ_output::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void HGCPixelFormatConversion_kV4S_BE_WXYZ_output::~HGCPixelFormatConversion_kV4S_BE_WXYZ_output(HGNode *this)
{
  void *v1;

  HgcPixelFormatConversion_kV4S_BE_WXYZ_output::~HgcPixelFormatConversion_kV4S_BE_WXYZ_output(this);
  HGObject::operator delete(v1);
}

uint64_t HGCPixelFormatConversion_kV4S_BE_WXYZ_output::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCPixelFormatConversion_kV4S_BE_WXYZ_output::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void HGCPixelFormatConversion_kV4B10Bit_BE_output::~HGCPixelFormatConversion_kV4B10Bit_BE_output(HGNode *this)
{
  void *v1;

  HgcPixelFormatConversion_kV4B10Bit_BE_output::~HgcPixelFormatConversion_kV4B10Bit_BE_output(this);
  HGObject::operator delete(v1);
}

uint64_t HGCPixelFormatConversion_kV4B10Bit_BE_output::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCPixelFormatConversion_kV4B10Bit_BE_output::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void HGCColorGamma_bias::~HGCColorGamma_bias(HGNode *this)
{
  void *v1;

  HgcColorGamma_bias::~HgcColorGamma_bias(this);
  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_bias::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCColorGamma_bias::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void HGCColorGamma_chroma_downsample_f1::~HGCColorGamma_chroma_downsample_f1(HGNode *this)
{
  void *v1;

  HgcColorGamma_chroma_downsample_f1::~HgcColorGamma_chroma_downsample_f1(this);
  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_chroma_downsample_f1::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_chroma_downsample_f1::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return (a4 - 1) | a4 & 0xFFFFFFFF00000000;
}

void HGCColorGamma_chroma_upsample_f1::~HGCColorGamma_chroma_upsample_f1(HGNode *this)
{
  void *v1;

  HgcColorGamma_chroma_upsample_f1::~HgcColorGamma_chroma_upsample_f1(this);
  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_chroma_upsample_f1::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_chroma_upsample_f1::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return (a4 - 1) | a4 & 0xFFFFFFFF00000000;
}

void HGCColorGamma_2vuy_yxzx_collapse::~HGCColorGamma_2vuy_yxzx_collapse(HGNode *this)
{
  void *v1;

  HgcColorGamma_2vuy_yxzx_collapse::~HgcColorGamma_2vuy_yxzx_collapse(this);
  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_2vuy_yxzx_collapse::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_2vuy_yxzx_collapse::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4 & 0xFFFFFFFFFFFFFFFELL;
}

void HGCColorGamma_2vuy_xyxz_collapse::~HGCColorGamma_2vuy_xyxz_collapse(HGNode *this)
{
  void *v1;

  HgcColorGamma_2vuy_xyxz_collapse::~HgcColorGamma_2vuy_xyxz_collapse(this);
  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_2vuy_xyxz_collapse::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_2vuy_xyxz_collapse::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4 & 0xFFFFFFFFFFFFFFFELL;
}

void HGCColorGamma_v210_yxzx_rgba_collapse::~HGCColorGamma_v210_yxzx_rgba_collapse(HGNode *this)
{
  void *v1;

  HgcColorGamma_v210_yxzx_rgba_collapse::~HgcColorGamma_v210_yxzx_rgba_collapse(this);
  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_v210_yxzx_rgba_collapse::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_v210_yxzx_rgba_collapse::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v5;
  float v6;
  unsigned int v7;

  if (a3)
    return 0;
  HIDWORD(v5) = -1431655765 * a4 + 715827882;
  LODWORD(v5) = HIDWORD(v5);
  if ((v5 >> 1) < 0x2AAAAAAB)
  {
    v7 = a4;
  }
  else
  {
    v6 = (double)(int)a4 / 6.0;
    v7 = (int)(float)(floorf(v6) * 6.0);
  }
  return a4 & 0xFFFFFFFF00000000 | v7;
}

void HGCColorGamma_v216_yxzx_collapse::~HGCColorGamma_v216_yxzx_collapse(HGNode *this)
{
  void *v1;

  HgcColorGamma_v216_yxzx_collapse::~HgcColorGamma_v216_yxzx_collapse(this);
  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_v216_yxzx_collapse::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_v216_yxzx_collapse::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4 & 0xFFFFFFFFFFFFFFFELL;
}

void HGGamma::HGGamma(HGGamma *this)
{
  uint64_t v1;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v1 = off_1E6522BC8;
  *(_QWORD *)(v1 + 408) = 0;
  *(_BYTE *)(v1 + 420) = 1;
  if (*(float *)(v1 + 416) != 1.0)
    *(_DWORD *)(v1 + 416) = 1065353216;
}

void HGGamma::~HGGamma(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6522BC8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6522BC8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGGamma::SetPremultiplyState(uint64_t this, char a2)
{
  *(_BYTE *)(this + 420) = a2;
  return this;
}

uint64_t HGGamma::SetParameter(HGGamma *this, int a2, float a3, float a4, float a5, float a6)
{
  float v7;

  if (a2)
    return 0xFFFFFFFFLL;
  v7 = fabsf(a3);
  if (*((float *)this + 104) == v7)
    return 0;
  *((float *)this + 104) = v7;
  return 1;
}

HGNode *HGGamma::GetOutput(HGGamma *this, HGRenderer *a2)
{
  HGNode *Input;
  int v5;
  HGNode *v6;
  HGNode *v7;
  uint64_t (**v8)(HGNode *);
  HGNode *v9;
  uint64_t (**v10)(HGNode *);
  HGNode *v11;
  _BOOL4 IsMergeable;
  _BOOL4 v13;
  const struct __class_type_info *v14;
  HGNode *v15;
  HGNode *v16;
  float v17;
  float v18;
  HGNode *v19;
  float v20;
  HGNode *v21;
  HGNode *v22;
  _QWORD *v23;
  float v25[4];
  _OWORD v26[4];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  if (vabds_f32(1.0, *((float *)this + 104)) >= 0.001)
  {
    memset(v26, 0, sizeof(v26));
    v5 = *((unsigned __int8 *)this + 420);
    v6 = (HGNode *)HGObject::operator new(0x1D0uLL);
    v7 = v6;
    *(_OWORD *)v6 = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *((_OWORD *)v6 + 8) = 0u;
    *((_OWORD *)v6 + 9) = 0u;
    *((_OWORD *)v6 + 10) = 0u;
    *((_OWORD *)v6 + 11) = 0u;
    *((_OWORD *)v6 + 12) = 0u;
    *((_OWORD *)v6 + 13) = 0u;
    *((_OWORD *)v6 + 14) = 0u;
    *((_OWORD *)v6 + 15) = 0u;
    *((_OWORD *)v6 + 16) = 0u;
    *((_OWORD *)v6 + 17) = 0u;
    *((_OWORD *)v6 + 18) = 0u;
    *((_OWORD *)v6 + 19) = 0u;
    *((_OWORD *)v6 + 20) = 0u;
    *((_OWORD *)v6 + 21) = 0u;
    *((_OWORD *)v6 + 22) = 0u;
    *((_OWORD *)v6 + 23) = 0u;
    *((_OWORD *)v6 + 24) = 0u;
    *((_OWORD *)v6 + 25) = 0u;
    *((_OWORD *)v6 + 26) = 0u;
    *((_OWORD *)v6 + 27) = 0u;
    *((_OWORD *)v6 + 28) = 0u;
    if (v5)
    {
      HgcGamma::HgcGamma((HgcGamma *)v6);
      v8 = off_1E65230C8;
      *(_QWORD *)v7 = off_1E65230C8;
      *((_OWORD *)v7 + 26) = 0u;
      *((_OWORD *)v7 + 27) = 0u;
      *((_OWORD *)v7 + 28) = 0u;
      v9 = (HGNode *)*((_QWORD *)this + 51);
      if (v9 != v7)
      {
        if (v9)
        {
          (*(void (**)(HGNode *))(*(_QWORD *)v9 + 24))(v9);
          v8 = *(uint64_t (***)(HGNode *))v7;
        }
        *((_QWORD *)this + 51) = v7;
        v8[2](v7);
      }
      MEMORY[0x1B5E28D80]((char *)v7 + 416, "HgcGamma");
      MEMORY[0x1B5E28D80]((char *)v7 + 440, v26);
      (*(void (**)(HGNode *))(*(_QWORD *)v7 + 24))(v7);
    }
    else
    {
      HgcGammaNoPremult::HgcGammaNoPremult((HgcGammaNoPremult *)v6);
      v10 = off_1E6523318;
      *(_QWORD *)v7 = off_1E6523318;
      *((_OWORD *)v7 + 26) = 0u;
      *((_OWORD *)v7 + 27) = 0u;
      *((_OWORD *)v7 + 28) = 0u;
      v11 = (HGNode *)*((_QWORD *)this + 51);
      if (v11 != v7)
      {
        if (v11)
        {
          (*(void (**)(HGNode *))(*(_QWORD *)v11 + 24))(v11);
          v10 = *(uint64_t (***)(HGNode *))v7;
        }
        *((_QWORD *)this + 51) = v7;
        v10[2](v7);
      }
      MEMORY[0x1B5E28D80]((char *)v7 + 416, "HgcGammaNoPremult");
      MEMORY[0x1B5E28D80]((char *)v7 + 440, v26);
      (*(void (**)(HGNode *))(*(_QWORD *)v7 + 24))(v7);
    }
    IsMergeable = HGRenderer::IsMergeable(a2, (HGNode *)this, 0, 0);
    if (Input)
      v13 = IsMergeable;
    else
      v13 = 0;
    if (v13
      && (*((_BYTE *)this + 420)
    {
      v16 = v15;
      (*(void (**)(HGNode *, _QWORD, float *))(*(_QWORD *)v15 + 104))(v15, 0, v25);
      v17 = v25[0];
      v18 = *((float *)this + 104);
      v19 = (HGNode *)HGObject::operator new(0x1B0uLL);
      HGNode::HGNode(v19);
      *(_QWORD *)v19 = off_1E6522BC8;
      *((_QWORD *)v19 + 51) = 0;
      *((_BYTE *)v19 + 420) = 1;
      v20 = fabsf(v17 * v18);
      if (*((float *)v19 + 104) != 1.0 || v20 != 1.0)
        *((float *)v19 + 104) = v20;
      v21 = HGRenderer::GetInput(a2, v16, 0);
      (*(void (**)(HGNode *, _QWORD, HGNode *))(*(_QWORD *)v19 + 120))(v19, 0, v21);
      *((_BYTE *)v19 + 420) = *((_BYTE *)this + 420);
      v22 = (HGNode *)*((_QWORD *)this + 51);
      Input = v19;
      if (v22 != v19)
      {
        if (v22)
          (*(void (**)(HGNode *))(*(_QWORD *)v22 + 24))(v22);
        *((_QWORD *)this + 51) = v19;
        (*(void (**)(HGNode *))(*(_QWORD *)v19 + 16))(v19);
        Input = (HGNode *)*((_QWORD *)this + 51);
      }
      (*(void (**)(HGNode *))(*(_QWORD *)v19 + 24))(v19);
    }
    else
    {
      (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 0, *((float *)this + 104), *((float *)this + 104), *((float *)this + 104), 1.0);
      v23 = (_QWORD *)((char *)this + 408);
      (*(void (**)(_QWORD, _QWORD, HGNode *))(*(_QWORD *)*v23 + 120))(*v23, 0, Input);
      return (HGNode *)*v23;
    }
  }
  return Input;
}

void sub_1B2A37FD8(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void HGGammaMC::HGGammaMC(HGGammaMC *this)
{
  float32x4_t *v1;

  HGNode::HGNode((HGNode *)this);
  v1->i64[0] = (uint64_t)off_1E6522E48;
  v1[25].i64[1] = 0;
  __asm { FMOV            V0.4S, #1.0 }
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(v1[26], _Q0)))) & 1) != 0
    || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(v1[27], (float32x4_t)xmmword_1B304EFF0)))) & 1) != 0)
  {
    v1[26] = _Q0;
    v1[27] = (float32x4_t)xmmword_1B304EFF0;
  }
}

void HGGammaMC::~HGGammaMC(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6522E48;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6522E48;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGGammaMC::SetParameter(float32x4_t *this, int a2, float32x2_t a3, float32_t a4, float a5, float a6)
{
  float32x4_t v7;
  float v8;
  float32x4_t v14;
  float v15;
  float32x4_t v16;
  float32x4_t v17;

  if (a2)
    return 0xFFFFFFFFLL;
  a3.f32[1] = a4;
  *(float32x2_t *)v7.f32 = vabs_f32(a3);
  v8 = fabsf(a5);
  __asm { FMOV            V1.2S, #1.0 }
  *(float32x2_t *)v14.f32 = vsub_f32(_D1, *(float32x2_t *)v7.f32);
  v15 = 1.0 - v8;
  v16.i64[0] = v7.i64[0];
  v16.i64[1] = __PAIR64__(1.0, LODWORD(v8));
  if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(this[26], v16))), 0xFuLL))) & 1) == 0)
  {
    v17.i64[0] = v14.i64[0];
    v17.i64[1] = __PAIR64__(1.0, LODWORD(v15));
    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(this[27], v17))), 0xFuLL))) & 1) == 0)return 0;
  }
  v7.i64[1] = __PAIR64__(1.0, LODWORD(v8));
  v14.i64[1] = __PAIR64__(1.0, LODWORD(v15));
  this[26] = v7;
  this[27] = v14;
  return 1;
}

HGNode *HGGammaMC::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGNode *Input;
  HgcGamma *v6;
  HgcGamma *v7;
  HgcGamma *v8;
  _OWORD v10[4];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  Input = HGRenderer::GetInput(a2, this, 0);
  if (*((float *)this + 104) != 1.0 || *((float *)this + 105) != 1.0 || *((float *)this + 106) != 1.0)
  {
    v6 = (HgcGamma *)HGObject::operator new(0x1D0uLL);
    *(_OWORD *)v6 = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *((_OWORD *)v6 + 8) = 0u;
    *((_OWORD *)v6 + 9) = 0u;
    *((_OWORD *)v6 + 10) = 0u;
    *((_OWORD *)v6 + 11) = 0u;
    *((_OWORD *)v6 + 12) = 0u;
    *((_OWORD *)v6 + 13) = 0u;
    *((_OWORD *)v6 + 14) = 0u;
    *((_OWORD *)v6 + 15) = 0u;
    *((_OWORD *)v6 + 16) = 0u;
    *((_OWORD *)v6 + 17) = 0u;
    *((_OWORD *)v6 + 18) = 0u;
    *((_OWORD *)v6 + 19) = 0u;
    *((_OWORD *)v6 + 20) = 0u;
    *((_OWORD *)v6 + 21) = 0u;
    *((_OWORD *)v6 + 22) = 0u;
    *((_OWORD *)v6 + 23) = 0u;
    *((_OWORD *)v6 + 24) = 0u;
    *((_OWORD *)v6 + 25) = 0u;
    *((_OWORD *)v6 + 26) = 0u;
    *((_OWORD *)v6 + 27) = 0u;
    *((_OWORD *)v6 + 28) = 0u;
    HgcGamma::HgcGamma(v6);
    *(_QWORD *)v6 = off_1E65230C8;
    *((_OWORD *)v6 + 26) = 0u;
    *((_OWORD *)v6 + 27) = 0u;
    *((_OWORD *)v6 + 28) = 0u;
    memset(v10, 0, sizeof(v10));
    MEMORY[0x1B5E28D80]((char *)v6 + 416, "HgcGamma");
    MEMORY[0x1B5E28D80]((char *)v6 + 440, v10);
    v7 = (HgcGamma *)*((_QWORD *)this + 51);
    v8 = v6;
    if (v7 != v6)
    {
      if (v7)
        (*(void (**)(HgcGamma *))(*(_QWORD *)v7 + 24))(v7);
      *((_QWORD *)this + 51) = v6;
      (*(void (**)(HgcGamma *))(*(_QWORD *)v6 + 16))(v6);
      v8 = (HgcGamma *)*((_QWORD *)this + 51);
    }
    (*(void (**)(HgcGamma *, _QWORD, HGNode *))(*(_QWORD *)v8 + 120))(v8, 0, Input);
    (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 0, *((float *)this + 104), *((float *)this + 105), *((float *)this + 106), *((float *)this + 107));
    (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 1, *((float *)this + 108), *((float *)this + 109), *((float *)this + 110), *((float *)this + 111));
    Input = (HGNode *)*((_QWORD *)this + 51);
    (*(void (**)(HgcGamma *))(*(_QWORD *)v6 + 24))(v6);
  }
  return Input;
}

void sub_1B2A383FC(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void `anonymous namespace'::Gamma<HgcGamma>::~Gamma(HGNode *this)
{
  *(_QWORD *)this = off_1E65230C8;
  if (*((char *)this + 463) < 0)
  {
    operator delete(*((void **)this + 55));
    if ((*((char *)this + 439) & 0x80000000) == 0)
      goto LABEL_3;
LABEL_6:
    operator delete(*((void **)this + 52));
    HgcGamma::~HgcGamma(this);
    return;
  }
  if (*((char *)this + 439) < 0)
    goto LABEL_6;
LABEL_3:
  HgcGamma::~HgcGamma(this);
}

{
  void *v2;

  *(_QWORD *)this = off_1E65230C8;
  if (*((char *)this + 463) < 0)
  {
    operator delete(*((void **)this + 55));
    if ((*((char *)this + 439) & 0x80000000) == 0)
      goto LABEL_3;
LABEL_6:
    operator delete(*((void **)this + 52));
    HgcGamma::~HgcGamma(this);
    goto LABEL_4;
  }
  if (*((char *)this + 439) < 0)
    goto LABEL_6;
LABEL_3:
  HgcGamma::~HgcGamma(this);
LABEL_4:
  HGObject::operator delete(v2);
}

uint64_t `anonymous namespace'::Gamma<HgcGamma>::label_A(uint64_t a1)
{
  uint64_t result;

  result = a1 + 416;
  if (*(char *)(a1 + 439) < 0)
    return *(_QWORD *)result;
  return result;
}

void `anonymous namespace'::Gamma<HgcGammaNoPremult>::~Gamma(HGNode *this)
{
  *(_QWORD *)this = off_1E6523318;
  if (*((char *)this + 463) < 0)
  {
    operator delete(*((void **)this + 55));
    if ((*((char *)this + 439) & 0x80000000) == 0)
      goto LABEL_3;
LABEL_6:
    operator delete(*((void **)this + 52));
    HgcGammaNoPremult::~HgcGammaNoPremult(this);
    return;
  }
  if (*((char *)this + 439) < 0)
    goto LABEL_6;
LABEL_3:
  HgcGammaNoPremult::~HgcGammaNoPremult(this);
}

{
  void *v2;

  *(_QWORD *)this = off_1E6523318;
  if (*((char *)this + 463) < 0)
  {
    operator delete(*((void **)this + 55));
    if ((*((char *)this + 439) & 0x80000000) == 0)
      goto LABEL_3;
LABEL_6:
    operator delete(*((void **)this + 52));
    HgcGammaNoPremult::~HgcGammaNoPremult(this);
    goto LABEL_4;
  }
  if (*((char *)this + 439) < 0)
    goto LABEL_6;
LABEL_3:
  HgcGammaNoPremult::~HgcGammaNoPremult(this);
LABEL_4:
  HGObject::operator delete(v2);
}

uint64_t `anonymous namespace'::Gamma<HgcGammaNoPremult>::label_A(uint64_t a1)
{
  uint64_t result;

  result = a1 + 416;
  if (*(char *)(a1 + 439) < 0)
    return *(_QWORD *)result;
  return result;
}

uint64_t DepthBufferManager::init(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 8) = a2;
  return result;
}

void DepthBufferManager::~DepthBufferManager(DepthBufferManager *this)
{
  void *i;

  *(_QWORD *)this = off_1E6523568;
  for (i = (void *)*((_QWORD *)this + 2); i != *((void **)this + 3); i = (void *)*((_QWORD *)this + 2))
    (*(void (**)(DepthBufferManager *))(*(_QWORD *)this + 32))(this);
  *((_QWORD *)this + 1) = 0;
  if (i)
  {
    *((_QWORD *)this + 3) = i;
    operator delete(i);
  }
}

BOOL DepthBufferManager::hasDepthBuffer(DepthBufferManager *this)
{
  return *((_QWORD *)this + 2) != *((_QWORD *)this + 3);
}

uint64_t DepthBufferManager::getDepthBuffer(DepthBufferManager *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 3);
  if (*((_QWORD *)this + 2) == v1)
    return 0;
  else
    return *(_QWORD *)(v1 - 8);
}

_QWORD *DepthBufferManager::uninit(_QWORD *this)
{
  _QWORD *i;

  for (i = this; i[2] != i[3]; this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*i + 32))(i))
    ;
  i[1] = 0;
  return this;
}

void DepthBufferManager::push(DepthBufferManager *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;

  v6 = atomic_load(HGLogger::_enabled);
  if ((v6 & 1) != 0)
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"dbm : PUSH\n", a4, a5);
  v8 = (char *)*((_QWORD *)this + 3);
  v7 = *((_QWORD *)this + 4);
  if ((unint64_t)v8 < v7)
  {
    *(_QWORD *)v8 = 0;
    v9 = (uint64_t)(v8 + 8);
    goto LABEL_25;
  }
  v10 = (char *)*((_QWORD *)this + 2);
  v11 = (v8 - v10) >> 3;
  v12 = v11 + 1;
  if ((unint64_t)(v11 + 1) >> 61)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v13 = v7 - (_QWORD)v10;
  if (v13 >> 2 > v12)
    v12 = v13 >> 2;
  if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
    v14 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v14 = v12;
  if (v14)
  {
    if (v14 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v15 = (char *)operator new(8 * v14);
    v16 = &v15[8 * v11];
    v17 = &v15[8 * v14];
    *(_QWORD *)v16 = 0;
    v9 = (uint64_t)(v16 + 8);
    v18 = (char *)(v8 - v10);
    if (v8 == v10)
      goto LABEL_23;
    goto LABEL_16;
  }
  v15 = 0;
  v16 = (char *)(8 * v11);
  v17 = 0;
  *(_QWORD *)(8 * v11) = 0;
  v9 = 8 * v11 + 8;
  v18 = (char *)(v8 - v10);
  if (v8 != v10)
  {
LABEL_16:
    v19 = (unint64_t)(v18 - 8);
    if (v19 < 0x58)
      goto LABEL_30;
    if ((unint64_t)(v10 - v15) < 0x20)
      goto LABEL_30;
    v20 = (v19 >> 3) + 1;
    v21 = 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
    v22 = &v8[-v21];
    v16 -= v21;
    v23 = &v15[8 * v11 - 16];
    v24 = v8 - 16;
    v25 = v20 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v26 = *(_OWORD *)v24;
      *((_OWORD *)v23 - 1) = *((_OWORD *)v24 - 1);
      *(_OWORD *)v23 = v26;
      v23 -= 32;
      v24 -= 32;
      v25 -= 4;
    }
    while (v25);
    v8 = v22;
    if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_30:
      do
      {
        v27 = *((_QWORD *)v8 - 1);
        v8 -= 8;
        *((_QWORD *)v16 - 1) = v27;
        v16 -= 8;
      }
      while (v8 != v10);
    }
    v8 = (char *)*((_QWORD *)this + 2);
  }
LABEL_23:
  *((_QWORD *)this + 2) = v16;
  *((_QWORD *)this + 3) = v9;
  *((_QWORD *)this + 4) = v17;
  if (v8)
    operator delete(v8);
LABEL_25:
  *((_QWORD *)this + 3) = v9;
}

void DepthBufferManager::pop(DepthBufferManager *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = atomic_load(HGLogger::_enabled);
  if ((v6 & 1) != 0)
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"dbm : POP\n", a4, a5);
  v8 = *((_QWORD *)this + 2);
  v7 = *((_QWORD *)this + 3);
  if (v8 == v7)
  {
    *((_QWORD *)this + 3) = v8 - 8;
  }
  else
  {
    v9 = *(_QWORD *)(v7 - 8);
    if (v9)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
      v7 = *((_QWORD *)this + 3);
    }
    *((_QWORD *)this + 3) = v7 - 8;
  }
}

uint64_t DepthBufferManager::enableDepth(DepthBufferManager *this)
{
  return (*(uint64_t (**)(DepthBufferManager *, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)this + 64))(this, 1, 1, 0, 0);
}

void DBM_gl::DBM_gl(DBM_gl *this, HGRenderer *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_BYTE *)this + 40) = 0;
  *((_QWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_1E65235C8;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 9) = (char *)this + 80;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 24) = -1;
  *((_QWORD *)this + 13) = 0;
  v4 = HGRectMake4i(0, 0, 1u, 1u);
  v6 = (*(uint64_t (**)(HGRenderer *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 136))(a2, v4, v5, 28);
  (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 1) + 144))(*((_QWORD *)this + 1), v6);
  (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  DBM_gl::_initOneDepthFormat(this, 6402);
  *((_DWORD *)this + 24) = 6402;
  glFlush();
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 1) + 144))(*((_QWORD *)this + 1), 0);
}

void sub_1B2A38A48(_Unwind_Exception *a1)
{
  DepthBufferManager *v1;
  uint64_t v2;

  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v2, *((_QWORD **)v1 + 10));
  DepthBufferManager::~DepthBufferManager(v1);
  _Unwind_Resume(a1);
}

void DBM_gl::~DBM_gl(DBM_gl *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E65235C8;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 72, *((_QWORD **)this + 10));
  for (*(_QWORD *)this = off_1E6523568; ; (*(void (**)(DBM_gl *))(*(_QWORD *)this + 32))(this))
  {
    v2 = (void *)*((_QWORD *)this + 2);
    if (v2 == *((void **)this + 3))
      break;
  }
  *((_QWORD *)this + 1) = 0;
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_1E65235C8;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 72, *((_QWORD **)this + 10));
  for (*(_QWORD *)this = off_1E6523568; ; (*(void (**)(DBM_gl *))(*(_QWORD *)this + 32))(this))
  {
    v2 = (void *)*((_QWORD *)this + 2);
    if (v2 == *((void **)this + 3))
      break;
  }
  *((_QWORD *)this + 1) = 0;
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1B5E29170);
}

HGGPURenderer *DBM_gl::uninit(HGGPURenderer **this)
{
  GLuint v2;
  HGGPURenderer *v3;
  HGGPURenderer *v4;
  HGGPURenderer *result;
  GLuint shaders;
  PCSharedCount v7;
  _BYTE v8[16];

  if (this[13])
  {
    HGGPURenderer::GetCurrentContext(this[1], (uint64_t *)&v7);
    HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v8, &v7.var0);
    HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v8);
    PCSharedCount::PCSharedCount(&v7);
    v2 = *((_DWORD *)this + 26);
    shaders = 0;
    glGetAttachedShaders(v2, 1, 0, &shaders);
    glDeleteShader(shaders);
    glDeleteProgram(v2);
    this[13] = 0;
  }
  v3 = this[6];
  if (v3)
  {
    (*(void (**)(HGGPURenderer *))(*(_QWORD *)v3 + 24))(v3);
    this[6] = 0;
  }
  v4 = this[7];
  if (v4)
  {
    (*(void (**)(HGGPURenderer *))(*(_QWORD *)v4 + 24))(v4);
    this[7] = 0;
  }
  result = this[8];
  if (result)
  {
    result = (HGGPURenderer *)(*(uint64_t (**)(HGGPURenderer *))(*(_QWORD *)result + 24))(result);
    this[8] = 0;
  }
  while (this[2] != this[3])
    result = (HGGPURenderer *)(*((uint64_t (**)(HGGPURenderer **))*this + 4))(this);
  this[1] = 0;
  return result;
}

void sub_1B2A38C54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

uint64_t DBM_gl::enableDepth(DBM_gl *this)
{
  return (*(uint64_t (**)(DBM_gl *, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)this + 64))(this, 1, 1, 0, 0);
}

void DBM_gl::enableDepth(DBM_gl *this, int a2, int flag, const char *a4, char *a5)
{
  int v5;
  GLenum v6;
  unsigned __int8 v10;
  GLenum v11;
  unsigned __int8 v12;
  unsigned __int8 v13;

  v5 = (int)a5;
  v6 = a4;
  v10 = atomic_load(HGLogger::_enabled);
  if ((v10 & 1) != 0)
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"depth enabled\n", a4, a5);
  if (a2)
  {
    glDepthMask(flag);
    glEnable(0xB71u);
    if (v6)
      v11 = v6;
    else
      v11 = 513;
    glDepthFunc(v11);
  }
  else if (flag)
  {
    v12 = atomic_load(HGLogger::_enabled);
    if ((v12 & 1) != 0)
      HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"\n *** DBM ERROR : can't write depth with depth test off.\n\n", a4, a5);
  }
  if (*((_BYTE *)this + 112) || v5)
  {
    v13 = atomic_load(HGLogger::_enabled);
    if ((v13 & 1) != 0)
      HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"depth cleared\n", a4, a5);
    glClearDepthf(1.0);
    glClear(0x100u);
    *((_BYTE *)this + 112) = 0;
  }
}

void DBM_gl::disableDepth(DBM_gl *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v5;

  v5 = atomic_load(HGLogger::_enabled);
  if ((v5 & 1) != 0)
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"depth disabled\n", a4, a5);
  glDepthMask(0);
  glDisable(0xB71u);
}

_QWORD *DBM_gl::_reinitDepth(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;
  GLuint Program;
  GLuint Shader;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  char *v11;
  GLenum i;
  const char *v13;
  unsigned __int8 v14;
  GLint length;
  HGRect v16;

  if (this[6])
  {
    v1 = this;
    (*(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t, _QWORD))(*this + 64))(this, 1, 1, 519, 0);
    v2 = v1[13];
    if (!v2)
    {
      Program = glCreateProgram();
      Shader = glCreateShader(0x8B30u);
      length = strlen(DBM_gl::_reinitDepth(void)::shaderStr);
      glShaderSource(Shader, 1, (const GLchar *const *)&DBM_gl::_reinitDepth(void)::shaderStr, &length);
      glCompileShader(Shader);
      glAttachShader(Program, Shader);
      glBindAttribLocation(Program, 0, "hg_TexCoord0");
      glLinkProgram(Program);
      LODWORD(v2) = Program;
      v1[13] = Program;
    }
    glUseProgram(v2);
    v5 = HGRectIntersection(*(_QWORD *)(*(_QWORD *)(v1[3] - 8) + 20), *(_QWORD *)(*(_QWORD *)(v1[3] - 8) + 28), *(_QWORD *)(v1[6] + 20), *(_QWORD *)(v1[6] + 28));
    v7 = v6;
    v8 = *(unsigned int *)(v1[6] + 168);
    v9 = *(unsigned int *)(*(_QWORD *)(v1[3] - 8) + 156);
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v1[1] + 152))(v1[1], 0);
    *(_QWORD *)&v16.var0 = v5;
    *(_QWORD *)&v16.var2 = v7;
    HGGPURenderer::Rect((HGGPURenderer *)v1[1], v16);
    (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v1[1] + 152))(v1[1], 0, 0, 0, 0);
    glUseProgram(0);
    if ((_MergedGlobals_7 & 1) == 0)
    {
      for (i = glGetError(); i; i = glGetError())
      {
        v13 = HGGLGetErrorString(i);
        printf("glGetError : %s\n", v13);
      }
    }
    v14 = atomic_load(HGLogger::_enabled);
    if ((v14 & 1) != 0)
      HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"** copying depth texture %d into depth buffer %d\n", v10, v11, v8, v9);
    return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v1 + 72))(v1);
  }
  return this;
}

void DBM_gl::_bind(DBM_gl *this, HGNode *a2, HGRect a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  const char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  const char *v19;
  char *v20;
  unsigned __int8 v21;
  uint64_t v22;
  const char *v23;
  char *v24;
  unsigned __int8 v25;
  uint64_t v26;
  uint64_t v27;
  HGGPURenderer *v28;
  const char *v29;
  char *v30;
  unsigned __int8 v31;
  uint64_t v32;
  HGBitmap *v33;
  void *v34;
  uint64_t v35;
  _DWORD *v36;
  GLuint v37;
  uint64_t v38;
  const char *v39;
  char *v40;
  unsigned __int8 v41;
  GLenum v42;
  const char *v43;
  GLenum Error;
  const char *v45;
  uint64_t v46;
  unsigned __int8 v47;
  const char *v48;
  char *v49;
  unsigned __int8 v50;
  uint64_t v51;
  unsigned __int8 v52;
  GLuint texture;
  char v55[20];
  char __str[100];
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 2) == *((_QWORD *)this + 3))
    return;
  v4 = *(_QWORD *)&a3.var2;
  v5 = *(_QWORD *)&a3.var0;
  *((_BYTE *)this + 112) = 1;
  snprintf(__str, 0x64uLL, "DBM_gl::bind( rect : %d %d %d %d)", a3.var0, a3.var1, a3.var2, a3.var3);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v55, "gpu", 1, __str);
  v9 = *(_QWORD *)(*((_QWORD *)this + 1) + 24);
  v10 = *(_QWORD *)(v9 + 136);
  v11 = *(_QWORD *)(v9 + 144);
  v12 = *((_QWORD *)this + 3);
  v13 = *(_QWORD *)(v12 - 8);
  if (!v13)
    goto LABEL_32;
  v14 = *(_QWORD *)(v13 + 136);
  v15 = *(_QWORD *)(v13 + 144);
  v16 = atomic_load(HGLogger::_enabled);
  if ((v16 & 1) != 0)
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"************ already has depth buffer, let's check \n", v7, v8);
  v17 = atomic_load(HGLogger::_enabled);
  if ((v17 & 1) != 0)
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)" current depth buffer rect : %d %d %d %d\n", v7, v8, v14, HIDWORD(v14), v15, HIDWORD(v15));
  v18 = atomic_load(HGLogger::_enabled);
  if ((v18 & 1) != 0)
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)" requested rect : %d %d %d %d\n", v7, v8, v10, HIDWORD(v10), v11, HIDWORD(v11));
  if (!HGRectIsEqual(v14, v15, v10, v11))
  {
    if (HGRectContainsRect(v14, v15, v10, v11))
    {
      v25 = atomic_load(HGLogger::_enabled);
      if ((v25 & 1) != 0)
        HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"too big!, we'll need a sub-buffer to render into! \n", v23, v24);
      v26 = *((_QWORD *)this + 3);
      if (*((_QWORD *)this + 2) == v26)
        v27 = 0;
      else
        v27 = *(_QWORD *)(v26 - 8);
      *((_QWORD *)this + 7) = v27;
      (*(void (**)(uint64_t))(*(_QWORD *)v27 + 16))(v27);
    }
    else if (HGRectContainsRect(v10, v11, v14, v15))
    {
      v31 = atomic_load(HGLogger::_enabled);
      if ((v31 & 1) != 0)
        HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"nope, too bad\n", v29, v30);
      *((_BYTE *)this + 112) = 1;
      v32 = *((_QWORD *)this + 3);
      if (*((_QWORD *)this + 2) == v32 || (v33 = *(HGBitmap **)(v32 - 8)) == 0)
      {
        v52 = atomic_load(HGLogger::_enabled);
        if ((v52 & 1) != 0)
          HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"no depth, but need one! use a small \"deep\" texture\n", v29, v30);
        v34 = DBM_gl::nullTexture(this);
        (*(void (**)(void *))(*(_QWORD *)v34 + 16))(v34);
      }
      else
      {
        v34 = HGGLTexture::CreateTexture(*(HGGLTexture **)(v32 - 8), *((HGGLBuffer **)this + 1), v28);
        HGGPURenderer::AddTextureUsage(*((HGGPURenderer **)this + 1), v33);
      }
      *((_QWORD *)this + 6) = v34;
      v35 = *(_QWORD *)(v12 - 8);
      if (!v35)
        goto LABEL_32;
LABEL_31:
      (*(void (**)(uint64_t))(*(_QWORD *)v35 + 24))(v35);
      *(_QWORD *)(v12 - 8) = 0;
      goto LABEL_32;
    }
    v35 = *(_QWORD *)(v12 - 8);
    if (!v35)
      goto LABEL_32;
    goto LABEL_31;
  }
  v21 = atomic_load(HGLogger::_enabled);
  if ((v21 & 1) != 0)
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"same size, perfect!!\n", v19, v20);
  *((_BYTE *)this + 112) = 0;
  v22 = *(_QWORD *)(v12 - 8);
  if (qword_1ED4DA418 == v22)
  {
    *((_BYTE *)this + 112) = 1;
    qword_1ED4DA418 = 0;
    if (v22)
      goto LABEL_33;
  }
  else if (v22)
  {
    goto LABEL_33;
  }
LABEL_32:
  texture = 0;
  HGGPURenderer::GenRectTexture(*((HGTextureManager ***)this + 1), (char *)&texture, (char *)0xDE1, v11 - v10, HIDWORD(v11) - HIDWORD(v10), *((_DWORD *)this + 24), 6402, 5125, 0);
  glBindTexture(0xDE1u, texture);
  glTexParameteri(0xDE1u, 0x2802u, 33071);
  glTexParameteri(0xDE1u, 0x2803u, 33071);
  glTexParameteri(0xDE1u, 0x2800u, 9728);
  glTexParameteri(0xDE1u, 0x2801u, 9728);
  glTexImage2D(0xDE1u, 0, *((_DWORD *)this + 24), v11 - v10, HIDWORD(v11) - HIDWORD(v10), 0, 0x1902u, 0x1405u, 0);
  v36 = HGObject::operator new(0xB8uLL);
  HGGLBuffer::HGGLBuffer((uint64_t)v36, v10, v11, 7, *((_QWORD *)this + 1));
  v37 = texture;
  v36[39] = texture;
  v36[40] = v37;
  v36[38] = 3553;
  *((_QWORD *)v36 + 17) = v5;
  *((_QWORD *)v36 + 18) = v4;
  *((_BYTE *)v36 + 180) = 0;
  *(_QWORD *)(v12 - 8) = v36;
  glBindTexture(0xDE1u, 0);
  v22 = *(_QWORD *)(v12 - 8);
  if (!v22)
    goto LABEL_42;
LABEL_33:
  if (!a4)
  {
LABEL_42:
    if (v22)
    {
      v46 = *(unsigned int *)(v22 + 156);
      v47 = atomic_load(HGLogger::_enabled);
      if ((v47 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"created (not bound) depth with ID %d\n", v19, v20, v46);
      qword_1ED4DA418 = *(_QWORD *)(v12 - 8);
    }
    goto LABEL_46;
  }
  v38 = *(unsigned int *)(v22 + 156);
  glFramebufferTexture2D(0x8D40u, 0x8D00u, 0xDE1u, *(_DWORD *)(v22 + 156), 0);
  v41 = atomic_load(HGLogger::_enabled);
  if ((v41 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"Drawing into depth with ID %d\n", v39, v40, v38);
  if ((_MergedGlobals_7 & 1) == 0)
  {
    v42 = glCheckFramebufferStatus(0x8D40u);
    if (v42 != 36053)
    {
      v43 = HGGLGetFramebufferStatusString(v42);
      printf("glCheckFBOStatus : %s\n", v43);
    }
    if ((_MergedGlobals_7 & 1) == 0)
    {
      while (1)
      {
        Error = glGetError();
        if (!Error)
          break;
        v45 = HGGLGetErrorString(Error);
        printf("glGetError : %s\n", v45);
      }
    }
  }
LABEL_46:
  texture = 0;
  glGetIntegerv(0xD56u, (GLint *)&texture);
  v50 = atomic_load(HGLogger::_enabled);
  if ((v50 & 1) != 0)
    HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"fbo depth size : %d \t tex depth size : %d\n", v48, v49, texture, 0xFFFFFFFFLL);
  DBM_gl::_reinitDepth(this);
  v51 = *((_QWORD *)this + 6);
  if (v51)
    (*(void (**)(uint64_t))(*(_QWORD *)v51 + 24))(v51);
  *((_QWORD *)this + 6) = 0;
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v55);
}

void sub_1B2A39540(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A39554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A39568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A3957C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A39590(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  void *v14;

  HGObject::operator delete(v14);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a14);
  _Unwind_Resume(a1);
}

void sub_1B2A395B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A395C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A395D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A395EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A39600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void DBM_gl::preBind(DBM_gl *this, HGRect a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)&a2.var2;
  *(_QWORD *)&a2.var2 = *(_QWORD *)&a2.var0;
  DBM_gl::_bind(this, *(HGNode **)&a2.var0, *(HGRect *)&a2.var2, 0);
}

void DBM_gl::bind(DBM_gl *this, HGNode *a2, HGRect a3)
{
  DBM_gl::_bind(this, a2, a3, 1);
}

uint64_t DBM_gl::unbind(DBM_gl *this)
{
  HGGPURenderer *v2;
  const char *v3;
  char *v4;
  unsigned __int8 v5;
  uint64_t result;
  uint64_t v7;
  HGBitmap *v8;
  void *Texture;
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  GLenum v18;
  const char *v19;
  GLenum i;
  const char *v21;
  const char *v22;
  char *v23;
  unsigned __int8 v24;

  glFramebufferTexture2D(0x8D40u, 0x8D00u, 0xDE1u, 0, 0);
  v5 = atomic_load(HGLogger::_enabled);
  if ((v5 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"unbinding depth\n", v3, v4);
  result = *((_QWORD *)this + 6);
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  *((_QWORD *)this + 6) = 0;
  if (*((_QWORD *)this + 7))
  {
    v7 = *((_QWORD *)this + 3);
    if (*((_QWORD *)this + 2) == v7 || (v8 = *(HGBitmap **)(v7 - 8)) == 0)
    {
      v10 = atomic_load(HGLogger::_enabled);
      if ((v10 & 1) != 0)
        HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"no depth, but need one! use a small \"deep\" texture\n", v3, v4);
      Texture = DBM_gl::nullTexture(this);
      (*(void (**)(void *))(*(_QWORD *)Texture + 16))(Texture);
    }
    else
    {
      Texture = HGGLTexture::CreateTexture(*(HGGLTexture **)(v7 - 8), *((HGGLBuffer **)this + 1), v2);
      HGGPURenderer::AddTextureUsage(*((HGGPURenderer **)this + 1), v8);
    }
    *((_QWORD *)this + 6) = Texture;
    (*(void (**)(_QWORD))(**(_QWORD **)(v7 - 8) + 24))(*(_QWORD *)(v7 - 8));
    v11 = *((_QWORD *)this + 7);
    *(_QWORD *)(v7 - 8) = v11;
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 16))(v11);
    v12 = *((_QWORD *)this + 7);
    v13 = *(unsigned int *)(*((_QWORD *)this + 6) + 168);
    v14 = *(unsigned int *)(v12 + 156);
    v15 = (_QWORD *)*((_QWORD *)this + 1);
    v16 = v15[3];
    v17 = (*(uint64_t (**)(_QWORD *, _QWORD, _QWORD, uint64_t))(*v15 + 136))(v15, *(_QWORD *)(v12 + 20), *(_QWORD *)(v12 + 28), 24);
    (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 1) + 144))(*((_QWORD *)this + 1), v17);
    glFramebufferTexture2D(0x8D40u, 0x8D00u, 0xDE1u, v14, 0);
    if ((_MergedGlobals_7 & 1) == 0)
    {
      v18 = glCheckFramebufferStatus(0x8D40u);
      if (v18 != 36053)
      {
        v19 = HGGLGetFramebufferStatusString(v18);
        printf("glCheckFBOStatus : %s\n", v19);
      }
      if ((_MergedGlobals_7 & 1) == 0)
      {
        for (i = glGetError(); i; i = glGetError())
        {
          v21 = HGGLGetErrorString(i);
          printf("glGetError : %s\n", v21);
        }
      }
    }
    DBM_gl::_reinitDepth(this);
    glFramebufferTexture2D(0x8D40u, 0x8D00u, 0xDE1u, v14, 0);
    (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 1) + 144))(*((_QWORD *)this + 1), v16);
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
    v24 = atomic_load(HGLogger::_enabled);
    if ((v24 & 1) != 0)
      HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"** copying page depth texture %d into full-buffered depth buffer %d\n", v22, v23, v13, v14);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 7) + 24))(*((_QWORD *)this + 7));
    *((_QWORD *)this + 7) = 0;
    result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 6) + 24))(*((_QWORD *)this + 6));
    *((_QWORD *)this + 6) = 0;
  }
  return result;
}

void *DBM_gl::nullTexture(DBM_gl *this)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  GLuint texture;

  if (*((_QWORD *)this + 8))
    return (void *)*((_QWORD *)this + 8);
  texture = 0;
  HGGPURenderer::GenRectTexture(*((HGTextureManager ***)this + 1), (char *)&texture, (char *)0xDE1, 1, 1, *((_DWORD *)this + 24), 6402, 5125, 0);
  glBindTexture(0xDE1u, texture);
  glTexParameteri(0xDE1u, 0x2802u, 33071);
  glTexParameteri(0xDE1u, 0x2803u, 33071);
  glTexParameteri(0xDE1u, 0x2800u, 9728);
  glTexParameteri(0xDE1u, 0x2801u, 9728);
  glTexImage2D(0xDE1u, 0, *((_DWORD *)this + 24), 1, 1, 0, 0x1902u, 0x1405u, &DBM_gl::nullTexture(void)::deep_pixel);
  v3 = HGRectMake4i(0, 0, 1u, 1u);
  v5 = v4;
  v6 = HGObject::operator new(0xC8uLL);
  HGGLTexture::HGGLTexture((uint64_t)v6, v3, v5, 7, *((_QWORD *)this + 1), 3553, texture != 0);
  *((_QWORD *)this + 8) = v6;
  return v6;
}

void sub_1B2A399F4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t DBM_gl::_initOneDepthFormat(DBM_gl *this, int a2)
{
  uint64_t v4;
  uint64_t v5;
  GLenum v6;
  GLint v7;
  uint64_t *v8;
  uint64_t **v9;
  uint64_t **v10;
  int v11;
  uint64_t v12;
  uint64_t *v13;
  _DWORD *v14;
  GLint params;
  PCSharedCount v17;
  _BYTE v18[16];

  *((_DWORD *)this + 24) = a2;
  HGGPURenderer::GetCurrentContext(*((HGGPURenderer **)this + 1), (uint64_t *)&v17);
  HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v18, &v17.var0);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v18);
  PCSharedCount::PCSharedCount(&v17);
  _MergedGlobals_7 = 1;
  (*(void (**)(DBM_gl *))(*(_QWORD *)this + 24))(this);
  v4 = HGRectMake4i(0, 0, 1u, 1u);
  (*(void (**)(DBM_gl *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)this + 40))(this, 0, v4, v5);
  v6 = glCheckFramebufferStatus(0x8D40u);
  params = -1;
  glGetIntegerv(0xD56u, &params);
  (*(void (**)(DBM_gl *))(*(_QWORD *)this + 48))(this);
  _MergedGlobals_7 = 0;
  if (v6 == 36053)
  {
    v7 = params;
    if (params >= 1)
    {
      v9 = (uint64_t **)((char *)this + 80);
      v8 = (uint64_t *)*((_QWORD *)this + 10);
      if (v8)
      {
        do
        {
          while (1)
          {
            v10 = (uint64_t **)v8;
            v11 = *((_DWORD *)v8 + 7);
            if (v11 <= a2)
              break;
            v8 = *v10;
            v9 = v10;
            if (!*v10)
              goto LABEL_11;
          }
          if (v11 >= a2)
          {
            v14 = v10;
            goto LABEL_14;
          }
          v8 = v10[1];
        }
        while (v8);
        v9 = v10 + 1;
      }
      else
      {
        v10 = (uint64_t **)((char *)this + 80);
      }
LABEL_11:
      v14 = operator new(0x28uLL);
      v14[7] = a2;
      v14[8] = 0;
      *(_QWORD *)v14 = 0;
      *((_QWORD *)v14 + 1) = 0;
      *((_QWORD *)v14 + 2) = v10;
      *v9 = (uint64_t *)v14;
      v12 = **((_QWORD **)this + 9);
      v13 = (uint64_t *)v14;
      if (v12)
      {
        *((_QWORD *)this + 9) = v12;
        v13 = *v9;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 10), v13);
      ++*((_QWORD *)this + 11);
LABEL_14:
      v14[8] = v7;
    }
  }
  return (*(uint64_t (**)(DBM_gl *))(*(_QWORD *)this + 32))(this);
}

void sub_1B2A39BAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  uint64_t v10;

  (*(void (**)(uint64_t))(*(_QWORD *)v10 + 32))(v10);
  _Unwind_Resume(a1);
}

uint64_t DBM_cpu::DBM_cpu(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)a1 = &off_1E6523630;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 44) = HGRectMake4i(0, 0, 0, 0);
  *(_QWORD *)(a1 + 52) = v3;
  return a1;
}

void sub_1B2A39C48(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void **v3;
  void *v5;
  void *v6;

  v3 = v2;
  v5 = *v3;
  if (*v3)
  {
    v1[10] = v5;
    operator delete(v5);
  }
  for (*v1 = off_1E6523568; ; (*(void (**)(_QWORD *))(*v1 + 32))(v1))
  {
    v6 = (void *)v1[2];
    if (v6 == (void *)v1[3])
      break;
  }
  v1[1] = 0;
  if (v6)
  {
    v1[3] = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

void DBM_cpu::~DBM_cpu(DBM_cpu *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_1E6523630;
  v2 = (void *)*((_QWORD *)this + 9);
  if (v2)
  {
    *((_QWORD *)this + 10) = v2;
    operator delete(v2);
  }
  for (*(_QWORD *)this = off_1E6523568; ; (*(void (**)(DBM_cpu *))(*(_QWORD *)this + 32))(this))
  {
    v3 = (void *)*((_QWORD *)this + 2);
    if (v3 == *((void **)this + 3))
      break;
  }
  *((_QWORD *)this + 1) = 0;
  if (v3)
  {
    *((_QWORD *)this + 3) = v3;
    operator delete(v3);
  }
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_1E6523630;
  v2 = (void *)*((_QWORD *)this + 9);
  if (v2)
  {
    *((_QWORD *)this + 10) = v2;
    operator delete(v2);
  }
  for (*(_QWORD *)this = off_1E6523568; ; (*(void (**)(DBM_cpu *))(*(_QWORD *)this + 32))(this))
  {
    v3 = (void *)*((_QWORD *)this + 2);
    if (v3 == *((void **)this + 3))
      break;
  }
  *((_QWORD *)this + 1) = 0;
  if (v3)
  {
    *((_QWORD *)this + 3) = v3;
    operator delete(v3);
  }
  JUMPOUT(0x1B5E29170);
}

uint64_t DBM_cpu::push(DBM_cpu *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  unint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  __int128 *v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  uint64_t result;
  uint64_t v28;

  DepthBufferManager::push(this, a2, a3, a4, a5);
  v7 = (char *)*((_QWORD *)this + 10);
  v6 = *((_QWORD *)this + 11);
  v8 = v7;
  if ((unint64_t)v7 < v6)
  {
    *(_QWORD *)v7 = 0;
    v9 = (uint64_t)(v7 + 8);
    goto LABEL_23;
  }
  v10 = (char *)*((_QWORD *)this + 9);
  v11 = (v7 - v10) >> 3;
  v12 = v11 + 1;
  if ((unint64_t)(v11 + 1) >> 61)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v13 = v6 - (_QWORD)v10;
  if (v13 >> 2 > v12)
    v12 = v13 >> 2;
  if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
    v14 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v14 = v12;
  if (v14)
  {
    if (v14 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v15 = (char *)operator new(8 * v14);
    v16 = &v15[8 * v11];
    v17 = &v15[8 * v14];
    *(_QWORD *)v16 = 0;
    v9 = (uint64_t)(v16 + 8);
    v18 = (char *)(v7 - v10);
    if (v7 == v10)
      goto LABEL_21;
    goto LABEL_14;
  }
  v15 = 0;
  v16 = (char *)(8 * v11);
  v17 = 0;
  *(_QWORD *)(8 * v11) = 0;
  v9 = 8 * v11 + 8;
  v18 = (char *)(v7 - v10);
  if (v7 != v10)
  {
LABEL_14:
    v19 = (unint64_t)(v18 - 8);
    if (v19 < 0x58)
      goto LABEL_28;
    if ((unint64_t)(v10 - v15) < 0x20)
      goto LABEL_28;
    v20 = (v19 >> 3) + 1;
    v21 = 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
    v8 = &v7[-v21];
    v16 -= v21;
    v22 = &v15[8 * v11 - 16];
    v23 = (__int128 *)(v7 - 16);
    v24 = v20 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v25 = *v23;
      *((_OWORD *)v22 - 1) = *(v23 - 1);
      *(_OWORD *)v22 = v25;
      v22 -= 32;
      v23 -= 2;
      v24 -= 4;
    }
    while (v24);
    if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_28:
      do
      {
        v26 = *((_QWORD *)v8 - 1);
        v8 -= 8;
        *((_QWORD *)v16 - 1) = v26;
        v16 -= 8;
      }
      while (v8 != v10);
    }
    v8 = (char *)*((_QWORD *)this + 9);
  }
LABEL_21:
  *((_QWORD *)this + 9) = v16;
  *((_QWORD *)this + 10) = v9;
  *((_QWORD *)this + 11) = v17;
  if (v8)
    operator delete(v8);
LABEL_23:
  *((_QWORD *)this + 10) = v9;
  result = HGRectMake4i(0, 0, 0, 0);
  *(_QWORD *)((char *)this + 44) = result;
  *(_QWORD *)((char *)this + 52) = v28;
  return result;
}

uint64_t DBM_cpu::pop(DBM_cpu *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;

  v6 = atomic_load(HGLogger::_enabled);
  if ((v6 & 1) != 0)
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"dbm : POP\n", a4, a5);
  v7 = *((_QWORD *)this + 3);
  if (*((_QWORD *)this + 2) == v7)
  {
    v7 = *((_QWORD *)this + 2);
  }
  else
  {
    v8 = *(_QWORD *)(v7 - 8);
    if (v8)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
      v7 = *((_QWORD *)this + 3);
    }
  }
  *((_QWORD *)this + 3) = v7 - 8;
  *((_QWORD *)this + 10) -= 8;
  result = HGRectMake4i(0, 0, 0, 0);
  *(_QWORD *)((char *)this + 44) = result;
  *(_QWORD *)((char *)this + 52) = v10;
  return result;
}

uint64_t DBM_cpu::bufferHint(uint64_t result, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(*(_QWORD *)(result + 80) - 8) = a2;
  return result;
}

void DBM_cpu::bind(DBM_cpu *this, HGNode *a2, HGRect a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t var1;
  uint64_t var3;
  const char *v8;
  char *v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 v15;
  unint64_t v16;
  uint64_t v17;
  unsigned __int8 v18;
  _BOOL4 IsEqual;
  const char *v20;
  char *v21;
  unsigned __int8 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  char *v27;
  HGBuffer *v28;
  const char *v29;
  char *v30;
  unsigned __int8 v31;
  int v32;
  _OWORD *v38;
  int v39;
  const char *v40;
  char *v41;
  int v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  unsigned __int8 v45;
  HGBitmap *v46;
  const char *v47;
  char *v48;
  int v49;
  int v50;
  unsigned __int8 v51;
  int v52;
  int v53;
  unsigned __int8 v54;
  uint64_t v55;
  uint64_t v56;
  char v57[20];
  char __str[100];
  uint64_t v59;
  HGRect v60;

  v59 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 2) != *((_QWORD *)this + 3))
  {
    v3 = *(_QWORD *)&a3.var2;
    v4 = *(_QWORD *)&a3.var0;
    var1 = a3.var1;
    var3 = a3.var3;
    snprintf(__str, 0x64uLL, "DBM_cpu::bind( rect : %d %d %d %d)", a3.var0, a3.var1, a3.var2, a3.var3);
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v57, "gpu", 1, __str);
    v10 = v4;
    v56 = var1;
    LODWORD(v11) = var1;
    v12 = v3;
    v13 = v4;
    if (HGRectIsNull(*(_QWORD *)((char *)this + 44), *(_QWORD *)((char *)this + 52)))
    {
      v14 = *((_QWORD *)this + 3);
      if (!*(_QWORD *)(v14 - 8))
        goto LABEL_13;
    }
    else
    {
      v15 = atomic_load(HGLogger::_enabled);
      if ((v15 & 1) != 0)
        HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"current request for : %d %d %d %d\n", v8, v9, *((unsigned int *)this + 11), *((unsigned int *)this + 12), *((unsigned int *)this + 13), *((unsigned int *)this + 14));
      v16 = HGRectUnion(v4, v3, *(_QWORD *)((char *)this + 44), *(_QWORD *)((char *)this + 52));
      v10 = v16;
      v12 = v17;
      v11 = HIDWORD(v16);
      v13 = v16;
      v14 = *((_QWORD *)this + 3);
      if (!*(_QWORD *)(v14 - 8))
        goto LABEL_13;
    }
    v18 = atomic_load(HGLogger::_enabled);
    if ((v18 & 1) != 0)
      HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"************ already has depth buffer... \n", v8, v9);
    IsEqual = HGRectIsEqual(*(_QWORD *)(*(_QWORD *)(v14 - 8) + 20), *(_QWORD *)(*(_QWORD *)(v14 - 8) + 28), v4, v3);
    v22 = atomic_load(HGLogger::_enabled);
    if (!IsEqual)
    {
      if ((v22 & 1) != 0)
        HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"... nope, too bad... creating a new one... \n", v20, v21);
      (*(void (**)(_QWORD))(**(_QWORD **)(v14 - 8) + 24))(*(_QWORD *)(v14 - 8));
      *(_QWORD *)(v14 - 8) = 0;
      v23 = *(_QWORD *)(*((_QWORD *)this + 10) - 8);
      if (!v23)
        goto LABEL_15;
LABEL_14:
      v24 = HGRectIntersection(v13, v12, *(_QWORD *)(v23 + 20), *(_QWORD *)(v23 + 28));
      if (!HGRectIsNull(v24, v25))
      {
        v43 = atomic_load(HGLogger::_enabled);
        if ((v43 & 1) != 0)
          HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"found pre-allocated buffer %p\n", v26, v27, v23);
        v44 = atomic_load(HGLogger::_enabled);
        if ((v44 & 1) != 0)
          HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"current tile : %d %d %d %d\n", v26, v27, v4, v56, v3, var3);
        v45 = atomic_load(HGLogger::_enabled);
        if ((v45 & 1) != 0)
          HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"buffered depth : %d %d %d %d\n", v26, v27, *(unsigned int *)(v23 + 20), *(unsigned int *)(v23 + 24), *(unsigned int *)(v23 + 28), *(unsigned int *)(v23 + 32));
        if (*(_QWORD *)(v14 - 8))
          goto LABEL_45;
        v46 = (HGBitmap *)HGObject::operator new(0x80uLL);
        HGBitmap::HGBitmap(v46, *(_QWORD *)(v23 + 20), *(_QWORD *)(v23 + 28), *(unsigned int *)(v23 + 16), *(_QWORD *)(v23 + 80), *(_QWORD *)(v23 + 64));
        v28 = (HGBuffer *)HGObject::operator new(0x80uLL);
        *(_QWORD *)&v60.var0 = v13;
        *(_QWORD *)&v60.var2 = v12;
        HGBuffer::HGBuffer(v28, v60, v46);
        (*(void (**)(HGBitmap *))(*(_QWORD *)v46 + 24))(v46);
        *(_QWORD *)(v14 - 8) = v28;
        if (HGRectIsNull(*(_QWORD *)((char *)this + 44), *(_QWORD *)((char *)this + 52)))
        {
          v42 = 0;
        }
        else
        {
          v52 = v4 - *((_DWORD *)v28 + 5);
          v53 = *((_DWORD *)v28 + 14);
          v42 = (v56 - *((_DWORD *)v28 + 6)) * *((_DWORD *)v28 + 16) + v52 * v53;
          v54 = atomic_load(HGLogger::_enabled);
          if ((v54 & 1) != 0)
            HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"bind : offset : %d\n", v47, v48, ((v56 - *((_DWORD *)v28 + 6)) * *((_DWORD *)v28 + 16) + v52 * v53));
        }
        goto LABEL_44;
      }
LABEL_15:
      if (*(_QWORD *)(v14 - 8))
      {
LABEL_45:
        HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v57);
        return;
      }
      v28 = (HGBuffer *)HGObject::operator new(0x80uLL);
      HGBuffer::HGBuffer((uint64_t)v28, v13, v12, 28);
      *(_QWORD *)(v14 - 8) = v28;
      v31 = atomic_load(HGLogger::_enabled);
      if ((v31 & 1) != 0)
        HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"bind : new buffer : %p\n", v29, v30, v28);
      if (HIDWORD(v12) - (int)v11 >= 1 && (int)v12 - v10 >= 1)
      {
        v32 = 0;
        __asm { FMOV            V0.4S, #1.0 }
        do
        {
          v38 = (_OWORD *)(*((_QWORD *)v28 + 10) + v32 * *((_DWORD *)v28 + 16));
          v39 = v12 - v10;
          do
          {
            *v38 = _Q0;
            v38 = (_OWORD *)((char *)v38 + *((int *)v28 + 14));
            --v39;
          }
          while (v39);
          ++v32;
        }
        while (v32 != HIDWORD(v12) - (_DWORD)v11);
      }
      if (HGRectIsNull(*(_QWORD *)((char *)this + 44), *(_QWORD *)((char *)this + 52)))
      {
        v42 = 0;
      }
      else
      {
        v49 = v4 - v10;
        v50 = *((_DWORD *)v28 + 14);
        v42 = (v56 - v11) * *((_DWORD *)v28 + 16) + (v4 - v10) * v50;
        v51 = atomic_load(HGLogger::_enabled);
        if ((v51 & 1) != 0)
          HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"bind : offset : %d\n", v40, v41, ((v56 - v11) * *((_DWORD *)v28 + 16) + v49 * v50));
      }
LABEL_44:
      *((_QWORD *)this + 8) = *((_QWORD *)v28 + 10) + v42;
      *(_QWORD *)((char *)this + 44) = HGRectMake4i(0, 0, 0, 0);
      *(_QWORD *)((char *)this + 52) = v55;
      goto LABEL_45;
    }
    if ((v22 & 1) != 0)
      HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"... same rect, yeah!! \n", v20, v21);
LABEL_13:
    v23 = *(_QWORD *)(*((_QWORD *)this + 10) - 8);
    if (!v23)
      goto LABEL_15;
    goto LABEL_14;
  }
}

void sub_1B2A3A4B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A3A4C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  void *v14;

  HGObject::operator delete(v14);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a14);
  _Unwind_Resume(a1);
}

void sub_1B2A3A554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A3A568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A3A57C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A3A594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A3A5A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A3A5BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t DBM_cpu::setDepthBuffer(DBM_cpu *this, HGBitmap *a2, HGRect a3)
{
  const char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;

  (*(void (**)(DBM_cpu *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 40))(this, 0, *(_QWORD *)&a3.var0, *(_QWORD *)&a3.var2);
  v7 = *((_QWORD *)this + 3);
  if (*((_QWORD *)this + 2) != v7)
  {
    v8 = *(_QWORD *)(v7 - 8);
    if (v8)
    {
      v9 = atomic_load(HGLogger::_enabled);
      if ((v9 & 1) != 0)
        HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"copying depth from cached depth %p to current dbm's depth %p\n", v5, v6, a2, v8);
      v10 = HGRectIntersection(*(_QWORD *)((char *)a2 + 20), *(_QWORD *)((char *)a2 + 28), *(_QWORD *)(v8 + 20), *(_QWORD *)(v8 + 28));
      v12 = HIDWORD(v11);
      if (SHIDWORD(v10) < SHIDWORD(v11))
      {
        v13 = *((_DWORD *)a2 + 14) * ((int)v11 - (int)v10);
        v14 = SHIDWORD(v10);
        v15 = (int)v10;
        do
        {
          memcpy((void *)(*(_QWORD *)(v8 + 80)+ *(_QWORD *)(v8 + 64) * (v14 - *(int *)(v8 + 24))+ *(_QWORD *)(v8 + 56) * (v15 - *(int *)(v8 + 20))), (const void *)(*((_QWORD *)a2 + 10)+ *((_QWORD *)a2 + 8) * (v14 - *((int *)a2 + 6))+ *((_QWORD *)a2 + 7) * (v15 - *((int *)a2 + 5))), v13);
          ++v14;
        }
        while ((_DWORD)v12 != (_DWORD)v14);
      }
    }
  }
  return (*(uint64_t (**)(DBM_cpu *))(*(_QWORD *)this + 48))(this);
}

void HGMetalBuffer::~HGMetalBuffer(HGMetalBuffer *this)
{
  uint64_t *v2;
  _QWORD *v3;
  void *v4;

  *(_QWORD *)this = off_1E65236D0;
  v3 = (_QWORD *)((char *)this + 128);
  v2 = (uint64_t *)*((_QWORD *)this + 16);
  if (v2)
    HGMetalBufferPool::releaseBuffer(v2, *((_QWORD *)this + 18));
  else

  *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  HGBitmap::~HGBitmap((HGBitmap *)this, v4);
}

{
  uint64_t *v2;
  _QWORD *v3;
  void *v4;

  *(_QWORD *)this = off_1E65236D0;
  v3 = (_QWORD *)((char *)this + 128);
  v2 = (uint64_t *)*((_QWORD *)this + 16);
  if (v2)
    HGMetalBufferPool::releaseBuffer(v2, *((_QWORD *)this + 18));
  else

  *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  HGBitmap::~HGBitmap((HGBitmap *)this, v4);
}

{
  uint64_t *v2;
  _QWORD *v3;
  void *v4;
  void *v5;

  *(_QWORD *)this = off_1E65236D0;
  v3 = (_QWORD *)((char *)this + 128);
  v2 = (uint64_t *)*((_QWORD *)this + 16);
  if (v2)
    HGMetalBufferPool::releaseBuffer(v2, *((_QWORD *)this + 18));
  else

  *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  HGBitmap::~HGBitmap((HGBitmap *)this, v4);
  HGObject::operator delete(v5);
}

uint64_t HGMetalBuffer::GetContent(id *this)
{
  return objc_msgSend(this[18], "contents");
}

char *HGMetalBuffer::ModifyRangeAndMarkAsDirty(id *this, uint64_t a2, size_t a3, const void *a4)
{
  char *result;

  result = (char *)objc_msgSend(this[18], "contents");
  if (result)
    return (char *)memcpy(&result[a2], a4, a3);
  return result;
}

BOOL HGMetalBuffer::canCreateFromBytes(HGBitmap *this, HGBitmap *a2)
{
  HGBitmap *v2;
  const void *Storage;
  _QWORD *v4;
  HGBitmap *v5;
  _BOOL4 IsEqual;
  int v7;
  uint64_t v8;
  _BOOL4 v9;

  v2 = this;
  Storage = (const void *)HGBitmap::GetStorage(this);
  if (Storage
  {
    IsEqual = HGRectIsEqual(*(_QWORD *)((char *)v4 + 20), *(_QWORD *)((char *)v4 + 28), *(_QWORD *)((char *)v2 + 36), *(_QWORD *)((char *)v2 + 44));
    v7 = getpagesize();
    if (IsEqual)
      v2 = v5;
    v8 = v7;
    if (!(*((_QWORD *)v2 + 10) % v7))
      goto LABEL_7;
  }
  else
  {
    v8 = getpagesize();
    if (!(*((_QWORD *)v2 + 10) % v8))
    {
LABEL_7:
      v9 = *((_QWORD *)v2 + 9) % v8 == 0;
      return HGMetalUtils::metalFormat(*((_DWORD *)v2 + 4)) && v9;
    }
  }
  v9 = 0;
  return HGMetalUtils::metalFormat(*((_DWORD *)v2 + 4)) && v9;
}

BOOL HGMetalBuffer::canCreateFromBytes(uint64_t a1, HGBitmap *this)
{
  const void *Storage;
  _QWORD *v5;
  HGBitmap *v6;
  HGBitmap *v7;
  unsigned int v8;

  Storage = (const void *)HGBitmap::GetStorage(this);
  if (!Storage
  {
    v6 = this;
  }
  v8 = *(_DWORD *)(HGMetalDeviceInfo::getDeviceInfo(a1) + 48);
  return *((_DWORD *)v6 + 7) - *((_DWORD *)v6 + 5) <= v8
      && *((_DWORD *)v6 + 8) - *((_DWORD *)v6 + 6) <= v8
      && HGMetalBuffer::canCreateFromBytes(this, v7);
}

const char *HGMetalBuffer::createFromBytes@<X0>(HGMetalBuffer *this@<X2>, void *a2@<X0>, uint64_t *a3@<X1>, char a4@<W3>, _QWORD *a5@<X8>)
{
  const void *Storage;
  _QWORD *v11;
  HGMetalBuffer *v12;
  const char *v13;
  char *v14;
  unsigned int v15;
  char *v17;
  uint64_t v18;
  const char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  id v24;
  _QWORD v25[3];
  int v26;

  *a5 = 0;
  if (this && *((_QWORD *)this + 10))
  {
    if (HGMetalBuffer::canCreateFromBytes((HGBitmap *)this, (HGBitmap *)a3))
    {
      v26 = 4608;
      kdebug_trace();
      Storage = (const void *)HGBitmap::GetStorage((HGBitmap *)this);
      if (!Storage
      {
        v12 = this;
      }
      v15 = *(_DWORD *)(HGMetalDeviceInfo::getDeviceInfo((uint64_t)a2) + 48);
      if (*((_DWORD *)v12 + 7) - *((_DWORD *)v12 + 5) > v15 || *((_DWORD *)v12 + 8) - *((_DWORD *)v12 + 6) > v15)
      {
        HGLogger::warning((HGLogger *)"HGMetalBuffer::createFromBytes() failed. Exceeding buffer size limits.", v13, v14);
        return (const char *)kdebug_trace();
      }
      if ((a4 & 1) == 0)
        HGLogger::warning((HGLogger *)"MTLResourceStorageModeManaged is not available on iOS.", v13, v14);
      if (a3)
      {
        v18 = *((_QWORD *)v12 + 9);
        v25[0] = *((_QWORD *)v12 + 10);
        v25[1] = v18;
        v25[2] = 0;
        v22 = HGMetalBufferWrapperInfinipool::newBuffer(a3, (uint64_t)v25);
        if (v22)
        {
LABEL_20:
          v23 = HGObject::operator new(0x98uLL);
          HGBitmap::HGBitmap((uint64_t)v23, *(_QWORD *)((char *)v12 + 20), *(_QWORD *)((char *)v12 + 28), *((_DWORD *)v12 + 4), 0);
          *v23 = off_1E65236D0;
          v23[17] = 0;
          v23[18] = 0;
          v23[16] = 0;
          *((_DWORD *)v23 + 3) |= 0x120u;
          if (a2)
          {
            v23[17] = a2;
            v24 = a2;
          }
          *a5 = v23;
          *((_OWORD *)v23 + 4) = *((_OWORD *)v12 + 4);
          v23[18] = v22;
          HGBitmap::SetStorage((HGBitmap *)v23, v12);
          return (const char *)kdebug_trace();
        }
      }
      else
      {
        v22 = objc_msgSend(a2, "newBufferWithBytesNoCopy:length:options:deallocator:", *((_QWORD *)v12 + 10), *((_QWORD *)v12 + 9), 0, 0);
        v20 = (char *)*((_QWORD *)v12 + 9);
        v21 = *((_QWORD *)v12 + 10);
        v19 = 0;
        if (v22)
          goto LABEL_20;
      }
      HGLogger::warning((HGLogger *)"HGMetalBuffer::createFromBytes() failed. MTLBuffer creation failed.", v19, v20, v21);
      return (const char *)kdebug_trace();
    }
    v17 = "HGMetalBuffer::createFromBytes() failed. Data is not properly aligned.";
  }
  else
  {
    v17 = "HGMetalBuffer::createFromBytes() failed. No HGBitmap provided.";
  }
  return HGLogger::warning((HGLogger *)v17, (const char *)a3, (char *)this);
}

void sub_1B2A3AC7C(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
  HGBitmap *v13;

  HGBitmap::~HGBitmap(v13, a2);
  HGObject::operator delete(v13);
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B2A3ACD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B2A3ACE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B2A3ACF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B2A3AD0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B2A3AD24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B2A3AD38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a13);
  _Unwind_Resume(a1);
}

const char *HGMetalBuffer::createWithCopy@<X0>(void *a1@<X0>, uint64_t a2@<X1>, char *a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  const char *v9;
  char *v10;
  id v11;
  unsigned __int8 v13;

  *a4 = 0;
  if (!a2 || !*(_QWORD *)(a2 + 80))
    return HGLogger::warning((HGLogger *)"HGMetalBuffer::createWithCopy() failed. No HGBitmap provided.", (const char *)a2, a3);
  kdebug_trace();
  v7 = objc_msgSend(a1, "newBufferWithBytes:length:options:", *(_QWORD *)(a2 + 80), *(_QWORD *)(a2 + 72), 32);
  if (v7)
  {
    v8 = HGObject::operator new(0x98uLL);
    HGBitmap::HGBitmap((uint64_t)v8, *(_QWORD *)(a2 + 20), *(_QWORD *)(a2 + 28), *(_DWORD *)(a2 + 16), 0);
    *v8 = off_1E65236D0;
    v8[17] = 0;
    v8[18] = 0;
    v8[16] = 0;
    *((_DWORD *)v8 + 3) |= 0x120u;
    if (a1)
    {
      v8[17] = a1;
      v11 = a1;
    }
    *a4 = v8;
    *((_OWORD *)v8 + 4) = *(_OWORD *)(a2 + 64);
    v8[18] = v7;
  }
  else
  {
    HGLogger::warning((HGLogger *)"HGMetalBuffer::createWithCopy() failed. MTLBuffer creation failed.", 0, *(char **)(a2 + 72), *(_QWORD *)(a2 + 80));
  }
  v13 = atomic_load(HGLogger::_enabled);
  if ((v13 & 1) != 0)
    HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"HGMTL PERF WARNING - HGMetalBuffer::createWithCopy: newBufferWithBytes with copy of misaligned data\n", v9, v10);
  return (const char *)kdebug_trace();
}

void sub_1B2A3AEC4(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
  HGBitmap *v11;

  HGBitmap::~HGBitmap(v11, a2);
  HGObject::operator delete(v11);
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  _Unwind_Resume(a1);
}

void sub_1B2A3AEF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  _Unwind_Resume(a1);
}

void sub_1B2A3AF08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  uint64_t *v11;
  uint64_t v13;

  v13 = *v11;
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
  _Unwind_Resume(a1);
}

uint64_t HGMetalBuffer::create@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, _QWORD *a6@<X8>)
{
  void *v12;
  id v13;
  uint64_t result;
  const char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;

  v12 = HGObject::operator new(0x98uLL);
  HGBitmap::HGBitmap((uint64_t)v12, a3, a4, a5, 0);
  *(_QWORD *)v12 = off_1E65236D0;
  *((_QWORD *)v12 + 17) = 0;
  *((_QWORD *)v12 + 18) = 0;
  *((_QWORD *)v12 + 16) = 0;
  *((_DWORD *)v12 + 3) |= 0x120u;
  if (a1)
  {
    *((_QWORD *)v12 + 17) = a1;
    v13 = a1;
  }
  *a6 = v12;
  if (a2)
  {
    v18 = *((_QWORD *)v12 + 9);
    result = HGMetalBufferPool::newBuffer(a2, &v18);
    v17 = result;
    if (result)
    {
LABEL_5:
      *((_QWORD *)v12 + 18) = v17;
      *((_QWORD *)v12 + 16) = a2;
      return result;
    }
  }
  else
  {
    v17 = objc_msgSend(a1, "newBufferWithLength:options:", *((_QWORD *)v12 + 9), 0);
    result = *((_QWORD *)v12 + 18);
    v16 = (char *)*((_QWORD *)v12 + 9);
    v15 = 0;
    if (v17)
      goto LABEL_5;
  }
  HGLogger::warning((HGLogger *)"HGMetalBuffer::create() failed. Failed to allocate buffer object.", v15, v16);
  result = (*(uint64_t (**)(void *))(*(_QWORD *)v12 + 24))(v12);
  *a6 = 0;
  return result;
}

void sub_1B2A3B050(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t HGMetalBuffer::create@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, unsigned int a3@<W2>, _QWORD *a4@<X8>)
{
  uint64_t v7;
  uint64_t v8;

  v7 = HGRectMake4i(0, 0, a3, 1u);
  return HGMetalBuffer::create(a1, a2, v7, v8, 1, a4);
}

void *HGMetalBuffer::getMetalStorage(HGBitmap *this, HGBitmap *a2)
{
  HGBitmap *v2;
  void *v3;
  const void *Storage;
  HGBitmap *v5;

  if (!this)
    return 0;
  v2 = this;
  do
  {
    Storage = (const void *)HGBitmap::GetStorage(v2);
    if (!Storage)
      break;
    v2 = v5;
  }
  while (!v3 && v5 != 0);
  return v3;
}

uint64_t HGComicLUT::GetFormat(HGComicLUT *this)
{
  return 17;
}

uint64_t HGComicLUT::GetRect(HGComicLUT *this)
{
  HGRect v2;

  HGRect::Init(&v2, 0, 0, 512, 512);
  return *(_QWORD *)&v2.var0;
}

void *HGComicLUT::GetData(int a1)
{
  if ((a1 - 1) > 4)
    return &HGComicLUT0Data;
  else
    return *(&off_1E6523740 + a1 - 1);
}

uint64_t HGGLBuffer::HGGLBuffer(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  _QWORD *v7;

  v7 = HGBuffer::HGBuffer(a1, a2, a3, a4, 0);
  *v7 = off_1E6523778;
  v7[16] = a5;
  *(_OWORD *)(v7 + 17) = *(_OWORD *)((char *)v7 + 20);
  v7[19] = 0;
  v7[20] = 0;
  *((_DWORD *)v7 + 42) = 0;
  *(int32x2_t *)((char *)v7 + 172) = vsub_s32(*(int32x2_t *)((char *)v7 + 28), *(int32x2_t *)((char *)v7 + 20));
  *((_WORD *)v7 + 90) = 257;
  *((_BYTE *)v7 + 182) = 0;
  *((_DWORD *)v7 + 3) |= 0x110u;
  if (a5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a5 + 16))(a5);
    *(_BYTE *)(a1 + 182) = 1;
  }
  return a1;
}

void sub_1B2A3B290(_Unwind_Exception *a1)
{
  HGBuffer *v1;

  HGBuffer::~HGBuffer(v1);
  _Unwind_Resume(a1);
}

uint64_t HGGLBuffer::HGGLBuffer(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6, int a7, char a8)
{
  _QWORD *v13;

  v13 = HGBuffer::HGBuffer(a1, a2, a3, a4, 0);
  *v13 = off_1E6523778;
  v13[16] = a5;
  *(_OWORD *)(v13 + 17) = *(_OWORD *)((char *)v13 + 20);
  *((_DWORD *)v13 + 38) = a6;
  *((_DWORD *)v13 + 39) = a7;
  v13[20] = 0;
  *((_DWORD *)v13 + 42) = 0;
  *(int32x2_t *)((char *)v13 + 172) = vsub_s32(*(int32x2_t *)((char *)v13 + 28), *(int32x2_t *)((char *)v13 + 20));
  *((_BYTE *)v13 + 180) = 0;
  *((_BYTE *)v13 + 181) = a8;
  *((_BYTE *)v13 + 182) = 0;
  *((_DWORD *)v13 + 3) |= 0x110u;
  if (a5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a5 + 16))(a5);
    *(_BYTE *)(a1 + 182) = 1;
  }
  return a1;
}

void sub_1B2A3B358(_Unwind_Exception *a1)
{
  HGBuffer *v1;

  HGBuffer::~HGBuffer(v1);
  _Unwind_Resume(a1);
}

void HGGLBuffer::~HGGLBuffer(HGGLBuffer *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6523778;
  v2 = *((_QWORD *)this + 16);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    *((_QWORD *)this + 16) = 0;
    *((_BYTE *)this + 182) = 1;
  }
  else
  {
    *((_BYTE *)this + 182) = 0;
  }
  HGBuffer::~HGBuffer(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6523778;
  v2 = *((_QWORD *)this + 16);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    *((_QWORD *)this + 16) = 0;
    *((_BYTE *)this + 182) = 1;
  }
  else
  {
    *((_BYTE *)this + 182) = 0;
  }
  HGBuffer::~HGBuffer(this);
  HGObject::operator delete(v3);
}

unsigned int *HGGLBuffer::Release(HGBitmap *this)
{
  unsigned int v2;
  uint64_t v3;

  if (*((_QWORD *)this + 16))
  {
    v2 = atomic_load((unsigned int *)this + 2);
    if (v2 == 1)
    {
      HGGPURenderer::ReleaseBitmap(*((int64x2_t **)this + 16), this, (char *)1);
      v3 = *((_QWORD *)this + 16);
      if (v3)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
        *((_QWORD *)this + 16) = 0;
      }
    }
  }
  return HGObject::Release((unsigned int *)this);
}

void HGGLBuffer::ReadPixels(HGGLBuffer *this, HGPixelBufferObj *a2, HGRect a3)
{
  HGPixelBufferObj::ReadPixels((uint64_t)a2, *(uint64_t *)&a3.var0, *(uint64_t *)&a3.var2, *(_QWORD *)((char *)this + 20), *(_QWORD *)((char *)this + 28), (*((_DWORD *)this + 5) - *((_DWORD *)this + 34)), (*((_DWORD *)this + 6) - *((_DWORD *)this + 35)), *((_DWORD *)this + 4));
}

uint64_t HGGLBuffer::AttachRenderer(uint64_t result, uint64_t a2)
{
  if (!*(_BYTE *)(result + 182) && a2 && !*(_QWORD *)(result + 128))
  {
    *(_QWORD *)(result + 128) = a2;
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  }
  return result;
}

uint64_t HGGLBuffer::DetachRenderer(uint64_t this)
{
  uint64_t v1;

  if (!*(_BYTE *)(this + 182))
  {
    v1 = this;
    this = *(_QWORD *)(this + 128);
    if (this)
    {
      this = (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 24))(this);
      *(_QWORD *)(v1 + 128) = 0;
    }
  }
  return this;
}

uint64_t HGBlendingInfo::Get(HGBlendingInfo *this)
{
  unsigned __int8 v1;
  int v3;
  __int128 v4;
  int v5;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_8);
  if ((v1 & 1) == 0)
  {
    v5 = (int)this;
    v3 = __cxa_guard_acquire((__guard *)&_MergedGlobals_8);
    LODWORD(this) = v5;
    if (v3)
    {
      qword_1ED4DA428 = 0;
      qword_1ED4DA430 = 1;
      dword_1ED4DA438 = 1;
      unk_1ED4DA444 = 0;
      unk_1ED4DA43C = 0;
      dword_1ED4DA44C = 0;
      qword_1ED4DA450 = 1;
      dword_1ED4DA458 = 1;
      unk_1ED4DA464 = 0;
      unk_1ED4DA45C = 0;
      dword_1ED4DA46C = 0;
      qword_1ED4DA470 = 1;
      dword_1ED4DA478 = 1;
      unk_1ED4DA484 = 0;
      unk_1ED4DA47C = 0;
      dword_1ED4DA48C = 0;
      qword_1ED4DA490 = 1;
      dword_1ED4DA498 = 1;
      unk_1ED4DA4A4 = 0;
      unk_1ED4DA49C = 0;
      dword_1ED4DA4AC = 0;
      qword_1ED4DA4B0 = 1;
      dword_1ED4DA4B8 = 1;
      dword_1ED4DA4CC = 0;
      unk_1ED4DA4BC = 0;
      unk_1ED4DA4C4 = 0;
      qword_1ED4DA4D0 = 1;
      dword_1ED4DA4D8 = 1;
      dword_1ED4DA4EC = 0;
      unk_1ED4DA4DC = 0;
      unk_1ED4DA4E4 = 0;
      qword_1ED4DA4F0 = 1;
      dword_1ED4DA4F8 = 1;
      unk_1ED4DA504 = 0;
      unk_1ED4DA4FC = 0;
      dword_1ED4DA50C = 0;
      qword_1ED4DA510 = 1;
      dword_1ED4DA518 = 1;
      unk_1ED4DA524 = 0;
      unk_1ED4DA51C = 0;
      dword_1ED4DA52C = 0;
      xmmword_1ED4DA530 = xmmword_1B309BAB0;
      qword_1ED4DA540 = 0;
      xmmword_1ED4DA550 = xmmword_1B3056FC0;
      qword_1ED4DA560 = 0;
      qword_1ED4DA548 = 3;
      qword_1ED4DA568 = 0;
      qword_1ED4DA570 = 1;
      dword_1ED4DA578 = 1;
      unk_1ED4DA584 = 0;
      unk_1ED4DA57C = 0;
      dword_1ED4DA58C = 0;
      qword_1ED4DA590 = 1;
      dword_1ED4DA598 = 1;
      unk_1ED4DA5A4 = 0;
      unk_1ED4DA59C = 0;
      dword_1ED4DA5AC = 0;
      qword_1ED4DA5B0 = 1;
      dword_1ED4DA5B8 = 1;
      unk_1ED4DA5C4 = 0;
      unk_1ED4DA5BC = 0;
      dword_1ED4DA5CC = 0;
      qword_1ED4DA5D0 = 1;
      dword_1ED4DA5D8 = 1;
      unk_1ED4DA5E4 = 0;
      unk_1ED4DA5DC = 0;
      dword_1ED4DA5EC = 0;
      xmmword_1ED4DA5F0 = xmmword_1B309BAB0;
      qword_1ED4DA600 = 0;
      xmmword_1ED4DA610 = xmmword_1B351F5D0;
      qword_1ED4DA620 = 0;
      qword_1ED4DA608 = 3;
      qword_1ED4DA628 = 0;
      xmmword_1ED4DA630 = xmmword_1B309BAB0;
      qword_1ED4DA640 = 0;
      xmmword_1ED4DA650 = xmmword_1B351F5E0;
      qword_1ED4DA660 = 0;
      qword_1ED4DA648 = 3;
      qword_1ED4DA668 = 0;
      qword_1ED4DA670 = 1;
      dword_1ED4DA678 = 1;
      unk_1ED4DA684 = 0;
      unk_1ED4DA67C = 0;
      dword_1ED4DA68C = 0;
      qword_1ED4DA690 = 1;
      dword_1ED4DA698 = 1;
      unk_1ED4DA6A4 = 0;
      unk_1ED4DA69C = 0;
      dword_1ED4DA6AC = 0;
      qword_1ED4DA6B0 = 1;
      dword_1ED4DA6B8 = 1;
      unk_1ED4DA6C4 = 0;
      unk_1ED4DA6BC = 0;
      dword_1ED4DA6CC = 0;
      qword_1ED4DA6D0 = 1;
      dword_1ED4DA6D8 = 1;
      unk_1ED4DA6E4 = 0;
      unk_1ED4DA6DC = 0;
      dword_1ED4DA6EC = 0;
      qword_1ED4DA6F0 = 1;
      dword_1ED4DA6F8 = 1;
      unk_1ED4DA704 = 0;
      unk_1ED4DA6FC = 0;
      dword_1ED4DA70C = 0;
      qword_1ED4DA710 = 1;
      dword_1ED4DA718 = 1;
      unk_1ED4DA724 = 0;
      unk_1ED4DA71C = 0;
      dword_1ED4DA72C = 0;
      qword_1ED4DA730 = 1;
      dword_1ED4DA738 = 1;
      unk_1ED4DA744 = 0;
      unk_1ED4DA73C = 0;
      dword_1ED4DA74C = 0;
      qword_1ED4DA750 = 1;
      dword_1ED4DA758 = 1;
      unk_1ED4DA764 = 0;
      unk_1ED4DA75C = 0;
      dword_1ED4DA76C = 0;
      qword_1ED4DA770 = 1;
      dword_1ED4DA778 = 1;
      unk_1ED4DA784 = 0;
      unk_1ED4DA77C = 0;
      dword_1ED4DA78C = 0;
      xmmword_1ED4DA790 = xmmword_1B309BAB0;
      qword_1ED4DA7A0 = 0;
      xmmword_1ED4DA7B0 = xmmword_1B351F5F0;
      qword_1ED4DA7C0 = 0;
      qword_1ED4DA7A8 = 3;
      qword_1ED4DA7C8 = 0;
      qword_1ED4DA7D0 = 1;
      dword_1ED4DA7D8 = 1;
      unk_1ED4DA7E4 = 0;
      unk_1ED4DA7DC = 0;
      dword_1ED4DA7EC = 0;
      qword_1ED4DA7F0 = 1;
      dword_1ED4DA7F8 = 1;
      unk_1ED4DA804 = 0;
      unk_1ED4DA7FC = 0;
      dword_1ED4DA80C = 0;
      qword_1ED4DA810 = 1;
      dword_1ED4DA818 = 1;
      unk_1ED4DA824 = 0;
      unk_1ED4DA81C = 0;
      dword_1ED4DA82C = 0;
      xmmword_1ED4DA830 = xmmword_1B309BAB0;
      qword_1ED4DA840 = 0;
      xmmword_1ED4DA850 = xmmword_1B309BAA0;
      qword_1ED4DA860 = 0;
      qword_1ED4DA848 = 3;
      qword_1ED4DA868 = 0;
      qword_1ED4DA870 = 1;
      dword_1ED4DA878 = 1;
      unk_1ED4DA884 = 0;
      unk_1ED4DA87C = 0;
      dword_1ED4DA88C = 0;
      xmmword_1ED4DA890 = xmmword_1B309BAB0;
      qword_1ED4DA8A0 = 0;
      xmmword_1ED4DA8B0 = xmmword_1B351F600;
      qword_1ED4DA8C0 = 0;
      qword_1ED4DA8A8 = 3;
      xmmword_1ED4DA8D0 = xmmword_1B351F610;
      qword_1ED4DA8E0 = 0;
      qword_1ED4DA8C8 = 3;
      qword_1ED4DA8E8 = 0;
      qword_1ED4DA8F0 = 1;
      dword_1ED4DA8F8 = 1;
      unk_1ED4DA904 = 0;
      unk_1ED4DA8FC = 0;
      dword_1ED4DA90C = 0;
      xmmword_1ED4DA910 = xmmword_1B309BAB0;
      qword_1ED4DA920 = 0;
      *(_QWORD *)&v4 = 0x100000001;
      *((_QWORD *)&v4 + 1) = 0x100000001;
      xmmword_1ED4DA930 = v4;
      qword_1ED4DA940 = 0x200000002;
      qword_1ED4DA928 = 0;
      xmmword_1ED4DA950 = xmmword_1B309BAB0;
      qword_1ED4DA960 = 0;
      qword_1ED4DA948 = 0;
      __cxa_guard_release((__guard *)&_MergedGlobals_8);
      LODWORD(this) = v5;
    }
  }
  return (uint64_t)&_MergedGlobals_8 + 32 * this + 8;
}

BOOL HGBlendingInfo::operator<(uint64_t a1, uint64_t a2)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  if (*(_QWORD *)a1 < *(_QWORD *)a2)
    return 1;
  if (*(_QWORD *)a2 < *(_QWORD *)a1)
    return 0;
  v3 = *(_DWORD *)(a1 + 8);
  v4 = *(_DWORD *)(a2 + 8);
  if (v3 < v4)
    return 1;
  if (v4 < v3)
    return 0;
  v5 = *(_DWORD *)(a1 + 12);
  v6 = *(_DWORD *)(a2 + 12);
  if (v5 < v6)
    return 1;
  if (v6 < v5)
    return 0;
  v7 = *(_DWORD *)(a1 + 16);
  v8 = *(_DWORD *)(a2 + 16);
  if (v7 < v8)
    return 1;
  if (v8 < v7)
    return 0;
  v9 = *(_DWORD *)(a1 + 20);
  v10 = *(_DWORD *)(a2 + 20);
  if (v9 < v10)
    return 1;
  if (v10 < v9)
    return 0;
  v11 = *(_DWORD *)(a1 + 24);
  v12 = *(_DWORD *)(a2 + 24);
  if (v11 < v12)
    return 1;
  if (v12 >= v11)
    return *(_DWORD *)(a1 + 28) < *(_DWORD *)(a2 + 28);
  return 0;
}

BOOL HGBlendingInfo::operator==(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)a1 == *(_QWORD *)a2
      && *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
      && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
      && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16)
      && *(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20)
      && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24)
      && *(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 28);
}

void HGMetalBlendingInfo::HGMetalBlendingInfo(HGMetalBlendingInfo *this, int32x2_t *a2)
{
  int8x8_t v2;
  int8x8_t v3;
  int8x8_t v4;
  int32x2_t v5;
  uint64x2_t v6;
  uint64x2_t v7;
  int8x8_t v8;
  int32x2_t v9;
  uint32x2_t v10;

  v2 = (int8x8_t)a2[1];
  v3 = (int8x8_t)a2[2];
  v4 = (int8x8_t)vcgt_u32((uint32x2_t)0xD0000000DLL, (uint32x2_t)v2);
  v5 = vsub_s32((int32x2_t)vand_s8(v2, v4), (int32x2_t)vmvn_s8(v4));
  v6.i64[0] = v5.u32[0];
  v6.i64[1] = v5.u32[1];
  v7 = v6;
  v8 = (int8x8_t)vcgt_u32((uint32x2_t)0xD0000000DLL, (uint32x2_t)v3);
  v9 = vsub_s32((int32x2_t)vand_s8(v3, v8), (int32x2_t)vmvn_s8(v8));
  v6.i64[0] = v9.u32[0];
  v6.i64[1] = v9.u32[1];
  *(uint64x2_t *)this = v7;
  *((uint64x2_t *)this + 1) = v6;
  v10 = (uint32x2_t)vadd_s32(a2[3], (int32x2_t)-1);
  v6.i64[0] = v10.u32[0];
  v6.i64[1] = v10.u32[1];
  *((int8x16_t *)this + 2) = vandq_s8((int8x16_t)vaddw_u32((uint64x2_t)vdupq_n_s64(1uLL), v10), (int8x16_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(4uLL), v6));
}

void HGGLHandler::HGGLHandler(HGGLHandler *this)
{
  uint64_t v1;

  HGHandler::HGHandler(this);
  *(_QWORD *)v1 = off_1E65237F8;
  *(_DWORD *)(v1 + 248) = 3553;
}

uint64_t HGGLHandler::InitTexture(HGGLHandler *this, int a2, HGRect a3, HGRect a4, HGRect a5, int a6, int a7)
{
  *((_DWORD *)this + 62) = a2;
  return HGHandler::InitTexture((uint64_t)this, a2, a3, a4, a5, a6, a7);
}

void HGGLHandler::SetFilter(HGGLHandler *this, _BOOL4 a2, _BOOL4 a3)
{
  _BOOL4 v3;
  _BOOL4 v4;
  GLenum v6;
  GLint v7;
  GLint v8;
  const char *v9;
  char *v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  const char *v13;
  unsigned __int8 v14;
  const char *v15;

  v3 = a3;
  v4 = a2;
  if (a2 < 0)
  {
    v4 = *((_DWORD *)this + 59) != 0;
    if ((a3 & 0x80000000) == 0)
      goto LABEL_3;
  }
  else if ((a3 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  v3 = *((_DWORD *)this + 59) != 0;
LABEL_3:
  v6 = *((_DWORD *)this + 62);
  if (v4)
    v7 = 9729;
  else
    v7 = 9728;
  glTexParameteri(v6, 0x2800u, v7);
  if (v3)
    v8 = 9729;
  else
    v8 = 9728;
  glTexParameteri(*((_DWORD *)this + 62), 0x2801u, v8);
  v11 = atomic_load(HGLogger::_enabled);
  if ((v11 & 1) == 0)
  {
    v12 = atomic_load(HGLogger::_enabled);
    if ((v12 & 1) == 0)
      return;
    goto LABEL_15;
  }
  v13 = "linear";
  if (!v4)
    v13 = "nearest";
  HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"min filter: %s\n", v9, v10, v13);
  v14 = atomic_load(HGLogger::_enabled);
  if ((v14 & 1) != 0)
  {
LABEL_15:
    v15 = "linear";
    if (!v3)
      v15 = "nearest";
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"mag filter: %s\n", v9, v10, v15);
  }
}

uint64_t HGGLHandler::ActiveTexture(HGGLHandler *this, int a2, int a3)
{
  uint64_t v5;
  const char *v6;
  char *v7;
  unsigned __int8 v8;
  unsigned __int8 v9;

  v5 = (*((_DWORD *)this + 40) + a2);
  glActiveTexture(v5 + 33984);
  v8 = atomic_load(HGLogger::_enabled);
  if ((v8 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"active texture: %d\n", v6, v7, v5);
  if (a3)
  {
    v9 = atomic_load(HGLogger::_enabled);
    if ((v9 & 1) != 0)
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"physical translate: { %d, %d, %lf }\n", v6, v7, *((unsigned int *)this + 60), *((unsigned int *)this + 61), 0);
  }
  return v5;
}

uint64_t HGGLHandler::ActiveTextureMatrix(HGGLHandler *this, uint64_t a2)
{
  return (*(uint64_t (**)(HGGLHandler *, uint64_t, _QWORD))(*(_QWORD *)this + 72))(this, a2, 0);
}

void HGGLHandler::LoadIdentity(HGGLHandler *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v5;

  v5 = atomic_load(HGLogger::_enabled);
  if ((v5 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"load identity\n", a4, a5);
}

void HGGLHandler::Translate(HGGLHandler *this, double a2, double a3, double a4, uint64_t a5, uint64_t a6, const char *a7, char *a8)
{
  unsigned __int8 v8;

  v8 = atomic_load(HGLogger::_enabled);
  if ((v8 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"translate: { %lf, %lf, %lf }\n", a7, a8, *(_QWORD *)&a2, *(_QWORD *)&a3, *(_QWORD *)&a4);
}

void HGGLHandler::Scale(HGGLHandler *this, double a2, double a3, double a4, uint64_t a5, uint64_t a6, const char *a7, char *a8)
{
  unsigned __int8 v8;

  v8 = atomic_load(HGLogger::_enabled);
  if ((v8 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"scale: { %lf, %lf, %lf }\n", a7, a8, *(_QWORD *)&a2, *(_QWORD *)&a3, *(_QWORD *)&a4);
}

void HGGLHandler::MultMatrix(HGGLHandler *this, const double *a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  unsigned __int8 v12;

  v6 = atomic_load(HGLogger::_enabled);
  if ((v6 & 1) != 0)
  {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"mult: { { %lf, %lf, %lf, %lf}, \n", a4, a5, *(_QWORD *)a2, *((_QWORD *)a2 + 1), *((_QWORD *)a2 + 2), *((_QWORD *)a2 + 3));
    v10 = atomic_load(HGLogger::_enabled);
    if ((v10 & 1) == 0)
    {
LABEL_3:
      v8 = atomic_load(HGLogger::_enabled);
      if ((v8 & 1) == 0)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else
  {
    v7 = atomic_load(HGLogger::_enabled);
    if ((v7 & 1) == 0)
      goto LABEL_3;
  }
  HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"        { %lf, %lf, %lf, %lf}, \n", a4, a5, *((_QWORD *)a2 + 4), *((_QWORD *)a2 + 5), *((_QWORD *)a2 + 6), *((_QWORD *)a2 + 7));
  v11 = atomic_load(HGLogger::_enabled);
  if ((v11 & 1) == 0)
  {
LABEL_4:
    v9 = atomic_load(HGLogger::_enabled);
    if ((v9 & 1) == 0)
      return;
LABEL_9:
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"        { %lf, %lf, %lf, %lf} }\n", a4, a5, *((_QWORD *)a2 + 12), *((_QWORD *)a2 + 13), *((_QWORD *)a2 + 14), *((_QWORD *)a2 + 15));
    return;
  }
LABEL_8:
  HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"        { %lf, %lf, %lf, %lf}, \n", a4, a5, *((_QWORD *)a2 + 8), *((_QWORD *)a2 + 9), *((_QWORD *)a2 + 10), *((_QWORD *)a2 + 11));
  v12 = atomic_load(HGLogger::_enabled);
  if ((v12 & 1) != 0)
    goto LABEL_9;
}

void HGGLHandler::MultMatrix(HGGLHandler *this, const float *a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  unsigned __int8 v12;

  v6 = atomic_load(HGLogger::_enabled);
  if ((v6 & 1) != 0)
  {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"mult: { { %lf, %lf, %lf, %lf}, \n", a4, a5, *a2, a2[1], a2[2], a2[3]);
    v10 = atomic_load(HGLogger::_enabled);
    if ((v10 & 1) == 0)
    {
LABEL_3:
      v8 = atomic_load(HGLogger::_enabled);
      if ((v8 & 1) == 0)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else
  {
    v7 = atomic_load(HGLogger::_enabled);
    if ((v7 & 1) == 0)
      goto LABEL_3;
  }
  HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"        { %lf, %lf, %lf, %lf}, \n", a4, a5, a2[4], a2[5], a2[6], a2[7]);
  v11 = atomic_load(HGLogger::_enabled);
  if ((v11 & 1) == 0)
  {
LABEL_4:
    v9 = atomic_load(HGLogger::_enabled);
    if ((v9 & 1) == 0)
      return;
LABEL_9:
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"        { %lf, %lf, %lf, %lf} }\n", a4, a5, a2[12], a2[13], a2[14], a2[15]);
    return;
  }
LABEL_8:
  HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"        { %lf, %lf, %lf, %lf}, \n", a4, a5, a2[8], a2[9], a2[10], a2[11]);
  v12 = atomic_load(HGLogger::_enabled);
  if ((v12 & 1) != 0)
    goto LABEL_9;
}

void HGGLSLHandler::~HGGLSLHandler(OZChannelBase *this, const PCString *a2)
{
  OZChannelBase::setRangeName(this, a2);
  JUMPOUT(0x1B5E29170);
}

HGGLSLHandler *HGGLSLHandler::Reset(HGGLSLHandler *this, HGRenderer *a2, int a3)
{
  uint64_t **GLState;
  int UniformLocation;
  int v8;
  HGGPURenderer *v9;
  uint64_t ProjectionMatrix;
  int v12;
  const float *v13;
  const char *v14;
  char *v15;
  unsigned __int8 v16;

  HGHandler::Reset((uint64_t)this, (uint64_t)a2);
  *((_DWORD *)this + 63) = a3;
  *((_QWORD *)this + 96) = 0;
  GLState = (uint64_t **)HGGPURenderer::GetGLState(a2);
  UniformLocation = HGGLState::getUniformLocation(GLState, *((unsigned int *)this + 63), 0, 0);
  *((_DWORD *)this + 194) = UniformLocation;
  if (a2)
  {
    v8 = UniformLocation;
    if (v8 != -1 && v9 != 0)
    {
      ProjectionMatrix = HGGPURenderer::GetProjectionMatrix(v9);
      (*(void (**)(uint64_t, char *))(*(_QWORD *)ProjectionMatrix + 40))(ProjectionMatrix, (char *)this + 780);
      glUniformMatrix4fv(*((_DWORD *)this + 194), 1, 0, (const GLfloat *)this + 195);
      v16 = atomic_load(HGLogger::_enabled);
      if ((v16 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (projection) :\n", v14, v15, *((unsigned int *)this + 194));
      log_matrix((float *)this + 195, v12, v13, v14, v15);
    }
  }
  *((_OWORD *)this + 16) = xmmword_1B304F230;
  *((_OWORD *)this + 17) = xmmword_1B304F240;
  *((_OWORD *)this + 18) = xmmword_1B304F250;
  *((_OWORD *)this + 19) = xmmword_1B304EFF0;
  *((_OWORD *)this + 20) = xmmword_1B304F230;
  *((_OWORD *)this + 21) = xmmword_1B304F240;
  *((_OWORD *)this + 22) = xmmword_1B304F250;
  *((_OWORD *)this + 23) = xmmword_1B304EFF0;
  *((_OWORD *)this + 24) = xmmword_1B304F230;
  *((_OWORD *)this + 25) = xmmword_1B304F240;
  *((_OWORD *)this + 26) = xmmword_1B304F250;
  *((_OWORD *)this + 27) = xmmword_1B304EFF0;
  *((_OWORD *)this + 28) = xmmword_1B304F230;
  *((_OWORD *)this + 29) = xmmword_1B304F240;
  *((_OWORD *)this + 30) = xmmword_1B304F250;
  *((_OWORD *)this + 31) = xmmword_1B304EFF0;
  *((_OWORD *)this + 32) = xmmword_1B304F230;
  *((_OWORD *)this + 33) = xmmword_1B304F240;
  *((_OWORD *)this + 34) = xmmword_1B304F250;
  *((_OWORD *)this + 35) = xmmword_1B304EFF0;
  *((_OWORD *)this + 36) = xmmword_1B304F230;
  *((_OWORD *)this + 37) = xmmword_1B304F240;
  *((_OWORD *)this + 38) = xmmword_1B304F250;
  *((_OWORD *)this + 39) = xmmword_1B304EFF0;
  *((_OWORD *)this + 40) = xmmword_1B304F230;
  *((_OWORD *)this + 41) = xmmword_1B304F240;
  *((_OWORD *)this + 42) = xmmword_1B304F250;
  *((_OWORD *)this + 43) = xmmword_1B304EFF0;
  *((_OWORD *)this + 44) = xmmword_1B304F230;
  *((_OWORD *)this + 45) = xmmword_1B304F240;
  *((_OWORD *)this + 46) = xmmword_1B304F250;
  *((_OWORD *)this + 47) = xmmword_1B304EFF0;
  return this;
}

void log_matrix(float *a1, int a2, const float *a3, const char *a4, char *a5)
{
  unsigned __int8 v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  unsigned __int8 v12;

  v6 = atomic_load(HGLogger::_enabled);
  if ((v6 & 1) != 0)
  {
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)" { { %lf, %lf, %lf, %lf}, \n", a4, a5, *a1, a1[1], a1[2], a1[3]);
    v10 = atomic_load(HGLogger::_enabled);
    if ((v10 & 1) == 0)
    {
LABEL_3:
      v8 = atomic_load(HGLogger::_enabled);
      if ((v8 & 1) == 0)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else
  {
    v7 = atomic_load(HGLogger::_enabled);
    if ((v7 & 1) == 0)
      goto LABEL_3;
  }
  HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"   { %lf, %lf, %lf, %lf}, \n", a4, a5, a1[4], a1[5], a1[6], a1[7]);
  v11 = atomic_load(HGLogger::_enabled);
  if ((v11 & 1) == 0)
  {
LABEL_4:
    v9 = atomic_load(HGLogger::_enabled);
    if ((v9 & 1) == 0)
      return;
LABEL_9:
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"   { %lf, %lf, %lf, %lf} }\n", a4, a5, a1[12], a1[13], a1[14], a1[15]);
    return;
  }
LABEL_8:
  HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"   { %lf, %lf, %lf, %lf}, \n", a4, a5, a1[8], a1[9], a1[10], a1[11]);
  v12 = atomic_load(HGLogger::_enabled);
  if ((v12 & 1) != 0)
    goto LABEL_9;
}

void HGGLSLHandler::LoadModelViewMatrix(float32x2_t *this, const simd::float4x4 *a2)
{
  float32x4_t *v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  int v10;
  const float *v11;
  const char *v12;
  char *v13;
  unsigned __int8 v14;
  GLfloat value[4];
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = (float32x4_t *)((char *)&this[97] + 4);
  HGHandler::LoadModelViewMatrix((HGHandler *)this, a2);
  v4 = v3[1];
  v5 = v3[2];
  v6 = v3[3];
  v7 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v3, COERCE_FLOAT(*(_OWORD *)this[4].f32)), v4, this[4], 1), v5, *(float32x4_t *)this[4].f32, 2), v6, *(float32x4_t *)this[4].f32, 3);
  v8 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v3, COERCE_FLOAT(*(_OWORD *)this[6].f32)), v4, this[6], 1), v5, *(float32x4_t *)this[6].f32, 2), v6, *(float32x4_t *)this[6].f32, 3);
  v9 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v3, COERCE_FLOAT(*(_OWORD *)this[8].f32)), v4, this[8], 1), v5, *(float32x4_t *)this[8].f32, 2), v6, *(float32x4_t *)this[8].f32, 3);
  *(float32x4_t *)value = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v3, COERCE_FLOAT(*(_OWORD *)this[2].f32)), v4, this[2], 1), v5, *(float32x4_t *)this[2].f32, 2), v6, *(float32x4_t *)this[2].f32, 3);
  v16 = v7;
  v17 = v8;
  v18 = v9;
  glUniformMatrix4fv(this[97].i32[0], 1, 0, value);
  v14 = atomic_load(HGLogger::_enabled);
  if ((v14 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (model-view-projection) :\n", v12, v13, this[97].u32[0]);
  log_matrix(value, v10, v11, v12, v13);
}

const char *HGGLSLHandler::LoadProjectionMatrix(HGGLSLHandler *this, const simd::float4x4 *a2, char *a3)
{
  return HGLogger::error((HGLogger *)"Projection matrix loading not supported in OpenGL", (const char *)a2, a3);
}

void HGGLSLHandler::Commit(HGGLSLHandler *this)
{
  uint64_t **GLState;
  uint64_t **v3;
  uint64_t UniformLocation;
  uint64_t v5;
  int v6;
  const float *v7;
  const char *v8;
  char *v9;
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  const float *v14;
  const char *v15;
  char *v16;
  unsigned __int8 v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  const float *v21;
  const char *v22;
  char *v23;
  unsigned __int8 v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  const float *v28;
  const char *v29;
  char *v30;
  unsigned __int8 v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  const float *v35;
  const char *v36;
  char *v37;
  unsigned __int8 v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  const float *v42;
  const char *v43;
  char *v44;
  unsigned __int8 v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  const float *v49;
  const char *v50;
  char *v51;
  unsigned __int8 v52;
  uint64_t v53;
  uint64_t v54;
  GLfloat *v55;
  int v56;
  const float *v57;
  const char *v58;
  char *v59;
  unsigned __int8 v60;

  GLState = (uint64_t **)HGGPURenderer::GetGLState(*((HGGPURenderer **)this + 18));
  v3 = GLState;
  if ((*((_BYTE *)this + 772) & 1) != 0)
  {
    UniformLocation = HGGLState::getUniformLocation(GLState, *((unsigned int *)this + 63), 1, 0);
    if ((_DWORD)UniformLocation != -1)
    {
      v5 = UniformLocation;
      glUniformMatrix4fv(UniformLocation, 1, 0, (const GLfloat *)this + 64);
      v10 = atomic_load(HGLogger::_enabled);
      if ((v10 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v8, v9, v5);
      log_matrix((float *)this + 64, v6, v7, v8, v9);
    }
  }
  if ((*((_BYTE *)this + 772) & 2) != 0)
  {
    v11 = HGGLState::getUniformLocation(v3, *((unsigned int *)this + 63), 1, 1);
    if ((_DWORD)v11 != -1)
    {
      v12 = v11;
      glUniformMatrix4fv(v11, 1, 0, (const GLfloat *)this + 80);
      v17 = atomic_load(HGLogger::_enabled);
      if ((v17 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v15, v16, v12);
      log_matrix((float *)this + 80, v13, v14, v15, v16);
    }
  }
  if ((*((_BYTE *)this + 772) & 4) != 0)
  {
    v18 = HGGLState::getUniformLocation(v3, *((unsigned int *)this + 63), 1, 2);
    if ((_DWORD)v18 != -1)
    {
      v19 = v18;
      glUniformMatrix4fv(v18, 1, 0, (const GLfloat *)this + 96);
      v24 = atomic_load(HGLogger::_enabled);
      if ((v24 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v22, v23, v19);
      log_matrix((float *)this + 96, v20, v21, v22, v23);
    }
  }
  if ((*((_BYTE *)this + 772) & 8) != 0)
  {
    v25 = HGGLState::getUniformLocation(v3, *((unsigned int *)this + 63), 1, 3);
    if ((_DWORD)v25 != -1)
    {
      v26 = v25;
      glUniformMatrix4fv(v25, 1, 0, (const GLfloat *)this + 112);
      v31 = atomic_load(HGLogger::_enabled);
      if ((v31 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v29, v30, v26);
      log_matrix((float *)this + 112, v27, v28, v29, v30);
    }
  }
  if ((*((_BYTE *)this + 772) & 0x10) != 0)
  {
    v32 = HGGLState::getUniformLocation(v3, *((unsigned int *)this + 63), 1, 4);
    if ((_DWORD)v32 != -1)
    {
      v33 = v32;
      glUniformMatrix4fv(v32, 1, 0, (const GLfloat *)this + 128);
      v38 = atomic_load(HGLogger::_enabled);
      if ((v38 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v36, v37, v33);
      log_matrix((float *)this + 128, v34, v35, v36, v37);
    }
  }
  if ((*((_BYTE *)this + 772) & 0x20) != 0)
  {
    v39 = HGGLState::getUniformLocation(v3, *((unsigned int *)this + 63), 1, 5);
    if ((_DWORD)v39 != -1)
    {
      v40 = v39;
      glUniformMatrix4fv(v39, 1, 0, (const GLfloat *)this + 144);
      v45 = atomic_load(HGLogger::_enabled);
      if ((v45 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v43, v44, v40);
      log_matrix((float *)this + 144, v41, v42, v43, v44);
    }
  }
  if ((*((_BYTE *)this + 772) & 0x40) != 0)
  {
    v46 = HGGLState::getUniformLocation(v3, *((unsigned int *)this + 63), 1, 6);
    if ((_DWORD)v46 != -1)
    {
      v47 = v46;
      glUniformMatrix4fv(v46, 1, 0, (const GLfloat *)this + 160);
      v52 = atomic_load(HGLogger::_enabled);
      if ((v52 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v50, v51, v47);
      log_matrix((float *)this + 160, v48, v49, v50, v51);
    }
  }
  if ((*((_BYTE *)this + 772) & 0x80) != 0)
  {
    v53 = HGGLState::getUniformLocation(v3, *((unsigned int *)this + 63), 1, 7);
    if ((_DWORD)v53 != -1)
    {
      v54 = v53;
      v55 = (GLfloat *)((char *)this + 704);
      glUniformMatrix4fv(v53, 1, 0, v55);
      v60 = atomic_load(HGLogger::_enabled);
      if ((v60 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v58, v59, v54);
      log_matrix(v55, v56, v57, v58, v59);
    }
  }
}

uint64_t HGGLSLHandler::ActiveTexture(int32x2_t *this, int a2, int a3)
{
  uint64_t v5;
  __int128 v6;

  v5 = (this[20].i32[0] + a2);
  this[96].i32[0] = v5;
  glActiveTexture(v5 + 33984);
  if (a3)
  {
    *(float32x2_t *)&v6 = vcvt_f32_s32(this[30]);
    *((_QWORD *)&v6 + 1) = 0x3F80000000000000;
    *(_OWORD *)this[8 * (unint64_t)this[96].u32[0] + 38].i8 = v6;
  }
  return v5;
}

uint64_t HGGLSLHandler::ActiveTextureMatrix(HGGLSLHandler *this, uint64_t a2)
{
  return (*(uint64_t (**)(HGGLSLHandler *, uint64_t, _QWORD))(*(_QWORD *)this + 72))(this, a2, 0);
}

double HGGLSLHandler::LoadIdentity(HGGLSLHandler *this)
{
  uint64_t v1;
  _OWORD *v2;
  double result;

  *((_OWORD *)this + 4 * (unint64_t)*((unsigned int *)this + 192) + 16) = xmmword_1B304F230;
  v1 = *((unsigned int *)this + 192);
  v2 = (_OWORD *)((char *)this + 64 * v1 + 256);
  v2[1] = xmmword_1B304F240;
  v2[2] = xmmword_1B304F250;
  result = 0.0;
  v2[3] = xmmword_1B304EFF0;
  *((_DWORD *)this + 193) |= 1 << v1;
  return result;
}

float32x4_t HGGLSLHandler::Translate(HGGLSLHandler *this, double a2, double a3, double a4)
{
  uint64_t v4;
  float32x4_t *v5;
  float v6;
  float v7;
  float v8;
  float32x4_t result;

  v4 = *((unsigned int *)this + 192);
  v5 = (float32x4_t *)((char *)this + 64 * v4);
  v6 = a2;
  v7 = a3;
  v8 = a4;
  result = vaddq_f32(vaddq_f32(vmulq_n_f32(v5[16], v6), vmulq_n_f32(v5[17], v7)), vaddq_f32(vmulq_n_f32(v5[18], v8), v5[19]));
  v5[19] = result;
  *((_DWORD *)this + 193) |= 1 << v4;
  return result;
}

float32x4_t HGGLSLHandler::Scale(HGGLSLHandler *this, double a2, double a3, double a4)
{
  float32x4_t *v4;
  float v5;
  float32x4_t result;
  float v7;
  float v8;
  float32x4_t v9;
  float32x4_t v10;

  v4 = (float32x4_t *)((char *)this + 64 * (unint64_t)*((unsigned int *)this + 192));
  v5 = a2;
  result = vmulq_n_f32(v4[16], v5);
  v7 = a3;
  v8 = a4;
  v9 = vmulq_n_f32(v4[17], v7);
  v10 = vmulq_n_f32(v4[18], v8);
  v4[16] = result;
  v4[17] = v9;
  v4[18] = v10;
  *((_DWORD *)this + 193) |= 1 << *((_DWORD *)this + 192);
  return result;
}

float32x4_t HGGLSLHandler::MultMatrix(HGGLSLHandler *this, const double *a2)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float32x4_t *v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t result;

  v2 = *a2;
  v3 = a2[1];
  v4 = a2[2];
  v5 = a2[3];
  v6 = a2[4];
  v7 = a2[5];
  v8 = a2[6];
  v9 = a2[7];
  v10 = a2[8];
  v11 = a2[9];
  v12 = a2[10];
  v13 = a2[11];
  v14 = a2[12];
  v15 = a2[13];
  v16 = a2[14];
  v17 = a2[15];
  v18 = (float32x4_t *)((char *)this + 64 * (unint64_t)*((unsigned int *)this + 192));
  v19 = v18[16];
  v20 = v18[17];
  v21 = vaddq_f32(vmulq_n_f32(v19, v2), vmulq_n_f32(v20, v3));
  v22 = v18[18];
  v23 = v18[19];
  result = vaddq_f32(v21, vaddq_f32(vmulq_n_f32(v22, v4), vmulq_n_f32(v23, v5)));
  v18[16] = result;
  v18[17] = vaddq_f32(vaddq_f32(vmulq_n_f32(v19, v6), vmulq_n_f32(v20, v7)), vaddq_f32(vmulq_n_f32(v22, v8), vmulq_n_f32(v23, v9)));
  v18[18] = vaddq_f32(vaddq_f32(vmulq_n_f32(v19, v10), vmulq_n_f32(v20, v11)), vaddq_f32(vmulq_n_f32(v22, v12), vmulq_n_f32(v23, v13)));
  v18[19] = vaddq_f32(vaddq_f32(vmulq_n_f32(v19, v14), vmulq_n_f32(v20, v15)), vaddq_f32(vmulq_n_f32(v22, v16), vmulq_n_f32(v23, v17)));
  *((_DWORD *)this + 193) |= 1 << *((_DWORD *)this + 192);
  return result;
}

float32x4_t HGGLSLHandler::MultMatrix(HGGLSLHandler *this, const float *a2)
{
  float32x4_t *v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t result;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;

  v2 = (float32x4_t *)((char *)this + 64 * (unint64_t)*((unsigned int *)this + 192));
  v3 = v2[16];
  v4 = v2[17];
  v5 = v2[18];
  v6 = v2[19];
  result = vaddq_f32(vaddq_f32(vmulq_n_f32(v3, COERCE_FLOAT(*(_OWORD *)a2)), vmulq_lane_f32(v4, *(float32x2_t *)a2, 1)), vaddq_f32(vmulq_laneq_f32(v5, *(float32x4_t *)a2, 2), vmulq_laneq_f32(v6, *(float32x4_t *)a2, 3)));
  v8 = vaddq_f32(vaddq_f32(vmulq_n_f32(v3, COERCE_FLOAT(*((_OWORD *)a2 + 1))), vmulq_lane_f32(v4, *(float32x2_t *)(a2 + 4), 1)), vaddq_f32(vmulq_laneq_f32(v5, *(float32x4_t *)(a2 + 4), 2), vmulq_laneq_f32(v6, *(float32x4_t *)(a2 + 4), 3)));
  v9 = vaddq_f32(vaddq_f32(vmulq_n_f32(v3, COERCE_FLOAT(*((_OWORD *)a2 + 2))), vmulq_lane_f32(v4, *(float32x2_t *)(a2 + 8), 1)), vaddq_f32(vmulq_laneq_f32(v5, *(float32x4_t *)(a2 + 8), 2), vmulq_laneq_f32(v6, *(float32x4_t *)(a2 + 8), 3)));
  v10 = vaddq_f32(vaddq_f32(vmulq_n_f32(v3, COERCE_FLOAT(*((_OWORD *)a2 + 3))), vmulq_lane_f32(v4, *(float32x2_t *)(a2 + 12), 1)), vaddq_f32(vmulq_laneq_f32(v5, *(float32x4_t *)(a2 + 12), 2), vmulq_laneq_f32(v6, *(float32x4_t *)(a2 + 12), 3)));
  v2[16] = result;
  v2[17] = v8;
  v2[18] = v9;
  v2[19] = v10;
  *((_DWORD *)this + 193) |= 1 << *((_DWORD *)this + 192);
  return result;
}

float32x4_t HGGLSLHandler::Normalize(HGGLSLHandler *this)
{
  float32x4_t v6;
  float32x4_t *v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t result;

  __asm { FMOV            V1.2S, #1.0 }
  *(float32x2_t *)v6.f32 = vdiv_f32(_D1, vcvt_f32_u32((uint32x2_t)vsub_s32(*(int32x2_t *)((char *)this + 228), *(int32x2_t *)((char *)this + 220))));
  *(float32x2_t *)&v6.u32[2] = _D1;
  v7 = (float32x4_t *)((char *)this + 64 * (unint64_t)*((unsigned int *)this + 192));
  v8 = vmulq_f32(v7[16], v6);
  v9 = vmulq_f32(v7[17], v6);
  v10 = vmulq_f32(v7[18], v6);
  result = vmulq_f32(v6, v7[19]);
  v7[16] = v8;
  v7[17] = v9;
  v7[18] = v10;
  v7[19] = result;
  *((_DWORD *)this + 193) |= 1 << *((_DWORD *)this + 192);
  return result;
}

void HGGLSLHandler::Rect(HGGLSLHandler *this, HGRect a2, int a3)
{
  GLuint v4;
  GLuint v5;
  float ptr[8];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  ptr[0] = (float)a2.var0;
  ptr[1] = (float)a2.var1;
  ptr[2] = (float)a2.var2;
  ptr[3] = (float)a2.var1;
  ptr[4] = (float)a2.var0;
  ptr[5] = (float)a2.var3;
  ptr[6] = (float)a2.var2;
  ptr[7] = (float)a2.var3;
  if (a3 < 1)
  {
    glVertexAttribPointer(0, 2, 0x1406u, 0, 0, ptr);
    glEnableVertexAttribArray(0);
    glDrawArrays(5u, 0, 4);
  }
  else
  {
    v4 = a3 + 7;
    do
    {
      glVertexAttribPointer(v4, 2, 0x1406u, 0, 0, ptr);
      glEnableVertexAttribArray(v4--);
    }
    while (v4 != 7);
    glVertexAttribPointer(0, 2, 0x1406u, 0, 0, ptr);
    glEnableVertexAttribArray(0);
    glDrawArrays(5u, 0, 4);
    v5 = a3 + 7;
    do
    {
      glVertexAttribPointer(v5, 2, 0x1406u, 0, 0, 0);
      glDisableVertexAttribArray(v5--);
    }
    while (v5 != 7);
  }
  glVertexAttribPointer(0, 2, 0x1406u, 0, 0, 0);
  glDisableVertexAttribArray(0);
}

uint64_t HGGLSLHandler::LocalParameter(HGGLSLHandler *this, int a2, GLfloat a3, GLfloat a4, GLfloat a5, GLfloat a6)
{
  uint64_t v11;
  uint64_t **GLState;
  GLint UniformLocation;
  const char *v14;
  char *v15;
  unsigned __int8 v16;

  v11 = (*((_DWORD *)this + 42) + a2);
  GLState = (uint64_t **)HGGPURenderer::GetGLState(*((HGGPURenderer **)this + 18));
  UniformLocation = HGGLState::getUniformLocation(GLState, *((unsigned int *)this + 63), 2, v11);
  if (UniformLocation != -1)
  {
    glUniform4f(UniformLocation, a3, a4, a5, a6);
    v16 = atomic_load(HGLogger::_enabled);
    if ((v16 & 1) != 0)
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"program_local(%d): { %f, %f, %f, %f }\n", v14, v15, v11, a3, a4, a5, a6);
  }
  return v11;
}

uint64_t HGGLSLHandler::LocalParameters(HGGLSLHandler *this, uint64_t a2, float *a3, int a4)
{
  int v5;
  uint64_t v8;

  if (a4 >= 1)
  {
    v5 = a4;
    v8 = a2;
    do
    {
      (*(void (**)(HGGLSLHandler *, uint64_t, float, float, float, float))(*(_QWORD *)this + 136))(this, v8, *a3, a3[1], a3[2], a3[3]);
      v8 = (v8 + 1);
      a3 += 4;
      --v5;
    }
    while (v5);
  }
  return a2;
}

uint64_t HGGLSLHandler::LocalParametersBuffer(HGGLSLHandler *this, void *a2, unint64_t a3, unint64_t a4)
{
  return (*(uint64_t (**)(HGGLSLHandler *, unint64_t, void *, unint64_t))(*(_QWORD *)this + 144))(this, a4 >> 4, a2, a3 >> 4);
}

void HGGLSLHandler::UnBind(HGGLSLHandler *this)
{
  glUseProgram(0);
}

void HFDenseCRF::HFDenseCRF(HFDenseCRF *this, const __CFUUID *a2)
{
  *(_QWORD *)this = &off_1E65239F0;
}

void HFDenseCRF::~HFDenseCRF(HFDenseCRF *this)
{
  *(_QWORD *)this = &off_1E65239F0;
}

{
  *(_QWORD *)this = &off_1E65239F0;
  JUMPOUT(0x1B5E29170);
}

uint64_t HFDenseCRF::GenerateMask(HFDenseCRF *this, HGBitmap *a2, HGBitmap *a3, HGBitmap *a4, float a5, float a6, float a7, float a8, float a9, float a10, uint64_t a11)
{
  unint64_t v11;
  int v14;
  int v15;
  unsigned int v16;
  const char *v17;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  const float *v23;
  uint64_t v24;
  const float *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v33;
  const float *v34;
  const float *v35;
  float *v36;
  const float *v37;
  uint64_t v38;
  float v39;
  float v40;
  uint64_t v41;
  uint64_t v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float *v47;
  unint64_t v48;
  unint64_t v49;
  BOOL v51;
  BOOL v53;
  BOOL v54;
  uint64_t v55;
  const float *v56;
  const float *v57;
  const float *v58;
  float *v59;
  float32x4_t v60;
  float v61;
  float32x4_t v62;
  float v63;
  float32x4_t v64;
  float32x4_t v65;
  float v66;
  float32x4_t v67;
  float v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  const float *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  float *v78;
  float *v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  float *v95;
  float *v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  uint64_t v104;
  const float *v106;
  float *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v111;
  const float *v112;
  float *v113;
  float32x4_t v114;
  float v115;
  float32x4_t v116;
  float v117;
  float32x4_t v118;
  float32x4_t v119;
  float v120;
  float32x4_t v121;
  float v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  float v129;
  float v130;
  float v131;
  float *v132;
  uint64_t v133;
  const float *v134;
  int8x16_t *v135;
  uint64_t v137;
  uint64_t v138;
  uint64_t v140;
  int8x16_t *v141;
  const float *v142;
  const float *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  float *v147;
  float v148;
  unint64_t v150;
  _QWORD *v151;
  int v152;
  int v153;
  unint64_t v154;
  _QWORD *v155;
  int v156;
  int v157;
  _QWORD *v158;
  uint64_t v160;
  const float *v161;
  uint64_t v162;
  const float *v163;
  uint64_t v164;
  uint64_t v165;
  float *v166;
  const float *v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  const float *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  unint64_t v176;
  unint64_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v186;
  float32x4_t v189;
  float32x4_t v190;
  float32x4_t v191;
  float v192;
  float32x4_t v193;
  float32x4_t v194;
  float32x4_t v195;
  float v196;
  float32x4_t v197;
  float32x4_t v198;
  float32x4_t v199;
  float32x4x2_t v200;
  float32x4x2_t v201;
  float32x4x2_t v202;
  float32x4x2_t v203;
  float32x4x2_t v204;
  float32x4x2_t v205;
  float32x4x2_t v206;
  float32x4x2_t v207;

  v11 = (*((_DWORD *)a2 + 7) - *((_DWORD *)a2 + 5));
  if ((_DWORD)v11 != *((_DWORD *)a3 + 7) - *((_DWORD *)a3 + 5)
    || (v14 = *((_DWORD *)a2 + 8), v15 = *((_DWORD *)a2 + 6), v14 - v15 != *((_DWORD *)a3 + 8) - *((_DWORD *)a3 + 6))
    || (_DWORD)v11 != *((_DWORD *)a4 + 7) - *((_DWORD *)a4 + 5)
    || v14 - v15 != *((_DWORD *)a4 + 8) - *((_DWORD *)a4 + 6))
  {
    v17 = "Error: inputs to CRF must be the same size";
LABEL_22:
    puts(v17);
    return 1;
  }
  if (*((_DWORD *)a2 + 4) != 21)
  {
    v17 = "Error: image buffer for CRF must have 3 channels of 32-floats";
    goto LABEL_22;
  }
  v16 = *((_DWORD *)a3 + 4);
  v17 = "Error: probability buffer for CRF must have up to 3 channels of 32-floats";
  if (v16 > 0x15 || ((1 << v16) & 0x202080) == 0)
    goto LABEL_22;
  if (*((_DWORD *)a4 + 4) != 7)
  {
    v17 = "Error: matte buffer for CRF must have 1 channel of 32-floats";
    goto LABEL_22;
  }
  v156 = *((_DWORD *)a2 + 5);
  v157 = *((_DWORD *)a2 + 7);
  v150 = (v14 - v15);
  v158 = HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v158, *(_QWORD *)((char *)a2 + 20), *(_QWORD *)((char *)a2 + 28), 13);
  v152 = v15;
  v153 = v14;
  v154 = v11;
  if (v14 != v15 && v157 != v156)
  {
    v72 = (const float *)*((_QWORD *)a3 + 10);
    v73 = *((_QWORD *)a3 + 8);
    v74 = v158[10];
    v75 = v158[8];
    if (v11 <= 1)
      v76 = 1;
    else
      v76 = v11;
    if (v150 <= 1)
      v77 = 1;
    else
      v77 = (v14 - v15);
    if (v76 < 4)
    {
      v78 = (float *)(v72 + 3);
      v79 = (float *)(v74 + 12);
      do
      {
        v80 = expf(-*(v78 - 3));
        v81 = expf(-*(v78 - 2));
        v82 = 1.0 / (float)(v80 + v81);
        *(v79 - 3) = v80 * v82;
        *(v79 - 2) = v81 * v82;
        if (v11 >= 2)
        {
          v83 = expf(-*(v78 - 1));
          v84 = expf(-*v78);
          v85 = 1.0 / (float)(v83 + v84);
          *(v79 - 1) = v83 * v85;
          *v79 = v84 * v85;
          if (v76 != 2)
          {
            v86 = expf(-v78[1]);
            v87 = expf(-v78[2]);
            v88 = 1.0 / (float)(v86 + v87);
            v79[1] = v86 * v88;
            v79[2] = v87 * v88;
          }
        }
        v78 = (float *)((char *)v78 + v73);
        v79 = (float *)((char *)v79 + v75);
        --v77;
      }
      while (v77);
      goto LABEL_11;
    }
    v104 = 0;
    v169 = 2 * v76;
    v171 = (const float *)*((_QWORD *)a3 + 10);
    v175 = v76 & 0xFFFFFFFC;
    v177 = v76;
    __asm { FMOV            V0.4S, #1.0 }
    v106 = v171;
    v107 = (float *)v158[10];
    v179 = _Q0;
    v173 = *((_QWORD *)a3 + 8);
    do
    {
      v108 = v75;
      v109 = v74;
      if (v74 + v75 * v104 >= (unint64_t)&v72[v169] + v73 * v104
        || (unint64_t)v72 + v73 * v104 >= v74 + v169 * 4 + v75 * v104)
      {
        v111 = v175;
        v112 = v106;
        v113 = v107;
        do
        {
          v201 = vld2q_f32(v112);
          v112 += 8;
          v186 = v201.val[1];
          v190 = vnegq_f32(v201.val[0]);
          v196 = expf(v190.f32[1]);
          v114.f32[0] = expf(v190.f32[0]);
          v114.f32[1] = v196;
          v197 = v114;
          v115 = expf(v190.f32[2]);
          v116 = v197;
          v116.f32[2] = v115;
          v198 = v116;
          v117 = expf(v190.f32[3]);
          v118 = v198;
          v118.f32[3] = v117;
          v199 = v118;
          v191 = vnegq_f32(v186);
          v183 = expf(v191.f32[1]);
          v119.f32[0] = expf(v191.f32[0]);
          v119.f32[1] = v183;
          v184 = v119;
          v120 = expf(v191.f32[2]);
          v121 = v184;
          v121.f32[2] = v120;
          v185 = v121;
          v122 = expf(v191.f32[3]);
          v123 = v185;
          v123.f32[3] = v122;
          v124 = v123;
          v125 = vdivq_f32(v179, vaddq_f32(v199, v123));
          v203.val[0] = vmulq_f32(v199, v125);
          v203.val[1] = vmulq_f32(v124, v125);
          vst2q_f32(v113, v203);
          v113 += 8;
          v111 -= 4;
        }
        while (v111);
        v126 = v175;
        if (v177 == v175)
          goto LABEL_115;
      }
      else
      {
        v126 = 0;
      }
      v127 = v177 - v126;
      v128 = (8 * v126) | 4;
      do
      {
        v129 = expf(-*(const float *)((char *)v106 + v128 - 4));
        v130 = expf(-*(const float *)((char *)v106 + v128));
        v131 = 1.0 / (float)(v129 + v130);
        v132 = (float *)((char *)v107 + v128);
        *(v132 - 1) = v129 * v131;
        *v132 = v130 * v131;
        v128 += 8;
        --v127;
      }
      while (v127);
LABEL_115:
      ++v104;
      v75 = v108;
      v107 = (float *)((char *)v107 + v108);
      v72 = v171;
      v73 = v173;
      v106 = (const float *)((char *)v106 + v173);
      v74 = v109;
    }
    while (v104 != v77);
  }
LABEL_11:
  v18 = HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v18, *(_QWORD *)((char *)v158 + 20), *(_QWORD *)((char *)v158 + 28), *((unsigned int *)v158 + 4));
  v155 = v18;
  v151 = HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v151, *(_QWORD *)((char *)v158 + 20), *(_QWORD *)((char *)v158 + 28), *((unsigned int *)v158 + 4));
  if (!a11)
    goto LABEL_57;
  v19 = v158;
  v20 = v154;
  v21 = v18;
  if (v153 == v152)
    goto LABEL_59;
  if (v157 == v156)
    goto LABEL_58;
  v22 = 0;
  v23 = (const float *)*((_QWORD *)a3 + 10);
  v24 = *((_QWORD *)a3 + 8);
  v25 = (const float *)v18[10];
  v167 = (const float *)v151[10];
  v172 = v151[8];
  v174 = v18[8];
  if (v154 <= 1)
    v26 = 1;
  else
    v26 = v154;
  if (v150 <= 1)
    v27 = 1;
  else
    v27 = v150;
  v165 = 2 * v26;
  v176 = v26;
  v163 = v23;
  v164 = v26 & 0xFFFFFFFC;
  v166 = (float *)v158[10];
  __asm { FMOV            V0.4S, #1.0 }
  v178 = _Q0;
  v168 = v27;
  v170 = v158[8];
  v161 = (const float *)v18[10];
  v162 = v24;
  while (2)
  {
    v160 = v22;
    v33 = 0;
    v34 = v23;
    v35 = v25;
    v36 = v166;
    v37 = v167;
    do
    {
      if (v176 < 4)
      {
        v38 = 0;
LABEL_28:
        v40 = a7;
        v39 = a10;
LABEL_29:
        v41 = v176 - v38;
        v42 = (8 * v38) | 4;
        do
        {
          v43 = (float)((float)(*(const float *)((char *)v35 + v42) * v40) - *(const float *)((char *)v34 + v42))
              + (float)(*(const float *)((char *)v37 + v42) * v39);
          v44 = expf((float)((float)(*(const float *)((char *)v35 + v42 - 4) * v40)- *(const float *)((char *)v34 + v42 - 4))+ (float)(*(const float *)((char *)v37 + v42 - 4) * v39));
          v45 = expf(v43);
          v40 = a7;
          v39 = a10;
          v46 = 1.0 / (float)(v44 + v45);
          v47 = (float *)((char *)v36 + v42);
          *(v47 - 1) = v44 * v46;
          *v47 = v45 * v46;
          v42 += 8;
          --v41;
        }
        while (v41);
        goto LABEL_25;
      }
      v38 = 0;
      v48 = (unint64_t)v166 + v170 * v33;
      v49 = (unint64_t)&v166[v165] + v170 * v33;
      v51 = v48 < (unint64_t)&v25[v165] + v174 * v33 && (unint64_t)v25 + v174 * v33 < v49;
      v53 = v48 < (unint64_t)&v167[v165] + v172 * v33 && (unint64_t)v167 + v172 * v33 < v49;
      v54 = (unint64_t)v23 + v24 * v33 >= v49 || v48 >= (unint64_t)&v23[v165] + v24 * v33;
      if (!v54 || v51)
        goto LABEL_28;
      v40 = a7;
      v39 = a10;
      if (v53)
        goto LABEL_29;
      v55 = v164;
      v56 = v34;
      v57 = v35;
      v58 = v37;
      v59 = v36;
      do
      {
        v200 = vld2q_f32(v56);
        v56 += 8;
        v204 = vld2q_f32(v57);
        v57 += 8;
        v206 = vld2q_f32(v58);
        v58 += 8;
        v180 = vaddq_f32(vsubq_f32(vmulq_n_f32(v204.val[0], v40), v200.val[0]), vmulq_n_f32(v206.val[0], v39));
        v189 = vaddq_f32(vsubq_f32(vmulq_n_f32(v204.val[1], v40), v200.val[1]), vmulq_n_f32(v206.val[1], v39));
        v192 = expf(v180.f32[1]);
        v60.f32[0] = expf(v180.f32[0]);
        v60.f32[1] = v192;
        v193 = v60;
        v61 = expf(v180.f32[2]);
        v62 = v193;
        v62.f32[2] = v61;
        v194 = v62;
        v63 = expf(v180.f32[3]);
        v64 = v194;
        v64.f32[3] = v63;
        v195 = v64;
        v180.i32[0] = expf(v189.f32[1]);
        v65.f32[0] = expf(v189.f32[0]);
        v65.i32[1] = v180.i32[0];
        v181 = v65;
        v66 = expf(v189.f32[2]);
        v67 = v181;
        v67.f32[2] = v66;
        v182 = v67;
        v68 = expf(v189.f32[3]);
        v40 = a7;
        v39 = a10;
        v69 = v182;
        v69.f32[3] = v68;
        v70 = v69;
        v71 = vdivq_f32(v178, vaddq_f32(v195, v69));
        v202.val[0] = vmulq_f32(v195, v71);
        v202.val[1] = vmulq_f32(v70, v71);
        vst2q_f32(v59, v202);
        v59 += 8;
        v55 -= 4;
      }
      while (v55);
      v23 = v163;
      v38 = v164;
      v25 = v161;
      v24 = v162;
      if (v176 != v164)
        goto LABEL_29;
LABEL_25:
      ++v33;
      v36 = (float *)((char *)v36 + v170);
      v37 = (const float *)((char *)v37 + v172);
      v35 = (const float *)((char *)v35 + v174);
      v34 = (const float *)((char *)v34 + v24);
    }
    while (v33 != v168);
    v22 = v160 + 1;
    if (v160 + 1 != a11)
      continue;
    break;
  }
LABEL_57:
  v19 = v158;
  v20 = v154;
  v21 = v155;
  if (v153 != v152)
  {
LABEL_58:
    if (v157 == v156)
      goto LABEL_59;
    v89 = v19[10];
    v90 = v19[8];
    v91 = v150;
    v92 = *((_QWORD *)a4 + 10);
    v93 = *((_QWORD *)a4 + 8);
    if (v20 <= 1)
      v94 = 1;
    else
      v94 = v20;
    if (v150 <= 1)
      v91 = 1;
    if (v94 < 8)
    {
      v95 = (float *)(v89 + 28);
      v96 = (float *)(v92 + 12);
      do
      {
        if (*(v95 - 7) <= *(v95 - 6))
          v97 = 0.0;
        else
          v97 = 1.0;
        *(v96 - 3) = v97;
        if (v20 >= 2)
        {
          v98 = *(v95 - 5) <= *(v95 - 4) ? 0.0 : 1.0;
          *(v96 - 2) = v98;
          if (v94 != 2)
          {
            v99 = *(v95 - 3) <= *(v95 - 2) ? 0.0 : 1.0;
            *(v96 - 1) = v99;
            if (v94 != 3)
            {
              v100 = *(v95 - 1) <= *v95 ? 0.0 : 1.0;
              *v96 = v100;
              if (v94 != 4)
              {
                v101 = v95[1] <= v95[2] ? 0.0 : 1.0;
                v96[1] = v101;
                if (v94 != 5)
                {
                  v102 = v95[3] <= v95[4] ? 0.0 : 1.0;
                  v96[2] = v102;
                  if (v94 != 6)
                  {
                    if (v95[5] <= v95[6])
                      v103 = 0.0;
                    else
                      v103 = 1.0;
                    v96[3] = v103;
                  }
                }
              }
            }
          }
        }
        v95 = (float *)((char *)v95 + v90);
        v96 = (float *)((char *)v96 + v93);
        --v91;
      }
      while (v91);
      goto LABEL_59;
    }
    v133 = 0;
    v134 = (const float *)(v89 + 32);
    v135 = (int8x16_t *)(v92 + 16);
    __asm { FMOV            V0.4S, #1.0 }
    v137 = v19[10];
    v138 = *((_QWORD *)a4 + 10);
    while (2)
    {
      if (v92 + v93 * v133 >= v89 + 8 * v94 + v90 * v133 || v89 + v90 * v133 >= v92 + 4 * v94 + v93 * v133)
      {
        v140 = v94 & 0xFFFFFFF8;
        v141 = v135;
        v142 = v134;
        do
        {
          v143 = v142 - 8;
          v205 = vld2q_f32(v143);
          v207 = vld2q_f32(v142);
          v141[-1] = vandq_s8(_Q0, (int8x16_t)vcgtq_f32(v205.val[0], v205.val[1]));
          *v141 = vandq_s8(_Q0, (int8x16_t)vcgtq_f32(v207.val[0], v207.val[1]));
          v142 += 16;
          v141 += 2;
          v140 -= 8;
        }
        while (v140);
        v144 = v94 & 0xFFFFFFF8;
        if (v94 != v144)
          goto LABEL_137;
      }
      else
      {
        v144 = 0;
LABEL_137:
        v145 = v94 - v144;
        v146 = 8 * v144;
        v147 = (float *)(v138 + 4 * v144);
        do
        {
          if (*(float *)(v137 + v146) <= *(float *)(v137 + v146 + 4))
            v148 = 0.0;
          else
            v148 = 1.0;
          *v147++ = v148;
          v146 += 8;
          --v145;
        }
        while (v145);
      }
      ++v133;
      v134 = (const float *)((char *)v134 + v90);
      v135 = (int8x16_t *)((char *)v135 + v93);
      v138 += v93;
      v137 += v90;
      if (v133 == v91)
        break;
      continue;
    }
  }
LABEL_59:
  if (v151)
    (*(void (**)(_QWORD *))(*v151 + 24))(v151);
  if (v21)
    (*(void (**)(_QWORD *))(*v21 + 24))(v21);
  if (v19)
    (*(void (**)(_QWORD *))(*v19 + 24))(v19);
  return 0;
}

void sub_1B2A3D910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  HGObject::operator delete(__p);
  if (a14)
    (*(void (**)(uint64_t))(*(_QWORD *)a14 + 24))(a14);
  (*(void (**)(void *))(*(_QWORD *)a16 + 24))(a16);
  _Unwind_Resume(a1);
}

uint64_t HGComputeDevice::HGComputeDevice()
{
  uint64_t v0;
  int v1;
  std::string *v2;
  utsname v4;
  char v5;
  uint64_t v6;

  v0 = MEMORY[0x1E0C80A78]();
  v6 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)v0 = &unk_1E6523A20;
  *(_DWORD *)(v0 + 8) = v1;
  *(_OWORD *)(v0 + 16) = 0u;
  v2 = (std::string *)(v0 + 40);
  *(_OWORD *)(v0 + 32) = 0u;
  *(_OWORD *)(v0 + 48) = 0u;
  if (!gethostname(v4.sysname, 0x1000uLL))
  {
    v5 = 0;
    MEMORY[0x1B5E28D80](v0 + 16, &v4);
    if (uname(&v4))
      goto LABEL_6;
    goto LABEL_9;
  }
  if (*(char *)(v0 + 39) < 0)
  {
    **(_BYTE **)(v0 + 16) = 0;
    *(_QWORD *)(v0 + 24) = 0;
    if (uname(&v4))
      goto LABEL_6;
LABEL_9:
    MEMORY[0x1B5E28D80](v2, &v4);
    std::string::push_back(v2, 32);
    std::string::append(v2, v4.release);
    std::string::push_back(v2, 32);
    std::string::append(v2, v4.machine);
    std::string::push_back(v2, 32);
    std::string::append(v2, v4.version);
    return v0;
  }
  *(_BYTE *)(v0 + 16) = 0;
  *(_BYTE *)(v0 + 39) = 0;
  if (!uname(&v4))
    goto LABEL_9;
LABEL_6:
  if (*(char *)(v0 + 63) < 0)
  {
    **(_BYTE **)(v0 + 40) = 0;
    *(_QWORD *)(v0 + 48) = 0;
  }
  else
  {
    *(_BYTE *)(v0 + 40) = 0;
    *(_BYTE *)(v0 + 63) = 0;
  }
  return v0;
}

void sub_1B2A3DB48(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;

  if (*(char *)(v1 + 63) < 0)
  {
    operator delete(*v3);
    if ((*(char *)(v1 + 39) & 0x80000000) == 0)
LABEL_3:
      _Unwind_Resume(exception_object);
  }
  else if ((*(char *)(v1 + 39) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void HGCPUComputeDevice::HGCPUComputeDevice(HGCPUComputeDevice *this)
{
  uint64_t v2;
  uint64_t v3;
  const char *v4;
  const char *v5;
  size_t v6;
  size_t v7;
  int v8[2];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v2 = HGComputeDevice::HGComputeDevice();
  *(_QWORD *)v2 = &unk_1E6523A40;
  *(_OWORD *)(v2 + 64) = 0u;
  v3 = v2 + 64;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  *(_QWORD *)(v2 + 112) = 0;
  v4 = macho_arch_name_for_mach_header(0);
  if (v4)
    v5 = v4;
  else
    v5 = "(unknown)";
  MEMORY[0x1B5E28D80](v3, v5);
  LODWORD(v6) = 0;
  v7 = 4;
  sysctlbyname("hw.physicalcpu", &v6, &v7, 0, 0);
  *((_DWORD *)this + 22) = v6;
  LODWORD(v6) = 0;
  v7 = 4;
  sysctlbyname("hw.activecpu", &v6, &v7, 0, 0);
  *((_DWORD *)this + 23) = v6;
  v6 = 8;
  v7 = 0;
  *(_QWORD *)v8 = 0x1800000006;
  sysctl(v8, 2u, &v7, &v6, 0, 0);
  *((_QWORD *)this + 12) = v7;
  v6 = 8;
  v7 = 0;
  sysctlbyname("hw.l1dcachesize", &v7, &v6, 0, 0);
  *((_QWORD *)this + 13) = v7;
  v6 = 8;
  v7 = 0;
  sysctlbyname("hw.l2cachesize", &v7, &v6, 0, 0);
  *((_QWORD *)this + 14) = v7;
}

void sub_1B2A3DD1C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 87) < 0)
    operator delete(*v2);
  HGComputeDevice::~HGComputeDevice((void **)v1);
  _Unwind_Resume(a1);
}

void HGComputeDevice::~HGComputeDevice(void **this)
{
  *this = &unk_1E6523A20;
  if ((*((char *)this + 63) & 0x80000000) == 0)
  {
    if ((*((char *)this + 39) & 0x80000000) == 0)
      return;
LABEL_5:
    operator delete(this[2]);
    return;
  }
  operator delete(this[5]);
  if (*((char *)this + 39) < 0)
    goto LABEL_5;
}

{
  *this = &unk_1E6523A20;
  if (*((char *)this + 63) < 0)
  {
    operator delete(this[5]);
    if ((*((char *)this + 39) & 0x80000000) == 0)
LABEL_6:
      JUMPOUT(0x1B5E29170);
  }
  else if ((*((char *)this + 39) & 0x80000000) == 0)
  {
    goto LABEL_6;
  }
  operator delete(this[2]);
  goto LABEL_6;
}

_QWORD *HGGPUComputeDevice::HGGPUComputeDevice(_QWORD *a1, void *a2)
{
  uint64_t v4;
  uint64_t v5;
  id v6;
  id *DeviceInfo;
  uint64_t v8;
  uint64_t v9;

  v4 = HGComputeDevice::HGComputeDevice();
  *(_QWORD *)v4 = off_1E6523A60;
  *(_QWORD *)(v4 + 64) = 0;
  v5 = v4 + 64;
  *(_QWORD *)(v4 + 96) = 0;
  *(_QWORD *)(v4 + 72) = 0;
  *(_QWORD *)(v4 + 80) = 0;
  *(_DWORD *)(v4 + 88) = 0;
  *(_DWORD *)(v4 + 104) = -1;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 139) = 0u;
  *(_BYTE *)(v4 + 155) = 1;
  *(_QWORD *)(v4 + 120) = a2;
  v6 = a2;
  DeviceInfo = (id *)HGMetalDeviceInfo::getDeviceInfo(a1[15]);
  a1[16] = DeviceInfo;
  v8 = HGMetalDeviceInfo::name(DeviceInfo);
  MEMORY[0x1B5E28D80](v5, v8);
  v9 = a1[16];
  a1[12] = *(_QWORD *)(v9 + 24);
  a1[14] = *(_QWORD *)(v9 + 40);
  return a1;
}

void sub_1B2A3DE50(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 87) < 0)
    operator delete(*v2);
  HGComputeDevice::~HGComputeDevice((void **)v1);
  _Unwind_Resume(a1);
}

void HGGPUComputeDevice::~HGGPUComputeDevice(HGGPUComputeDevice *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 15);
  if (v2)

  if (*((char *)this + 87) < 0)
  {
    operator delete(*((void **)this + 8));
    *(_QWORD *)this = &unk_1E6523A20;
    if ((*((char *)this + 63) & 0x80000000) == 0)
    {
LABEL_5:
      if ((*((char *)this + 39) & 0x80000000) == 0)
        return;
LABEL_9:
      operator delete(*((void **)this + 2));
      return;
    }
  }
  else
  {
    *(_QWORD *)this = &unk_1E6523A20;
    if ((*((char *)this + 63) & 0x80000000) == 0)
      goto LABEL_5;
  }
  operator delete(*((void **)this + 5));
  if (*((char *)this + 39) < 0)
    goto LABEL_9;
}

{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 15);
  if (v2)

  if (*((char *)this + 87) < 0)
  {
    operator delete(*((void **)this + 8));
    *(_QWORD *)this = &unk_1E6523A20;
    if ((*((char *)this + 63) & 0x80000000) == 0)
    {
LABEL_5:
      if ((*((char *)this + 39) & 0x80000000) == 0)
        goto LABEL_10;
      goto LABEL_9;
    }
  }
  else
  {
    *(_QWORD *)this = &unk_1E6523A20;
    if ((*((char *)this + 63) & 0x80000000) == 0)
      goto LABEL_5;
  }
  operator delete(*((void **)this + 5));
  if ((*((char *)this + 39) & 0x80000000) == 0)
LABEL_10:
    JUMPOUT(0x1B5E29170);
LABEL_9:
  operator delete(*((void **)this + 2));
  goto LABEL_10;
}

uint64_t HGGPUComputeDevice::GetGLVirtualScreen(HGGPUComputeDevice *this)
{
  uint64_t result;

  result = *((unsigned int *)this + 26);
  if ((_DWORD)result == -1)
  {
    result = 0;
    *((_DWORD *)this + 26) = 0;
  }
  return result;
}

void HGComputeDeviceManager::GetCPUComputeDevice(HGComputeDeviceManager *this@<X0>, _QWORD *a2@<X8>)
{
  unsigned __int8 v3;
  unint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char v14;
  char **v15;
  char *v16;

  HG_RENDERER_ENV::Init(this);
  v3 = atomic_load((unsigned __int8 *)&qword_1ED4DA970);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA970))
  {
    qword_1ED4DA988 = 0;
    unk_1ED4DA990 = 0;
    qword_1ED4DA980 = 0;
    __cxa_atexit((void (*)(void *))std::vector<std::shared_ptr<HGComputeDevice const>>::~vector[abi:ne180100], &qword_1ED4DA980, &dword_1B2737000);
    __cxa_guard_release(&qword_1ED4DA970);
  }
  v4 = atomic_load(&_MergedGlobals_9);
  if (v4 != -1)
  {
    v16 = &v14;
    v15 = &v16;
    std::__call_once(&_MergedGlobals_9, &v15, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<CreateComputeDeviceList(void)::$_0 &&>>);
  }
  v5 = (uint64_t *)qword_1ED4DA980;
  v6 = qword_1ED4DA988;
  while (1)
  {
    if (v5 == (uint64_t *)v6)
      goto LABEL_18;
    v7 = *v5;
    v8 = (std::__shared_weak_count *)v5[1];
    if (!v8)
      break;
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    if (!*(_DWORD *)(v7 + 8))
    {
      if (*(_UNKNOWN **)v7 == &unk_1E6523A40)
      {
        *a2 = v7;
        a2[1] = v8;
        do
          v12 = __ldxr(p_shared_owners);
        while (__stxr(v12 + 1, p_shared_owners));
      }
      else
      {
        *a2 = 0;
        a2[1] = 0;
      }
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
      return;
    }
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
LABEL_6:
    v5 += 2;
  }
  if (*(_DWORD *)(v7 + 8))
    goto LABEL_6;
  if (*(_UNKNOWN **)v7 != &unk_1E6523A40)
  {
LABEL_18:
    *a2 = 0;
    a2[1] = 0;
    return;
  }
  *a2 = v7;
  a2[1] = 0;
}

uint64_t *HGComputeDeviceManager::GetGPUComputeDeviceList(HGComputeDeviceManager *this)
{
  GetSortedGPUDeviceList(this);
  return &qword_1ED4DA998;
}

void GetSortedGPUDeviceList(HG_RENDERER_ENV *a1)
{
  unsigned __int8 v1;
  unint64_t v2;
  unsigned __int8 v3;
  char v4;
  char **v5;
  char *v6;

  HG_RENDERER_ENV::Init(a1);
  v1 = atomic_load((unsigned __int8 *)&qword_1ED4DA970);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA970))
  {
    qword_1ED4DA988 = 0;
    unk_1ED4DA990 = 0;
    qword_1ED4DA980 = 0;
    __cxa_atexit((void (*)(void *))std::vector<std::shared_ptr<HGComputeDevice const>>::~vector[abi:ne180100], &qword_1ED4DA980, &dword_1B2737000);
    __cxa_guard_release(&qword_1ED4DA970);
  }
  v2 = atomic_load(&_MergedGlobals_9);
  if (v2 != -1)
  {
    v6 = &v4;
    v5 = &v6;
    std::__call_once(&_MergedGlobals_9, &v5, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<CreateComputeDeviceList(void)::$_0 &&>>);
  }
  v3 = atomic_load((unsigned __int8 *)&qword_1ED4DA978);
  if ((v3 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4DA978))
    {
      qword_1ED4DA9A0 = 0;
      unk_1ED4DA9A8 = 0;
      qword_1ED4DA998 = 0;
      __cxa_atexit((void (*)(void *))std::vector<std::shared_ptr<HGGPUComputeDevice const>>::~vector[abi:ne180100], &qword_1ED4DA998, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4DA978);
    }
  }
}

void HGComputeDeviceManager::GetGPUComputeDeviceForCGLVirtualScreen(HGComputeDeviceManager *this@<X0>, _QWORD *a2@<X8>)
{
  int v2;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v2 = (int)this;
  GetSortedGPUDeviceList(this);
  v4 = (_QWORD *)qword_1ED4DA998;
  v5 = qword_1ED4DA9A0;
  if (qword_1ED4DA998 == qword_1ED4DA9A0)
  {
LABEL_6:
    *a2 = 0;
    a2[1] = 0;
  }
  else
  {
    while (1)
    {
      v6 = *v4;
      v7 = *(_DWORD *)(*v4 + 104);
      if (v7 == -1)
      {
        v7 = 0;
        *(_DWORD *)(v6 + 104) = 0;
      }
      if (v7 == v2)
        break;
      v4 += 2;
      if (v4 == (_QWORD *)v5)
        goto LABEL_6;
    }
    v8 = v4[1];
    *a2 = v6;
    a2[1] = v8;
    if (v8)
    {
      v9 = (unint64_t *)(v8 + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
  }
}

void HGCPUComputeDevice::~HGCPUComputeDevice(void **this)
{
  if (*((char *)this + 87) < 0)
  {
    operator delete(this[8]);
    *this = &unk_1E6523A20;
    if ((*((char *)this + 63) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 39) & 0x80000000) == 0)
        return;
LABEL_7:
      operator delete(this[2]);
      return;
    }
  }
  else
  {
    *this = &unk_1E6523A20;
    if ((*((char *)this + 63) & 0x80000000) == 0)
      goto LABEL_3;
  }
  operator delete(this[5]);
  if (*((char *)this + 39) < 0)
    goto LABEL_7;
}

{
  if (*((char *)this + 87) < 0)
  {
    operator delete(this[8]);
    *this = &unk_1E6523A20;
    if ((*((char *)this + 63) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 39) & 0x80000000) == 0)
        goto LABEL_8;
      goto LABEL_7;
    }
  }
  else
  {
    *this = &unk_1E6523A20;
    if ((*((char *)this + 63) & 0x80000000) == 0)
      goto LABEL_3;
  }
  operator delete(this[5]);
  if ((*((char *)this + 39) & 0x80000000) == 0)
LABEL_8:
    JUMPOUT(0x1B5E29170);
LABEL_7:
  operator delete(this[2]);
  goto LABEL_8;
}

void **std::vector<std::shared_ptr<HGComputeDevice const>>::~vector[abi:ne180100](void **a1)
{
  char *v2;
  char *v3;
  void *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        v5 = (std::__shared_weak_count *)*((_QWORD *)v3 - 1);
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            v7 = __ldaxr(p_shared_owners);
          while (__stlxr(v7 - 1, p_shared_owners));
          if (!v7)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }
        v3 -= 16;
      }
      while (v3 != v2);
      v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<CreateComputeDeviceList(void)::$_0 &&>>()
{
  std::__shared_weak_count *v0;
  unint64_t *p_shared_owners;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  char *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  id v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  char *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unsigned __int8 v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  _OWORD *v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  unsigned __int8 v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  std::__shared_weak_count *v35;
  __int128 v36;

  v0 = (std::__shared_weak_count *)operator new(0x90uLL);
  v0->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v0->__shared_owners_;
  v0->__shared_weak_owners_ = 0;
  v0->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E6523AC0;
  HGCPUComputeDevice::HGCPUComputeDevice((HGCPUComputeDevice *)&v0[1]);
  *(_QWORD *)&v36 = v2;
  *((_QWORD *)&v36 + 1) = v0;
  do
    v3 = __ldxr(p_shared_owners);
  while (__stxr(v3 + 1, p_shared_owners));
  v4 = qword_1ED4DA988;
  if ((unint64_t)qword_1ED4DA988 >= unk_1ED4DA990)
  {
    v5 = std::vector<std::shared_ptr<HGComputeDevice const>>::__push_back_slow_path<std::shared_ptr<HGComputeDevice const>>((char **)&qword_1ED4DA980, (uint64_t)&v36);
    v6 = (std::__shared_weak_count *)*((_QWORD *)&v36 + 1);
    qword_1ED4DA988 = (uint64_t)v5;
    if (*((_QWORD *)&v36 + 1))
    {
      v7 = (unint64_t *)(*((_QWORD *)&v36 + 1) + 8);
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  else
  {
    *(_QWORD *)qword_1ED4DA988 = v2;
    *(_QWORD *)(v4 + 8) = v0;
    qword_1ED4DA988 = v4 + 16;
  }
  v9 = MTLCreateSystemDefaultDevice();
  if (v9)
  {
    v10 = (std::__shared_weak_count *)operator new(0xB8uLL);
    v10->__shared_owners_ = 0;
    v11 = (unint64_t *)&v10->__shared_owners_;
    v10->__shared_weak_owners_ = 0;
    v10->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E6523B10;
    v12 = HGGPUComputeDevice::HGGPUComputeDevice(&v10[1].__vftable, v9);
    *(_QWORD *)&v36 = v12;
    *((_QWORD *)&v36 + 1) = v10;
    v34 = v12;
    v35 = v10;
    do
      v13 = __ldxr(v11);
    while (__stxr(v13 + 1, v11));
    v14 = qword_1ED4DA988;
    if ((unint64_t)qword_1ED4DA988 >= unk_1ED4DA990)
    {
      v15 = std::vector<std::shared_ptr<HGComputeDevice const>>::__push_back_slow_path<std::shared_ptr<HGComputeDevice const>>((char **)&qword_1ED4DA980, (uint64_t)&v34);
      v16 = v35;
      qword_1ED4DA988 = (uint64_t)v15;
      if (v35)
      {
        v17 = (unint64_t *)&v35->__shared_owners_;
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
    }
    else
    {
      *(_QWORD *)qword_1ED4DA988 = v12;
      *(_QWORD *)(v14 + 8) = v10;
      qword_1ED4DA988 = v14 + 16;
    }
    v19 = atomic_load((unsigned __int8 *)&qword_1ED4DA978);
    if ((v19 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA978))
    {
      qword_1ED4DA9A0 = 0;
      unk_1ED4DA9A8 = 0;
      qword_1ED4DA998 = 0;
      __cxa_atexit((void (*)(void *))std::vector<std::shared_ptr<HGGPUComputeDevice const>>::~vector[abi:ne180100], &qword_1ED4DA998, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4DA978);
    }
    v20 = qword_1ED4DA9A0;
    if ((unint64_t)qword_1ED4DA9A0 >= unk_1ED4DA9A8)
    {
      v24 = std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__push_back_slow_path<std::shared_ptr<HGGPUComputeDevice const> const&>((uint64_t)&qword_1ED4DA998, &v36);
    }
    else
    {
      *(_QWORD *)qword_1ED4DA9A0 = v36;
      v21 = *((_QWORD *)&v36 + 1);
      *(_QWORD *)(v20 + 8) = *((_QWORD *)&v36 + 1);
      if (v21)
      {
        v22 = (unint64_t *)(v21 + 8);
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
      }
      v24 = (_OWORD *)(v20 + 16);
    }
    qword_1ED4DA9A0 = (uint64_t)v24;

    v25 = (std::__shared_weak_count *)*((_QWORD *)&v36 + 1);
    if (*((_QWORD *)&v36 + 1))
    {
      v26 = (unint64_t *)(*((_QWORD *)&v36 + 1) + 8);
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
  }
  v28 = atomic_load((unsigned __int8 *)&qword_1ED4DA978);
  if ((v28 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA978))
  {
    qword_1ED4DA9A0 = 0;
    unk_1ED4DA9A8 = 0;
    qword_1ED4DA998 = 0;
    __cxa_atexit((void (*)(void *))std::vector<std::shared_ptr<HGGPUComputeDevice const>>::~vector[abi:ne180100], &qword_1ED4DA998, &dword_1B2737000);
    __cxa_guard_release(&qword_1ED4DA978);
  }
  v29 = (uint64_t *)qword_1ED4DA998;
  v30 = atomic_load((unsigned __int8 *)&qword_1ED4DA978);
  if ((v30 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA978))
  {
    qword_1ED4DA9A0 = 0;
    unk_1ED4DA9A8 = 0;
    qword_1ED4DA998 = 0;
    __cxa_atexit((void (*)(void *))std::vector<std::shared_ptr<HGGPUComputeDevice const>>::~vector[abi:ne180100], &qword_1ED4DA998, &dword_1B2737000);
    __cxa_guard_release(&qword_1ED4DA978);
  }
  v31 = 126 - 2 * __clz((qword_1ED4DA9A0 - (uint64_t)v29) >> 4);
  if ((uint64_t *)qword_1ED4DA9A0 == v29)
    v32 = 0;
  else
    v32 = v31;
  std::__introsort<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *,false>(v29, (uint64_t *)qword_1ED4DA9A0, (uint64_t)&v36, v32, 1);
  do
    v33 = __ldaxr(p_shared_owners);
  while (__stlxr(v33 - 1, p_shared_owners));
  if (!v33)
  {
    ((void (*)(std::__shared_weak_count *))v0->__on_zero_shared)(v0);
    std::__shared_weak_count::__release_weak(v0);
  }
}

void sub_1B2A3E91C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t *p_shared_owners;
  unint64_t v16;
  unint64_t v17;

  if (a10)
    std::__call_once_proxy[abi:ne180100]<std::tuple<CreateComputeDeviceList(void)::$_0 &&>>(a10);
  if (a12)
  {
    p_shared_owners = (unint64_t *)&a12->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }
  do
    v17 = __ldaxr(v13);
  while (__stlxr(v17 - 1, v13));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<HGCPUComputeDevice>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E6523AC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HGCPUComputeDevice>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E6523AC0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

void std::__shared_ptr_emplace<HGCPUComputeDevice>::__on_zero_shared(uint64_t a1)
{
  if (*(char *)(a1 + 111) < 0)
  {
    operator delete(*(void **)(a1 + 88));
    *(_QWORD *)(a1 + 24) = &unk_1E6523A20;
    if ((*(char *)(a1 + 87) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(a1 + 63) & 0x80000000) == 0)
        return;
LABEL_7:
      operator delete(*(void **)(a1 + 40));
      return;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = &unk_1E6523A20;
    if ((*(char *)(a1 + 87) & 0x80000000) == 0)
      goto LABEL_3;
  }
  operator delete(*(void **)(a1 + 64));
  if (*(char *)(a1 + 63) < 0)
    goto LABEL_7;
}

char *std::vector<std::shared_ptr<HGComputeDevice const>>::__push_back_slow_path<std::shared_ptr<HGComputeDevice const>>(char **a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;
  uint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  __int128 v16;
  char *v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;

  v3 = (a1[1] - *a1) >> 4;
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) >> 60)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v5 = a1[2] - *a1;
  if (v5 >> 3 > v4)
    v4 = v5 >> 3;
  v6 = (unint64_t)v5 >= 0x7FFFFFFFFFFFFFF0;
  v7 = 0xFFFFFFFFFFFFFFFLL;
  if (!v6)
    v7 = v4;
  if (v7 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v9 = 16 * v7;
  v10 = (char *)operator new(16 * v7);
  v11 = &v10[16 * v3];
  *(_OWORD *)v11 = *(_OWORD *)a2;
  v12 = v11 + 16;
  v13 = &v10[v9];
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v14 = *a1;
  v15 = a1[1];
  if (v15 == *a1)
  {
    *a1 = v11;
    a1[1] = v12;
    a1[2] = v13;
    if (!v15)
      return v12;
    goto LABEL_19;
  }
  do
  {
    v16 = *((_OWORD *)v15 - 1);
    v15 -= 16;
    *((_OWORD *)v11 - 1) = v16;
    v11 -= 16;
    *(_QWORD *)v15 = 0;
    *((_QWORD *)v15 + 1) = 0;
  }
  while (v15 != v14);
  v17 = *a1;
  v15 = a1[1];
  *a1 = v11;
  a1[1] = v12;
  a1[2] = v13;
  if (v15 != v17)
  {
    do
    {
      v18 = (std::__shared_weak_count *)*((_QWORD *)v15 - 1);
      if (v18)
      {
        p_shared_owners = (unint64_t *)&v18->__shared_owners_;
        do
          v20 = __ldaxr(p_shared_owners);
        while (__stlxr(v20 - 1, p_shared_owners));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      v15 -= 16;
    }
    while (v15 != v17);
    v15 = v17;
  }
  if (v15)
LABEL_19:
    operator delete(v15);
  return v12;
}

void std::__shared_ptr_emplace<HGGPUComputeDevice>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E6523B10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HGGPUComputeDevice>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E6523B10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

void std::__shared_ptr_emplace<HGGPUComputeDevice>::__on_zero_shared(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 144);
  if (v2)

  if (*(char *)(a1 + 111) < 0)
  {
    operator delete(*(void **)(a1 + 88));
    *(_QWORD *)(a1 + 24) = &unk_1E6523A20;
    if ((*(char *)(a1 + 87) & 0x80000000) == 0)
    {
LABEL_5:
      if ((*(char *)(a1 + 63) & 0x80000000) == 0)
        return;
LABEL_9:
      operator delete(*(void **)(a1 + 40));
      return;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = &unk_1E6523A20;
    if ((*(char *)(a1 + 87) & 0x80000000) == 0)
      goto LABEL_5;
  }
  operator delete(*(void **)(a1 + 64));
  if (*(char *)(a1 + 63) < 0)
    goto LABEL_9;
}

void **std::vector<std::shared_ptr<HGGPUComputeDevice const>>::~vector[abi:ne180100](void **a1)
{
  char *v2;
  char *v3;
  void *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        v5 = (std::__shared_weak_count *)*((_QWORD *)v3 - 1);
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            v7 = __ldaxr(p_shared_owners);
          while (__stlxr(v7 - 1, p_shared_owners));
          if (!v7)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }
        v3 -= 16;
      }
      while (v3 != v2);
      v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

_OWORD *std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__push_back_slow_path<std::shared_ptr<HGGPUComputeDevice const> const&>(uint64_t a1, __int128 *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v9;
  char *v10;
  char *v11;
  __int128 v12;
  unint64_t *v13;
  unint64_t v14;
  char *v15;
  _OWORD *v16;
  __int128 v17;
  _QWORD *v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;

  v3 = *(_QWORD **)a1;
  v4 = *(_QWORD **)(a1 + 8);
  v5 = ((uint64_t)v4 - *(_QWORD *)a1) >> 4;
  v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) >> 60)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v7 = *(_QWORD *)(a1 + 16) - (_QWORD)v3;
  if (v7 >> 3 > v6)
    v6 = v7 >> 3;
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF0)
    v6 = 0xFFFFFFFFFFFFFFFLL;
  if (v6 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v9 = 16 * v6;
  v10 = (char *)operator new(16 * v6);
  v11 = &v10[16 * v5];
  v12 = *a2;
  *(_OWORD *)v11 = *a2;
  if (*((_QWORD *)&v12 + 1))
  {
    v13 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
    v3 = *(_QWORD **)a1;
    v4 = *(_QWORD **)(a1 + 8);
  }
  v15 = &v10[v9];
  v16 = v11 + 16;
  if (v4 == v3)
  {
    *(_QWORD *)a1 = v11;
    *(_QWORD *)(a1 + 8) = v16;
    *(_QWORD *)(a1 + 16) = v15;
    if (!v3)
      return v16;
    goto LABEL_23;
  }
  do
  {
    v17 = *((_OWORD *)v4 - 1);
    v4 -= 2;
    *((_OWORD *)v11 - 1) = v17;
    v11 -= 16;
    *v4 = 0;
    v4[1] = 0;
  }
  while (v4 != v3);
  v18 = *(_QWORD **)a1;
  v3 = *(_QWORD **)(a1 + 8);
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + 8) = v16;
  *(_QWORD *)(a1 + 16) = v15;
  if (v3 != v18)
  {
    do
    {
      v19 = (std::__shared_weak_count *)*(v3 - 1);
      if (v19)
      {
        p_shared_owners = (unint64_t *)&v19->__shared_owners_;
        do
          v21 = __ldaxr(p_shared_owners);
        while (__stlxr(v21 - 1, p_shared_owners));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }
      v3 -= 2;
    }
    while (v3 != v18);
    v3 = v18;
  }
  if (v3)
LABEL_23:
    operator delete(v3);
  return v16;
}

void std::__introsort<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *,false>(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t *v47;
  uint64_t *v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t *v67;
  uint64_t *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  unint64_t v81;
  uint64_t *v82;
  uint64_t *v83;
  uint64_t *v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t *v87;
  uint64_t *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  char v95;
  BOOL v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  unint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unint64_t v119;
  unint64_t v120;
  uint64_t *v121;
  unint64_t v122;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;

void std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;

  if (a1 != a2)
  {
    v4 = a1 + 2;
    if (a1 + 2 != a2)
    {
      v5 = a1;
      do
      {
        v6 = v5;
        v5 = v4;
        v7 = v6[2];
        v8 = *v6;
        if (*(_QWORD *)(v7 + 112) > *(_QWORD *)(*v6 + 112))
        {
          v9 = v6[3];
          v10 = v5;
          *v5 = 0;
          v5[1] = 0;
          while (1)
          {
            v11 = v10;
            v10 = v6;
            v12 = v6[1];
            *v10 = 0;
            v10[1] = 0;
            v13 = (std::__shared_weak_count *)v11[1];
            *v11 = v8;
            v11[1] = v12;
            if (v13)
            {
              p_shared_owners = (unint64_t *)&v13->__shared_owners_;
              do
                v15 = __ldaxr(p_shared_owners);
              while (__stlxr(v15 - 1, p_shared_owners));
              if (!v15)
              {
                ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
                std::__shared_weak_count::__release_weak(v13);
              }
            }
            if (v10 == a1)
              break;
            v6 = v10 - 2;
            v8 = *(v10 - 2);
            if (*(_QWORD *)(v7 + 112) <= *(_QWORD *)(v8 + 112))
            {
              v16 = (std::__shared_weak_count *)v10[1];
              *v10 = v7;
              v10[1] = v9;
              if (!v16)
                goto LABEL_4;
              goto LABEL_17;
            }
          }
          v16 = (std::__shared_weak_count *)a1[1];
          *a1 = v7;
          a1[1] = v9;
          if (!v16)
            goto LABEL_4;
LABEL_17:
          v17 = (unint64_t *)&v16->__shared_owners_;
          do
            v18 = __ldaxr(v17);
          while (__stlxr(v18 - 1, v17));
          if (!v18)
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
        }
LABEL_4:
        v4 = v5 + 2;
      }
      while (v5 + 2 != a2);
    }
  }
}

void std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;

  if (a1 != a2)
  {
    v3 = a1;
    while (v3 + 2 != a2)
    {
      v4 = v3;
      v3 += 2;
      v5 = v4[2];
      v6 = *v4;
      if (*(_QWORD *)(v5 + 112) > *(_QWORD *)(*v4 + 112))
      {
        v7 = v4[3];
        v8 = v3;
        *v3 = 0;
        v3[1] = 0;
        do
        {
          v9 = v8;
          v8 = v4;
          v10 = v4[1];
          *v8 = 0;
          v8[1] = 0;
          v11 = (std::__shared_weak_count *)v9[1];
          *v9 = v6;
          v9[1] = v10;
          if (v11)
          {
            p_shared_owners = (unint64_t *)&v11->__shared_owners_;
            do
              v13 = __ldaxr(p_shared_owners);
            while (__stlxr(v13 - 1, p_shared_owners));
            if (!v13)
            {
              ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
              std::__shared_weak_count::__release_weak(v11);
            }
          }
          v4 = v8 - 2;
          v6 = *(v8 - 2);
        }
        while (*(_QWORD *)(v5 + 112) > *(_QWORD *)(v6 + 112));
        v14 = (std::__shared_weak_count *)v8[1];
        *v8 = v5;
        v8[1] = v7;
        if (v14)
        {
          v15 = (unint64_t *)&v14->__shared_owners_;
          do
            v16 = __ldaxr(v15);
          while (__stlxr(v16 - 1, v15));
          if (!v16)
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
        }
      }
    }
  }
}

uint64_t *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::shared_ptr<HGGPUComputeDevice const> *,SortGPUDevices &>(__int128 *a1, uint64_t *a2)
{
  __int128 v2;
  unint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __int128 *v13;
  __int128 v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  __int128 v22;

  v2 = *a1;
  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  v3 = *(_QWORD *)(v2 + 112);
  if (v3 <= *(_QWORD *)(*(a2 - 2) + 112))
  {
    v6 = (uint64_t *)(a1 + 1);
    do
    {
      v4 = v6;
      if (v6 >= a2)
        break;
      v6 += 2;
    }
    while (v3 <= *(_QWORD *)(*v4 + 112));
  }
  else
  {
    v4 = (uint64_t *)a1;
    do
    {
      v5 = v4[2];
      v4 += 2;
    }
    while (v3 <= *(_QWORD *)(v5 + 112));
  }
  if (v4 < a2)
  {
    do
    {
      v7 = *(a2 - 2);
      a2 -= 2;
    }
    while (v3 > *(_QWORD *)(v7 + 112));
  }
  if (v4 < a2)
  {
    v8 = *v4;
    v9 = *a2;
    do
    {
      *v4 = v9;
      *a2 = v8;
      v10 = v4[1];
      v4[1] = a2[1];
      a2[1] = v10;
      do
      {
        v11 = v4[2];
        v4 += 2;
        v8 = v11;
      }
      while (v3 <= *(_QWORD *)(v11 + 112));
      do
      {
        v12 = *(a2 - 2);
        a2 -= 2;
        v9 = v12;
      }
      while (v3 > *(_QWORD *)(v12 + 112));
    }
    while (v4 < a2);
  }
  v13 = (__int128 *)(v4 - 2);
  if (v4 - 2 != (uint64_t *)a1)
  {
    v14 = *v13;
    *(_QWORD *)v13 = 0;
    *(v4 - 1) = 0;
    v15 = (std::__shared_weak_count *)*((_QWORD *)a1 + 1);
    *a1 = v14;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        v17 = __ldaxr(p_shared_owners);
      while (__stlxr(v17 - 1, p_shared_owners));
      if (!v17)
      {
        v22 = v2;
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
        v2 = v22;
      }
    }
  }
  v18 = (std::__shared_weak_count *)*(v4 - 1);
  *((_OWORD *)v4 - 1) = v2;
  if (!v18)
    return v4;
  v19 = (unint64_t *)&v18->__shared_owners_;
  do
    v20 = __ldaxr(v19);
  while (__stlxr(v20 - 1, v19));
  if (v20)
    return v4;
  ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
  std::__shared_weak_count::__release_weak(v18);
  return v4;
}

__int128 *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::shared_ptr<HGGPUComputeDevice const> *,SortGPUDevices &>(__int128 *a1, __int128 *a2)
{
  uint64_t v3;
  __int128 v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 *v11;
  __int128 *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 *v16;
  __int128 v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  __int128 v25;

  v3 = 0;
  v4 = *a1;
  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  v5 = *(_QWORD *)(v4 + 112);
  do
    v6 = *(_QWORD *)&a1[++v3];
  while (*(_QWORD *)(v6 + 112) > v5);
  v7 = (unint64_t)&a1[v3];
  if (v3 == 1)
  {
    do
    {
      if (v7 >= (unint64_t)a2)
        break;
      v9 = *((_QWORD *)a2-- - 2);
    }
    while (*(_QWORD *)(v9 + 112) <= v5);
  }
  else
  {
    do
      v8 = *((_QWORD *)a2-- - 2);
    while (*(_QWORD *)(v8 + 112) <= v5);
  }
  if (v7 >= (unint64_t)a2)
  {
    v11 = &a1[v3];
    v16 = (__int128 *)(v7 - 16);
    if ((__int128 *)(v7 - 16) == a1)
      goto LABEL_22;
  }
  else
  {
    v10 = *(_QWORD *)a2;
    v11 = &a1[v3];
    v12 = a2;
    do
    {
      *(_QWORD *)v11 = v10;
      *(_QWORD *)v12 = v6;
      v13 = *((_QWORD *)v11 + 1);
      *((_QWORD *)v11 + 1) = *((_QWORD *)v12 + 1);
      *((_QWORD *)v12 + 1) = v13;
      do
      {
        v14 = *((_QWORD *)v11++ + 2);
        v6 = v14;
      }
      while (*(_QWORD *)(v14 + 112) > v5);
      do
      {
        v15 = *((_QWORD *)v12-- - 2);
        v10 = v15;
      }
      while (*(_QWORD *)(v15 + 112) <= v5);
    }
    while (v11 < v12);
    v16 = v11 - 1;
    if (v11 - 1 == a1)
      goto LABEL_22;
  }
  v17 = *v16;
  *(_QWORD *)v16 = 0;
  *((_QWORD *)v16 + 1) = 0;
  v18 = (std::__shared_weak_count *)*((_QWORD *)a1 + 1);
  *a1 = v17;
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v20 = __ldaxr(p_shared_owners);
    while (__stlxr(v20 - 1, p_shared_owners));
    if (!v20)
    {
      v25 = v4;
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
      v4 = v25;
    }
  }
LABEL_22:
  v21 = (std::__shared_weak_count *)*((_QWORD *)v11 - 1);
  *(v11 - 1) = v4;
  if (v21)
  {
    v22 = (unint64_t *)&v21->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  return v16;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t *v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t *v56;
  uint64_t v57;
  std::__shared_weak_count *v58;
  unint64_t *p_shared_owners;
  unint64_t v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 2);
      v7 = *a1;
      if (*(_QWORD *)(v6 + 112) > *(_QWORD *)(*a1 + 112))
      {
        *a1 = v6;
        *(a2 - 2) = v7;
        v8 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return result;
    case 3:
      v9 = a1[2];
      v10 = *(_QWORD *)(v9 + 112);
      v11 = *a1;
      v12 = *(_QWORD *)(*a1 + 112);
      v13 = *(a2 - 2);
      v14 = *(_QWORD *)(v13 + 112);
      if (v10 > v12)
      {
        if (v14 <= v10)
        {
          v15 = a1 + 3;
          v43 = a1[3];
          v44 = a1[1];
          *a1 = v9;
          a1[1] = v43;
          a1[2] = v11;
          a1[3] = v44;
          v45 = *(a2 - 2);
          if (*(_QWORD *)(v45 + 112) <= v12)
            return result;
          a1[2] = v45;
        }
        else
        {
          v15 = a1 + 1;
          *a1 = v13;
        }
        *(a2 - 2) = v11;
        v37 = a2 - 1;
        goto LABEL_25;
      }
      if (v14 > v10)
      {
        a1[2] = v13;
        *(a2 - 2) = v9;
        v37 = a1 + 3;
        v36 = a1[3];
        a1[3] = *(a2 - 1);
        *(a2 - 1) = v36;
        v38 = a1[2];
        v39 = *a1;
        if (*(_QWORD *)(v38 + 112) > *(_QWORD *)(*a1 + 112))
        {
          *a1 = v38;
          a1[2] = v39;
          v15 = a1 + 1;
LABEL_25:
          v46 = *v15;
          *v15 = *v37;
          *v37 = v46;
          return result;
        }
      }
      return result;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(a1, a1 + 2, a1 + 4, a1 + 6);
      v24 = *(a2 - 2);
      v25 = a1[6];
      if (*(_QWORD *)(v24 + 112) > *(_QWORD *)(v25 + 112))
      {
        a1[6] = v24;
        *(a2 - 2) = v25;
        v26 = a1[7];
        a1[7] = *(a2 - 1);
        *(a2 - 1) = v26;
        v27 = a1[6];
        v28 = *(_QWORD *)(v27 + 112);
        v29 = a1[4];
        if (v28 > *(_QWORD *)(v29 + 112))
        {
          v30 = a1[5];
          v31 = a1[7];
          a1[4] = v27;
          a1[5] = v31;
          a1[6] = v29;
          a1[7] = v30;
          v32 = a1[2];
          if (v28 > *(_QWORD *)(v32 + 112))
          {
            v33 = a1[3];
            a1[2] = v27;
            a1[3] = v31;
            a1[4] = v32;
            a1[5] = v33;
            v34 = *a1;
            if (v28 > *(_QWORD *)(*a1 + 112))
            {
              v35 = a1[1];
              *a1 = v27;
              a1[1] = v31;
              a1[2] = v34;
              a1[3] = v35;
            }
          }
        }
      }
      return 1;
    default:
      v16 = a1 + 4;
      v17 = a1[4];
      v18 = a1[2];
      v19 = *(_QWORD *)(v18 + 112);
      v20 = *a1;
      v21 = *(_QWORD *)(*a1 + 112);
      v22 = *(_QWORD *)(v17 + 112);
      if (v19 > v21)
      {
        if (v22 <= v19)
        {
          v23 = a1 + 3;
          v47 = a1[3];
          v48 = a1[1];
          *a1 = v18;
          a1[1] = v47;
          a1[2] = v20;
          a1[3] = v48;
          if (v22 <= v21)
            goto LABEL_31;
          a1[2] = v17;
        }
        else
        {
          v23 = a1 + 1;
          *a1 = v17;
        }
        a1[4] = v20;
        v41 = a1 + 5;
        goto LABEL_30;
      }
      if (v22 > v19)
      {
        v41 = a1 + 3;
        v40 = a1[3];
        v42 = a1[5];
        a1[4] = v18;
        a1[5] = v40;
        a1[2] = v17;
        a1[3] = v42;
        if (v22 > v21)
        {
          *a1 = v17;
          a1[2] = v20;
          v23 = a1 + 1;
LABEL_30:
          v49 = *v23;
          *v23 = *v41;
          *v41 = v49;
        }
      }
LABEL_31:
      v50 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v51 = 0;
      while (1)
      {
        v52 = *v50;
        v53 = *v16;
        if (*(_QWORD *)(*v50 + 112) > *(_QWORD *)(*v16 + 112))
        {
          v54 = v50[1];
          v55 = v50;
          *v50 = 0;
          v50[1] = 0;
          while (1)
          {
            v56 = v55;
            v55 = v16;
            v57 = v16[1];
            *v55 = 0;
            v55[1] = 0;
            v58 = (std::__shared_weak_count *)v56[1];
            *v56 = v53;
            v56[1] = v57;
            if (v58)
            {
              p_shared_owners = (unint64_t *)&v58->__shared_owners_;
              do
                v60 = __ldaxr(p_shared_owners);
              while (__stlxr(v60 - 1, p_shared_owners));
              if (!v60)
              {
                ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
                std::__shared_weak_count::__release_weak(v58);
              }
            }
            if (v55 == a1)
              break;
            v16 = v55 - 2;
            v53 = *(v55 - 2);
            if (*(_QWORD *)(v52 + 112) <= *(_QWORD *)(v53 + 112))
            {
              v61 = (std::__shared_weak_count *)v55[1];
              *v55 = v52;
              v55[1] = v54;
              if (!v61)
                goto LABEL_33;
              goto LABEL_47;
            }
          }
          v61 = (std::__shared_weak_count *)a1[1];
          *a1 = v52;
          a1[1] = v54;
          if (!v61)
            goto LABEL_33;
LABEL_47:
          v62 = (unint64_t *)&v61->__shared_owners_;
          do
            v63 = __ldaxr(v62);
          while (__stlxr(v63 - 1, v62));
          if (!v63)
          {
            ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
            std::__shared_weak_count::__release_weak(v61);
          }
LABEL_33:
          if (++v51 == 8)
            return v50 + 2 == a2;
        }
        v16 = v50;
        v50 += 2;
        if (v50 == a2)
          return 1;
      }
  }
}

uint64_t *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v4 = *a2;
  v5 = *(_QWORD *)(*a2 + 112);
  v6 = *result;
  v7 = *a3;
  v8 = *(_QWORD *)(*a3 + 112);
  if (v5 <= *(_QWORD *)(*result + 112))
  {
    if (v8 > v5)
    {
      *a2 = v7;
      *a3 = v4;
      v11 = a2 + 1;
      v10 = a2[1];
      a2[1] = a3[1];
      a3[1] = v10;
      v12 = *result;
      if (*(_QWORD *)(*a2 + 112) > *(_QWORD *)(*result + 112))
      {
        *result = *a2;
        v9 = result + 1;
        *a2 = v12;
LABEL_10:
        v14 = *v9;
        *v9 = *v11;
        *v11 = v14;
      }
    }
  }
  else
  {
    if (v8 > v5)
    {
      v9 = result + 1;
      *result = v7;
LABEL_9:
      *a3 = v6;
      v11 = a3 + 1;
      goto LABEL_10;
    }
    *result = v4;
    *a2 = v6;
    v9 = a2 + 1;
    v13 = result[1];
    result[1] = a2[1];
    a2[1] = v13;
    v6 = *a2;
    if (*(_QWORD *)(*a3 + 112) > *(_QWORD *)(*a2 + 112))
    {
      *a2 = *a3;
      goto LABEL_9;
    }
  }
  v15 = *a3;
  if (*(_QWORD *)(*a4 + 112) > *(_QWORD *)(*a3 + 112))
  {
    *a3 = *a4;
    *a4 = v15;
    v16 = a3[1];
    a3[1] = a4[1];
    a4[1] = v16;
    v17 = *a2;
    if (*(_QWORD *)(*a3 + 112) > *(_QWORD *)(*a2 + 112))
    {
      *a2 = *a3;
      *a3 = v17;
      v18 = a2[1];
      a2[1] = a3[1];
      a3[1] = v18;
      v19 = *result;
      if (*(_QWORD *)(*a2 + 112) > *(_QWORD *)(*result + 112))
      {
        *result = *a2;
        *a2 = v19;
        v20 = result[1];
        result[1] = a2[1];
        a2[1] = v20;
      }
    }
  }
  return result;
}

void std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  unint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;

  v4 = a3 - 2;
  if (a3 < 2)
    return;
  v6 = (uint64_t)a4 - a1;
  v7 = v4 >> 1;
  if ((uint64_t)(v4 >> 1) < ((uint64_t)a4 - a1) >> 4)
    return;
  v9 = v6 >> 3;
  v10 = (v6 >> 3) + 1;
  v11 = (_QWORD *)(a1 + 16 * v10);
  v12 = v9 + 2;
  if (v9 + 2 >= a3)
  {
    v14 = *a4;
    if (*(_QWORD *)(*v11 + 112) > *(_QWORD *)(*a4 + 112))
      return;
  }
  else
  {
    v13 = *v11;
    if (*(_QWORD *)(*v11 + 112) > *(_QWORD *)(v11[2] + 112))
    {
      v13 = v11[2];
      v11 += 2;
      v10 = v12;
    }
    v14 = *a4;
    if (*(_QWORD *)(v13 + 112) > *(_QWORD *)(*a4 + 112))
      return;
  }
  v15 = a4[1];
  *a4 = 0;
  a4[1] = 0;
  v16 = *v11;
  while (1)
  {
    v17 = v11;
    v18 = v11[1];
    *v17 = 0;
    v17[1] = 0;
    v19 = (std::__shared_weak_count *)a4[1];
    *a4 = v16;
    a4[1] = v18;
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        v21 = __ldaxr(p_shared_owners);
      while (__stlxr(v21 - 1, p_shared_owners));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    if (v7 < v10)
      break;
    v11 = (_QWORD *)(a1 + 16 * ((2 * v10) | 1));
    if (2 * v10 + 2 < a3)
    {
      v16 = *v11;
      if (*(_QWORD *)(*v11 + 112) <= *(_QWORD *)(v11[2] + 112))
      {
        v10 = (2 * v10) | 1;
      }
      else
      {
        v16 = v11[2];
        v11 += 2;
        v10 = 2 * v10 + 2;
      }
      a4 = v17;
      if (*(_QWORD *)(v16 + 112) > *(_QWORD *)(v14 + 112))
        break;
    }
    else
    {
      v16 = *v11;
      v10 = (2 * v10) | 1;
      a4 = v17;
      if (*(_QWORD *)(*v11 + 112) > *(_QWORD *)(v14 + 112))
        break;
    }
  }
  v22 = (std::__shared_weak_count *)v17[1];
  *v17 = v14;
  v17[1] = v15;
  if (v22)
  {
    v23 = (unint64_t *)&v22->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
}

void std::__pop_heap[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices,std::shared_ptr<HGGPUComputeDevice const> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  int64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  __int128 v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  __int128 v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  __int128 v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  __int128 v33;
  __int128 v34;

  if (a4 < 2)
    return;
  v8 = 0;
  v33 = *(_OWORD *)a1;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v9 = (unint64_t)(a4 - 2) >> 1;
  v10 = (_QWORD *)a1;
  do
  {
    v11 = v10;
    v10 += 2 * v8 + 2;
    if (2 * v8 + 2 >= a4)
    {
      v8 = (2 * v8) | 1;
      v15 = *v10;
      v16 = v10[1];
      *v10 = 0;
      v10[1] = 0;
      v14 = (std::__shared_weak_count *)v11[1];
      *v11 = v15;
      v11[1] = v16;
      if (!v14)
        continue;
    }
    else
    {
      v12 = *v10;
      if (*(_QWORD *)(*v10 + 112) <= *(_QWORD *)(v10[2] + 112))
      {
        v8 = (2 * v8) | 1;
      }
      else
      {
        v12 = v10[2];
        v10 += 2;
        v8 = 2 * v8 + 2;
      }
      v13 = v10[1];
      *v10 = 0;
      v10[1] = 0;
      v14 = (std::__shared_weak_count *)v11[1];
      *v11 = v12;
      v11[1] = v13;
      if (!v14)
        continue;
    }
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  while (v8 <= v9);
  if (v10 == (_QWORD *)(a2 - 16))
  {
    v29 = v33;
    v34 = 0uLL;
    v30 = (std::__shared_weak_count *)v10[1];
    *(_OWORD *)v10 = v29;
    if (v30)
    {
      v31 = (unint64_t *)&v30->__shared_owners_;
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
  }
  else
  {
    v19 = *(_OWORD *)(a2 - 16);
    *(_QWORD *)(a2 - 16) = 0;
    *(_QWORD *)(a2 - 8) = 0;
    v20 = (std::__shared_weak_count *)v10[1];
    *(_OWORD *)v10 = v19;
    if (v20)
    {
      v21 = (unint64_t *)&v20->__shared_owners_;
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    v23 = v33;
    v34 = 0uLL;
    v24 = *(std::__shared_weak_count **)(a2 - 8);
    *(_OWORD *)(a2 - 16) = v23;
    if (v24)
    {
      v25 = (unint64_t *)&v24->__shared_owners_;
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(a1, (uint64_t)(v10 + 2), a3, ((uint64_t)v10 - a1 + 16) >> 4);
  }
  if (*((_QWORD *)&v34 + 1))
  {
    v27 = (unint64_t *)(*((_QWORD *)&v34 + 1) + 8);
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v34 + 1) + 16))(*((_QWORD *)&v34 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v34 + 1));
    }
  }
}

void sub_1B2A40684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;

  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v6 = v4 >> 1;
    v7 = (_QWORD *)(a1 + 16 * (v4 >> 1));
    v8 = (_QWORD *)(a2 - 16);
    v9 = *(_QWORD *)(a2 - 16);
    if (*(_QWORD *)(*v7 + 112) > *(_QWORD *)(v9 + 112))
    {
      v10 = *(_QWORD *)(a2 - 8);
      *v8 = 0;
      *(_QWORD *)(a2 - 8) = 0;
      v11 = *v7;
      do
      {
        v12 = v7;
        v13 = v7[1];
        *v12 = 0;
        v12[1] = 0;
        v14 = (std::__shared_weak_count *)v8[1];
        *v8 = v11;
        v8[1] = v13;
        if (v14)
        {
          p_shared_owners = (unint64_t *)&v14->__shared_owners_;
          do
            v16 = __ldaxr(p_shared_owners);
          while (__stlxr(v16 - 1, p_shared_owners));
          if (!v16)
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
        }
        if (!v6)
          break;
        v6 = (v6 - 1) >> 1;
        v7 = (_QWORD *)(a1 + 16 * v6);
        v11 = *v7;
        v8 = v12;
      }
      while (*(_QWORD *)(*v7 + 112) > *(_QWORD *)(v9 + 112));
      v17 = (std::__shared_weak_count *)v12[1];
      *v12 = v9;
      v12[1] = v10;
      if (v17)
      {
        v18 = (unint64_t *)&v17->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
    }
  }
}

uint64_t OUTLINED_FUNCTION_0_1()
{
  uint64_t v0;

  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v0 + 16))(v0);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<CreateComputeDeviceList(void)::$_0 &&>>(std::__shared_weak_count *a1)
{
  unint64_t *p_shared_owners;
  unint64_t v3;

  p_shared_owners = (unint64_t *)&a1->__shared_owners_;
  do
    v3 = __ldaxr(p_shared_owners);
  while (__stlxr(v3 - 1, p_shared_owners));
  if (!v3)
  {
    OUTLINED_FUNCTION_0_1();
    std::__shared_weak_count::__release_weak(a1);
  }
}

uint64_t HGFormatUtils::toGLInternalFormat(int a1)
{
  return s_HGFormatInfos[8 * a1];
}

uint64_t HGFormatUtils::toGLFormat(int a1)
{
  return s_HGFormatInfos[8 * a1 + 1];
}

uint64_t HGFormatUtils::toGLType(int a1)
{
  return s_HGFormatInfos[8 * a1 + 2];
}

uint64_t HGFormatUtils::toString(int a1)
{
  return *(_QWORD *)&s_HGFormatInfos[8 * a1 + 6];
}

uint64_t HGFormatUtils::RGBtoRGBA(uint64_t result, const char *a2, char *a3)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;

  v3 = result;
  v4 = s_HGFormatInfos[8 * result + 1];
  if (v4 - 6403 > 7)
    goto LABEL_9;
  if (((1 << (v4 - 3)) & 0xE9) != 0)
    return result;
  if (v4 == 6407)
  {
    v5 = s_HGFormatInfos[8 * result + 2];
    switch(v5)
    {
      case 0x1403u:
        return 25;
      case 0x1406u:
        return 28;
      case 0x8D61u:
        return 27;
      default:
        return 24;
    }
  }
  else
  {
LABEL_9:
    if (v4 != 32993 && v4 != 33319)
    {
      HGLogger::warning((HGLogger *)"componentsPerPixel -- unknown GL format", a2, a3);
      return v3;
    }
  }
  return result;
}

uint64_t HGFormatUtils::precision(int a1)
{
  unsigned int v1;

  v1 = s_HGFormatInfos[8 * a1 + 2];
  switch(v1)
  {
    case 0x1403u:
      return 2;
    case 0x1406u:
      return 8;
    case 0x8D61u:
      return 4;
  }
  return 1;
}

uint64_t HGFormatUtils::bytesPerPixel(int a1)
{
  if (a1 <= 41)
    return s_HGFormatInfos[8 * a1 + 3];
  else
    return 0;
}

uint64_t HGFormatUtils::tileWidthFactorRequirement(int a1)
{
  if (a1 == 31)
    return 6;
  else
    return 2;
}

uint64_t HGFormatUtils::GLFormatToByteSize(HGFormatUtils *this, const char *a2, char *a3)
{
  int v3;
  unsigned int v4;

  v3 = (int)a2;
  v4 = 1;
  switch((int)this)
  {
    case 6403:
    case 6406:
    case 6409:
      goto LABEL_9;
    case 6404:
    case 6405:
      goto LABEL_16;
    case 6407:
      v4 = 3;
      if ((int)a2 <= 5125)
        goto LABEL_17;
      goto LABEL_10;
    case 6408:
      goto LABEL_8;
    case 6410:
      goto LABEL_6;
    default:
      if ((_DWORD)this == 32993)
      {
LABEL_8:
        v4 = 4;
LABEL_9:
        if ((int)a2 <= 5125)
          goto LABEL_17;
      }
      else if ((_DWORD)this == 33319)
      {
LABEL_6:
        v4 = 2;
        if ((int)a2 <= 5125)
          goto LABEL_17;
      }
      else
      {
LABEL_16:
        HGLogger::warning((HGLogger *)"componentsPerPixel -- unknown GL format", a2, a3);
        v4 = 1;
        if (v3 <= 5125)
        {
LABEL_17:
          if (v3 == 5121)
            return v4;
          if (v3 == 5123)
            return 2 * v4;
          goto LABEL_13;
        }
      }
LABEL_10:
      if (v3 == 5126)
        return 4 * v4;
      if (v3 == 34235)
        return v4;
      if (v3 != 36193)
      {
LABEL_13:
        HGLogger::warning((HGLogger *)"bytesPerComponent -- unknown GL type", a2, a3);
        return v4;
      }
      return 2 * v4;
  }
}

const char *HGFormatUtils::GLPixelFormatToString(HGFormatUtils *this, const char *a2, char *a3)
{
  uint64_t v3;
  uint64_t v4;
  const char *result;

  if ((int)this > 32992)
  {
    if ((_DWORD)this == 32993)
    {
      return "GL_BGRA";
    }
    else if ((_DWORD)this == 33319)
    {
      return "GL_RG";
    }
    else
    {
LABEL_9:
      HGLogger::warning((HGLogger *)"HGFormatUtils::GLPixelFormatToString -- unknown GL format", a2, a3, v3, v4);
      return "";
    }
  }
  else
  {
    switch((int)this)
    {
      case 6402:
        result = "GL_DEPTH_COMPONENT";
        break;
      case 6403:
        result = "GL_RED";
        break;
      case 6404:
      case 6405:
        goto LABEL_9;
      case 6406:
        result = "GL_ALPHA";
        break;
      case 6407:
        result = "GL_RGB";
        break;
      case 6408:
        result = "GL_RGBA";
        break;
      case 6409:
        result = "GL_LUMINANCE";
        break;
      case 6410:
        result = "GL_LUMINANCE_ALPHA";
        break;
      default:
        if ((_DWORD)this)
          goto LABEL_9;
        result = "(null)";
        break;
    }
  }
  return result;
}

const char *HGFormatUtils::GLPixelTypeToString(HGFormatUtils *this, const char *a2, char *a3)
{
  uint64_t v3;
  uint64_t v4;
  const char *result;

  if ((int)this > 34234)
  {
    if ((_DWORD)this == 34235)
    {
      return "GL_UNSIGNED_SHORT_8_8_REV_APPLE";
    }
    else if ((_DWORD)this == 36193)
    {
      return "GL_HALF";
    }
    else
    {
LABEL_9:
      HGLogger::warning((HGLogger *)"HGFormatUtils::GLPixelTypeToString -- unknown GL type", a2, a3, v3, v4);
      return "";
    }
  }
  else
  {
    switch((int)this)
    {
      case 5121:
        result = "GL_UNSIGNED_BYTE";
        break;
      case 5122:
      case 5124:
        goto LABEL_9;
      case 5123:
        result = "GL_UNSIGNED_SHORT";
        break;
      case 5125:
        result = "GL_UNSIGNED_INT";
        break;
      case 5126:
        result = "GL_FLOAT";
        break;
      default:
        if ((_DWORD)this)
          goto LABEL_9;
        result = "(null)";
        break;
    }
  }
  return result;
}

uint64_t HGFormatUtils::isPackedFormat(unsigned int a1)
{
  return (a1 < 0x20) & (0x8001C000 >> a1);
}

unint64_t HGFormatUtils::collapseRectForFormat(uint64_t *a1, int a2)
{
  uint64_t v2;

  v2 = *a1;
  if ((a2 - 14) < 3)
    return v2 & 0xFFFFFFFF00000000 | vcvtms_s32_f32((float)(int)v2 * 0.5);
  if (a2 == 31)
    return v2 & 0xFFFFFFFF00000000 | vcvts_n_s32_f32(floorf((float)(int)v2 / 6.0), 2uLL);
  return v2 & 0xFFFFFFFF00000000 | *a1;
}

HGFormatUtils *HGFormatUtils::adjustPrecision(HGFormatUtils *this, unsigned int a2)
{
  unsigned __int8 v4;
  unsigned __int8 v5;
  unint64_t v6;
  HGFormatUtils *result;
  uint64_t v8;
  unsigned int *v9;
  uint64_t **v10;
  _QWORD *v11;
  unsigned int v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t **v19;
  uint64_t **v20;
  unsigned int v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t *v24;
  _QWORD *v25;
  _QWORD *v26;
  char v27;
  char **v28;
  char *v29;

  v4 = atomic_load((unsigned __int8 *)&qword_1ED4DA9B8);
  if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9B8))
  {
    v25 = (_QWORD *)operator new();
    v25[1] = 0;
    v25[2] = 0;
    *v25 = v25 + 1;
    _MergedGlobals_10 = (uint64_t)v25;
    __cxa_guard_release(&qword_1ED4DA9B8);
  }
  v5 = atomic_load((unsigned __int8 *)&qword_1ED4DA9C8);
  if ((v5 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9C8))
  {
    v26 = (_QWORD *)operator new();
    v26[1] = 0;
    v26[2] = 0;
    *v26 = v26 + 1;
    qword_1ED4DA9C0 = (uint64_t)v26;
    __cxa_guard_release(&qword_1ED4DA9C8);
  }
  v6 = atomic_load(&qword_1ED4DA9D0);
  if (v6 != -1)
  {
    v29 = &v27;
    v28 = &v29;
    std::__call_once(&qword_1ED4DA9D0, &v28, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGFormatUtils::adjustPrecision(unsigned int,unsigned int)::$_0 &&>>);
  }
  result = 0;
  if ((_DWORD)this && a2)
  {
    if ((a2 & this) != 0)
    {
      return this;
    }
    else
    {
      v8 = _MergedGlobals_10;
      v10 = (uint64_t **)(_MergedGlobals_10 + 8);
      v9 = *(unsigned int **)(_MergedGlobals_10 + 8);
      if (v9)
      {
        while (1)
        {
          while (1)
          {
            v11 = v9;
            v12 = v9[7];
            if (v12 <= this)
              break;
            v9 = (unsigned int *)*v11;
            v10 = (uint64_t **)v11;
            if (!*v11)
              goto LABEL_17;
          }
          if (v12 >= this)
            break;
          v9 = (unsigned int *)v11[1];
          if (!v9)
          {
            v10 = (uint64_t **)(v11 + 1);
            goto LABEL_17;
          }
        }
      }
      else
      {
        v11 = (_QWORD *)(_MergedGlobals_10 + 8);
LABEL_17:
        v13 = v11;
        v11 = operator new(0x28uLL);
        *((_DWORD *)v11 + 7) = (_DWORD)this;
        *((_DWORD *)v11 + 8) = 0;
        *v11 = 0;
        v11[1] = 0;
        v11[2] = v13;
        *v10 = v11;
        v14 = **(_QWORD **)v8;
        v15 = v11;
        if (v14)
        {
          *(_QWORD *)v8 = v14;
          v15 = *v10;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v8 + 8), v15);
        ++*(_QWORD *)(v8 + 16);
      }
      v16 = *((unsigned int *)v11 + 8);
      v17 = qword_1ED4DA9C0;
      v19 = (uint64_t **)(qword_1ED4DA9C0 + 8);
      v18 = *(uint64_t **)(qword_1ED4DA9C0 + 8);
      if (v18)
      {
        while (1)
        {
          while (1)
          {
            v20 = (uint64_t **)v18;
            v21 = *((_DWORD *)v18 + 8);
            if (v21 <= a2)
              break;
            v18 = *v20;
            v19 = v20;
            if (!*v20)
              goto LABEL_27;
          }
          if (v21 >= a2)
            break;
          v18 = v20[1];
          if (!v18)
          {
            v19 = v20 + 1;
            goto LABEL_27;
          }
        }
      }
      else
      {
        v20 = (uint64_t **)(qword_1ED4DA9C0 + 8);
LABEL_27:
        v22 = (uint64_t *)v20;
        v20 = (uint64_t **)operator new(0x40uLL);
        *((_DWORD *)v20 + 8) = a2;
        v20[6] = 0;
        v20[7] = 0;
        v20[5] = 0;
        *v20 = 0;
        v20[1] = 0;
        v20[2] = v22;
        *v19 = (uint64_t *)v20;
        v23 = **(_QWORD **)v17;
        v24 = (uint64_t *)v20;
        if (v23)
        {
          *(_QWORD *)v17 = v23;
          v24 = *v19;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v17 + 8), v24);
        ++*(_QWORD *)(v17 + 16);
      }
      return (HGFormatUtils *)*((unsigned int *)v20[5] + v16);
    }
  }
  return result;
}

void sub_1B2A41050(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1ED4DA9C8);
  _Unwind_Resume(a1);
}

void sub_1B2A41068(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1ED4DA9B8);
  _Unwind_Resume(a1);
}

uint64_t HGFormatUtils::buildFormat(int a1, int a2)
{
  int v2;

  v2 = a2 - 1;
  if ((a2 - 1) <= 7 && ((0x8Bu >> v2) & 1) != 0)
    return *((unsigned int *)*(&off_1E65244C8 + v2) + a1 - 1);
  else
    return 0;
}

uint64_t HGGPURenderer::UpdateLimits(HGGPURenderer *this, HGLimits *a2, int a3)
{
  int v3;
  BOOL v4;
  char v5;
  _BYTE *v6;
  char v7;
  __int16 v8;

  v3 = a3 & 0xF0000;
  if ((a3 & 0xFF00) != 0xB00)
  {
    *(_OWORD *)((char *)a2 + 20) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *(_OWORD *)((char *)a2 + 4) = 0u;
    *(_DWORD *)a2 = a3;
    if (v3 == 393216)
      v8 = 64;
    else
      v8 = 128;
    *((_WORD *)a2 + 10) = -1;
    *((_WORD *)a2 + 11) = v8;
    *((_WORD *)a2 + 12) = -1;
    v6 = (char *)a2 + 40;
    *((_WORD *)a2 + 21) = -1;
    *((_WORD *)a2 + 18) = 8;
    goto LABEL_14;
  }
  *((_DWORD *)a2 + 9) = 8;
  *(_DWORD *)a2 = a3;
  *(_DWORD *)((char *)a2 + 30) = 0;
  *(_QWORD *)((char *)a2 + 12) = 0;
  *(_QWORD *)((char *)a2 + 4) = 0;
  *((_DWORD *)a2 + 5) = -1;
  *((_DWORD *)a2 + 11) = -1;
  *((_WORD *)a2 + 17) = 0;
  *((_BYTE *)a2 + 41) = 0;
  *((_BYTE *)a2 + 43) = 0;
  *((_WORD *)a2 + 12) = -1;
  *(_DWORD *)((char *)a2 + 26) = -256;
  v4 = v3 == 393216;
  if (v3 == 393216)
    v5 = 31;
  else
    v5 = 0;
  *((_BYTE *)a2 + 40) = v5;
  v6 = (char *)a2 + 40;
  if (v4)
    v7 = 4;
  else
    v7 = 60;
  *((_BYTE *)a2 + 42) = v7;
  if (v4)
LABEL_14:
    *v6 = 8;
  return HGLimits::setnormalized((uint64_t)a2, 1);
}

_QWORD *PBOStrategy::PBOStageSetBuffer::operator()(_QWORD *result)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;

  v1 = result[1];
  v2 = (_QWORD *)result[4];
  if (v2)
    result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*v2 + 16))(result[4]);
  v5 = v2;
  v3 = *(_QWORD **)(v1 + 8);
  if ((unint64_t)v3 >= *(_QWORD *)(v1 + 16))
  {
    v4 = std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>((void **)v1, &v5);
    result = v5;
    *(_QWORD *)(v1 + 8) = v4;
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 24))(result);
  }
  else
  {
    *v3 = v2;
    *(_QWORD *)(v1 + 8) = v3 + 1;
  }
  return result;
}

void sub_1B2A41220(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(exception_object);
}

void PBOStrategy::PBOStageReadPixels::operator()(uint64_t a1, int a2)
{
  signed int v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  HGRect v10;
  HGRect v11;

  v3 = a2 % ((*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8) - **(_QWORD **)(a1 + 24)) >> 3);
  v4 = (uint64_t *)(**(_QWORD **)(a1 + 16) + 16 * a2);
  v5 = *(_QWORD *)(**(_QWORD **)(a1 + 8) + 8 * a2);
  v6 = HGRectIntersection(*v4, v4[1], *(_QWORD *)(v5 + 20), *(_QWORD *)(v5 + 28));
  v8 = v7;
  HGPixelBufferObj::padding(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 8 * v3), *(_DWORD *)(a1 + 32));
  v9 = *(_DWORD *)(v5 + 12);
  if ((v9 & 0x10) != 0)
  {
    if ((v9 & 0x100) != 0)
    {
      *(_QWORD *)&v11.var0 = v6;
      *(_QWORD *)&v11.var2 = v8;
      HGGLBuffer::ReadPixels((HGGLBuffer *)v5, *(HGPixelBufferObj **)(**(_QWORD **)(a1 + 24) + 8 * v3), v11);
    }
    else if ((v9 & 0x200) != 0)
    {
      *(_QWORD *)&v10.var0 = v6;
      *(_QWORD *)&v10.var2 = v8;
      HGGLTexture::ReadPixels((HGGLTexture *)v5, *(HGPixelBufferObj **)(**(_QWORD **)(a1 + 24) + 8 * v3), v10);
    }
  }
}

uint64_t PBOStrategy::PBOStageMapBuffer::operator()(uint64_t a1, int a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t result;

  HGPixelBufferObj::GetDataPtr(*(HGPixelBufferObj **)(**(_QWORD **)(a1 + 24)
                                                    + 8
                                                    * (int)(a2
                                                          % ((*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8)
                                                                          - **(_QWORD **)(a1 + 24)) >> 3))));
  v4 = *(uint64_t **)(a1 + 8);
  v5 = *v4;
  result = *(_QWORD *)(*v4 + 8 * a2);
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
    *(_QWORD *)(v5 + 8 * a2) = 0;
  }
  return result;
}

void PBOStrategy::PBOStageStartCopy::operator()(uint64_t a1, unsigned int a2)
{
  HGPixelBufferObj::StartCopyBitmap(*(HGPixelBufferObj **)(**(_QWORD **)(a1 + 24)+ 8* (int)(a2% ((*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8) - **(_QWORD **)(a1 + 24)) >> 3))), *(HGBitmap **)(a1 + 32));
}

uint64_t PBOStrategy::PBOStageFinishCopy::operator()(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = **(_QWORD **)(a1 + 24);
  v4 = 8 * (int)(a2 % ((unint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8) - v3) >> 3));
  HGPixelBufferObj::FinishCopyBitmap(*(_QWORD *)(v3 + v4));
  return HGPixelBufferObj::ReleaseDataPtr(*(HGPixelBufferObj **)(**(_QWORD **)(a1 + 24) + v4));
}

void HGGPURenderer::Init(HGGPURenderer *this, const char *a2, char *a3)
{
  HGTransform *v4;
  HGGLShaderCache *v5;
  HGGLContext *v6;
  HGGLState *v7;
  HGGLContext *v8;
  PC_Sp_counted_base *v9;
  PCSharedCount *v10;
  PC_Sp_counted_base *v11;
  const char *v12;
  char *v13;
  HGTextureManager *v14;
  const char *v15;
  char *v16;
  void *v17;
  void *v18;
  HGGLHandler *v19;
  HGTextureManager *v20;
  PCICCTransferFunctionLUT *v21;
  HGGPUResources *LUTEnd;
  const HGMetalDeviceInfo *v23;
  HGGPUResources *DeviceResources;
  CVOpenGLESTextureCacheRef *v25;
  HGMetalDeviceInfo *v26;
  uint64_t v27;
  PCSharedCount v28;
  PCSharedCount v29;
  uint64_t v30;
  PCSharedCount v31;
  GLuint framebuffers;
  GLint params[2];

  if (!*((_QWORD *)this + 139))
  {
    *((_BYTE *)this + 809) = 0;
    HGLogger::warning((HGLogger *)"Failed to initialize Metal device.", a2, a3);
  }
  v4 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v4);
  *((_QWORD *)this + 151) = v4;
  *((_DWORD *)this + 335) = 1;
  GLPBO::forcePostReadPixelsFence(HG_RENDERER_ENV::FORCE_POST_READPIXELS_FENCE);
  GLPBO::forcePostReadPixelsFinish(HG_RENDERER_ENV::FORCE_POST_READPIXELS_FINISH);
  v5 = (HGGLShaderCache *)operator new();
  HGGLShaderCache::HGGLShaderCache(v5);
  *((_QWORD *)this + 161) = v5;
  HGGLShaderCache::SetCapacity(v5, 4096);
  HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v29, 0);
  v6 = (HGGLContext *)*((_QWORD *)this + 143);
  if (v6 && HGGLContext::ptr(v6))
  {
    v7 = (HGGLState *)operator new();
    HGGLState::HGGLState(v7);
    *((_QWORD *)this + 146) = v7;
    HGGLGetCurrentContext();
    v29.var0 = *(PC_Sp_counted_base **)params;
    PCSharedCount::PCSharedCount((PCSharedCount *)params);
    HGGLContext::setCurrent(*((HGGLContext **)this + 143));
    v8 = (HGGLContext *)*((_QWORD *)this + 143);
    if (v8)
      (*(void (**)(_QWORD))(*(_QWORD *)v8 + 16))(*((_QWORD *)this + 143));
    if (HGGLContext::isAccelerated(v8))
    {
      HGGLContext::context((uint64_t *)&v31, v8);
      HGGLContext::Create((uint64_t *)&v31, (HGObject **)params);
      v9 = *(PC_Sp_counted_base **)params;
      if (*(_QWORD *)params)
      {
        *(_QWORD *)params = 0;
        PCSharedCount::PCSharedCount(&v31);
        HGGLContext::getVirtualScreen(v8);
        HGGLContext::setVirtualScreen((HGGLContext *)v9);
        HGGLContext::context(&v30, (HGGLContext *)v9);
        *(_QWORD *)params = v30;
        HGGLSetCurrentContext((PC_Sp_counted_base **)params);
        PCSharedCount::PCSharedCount((PCSharedCount *)params);
        glColorMask(1u, 1u, 1u, 1u);
        glDepthMask(0);
        glStencilMask(0);
        glDisable(0xB71u);
        glDisable(0xB90u);
        glDisable(0xBE2u);
        glDisable(0xB44u);
        glDisable(0xBD0u);
        framebuffers = 0;
        glGenFramebuffers(1, &framebuffers);
        glBindFramebuffer(0x8D40u, framebuffers);
        v10 = (PCSharedCount *)&v30;
      }
      else
      {
        v10 = &v31;
      }
      PCSharedCount::PCSharedCount(v10);
      v11 = (PC_Sp_counted_base *)*((_QWORD *)this + 144);
      if (v11 == v9)
      {
LABEL_16:
        if (v9)
          (*(void (**)(PC_Sp_counted_base *))(*(_QWORD *)v9 + 24))(v9);
LABEL_18:
        if (v8)
          (*(void (**)(HGGLContext *))(*(_QWORD *)v8 + 24))(v8);
        if (!HGGLContext::ptr(*((HGGLContext **)this + 144)))
        {
          *((_BYTE *)this + 809) = 0;
          HGLogger::warning((HGLogger *)"Failed to create internal GL Context.", v12, v13);
        }
        goto LABEL_22;
      }
    }
    else
    {
      v9 = 0;
      v11 = (PC_Sp_counted_base *)*((_QWORD *)this + 144);
      if (!v11)
        goto LABEL_16;
    }
    if (v11)
      (*(void (**)(PC_Sp_counted_base *))(*(_QWORD *)v11 + 24))(v11);
    *((_QWORD *)this + 144) = v9;
    goto LABEL_18;
  }
LABEL_22:
  if (*((_BYTE *)this + 809))
  {
    v14 = (HGTextureManager *)*((_QWORD *)this + 184);
    if (v14 && !HGTextureManager::init(v14))
    {
      *((_BYTE *)this + 809) = 0;
      HGLogger::warning((HGLogger *)"Failed to initialize texture manager.", v15, v16);
    }
    if (*((_BYTE *)this + 809))
    {
      if (*((_BYTE *)this + 1281))
      {
        HGGLContext::context((uint64_t *)&v31, *((HGGLContext **)this + 144));
        v17 = HGObject::operator new(0x20uLL);
        *(PCSharedCount *)params = v31;
        HGCVGLTextureFactory::HGCVGLTextureFactory(v17, params, 0.5);
        PCSharedCount::PCSharedCount((PCSharedCount *)params);
        v18 = (void *)*((_QWORD *)this + 147);
        if (v18 == v17)
        {
          if (v17)
            (*(void (**)(void *))(*(_QWORD *)v17 + 24))(v17);
        }
        else
        {
          if (v18)
            (*(void (**)(void *))(*(_QWORD *)v18 + 24))(v18);
          *((_QWORD *)this + 147) = v17;
        }
        PCSharedCount::PCSharedCount(&v31);
        HGGLContext::setCurrent(*((HGGLContext **)this + 144));
        params[0] = 0;
        glGetIntegerv(0x8D57u, params);
        *((_DWORD *)this + 356) = params[0];
        (*(void (**)(HGGPURenderer *))(*(_QWORD *)this + 288))(this);
      }
      *((_QWORD *)this + 102) = HGRenderer::GetCachedLimits(this, 394768);
      *((_QWORD *)this + 103) = HGRenderer::GetCachedLimits(this, 329232);
      *((_QWORD *)this + 162) = 0;
      v19 = (HGGLHandler *)operator new();
      HGGLHandler::HGGLHandler(v19);
      *(_QWORD *)v19 = &unk_1E65238D8;
      *((_QWORD *)this + 163) = v19;
      v20 = (HGTextureManager *)*((_QWORD *)this + 184);
      if (v20)
      {
        HGTextureManager::finishDeleteTextureQueue(v20);
        HGGPURenderer::PurgePostDeleteEvents((int64x2_t *)this);
        HGTextureManager::emptyTexturePool(*((HGTextureManager **)this + 184));
        v21 = (PCICCTransferFunctionLUT *)*((_QWORD *)this + 139);
        if (v21)
        {
          LUTEnd = (HGGPUResources *)PCICCTransferFunctionLUT::getLUTEnd(v21);
          DeviceResources = HGGPUResources::getDeviceResources(LUTEnd, v23);
          if (DeviceResources)
            HGGPUResources::releaseFreeObjects(DeviceResources);
        }
        v25 = (CVOpenGLESTextureCacheRef *)*((_QWORD *)this + 147);
        if (v25)
          HGCVGLTextureFactory::flush(v25);
      }
      HGGPURenderer::InitMetal(this);
      v26 = (HGMetalDeviceInfo *)PCICCTransferFunctionLUT::getLUTEnd(*((PCICCTransferFunctionLUT **)this + 139));
      if (HGMetalDeviceInfo::isIntel(v26))
        *((_BYTE *)this + 1264) = 2;
      v27 = *((_QWORD *)this + 184);
      if (v27 && HG_RENDERER_ENV::FORCE_RECYCLE_SHARED_TEXTURES != -1)
      {
        HGTextureManager::recycleClientStorageTextures(v27, HG_RENDERER_ENV::FORCE_RECYCLE_SHARED_TEXTURES != 0);
        v27 = *((_QWORD *)this + 184);
      }
      if (v27 && HG_RENDERER_ENV::CLIENT_STORAGE_RECYCLING_POLICY != -1)
        HGTextureManager::storageRecyclingPolicy(v27, HG_RENDERER_ENV::CLIENT_STORAGE_RECYCLING_POLICY);
      if (HG_RENDERER_ENV::FORCE_TEXTURE_STORAGE_HINT != -1)
        *((_BYTE *)this + 1264) = HG_RENDERER_ENV::FORCE_TEXTURE_STORAGE_HINT;
      HGGPURenderer::InitDefaultPageSize((PCICCTransferFunctionLUT **)this);
    }
  }
  if (PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v29))
  {
    v28.var0 = v29.var0;
    HGGLSetCurrentContext(&v28.var0);
    PCSharedCount::PCSharedCount(&v28);
  }
  PCSharedCount::PCSharedCount(&v29);
}

void sub_1B2A418CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10, PCSharedCount a11, PCSharedCount a12, uint64_t a13, PCSharedCount a14)
{
  uint64_t v14;

  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
  PCSharedCount::PCSharedCount(&a12);
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

void sub_1B2A41974()
{
  JUMPOUT(0x1B2A41A44);
}

void sub_1B2A4197C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  uint64_t v10;

  MEMORY[0x1B5E29170](v10, 0x10A1C40F99B7576);
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

void sub_1B2A419B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  uint64_t v10;

  MEMORY[0x1B5E29170](v10, 0x10A0C40B3F59724);
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

void sub_1B2A419E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount((PCSharedCount *)&a9);
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

void sub_1B2A41A00(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10B2C40048180CFLL);
  _Unwind_Resume(a1);
}

void sub_1B2A41A24(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A41A74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

_QWORD *HGGPURenderer::HGGPURenderer(_QWORD *a1, PC_Sp_counted_base **a2, int a3)
{
  uint64_t v6;
  HGGLContext **v7;
  HGGLContext *v8;
  HGObject *v9;
  _QWORD *v10;
  int VirtualScreen;
  HGTextureManager *v12;
  HGMetalDeviceInfo *v13;
  const HGMetalDeviceInfo *MainDevice;
  HGMetalContext *v15;
  const char *v16;
  char *v17;
  HGMetalContext *v18;
  PCSharedCount v20;
  HGGLContext *v21;

  HGRenderer::HGRenderer((HGRenderer *)a1);
  *(_OWORD *)(v6 + 1128) = 0u;
  *(_QWORD *)v6 = off_1E65240A0;
  *(_OWORD *)(v6 + 1104) = 0u;
  *(_QWORD *)(v6 + 1120) = v6 + 1128;
  v7 = (HGGLContext **)(v6 + 1144);
  *(_OWORD *)(v6 + 1144) = 0u;
  *(_DWORD *)(v6 + 1160) = 0;
  *(_OWORD *)(v6 + 1168) = 0u;
  *(_OWORD *)(v6 + 1184) = 0u;
  *(_DWORD *)(v6 + 1200) = 0;
  *(_OWORD *)(v6 + 1208) = 0u;
  *(_OWORD *)(v6 + 1224) = 0u;
  *(_QWORD *)(v6 + 1240) = 0xFFFFFFFFLL;
  *(_DWORD *)(v6 + 1248) = 2048;
  *(_QWORD *)(v6 + 1256) = 0;
  *(_WORD *)(v6 + 1264) = 257;
  *(_BYTE *)(v6 + 1266) = 1;
  *(_DWORD *)(v6 + 1268) = 1;
  *(_QWORD *)(v6 + 1272) = 0;
  *(_WORD *)(v6 + 1280) = 257;
  *(_OWORD *)(v6 + 1304) = 0u;
  *(_OWORD *)(v6 + 1320) = 0u;
  *(_OWORD *)(v6 + 1288) = 0u;
  *(_BYTE *)(v6 + 1336) = 1;
  *(_OWORD *)(v6 + 1340) = 0u;
  *(_OWORD *)(v6 + 1356) = 0u;
  *(_OWORD *)(v6 + 1372) = 0u;
  *(_OWORD *)(v6 + 1388) = 0u;
  *(_OWORD *)(v6 + 1404) = 0u;
  *(_QWORD *)(v6 + 1420) = 0;
  *(_DWORD *)(v6 + 1428) = -1;
  *(_QWORD *)(v6 + 1432) = 0;
  *(_QWORD *)(v6 + 1448) = 0;
  *(_QWORD *)(v6 + 1456) = 0;
  *(_QWORD *)(v6 + 1440) = v6 + 1448;
  *(_DWORD *)(v6 + 1464) = 0;
  *(_QWORD *)(v6 + 1472) = 0;
  v20.var0 = *a2;
  HGGLContext::Share((uint64_t *)&v20, (HGObject **)&v21);
  v8 = *v7;
  v9 = (HGObject *)v21;
  if (*v7 == v21)
  {
    if (v8)
      (*(void (**)(HGGLContext *))(*(_QWORD *)v8 + 24))(v8);
  }
  else
  {
    if (v8)
    {
      (*(void (**)(HGGLContext *))(*(_QWORD *)v8 + 24))(v8);
      v9 = (HGObject *)v21;
    }
    *v7 = (HGGLContext *)v9;
    v21 = 0;
  }
  v10 = a1 + 138;
  PCSharedCount::PCSharedCount(&v20);
  if (a3)
  {
    VirtualScreen = HGGLContext::getVirtualScreen(*v7);
    *v10 = VirtualScreen + 1;
    if (VirtualScreen == -1)
    {
LABEL_9:
      v12 = (HGTextureManager *)operator new();
      v13 = HGTextureManager::HGTextureManager(v12, (HGGPURenderer *)a1);
      goto LABEL_12;
    }
  }
  else if (!*v10)
  {
    goto LABEL_9;
  }
  v12 = (HGTextureManager *)operator new();
  v13 = HGTextureManager::HGTextureManager(v12, (HGGPURenderer *)a1, (void *)a1[138]);
LABEL_12:
  a1[184] = v12;
  MainDevice = (const HGMetalDeviceInfo *)HGMetalDeviceInfo::getMainDevice(v13);
  v15 = (HGMetalContext *)HGObject::operator new(0x68uLL);
  HGMetalContext::HGMetalContext(v15, MainDevice);
  v18 = (HGMetalContext *)a1[139];
  if (v18 == v15)
  {
    if (v15)
      (*(void (**)(HGMetalContext *))(*(_QWORD *)v15 + 24))(v15);
  }
  else
  {
    if (v18)
      (*(void (**)(HGMetalContext *))(*(_QWORD *)v18 + 24))(v18);
    a1[139] = v15;
  }
  HGGPURenderer::Init((HGGPURenderer *)a1, v16, v17);
  return a1;
}

void sub_1B2A41CC8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  MEMORY[0x1B5E29170](v3, 0x10A0C406BFFB60BLL);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1 + 1440, *(_QWORD **)(v1 + 1448));
  std::deque<HGNode *>::~deque[abi:ne180100](v1 + 1376);
  v6 = *(void **)(v1 + 1216);
  if (v6)
  {
    *(_QWORD *)(v1 + 1224) = v6;
    operator delete(v6);
  }
  v7 = *(_QWORD *)(v1 + 1176);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  v8 = *(_QWORD *)(v1 + 1152);
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
  if (*v4)
    (*(void (**)(_QWORD))(*(_QWORD *)*v4 + 24))(*v4);
  std::__tree<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::__map_value_compare<HGMetalDeviceInfo const*,std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::less<HGMetalDeviceInfo const*>,true>,std::allocator<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>>>::destroy(v2, *(_QWORD **)(v1 + 1128));
  v9 = *(_QWORD *)(v1 + 1112);
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  HGRenderer::~HGRenderer((HGRenderer *)v1);
  _Unwind_Resume(a1);
}

_QWORD *HGGPURenderer::HGGPURenderer(_QWORD *a1, PC_Sp_counted_base **a2)
{
  PCSharedCount v4;

  v4.var0 = *a2;
  HGGPURenderer::HGGPURenderer(a1, &v4.var0, 0);
  PCSharedCount::PCSharedCount(&v4);
  return a1;
}

void sub_1B2A41E40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

int64x2_t *HGGPURenderer::PurgePostDeleteEvents(int64x2_t *this)
{
  uint64_t v1;
  int64x2_t *v2;
  pthread_mutex_t *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  v1 = this[92].i64[0];
  if (v1)
  {
    v2 = this;
    v3 = *(pthread_mutex_t **)(v1 + 112);
    HGTextureManager::PostTextureDeleteEventList::lock(v3);
    while (HGTextureManager::PostTextureDeleteEventList::hasEvent((HGTextureManager::PostTextureDeleteEventList *)v3))
    {
      v4 = HGTextureManager::PostTextureDeleteEventList::popEvent((HGTextureManager::PostTextureDeleteEventList *)v3);
      HGTextureManager::PostTextureDeleteEventList::unlock(v3);
      (*(void (**)(int64x2_t *))(v2->i64[0] + 16))(v2);
      v5 = v2[86].i64[1];
      v6 = v2[88].u64[0];
      v7 = v6 >> 9;
      v8 = (char *)(v5 + 8 * (v6 >> 9));
      v9 = v2[87].i64[0];
      if (v9 == v5)
      {
        v12 = v2[88].i64[1] + v6;
        v13 = (char *)(v5 + 8 * (v12 >> 9));
        if (v7 == v12 >> 9)
        {
          v11 = 0;
          if (!v5)
            goto LABEL_16;
LABEL_12:
          if ((char *)(*(_QWORD *)v8 + 4096) != v11)
            goto LABEL_41;
          v8 += 8;
          goto LABEL_45;
        }
        v11 = 0;
        v14 = 0;
        v10 = *(_QWORD *)v8;
      }
      else
      {
        v10 = *(_QWORD *)(v5 + 8 * v7);
        v11 = (char *)(v10 + 8 * (v2[88].i64[0] & 0x1FF));
        v12 = v2[88].i64[1] + v6;
        v13 = (char *)(v5 + 8 * (v12 >> 9));
        v14 = *(_QWORD *)v13 + 8 * (v12 & 0x1FF);
        if (v7 == v12 >> 9)
        {
          if (v11 != (char *)v14)
          {
            while (*(_QWORD *)v11 != v4)
            {
              v11 += 8;
              if (v11 == (char *)v14)
              {
                v11 = (char *)(*(_QWORD *)v13 + 8 * (v12 & 0x1FF));
                break;
              }
            }
            if (!v5)
            {
LABEL_16:
              v8 = 0;
              if (v9 != v5)
                goto LABEL_42;
              goto LABEL_46;
            }
          }
          goto LABEL_12;
        }
      }
      v15 = (char *)(v10 + 4096);
      while (*(_QWORD *)v11 != v4)
      {
        v11 += 8;
        if (v11 == v15)
          goto LABEL_26;
      }
      if (v11 != v15)
        goto LABEL_41;
LABEL_26:
      v16 = (uint64_t *)(v8 + 8);
      if (v8 + 8 != v13)
      {
        v17 = 0;
        v8 += 8;
        v18 = *v16;
        while (*(_QWORD *)(v18 + v17) != v4)
        {
          v17 += 8;
          if (v17 == 4096)
            goto LABEL_26;
        }
        v11 = (char *)(v18 + v17);
LABEL_41:
        if (v9 != v5)
          goto LABEL_42;
        goto LABEL_46;
      }
      if (*(_QWORD *)v13 == v14)
      {
        v8 = v13;
        v11 = (char *)v14;
        if (v9 != v5)
          goto LABEL_42;
        goto LABEL_46;
      }
      v11 = *(char **)v13;
      while (*(_QWORD *)v11 != v4)
      {
        v11 += 8;
        if (v11 == (char *)v14)
        {
          v11 = (char *)v14;
          break;
        }
      }
      if ((char *)(*(_QWORD *)v13 + 4096) != v11)
      {
        v8 = v13;
        if (v9 != v5)
          goto LABEL_42;
        goto LABEL_46;
      }
      v8 += 16;
LABEL_45:
      v11 = *(char **)v8;
      if (v9 != v5)
      {
LABEL_42:
        if (v11 == (char *)(*(_QWORD *)v13 + 8 * (v12 & 0x1FF)))
          goto LABEL_4;
LABEL_47:
        std::deque<Pipeline *>::erase(v2 + 86, v8, v11);
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
        goto LABEL_4;
      }
LABEL_46:
      if (v11)
        goto LABEL_47;
LABEL_4:
      (*(void (**)(int64x2_t *))(v2->i64[0] + 24))(v2);
      HGTextureManager::PostTextureDeleteEventList::lock(v3);
    }
    return (int64x2_t *)HGTextureManager::PostTextureDeleteEventList::unlock(v3);
  }
  return this;
}

HGMetalHandler *HGGPURenderer::InitMetal(HGGPURenderer *this)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  HGMetalContext *v7;
  const char *p_p;
  uint64_t v9;
  HGMetalHandler *v10;
  HGMetalHandler *result;
  void *__p;
  char v13;
  _QWORD v14[2];
  _QWORD v15[11];
  char v16;
  uint64_t v17;

  HGLogger::setLevel((HGLogger *)"metal_osx", 0);
  HGLogger::setLevel((HGLogger *)"metal", 0);
  HGLogger::setLevel((HGLogger *)"concat", 0);
  v2 = *((_QWORD *)this + 139);
  if (v2)
  {
    if ((HG_RENDERER_ENV::METAL_MAX_ENCODERS_PER_BUFFER & 0x80000000) == 0)
      HGMetalContext::setCommandBufferLimits(v2, HG_RENDERER_ENV::METAL_MAX_ENCODERS_PER_BUFFER, -1);
    v3 = HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_COUNT;
    v4 = HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_MEMORY;
    if ((HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_COUNT & 0x80000000) == 0
      || (HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_MEMORY & 0x80000000) == 0)
    {
      v5 = *((_QWORD *)this + 139);
      if (HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_COUNT < 0)
        v3 = *(_DWORD *)(v5 + 84);
      if (HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_MEMORY < 0)
        v4 = *(_QWORD *)(v5 + 88);
      *(_DWORD *)(v5 + 84) = v3;
      *(_QWORD *)(v5 + 88) = v4;
    }
    if (HG_RENDERER_ENV::METAL_UPLOAD_TEXTURE_CREATION_STRATEGY >= 1)
    {
      if (HG_RENDERER_ENV::METAL_UPLOAD_TEXTURE_CREATION_STRATEGY == 1)
        v6 = 5;
      else
        v6 = 13;
      switch(HG_RENDERER_ENV::METAL_UPLOAD_TEXTURE_CREATION_STRATEGY)
      {
        case 3:
          v6 |= 0x10u;
          break;
        case 4:
          v6 |= 0x20u;
          break;
        case 5:
          v6 |= 0x40u;
          break;
        case 6:
          v6 |= 0x80u;
          break;
        default:
          break;
      }
      *(_DWORD *)(*((_QWORD *)this + 139) + 48) = v6;
    }
    if (HG_RENDERER_ENV::METAL_BLIT_MAX_TILE_SIZE_MB >= 1)
      *(_DWORD *)(*((_QWORD *)this + 139) + 96) = HG_RENDERER_ENV::METAL_BLIT_MAX_TILE_SIZE_MB;
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v14);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"HeliumRender #", 14);
    std::ostream::operator<<();
    v7 = (HGMetalContext *)*((_QWORD *)this + 139);
    std::stringbuf::str();
    if (v13 >= 0)
      p_p = (const char *)&__p;
    else
      p_p = (const char *)__p;
    HGMetalContext::setLabel(v7, p_p);
    if (v13 < 0)
      operator delete(__p);
    v14[0] = *MEMORY[0x1E0DE4F50];
    v9 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
    *(_QWORD *)((char *)v14 + *(_QWORD *)(v14[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
    v15[0] = v9;
    v15[1] = MEMORY[0x1E0DE4FB8] + 16;
    if (v16 < 0)
      operator delete((void *)v15[9]);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1B5E290BC](&v17);
  }
  v10 = (HGMetalHandler *)operator new();
  result = HGMetalHandler::HGMetalHandler(v10, *((HGMetalContext **)this + 139));
  *((_QWORD *)this + 164) = v10;
  return result;
}

void sub_1B2A42324(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
    _Unwind_Resume(a1);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void HGGPURenderer::InitDefaultPageSize(PCICCTransferFunctionLUT **this)
{
  const char *v2;
  char *v3;
  uint64_t LUTEnd;
  unsigned __int8 v5;
  float v6;
  unint64_t v7;
  int v8;
  int v9;

  LUTEnd = PCICCTransferFunctionLUT::getLUTEnd(this[139]);
  *((_DWORD *)this + 312) = *(_DWORD *)(LUTEnd + 48);
  v5 = atomic_load(HGLogger::_enabled);
  if ((v5 & 1) != 0)
    HGLogger::log((HGLogger *)"init", (const char *)1, (HGLogger *)"m_MaxPageSize : %d\n", v2, v3, *((unsigned int *)this + 312));
  v6 = 0.25;
  if (HG_RENDERER_ENV::LOW_MEMORY_USAGE == 1)
    v6 = 0.125;
  v7 = *(_QWORD *)(LUTEnd + 40);
  this[157] = (PCICCTransferFunctionLUT *)(float)(v6 * (float)v7);
  v8 = HG_RENDERER_ENV::FORCE_PAGE_SIZE;
  if (HG_RENDERER_ENV::FORCE_PAGE_SIZE != -1)
  {
    *((_DWORD *)this + 165) = HG_RENDERER_ENV::FORCE_PAGE_SIZE;
    v9 = *((_DWORD *)this + 312);
    if (v8 <= v9)
      return;
LABEL_21:
    *((_DWORD *)this + 165) = v9;
    return;
  }
  if (HGMetalDeviceInfo::isIntel((HGMetalDeviceInfo *)LUTEnd))
  {
    *((_DWORD *)this + 165) = 555;
    v9 = *((_DWORD *)this + 312);
    if (v9 < 555)
      goto LABEL_21;
  }
  else if (v7 < 0x1DCD65000)
  {
    if (v7 < 0x77359400)
    {
      if (v7 < 0x3B9ACA00)
      {
        *((_DWORD *)this + 165) = 750;
        v9 = *((_DWORD *)this + 312);
        if (v9 < 750)
          goto LABEL_21;
      }
      else
      {
        *((_DWORD *)this + 165) = 1500;
        v9 = *((_DWORD *)this + 312);
        if (v9 < 1500)
          goto LABEL_21;
      }
    }
    else
    {
      *((_DWORD *)this + 165) = 3000;
      v9 = *((_DWORD *)this + 312);
      if (v9 < 3000)
        goto LABEL_21;
    }
  }
  else
  {
    *((_DWORD *)this + 165) = 5000;
    v9 = *((_DWORD *)this + 312);
    if (v9 < 5000)
      goto LABEL_21;
  }
}

void HGGPURenderer::~HGGPURenderer(HGGPURenderer *this)
{
  HGGLContext *var0;
  HGGLContext *v3;
  const void *v4;
  HGMetalHandler *v5;
  HGMetalHandler *v6;
  id *v7;
  id *v8;
  HGTextureManager *v9;
  HGTextureManager *v10;
  HGGLContext *v11;
  void **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void **v16;
  char *v17;
  char *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  HGGLState *v22;
  HGGLContext *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  PCSharedCount v32;
  PCSharedCount v33;
  PCSharedCount v34;

  *(_QWORD *)this = off_1E65240A0;
  if (*((_BYTE *)this + 1281))
  {
    HGGLGetCurrentContext();
    HGGLContext::Share((uint64_t *)&v33, (HGObject **)&v34);
    var0 = (HGGLContext *)v34.var0;
    if (v34.var0)
      v34.var0 = 0;
    PCSharedCount::PCSharedCount(&v33);
    v3 = (HGGLContext *)*((_QWORD *)this + 143);
    if (v3)
      HGGLContext::setCurrent(v3);
  }
  else
  {
    var0 = 0;
  }
  HGLUTCacheManager::clear(*((HGLUTCacheManager **)this + 69));
  (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
  v4 = (const void *)*((_QWORD *)this + 164);
  if (v4)
  {
    if (v5)
    {
      v6 = v5;
      HGMetalHandler::FinalizeCommandBuffer(v5);
      HGMetalHandler::BindBuffer(v6, 0);
    }
  }
  v7 = (id *)*((_QWORD *)this + 165);
  if (v7)
  {
    HGMetalCommandBufferRef::waitUntilCompleted(v7);
    v8 = (id *)*((_QWORD *)this + 165);
    if (v8)
    {
      HGMetalCommandBufferRef::~HGMetalCommandBufferRef(v8);
      MEMORY[0x1B5E29170]();
    }
  }
  *((_QWORD *)this + 165) = 0;
  v9 = (HGTextureManager *)*((_QWORD *)this + 184);
  if (v9)
  {
    HGTextureManager::finishDeleteTextureQueue(v9);
    HGGPURenderer::PurgePostDeleteEvents((int64x2_t *)this);
    v10 = (HGTextureManager *)*((_QWORD *)this + 184);
    if (v10)
    {
      HGTextureManager::~HGTextureManager(v10);
      MEMORY[0x1B5E29170]();
    }
    *((_QWORD *)this + 184) = 0;
  }
  *((_DWORD *)this + 290) = 0;
  v11 = (HGGLContext *)*((_QWORD *)this + 144);
  if (v11)
  {
    if (*((_DWORD *)this + 357) != -1)
    {
      HGGLContext::setCurrent(v11);
      glDeleteTextures(1, (const GLuint *)this + 357);
    }
    HGGLShaderCache::ResetMetal(*((HGGLShaderCache **)this + 161), *((const HGMetalContext **)this + 139));
    HGGLShaderCache::ResetGLSL(*((HGGLShaderCache **)this + 161));
    HGGLShaderCache::ResetARB(*((HGGLShaderCache **)this + 161));
  }
  v12 = (void **)*((_QWORD *)this + 161);
  if (v12)
  {
    HGGLShaderCache::~HGGLShaderCache(v12);
    MEMORY[0x1B5E29170]();
  }
  *((_QWORD *)this + 161) = 0;
  v13 = *((_QWORD *)this + 162);
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  v14 = *((_QWORD *)this + 163);
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
  v15 = *((_QWORD *)this + 164);
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  v16 = (void **)*((_QWORD *)this + 179);
  if (v16)
  {
    v17 = (char *)*v16;
    if (*v16)
    {
      v18 = (char *)v16[1];
      v19 = *v16;
      if (v18 != v17)
      {
        do
        {
          v21 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          v20 = v21;
          if (v21)
            (*(void (**)(uint64_t))(*(_QWORD *)v20 + 24))(v20);
        }
        while (v18 != v17);
        v19 = *v16;
      }
      v16[1] = v17;
      operator delete(v19);
    }
    MEMORY[0x1B5E29170](v16, 0x20C40960023A9);
  }
  *((_QWORD *)this + 179) = 0;
  v22 = (HGGLState *)*((_QWORD *)this + 146);
  if (v22)
  {
    HGGLState::~HGGLState(v22);
    MEMORY[0x1B5E29170]();
  }
  if (*((_BYTE *)this + 1281))
    HGGPURenderer::UnBindCachedFramebuffer(this);
  v23 = (HGGLContext *)*((_QWORD *)this + 144);
  if (v23)
  {
    HGGLContext::context((uint64_t *)&v34, v23);
    if (PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v34))
    {
      v32.var0 = v34.var0;
      HGGLSetCurrentContext(&v32.var0);
      PCSharedCount::PCSharedCount(&v32);
      glBindFramebuffer(0x8D40u, 0);
      if (*((_DWORD *)this + 297))
        glDeleteFramebuffers(1, (const GLuint *)this + 297);
    }
    v24 = *((_QWORD *)this + 144);
    if (v24)
      (*(void (**)(uint64_t))(*(_QWORD *)v24 + 24))(v24);
    *((_QWORD *)this + 144) = 0;
    PCSharedCount::PCSharedCount(&v34);
  }
  v25 = *((_QWORD *)this + 143);
  if (v25)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v25 + 24))(v25);
    *((_QWORD *)this + 143) = 0;
  }
  v26 = *((_QWORD *)this + 151);
  if (v26)
    (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
  *((_QWORD *)this + 151) = 0;
  if (var0)
  {
    HGGLContext::setCurrent(var0);
    (*(void (**)(HGGLContext *))(*(_QWORD *)var0 + 24))(var0);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 1440, *((_QWORD **)this + 181));
  std::deque<HGNode *>::~deque[abi:ne180100]((uint64_t)this + 1376);
  v27 = (void *)*((_QWORD *)this + 152);
  if (v27)
  {
    *((_QWORD *)this + 153) = v27;
    operator delete(v27);
  }
  v28 = *((_QWORD *)this + 147);
  if (v28)
    (*(void (**)(uint64_t))(*(_QWORD *)v28 + 24))(v28);
  v29 = *((_QWORD *)this + 144);
  if (v29)
    (*(void (**)(uint64_t))(*(_QWORD *)v29 + 24))(v29);
  v30 = *((_QWORD *)this + 143);
  if (v30)
    (*(void (**)(uint64_t))(*(_QWORD *)v30 + 24))(v30);
  std::__tree<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::__map_value_compare<HGMetalDeviceInfo const*,std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::less<HGMetalDeviceInfo const*>,true>,std::allocator<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>>>::destroy((uint64_t)this + 1120, *((_QWORD **)this + 141));
  v31 = *((_QWORD *)this + 139);
  if (v31)
    (*(void (**)(uint64_t))(*(_QWORD *)v31 + 24))(v31);
  HGRenderer::~HGRenderer(this);
}

{
  void *v1;

  HGGPURenderer::~HGGPURenderer(this);
  HGObject::operator delete(v1);
}

void HGGPURenderer::FinishMetalCommandBuffer(HGGPURenderer *this)
{
  const void *v2;
  HGMetalHandler *v3;
  HGMetalHandler *v4;
  id *v5;

  (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
  v2 = (const void *)*((_QWORD *)this + 164);
  if (v2)
  {
    if (v3)
    {
      v4 = v3;
      HGMetalHandler::FinalizeCommandBuffer(v3);
      HGMetalHandler::BindBuffer(v4, 0);
    }
  }
  v5 = (id *)*((_QWORD *)this + 165);
  if (v5)
    HGMetalCommandBufferRef::waitUntilCompleted(v5);
}

uint64_t HGGPURenderer::GetMetalContext(HGGPURenderer *this)
{
  return *((_QWORD *)this + 139);
}

void HGGPURenderer::UnBindCachedFramebuffer(HGGPURenderer *this)
{
  unsigned __int8 v2;
  const char *v3;
  char *v4;
  unsigned __int8 v5;
  uint64_t *v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  char *v10;
  uint64_t v11;
  unsigned __int8 v12;
  unsigned __int8 v13;
  FBOStrategy *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t *v18;
  int v19;
  uint64_t v20;
  _BYTE v21[16];

  v2 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E0);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E0))
  {
    v15 = operator new();
    *(_QWORD *)v15 = 850045863;
    *(_OWORD *)(v15 + 8) = 0u;
    *(_OWORD *)(v15 + 24) = 0u;
    *(_OWORD *)(v15 + 40) = 0u;
    *(_QWORD *)(v15 + 56) = 0;
    qword_1ED4DA9D8 = v15;
    __cxa_guard_release(&qword_1ED4DA9E0);
  }
  std::mutex::lock((std::mutex *)qword_1ED4DA9D8);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v21, "framebuffer", 2, "UnBindCachedFramebuffer()");
  v5 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
  if ((v5 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
  {
    qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
    qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
    qword_1ED4DAA00 = 0;
    __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
    __cxa_guard_release(&qword_1ED4DA9E8);
  }
  v6 = (uint64_t *)qword_1ED4DA9F8;
  v7 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
  if ((v7 & 1) == 0)
  {
    v16 = qword_1ED4DA9F8;
    v17 = __cxa_guard_acquire(&qword_1ED4DA9E8);
    v6 = (uint64_t *)v16;
    if (v17)
    {
      qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DAA00 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4DA9E8);
      v6 = (uint64_t *)v16;
    }
  }
  if (v6 == &qword_1ED4DA9F0)
  {
LABEL_7:
    v6 = &qword_1ED4DA9F0;
  }
  else
  {
    while (*((_DWORD *)v6 + 7) != *((_DWORD *)this + 298))
    {
      v6 = (uint64_t *)v6[1];
      if (v6 == &qword_1ED4DA9F0)
        goto LABEL_7;
    }
  }
  v8 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
  if ((v8 & 1) == 0)
  {
    v18 = v6;
    v19 = __cxa_guard_acquire(&qword_1ED4DA9E8);
    v6 = v18;
    if (v19)
    {
      qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DAA00 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4DA9E8);
      v6 = v18;
    }
  }
  if (v6 == &qword_1ED4DA9F0)
  {
    v12 = atomic_load(HGLogger::_enabled);
    if ((v12 & 1) != 0)
    {
      v10 = "uh oh! unknown framebuffer (%d)\n";
      v11 = 1;
      goto LABEL_14;
    }
  }
  else
  {
    *((_BYTE *)v6 + 32) = 0;
    v9 = atomic_load(HGLogger::_enabled);
    if ((v9 & 1) != 0)
    {
      v10 = "done with framebuffer (%d) - marking unused\n";
      v11 = 2;
LABEL_14:
      HGLogger::log((HGLogger *)"framebuffer", (const char *)v11, (HGLogger *)v10, v3, v4, *((unsigned int *)this + 298));
    }
  }
  v13 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E0);
  if ((v13 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E0))
  {
    v20 = operator new();
    *(_QWORD *)v20 = 850045863;
    *(_OWORD *)(v20 + 8) = 0u;
    *(_OWORD *)(v20 + 24) = 0u;
    *(_OWORD *)(v20 + 40) = 0u;
    *(_QWORD *)(v20 + 56) = 0;
    qword_1ED4DA9D8 = v20;
    __cxa_guard_release(&qword_1ED4DA9E0);
  }
  std::mutex::unlock((std::mutex *)qword_1ED4DA9D8);
  glBindFramebuffer(0x8D40u, 0);
  *((_DWORD *)this + 298) = 0;
  FBOStrategy::cleanupCache(v14);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v21);
}

void sub_1B2A42C88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  __cxa_guard_abort(&qword_1ED4DA9E0);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A42CA8(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1ED4DA9E0);
  _Unwind_Resume(a1);
}

void sub_1B2A42CC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::label(PCICCTransferFunctionLUT **this)
{
  void **v2;
  uint64_t v3;
  PCICCTransferFunctionLUT *v4;
  _QWORD *v5;
  id *LUTEnd;
  _QWORD *v7;
  id *v8;
  const char *v9;
  size_t v10;
  _QWORD *v11;
  uint64_t v12;
  void *__p[2];
  unsigned __int8 v15;
  _QWORD v16[2];
  _QWORD v17[11];
  char v18;
  uint64_t v19;

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v16);
  HGRenderer::label((uint64_t *)__p, (HGRenderer *)this);
  if ((v15 & 0x80u) == 0)
    v2 = __p;
  else
    v2 = (void **)__p[0];
  if ((v15 & 0x80u) == 0)
    v3 = v15;
  else
    v3 = (uint64_t)__p[1];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)v2, v3);
  if ((char)v15 < 0)
  {
    operator delete(__p[0]);
    v4 = this[139];
    if (!v4)
      goto LABEL_13;
  }
  else
  {
    v4 = this[139];
    if (!v4)
      goto LABEL_13;
  }
  v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" ID:0x", 6);
  *(_DWORD *)((char *)v5 + *(_QWORD *)(*v5 - 24) + 8) = *(_DWORD *)((_BYTE *)v5 + *(_QWORD *)(*v5 - 24) + 8) & 0xFFFFFFB5 | 8;
  PCICCTransferFunctionLUT::getLUTEnd(v4);
  std::ostream::operator<<();
  LUTEnd = (id *)PCICCTransferFunctionLUT::getLUTEnd(v4);
  if (HGMetalDeviceInfo::name(LUTEnd))
  {
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" (", 2);
    v8 = (id *)PCICCTransferFunctionLUT::getLUTEnd(v4);
    v9 = (const char *)HGMetalDeviceInfo::name(v8);
    v10 = strlen(v9);
    v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)v9, v10);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)")", 1);
  }
LABEL_13:
  std::stringbuf::str();
  v16[0] = *MEMORY[0x1E0DE4F50];
  v12 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)v16 + *(_QWORD *)(v16[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v17[0] = v12;
  v17[1] = MEMORY[0x1E0DE4FB8] + 16;
  if (v18 < 0)
    operator delete((void *)v17[9]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1B5E290BC](&v19);
}

void sub_1B2A42EA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
    _Unwind_Resume(a1);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::debugDescription(HGGPURenderer *this)
{
  return (*(uint64_t (**)(HGGPURenderer *))(*(_QWORD *)this + 40))(this);
}

uint64_t HGGPURenderer::ShouldAllocateGLTexture(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  uint64_t result;
  unsigned int v9;
  unsigned int v11;
  uint64_t v13;

  if (*(_BYTE *)(a1 + 1281))
  {
    result = *(_QWORD *)(a1 + 1472);
    if (!result)
      return result;
    v9 = HGTextureManager::maxTextureSizeGL(result, a4);
    if (v9 < a2 || v9 < a3)
      return 0;
  }
  else
  {
    v11 = *(_DWORD *)(PCICCTransferFunctionLUT::getLUTEnd(*(PCICCTransferFunctionLUT **)(a1 + 1112)) + 48);
    if (v11 < a2 || v11 < a3)
      return 0;
  }
  if (a4 <= 41)
    v13 = s_HGFormatInfos[8 * a4 + 3];
  else
    v13 = 0;
  return a3 * (unint64_t)a2 * v13 < *(_QWORD *)(a1 + 1256);
}

uint64_t HGGPURenderer::ShouldAllocateTexture(uint64_t a1, unsigned int a2, unsigned int a3, int a4, int a5, int a6)
{
  unsigned int v11;
  BOOL v12;
  char v13;
  uint64_t result;
  unsigned int v15;
  unsigned int v17;
  uint64_t v18;

  if (*(_BYTE *)(a1 + 1281))
  {
    if (a5)
    {
      v11 = *(_DWORD *)(PCICCTransferFunctionLUT::getLUTEnd(*(PCICCTransferFunctionLUT **)(a1 + 1112)) + 48);
      v12 = v11 >= a2 && v11 >= a3;
      v13 = !v12;
      if (!v12 || !a6)
      {
        if ((v13 & 1) != 0)
          return 0;
        goto LABEL_24;
      }
LABEL_21:
      result = *(_QWORD *)(a1 + 1472);
      if (!result)
        return result;
      v17 = HGTextureManager::maxTextureSizeGL(result, a4);
      result = 0;
      if (v17 < a2 || v17 < a3)
        return result;
      goto LABEL_24;
    }
    if (a6)
      goto LABEL_21;
  }
  else
  {
    v15 = *(_DWORD *)(PCICCTransferFunctionLUT::getLUTEnd(*(PCICCTransferFunctionLUT **)(a1 + 1112)) + 48);
    if (v15 < a2 || v15 < a3)
      return 0;
  }
LABEL_24:
  if (a4 <= 41)
    v18 = s_HGFormatInfos[8 * a4 + 3];
  else
    v18 = 0;
  return a3 * (unint64_t)a2 * v18 < *(_QWORD *)(a1 + 1256);
}

uint64_t HGGPURenderer::IsCPU(HGGPURenderer *this)
{
  return 0;
}

uint64_t HGGPURenderer::RenderFullROI_Default(HGGPURenderer *this)
{
  return 0;
}

const char *HGGPURenderer::RenderBitmap(HGGPURenderer *this, HGBitmap *a2, HGNode *a3)
{
  int v3;
  BOOL v4;
  char *v5;
  const char *result;
  uint64_t v8;
  _BYTE v9[40];

  v3 = *((_DWORD *)a2 + 3);
  if (*((_BYTE *)this + 1280))
    v4 = 1;
  else
    v4 = (*((_DWORD *)a2 + 3) & 0x10) == 0;
  if (!v4)
  {
    v5 = "  ERROR : cannot render to shared GL texture.";
    return HGLogger::warning((HGLogger *)v5, (const char *)a2, (char *)a3);
  }
  if ((~v3 & 0x210) == 0)
  {
    v5 = "  ERROR : bitmap is a GL texture (need a HGGLBuffer).";
    return HGLogger::warning((HGLogger *)v5, (const char *)a2, (char *)a3);
  }
  if ((~v3 & 0x120) == 0)
  {
    v5 = "  ERROR : bitmap is a MTL buffer (need a texture).";
    return HGLogger::warning((HGLogger *)v5, (const char *)a2, (char *)a3);
  }
  HGRendererOutput::HGRendererOutput((HGRendererOutput *)v9, a3, a2);
  HGRenderer::RenderNode(this, (const HGRendererOutput *)v9, (char *)1, &v8);
  result = (const char *)v8;
  if (v8)
    return (const char *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
  return result;
}

{
  HGLogger::warning((HGLogger *)"  WARNING : calling obsolete HGGPURenderer function:\n  (fullROI is always 'on' when providing a destination bitmap)\n", (const char *)a2, (char *)a3);
  return HGGPURenderer::RenderBitmap(this, a2, a3);
}

uint64_t HGGPURenderer::GetGLTexture(HGGPURenderer *this, HGBitmap *a2, char *a3)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  HGBitmap *v8;
  HGBitmap *v9;
  int v10;
  uint64_t v11;
  uint64_t v13;
  void *v14;
  PCSharedCount v15;
  PCSharedCount v16[3];

  if (!*((_BYTE *)this + 809))
  {
    HGLogger::warning((HGLogger *)"Invalid Renderer", (const char *)a2, a3);
    return 0;
  }
  v4 = *((_QWORD *)this + 146);
  if (!v4)
  {
    HGLogger::warning((HGLogger *)"Renderer does not support OpenGL", (const char *)a2, a3);
    return 0;
  }
  HGGLContext::context((uint64_t *)&v15, *((HGGLContext **)this + 143));
  HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v16, v4, &v15);
  PCSharedCount::PCSharedCount(&v15);
  v6 = *(_QWORD *)((char *)a2 + 20);
  v7 = *(_QWORD *)((char *)a2 + 28);
  v8 = HGGPURenderer::ConvertToNonMetalTexture(this, a2);
  v9 = v8;
  v10 = *((_DWORD *)v8 + 3);
  if ((v10 & 0x30) == 0)
  {
    v13 = (*(uint64_t (**)(HGGPURenderer *, uint64_t, uint64_t, HGBitmap *))(*(_QWORD *)this + 352))(this, v6, v7, v8);
    goto LABEL_14;
  }
  if ((v10 & 0x10) != 0)
  {
    if ((v10 & 0x100) == 0)
    {
      if ((v10 & 0x200) != 0)
      {
        v11 = (uint64_t)v14;
        if (v14)
          (*(void (**)(void *))(*(_QWORD *)v14 + 16))(v14);
        goto LABEL_15;
      }
      goto LABEL_5;
    }
    (*(void (**)(HGGPURenderer *, HGBitmap *))(*(_QWORD *)this + 144))(this, v8);
    v13 = (*(uint64_t (**)(HGGPURenderer *))(*(_QWORD *)this + 328))(this);
LABEL_14:
    v11 = v13;
    goto LABEL_15;
  }
LABEL_5:
  v11 = 0;
LABEL_15:
  (*(void (**)(HGBitmap *))(*(_QWORD *)v9 + 24))(v9);
  (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v16);
  return v11;
}

void sub_1B2A4339C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCSharedCount a9)
{
  PCSharedCount::PCSharedCount(&a9);
  _Unwind_Resume(a1);
}

void sub_1B2A433B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::ConvertToGLTexture(HGGPURenderer *this, HGRect a2, HGBitmap *a3)
{
  uint64_t v3;
  uint64_t v4;
  HGBitmap *v6;
  HGBitmap *v7;
  int v8;
  uint64_t v9;
  void *v10;

  v3 = *(_QWORD *)&a2.var2;
  v4 = *(_QWORD *)&a2.var0;
  v6 = HGGPURenderer::ConvertToNonMetalTexture(this, a3);
  v7 = v6;
  v8 = *((_DWORD *)v6 + 3);
  if ((v8 & 0x30) != 0)
  {
    if ((v8 & 0x10) == 0)
      goto LABEL_3;
    if ((v8 & 0x100) != 0)
    {
      (*(void (**)(HGGPURenderer *, HGBitmap *))(*(_QWORD *)this + 144))(this, v6);
      v9 = (*(uint64_t (**)(HGGPURenderer *))(*(_QWORD *)this + 328))(this);
      goto LABEL_10;
    }
    if ((v8 & 0x200) != 0)
    {
      v9 = (uint64_t)v10;
      if (v10)
        (*(void (**)(void *))(*(_QWORD *)v10 + 16))(v10);
    }
    else
    {
LABEL_3:
      v9 = 0;
    }
  }
  else
  {
    v9 = (*(uint64_t (**)(HGGPURenderer *, uint64_t, uint64_t, HGBitmap *))(*(_QWORD *)this + 352))(this, v4, v3, v6);
  }
LABEL_10:
  (*(void (**)(HGBitmap *))(*(_QWORD *)v7 + 24))(v7);
  return v9;
}

uint64_t HGGPURenderer::GetRawGLTexture(HGGPURenderer *this, HGBitmap *a2, char *a3)
{
  uint64_t v4;
  uint64_t v6;
  char *v8;
  PCSharedCount v9;
  PCSharedCount v10[3];

  if (*((_BYTE *)this + 809))
  {
    v4 = *((_QWORD *)this + 146);
    if (v4)
    {
      HGGLContext::context((uint64_t *)&v9, *((HGGLContext **)this + 143));
      HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v10, v4, &v9);
      PCSharedCount::PCSharedCount(&v9);
      v6 = HGGPURenderer::ConvertToRawGLTexture(this, a2);
      (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
      HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v10);
      return v6;
    }
    v8 = "Renderer does not support OpenGL";
  }
  else
  {
    v8 = "Invalid Renderer";
  }
  HGLogger::warning((HGLogger *)v8, (const char *)a2, a3);
  return 0;
}

void sub_1B2A4357C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCSharedCount a9)
{
  PCSharedCount::PCSharedCount(&a9);
  _Unwind_Resume(a1);
}

void sub_1B2A43590(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::ConvertToRawGLTexture(HGGPURenderer *this, HGBitmap *a2)
{
  HGBitmap *v4;
  HGBitmap *v5;
  char *Buffer;
  uint64_t v7;
  uint64_t v8;
  HGBitmap *v9;
  HGBitmap *v10;
  int v11;
  uint64_t v12;
  void *v13;

  v4 = HGGPURenderer::ConvertToNonMetalTexture(this, a2);
  v5 = v4;
  if ((*((_BYTE *)v4 + 12) & 1) != 0)
  {
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)this, *(HGRect *)((char *)a2 + 20), *((unsigned int *)a2 + 4), 0, 0, 0, *((_BYTE *)this + 1336) == 0);
    HGGPURenderer::BufferCopyOpenGL(this, (HGBuffer *)Buffer, *(HGRect *)((char *)a2 + 20), v5);
  }
  else
  {
    (*(void (**)(HGBitmap *))(*(_QWORD *)v4 + 16))(v4);
    Buffer = (char *)v5;
  }
  v7 = *(_QWORD *)(Buffer + 20);
  v8 = *(_QWORD *)(Buffer + 28);
  v9 = HGGPURenderer::ConvertToNonMetalTexture(this, (HGBitmap *)Buffer);
  v10 = v9;
  v11 = *((_DWORD *)v9 + 3);
  if ((v11 & 0x30) != 0)
  {
    if ((v11 & 0x10) == 0)
      goto LABEL_6;
    if ((v11 & 0x100) != 0)
    {
      (*(void (**)(HGGPURenderer *, HGBitmap *))(*(_QWORD *)this + 144))(this, v9);
      v12 = (*(uint64_t (**)(HGGPURenderer *))(*(_QWORD *)this + 328))(this);
      goto LABEL_13;
    }
    if ((v11 & 0x200) != 0)
    {
      v12 = (uint64_t)v13;
      if (v13)
        (*(void (**)(void *))(*(_QWORD *)v13 + 16))(v13);
    }
    else
    {
LABEL_6:
      v12 = 0;
    }
  }
  else
  {
    v12 = (*(uint64_t (**)(HGGPURenderer *, uint64_t, uint64_t, HGBitmap *))(*(_QWORD *)this + 352))(this, v7, v8, v9);
  }
LABEL_13:
  (*(void (**)(HGBitmap *))(*(_QWORD *)v10 + 24))(v10);
  (*(void (**)(HGBitmap *))(*(_QWORD *)v5 + 24))(v5);
  (*(void (**)(char *))(*(_QWORD *)Buffer + 24))(Buffer);
  return v12;
}

HGBitmap *HGGPURenderer::GetMetalTexture(HGGPURenderer *this, HGBitmap *a2, char *a3)
{
  uint64_t v5;
  HGBitmap *v6;
  PCSharedCount v8;
  PCSharedCount v9[3];
  HGRect v10;

  if (*((_BYTE *)this + 809))
  {
    v5 = *((_QWORD *)this + 146);
    if (v5)
    {
      HGGLContext::context((uint64_t *)&v8, *((HGGLContext **)this + 143));
      HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v9, v5, &v8);
      PCSharedCount::PCSharedCount(&v8);
      v6 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)this, *(HGRect *)((char *)a2 + 20), a2, 1);
      (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
      HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v9);
      return v6;
    }
    else
    {
      *(_QWORD *)&v10.var0 = *(_QWORD *)((char *)a2 + 20);
      *(_QWORD *)&v10.var2 = *(_QWORD *)((char *)a2 + 28);
      return HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)this, v10, a2, 1);
    }
  }
  else
  {
    HGLogger::warning((HGLogger *)"Invalid Renderer", (const char *)a2, a3);
    return 0;
  }
}

void sub_1B2A43824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCSharedCount a9)
{
  PCSharedCount::PCSharedCount(&a9);
  _Unwind_Resume(a1);
}

void sub_1B2A43838(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

HGBitmap *HGGPURenderer::ConvertToMetalTexture(HGMetalTexture **this, HGRect a2, HGBitmap *a3)
{
  return HGGPURenderer::ConvertToMetalTexture(this, a2, a3, 1);
}

HGBitmap *HGGPURenderer::ConvertToRawMetalTexture(HGGPURenderer *this, HGBitmap *a2)
{
  HGBitmap *v4;
  HGBitmap *v5;
  char *Buffer;
  HGBitmap *v7;

  v4 = HGGPURenderer::ConvertToNonGLTexture(this, a2);
  v5 = v4;
  if ((*((_BYTE *)v4 + 12) & 1) != 0)
  {
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)this, *(HGRect *)((char *)a2 + 20), *((unsigned int *)a2 + 4), 1, 0, 0, *((_BYTE *)this + 1336) == 0);
    HGGPURenderer::BufferCopyMetal(this, (HGBuffer *)Buffer, *(HGRect *)((char *)a2 + 20), v5);
  }
  else
  {
    (*(void (**)(HGBitmap *))(*(_QWORD *)v4 + 16))(v4);
    Buffer = (char *)v5;
  }
  v7 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)this, *(HGRect *)(Buffer + 20), (HGBitmap *)Buffer, 1);
  (*(void (**)(HGBitmap *))(*(_QWORD *)v5 + 24))(v5);
  (*(void (**)(char *))(*(_QWORD *)Buffer + 24))(Buffer);
  return v7;
}

HGBitmap *HGGPURenderer::GetBitmap(uint64_t a1, uint64_t a2, uint64_t a3)
{
  HGBitmap *v3;
  int v5;
  uint64_t v7;
  char *Buffer;
  char *v9;
  char *v10;
  __n128 v11;
  uint64_t v13;
  HGBitmap *v14;
  __n128 v15;
  PCSharedCount v16;
  PCSharedCount v17[3];

  if (*(_BYTE *)(a1 + 809))
  {
    v3 = (HGBitmap *)a2;
    v5 = *(_DWORD *)(a2 + 12);
    if ((v5 & 0x30) != 0)
    {
      if ((v5 & 0x20) != 0)
      {
        v13 = *(unsigned int *)(a2 + 16);
        if ((_DWORD)v13 != (_DWORD)a3)
          HGLogger::warning((HGLogger *)"HGGPURenderer::GetBitmap() -- Requested format (%s) doesn't match the bitmap's format (%s) and will be ignored.", (const char *)a2, (char *)a3, *(_QWORD *)&s_HGFormatInfos[8 * a3 + 6], *(_QWORD *)&s_HGFormatInfos[8 * v13 + 6]);
        v14 = (HGBitmap *)HGObject::operator new(0x80uLL);
        HGBitmap::HGBitmap(v14, *(_QWORD *)((char *)v3 + 20), *(_QWORD *)((char *)v3 + 28), *((unsigned int *)v3 + 4));
        HGGPURenderer::ReadbackMetalTexture((HGGPURenderer *)a1, v3, v14);
        v3 = v14;
      }
      else
      {
        v7 = *(_QWORD *)(a1 + 1168);
        HGGLContext::context((uint64_t *)&v16, *(HGGLContext **)(a1 + 1144));
        HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v17, v7, &v16);
        PCSharedCount::PCSharedCount(&v16);
        if ((*((_BYTE *)v3 + 13) & 1) != 0)
        {
          (*(void (**)(uint64_t, HGBitmap *))(*(_QWORD *)a1 + 144))(a1, v3);
          v10 = (char *)HGObject::operator new(0x80uLL);
          v15 = HGBitmap::HGBitmap(v10, *(_QWORD *)((char *)v3 + 20), *(_QWORD *)((char *)v3 + 28), a3);
          (*(void (**)(uint64_t, _QWORD, _QWORD, char *, __n128))(*(_QWORD *)a1 + 344))(a1, *(_QWORD *)((char *)v3 + 20), *(_QWORD *)((char *)v3 + 28), v10, v15);
        }
        else
        {
          Buffer = HGGPURenderer::CreateBuffer(a1, *(HGRect *)((char *)v3 + 20), a3, 0, 0, 0, *(_BYTE *)(a1 + 1336) == 0);
          (*(void (**)(uint64_t, char *))(*(_QWORD *)a1 + 144))(a1, Buffer);
          (*(void (**)(uint64_t, _QWORD, HGBitmap *, _QWORD, _QWORD))(*(_QWORD *)a1 + 152))(a1, 0, v3, 0, 0);
          HGGPURenderer::Copy((HGGPURenderer *)a1, *(HGRect *)((char *)v3 + 20), 0, v9);
          (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 152))(a1, 0, 0, 0, 0);
          v10 = (char *)HGObject::operator new(0x80uLL);
          v11 = HGBitmap::HGBitmap(v10, *(_QWORD *)(Buffer + 20), *(_QWORD *)(Buffer + 28), *((unsigned int *)Buffer + 4));
          (*(void (**)(uint64_t, _QWORD, _QWORD, char *, __n128))(*(_QWORD *)a1 + 344))(a1, *(_QWORD *)(v10 + 20), *(_QWORD *)(v10 + 28), v10, v11);
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
          (*(void (**)(char *))(*(_QWORD *)Buffer + 24))(Buffer);
        }
        HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v17);
        v3 = (HGBitmap *)v10;
      }
    }
    else
    {
      (*(void (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    }
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
    return v3;
  }
  else
  {
    HGLogger::warning((HGLogger *)"Invalid Renderer", (const char *)a2, (char *)a3);
    return 0;
  }
}

void sub_1B2A43BB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount a12)
{
  void *v12;

  HGObject::operator delete(v12);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(&a12);
  _Unwind_Resume(a1);
}

void sub_1B2A43BD8(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A43BEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11)
{
  PCSharedCount::PCSharedCount(&a11);
  _Unwind_Resume(a1);
}

void sub_1B2A43C00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A43C14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

void HGGPURenderer::ReadbackMetalTexture(HGGPURenderer *this, HGBitmap *a2, HGBitmap *a3)
{
  char *v6;
  char *v7;
  const void *v8;
  HGMetalHandler *v9;
  HGMetalHandler *v10;
  id *v11;
  HGMetalTexture *MetalStorage;

  (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
  v8 = (const void *)*((_QWORD *)this + 164);
  if (v8)
  {
    if (v9)
    {
      v10 = v9;
      HGMetalHandler::FinalizeCommandBuffer(v9);
      HGMetalHandler::BindBuffer(v10, 0);
    }
  }
  v11 = (id *)*((_QWORD *)this + 165);
  if (v11)
    HGMetalCommandBufferRef::waitUntilCompleted(v11);
  if ((~*((_DWORD *)a2 + 3) & 0x220) != 0
    || (MetalStorage = (HGMetalTexture *)HGMetalTexture::getMetalStorage(a2, (HGBitmap *)v6)) == 0)
  {
    HGLogger::warning((HGLogger *)"HGGPURenderer::ReadbackMetalTexture failed.", v6, v7);
  }
  else
  {
    HGMetalTexture::CopyTexture(MetalStorage, *((id **)this + 139), a3, *(HGRect *)((char *)a3 + 20));
  }
}

char *HGGPURenderer::CreateBuffer(uint64_t a1, HGRect a2, uint64_t a3, int a4, int a5, uint64_t a6)
{
  return HGGPURenderer::CreateBuffer(a1, a2, a3, a4, a5, a6, *(_BYTE *)(a1 + 1336) == 0);
}

uint64_t HGGPURenderer::Copy(HGGPURenderer *this, HGRect a2, const char *a3, char *a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 v8;
  HGGLShaderCache *v9;
  double v10;
  double v11;
  uint32x4_t v12;
  const char *v13;
  uint64_t Entry;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  HGHandler *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t TextureRect;
  uint64_t v24;
  uint64_t v25;
  string_t v26[6];
  HGRect v27;

  v4 = (int)a3;
  v5 = *(_QWORD *)&a2.var2;
  v6 = *(_QWORD *)&a2.var0;
  v8 = atomic_load(HGLogger::_enabled);
  if ((v8 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"copy texture to buffer [%d %d %d %d]\n", a3, a4, *(_QWORD *)&a2.var0, a2.var1, *(_QWORD *)&a2.var2, a2.var3);
  v9 = (HGGLShaderCache *)*((_QWORD *)this + 161);
  HGString::sample2d((HGString *)0x60620, v4, 0, (HGString *)v26);
  v13 = HGString::c_str(v26, v10, v11, v12);
  Entry = HGGLShaderCache::GetEntry(v9, v13);
  HGString::~HGString((HGString *)v26);
  result = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)this + 432))(this, Entry);
  if ((_DWORD)result)
    v16 = 0;
  else
    v16 = Entry;
  v17 = *((_QWORD *)this + 3 * v4 + 4);
  if (v16)
    v18 = v17 == 0;
  else
    v18 = 1;
  if (!v18)
  {
    v19 = (HGHandler *)(*(uint64_t (**)(HGGPURenderer *))(*(_QWORD *)this + 368))(this);
    v20 = *(unsigned int *)(v17 + 160);
    v21 = *(_QWORD *)(v17 + 20);
    v22 = *(_QWORD *)(v17 + 28);
    TextureRect = HGGLTexture::GetTextureRect((HGGLTexture *)v17);
    LODWORD(v25) = -*(_DWORD *)(v17 + 20);
    HIDWORD(v25) = -*(_DWORD *)(v17 + 24);
    (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v19 + 32))(v19, v20, v6, v5, v21, v22, TextureRect, v24, v25);
    HGHandler::TexCoord(v19, v4, 0, 0, 0);
    (*(void (**)(HGHandler *))(*(_QWORD *)v19 + 168))(v19);
    (*(void (**)(HGHandler *))(*(_QWORD *)v19 + 40))(v19);
    *(_QWORD *)&v27.var0 = v6;
    *(_QWORD *)&v27.var2 = v5;
    HGGPURenderer::Rect(this, v19, v27, (v4 + 1));
    return (*(uint64_t (**)(HGGPURenderer *, HGHandler *))(*(_QWORD *)this + 392))(this, v19);
  }
  return result;
}

void sub_1B2A43EC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

void HGGPURenderer::StartGPUCapture(HGGPURenderer *this)
{
  OZChannelBase *v1;
  int v3;
  const char *v4;
  __int128 v5;
  uint64_t v6;
  void *__p[2];
  uint64_t v8;
  uint64_t v9[2];
  int v10;

  v1 = (OZChannelBase *)*((_QWORD *)this + 139);
  if (v1)
  {
    v3 = *((_DWORD *)this + 366);
    if (v3)
    {
      if (v3 == 2)
      {
        v10 = 0;
        v9[0] = (uint64_t)this;
        v9[1] = (uint64_t)&v10;
        HGGPURenderer::StartGPUCapture(void)::$_0::operator()((uint64_t)__p, v9);
        while (1)
        {
          v4 = v8 >= 0 ? (const char *)__p : (const char *)__p[0];
          if (access(v4, 0))
            break;
          HGGPURenderer::StartGPUCapture(void)::$_0::operator()((uint64_t)&v5, v9);
          if (SHIBYTE(v8) < 0)
            operator delete(__p[0]);
          *(_OWORD *)__p = v5;
          v8 = v6;
        }
        OZChannelBase::setRangeName(v1, (const PCString *)1);
      }
      else
      {
        HIBYTE(v8) = 0;
        LOBYTE(__p[0]) = 0;
        OZChannelBase::setRangeName(v1, 0);
      }
      if (SHIBYTE(v8) < 0)
        operator delete(__p[0]);
      *((_DWORD *)this + 366) = 0;
    }
  }
}

void sub_1B2A43FC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t HGGPURenderer::StartGPUCapture(void)::$_0::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  char *v11;
  const std::locale::facet *v12;
  int v13;
  _QWORD *v14;
  uint64_t v15;
  std::locale v17[2];
  char v18;
  void *v19[2];
  char v20;
  _QWORD v21[2];
  _QWORD v22[11];
  char v23;
  uint64_t v24;

  v3 = *a2;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v21);
  v4 = *(char *)(v3 + 1047);
  if (v4 >= 0)
    v5 = v3 + 1024;
  else
    v5 = *(_QWORD *)(v3 + 1024);
  if (v4 >= 0)
    v6 = *(unsigned __int8 *)(v3 + 1047);
  else
    v6 = *(_QWORD *)(v3 + 1032);
  v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, v5, v6);
  v20 = 7;
  strcpy((char *)v19, "/helium");
  v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)v19, 7);
  v9 = v8;
  v10 = *v8;
  v11 = (char *)v8 + *(_QWORD *)(*v8 - 24);
  if (*((_DWORD *)v11 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(_QWORD *)(*v8 - 24)));
    v12 = std::locale::use_facet(v17, MEMORY[0x1E0DE4A90]);
    v13 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 32);
    std::locale::~locale(v17);
    *((_DWORD *)v11 + 36) = v13;
    v10 = *v9;
  }
  *((_DWORD *)v11 + 36) = 48;
  *(uint64_t *)((char *)v9 + *(_QWORD *)(v10 - 24) + 24) = 3;
  ++*(_DWORD *)a2[1];
  v14 = (_QWORD *)std::ostream::operator<<();
  v18 = 9;
  strcpy((char *)v17, ".gputrace");
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)v17, 9);
  if (v18 < 0)
  {
    operator delete(v17[0].__locale_);
    if ((v20 & 0x80000000) == 0)
      goto LABEL_11;
  }
  else if ((v20 & 0x80000000) == 0)
  {
    goto LABEL_11;
  }
  operator delete(v19[0]);
LABEL_11:
  std::stringbuf::str();
  v21[0] = *MEMORY[0x1E0DE4F50];
  v15 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)v21 + *(_QWORD *)(v21[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v22[0] = v15;
  v22[1] = MEMORY[0x1E0DE4FB8] + 16;
  if (v23 < 0)
    operator delete((void *)v22[9]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1B5E290BC](&v24);
}

void sub_1B2A441E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if ((a21 & 0x80000000) == 0)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a22);
    _Unwind_Resume(a1);
  }
  operator delete(__p);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void sub_1B2A44274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::RenderBgn(HGGPURenderer *this, int a2)
{
  uint64_t v3;
  HGGLContext *v4;
  uint64_t result;
  OZChannelBase *v6;
  const PCString *v7;
  PCSharedCount v8;

  HGRenderer::RenderBgn(this, a2);
  if (*((_BYTE *)this + 1281))
  {
    HGCVGLTextureFactory::flush(*((CVOpenGLESTextureCacheRef **)this + 147));
    HGGLState::startContextTracking(*((HGGLState **)this + 146));
    HGTextureManager::renderBgn(*((HGTextureManager **)this + 184));
    v3 = *((_QWORD *)this + 146);
    if (v3)
    {
      v4 = (HGGLContext *)*((_QWORD *)this + *((unsigned int *)this + 290) + 143);
      if (v4)
        HGGLContext::context((uint64_t *)&v8, v4);
      else
        HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v8, 0);
      HGGLState::setCurrentContext(v3, &v8.var0);
      PCSharedCount::PCSharedCount(&v8);
    }
    glIsTexture(0);
  }
  result = HGGLShaderCache::ClearStats(*((HGGLShaderCache **)this + 161));
  v6 = (OZChannelBase *)*((_QWORD *)this + 139);
  if (v6)
  {
    HGGPURenderer::StartGPUCapture(this);
    return OZChannelBase::setRangeName(v6, v7);
  }
  return result;
}

void sub_1B2A4433C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

double HGGPURenderer::RenderEnd(HGGPURenderer *this, int a2)
{
  _BOOL4 v4;
  BOOL v5;
  const PCString *v6;
  id *v7;
  unint64_t v8;
  const void *v9;
  HGMetalHandler *v10;
  OZChannelBase *v11;
  const char *v12;
  char *v13;
  double result;
  _QWORD *v15;
  _OWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  BOOL v20;

  if (HG_RENDERER_ENV::FORCE_POST_RENDER_FINISH)
  {
    v4 = 1;
    if (*((_BYTE *)this + 1281))
      goto LABEL_3;
LABEL_10:
    *((_DWORD *)this + 311) = 0;
    goto LABEL_11;
  }
  v4 = *((_DWORD *)this + 170) != 0;
  if (!*((_BYTE *)this + 1281))
    goto LABEL_10;
LABEL_3:
  if (*((_DWORD *)this + 311))
  {
    glFlush();
    if (*((_BYTE *)this + 1281))
      v5 = v4;
    else
      v5 = 0;
    *((_DWORD *)this + 311) = 0;
    if (v5)
      goto LABEL_14;
LABEL_11:
    HGGPURenderer::FrameEnd(this);
    if (!v4)
      goto LABEL_17;
    goto LABEL_15;
  }
  *((_DWORD *)this + 311) = 0;
  if (!v4)
  {
    HGGPURenderer::FrameEnd(this);
    v8 = *((unsigned int *)this + 172);
    if ((v8 & 0x80000000) != 0)
      goto LABEL_21;
    goto LABEL_18;
  }
LABEL_14:
  glFinish();
  HGGPURenderer::FrameEnd(this);
  if (!v4)
    goto LABEL_17;
LABEL_15:
  v7 = (id *)*((_QWORD *)this + 165);
  if (v7)
    HGMetalCommandBufferRef::waitUntilCompleted(v7);
LABEL_17:
  v8 = *((unsigned int *)this + 172);
  if ((v8 & 0x80000000) != 0)
    goto LABEL_21;
LABEL_18:
  v9 = (const void *)*((_QWORD *)this + 164);
  if (v9)
  {
    if (v10)
      HGMetalHandler::WaitForCommandBuffersCount(v10, v8);
  }
LABEL_21:
  v11 = (OZChannelBase *)*((_QWORD *)this + 139);
  if (v11)
    OZChannelBase::setRangeName(v11, v6);
  HGGPURenderer::PurgePostDeleteEvents((int64x2_t *)this);
  if (*((_BYTE *)this + 1281))
  {
    HGTextureManager::renderEnd(*((HGTextureManager **)this + 184));
    HGGLState::stopContextTracking(*((PCSharedCount **)this + 146));
  }
  HGRenderer::RenderEnd(this, a2);
  if (*((_QWORD *)this + 182))
  {
    v15 = (_QWORD *)*((_QWORD *)this + 180);
    v16 = (_OWORD *)((char *)this + 1448);
    if (v15 != (_QWORD *)((char *)this + 1448))
    {
      do
      {
        v17 = (_QWORD *)v15[4];
        if (!v17)
          __cxa_bad_typeid();
        HGLogger::warning((HGLogger *)"ProcessNode( %p) :\n  unable to subdivide input ROI for node (or concatenated chain) : %s\n", v12, v13, v15[4], *(_QWORD *)(*(_QWORD *)(*v17 - 8) + 8) & 0x7FFFFFFFFFFFFFFFLL);
        v18 = (_QWORD *)v15[1];
        if (v18)
        {
          do
          {
            v19 = v18;
            v18 = (_QWORD *)*v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            v19 = (_QWORD *)v15[2];
            v20 = *v19 == (_QWORD)v15;
            v15 = v19;
          }
          while (!v20);
        }
        v15 = v19;
      }
      while (v19 != (_QWORD *)v16);
    }
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 1440, *((_QWORD **)this + 181));
    *((_QWORD *)this + 180) = v16;
    result = 0.0;
    *v16 = 0u;
  }
  return result;
}

_DWORD *HGGPURenderer::FrameEnd(HGGPURenderer *this)
{
  const void *v2;
  HGMetalHandler *v3;
  HGMetalHandler *v4;
  id *v5;
  _DWORD *result;
  uint64_t v7;
  unsigned __int8 v8;
  unsigned int v9;
  unsigned int v10[2];

  (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
  v2 = (const void *)*((_QWORD *)this + 164);
  if (v2)
  {
    if (v3)
    {
      v4 = v3;
      HGMetalHandler::FinalizeCommandBuffer(v3);
      HGMetalHandler::BindBuffer(v4, 0);
    }
  }
  v5 = (id *)*((_QWORD *)this + 165);
  if (v5)
    HGMetalCommandBufferRef::waitUntilScheduled(v5);
  result = (_DWORD *)*((_QWORD *)this + 164);
  if (result)
  {
    if (result)
    {
      v7 = (uint64_t)result;
      v8 = atomic_load(HGLogger::_enabled);
      if ((v8 & 1) != 0 && *((int *)this + 163) >= 1)
      {
        *(_QWORD *)v10 = 0;
        v9 = 0;
        HGMetalHandler::GetFrameCounters(result, &v10[1], v10, &v9);
        printf("+ Helium Render Summary : %d command buffers, %d encoders, %d draw calls\n", v9, v10[0], v10[1]);
      }
      return (_DWORD *)HGMetalHandler::FrameEnd(v7);
    }
  }
  return result;
}

_QWORD *HGGPURenderer::WaitForCommandBuffers(_QWORD *this)
{
  unint64_t v1;

  v1 = *((unsigned int *)this + 172);
  if ((v1 & 0x80000000) == 0)
  {
    this = (_QWORD *)this[164];
    if (this)
    {
      if (this)
        return (_QWORD *)HGMetalHandler::WaitForCommandBuffersCount((HGMetalHandler *)this, v1);
    }
  }
  return this;
}

void HGGPURenderer::AdjustForBufferLocation(uint64_t a1, uint64_t a2, int a3)
{
  unsigned __int8 v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  int NodeRenderAPI;
  const char *v11;
  char *v12;
  const char *v13;
  char *v14;
  int v15;
  unsigned __int8 v16;
  const char *v17;
  BOOL v18;
  int v20;
  BOOL v21;
  _BYTE v22[16];

  HGLogger::setLevel((HGLogger *)"bufferAPI", 0);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v22, "bufferAPI", 1, "AdjustForBufferLocation(HGNode*)");
  v6 = atomic_load(HGLogger::_enabled);
  if ((v6 & 1) != 0)
  {
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 48))(a2);
    HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"node %p : %s\n", v8, v9, a2, v7);
  }
  NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI((HGGPURenderer *)a1, (HGNode *)a2);
  v15 = NodeRenderAPI;
  v16 = atomic_load(HGLogger::_enabled);
  if ((v16 & 1) != 0)
  {
    v17 = "Metal";
    if (!NodeRenderAPI)
      v17 = "OpenGL";
    HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"node API: %s\n", v13, v14, v17);
  }
  if (a3 == 4 && v15 == 1)
  {
    v18 = 1;
    goto LABEL_19;
  }
  v18 = a3 == 5 && v15 == 0;
  if (a3 == 4 || (a3 - 1) >= 2 && !v15)
  {
LABEL_19:
    if (*(_BYTE *)(a1 + 1280))
    {
      if (!v18)
      {
        v20 = *(_DWORD *)(a1 + 1272);
        if (v20 == 2)
        {
          HGLogger::error((HGLogger *)"%s", v11, v12, "OpenGL sharegroup : HGRendererBufferLocation is an OpenGL object.");
        }
        else if (v20 == 1)
        {
          HGLogger::warning((HGLogger *)"%s", v11, v12, "OpenGL sharegroup : HGRendererBufferLocation is an OpenGL object.");
        }
        goto LABEL_26;
      }
    }
    else
    {
      HGLogger::warning((HGLogger *)"no GL sharegroup : OpenGL HGRendererBufferLocation ignored.", v11, v12);
    }
LABEL_25:
    *(_DWORD *)(a2 + 16) |= 0x1000u;
    goto LABEL_26;
  }
  v21 = !v18;
  if (a3 == 1)
    v21 = 0;
  if (!v21)
    goto LABEL_25;
LABEL_26:
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v22);
}

void sub_1B2A44838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A4484C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A44860(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::GetNodeRenderAPI(HGGPURenderer *this, HGNode *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  BOOL v10;
  BOOL v12;
  uint64_t v13;
  const char *v14;
  char *v15;

  LODWORD(v4) = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)this + 128))(this, 43);
  v5 = HGNode::SupportsMetal(a2);
  v6 = HGNode::SupportsGLSL(a2);
  if ((v5 & 1) != 0 || (v6 & 1) != 0)
  {
    if ((_DWORD)v4)
      v4 = v4;
    else
      v4 = v6 ^ 1u;
    if ((_DWORD)v4 != 1)
    {
      if ((_DWORD)v4)
        v10 = 0;
      else
        v10 = *((_BYTE *)this + 1281) == 0;
      if (!v10)
        return v4;
      goto LABEL_18;
    }
  }
  else
  {
    v7 = (*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 48))(a2);
    HGLogger::warning((HGLogger *)"no supported API in node %s (%p)!!", v8, v9, v7, a2);
  }
  v4 = v5;
  if ((_DWORD)v5)
    v12 = 0;
  else
    v12 = *((_BYTE *)this + 1281) == 0;
  if (!v12)
    return v4;
LABEL_18:
  v13 = (*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 48))(a2);
  HGLogger::warning((HGLogger *)"OpenGL is not supported! No render path available for node %s (%p).", v14, v15, v13, a2);
  return v4;
}

const char *HGGPURenderer::ValidateGLSharegroupSupport(const char *this, const char *a2, char *a3)
{
  int v3;

  v3 = *((_DWORD *)this + 318);
  if (v3 == 2)
    return HGLogger::error((HGLogger *)"%s", a2, a3, a2);
  if (v3 == 1)
    return HGLogger::warning((HGLogger *)"%s", a2, a3, a2);
  return this;
}

_DWORD *HGGPURenderer::AdjustForBufferLocation(HGGPURenderer *a1, _DWORD *a2, int a3)
{
  const char *v6;
  const char *v7;
  char *v8;
  unsigned __int8 v9;
  const char *v10;
  unsigned __int8 v11;
  const char *v12;
  unsigned __int8 v13;
  const char *v14;
  unsigned __int8 v15;
  const char *v16;
  char v17;
  const char *v18;
  char *v19;
  char v20;
  unsigned __int8 v21;
  HGBitmap *v22;
  const char *v23;
  char *v24;
  int v25;
  _BOOL4 v26;
  BOOL v27;
  unsigned __int8 v28;
  BOOL v29;
  unsigned __int8 v30;
  uint64_t v31;
  uint64_t v32;
  HGBitmap *v33;
  HGBitmap *v34;
  int v35;
  unsigned __int8 v36;
  uint64_t v37;
  int v38;
  _DWORD *v40;
  _BYTE v41[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v41, "bufferAPI", 1, "AdjustForBufferLocation(HGBitmap*)");
  if ((int)HGLogger::getLevel((HGLogger *)"bufferAPI", v6) >= 1)
  {
    v9 = atomic_load(HGLogger::_enabled);
    if ((v9 & 1) != 0)
    {
      if ((a2[3] & 0x30) != 0)
        v10 = "no";
      else
        v10 = "yes";
      HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"buffer is cpu memory : %s\n", v7, v8, v10);
    }
    v11 = atomic_load(HGLogger::_enabled);
    if ((v11 & 1) != 0)
    {
      if ((a2[3] & 1) != 0)
        v12 = "yes";
      else
        v12 = "no";
      HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"buffer is IOSurface : %s\n", v7, v8, v12);
    }
    v13 = atomic_load(HGLogger::_enabled);
    if ((v13 & 1) != 0)
    {
      if ((a2[3] & 0x20) != 0)
        v14 = "yes";
      else
        v14 = "no";
      HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"buffer is Metal texture : %s\n", v7, v8, v14);
    }
    v15 = atomic_load(HGLogger::_enabled);
    if ((v15 & 1) != 0)
    {
      if ((a2[3] & 0x10) != 0)
        v16 = "yes";
      else
        v16 = "no";
      HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"buffer is OpenGL buffer/texture : %s\n", v7, v8, v16);
    }
  }
  v17 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)a2 + 64))(a2);
  if (a3 == 3)
    v20 = v17;
  else
    v20 = 1;
  if ((v20 & 1) != 0)
  {
    if (a3 == 2)
    {
      v21 = atomic_load(HGLogger::_enabled);
      if ((v21 & 1) != 0)
        HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"convert buffer to system memory bitmap\n", v18, v19);
      v22 = (HGBitmap *)(*(uint64_t (**)(HGGPURenderer *, _DWORD *, _QWORD))(*(_QWORD *)a1 + 96))(a1, a2, a2[4]);
      goto LABEL_48;
    }
    v27 = 0;
    v26 = a3 == 4;
    if (!*((_BYTE *)a1 + 1280))
      goto LABEL_40;
  }
  else
  {
    if (!*((_BYTE *)a1 + 1280))
    {
LABEL_43:
      v30 = atomic_load(HGLogger::_enabled);
      if ((v30 & 1) != 0)
        HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"convert buffer to Metal texture\n", v18, v19);
      if (HG_RENDERER_ENV::FORCE_NATIVE_TEXTURE_OUTPUT == 1)
        v22 = HGGPURenderer::ConvertToRawMetalTexture(a1, (HGBitmap *)a2);
      else
        v22 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)a1, *(HGRect *)(a2 + 5), (HGBitmap *)a2, 1);
LABEL_48:
      a2 = v22;
      if (!v22)
        goto LABEL_67;
      goto LABEL_62;
    }
    v25 = *((_DWORD *)a1 + 317);
    v26 = v25 == 0;
    v27 = v25 != 0;
    if (a3 == 4)
      v26 = 1;
  }
  if (v26)
  {
    v28 = atomic_load(HGLogger::_enabled);
    if ((v28 & 1) != 0)
      HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"convert buffer to OpenGL texture\n", v18, v19);
    if (HG_RENDERER_ENV::FORCE_NATIVE_TEXTURE_OUTPUT == 1)
    {
      v22 = (HGBitmap *)HGGPURenderer::ConvertToRawGLTexture(a1, (HGBitmap *)a2);
      goto LABEL_48;
    }
    v31 = *(_QWORD *)(a2 + 5);
    v32 = *(_QWORD *)(a2 + 7);
    v33 = HGGPURenderer::ConvertToNonMetalTexture(a1, (HGBitmap *)a2);
    v34 = v33;
    v35 = *((_DWORD *)v33 + 3);
    if ((v35 & 0x30) != 0)
    {
      if ((v35 & 0x10) == 0)
      {
LABEL_54:
        a2 = 0;
        goto LABEL_61;
      }
      if ((v35 & 0x100) == 0)
      {
        if ((v35 & 0x200) == 0)
          goto LABEL_54;
        a2 = v40;
        if (v40)
          (*(void (**)(_DWORD *))(*(_QWORD *)v40 + 16))(v40);
LABEL_61:
        (*(void (**)(HGBitmap *))(*(_QWORD *)v34 + 24))(v34);
        if (!a2)
          goto LABEL_67;
        goto LABEL_62;
      }
      (*(void (**)(HGGPURenderer *, HGBitmap *))(*(_QWORD *)a1 + 144))(a1, v33);
      v37 = (*(uint64_t (**)(HGGPURenderer *))(*(_QWORD *)a1 + 328))(a1);
    }
    else
    {
      v37 = (*(uint64_t (**)(HGGPURenderer *, uint64_t, uint64_t, HGBitmap *))(*(_QWORD *)a1 + 352))(a1, v31, v32, v33);
    }
    a2 = (_DWORD *)v37;
    goto LABEL_61;
  }
LABEL_40:
  v29 = !v27;
  if (a3 == 5)
    v29 = 0;
  if (!v29)
    goto LABEL_43;
  v36 = atomic_load(HGLogger::_enabled);
  if ((v36 & 1) != 0)
    HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"no-op. We're good.\n", v18, v19);
  (*(void (**)(_DWORD *))(*(_QWORD *)a2 + 16))(a2);
LABEL_62:
  if ((a2[3] & 0x10) != 0)
  {
    v38 = *((_DWORD *)a1 + 318);
    if (v38 == 2)
    {
      HGLogger::error((HGLogger *)"%s", v23, v24, "OpenGL sharegroup : HGGPURenderer output is an OpenGL object.");
    }
    else if (v38 == 1)
    {
      HGLogger::warning((HGLogger *)"%s", v23, v24, "OpenGL sharegroup : HGGPURenderer output is an OpenGL object.");
    }
  }
LABEL_67:
  (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v41);
  return a2;
}

void sub_1B2A44E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A44E40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A44E54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGGPURenderer::GenRectTexture(HGTextureManager **this, char *a2, char *a3, int a4, int a5, int a6, int a7, int a8, BOOL a9)
{
  int v14;
  _BYTE v17[64];

  v14 = (int)a3;
  if (a9)
    HGLogger::error((HGLogger *)"wrong texture creation function for shared texture", a2, a3);
  HGTextureManager::TextureInfo::TextureInfo((HGTextureManager::TextureInfo *)v17, v14, a4, a5, a6, a7, a8);
  HGTextureManager::createTexture(this[184], (unsigned int *)a2, (const HGTextureManager::TextureInfo *)v17);
}

void HGGPURenderer::AddTextureUsage(HGGPURenderer *this, HGBitmap *a2)
{
  char *v4;
  char *v5;
  unint64_t v6;
  uint64_t v7;
  void **v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  __int128 *v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;

  v4 = (char *)*((_QWORD *)this + 153);
  v5 = v4;
  v6 = *((_QWORD *)this + 154);
  if ((unint64_t)v4 < v6)
  {
    *(_QWORD *)v4 = a2;
    v7 = (uint64_t)(v4 + 8);
    goto LABEL_23;
  }
  v8 = (void **)((char *)this + 1216);
  v9 = (char *)*((_QWORD *)this + 152);
  v10 = (v4 - v9) >> 3;
  v11 = v10 + 1;
  if ((unint64_t)(v10 + 1) >> 61)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v12 = v6 - (_QWORD)v9;
  if (v12 >> 2 > v11)
    v11 = v12 >> 2;
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
    v13 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v13 = v11;
  if (v13)
  {
    if (v13 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v14 = (char *)operator new(8 * v13);
    v15 = &v14[8 * v10];
    v16 = &v14[8 * v13];
    *(_QWORD *)v15 = a2;
    v7 = (uint64_t)(v15 + 8);
    v17 = (char *)(v4 - v9);
    if (v4 == v9)
      goto LABEL_21;
    goto LABEL_14;
  }
  v14 = 0;
  v15 = (char *)(8 * v10);
  v16 = 0;
  *(_QWORD *)(8 * v10) = a2;
  v7 = 8 * v10 + 8;
  v17 = (char *)(v4 - v9);
  if (v4 != v9)
  {
LABEL_14:
    v18 = (unint64_t)(v17 - 8);
    if (v18 < 0x58)
      goto LABEL_28;
    if ((unint64_t)(v9 - v14) < 0x20)
      goto LABEL_28;
    v19 = (v18 >> 3) + 1;
    v20 = 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
    v5 = &v4[-v20];
    v15 -= v20;
    v21 = &v14[8 * v10 - 16];
    v22 = (__int128 *)(v4 - 16);
    v23 = v19 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v24 = *v22;
      *((_OWORD *)v21 - 1) = *(v22 - 1);
      *(_OWORD *)v21 = v24;
      v21 -= 32;
      v22 -= 2;
      v23 -= 4;
    }
    while (v23);
    if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_28:
      do
      {
        v25 = *((_QWORD *)v5 - 1);
        v5 -= 8;
        *((_QWORD *)v15 - 1) = v25;
        v15 -= 8;
      }
      while (v5 != v9);
    }
    v5 = (char *)*v8;
  }
LABEL_21:
  *((_QWORD *)this + 152) = v15;
  *((_QWORD *)this + 153) = v7;
  *((_QWORD *)this + 154) = v16;
  if (v5)
    operator delete(v5);
LABEL_23:
  *((_QWORD *)this + 153) = v7;
  *((_DWORD *)this + 310) = -1;
}

unint64_t HGGPURenderer::TextureUsageCount(HGGPURenderer *this)
{
  unint64_t result;
  _BYTE *v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char v15;

  result = *((unsigned int *)this + 310);
  if ((_DWORD)result == -1)
  {
    v3 = (_BYTE *)*((_QWORD *)this + 152);
    v4 = (_BYTE *)*((_QWORD *)this + 153);
    v5 = v4 - v3;
    if (v4 == v3)
    {
      v7 = 0;
      v6 = 0;
    }
    else
    {
      if (v5 < 0)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v6 = (char *)operator new(v4 - v3);
      v7 = &v6[8 * (v5 >> 3)];
      memcpy(v6, v3, v5);
    }
    v8 = 126 - 2 * __clz((v7 - v6) >> 3);
    if (v7 == v6)
      v9 = 0;
    else
      v9 = v8;
    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **,false>((uint64_t)v6, v7, (uint64_t)&v15, v9, 1);
    if (v7 != v6)
    {
      v10 = v6 + 8;
      while (v10 != v7)
      {
        v11 = *((_QWORD *)v10 - 1);
        v12 = *(_QWORD *)v10;
        v10 += 8;
        if (v11 == v12)
        {
          v13 = v10 - 16;
          while (v10 != v7)
          {
            v14 = v11;
            v11 = *(_QWORD *)v10;
            if (v14 != *(_QWORD *)v10)
            {
              *((_QWORD *)v13 + 1) = v11;
              v13 += 8;
            }
            v10 += 8;
          }
          v7 = v13 + 8;
          break;
        }
      }
    }
    if (v6)
      operator delete(v6);
    result = (unint64_t)(v7 - v6) >> 3;
    *((_DWORD *)this + 310) = result;
  }
  return result;
}

void sub_1B2A451E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  void *v10;

  if (v10)
    operator delete(v10);
  _Unwind_Resume(exception_object);
}

unsigned int *HGGPURenderer::Release(HGGPURenderer *this)
{
  unsigned int v2;
  uint64_t v3;
  char *v4;
  char *v5;
  int64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (HGGPURenderer::TextureUsageCount(this))
  {
    v2 = atomic_load((unsigned int *)this + 2);
    if (v2 == HGGPURenderer::TextureUsageCount(this) + 1)
    {
      HGObject::Retain((uint64_t)this);
      v3 = *((_QWORD *)this + 170);
      if (v3)
      {
        v4 = (char *)*((_QWORD *)this + 152);
        v5 = (char *)*((_QWORD *)this + 153);
        if (v4 != v5)
        {
          while (*(_QWORD *)v4 != v3)
          {
            v4 += 8;
            if (v4 == v5)
            {
              v4 = (char *)*((_QWORD *)this + 153);
              break;
            }
          }
        }
        v6 = v5 - (v4 + 8);
        if (v5 != v4 + 8)
        {
          memmove(v4, v4 + 8, v5 - (v4 + 8));
          v3 = *((_QWORD *)this + 170);
        }
        *((_QWORD *)this + 153) = &v4[v6];
        *((_DWORD *)this + 310) = -1;
        (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
        *((_QWORD *)this + 170) = 0;
      }
      v7 = *((_QWORD *)this + 171);
      if (v7)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
        *((_QWORD *)this + 171) = 0;
      }
      v8 = *((_QWORD *)this + 169);
      if (v8)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
        *((_QWORD *)this + 169) = 0;
      }
      (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
      HGObject::Release((unsigned int *)this);
    }
  }
  return HGObject::Release((unsigned int *)this);
}

void HGGPURenderer::SetParameter(HGRenderer *this, const char *a2, char *a3)
{
  int v3;
  int v5;
  int Target;
  int v7;
  int v8;
  POTPaddingPolicy *v9;
  POTPaddingPolicy *v10;
  _QWORD *v11;
  _QWORD *v12;
  std::string v13;
  std::string __p;
  POTPaddingPolicy *v15;
  POTPaddingPolicy *v16;

  v3 = (int)a3;
  switch((int)a2)
  {
    case 5:
    case 46:
      return;
    case 18:
      if (HG_RENDERER_ENV::FORCE_PAGE_SIZE == -1)
      {
        v5 = *((_DWORD *)this + 312);
        if (v5 >= (int)a3)
          v5 = (int)a3;
        *((_DWORD *)this + 165) = v5;
      }
      break;
    case 19:
      HGRenderer::SetParameter((uint64_t)this, 19, a3);
      Target = HGRenderer::GetTarget(this, 393216);
      if (*((_DWORD *)this + 144) == 28
        && (Target - 394305) <= 0xFFFFFFBE
        && HG_RENDERER_ENV::LOW_MEMORY_USAGE)
      {
        (*(void (**)(HGRenderer *, uint64_t, uint64_t))(*(_QWORD *)this + 120))(this, 26, 12);
      }
      break;
    case 20:
      v7 = *((_DWORD *)this + 145);
      HGRenderer::SetParameter((uint64_t)this, 20, a3);
      v8 = *((_DWORD *)this + 145);
      if (v7 != v8)
      {
        if (v8 == 28)
        {
          std::string::basic_string[abi:ne180100]<0>(&v13, "highp");
        }
        else if (v8 == 24)
        {
          std::string::basic_string[abi:ne180100]<0>(&v13, "lowp");
        }
        else
        {
          std::string::basic_string[abi:ne180100]<0>(&v13, "mediump");
        }
        __p = v13;
        HGGLState::resetUniforms(*((HGGLState ***)this + 146));
        HGGLShaderCache::SetPrecisionKeyword(*((_QWORD *)this + 161), &__p);
        HGGLShaderCache::ResetGLSL(*((HGGLShaderCache **)this + 161));
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }
      break;
    case 21:
      *((_DWORD *)this + 335) = (_DWORD)a3;
      break;
    case 25:
      *((_QWORD *)this + 157) = (uint64_t)(int)a3 << 20;
      break;
    case 26:
      *((_QWORD *)this + 157) = (unint64_t)(float)((float)((float)(int)a3 / 100.0)
                                                        * (float)*(unint64_t *)(PCICCTransferFunctionLUT::getLUTEnd(*((PCICCTransferFunctionLUT **)this + 139))
                                                                                     + 40));
      break;
    case 35:
      if (*((_BYTE *)this + 1281) && *((_QWORD *)this + 184))
      {
        v9 = (POTPaddingPolicy *)HGObject::operator new(0x10uLL);
        v10 = v9;
        if (v3 == 128)
        {
          POTPaddingPolicy::POTPaddingPolicy(v9);
          v11 = (_QWORD *)*((_QWORD *)this + 184);
          v16 = v10;
          if (v10)
            (*(void (**)(POTPaddingPolicy *))(*(_QWORD *)v10 + 16))(v10);
          HGTextureManager::setTexturePaddingPolicy(v11, (_QWORD **)&v16);
          if (v16)
            (*(void (**)(POTPaddingPolicy *))(*(_QWORD *)v16 + 24))(v16);
          if (v10)
            (*(void (**)(POTPaddingPolicy *))(*(_QWORD *)v10 + 24))(v10);
        }
        else
        {
          BorderPaddingPolicy::BorderPaddingPolicy(v9, v3);
          v12 = (_QWORD *)*((_QWORD *)this + 184);
          v15 = v10;
          if (v10)
            (*(void (**)(POTPaddingPolicy *))(*(_QWORD *)v10 + 16))(v10);
          HGTextureManager::setTexturePaddingPolicy(v12, (_QWORD **)&v15);
          if (v15)
            (*(void (**)(POTPaddingPolicy *))(*(_QWORD *)v15 + 24))(v15);
          if (v10)
            (*(void (**)(POTPaddingPolicy *))(*(_QWORD *)v10 + 24))(v10);
        }
      }
      break;
    case 37:
      *((_BYTE *)this + 1265) = (_DWORD)a3 != 0;
      break;
    case 38:
      if (HG_RENDERER_ENV::FORCE_TEXTURE_STORAGE_HINT == -1)
        *((_BYTE *)this + 1264) = (_BYTE)a3;
      break;
    case 39:
      *((_BYTE *)this + 1266) = (_DWORD)a3 != 0;
      break;
    case 43:
      *((_DWORD *)this + 317) = (_DWORD)a3;
      if (!(_DWORD)a3 && !*((_BYTE *)this + 1281))
      {
        *((_DWORD *)this + 317) = 1;
        HGLogger::warning((HGLogger *)"Renderer does not support OpenGL rendering! Welcome to the future!", a2, a3);
      }
      break;
    case 44:
      *((_DWORD *)this + 318) = (_DWORD)a3;
      break;
    case 45:
      *((_DWORD *)this + 319) = (_DWORD)a3;
      break;
    case 47:
      *((_DWORD *)this + 366) = (_DWORD)a3;
      break;
    default:
      HGRenderer::SetParameter((uint64_t)this, (int)a2, a3);
      break;
  }
}

void sub_1B2A45738(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  uint64_t v18;

  (*(void (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
  _Unwind_Resume(a1);
}

int HGGPURenderer::GetParameter(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 18:
      LODWORD(a1) = *(_DWORD *)(a1 + 660);
      break;
    case 21:
      LODWORD(a1) = *(_DWORD *)(a1 + 1340);
      break;
    case 25:
      a1 = *(_QWORD *)(a1 + 1256) >> 20;
      break;
    case 26:
      LODWORD(a1) = llroundf((float)(unint64_t)(*(_QWORD *)(a1 + 1256)/ *(_QWORD *)(PCICCTransferFunctionLUT::getLUTEnd(*(PCICCTransferFunctionLUT **)(a1 + 1112))+ 40))* 100.0);
      break;
    case 27:
      LODWORD(a1) = *(_DWORD *)(a1 + 1248);
      break;
    case 43:
      LODWORD(a1) = *(_DWORD *)(a1 + 1268);
      break;
    case 44:
      LODWORD(a1) = *(_DWORD *)(a1 + 1272);
      break;
    case 45:
      LODWORD(a1) = *(_DWORD *)(a1 + 1276);
      break;
    case 47:
      LODWORD(a1) = *(_DWORD *)(a1 + 1464);
      break;
    default:
      LODWORD(a1) = HGRenderer::GetParameter(a1, a2);
      break;
  }
  return a1;
}

char *HGGPURenderer::CreateBuffer(uint64_t a1, HGRect a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  BOOL v11;
  uint64_t v12;
  HGBuffer *v13;
  int v14;
  PCICCTransferFunctionLUT *v15;
  HGGPUResources *LUTEnd;
  const HGMetalDeviceInfo *v17;
  const HGMetalDeviceInfo *DeviceResources;
  const char *v19;
  const char *v21;
  HGBitmap *v22;
  HGRect v23;

  v7 = *(_QWORD *)&a2.var2;
  v8 = *(_QWORD *)&a2.var0;
  v9 = *(_DWORD *)(a1 + 620);
  if (v9 == 2)
    a5 = 1;
  if (v9)
    v11 = a5 == 0;
  else
    v11 = 1;
  if (!v11)
  {
    if ((_DWORD)a3 == 24)
      v14 = 23;
    else
      v14 = a3;
    v21 = 0;
    v15 = *(PCICCTransferFunctionLUT **)(a1 + 1112);
    if (v15)
    {
      LUTEnd = (HGGPUResources *)PCICCTransferFunctionLUT::getLUTEnd(v15);
      DeviceResources = HGGPUResources::getDeviceResources(LUTEnd, v17);
      if (DeviceResources)
      {
        v19 = (const char *)*((_QWORD *)DeviceResources + 3);
        if (v19)
        {
          (*(void (**)(_QWORD))(*(_QWORD *)v19 + 16))(*((_QWORD *)DeviceResources + 3));
          v21 = v19;
        }
      }
    }
    HGCVBitmap::create(&v21, v8, v7, v14, &v22);
    if (v21)
      (*(void (**)(const char *))(*(_QWORD *)v21 + 24))(v21);
    v13 = (HGBuffer *)HGObject::operator new(0x80uLL);
    *(_QWORD *)&v23.var0 = *(_QWORD *)((char *)v22 + 20);
    *(_QWORD *)&v23.var2 = *(_QWORD *)((char *)v22 + 28);
    HGBuffer::HGBuffer(v13, v23, v22);
    if (v22)
      (*(void (**)(HGBitmap *))(*(_QWORD *)v22 + 24))(v22);
    return (char *)v13;
  }
  if (a4 == 1)
  {
    v12 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 336))(a1, *(_QWORD *)&a2.var0, *(_QWORD *)&a2.var2, a3, a6, a7);
    v13 = (HGBuffer *)HGObject::operator new(0x80uLL);
    HGBuffer::HGBuffer(v13, *(HGRect *)(v12 + 20), (HGBitmap *)v12);
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
    return (char *)v13;
  }
  return HGGPURenderer::CreateBuffer(a1, a2, a3, a6);
}

void sub_1B2A45A68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void *v10;
  uint64_t v11;
  void *v12;

  v12 = v10;
  HGObject::operator delete(v12);
  (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
  _Unwind_Resume(a1);
}

char *HGGPURenderer::CreateBuffer(uint64_t a1, HGRect a2, int a3, int a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  HGGLContext *v15;
  int *v16;
  int v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  const char *v21;
  char *v22;
  unsigned int v23;
  unsigned int v25;
  HGRect v26;
  PCSharedCount v27;
  HGRect v28;

  if (a3)
  {
    v5 = *(_QWORD *)&a2.var2;
    v6 = *(_QWORD *)&a2.var0;
    v7 = a1;
    v26 = a2;
    LODWORD(a1) = a2.var0;
    if (a4)
    {
      v10 = *(_DWORD *)(v7 + 1340);
      if (v10)
      {
        v11 = HGRectMake4i(-v10, -v10, *(_DWORD *)(v7 + 1340), v10);
        v13 = v12;
        *(_QWORD *)&v28.var0 = v11;
        *(_QWORD *)&v28.var2 = v13;
        HGRect::Grow(&v26, v28);
        a2 = v26;
      }
      a1 = HGTextureManager::adjustTextureSize(*(HGTextureManager **)(v7 + 1472), a2);
      *(_QWORD *)&v26.var0 = a1;
      *(_QWORD *)&v26.var2 = v14;
      if (a3 != 31)
      {
LABEL_4:
        v8 = *(_QWORD *)(v7 + 1168);
        if (!v8)
          goto LABEL_15;
        goto LABEL_11;
      }
    }
    else if (a3 != 31)
    {
      goto LABEL_4;
    }
    v26.var2 = a1 + 6 * (((int)v5 - (int)v6 + 5) / 6u);
    v8 = *(_QWORD *)(v7 + 1168);
    if (!v8)
    {
LABEL_15:
      HGGLContext::isES2(*(HGGLContext **)(v7 + 1144 + 8 * *(unsigned int *)(v7 + 1160)));
      v16 = (int *)&s_HGFormatInfos[8 * a3];
      v17 = *v16;
      HGGLContext::isES2(*(HGGLContext **)(v7 + 1144 + 8 * *(unsigned int *)(v7 + 1160)));
      v18 = v16[2];
      HGGLContext::isES2(*(HGGLContext **)(v7 + 1144 + 8 * *(unsigned int *)(v7 + 1160)));
      v19 = v16[1];
      v25 = 0;
      HGTextureManager::TextureInfo::TextureInfo((HGTextureManager::TextureInfo *)&v27, 3553, v26.var2 - v26.var0, v26.var3 - v26.var1, v17, v19, v18);
      HGTextureManager::createTexture(*(HGTextureManager **)(v7 + 1472), &v25, (const HGTextureManager::TextureInfo *)&v27);
      HGTextureManager::activeTexture(*(HGTextureManager **)(v7 + 1472), 0x84C0u, v20, v21, v22);
      HGTextureManager::bindTexture(*(HGTextureManager **)(v7 + 1472), 0xDE1u, v25);
      glTexParameteri(0xDE1u, 0x2800u, 9728);
      glTexParameteri(0xDE1u, 0x2801u, 9728);
      glTexParameteri(0xDE1u, 0x2802u, 33071);
      glTexParameteri(0xDE1u, 0x2803u, 33071);
      HGTextureManager::texImage2D(*(HGTextureManager **)(v7 + 1472), 3553, 0, v17, v26.var2 - v26.var0, v26.var3 - v26.var1, 0, v19, v18, 0);
      HGTextureManager::bindTexture(*(HGTextureManager **)(v7 + 1472), 0xDE1u, 0);
      v9 = (char *)HGObject::operator new(0xB8uLL);
      HGGLBuffer::HGGLBuffer((uint64_t)v9, v6, v5, a3, v7);
      v23 = v25;
      *((_DWORD *)v9 + 39) = v25;
      *((_DWORD *)v9 + 40) = v23;
      *((_DWORD *)v9 + 38) = 3553;
      *(HGRect *)(v9 + 136) = v26;
      v9[180] = !HGRectIsEqual(*(uint64_t *)&v26.var0, *(uint64_t *)&v26.var2, v6, v5);
      return v9;
    }
LABEL_11:
    v15 = *(HGGLContext **)(v7 + 8 * *(unsigned int *)(v7 + 1160) + 1144);
    if (v15)
      HGGLContext::context((uint64_t *)&v27, v15);
    else
      HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v27, 0);
    HGGLState::setCurrentContext(v8, &v27.var0);
    PCSharedCount::PCSharedCount(&v27);
    goto LABEL_15;
  }
  HGLogger::error((HGLogger *)"CreateBuffer() : format == kHGFormat_Null.\n", *(const char **)&a2.var0, *(char **)&a2.var2);
  return 0;
}

void sub_1B2A45DAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, PCSharedCount a15)
{
  PCSharedCount::PCSharedCount(&a15);
  _Unwind_Resume(a1);
}

void sub_1B2A45DC0(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

char *HGGPURenderer::CreateBuffer(uint64_t a1, HGRect a2, int a3)
{
  return HGGPURenderer::CreateBuffer(a1, a2, a3, 1);
}

_QWORD *HGGPURenderer::CreateTexture(HGGPURenderer *this, uint64_t a2, HGGPURenderer *a3)
{
  uint64_t v4;
  HGGLContext *v5;
  uint64_t v6;
  _QWORD *Texture;
  PCSharedCount v9;

  if (!*((_QWORD *)this + 3))
    return 0;
  v4 = *((_QWORD *)this + 146);
  if (v4)
  {
    v5 = (HGGLContext *)*((_QWORD *)this + *((unsigned int *)this + 290) + 143);
    if (v5)
      HGGLContext::context((uint64_t *)&v9, v5);
    else
      HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v9, 0);
    HGGLState::setCurrentContext(v4, &v9.var0);
    PCSharedCount::PCSharedCount(&v9);
  }
  if (*((_BYTE *)this + 1281))
  {
    if (*((_DWORD *)this + 311))
      glFlush();
  }
  *((_DWORD *)this + 311) = 0;
  v6 = *((_QWORD *)this + 3);
  if (!*(_DWORD *)(v6 + 156))
    return 0;
  Texture = HGGLTexture::CreateTexture(*((HGGLTexture **)this + 3), this, a3);
  HGGPURenderer::AddTextureUsage(this, (HGBitmap *)v6);
  return Texture;
}

void sub_1B2A45EB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

void *HGGPURenderer::CreateMetalTexture(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char a5, int a6)
{
  uint64_t v9;
  void *v12;
  uint64_t *v13;
  void *v14;
  void *v15;
  void *v17;

  v9 = *(_QWORD *)(a1 + 1112);
  if (*(_BYTE *)(v9 + 52))
  {
    v12 = *(void **)(*(_QWORD *)(v9 + 16) + 16);
    v13 = (uint64_t *)HGMetalContext::texturePool((HGMetalContext *)v9);
    HGMetalTexture::create(v12, v13, a2, a3, a4, a5, 1, a6, &v17, 0);
    if (v17)
    {
      (*(void (**)(void *))(*(_QWORD *)v17 + 16))(v17);
      v14 = v17;
      v15 = v17;
      if (!v17)
        return v15;
      goto LABEL_7;
    }
    v15 = HGObject::operator new(0x80uLL);
    HGBuffer::HGBuffer((uint64_t)v15, 0, 0, a4);
    v14 = v17;
    if (v17)
LABEL_7:
      (*(void (**)(void *))(*(_QWORD *)v14 + 24))(v14);
  }
  else
  {
    v15 = HGObject::operator new(0x80uLL);
    HGBuffer::HGBuffer((uint64_t)v15, a2, a3, a4);
  }
  return v15;
}

void sub_1B2A45FCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void *v10;

  HGObject::operator delete(v10);
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(a1);
}

void HGGPURenderer::ReadBitmap(HGGPURenderer *this, HGRect a2, HGBitmap *a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  HGGLContext *v9;
  PCSharedCount v10;
  PCSharedCount v11[3];
  HGRect v12;

  if (*((_QWORD *)this + 3))
  {
    v4 = *((_DWORD *)a3 + 4);
    if (v4 != 31)
    {
      if (v4)
      {
        v5 = *(_QWORD *)&a2.var2;
        v6 = *(_QWORD *)&a2.var0;
        v8 = *((_QWORD *)this + 146);
        v9 = (HGGLContext *)*((_QWORD *)this + *((unsigned int *)this + 290) + 143);
        if (v9)
          HGGLContext::context((uint64_t *)&v10, v9);
        else
          HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v10, 0);
        HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v11, v8, &v10);
        PCSharedCount::PCSharedCount(&v10);
        if (*((_BYTE *)this + 1281))
        {
          if (*((_DWORD *)this + 311))
            glFlush();
        }
        *((_DWORD *)this + 311) = 0;
        *(_QWORD *)&v12.var0 = v6;
        *(_QWORD *)&v12.var2 = v5;
        HGGPURenderer::ReadBitmapClassic(this, v12, a3);
        HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v11);
      }
      else
      {
        HGLogger::error((HGLogger *)"ReadBitmap() : bmp->m_Format == kHGFormat_Null. No readback attempted.\n", *(const char **)&a2.var0, *(char **)&a2.var2);
      }
    }
  }
}

void sub_1B2A46108(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCSharedCount a9)
{
  PCSharedCount::PCSharedCount(&a9);
  _Unwind_Resume(a1);
}

void sub_1B2A4611C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

void HGGPURenderer::GetCurrentContext(HGGPURenderer *this@<X0>, uint64_t *a2@<X8>)
{
  HGGLContext *v2;

  v2 = (HGGLContext *)*((_QWORD *)this + *((unsigned int *)this + 290) + 143);
  if (v2)
    HGGLContext::context(a2, v2);
  else
    HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)a2, 0);
}

uint64_t HGGPURenderer::ReadBitmapClassic(HGGPURenderer *this, HGRect a2, HGBitmap *a3)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  GLsizei v19;
  int v20;
  int v21;
  GLint v22;
  unint64_t v23;
  _DWORD *v24;
  int v25;
  HGGPURenderer *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  GLint v33;
  char *v34;
  unsigned int *v35;
  uint64_t i;
  unsigned int *v37;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  unint64_t v45;
  char v46;
  int v47;
  unint64_t v48;
  GLint param;
  int parama;
  dispatch_group_t *v51;
  int v52;
  unsigned __int8 v53[8];
  uint64_t v54;
  uint64_t v55;
  HGRect v56;

  v4 = *(_QWORD *)&a2.var2;
  v5 = *(_QWORD *)&a2.var0;
  v55 = *MEMORY[0x1E0C80C00];
  v52 = 4352;
  kdebug_trace();
  v7 = *((_DWORD *)a3 + 4) - 14;
  v8 = *((_QWORD *)a3 + 7);
  v9 = *((_QWORD *)a3 + 8);
  param = s_Alignments[v9 % v8];
  v10 = HGRectIntersection(v5, v4, *(_QWORD *)(*((_QWORD *)this + 3) + 20), *(_QWORD *)(*((_QWORD *)this + 3) + 28));
  v12 = v11;
  *(_QWORD *)v53 = 0;
  v54 = 0;
  HGRenderUtils::BufferFiller::BufferFiller((HGRenderUtils::BufferFiller *)&v51);
  *(_QWORD *)&v56.var0 = v10;
  *(_QWORD *)&v56.var2 = v12;
  HGRenderUtils::BufferFiller::start(&v51, a3, v56, v53, *((unsigned int *)a3 + 14));
  v48 = v8;
  v13 = HGRectIntersection(v5, v4, *(_QWORD *)((char *)a3 + 20), *(_QWORD *)((char *)a3 + 28));
  v15 = v13;
  v16 = v13;
  v17 = HIDWORD(v13);
  if (*((_DWORD *)this + 290))
  {
    v18 = *((_QWORD *)this + 3);
    v16 = v13 - *(_DWORD *)(v18 + 20);
    LODWORD(v17) = HIDWORD(v13) - *(_DWORD *)(v18 + 24);
  }
  v19 = v14 - v13;
  v46 = v7 < 3;
  v47 = v4;
  v44 = HIDWORD(v14);
  v45 = HIDWORD(v13);
  v43 = v17;
  if (v7 > 2)
  {
    if (*((_DWORD *)a3 + 4) == 31)
    {
      v16 = 4 * v16 / 6;
      v19 = 4 * ((v19 + 5) / 6);
    }
  }
  else
  {
    if (v16 >= 0)
      v20 = v16;
    else
      v20 = v16 + 1;
    v16 = v20 >> 1;
    v21 = v19 + 2;
    if (v19 >= -1)
      v21 = v19 + 1;
    v19 = v21 >> 1;
  }
  v22 = param;
  v23 = v9;
  parama = v5;
  v24 = (_DWORD *)*((_QWORD *)this + 3);
  v41 = v24[5];
  v42 = v24[6];
  v25 = v24[34];
  v40 = v24[35];
  glPixelStorei(0xD05u, v22);
  v26 = this;
  v27 = *((_QWORD *)a3 + 10);
  v28 = *((_QWORD *)a3 + 8);
  v39 = *((_QWORD *)a3 + 7);
  v29 = *((int *)a3 + 5);
  v30 = *((int *)a3 + 6);
  HGGLContext::isES2(*((HGGLContext **)v26 + *((unsigned int *)v26 + 290) + 143));
  v31 = v23 / (v48 << v46);
  v32 = (v44 - v45);
  v33 = v41 - v25 + v16;
  v34 = (char *)(v27 + v28 * ((int)v45 - v30) + v39 * (v15 - v29));
  if (v47 - parama == (_DWORD)v31)
  {
    v35 = &s_HGFormatInfos[8 * *((unsigned int *)a3 + 4)];
    glReadPixels(v33, v42 - v40 + v43, v19, v44 - v45, v35[1], v35[2], v34);
  }
  else if ((int)v32 >= 1)
  {
    for (i = 0; i != v32; ++i)
    {
      v37 = &s_HGFormatInfos[8 * *((unsigned int *)a3 + 4)];
      glReadPixels(v33, v42 - v40 + v43 + i, v19, 1, v37[1], v37[2], &v34[*((_QWORD *)a3 + 8) * i]);
    }
  }
  glPixelStorei(0xD05u, 4);
  HGRenderUtils::BufferFiller::~BufferFiller((HGRenderUtils::BufferFiller *)&v51);
  return kdebug_trace();
}

void sub_1B2A46484(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, int a19, int a20,char a21)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t HGGPURenderer::ReadBitmapWithPBO(HGGPURenderer *this, HGRect a2, HGBitmap *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  void ***v15;
  HGGLContext *v16;
  void *v17;
  void **v18;
  void **v19;
  void *v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  PC_Sp_counted_base *var0;
  PC_Sp_counted_base *v27;
  PC_Sp_counted_base *v28;
  uint64_t v29;
  uint64_t v30;
  void *__p;
  void *v33;
  uint64_t v34;
  PCSharedCount v35;
  PC_Sp_counted_base *v36;
  uint64_t v37;
  PCSharedCount v38;
  void *v39;
  _BYTE *v40;
  uint64_t v41;
  int v42;
  dispatch_group_t *v43;
  int v44;
  unsigned __int8 v45[8];
  uint64_t v46;
  uint64_t v47;
  HGRect v48;

  v4 = *(_QWORD *)&a2.var2;
  v5 = *(_QWORD *)&a2.var0;
  v47 = *MEMORY[0x1E0C80C00];
  v44 = 4354;
  kdebug_trace();
  v7 = *((_QWORD *)this + 3);
  (*(void (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
  (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
  if (!*((_QWORD *)this + 179))
  {
    v8 = (_QWORD *)operator new();
    *v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
    *((_QWORD *)this + 179) = v8;
  }
  v9 = HGRectIntersection(v5, v4, *(_QWORD *)(v7 + 20), *(_QWORD *)(v7 + 28));
  v11 = v10;
  *(_QWORD *)v45 = 0;
  v46 = 0;
  HGRenderUtils::BufferFiller::BufferFiller((HGRenderUtils::BufferFiller *)&v43);
  *(_QWORD *)&v48.var0 = v9;
  *(_QWORD *)&v48.var2 = v11;
  HGRenderUtils::BufferFiller::start(&v43, a3, v48, v45, *((unsigned int *)a3 + 14));
  v42 = 800;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  PBOStrategy::PBOTilingPolicy::tile(&v42, v9, v11, (uint64_t *)&v39);
  v12 = (unint64_t)(v40 - (_BYTE *)v39) >> 4;
  if ((int)v12 <= 1)
    v13 = 1;
  else
    v13 = 6;
  while (1)
  {
    v14 = *((_QWORD *)this + 179);
    v15 = (void ***)(v14 + 8);
    if (v13 <= (uint64_t)(*(_QWORD *)(v14 + 8) - *(_QWORD *)v14) >> 3)
      break;
    v16 = (HGGLContext *)*((_QWORD *)this + *((unsigned int *)this + 290) + 143);
    if (v16)
      HGGLContext::context((uint64_t *)&v38, v16);
    else
      HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v38, 0);
    v17 = HGObject::operator new(0x40uLL);
    v35.var0 = v38.var0;
    HGPixelBufferObj::HGPixelBufferObj(v17, &v35);
    __p = v17;
    PCSharedCount::PCSharedCount(&v35);
    v18 = *v15;
    if ((unint64_t)*v15 < *(_QWORD *)(v14 + 16))
    {
      *v18 = __p;
      __p = 0;
      *v15 = v18 + 1;
    }
    else
    {
      v19 = (void **)std::vector<HGRef<HGPixelBufferObj>>::__push_back_slow_path<HGRef<HGPixelBufferObj>>((void **)v14, &__p);
      v20 = __p;
      *v15 = v19;
      if (v20)
        (*(void (**)(void *))(*(_QWORD *)v20 + 24))(v20);
    }
    PCSharedCount::PCSharedCount(&v38);
  }
  v35.var0 = 0;
  v36 = 0;
  v37 = 0;
  v21 = (_QWORD *)operator new();
  v21[2] = &v39;
  v21[3] = v14;
  *v21 = &off_1E6524268;
  v21[1] = &v35;
  v21[4] = v7;
  v22 = operator new();
  *(_QWORD *)(v22 + 16) = &v39;
  *(_QWORD *)(v22 + 24) = v14;
  *(_QWORD *)v22 = &off_1E65242D0;
  *(_QWORD *)(v22 + 8) = &v35;
  *(_DWORD *)(v22 + 32) = 10240000;
  v23 = (_QWORD *)operator new();
  v23[2] = &v39;
  v23[3] = v14;
  *v23 = &off_1E6524310;
  v23[1] = &v35;
  v24 = (_QWORD *)operator new();
  v24[2] = &v39;
  v24[3] = v14;
  *v24 = &off_1E6524350;
  v24[1] = &v35;
  v24[4] = a3;
  v25 = (_QWORD *)operator new();
  v25[2] = &v39;
  v25[3] = v14;
  *v25 = &off_1E6524390;
  v25[1] = &v35;
  if ((int)v12 < 2)
  {
    (*(void (**)(_QWORD *, _QWORD))(*v21 + 16))(v21, 0);
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v22 + 16))(v22, 0);
    (*(void (**)(_QWORD *, _QWORD))(*v23 + 16))(v23, 0);
    (*(void (**)(_QWORD *, _QWORD))(*v24 + 16))(v24, 0);
    (*(void (**)(_QWORD *, _QWORD))(*v25 + 16))(v25, 0);
  }
  else
  {
    __p = 0;
    v33 = 0;
    v34 = 0;
    PBOStrategy::Pipeliner::addStage((char **)&__p, (uint64_t)v21, 0);
    PBOStrategy::Pipeliner::addStage((char **)&__p, v22, 0);
    PBOStrategy::Pipeliner::addStage((char **)&__p, (uint64_t)v23, 1u);
    PBOStrategy::Pipeliner::addStage((char **)&__p, (uint64_t)v24, 0);
    PBOStrategy::Pipeliner::addStage((char **)&__p, (uint64_t)v25, 4u);
    PBOStrategy::Pipeliner::execute((PBOStrategy::Pipeliner *)&__p, v12);
    if (__p)
    {
      v33 = __p;
      operator delete(__p);
    }
  }
  (*(void (**)(_QWORD *))(*v21 + 8))(v21);
  (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
  (*(void (**)(_QWORD *))(*v23 + 8))(v23);
  (*(void (**)(_QWORD *))(*v24 + 8))(v24);
  (*(void (**)(_QWORD *))(*v25 + 8))(v25);
  (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  var0 = v35.var0;
  if (v35.var0)
  {
    v27 = v36;
    v28 = v35.var0;
    if (v36 != v35.var0)
    {
      do
      {
        v30 = *((_QWORD *)v27 - 1);
        v27 = (PC_Sp_counted_base *)((char *)v27 - 8);
        v29 = v30;
        if (v30)
          (*(void (**)(uint64_t))(*(_QWORD *)v29 + 24))(v29);
      }
      while (v27 != var0);
      v28 = v35.var0;
    }
    v36 = var0;
    operator delete(v28);
  }
  if (v39)
  {
    v40 = v39;
    operator delete(v39);
  }
  HGRenderUtils::BufferFiller::~BufferFiller((HGRenderUtils::BufferFiller *)&v43);
  return kdebug_trace();
}

void sub_1B2A469E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, PCSharedCount a12, uint64_t a13, uint64_t a14, PCSharedCount a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, char a20,int a21,int a22,char a23)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void PBOStrategy::PBOTilingPolicy::tile(_DWORD *a1, unint64_t a2, unint64_t a3, uint64_t *a4)
{
  unint64_t v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v8;
  unint64_t v9;
  int v10;
  BOOL v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t *v19;
  unint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  uint64_t *v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;

  v4 = HIDWORD(a2);
  v5 = HIDWORD(a3);
  a4[1] = *a4;
  v6 = (HIDWORD(a3) - HIDWORD(a2)) / *a1;
  if (v6 != -1)
  {
    v8 = a3;
    v9 = a2;
    v10 = 0;
    v32 = (HIDWORD(a3) - HIDWORD(a2)) / *a1;
    v33 = 6 * (((HIDWORD(a3) - HIDWORD(a2)) / (v6 + 1) + 6) / 6);
    v30 = HIDWORD(a3);
    v31 = a3;
    do
    {
      while (1)
      {
        v12 = v4 + v10 * v33;
        v13 = v10 == v6 ? v5 : v12 + v33;
        v14 = HGRectMake4i(v9, v12, v8, v13);
        v16 = v14;
        v17 = v15;
        v19 = (uint64_t *)a4[1];
        v18 = a4[2];
        if ((unint64_t)v19 >= v18)
          break;
        *v19 = v14;
        v19[1] = v15;
        v6 = v32;
        a4[1] = (uint64_t)(v19 + 2);
        v11 = v10++ == v32;
        if (v11)
          return;
      }
      v5 = v4;
      v20 = v9;
      v21 = (uint64_t *)*a4;
      v22 = ((uint64_t)v19 - *a4) >> 4;
      v23 = v22 + 1;
      if ((unint64_t)(v22 + 1) >> 60)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v24 = v18 - (_QWORD)v21;
      if (v24 >> 3 > v23)
        v23 = v24 >> 3;
      if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF0)
        v25 = 0xFFFFFFFFFFFFFFFLL;
      else
        v25 = v23;
      if (v25)
      {
        if (v25 >> 60)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v26 = (char *)operator new(16 * v25);
        v27 = (uint64_t *)&v26[16 * v22];
        *v27 = v16;
        v27[1] = v17;
        v28 = (uint64_t)v27;
        v9 = v20;
        if (v19 == v21)
        {
LABEL_26:
          v4 = v5;
          v6 = v32;
          v29 = v27 + 2;
          *a4 = v28;
          a4[1] = (uint64_t)(v27 + 2);
          a4[2] = (uint64_t)&v26[16 * v25];
          LODWORD(v5) = v30;
          if (!v19)
            goto LABEL_22;
          goto LABEL_21;
        }
      }
      else
      {
        v26 = 0;
        v27 = (uint64_t *)(16 * v22);
        *v27 = v16;
        v27[1] = v15;
        v28 = 16 * v22;
        v9 = v20;
        if (v19 == v21)
          goto LABEL_26;
      }
      v6 = v32;
      do
      {
        *(_OWORD *)(v28 - 16) = *((_OWORD *)v19 - 1);
        v28 -= 16;
        v19 -= 2;
      }
      while (v19 != v21);
      v19 = (uint64_t *)*a4;
      v4 = v5;
      v29 = v27 + 2;
      *a4 = v28;
      a4[1] = (uint64_t)(v27 + 2);
      a4[2] = (uint64_t)&v26[16 * v25];
      LODWORD(v5) = v30;
      if (!v19)
        goto LABEL_22;
LABEL_21:
      operator delete(v19);
LABEL_22:
      v8 = v31;
      a4[1] = (uint64_t)v29;
      v11 = v10++ == v6;
    }
    while (!v11);
  }
}

void PBOStrategy::Pipeliner::addStage(char **a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;

  v5 = a3;
  v7 = a1[1];
  v6 = (unint64_t)a1[2];
  if ((unint64_t)v7 < v6)
  {
    *(_QWORD *)v7 = a2;
    *((_QWORD *)v7 + 1) = a3;
    v8 = (uint64_t)(v7 + 16);
    goto LABEL_18;
  }
  v9 = *a1;
  v10 = (v7 - *a1) >> 4;
  v11 = v10 + 1;
  if ((unint64_t)(v10 + 1) >> 60)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v12 = v6 - (_QWORD)v9;
  if (v12 >> 3 > v11)
    v11 = v12 >> 3;
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0)
    v13 = 0xFFFFFFFFFFFFFFFLL;
  else
    v13 = v11;
  if (v13)
  {
    if (v13 >> 60)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v14 = (char *)operator new(16 * v13);
    v15 = &v14[16 * v10];
    v16 = &v14[16 * v13];
    *(_QWORD *)v15 = a2;
    *((_QWORD *)v15 + 1) = v5;
    v8 = (uint64_t)(v15 + 16);
    if (v7 == v9)
      goto LABEL_16;
    goto LABEL_14;
  }
  v15 = (char *)(16 * v10);
  v16 = 0;
  *(_QWORD *)v15 = a2;
  *((_QWORD *)v15 + 1) = a3;
  v8 = 16 * v10 + 16;
  if (v7 != v9)
  {
    do
    {
LABEL_14:
      *((_OWORD *)v15 - 1) = *((_OWORD *)v7 - 1);
      v15 -= 16;
      v7 -= 16;
    }
    while (v7 != v9);
    v7 = *a1;
  }
LABEL_16:
  *a1 = v15;
  a1[1] = (char *)v8;
  a1[2] = v16;
  if (v7)
    operator delete(v7);
LABEL_18:
  a1[1] = (char *)v8;
}

void PBOStrategy::Pipeliner::execute(PBOStrategy::Pipeliner *this, int a2)
{
  unint64_t v4;
  uint64_t v5;
  int32x4_t *v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  int *v10;
  unint64_t v11;
  _DWORD *v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int32x4_t *v17;
  unint64_t v18;
  int v19;
  __int32 v20;
  int32x4_t *v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  uint64_t v26;
  int32x4_t v27;
  uint64_t v28;
  uint64_t v29;
  int32x4_t *v30;
  int v31;
  __int32 v32;
  unint64_t v33;
  int32x4_t *v34;
  int32x4_t v35;
  int v36;
  int32x4_t v37;
  uint64_t v38;
  int32x4_t *v39;
  int v40;
  __int32 v41;
  int32x4_t *v42;
  unint64_t v43;
  int32x4_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  int32x4_t *v56;
  unint64_t v57;
  unint64_t v58;

  v4 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  v5 = operator new[]();
  v6 = (int32x4_t *)v5;
  v7 = v4 & 0xFFFFFFFF0;
  if ((v4 & 0xFFFFFFFF0) != 0)
  {
    v8 = 0;
    v9 = (v4 >> 4);
    v10 = (int *)(*(_QWORD *)this + 8);
    v11 = v9;
    v12 = (_DWORD *)v5;
    do
    {
      v13 = *v10;
      v10 += 4;
      v8 += v13;
      *v12++ = -v8;
      --v11;
    }
    while (v11);
    v14 = (v8 + a2);
    if ((int)v14 >= 1)
    {
      if (v9 > 7)
      {
        v23 = (v4 >> 4) & 7;
        v24 = v9 - v23;
        v58 = v9 - v23;
        if (v23)
        {
          v25 = 0;
          v26 = v24;
          v57 = v24 + 1;
          v54 = v24 + 1;
          v55 = v24 + 2;
          v53 = v24 + 2;
          v27.i64[0] = 0x100000001;
          v27.i64[1] = 0x100000001;
          v51 = v24 + 4;
          v52 = v24 + 3;
          v49 = v24 + 5;
          v50 = v24 + 3;
          v48 = v24 + 4;
          v56 = (int32x4_t *)(v5 + 16);
          v46 = v24 + 5;
          v47 = v24 + 6;
          v45 = v24 + 6;
          do
          {
            v28 = v14;
            v29 = 0;
            v30 = v6;
            do
            {
              v32 = v30->i32[0];
              v30 = (int32x4_t *)((char *)v30 + 4);
              v31 = v32;
              if ((v32 & 0x80000000) == 0 && v31 < a2)
              {
                (*(void (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)this + v29) + 16))(*(_QWORD *)(*(_QWORD *)this + v29));
                v27.i64[0] = 0x100000001;
                v27.i64[1] = 0x100000001;
              }
              v29 += 16;
            }
            while (v7 != v29);
            v33 = v58;
            v34 = v56;
            do
            {
              v35 = vaddq_s32(*v34, v27);
              v34[-1] = vaddq_s32(v34[-1], v27);
              *v34 = v35;
              v34 += 2;
              v33 -= 8;
            }
            while (v33);
            ++v6->i32[v26];
            v14 = v28;
            if (v57 != v9)
            {
              ++v6->i32[v54];
              if (v55 != v9)
              {
                ++v6->i32[v53];
                if (v52 != v9)
                {
                  ++v6->i32[v50];
                  if (v51 != v9)
                  {
                    ++v6->i32[v48];
                    if (v49 != v9)
                    {
                      ++v6->i32[v46];
                      if (v47 != v9)
                        ++v6->i32[v45];
                    }
                  }
                }
              }
            }
            ++v25;
          }
          while (v25 != (_DWORD)v28);
        }
        else
        {
          v36 = 0;
          v37.i64[0] = 0x100000001;
          v37.i64[1] = 0x100000001;
          do
          {
            v38 = 0;
            v39 = v6;
            do
            {
              v41 = v39->i32[0];
              v39 = (int32x4_t *)((char *)v39 + 4);
              v40 = v41;
              if ((v41 & 0x80000000) == 0 && v40 < a2)
              {
                (*(void (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)this + v38) + 16))(*(_QWORD *)(*(_QWORD *)this + v38));
                v37.i64[0] = 0x100000001;
                v37.i64[1] = 0x100000001;
              }
              v38 += 16;
            }
            while (v7 != v38);
            v42 = v6 + 1;
            v43 = v58;
            do
            {
              v44 = vaddq_s32(*v42, v37);
              v42[-1] = vaddq_s32(v42[-1], v37);
              *v42 = v44;
              v42 += 2;
              v43 -= 8;
            }
            while (v43);
            ++v36;
          }
          while (v36 != (_DWORD)v14);
        }
      }
      else
      {
        v15 = 0;
        do
        {
          v16 = 0;
          v17 = v6;
          v18 = v9;
          do
          {
            v20 = v17->i32[0];
            v17 = (int32x4_t *)((char *)v17 + 4);
            v19 = v20;
            if ((v20 & 0x80000000) == 0 && v19 < a2)
              (*(void (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)this + v16) + 16))(*(_QWORD *)(*(_QWORD *)this + v16));
            v16 += 16;
            --v18;
          }
          while (v18);
          v21 = v6;
          v22 = v9;
          do
          {
            ++v21->i32[0];
            v21 = (int32x4_t *)((char *)v21 + 4);
            --v22;
          }
          while (v22);
          ++v15;
        }
        while (v15 != (_DWORD)v14);
      }
    }
  }
  JUMPOUT(0x1B5E2914CLL);
}

void **std::vector<HGRef<HGBitmap>>::~vector[abi:ne180100](void **a1)
{
  char *v2;
  char *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  v2 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        v6 = *((_QWORD *)v3 - 1);
        v3 -= 8;
        v5 = v6;
        if (v6)
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
      }
      while (v3 != v2);
      v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

HGBuffer *HGGPURenderer::LoadNullBuffer(HGGPURenderer *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  HGBuffer *v6;

  v2 = (void *)*((_QWORD *)this + 169);
  if (!v2)
  {
    v2 = HGObject::operator new(0x80uLL);
    v3 = HGRectMake4i(0, 0, 0, 0);
    HGBitmap::HGBitmap(v2, v3, v4, 24);
    *((_QWORD *)this + 169) = v2;
  }
  (*(void (**)(void *))(*(_QWORD *)v2 + 16))(v2);
  v5 = *((_QWORD *)this + 169);
  v6 = (HGBuffer *)HGObject::operator new(0x80uLL);
  HGBuffer::HGBuffer(v6, *(HGRect *)(v5 + 20), (HGBitmap *)v5);
  (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  return v6;
}

void sub_1B2A472A8(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A472BC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

unsigned int *HGGPURenderer::LoadNullGLTexture(HGGPURenderer *this)
{
  uint64_t v2;
  unsigned int *v3;
  uint64_t v4;
  const char *v5;
  char *v6;
  const char *v7;
  char *v8;
  unsigned __int8 v9;
  _BYTE v11[64];
  HGRect v12;

  v2 = *((_QWORD *)this + 170);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
    return (unsigned int *)*((_QWORD *)this + 170);
  }
  else
  {
    v3 = (unsigned int *)HGObject::operator new(0xC8uLL);
    *(_QWORD *)&v12.var0 = 0;
    *(_QWORD *)&v12.var2 = 0;
    HGGLTexture::HGGLTexture((HGGLTexture *)v3, v12, 0, this);
    HGTextureManager::TextureInfo::TextureInfo((HGTextureManager::TextureInfo *)v11, 3553, 1, 1, 6408, 6408, 5121);
    HGTextureManager::createTexture(*((HGTextureManager **)this + 184), v3 + 42, (const HGTextureManager::TextureInfo *)v11);
    HGTextureManager::activeTexture(*((HGTextureManager **)this + 184), 0x84C0u, v4, v5, v6);
    HGTextureManager::bindTexture(*((HGTextureManager **)this + 184), 0xDE1u, v3[42]);
    v3[40] = 3553;
    *((_QWORD *)v3 + 22) = *((_QWORD *)v3 + 21);
    HGTextureManager::texImage2D(*((HGTextureManager **)this + 184), 3553, 0, 6408, 1, 1, 0, 6408, 0x1401u, &HGGPURenderer::LoadNullGLTexture(void)::black_pixel);
    HGTextureManager::bindTexture(*((HGTextureManager **)this + 184), 0xDE1u, 0);
    v9 = atomic_load(HGLogger::_enabled);
    if ((v9 & 1) != 0)
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"Uploading black texture to ID %d\n", v7, v8, *((_QWORD *)v3 + 21));
    *((_QWORD *)this + 170) = v3;
    (*(void (**)(unsigned int *))(*(_QWORD *)v3 + 16))(v3);
    HGGPURenderer::AddTextureUsage(this, *((HGBitmap **)this + 170));
  }
  return v3;
}

void sub_1B2A47440(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::LoadNullMetalTexture(HGGPURenderer *this)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  HGMetalContext *v8;
  void *v9;
  char *v10;
  HGMetalTexture *v11;
  uint64_t v12;
  HGMetalTexture *v13;

  v2 = *((_QWORD *)this + 171);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
    return *((_QWORD *)this + 171);
  }
  else
  {
    v4 = HGRectMake4i(0, 0, 1u, 1u);
    v6 = v5;
    v7 = (char *)HGObject::operator new(0x80uLL);
    HGBitmap::HGBitmap(v7, v4, v6, 24);
    bzero(*((void **)v7 + 10), *((_QWORD *)v7 + 9));
    v8 = (HGMetalContext *)*((_QWORD *)this + 139);
    v9 = *(void **)(*((_QWORD *)v8 + 2) + 16);
    v10 = (char *)HGMetalContext::texturePool(v8);
    HGMetalTexture::createWithCopy(v9, v10, (uint64_t)v7, *(_QWORD *)(v7 + 20), *(_QWORD *)(v7 + 28), 0, 0, &v13);
    (*(void (**)(HGMetalTexture *))(*(_QWORD *)v13 + 16))(v13);
    v11 = v13;
    *((_QWORD *)this + 171) = v13;
    (*(void (**)(HGMetalTexture *))(*(_QWORD *)v11 + 16))(v11);
    v12 = *((_QWORD *)this + 171);
    if (v13)
      (*(void (**)(HGMetalTexture *))(*(_QWORD *)v13 + 24))(v13);
    (*(void (**)(char *))(*(_QWORD *)v7 + 24))(v7);
    return v12;
  }
}

void sub_1B2A47578(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

unsigned int *HGGPURenderer::LoadTexture(HGGPURenderer *this, HGRect a2, HGBitmap *a3)
{
  return HGGPURenderer::LoadTexture(this, a2, a3, 1);
}

unsigned int *HGGPURenderer::LoadTexture(HGGPURenderer *this, HGRect a2, HGBitmap *a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  HGGLContext *v10;
  uint64_t v11;
  HGBitmap *v12;
  unsigned int *NullGLTexture;
  unsigned int *v14;
  void *CVBitmapStorage;
  const void *v17;
  HGMetalHandler *v18;
  HGMetalHandler *v19;
  id *v20;
  uint64_t v21;
  HGBitmap *v22;
  const HGEdgePolicy *EdgePolicy;
  void *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  int var0;
  GLint v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  char *v38;
  _BOOL4 IsEqual;
  unsigned __int8 v40;
  unsigned __int8 v41;
  unsigned __int8 v42;
  unsigned __int8 v43;
  const char *v44;
  int var3;
  int var2;
  int var1;
  int v48;
  unsigned __int8 v49;
  unsigned __int8 v50;
  unsigned __int8 v51;
  const char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  _BOOL4 v56;
  int v57;
  unsigned __int8 v58;
  unsigned __int8 v59;
  const char *v60;
  unsigned __int8 v61;
  const char *v62;
  unsigned __int8 v63;
  const char *v64;
  unsigned __int8 v65;
  const char *v66;
  unsigned __int8 v67;
  const char *v68;
  int *v69;
  int v70;
  int v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  const char *v75;
  char *v76;
  uint64_t v77;
  unsigned int v78;
  unsigned int v79;
  GLint v80;
  GLint v81;
  GLsizei v82;
  uint64_t v83;
  unsigned int *v84;
  uint64_t i;
  unsigned int *v86;
  const char *v87;
  char *v88;
  int v89;
  unsigned __int8 v90;
  signed int v91;
  int v92;
  signed int v93;
  unint64_t v94;
  signed int v95;
  unsigned int v96;
  uint64_t v97;
  unsigned int v98;
  signed int v99;
  signed int v100;
  unint64_t *v101;
  uint64_t v102;
  unint64_t *v103;
  uint64_t v104;
  signed int v105;
  uint64_t v106;
  size_t v107;
  void *pixels;
  _DWORD *v109;
  _DWORD *v110;
  unsigned int *v111;
  void *v112;
  unsigned __int8 v113;
  uint64_t v114;
  uint64_t v115;
  unsigned int v116;
  int v117;
  _BOOL4 v118;
  unsigned int v119;
  unsigned int v120;
  _BOOL4 v121;
  int v122;
  __int128 v123;
  void *__p;
  _DWORD *v125;
  uint64_t v126;
  _BYTE v127[16];
  _BYTE v128[24];
  uint64_t v129;
  uint64_t v130;
  HGRect v131;
  HGRect v132;
  PCSharedCount v133;
  PCSharedCount v134[3];
  _BYTE v135[32];
  HGRect v136;
  HGRect v137;

  v6 = *(_QWORD *)&a2.var2;
  v7 = *(_QWORD *)&a2.var0;
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v135, "lt", 1, "HGGPURenderer::LoadTexture");
  v9 = *((_QWORD *)this + 146);
  v10 = (HGGLContext *)*((_QWORD *)this + *((unsigned int *)this + 290) + 143);
  if (v10)
    HGGLContext::context((uint64_t *)&v133, v10);
  else
    HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v133, 0);
  HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v134, v9, &v133);
  PCSharedCount::PCSharedCount(&v133);
  if (!a3)
  {
    NullGLTexture = HGGPURenderer::LoadNullGLTexture(this);
    goto LABEL_9;
  }
  *(_QWORD *)&v132.var0 = 0;
  *(_QWORD *)&v132.var2 = 0;
  *(_QWORD *)&v132.var0 = HGRectIntersection(v7, v6, *(_QWORD *)((char *)a3 + 20), *(_QWORD *)((char *)a3 + 28));
  *(_QWORD *)&v132.var2 = v11;
  if (HGRect::IsNull(&v132) || *((_DWORD *)a3 + 4) == 31)
  {
LABEL_7:
    NullGLTexture = HGGPURenderer::LoadNullGLTexture(this);
LABEL_9:
    v14 = NullGLTexture;
    goto LABEL_10;
  }
  CVBitmapStorage = HGCVBitmap::getCVBitmapStorage(a3, v12);
  if (CVBitmapStorage)
  {
    (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
    v17 = (const void *)*((_QWORD *)this + 164);
    if (v17)
    {
      if (v18)
      {
        v19 = v18;
        HGMetalHandler::FinalizeCommandBuffer(v18);
        HGMetalHandler::BindBuffer(v19, 0);
      }
    }
    v20 = (id *)*((_QWORD *)this + 165);
    if (v20)
      HGMetalCommandBufferRef::waitUntilScheduled(v20);
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v128, "lt", 1, "LoadTexture -- via CVOpenGLTextureCacheCreateTextureFromImage");
    v21 = *((_QWORD *)this + 147);
    (*(void (**)(void *))(*(_QWORD *)CVBitmapStorage + 16))(CVBitmapStorage);
    *(_QWORD *)&v131.var0 = CVBitmapStorage;
    HGCVGLTextureFactory::create(&__p, v21, &v131);
    if (*(_QWORD *)&v131.var0)
      (*(void (**)(_QWORD))(**(_QWORD **)&v131.var0 + 24))(*(_QWORD *)&v131.var0);
    v22 = (HGBitmap *)__p;
    if (__p)
    {
      EdgePolicy = (const HGEdgePolicy *)HGBitmap::GetEdgePolicy(a3);
      HGBitmap::SetEdgePolicy(v22, EdgePolicy);
      HGGLTexture::AssignRenderer((HGGLTexture *)__p, this);
      if (!__p)
      {
        v14 = 0;
        goto LABEL_29;
      }
      (*(void (**)(void *))(*(_QWORD *)__p + 16))(__p);
      v24 = __p;
      v14 = (unsigned int *)__p;
      if (!__p)
        goto LABEL_29;
    }
    else
    {
      v14 = HGGPURenderer::LoadNullGLTexture(this);
      v24 = __p;
      if (!__p)
      {
LABEL_29:
        HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v128);
        goto LABEL_10;
      }
    }
    (*(void (**)(void *))(*(_QWORD *)v24 + 24))(v24);
    goto LABEL_29;
  }
  if (!*((_QWORD *)a3 + 10))
    goto LABEL_7;
  v25 = *((_DWORD *)a3 + 4);
  v26 = (v25 - 14);
  v27 = *((_QWORD *)a3 + 8) % *((_QWORD *)a3 + 7);
  if (v26 >= 3)
  {
    if (v25 == 31)
    {
      v132.var2 = vcvts_n_s32_f32(ceilf((float)v132.var2 / 6.0), 2uLL);
      v132.var0 = vcvts_n_s32_f32(floorf((float)v132.var0 / 6.0), 2uLL);
      v28 = *(_QWORD *)&v132.var0;
      LODWORD(v26) = vcvtps_s32_f32((float)((float)v132.var2 * 3.0) * 0.5);
      v29 = *(_QWORD *)&v132.var2 & 0xFFFFFFFF00000000 | v26;
      var0 = vcvtms_s32_f32((float)((float)v132.var0 * 3.0) * 0.5);
    }
    else
    {
      v28 = *(_QWORD *)&v132.var0;
      v29 = *(_QWORD *)&v132.var2;
      var0 = v132.var0;
    }
  }
  else
  {
    v132.var2 = vcvtps_s32_f32((float)v132.var2 * 0.5);
    v132.var0 = vcvtms_s32_f32((float)v132.var0 * 0.5);
    v28 = *(_QWORD *)&v132.var0;
    v29 = *(_QWORD *)&v132.var2 & 0xFFFFFFFF00000000 | (int)(float)((float)v132.var2 + (float)v132.var2);
    var0 = (int)(float)((float)(int)v28 + (float)(int)v28);
  }
  v31 = s_Alignments[v27];
  v131 = v132;
  if (a4 && !*(_DWORD *)HGBitmap::GetEdgePolicy(a3))
  {
    v32 = *((_DWORD *)this + 335);
    if (v32)
    {
      v33 = HGRectMake4i(-v32, -v32, v32, *((_DWORD *)this + 335));
      v35 = v34;
      *(_QWORD *)&v136.var0 = v33;
      *(_QWORD *)&v136.var2 = v35;
      HGRect::Grow(&v131, v136);
    }
    *(_QWORD *)&v131.var0 = HGTextureManager::adjustTextureSize(*((HGTextureManager **)this + 184), v131);
    *(_QWORD *)&v131.var2 = v36;
  }
  v116 = var0;
  IsEqual = HGRectIsEqual(*(uint64_t *)&v131.var0, *(uint64_t *)&v131.var2, *(uint64_t *)&v132.var0, *(uint64_t *)&v132.var2);
  v40 = atomic_load(HGLogger::_enabled);
  if ((v40 & 1) != 0)
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"bitmap rect : [%d %d %d %d]\n", v37, v38, *((unsigned int *)a3 + 5), *((unsigned int *)a3 + 6), *((unsigned int *)a3 + 7), *((unsigned int *)a3 + 8));
  v41 = atomic_load(HGLogger::_enabled);
  if ((v41 & 1) != 0)
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"inter rect  : [%d %d %d %d]\n", v37, v38, v132.var0, v132.var1, v132.var2, v132.var3);
  v42 = atomic_load(HGLogger::_enabled);
  if ((v42 & 1) != 0)
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"padded rect : [%d %d %d %d]\n", v37, v38, v131.var0, v131.var1, v131.var2, v131.var3);
  v43 = atomic_load(HGLogger::_enabled);
  if ((v43 & 1) != 0)
  {
    v44 = "no";
    if (!IsEqual)
      v44 = "yes";
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"padded : %s\n", v37, v38, v44);
  }
  var2 = v131.var2;
  var3 = v131.var3;
  v48 = v131.var0;
  var1 = v131.var1;
  v49 = atomic_load(HGLogger::_enabled);
  if ((v49 & 1) != 0)
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"FORCE_UPLOAD_SUB_IMAGE    : %s\n", v37, v38, "no");
  v50 = atomic_load(HGLogger::_enabled);
  if ((v50 & 1) != 0)
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"FORCE_UPLOAD_LINE_BY_LINE : %s\n", v37, v38, "no");
  v51 = atomic_load(HGLogger::_enabled);
  if ((v51 & 1) != 0)
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"FORCE_TEX_COPY            : %s\n", v37, v38, "no");
  (*(void (**)(HGBitmap *))(*(_QWORD *)a3 + 16))(a3);
  v54 = *((_QWORD *)a3 + 7);
  v55 = *((_QWORD *)a3 + 8);
  v118 = IsEqual;
  v56 = IsEqual && v54 * (v131.var2 - v131.var0) == v55;
  v114 = v54 * (v132.var2 - v132.var0);
  v115 = *((_QWORD *)a3 + 8);
  v121 = v56;
  v57 = v114 == v55 || v56;
  v58 = atomic_load(HGLogger::_enabled);
  if ((v58 & 1) != 0)
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"NO_GL_UNPACK_ROW_LENGTH : %s\n", v52, v53, "yes");
  v59 = atomic_load(HGLogger::_enabled);
  if ((v59 & 1) != 0)
  {
    v60 = "no";
    if (v121)
      v60 = "yes";
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"canUploadFull     : %s\n", v52, v53, v60);
  }
  v61 = atomic_load(HGLogger::_enabled);
  if ((v61 & 1) != 0)
  {
    v62 = "no";
    if (v114 == v115)
      v62 = "yes";
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"canUploadSubImage : %s\n", v52, v53, v62);
  }
  v63 = atomic_load(HGLogger::_enabled);
  if ((v63 & 1) != 0)
  {
    v64 = "no";
    if (!v118)
      v64 = "yes";
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"needBorderUpload  : %s\n", v52, v53, v64);
  }
  v65 = atomic_load(HGLogger::_enabled);
  if ((v65 & 1) != 0)
  {
    v66 = "yes";
    if (v121)
      v66 = "no";
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"uploadSubImage    : %s\n", v52, v53, v66);
  }
  v67 = atomic_load(HGLogger::_enabled);
  if ((v67 & 1) != 0)
  {
    v68 = "yes";
    if (v57)
      v68 = "no";
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"uploadLineByLine  : %s\n", v52, v53, v68);
  }
  HGGLContext::isES2(*((HGGLContext **)this + *((unsigned int *)this + 290) + 143));
  v14 = (unsigned int *)HGObject::operator new(0xC8uLL);
  *(_QWORD *)&v137.var0 = v28 & 0xFFFFFFFF00000000 | v116;
  *(_QWORD *)&v137.var2 = v29;
  HGGLTexture::HGGLTexture((HGGLTexture *)v14, v137, a3, this);
  v69 = (int *)&s_HGFormatInfos[8 * v14[4]];
  v70 = *v69;
  v71 = v69[1];
  v72 = v69[2];
  *(HGRect *)(v14 + 5) = v132;
  HGTextureManager::TextureInfo::TextureInfo((HGTextureManager::TextureInfo *)v128, 3553, var2 - v48, var3 - var1, v70, v71, v72);
  if (v121)
  {
    v73 = *((_QWORD *)v14 + 8);
    v129 = *((_QWORD *)v14 + 10);
    v130 = v73;
  }
  HGTextureManager::createTexture(*((HGTextureManager **)this + 184), v14 + 42, (const HGTextureManager::TextureInfo *)v128);
  HGTextureManager::activeTexture(*((HGTextureManager **)this + 184), 0x84C0u, v74, v75, v76);
  HGTextureManager::bindTexture(*((HGTextureManager **)this + 184), 0xDE1u, v14[42]);
  v14[40] = 3553;
  *((_QWORD *)v14 + 22) = *((_QWORD *)v14 + 21);
  *((HGRect *)v14 + 9) = v131;
  if (!v121)
    HGTextureManager::texImage2D(*((HGTextureManager **)this + 184), (const HGTextureManager::TextureInfo *)v128);
  glPixelStorei(0xCF5u, v31);
  if (v121)
  {
    HGTextureManager::texImage2D(*((HGTextureManager **)this + 184), (const HGTextureManager::TextureInfo *)v128);
  }
  else
  {
    v77 = *((_QWORD *)v14 + 10);
    v78 = v14[5];
    v79 = v14[6];
    v80 = v78 - v131.var0;
    v81 = v79 - v131.var1;
    v82 = v14[7] - v78;
    v83 = v14[8] - v79;
    if (v114 == v115)
    {
      v84 = &s_HGFormatInfos[8 * v14[4]];
      glTexSubImage2D(0xDE1u, 0, v80, v81, v82, v83, v84[1], v84[2], *((const GLvoid **)v14 + 10));
    }
    else if ((int)v83 >= 1)
    {
      for (i = 0; i != v83; ++i)
      {
        v86 = &s_HGFormatInfos[8 * v14[4]];
        glTexSubImage2D(0xDE1u, 0, v80, v81 + i, v82, 1, v86[1], v86[2], (const GLvoid *)(v77 + *((_QWORD *)v14 + 8) * i));
      }
    }
  }
  glPixelStorei(0xCF5u, 4);
  if (v118)
  {
    v89 = !v121;
    v90 = atomic_load(HGLogger::_enabled);
    if ((v90 & 1) == 0)
      goto LABEL_118;
  }
  else
  {
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v127, "lt", 1, "border sub-tex image");
    __p = 0;
    v125 = 0;
    v126 = 0;
    v91 = v132.var0;
    v92 = v132.var3;
    v122 = v132.var2;
    v93 = v131.var0;
    v94 = v131.var2;
    v95 = v131.var3;
    if (v131.var1 >= v132.var1)
    {
      v98 = 0;
      v96 = v132.var1;
      v99 = v132.var3;
    }
    else
    {
      v117 = v132.var0;
      v119 = v131.var2;
      v96 = v132.var1;
      *(_QWORD *)&v123 = HGRectMake4i(v131.var0, v131.var1, v131.var2, v132.var1);
      *((_QWORD *)&v123 + 1) = v97;
      std::vector<HGRect>::push_back[abi:ne180100]((char **)&__p, &v123);
      v98 = (HIDWORD(v123) - DWORD1(v123)) * (DWORD2(v123) - v123);
      v99 = v92;
      v94 = v119;
      v91 = v117;
    }
    if (v95 > v99)
    {
      v120 = v96;
      v100 = v91;
      v123 = 0uLL;
      v101 = (unint64_t *)v94;
      *(_QWORD *)&v123 = HGRectMake4i(v93, v99, v94, v95);
      *((_QWORD *)&v123 + 1) = v102;
      std::vector<HGRect>::push_back[abi:ne180100]((char **)&__p, &v123);
      if (v98 <= (HIDWORD(v123) - DWORD1(v123)) * (DWORD2(v123) - (int)v123))
        v98 = (HIDWORD(v123) - DWORD1(v123)) * (DWORD2(v123) - v123);
      v94 = (unint64_t)v101;
      v91 = v100;
      v96 = v120;
    }
    if (v93 >= v91)
    {
      v105 = v122;
    }
    else
    {
      v103 = (unint64_t *)v94;
      v123 = 0uLL;
      *(_QWORD *)&v123 = HGRectMake4i(v93, v96, v91, v99);
      *((_QWORD *)&v123 + 1) = v104;
      std::vector<HGRect>::push_back[abi:ne180100]((char **)&__p, &v123);
      if (v98 <= (HIDWORD(v123) - DWORD1(v123)) * (DWORD2(v123) - (int)v123))
        v98 = (HIDWORD(v123) - DWORD1(v123)) * (DWORD2(v123) - v123);
      v105 = v122;
      v94 = (unint64_t)v103;
    }
    if ((int)v94 > v105)
    {
      v123 = 0uLL;
      *(_QWORD *)&v123 = HGRectMake4i(v105, v96, v94, v99);
      *((_QWORD *)&v123 + 1) = v106;
      std::vector<HGRect>::push_back[abi:ne180100]((char **)&__p, &v123);
      if (v98 <= (HIDWORD(v123) - DWORD1(v123)) * (DWORD2(v123) - (int)v123))
        v98 = (HIDWORD(v123) - DWORD1(v123)) * (DWORD2(v123) - v123);
    }
    v107 = *((_QWORD *)a3 + 7) * v98;
    pixels = (void *)HGMemory::allocate((HGMemory *)v107, 0, (unint64_t *)v94);
    bzero(pixels, v107);
    glPixelStorei(0xCF5u, 1);
    v109 = __p;
    v110 = v125;
    if (__p != v125)
    {
      do
      {
        v111 = &s_HGFormatInfos[8 * v14[4]];
        glTexSubImage2D(0xDE1u, 0, *v109 - v131.var0, v109[1] - v131.var1, v109[2] - *v109, v109[3] - v109[1], v111[1], v111[2], pixels);
        v109 += 4;
      }
      while (v109 != v110);
    }
    glPixelStorei(0xCF5u, 4);
    HGMemory::release((HGMemory *)pixels, v112);
    if (__p)
    {
      v125 = __p;
      operator delete(__p);
    }
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v127);
    v89 = 1;
    v113 = atomic_load(HGLogger::_enabled);
    if ((v113 & 1) == 0)
      goto LABEL_118;
  }
  HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"Uploading %s texture ID %d (%dx%d)\n", v87, v88, "2D", *((_QWORD *)v14 + 21), v14[7] - v14[5], v14[8] - v14[6]);
LABEL_118:
  if (v89)
    glFlush();
  HGTextureManager::bindTexture(*((HGTextureManager **)this + 184), 0xDE1u, 0);
  (*(void (**)(HGBitmap *))(*(_QWORD *)a3 + 24))(a3);
LABEL_10:
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v134);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v135);
  return v14;
}

void sub_1B2A48188(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,char a23,uint64_t a24,char a25)
{
  uint64_t v25;

  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)(v25 - 136));
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v25 - 112));
  _Unwind_Resume(a1);
}

void HGGPURenderer::FlushMetalCommandBuffer(HGGPURenderer *this)
{
  const void *v2;
  HGMetalHandler *v3;
  HGMetalHandler *v4;
  id *v5;

  (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
  v2 = (const void *)*((_QWORD *)this + 164);
  if (v2)
  {
    if (v3)
    {
      v4 = v3;
      HGMetalHandler::FinalizeCommandBuffer(v3);
      HGMetalHandler::BindBuffer(v4, 0);
    }
  }
  v5 = (id *)*((_QWORD *)this + 165);
  if (v5)
    HGMetalCommandBufferRef::waitUntilScheduled(v5);
}

void std::vector<HGRect>::push_back[abi:ne180100](char **a1, _OWORD *a2)
{
  unint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;

  v5 = a1[1];
  v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 < v4)
  {
    *(_OWORD *)v5 = *a2;
    v6 = v5 + 16;
LABEL_3:
    a1[1] = v6;
    return;
  }
  v7 = *a1;
  v8 = (v5 - *a1) >> 4;
  v9 = v8 + 1;
  if ((unint64_t)(v8 + 1) >> 60)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v10 = v4 - (_QWORD)v7;
  if (v10 >> 3 > v9)
    v9 = v10 >> 3;
  if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0)
    v11 = 0xFFFFFFFFFFFFFFFLL;
  else
    v11 = v9;
  if (v11)
  {
    if (v11 >> 60)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v12 = (char *)operator new(16 * v11);
  }
  else
  {
    v12 = 0;
  }
  v13 = &v12[16 * v8];
  *(_OWORD *)v13 = *a2;
  v6 = v13 + 16;
  if (v5 != v7)
  {
    do
    {
      *((_OWORD *)v13 - 1) = *((_OWORD *)v5 - 1);
      v13 -= 16;
      v5 -= 16;
    }
    while (v5 != v7);
    v5 = *a1;
  }
  *a1 = v13;
  a1[1] = v6;
  a1[2] = &v12[16 * v11];
  if (!v5)
    goto LABEL_3;
  operator delete(v5);
  a1[1] = v6;
}

uint64_t HGGPURenderer::SetProjectionMatrix(HGGPURenderer *this, HGTransform *a2)
{
  return (*(uint64_t (**)(_QWORD, HGTransform *))(**((_QWORD **)this + 151) + 96))(*((_QWORD *)this + 151), a2);
}

uint64_t HGGPURenderer::BindBuffer(HGGPURenderer *this, HGBitmap *a2)
{
  uint64_t v4;
  HGGLContext *v5;
  uint64_t v6;
  const char *v7;
  char *v8;
  HGTextureManager *v9;
  HGBitmap *v10;
  uint64_t v11;
  HGBitmap *v12;
  char *v13;
  int v14;
  void *CVBitmapStorage;
  const char *v16;
  char *v17;
  uint64_t v18;
  void *v19;
  PC_Sp_counted_base *var0;
  int v21;
  uint64_t v22;
  void *v24;
  PCSharedCount v25;

  v4 = *((_QWORD *)this + 146);
  if (v4)
  {
    v5 = (HGGLContext *)*((_QWORD *)this + *((unsigned int *)this + 290) + 143);
    if (v5)
      HGGLContext::context((uint64_t *)&v25, v5);
    else
      HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v25, 0);
    HGGLState::setCurrentContext(v4, &v25.var0);
    PCSharedCount::PCSharedCount(&v25);
  }
  (*(void (**)(HGGPURenderer *, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 152))(this, 0, 0, 0, 0);
  (*(void (**)(HGGPURenderer *, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 152))(this, 1, 0, 0, 0);
  (*(void (**)(HGGPURenderer *, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 152))(this, 2, 0, 0, 0);
  (*(void (**)(HGGPURenderer *, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 152))(this, 3, 0, 0, 0);
  (*(void (**)(HGGPURenderer *, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 152))(this, 4, 0, 0, 0);
  (*(void (**)(HGGPURenderer *, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 152))(this, 5, 0, 0, 0);
  (*(void (**)(HGGPURenderer *, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 152))(this, 6, 0, 0, 0);
  (*(void (**)(HGGPURenderer *, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 152))(this, 7, 0, 0, 0);
  v9 = (HGTextureManager *)*((_QWORD *)this + 184);
  if (v9)
    HGTextureManager::activeTexture(v9, 0x84C0u, v6, v7, v8);
  v10 = (HGBitmap *)*((_QWORD *)this + 168);
  if (a2 && v10 == a2)
    return 0;
  if (v10)
  {
    (*(void (**)(HGBitmap *))(*(_QWORD *)v10 + 24))(v10);
    *((_QWORD *)this + 168) = 0;
  }
  if (a2)
  {
    *((_QWORD *)this + 168) = a2;
    (*(void (**)(HGBitmap *))(*(_QWORD *)a2 + 16))(a2);
    a2 = (HGBitmap *)*((_QWORD *)this + 168);
    if (a2)
    {
      v14 = *((_DWORD *)a2 + 3);
      if ((v14 & 0x10) == 0)
      {
        CVBitmapStorage = HGCVBitmap::getCVBitmapStorage(*((HGBitmap **)this + 168), v12);
        if (CVBitmapStorage)
        {
          v18 = *((_QWORD *)this + 147);
          if (v18)
          {
            v19 = CVBitmapStorage;
            (*(void (**)(void *))(*(_QWORD *)CVBitmapStorage + 16))(CVBitmapStorage);
            v24 = v19;
            HGCVGLTextureFactory::create(&v25, v18, &v24);
            if (v24)
              (*(void (**)(void *))(*(_QWORD *)v24 + 24))(v24);
            var0 = v25.var0;
            v21 = *((_DWORD *)v25.var0 + 40);
            v22 = *((_QWORD *)v25.var0 + 21);
            a2 = (HGBitmap *)HGObject::operator new(0xB8uLL);
            HGGLBuffer::HGGLBuffer((uint64_t)a2, *(_QWORD *)((char *)var0 + 20), *(_QWORD *)((char *)var0 + 28), *((_DWORD *)var0 + 4), (uint64_t)this, v21, v22, 1);
            HGBitmap::SetStorage(a2, (HGObject *)v25.var0);
            if (v25.var0)
              (*(void (**)(PC_Sp_counted_base *))(*(_QWORD *)v25.var0 + 24))(v25.var0);
            if (a2)
              goto LABEL_28;
          }
        }
        goto LABEL_26;
      }
      if ((v14 & 0x100) == 0)
      {
        HGLogger::warning((HGLogger *)"BindBuffer() : bitmap is a texture, not a buffer", (const char *)v12, v13);
LABEL_26:
        a2 = 0;
        HGLogger::warning((HGLogger *)"BindBuffer() : couldn't bind buffer", v16, v17);
        goto LABEL_28;
      }
      (*(void (**)(_QWORD))(*(_QWORD *)a2 + 16))(*((_QWORD *)this + 168));
    }
  }
LABEL_28:
  v11 = HGGPURenderer::BindBufferInternal(this, a2);
  if (a2)
    (*(void (**)(HGBitmap *))(*(_QWORD *)a2 + 24))(a2);
  return v11;
}

void sub_1B2A48778(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  uint64_t v10;

  if (a10.var0)
    (*(void (**)(PC_Sp_counted_base *))(*(_QWORD *)a10.var0 + 24))(a10.var0);
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  _Unwind_Resume(exception_object);
}

uint64_t HGGPURenderer::BindBufferInternal(HGGPURenderer *this, HGBitmap *a2)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  int64_t v8;
  uint64_t v9;
  const char *v10;
  char *v11;
  uint64_t v13;
  HGGLContext *v14;
  uint64_t v15;
  HGGLContext *v16;
  const char *v17;
  char *v18;
  unsigned __int8 v19;
  const char *v20;
  GLsizei v21;
  GLsizei v22;
  PCSharedCount v23;

  if (*((_BYTE *)this + 1281))
    glUseProgram(0);
  v4 = *((_QWORD *)this + 3);
  if (v4)
  {
    v5 = *((_QWORD *)this + 3);
    if (*(_DWORD *)(v4 + 156))
    {
      HGTextureManager::framebufferTexture2D(*((HGTextureManager **)this + 184), *(_DWORD *)(v4 + 152), 0);
      v5 = *((_QWORD *)this + 3);
    }
    v6 = (char *)*((_QWORD *)this + 152);
    v7 = (char *)*((_QWORD *)this + 153);
    if (v6 != v7)
    {
      while (*(_QWORD *)v6 != v5)
      {
        v6 += 8;
        if (v6 == v7)
        {
          v6 = (char *)*((_QWORD *)this + 153);
          break;
        }
      }
    }
    v8 = v7 - (v6 + 8);
    if (v7 != v6 + 8)
      memmove(v6, v6 + 8, v7 - (v6 + 8));
    *((_QWORD *)this + 153) = &v6[v8];
    *((_DWORD *)this + 310) = -1;
    HGGLBuffer::DetachRenderer(v4);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 3) + 24))(*((_QWORD *)this + 3));
    *((_QWORD *)this + 3) = 0;
  }
  if (a2)
  {
    *((_QWORD *)this + 3) = a2;
    (*(void (**)(HGBitmap *))(*(_QWORD *)a2 + 16))(a2);
    v9 = *((_QWORD *)this + 3);
    if (!v9 || *(HGGPURenderer **)(v9 + 128) != this)
    {
      (*(void (**)(_QWORD))(*(_QWORD *)v9 + 24))(*((_QWORD *)this + 3));
      *((_QWORD *)this + 3) = 0;
      HGLogger::warning((HGLogger *)"BindBufferInternal() : buffer is tied to another renderer", v10, v11);
      return 0xFFFFFFFFLL;
    }
    *((_DWORD *)this + 290) = s_HGFormatInfos[8 * *(unsigned int *)(v9 + 16) + 4];
    if (*((_BYTE *)this + 1281) && *((_DWORD *)this + 311))
      glFlush();
    *((_DWORD *)this + 311) = 0;
    v15 = *((_QWORD *)this + 146);
    if (v15)
    {
      v16 = (HGGLContext *)*((_QWORD *)this + *((unsigned int *)this + 290) + 143);
      if (v16)
        HGGLContext::context((uint64_t *)&v23, v16);
      else
        HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v23, 0);
      HGGLState::setCurrentContext(v15, &v23.var0);
      PCSharedCount::PCSharedCount(&v23);
    }
    if (*(_DWORD *)(v9 + 156))
    {
      HGGPURenderer::BindCachedFramebuffer(this, *((unsigned int *)this + 290), (*(_DWORD *)(v9 + 144) - *(_DWORD *)(v9 + 136)), (*(_DWORD *)(v9 + 148) - *(_DWORD *)(v9 + 140)));
      HGTextureManager::framebufferTexture2D(*((HGTextureManager **)this + 184), *(_DWORD *)(v9 + 152), *(unsigned int *)(v9 + 156));
      v19 = atomic_load(HGLogger::_enabled);
      if ((v19 & 1) != 0)
      {
        v20 = "RECT";
        if (*(_DWORD *)(v9 + 152) == 3553)
          v20 = "2D";
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"Drawing into FBO with %s texture ID %d\n", v17, v18, v20, *(unsigned int *)(v9 + 156));
      }
      if (*(_BYTE *)(v9 + 180))
      {
        v21 = *(_DWORD *)(v9 + 144) - *(_DWORD *)(v9 + 136);
        v22 = *(_DWORD *)(v9 + 148) - *(_DWORD *)(v9 + 140);
        if ((v22 * v21) > 0xFFF)
        {
          glViewport(0, 0, v21, v22);
          (*(void (**)(_QWORD, float, float, float, float, float, float))(**((_QWORD **)this + 151) + 104))(*((_QWORD *)this + 151), (float)*(int *)(v9 + 136), (float)*(int *)(v9 + 144), (float)*(int *)(v9 + 140), (float)*(int *)(v9 + 148), -1.0, 1.0);
          HGGPURenderer::Clear(this, *(HGRect *)(v9 + 20), *(HGRect *)(v9 + 136));
        }
        else
        {
          glClearColor(0.0, 0.0, 0.0, 0.0);
          glClear(0x4000u);
        }
        *(_BYTE *)(v9 + 180) = 0;
      }
      glViewport(*(_DWORD *)(v9 + 20) - *(_DWORD *)(v9 + 136), *(_DWORD *)(v9 + 24) - *(_DWORD *)(v9 + 140), *(_DWORD *)(v9 + 172), *(_DWORD *)(v9 + 176));
      (*(void (**)(_QWORD, float, float, float, float, float, float))(**((_QWORD **)this + 151) + 104))(*((_QWORD *)this + 151), (float)*(int *)(v9 + 20), (float)*(int *)(v9 + 28), (float)*(int *)(v9 + 24), (float)*(int *)(v9 + 32), -1.0, 1.0);
    }
    HGGLBuffer::AttachRenderer(v9, (uint64_t)this);
    HGGPURenderer::AddTextureUsage(this, *((HGBitmap **)this + 3));
  }
  else
  {
    *((_DWORD *)this + 290) = *((_DWORD *)this + 158) != 0;
    if (*((_BYTE *)this + 1281) && *((_DWORD *)this + 311))
      glFlush();
    *((_DWORD *)this + 311) = 0;
    v13 = *((_QWORD *)this + 146);
    if (v13)
    {
      v14 = (HGGLContext *)*((_QWORD *)this + *((unsigned int *)this + 290) + 143);
      if (v14)
        HGGLContext::context((uint64_t *)&v23, v14);
      else
        HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v23, 0);
      HGGLState::setCurrentContext(v13, &v23.var0);
      PCSharedCount::PCSharedCount(&v23);
    }
  }
  return 0;
}

void sub_1B2A48BBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount a12)
{
  PCSharedCount::PCSharedCount(&a12);
  _Unwind_Resume(a1);
}

void sub_1B2A48BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount a12)
{
  PCSharedCount::PCSharedCount(&a12);
  _Unwind_Resume(a1);
}

void HGGPURenderer::BindCachedFramebuffer(HGGPURenderer *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 v8;
  unsigned __int8 v9;
  uint64_t *v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  uint64_t *v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  char *v21;
  unsigned __int8 v22;
  unsigned __int8 v23;
  unsigned __int8 v24;
  uint64_t *v25;
  unsigned __int8 v26;
  unsigned __int8 v27;
  unsigned __int8 v28;
  unsigned __int8 v29;
  unsigned __int8 v30;
  uint64_t *v31;
  unsigned __int8 v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  GLuint v36;
  unsigned __int8 v37;
  char *v38;
  const char *v39;
  char *v40;
  uint64_t v41;
  unsigned __int8 v42;
  FBOStrategy *v43;
  uint64_t v44;
  uint64_t v45;
  __int16 v46;
  char v47;
  _BYTE v48[20];
  GLuint framebuffers;

  v8 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E0);
  if ((v8 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E0))
  {
    v44 = operator new();
    *(_QWORD *)v44 = 850045863;
    *(_OWORD *)(v44 + 8) = 0u;
    *(_OWORD *)(v44 + 24) = 0u;
    *(_OWORD *)(v44 + 40) = 0u;
    *(_QWORD *)(v44 + 56) = 0;
    qword_1ED4DA9D8 = v44;
    __cxa_guard_release(&qword_1ED4DA9E0);
  }
  std::mutex::lock((std::mutex *)qword_1ED4DA9D8);
  framebuffers = *((_DWORD *)this + 298);
  v9 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
  if ((v9 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
  {
    qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
    qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
    qword_1ED4DAA00 = 0;
    __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
    __cxa_guard_release(&qword_1ED4DA9E8);
  }
  v10 = (uint64_t *)qword_1ED4DA9F8;
  v11 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
  if ((v11 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
  {
    qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
    qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
    qword_1ED4DAA00 = 0;
    __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
    __cxa_guard_release(&qword_1ED4DA9E8);
  }
  if (v10 == &qword_1ED4DA9F0)
  {
LABEL_7:
    v10 = &qword_1ED4DA9F0;
  }
  else
  {
    while (*((_DWORD *)v10 + 7) != framebuffers)
    {
      v10 = (uint64_t *)v10[1];
      if (v10 == &qword_1ED4DA9F0)
        goto LABEL_7;
    }
  }
  v12 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
  if ((v12 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
  {
    qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
    qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
    qword_1ED4DAA00 = 0;
    __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
    __cxa_guard_release(&qword_1ED4DA9E8);
  }
  if (v10 != &qword_1ED4DA9F0
    && *((_DWORD *)v10 + 4) == (_DWORD)a2
    && *((_DWORD *)v10 + 5) == (_DWORD)a3
    && *((_DWORD *)v10 + 6) == (_DWORD)a4)
  {
    v13 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
    if ((v13 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
    {
      qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DAA00 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4DA9E8);
    }
    v14 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
    if ((v14 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
    {
      qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DAA00 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4DA9E8);
    }
    v15 = (uint64_t *)qword_1ED4DA9F8;
    v16 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
    if ((v16 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
    {
      qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DAA00 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4DA9E8);
    }
    if (v15 != v10)
    {
      v17 = (uint64_t *)v10[1];
      if (v17 != v15)
      {
        v18 = *v10;
        *(_QWORD *)(v18 + 8) = v17;
        *(_QWORD *)v10[1] = v18;
        v19 = *v15;
        *(_QWORD *)(v19 + 8) = v10;
        *v10 = v19;
        *v15 = (uint64_t)v10;
        v10[1] = (uint64_t)v15;
      }
    }
  }
  else
  {
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v48, "framebuffer", 2, "BindCachedFramebuffer()");
    v22 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
    if ((v22 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
    {
      qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DAA00 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4DA9E8);
    }
    if (v10 != &qword_1ED4DA9F0)
    {
      v23 = atomic_load(HGLogger::_enabled);
      if ((v23 & 1) != 0)
        HGLogger::log((HGLogger *)"framebuffer", (const char *)2, (HGLogger *)"done with framebuffer (%d) - marking unused\n", v20, v21, framebuffers);
      *((_BYTE *)v10 + 32) = 0;
    }
    v24 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
    if ((v24 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
    {
      qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DAA00 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4DA9E8);
    }
    v25 = (uint64_t *)qword_1ED4DA9F8;
    v26 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
    if ((v26 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
    {
      qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DAA00 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4DA9E8);
    }
    while (v25 != &qword_1ED4DA9F0)
    {
      if (*((_DWORD *)v25 + 4) == (_DWORD)a2
        && *((_DWORD *)v25 + 5) == (_DWORD)a3
        && *((_DWORD *)v25 + 6) == (_DWORD)a4
        && !*((_BYTE *)v25 + 32))
      {
        goto LABEL_36;
      }
      v25 = (uint64_t *)v25[1];
    }
    v25 = &qword_1ED4DA9F0;
LABEL_36:
    v27 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
    if ((v27 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
    {
      qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DAA00 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4DA9E8);
    }
    if (v25 == &qword_1ED4DA9F0)
    {
      glGenFramebuffers(1, &framebuffers);
      v36 = framebuffers;
      v37 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
      if ((v37 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
      {
        qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
        qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
        qword_1ED4DAA00 = 0;
        __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
        __cxa_guard_release(&qword_1ED4DA9E8);
      }
      v38 = (char *)operator new(0x28uLL);
      *((_DWORD *)v38 + 6) = a4;
      *((_DWORD *)v38 + 7) = v36;
      v38[32] = 1;
      *(_WORD *)(v38 + 33) = v46;
      v38[35] = v47;
      v41 = qword_1ED4DA9F8;
      *(_QWORD *)v38 = &qword_1ED4DA9F0;
      *((_QWORD *)v38 + 1) = v41;
      *((_QWORD *)v38 + 2) = a2 | (unint64_t)(a3 << 32);
      *(_QWORD *)v41 = v38;
      qword_1ED4DA9F8 = (uint64_t)v38;
      ++qword_1ED4DAA00;
      LOBYTE(v41) = atomic_load(HGLogger::_enabled);
      if ((v41 & 1) != 0)
        HGLogger::log((HGLogger *)"framebuffer", (const char *)2, (HGLogger *)"allocating new framebuffer (%d) [%d, %d, %d]\n", v39, v40, framebuffers, a2, a3, a4);
    }
    else
    {
      v28 = atomic_load(HGLogger::_enabled);
      if ((v28 & 1) != 0)
        HGLogger::log((HGLogger *)"framebuffer", (const char *)2, (HGLogger *)"found unused framebuffer (%d) [%d, %d, %d]\n", v20, v21, *((unsigned int *)v25 + 7), a2, a3, a4);
      *((_BYTE *)v25 + 32) = 1;
      framebuffers = *((_DWORD *)v25 + 7);
      v29 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
      if ((v29 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
      {
        qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
        qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
        qword_1ED4DAA00 = 0;
        __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
        __cxa_guard_release(&qword_1ED4DA9E8);
      }
      v30 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
      if ((v30 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
      {
        qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
        qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
        qword_1ED4DAA00 = 0;
        __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
        __cxa_guard_release(&qword_1ED4DA9E8);
      }
      v31 = (uint64_t *)qword_1ED4DA9F8;
      v32 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
      if ((v32 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
      {
        qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
        qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
        qword_1ED4DAA00 = 0;
        __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
        __cxa_guard_release(&qword_1ED4DA9E8);
      }
      if (v31 != v25)
      {
        v33 = (uint64_t *)v25[1];
        if (v33 != v31)
        {
          v34 = *v25;
          *(_QWORD *)(v34 + 8) = v33;
          *(_QWORD *)v25[1] = v34;
          v35 = *v31;
          *(_QWORD *)(v35 + 8) = v25;
          *v25 = v35;
          *v31 = (uint64_t)v25;
          v25[1] = (uint64_t)v31;
        }
      }
    }
    glBindFramebuffer(0x8D40u, framebuffers);
    *((_DWORD *)this + 298) = framebuffers;
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v48);
  }
  v42 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E0);
  if ((v42 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E0))
  {
    v45 = operator new();
    *(_QWORD *)v45 = 850045863;
    *(_OWORD *)(v45 + 8) = 0u;
    *(_OWORD *)(v45 + 24) = 0u;
    *(_OWORD *)(v45 + 40) = 0u;
    *(_QWORD *)(v45 + 56) = 0;
    qword_1ED4DA9D8 = v45;
    __cxa_guard_release(&qword_1ED4DA9E0);
  }
  std::mutex::unlock((std::mutex *)qword_1ED4DA9D8);
  FBOStrategy::cleanupCache(v43);
}

void sub_1B2A49398(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1ED4DA9E0);
  _Unwind_Resume(a1);
}

void sub_1B2A493B0(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1ED4DA9E0);
  _Unwind_Resume(a1);
}

void sub_1B2A493C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A493DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A493F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

BOOL HGGPURenderer::Clear(HGGPURenderer *this, HGRect a2, HGRect a3)
{
  uint64_t v3;
  signed int var0;
  uint64_t v5;
  signed int v6;
  signed int var1;
  signed int v9;
  _BOOL8 v10;
  uint64_t v11;
  const char *v12;
  const char *v13;
  char *v14;
  uint64_t v15;
  const char *v16;
  const char *v17;
  char *v18;
  uint64_t v19;
  const char *v20;
  const char *v21;
  char *v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  char *v26;
  _BYTE v28[16];
  HGRect v29;
  HGRect v30;
  HGRect v31;
  HGRect v32;

  v3 = *(_QWORD *)&a3.var2;
  var0 = a3.var0;
  v5 = *(_QWORD *)&a2.var2;
  v6 = a2.var0;
  var1 = a2.var1;
  v9 = a3.var1;
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v28, "gpu", 2, "clear texture borders to zero");
  v10 = var1 > v9;
  if (var1 > v9)
  {
    v11 = HGRectMake4i(var0, v9, v3, var1);
    v13 = v12;
    *(_QWORD *)&v29.var0 = v11;
    *(_QWORD *)&v29.var2 = v13;
    HGGPURenderer::Clear(this, v29, v13, v14);
  }
  if (SHIDWORD(v5) < SHIDWORD(v3))
  {
    v15 = HGRectMake4i(var0, HIDWORD(v5), v3, HIDWORD(v3));
    v17 = v16;
    *(_QWORD *)&v30.var0 = v15;
    *(_QWORD *)&v30.var2 = v17;
    HGGPURenderer::Clear(this, v30, v17, v18);
    v10 = 1;
  }
  if (v6 > var0)
  {
    v19 = HGRectMake4i(var0, var1, v6, HIDWORD(v5));
    v21 = v20;
    *(_QWORD *)&v31.var0 = v19;
    *(_QWORD *)&v31.var2 = v21;
    HGGPURenderer::Clear(this, v31, v21, v22);
    v10 = 1;
  }
  if ((int)v5 < (int)v3)
  {
    v23 = HGRectMake4i(v5, var1, v3, HIDWORD(v5));
    v25 = v24;
    *(_QWORD *)&v32.var0 = v23;
    *(_QWORD *)&v32.var2 = v25;
    HGGPURenderer::Clear(this, v32, v25, v26);
    v10 = 1;
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v28);
  return v10;
}

void sub_1B2A49564(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

void HGGPURenderer::BindMultiSampleBuffer(HGGPURenderer *this, signed int a2, int a3, const char *a4, char *a5)
{
  signed int v6;
  unsigned __int8 v8;
  uint64_t v9;
  GLuint v10;
  GLuint Renderbuffer;
  GLuint v12;

  v6 = a2;
  if (a2 == 1 && (a3 & 1) == 0)
  {
    v8 = atomic_load(HGLogger::_enabled);
    if ((v8 & 1) != 0)
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"really?\n", a4, a5);
  }
  v9 = *((_QWORD *)this + 3);
  if (v9 && *(_DWORD *)(v9 + 16))
  {
    v10 = *((_DWORD *)this + 297);
    if (!v10)
    {
      glGenFramebuffers(1, (GLuint *)this + 297);
      v10 = *((_DWORD *)this + 297);
    }
    glBindFramebuffer(0x8D40u, v10);
    if (*((_DWORD *)this + 356) < v6)
      v6 = *((_DWORD *)this + 356);
    Renderbuffer = HGTextureManager::createRenderbuffer(*((HGTextureManager **)this + 184), v6, 32856);
    *((_DWORD *)this + 299) = Renderbuffer;
    glBindRenderbuffer(0x8D41u, Renderbuffer);
    glRenderbufferStorageMultisampleAPPLE();
    glFramebufferRenderbuffer(0x8D40u, 0x8CE0u, 0x8D41u, *((_DWORD *)this + 299));
    if (a3)
    {
      v12 = HGTextureManager::createRenderbuffer(*((HGTextureManager **)this + 184), v6, 33190);
      *((_DWORD *)this + 300) = v12;
      glBindRenderbuffer(0x8D41u, v12);
      glRenderbufferStorageMultisampleAPPLE();
      glFramebufferRenderbuffer(0x8D40u, 0x8D00u, 0x8D41u, *((_DWORD *)this + 300));
    }
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearDepthf(1.0);
    glDepthMask(1u);
    glClear(0x4100u);
    glEnable(0xB71u);
    glDepthFunc(0x201u);
  }
}

void HGGPURenderer::ResolveMultiSampleBuffer(HGGPURenderer *this)
{
  GLuint v2;
  uint64_t v3;
  uint64_t v4;

  glDepthMask(0);
  glDisable(0xB71u);
  glFlush();
  glBindFramebuffer(0x8CA9u, *((_DWORD *)this + 298));
  v2 = *((_DWORD *)this + 297);
  if (!v2)
  {
    glGenFramebuffers(1, (GLuint *)this + 297);
    v2 = *((_DWORD *)this + 297);
  }
  glBindFramebuffer(0x8CA8u, v2);
  glResolveMultisampleFramebufferAPPLE();
  glDiscardFramebufferEXT();
  glFramebufferRenderbuffer(0x8D40u, 0x8CE0u, 0x8D41u, 0);
  glFramebufferRenderbuffer(0x8D40u, 0x8D00u, 0x8D41u, 0);
  glBindRenderbuffer(0x8D41u, 0);
  glBindFramebuffer(0x8CA9u, 0);
  glBindFramebuffer(0x8CA8u, 0);
  v3 = *((unsigned int *)this + 299);
  if ((_DWORD)v3)
  {
    HGTextureManager::deleteRenderbuffer(*((HGTextureManager **)this + 184), v3);
    *((_DWORD *)this + 299) = 0;
  }
  v4 = *((unsigned int *)this + 300);
  if ((_DWORD)v4)
  {
    HGTextureManager::deleteRenderbuffer(*((HGTextureManager **)this + 184), v4);
    *((_DWORD *)this + 300) = 0;
  }
  glBindFramebuffer(0x8D40u, *((_DWORD *)this + 298));
  glFramebufferTexture2D(0x8D40u, 0x8CE0u, *(_DWORD *)(*((_QWORD *)this + 3) + 152), *(_DWORD *)(*((_QWORD *)this + 3) + 156), 0);
}

_QWORD *HGGPURenderer::SetLastMetalCmdBuffer(uint64_t a1, void *a2)
{
  id *v4;
  _QWORD *v5;
  _QWORD *result;

  v4 = *(id **)(a1 + 1320);
  if (v4)
  {
    HGMetalCommandBufferRef::~HGMetalCommandBufferRef(v4);
    MEMORY[0x1B5E29170]();
  }
  *(_QWORD *)(a1 + 1320) = 0;
  v5 = (_QWORD *)operator new();
  result = HGMetalCommandBufferRef::HGMetalCommandBufferRef(v5, a2);
  *(_QWORD *)(a1 + 1320) = v5;
  return result;
}

void sub_1B2A498FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x20C4093837F09);
  _Unwind_Resume(a1);
}

void HGGPURenderer::GetContext(uint64_t a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  HGGLContext *v3;

  v3 = *(HGGLContext **)(a1 + 8 * s_HGFormatInfos[8 * a2 + 4] + 1144);
  if (v3)
    HGGLContext::context(a3, v3);
  else
    HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)a3, 0);
}

const char *HGGPURenderer::ValidateCurrentContext(const char *this)
{
  BOOL v1;
  uint64_t v2;
  uint64_t CGColorSpace;
  const char *v4;
  char *v5;
  PCSharedCount v6;

  if (this[1281])
    v1 = HG_RENDERER_ENV::VALIDATE_CURRENT_GL_CONTEXT == 1;
  else
    v1 = 0;
  if (v1)
  {
    v2 = (uint64_t)this;
    HGGLGetCurrentContext();
    CGColorSpace = PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v6);
    PCSharedCount::PCSharedCount(&v6);
    this = (const char *)HGGLContext::ptr(*(HGGLContext **)(v2 + 1144));
    if ((const char *)CGColorSpace != this)
    {
      this = (const char *)HGGLContext::ptr(*(HGGLContext **)(v2 + 1152));
      if ((const char *)CGColorSpace != this)
        return HGLogger::warning((HGLogger *)"ValidateCurrentContext() : Invalid OpenGL context.", v4, v5);
    }
  }
  return this;
}

void sub_1B2A499D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::GetGLState(HGGPURenderer *this)
{
  return *((_QWORD *)this + 146);
}

uint64_t HGGPURenderer::GetProjectionMatrix(HGGPURenderer *this)
{
  return *((_QWORD *)this + 151);
}

uint64_t HGGPURenderer::BindTexture(uint64_t a1, const char *a2, char *a3, uint64_t a4, int a5)
{
  uint64_t v7;
  uint64_t v10;
  HGGLContext *v11;
  HGGLContext *v12;
  uint64_t CGColorSpace;
  const char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  HGTextureManager *v26;
  char isES2;
  const char *v28;
  char *v29;
  const char *v30;
  char *v31;
  unsigned __int8 v32;
  const char *v33;
  int v34;
  GLenum v35;
  const char *v36;
  char *v37;
  unsigned __int8 v38;
  const char *v39;
  char *v40;
  int v41;
  char *v42;
  char *v43;
  uint64_t v44;
  int64_t v45;
  GLint v46;
  GLenum v47;
  unsigned int v48;
  int v49;
  uint64_t v50;
  PCSharedCount v51;

  if (a2 > 7)
    return 0xFFFFFFFFLL;
  v7 = (uint64_t)a3;
  v10 = *(_QWORD *)(a1 + 1168);
  if (v10)
  {
    v11 = *(HGGLContext **)(a1 + 8 * *(unsigned int *)(a1 + 1160) + 1144);
    if (v11)
      HGGLContext::context((uint64_t *)&v51, v11);
    else
      HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v51, 0);
    HGGLState::setCurrentContext(v10, &v51.var0);
    PCSharedCount::PCSharedCount(&v51);
  }
  if (!*(_BYTE *)(a1 + 1281))
    goto LABEL_21;
  v12 = *(HGGLContext **)(a1 + 8 * *(unsigned int *)(a1 + 1160) + 1144);
  if (v12)
    HGGLContext::context((uint64_t *)&v51, v12);
  else
    HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v51, 0);
  CGColorSpace = PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v51);
  PCSharedCount::PCSharedCount(&v51);
  if (!CGColorSpace)
  {
LABEL_21:
    if (!v7)
      return 0;
    HGLogger::warning((HGLogger *)"BindTexture() : non-null buffer but OpenGL is disallowed", a2, a3);
    return 0xFFFFFFFFLL;
  }
  v16 = a1 + 24 * a2;
  v19 = *(_QWORD *)(v16 + 32);
  v18 = (uint64_t *)(v16 + 32);
  v17 = v19;
  v20 = v18[1];
  if (v7 || (a4 = 0, v17))
  {
    HGTextureManager::activeTexture(*(HGTextureManager **)(a1 + 1472), (_DWORD)a2 + 33984, (uint64_t)a3, v14, v15);
    v21 = a2;
    if (v17 == v7)
      goto LABEL_27;
    *v18 = 0;
    if (!v7)
    {
      HGTextureManager::bindTexture(*(HGTextureManager **)(a1 + 1472), *(_DWORD *)(v17 + 160), 0);
      v24 = 0;
      goto LABEL_45;
    }
    v49 = *(_DWORD *)(v7 + 12) & 0x30;
    v50 = a4;
    if (v49
      || (v7 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a1 + 352))(a1, *(_QWORD *)(v7 + 20), *(_QWORD *)(v7 + 28), v7)) != 0)
    {
      v22 = *(_QWORD *)(v7 + 128);
      if (!v22 || v22 == a1)
      {
        *v18 = v7;
        HGTextureManager::bindTexture(*(HGTextureManager **)(a1 + 1472), *(_DWORD *)(v7 + 160), *(unsigned int *)(v7 + 168));
        v26 = *(HGTextureManager **)(a1 + 1472);
        isES2 = HGGLContext::isES2(*(HGGLContext **)(a1 + 8 * *(unsigned int *)(a1 + 1160) + 1144));
        HGTextureManager::sizeHint(v26, (HGGLTexture *)v7, isES2, v28, v29);
        v32 = atomic_load(HGLogger::_enabled);
        if ((v32 & 1) != 0)
        {
          v33 = "RECT";
          if (*(_DWORD *)(v7 + 160) == 3553)
            v33 = "2D";
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"Binding %s texture ID %d to unit %d\n", v30, v31, v33, *(_QWORD *)(v7 + 168), a2);
        }
        *(_DWORD *)(v7 + 184) |= 1 << *(_DWORD *)(a1 + 1160);
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
        v34 = *(_DWORD *)(v7 + 188);
        *(_DWORD *)(v7 + 188) = v34 + 1;
        if (!v34)
        {
          HGGLTexture::AttachRenderer((HGGLTexture *)v7, (HGGPURenderer *)a1);
          HGGPURenderer::AddTextureUsage((HGGPURenderer *)a1, (HGBitmap *)v7);
        }
        v35 = *(_DWORD *)(v7 + 160);
        if (*(_DWORD *)HGBitmap::GetEdgePolicy((HGBitmap *)v7) == 1)
        {
          v38 = atomic_load(HGLogger::_enabled);
          if ((v38 & 1) != 0)
            HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"texture mode : GL_CLAMP_TO_EDGE\n", v36, v37);
        }
        glTexParameteri(v35, 0x2802u, 33071);
        glTexParameteri(v35, 0x2803u, 33071);
        v23 = 0;
        v24 = 0;
LABEL_41:
        if (!v49 && (v23 & 1) == 0)
          (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
        a4 = v50;
        if (!v17)
          goto LABEL_55;
LABEL_45:
        v41 = *(_DWORD *)(v17 + 188) - 1;
        *(_DWORD *)(v17 + 188) = v41;
        if (!v41)
        {
          v42 = *(char **)(a1 + 1216);
          v43 = *(char **)(a1 + 1224);
          v48 = v21;
          if (v42 != v43)
          {
            while (*(_QWORD *)v42 != v17)
            {
              v42 += 8;
              if (v42 == v43)
              {
                v42 = *(char **)(a1 + 1224);
                break;
              }
            }
          }
          v44 = a4;
          v45 = v43 - (v42 + 8);
          if (v43 != v42 + 8)
            memmove(v42, v42 + 8, v43 - (v42 + 8));
          *(_QWORD *)(a1 + 1224) = &v42[v45];
          *(_DWORD *)(a1 + 1240) = -1;
          a4 = v44;
          v21 = v48;
          if ((*(_BYTE *)(v17 + 12) & 0x30) != 0)
            HGGLTexture::DetachRenderer((HGGLTexture *)v17);
        }
        (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
        goto LABEL_55;
      }
      v23 = 0;
    }
    else
    {
      v23 = 1;
    }
    HGTextureManager::bindTexture(*(HGTextureManager **)(a1 + 1472), 0xDE1u, 0);
    HGLogger::warning((HGLogger *)"BindTexture() : buffer is tied to another renderer", v39, v40);
    v24 = 0xFFFFFFFFLL;
    goto LABEL_41;
  }
  v21 = a2;
LABEL_27:
  v24 = 0;
LABEL_55:
  if (*v18)
  {
    if (a5)
      v46 = 9729;
    else
      v46 = 9728;
    v47 = *(_DWORD *)(*v18 + 160);
    glTexParameteri(v47, 0x2801u, v46);
    glTexParameteri(v47, 0x2800u, v46);
  }
  v18[1] = a4;
  *(_DWORD *)(a1 + 24 * v21 + 48) = a5;
  if (v20)
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 24))(v20);
  return v24;
}

void sub_1B2A49E48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, PCSharedCount a16)
{
  PCSharedCount::PCSharedCount(&a16);
  _Unwind_Resume(a1);
}

void sub_1B2A49E5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, PCSharedCount a16)
{
  PCSharedCount::PCSharedCount(&a16);
  _Unwind_Resume(a1);
}

PCICCTransferFunctionLUT *HGGPURenderer::MarkBufferedOutput(PCICCTransferFunctionLUT **this, HGNode *a2)
{
  int NodeRenderAPI;
  int v5;
  _BOOL4 v6;
  _BOOL4 v7;
  unsigned int v8;
  unsigned int v9;
  PCICCTransferFunctionLUT *result;
  int v11;
  unsigned int v12;
  BOOL v13;
  char v14;
  char v15;
  int v16;
  _BOOL4 v17;
  unsigned int v18;
  BOOL v21;
  unsigned int v22;
  BOOL v23;
  char v24;
  unsigned int v25;
  uint64_t v26;

  NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI((HGGPURenderer *)this, a2);
  v5 = *((_DWORD *)a2 + 4) & 0x1000;
  v6 = NodeRenderAPI == 1;
  if (NodeRenderAPI != 1 && v5)
    v6 = *((_BYTE *)a2 + 108) != 0;
  v7 = NodeRenderAPI == 0;
  if (NodeRenderAPI && v5)
    v7 = *((_BYTE *)a2 + 107) != 0;
  v8 = *((_DWORD *)a2 + 44) - *((_DWORD *)a2 + 42);
  v9 = *((_DWORD *)a2 + 45) - *((_DWORD *)a2 + 43);
  result = (PCICCTransferFunctionLUT *)HGRenderer::GetOutputFormat((HGRenderer *)this, a2);
  v11 = (int)result;
  if (*((_DWORD *)a2 + 54) != -1 && *((_DWORD *)this + 153) != 1)
    goto LABEL_44;
  if (*((_BYTE *)this + 1281))
  {
    if (v6)
    {
      result = (PCICCTransferFunctionLUT *)PCICCTransferFunctionLUT::getLUTEnd(this[139]);
      v12 = *((_DWORD *)result + 12);
      v13 = v12 >= v8 && v12 >= v9;
      v14 = !v13;
      v15 = v14 ^ 1;
      if (!v13 || !v7)
      {
        v16 = *((_DWORD *)a2 + 4);
        if (*((int *)a2 + 52) >= 2)
          goto LABEL_21;
LABEL_47:
        v17 = 0;
        if (*((_DWORD *)this + 153) == 2)
          goto LABEL_48;
        goto LABEL_50;
      }
    }
    else if (!v7)
    {
      v15 = 1;
      v16 = *((_DWORD *)a2 + 4);
      if (*((int *)a2 + 52) < 2)
        goto LABEL_47;
      goto LABEL_21;
    }
    result = this[184];
    if (result)
    {
      result = (PCICCTransferFunctionLUT *)HGTextureManager::maxTextureSizeGL((uint64_t)result, v11);
      v15 = result >= v8 && result >= v9;
      v16 = *((_DWORD *)a2 + 4);
      if (*((int *)a2 + 52) < 2)
        goto LABEL_47;
      goto LABEL_21;
    }
LABEL_44:
    v15 = 0;
    v16 = *((_DWORD *)a2 + 4);
    if (*((int *)a2 + 52) < 2)
      goto LABEL_47;
    goto LABEL_21;
  }
  result = (PCICCTransferFunctionLUT *)PCICCTransferFunctionLUT::getLUTEnd(this[139]);
  v18 = *((_DWORD *)result + 12);
  v15 = v18 >= v8 && v18 >= v9;
  v16 = *((_DWORD *)a2 + 4);
  if (*((int *)a2 + 52) < 2)
    goto LABEL_47;
LABEL_21:
  if ((v16 & 0x100) != 0)
  {
    v17 = 1;
    if (*((_DWORD *)this + 153) == 2)
      goto LABEL_48;
  }
  else
  {
    v17 = *((_DWORD *)this + 153) == 3;
    if (*((_DWORD *)this + 153) == 2)
      goto LABEL_48;
  }
LABEL_50:
  v21 = 0;
  if ((v16 & 6) != 0)
    v17 = 1;
  if ((v16 & 8) == 0 && v17)
  {
    if (!*((_BYTE *)this + 1281))
    {
      result = (PCICCTransferFunctionLUT *)PCICCTransferFunctionLUT::getLUTEnd(this[139]);
      v21 = 0;
      v25 = *((_DWORD *)result + 12);
      if (v25 < v8 || v25 < v9)
        goto LABEL_49;
      goto LABEL_74;
    }
    if (v6)
    {
      result = (PCICCTransferFunctionLUT *)PCICCTransferFunctionLUT::getLUTEnd(this[139]);
      v22 = *((_DWORD *)result + 12);
      v23 = v22 >= v8 && v22 >= v9;
      v24 = !v23;
      if (!v23 || !v7)
      {
        if ((v24 & 1) == 0)
          goto LABEL_74;
LABEL_48:
        v21 = 0;
        goto LABEL_49;
      }
    }
    else if (!v7)
    {
LABEL_74:
      if (v11 <= 41)
        v26 = s_HGFormatInfos[8 * v11 + 3];
      else
        v26 = 0;
      v21 = v9 * (unint64_t)v8 * v26 < (unint64_t)this[157];
      goto LABEL_49;
    }
    result = this[184];
    if (result)
    {
      result = (PCICCTransferFunctionLUT *)HGTextureManager::maxTextureSizeGL((uint64_t)result, v11);
      v21 = 0;
      if (result < v8 || result < v9)
        goto LABEL_49;
      goto LABEL_74;
    }
    goto LABEL_48;
  }
LABEL_49:
  *((_BYTE *)a2 + 104) = v15 | v21;
  return result;
}

BOOL HGGPURenderer::RenderBufferedOutput(HGGPURenderer *this, HGNode *a2)
{
  int v2;
  _BOOL8 v5;
  uint64_t OutputFormat;
  HGBitmap *v7;
  HGBitmap *v8;
  uint64_t v9;
  uint64_t v10;
  HGBitmap *v11;
  HGBitmap *v12;
  int v13;
  uint64_t v14;
  void *v15;

  v2 = *((unsigned __int8 *)a2 + 104);
  if (*((_BYTE *)a2 + 104))
  {
    (*(void (**)(HGNode *, HGGPURenderer *))(*(_QWORD *)a2 + 416))(a2, this);
    (*(void (**)(HGNode *, HGGPURenderer *, uint64_t))(*(_QWORD *)a2 + 336))(a2, this, 1);
    v5 = (*((_DWORD *)a2 + 4) & 0x2000) == 0;
    OutputFormat = HGRenderer::GetOutputFormat(this, a2);
    v7 = (HGBitmap *)(*(uint64_t (**)(HGGPURenderer *, HGNode *, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD, _BOOL8))(*(_QWORD *)this + 168))(this, a2, *((_QWORD *)a2 + 21), *((_QWORD *)a2 + 22), OutputFormat, 0, 0, v5);
    v8 = v7;
    if (*((_BYTE *)a2 + 107))
    {
      if (!*((_BYTE *)a2 + 108))
      {
        v9 = *((_QWORD *)a2 + 21);
        v10 = *((_QWORD *)a2 + 22);
        v11 = HGGPURenderer::ConvertToNonMetalTexture(this, v7);
        v12 = v11;
        v13 = *((_DWORD *)v11 + 3);
        if ((v13 & 0x30) != 0)
        {
          if ((v13 & 0x10) != 0)
          {
            if ((v13 & 0x100) != 0)
            {
              (*(void (**)(HGGPURenderer *, HGBitmap *))(*(_QWORD *)this + 144))(this, v11);
              v14 = (*(uint64_t (**)(HGGPURenderer *))(*(_QWORD *)this + 328))(this);
              goto LABEL_16;
            }
            if ((v13 & 0x200) != 0)
            {
              v14 = (uint64_t)v15;
              if (v15)
                (*(void (**)(void *))(*(_QWORD *)v15 + 16))(v15);
              goto LABEL_16;
            }
          }
          v14 = 0;
        }
        else
        {
          v14 = (*(uint64_t (**)(HGGPURenderer *, uint64_t, uint64_t, HGBitmap *))(*(_QWORD *)this + 352))(this, v9, v10, v11);
        }
LABEL_16:
        (*(void (**)(HGBitmap *))(*(_QWORD *)v12 + 24))(v12);
        *((_QWORD *)a2 + 24) = v14;
        goto LABEL_17;
      }
    }
    else if (*((_BYTE *)a2 + 108))
    {
      *((_QWORD *)a2 + 24) = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)this, *(HGRect *)((char *)a2 + 168), v7, 1);
LABEL_17:
      (*(void (**)(HGBitmap *))(*(_QWORD *)v8 + 24))(v8);
      goto LABEL_18;
    }
    *((_QWORD *)a2 + 24) = v7;
LABEL_18:
    (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
  }
  return v2 != 0;
}

uint64_t HGGPURenderer::RenderTilesBegin(uint64_t result, uint64_t a2)
{
  int v2;
  unsigned int *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  _BOOL4 v11;
  _BOOL4 IsNull;
  uint64_t v13;

  v2 = *(_DWORD *)(a2 + 212);
  *(_DWORD *)(a2 + 212) = v2 + 1;
  if (!v2)
  {
    v4 = (unsigned int *)result;
    *(_DWORD *)(a2 + 16) = (*(_DWORD *)(a2 + 16) >> 17) & 2 | *(_DWORD *)(a2 + 16) & 0xFFFFFFEF;
    v5 = *(_DWORD *)(a2 + 88);
    if (v5 < 1)
    {
LABEL_15:
      (*(void (**)(unsigned int *, uint64_t, uint64_t))(*(_QWORD *)v4 + 320))(v4, a2, 1);
      IsNull = HGRectIsNull(*(_QWORD *)(a2 + 168), *(_QWORD *)(a2 + 176));
      v13 = *(_QWORD *)v4;
      if (IsNull)
        return (*(uint64_t (**)(unsigned int *, uint64_t))(v13 + 232))(v4, a2);
      (*(void (**)(unsigned int *, uint64_t))(v13 + 192))(v4, a2);
      (*(void (**)(unsigned int *, uint64_t))(*(_QWORD *)v4 + 208))(v4, a2);
      result = (*(uint64_t (**)(unsigned int *, uint64_t))(*(_QWORD *)v4 + 232))(v4, a2);
      if (*(_DWORD *)(a2 + 40) != 1)
        return (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(*(_QWORD *)a2 + 336))(a2, v4, 1);
      return result;
    }
    v6 = 0;
    while (1)
    {
      v7 = *(_QWORD *)(*(_QWORD *)(a2 + 80) + 8 * v6);
      if (!v7)
        goto LABEL_6;
      v8 = *(_QWORD *)(v7 + 16);
      if (!v8)
        goto LABEL_6;
      v9 = *(_DWORD *)(v7 + 12);
      v10 = v9 & 0x2006;
      if ((v9 & 0x2006) != 0)
      {
        v11 = HGRectIsNull(*(_QWORD *)(v7 + 32), *(_QWORD *)(v7 + 40));
        v8 = *(_QWORD *)(v7 + 16);
        if (!v11)
          break;
      }
      if ((*(_BYTE *)(a2 + 18) & 4) != 0)
        goto LABEL_12;
LABEL_5:
      (*(void (**)(unsigned int *, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v4 + 240))(v4, *(_QWORD *)(v8 + 144), *(_QWORD *)(v7 + 32), *(_QWORD *)(v7 + 40), v4[144]);
      v5 = *(_DWORD *)(a2 + 88);
LABEL_6:
      if (++v6 >= v5)
        goto LABEL_15;
    }
    (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v8 + 144) + 136))(*(_QWORD *)(v8 + 144), 0xFFFFFFFFLL, v10);
    v8 = *(_QWORD *)(v7 + 16);
    if ((*(_BYTE *)(a2 + 18) & 4) == 0)
      goto LABEL_5;
LABEL_12:
    (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v8 + 144) + 136))(*(_QWORD *)(v8 + 144), 0xFFFFFFFFLL, 2);
    v8 = *(_QWORD *)(v7 + 16);
    goto LABEL_5;
  }
  return result;
}

uint64_t HGGPURenderer::PostGetOutput(HGGPURenderer *this, HGNode *a2)
{
  uint64_t result;
  int v5;
  uint64_t i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  result = HGGPURenderer::GetNodeRenderAPI(this, a2);
  if (*((int *)a2 + 22) >= 1)
  {
    v5 = result;
    for (i = 0; i < *((int *)a2 + 22); ++i)
    {
      v7 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * i);
      if (!v7)
        continue;
      v8 = *(_QWORD *)(v7 + 16);
      if (!v8)
        continue;
      v9 = *(_QWORD *)(v8 + 144);
      if (v5 == 1)
      {
        *(_BYTE *)(v9 + 108) = 1;
        result = HGGPURenderer::GetNodeRenderAPI(this, (HGNode *)v9);
        if ((_DWORD)result == 1)
          goto LABEL_13;
      }
      else
      {
        if (!v5)
          *(_BYTE *)(v9 + 107) = 1;
        result = HGGPURenderer::GetNodeRenderAPI(this, (HGNode *)v9);
        if ((_DWORD)result == v5)
        {
LABEL_13:
          if ((*(_BYTE *)(v7 + 13) & 0x10) == 0)
            continue;
        }
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 136))(v9, 0xFFFFFFFFLL, 4096);
    }
  }
  return result;
}

char *HGGPURenderer::RenderTiles(uint64_t a1, const char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7, unsigned __int8 a8)
{
  HGGLContext *v16;
  HGBitmap *v17;
  _QWORD *MetalStorage;
  uint64_t v19;
  uint64_t LUTEnd;
  const char *v21;
  char *v22;
  char v23;
  uint64_t v24;
  char *v25;
  id v27;

  if ((_DWORD)a5)
  {
    HGAutoReleasePoolScopeGuard::HGAutoReleasePoolScopeGuard((HGAutoReleasePoolScopeGuard *)&v27);
    v16 = *(HGGLContext **)(a1 + 1144);
    if (v16 && HGGLContext::ptr(v16))
    {
      HGGLContext::getVirtualScreen(*(HGGLContext **)(a1 + 1144));
      HGGLContext::setVirtualScreen(*(HGGLContext **)(a1 + 1152));
    }
    if (a6)
    {
      if ((*(_BYTE *)(a6 + 12) & 0x30) != 0)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)a6 + 16))(a6);
        if ((~*(_DWORD *)(a6 + 12) & 0x220) == 0)
        {
          MetalStorage = HGMetalTexture::getMetalStorage((HGBitmap *)a6, v17);
          if (MetalStorage)
          {
            v19 = *(_QWORD *)(HGMetalDeviceInfo::getDeviceInfo(MetalStorage[17]) + 24);
            LUTEnd = PCICCTransferFunctionLUT::getLUTEnd(*(PCICCTransferFunctionLUT **)(a1 + 1112));
            if (v19 != *(_QWORD *)(LUTEnd + 24))
            {
              HGLogger::error((HGLogger *)"Device mismatch between renderer (0x%llx) and target texture (0x%llx).", v21, v22, *(_QWORD *)(LUTEnd + 24), v19);
              v25 = 0;
LABEL_16:
              HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard(&v27);
              return v25;
            }
          }
        }
        v23 = 0;
        v24 = 0;
      }
      else
      {
        v23 = 1;
        v24 = a6;
        a6 = 0;
      }
    }
    else
    {
      v24 = 0;
      v23 = 1;
    }
    v25 = HGGPURenderer::ProcessNode(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, v24, (char *)a6, 0, a7, a8);
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
    if ((v23 & 1) == 0)
      (*(void (**)(uint64_t))(*(_QWORD *)a6 + 24))(a6);
    goto LABEL_16;
  }
  HGLogger::error((HGLogger *)"RenderTiles() : format == kHGFormat_Null.\n", a2, a3);
  return 0;
}

void sub_1B2A4A74C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A4A760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A4A774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A4A788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A4A79C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A4A7B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A4A7C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A4A7D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

char *HGGPURenderer::ProcessNode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7, int a8, unsigned __int8 a9, unsigned __int8 a10)
{
  HGMetalDeviceInfo *LUTEnd;
  HGBitmap *v18;
  HGBitmap *v19;
  HGBuffer *v20;
  char *v21;
  HGBuffer *v23;
  char *v24;
  HGBitmap *v25;
  char *v26;
  int v27;
  char *Buffer;
  char *v29;
  HGCVBitmap *CVBitmapStorage;
  HGCVBitmap *v31;
  HGCVBitmap *v32;
  const char *v33;
  char *v34;
  unsigned __int8 v35;
  dispatch_group_t *v36;
  HGRect v37;
  HGRect v38;
  HGRect v39;

  if (!a6)
    return HGGPURenderer::ProcessNodeInternal((HGRenderer *)a1, a2, a3, a4, a5, a7, a8, a9, a10);
  LUTEnd = (HGMetalDeviceInfo *)PCICCTransferFunctionLUT::getLUTEnd(*(PCICCTransferFunctionLUT **)(a1 + 1112));
  if ((*(_BYTE *)(a6 + 12) & 1) != 0)
  {
    v23 = (HGBuffer *)HGObject::operator new(0x80uLL);
    HGBuffer::HGBuffer(v23, *(HGRect *)(a6 + 20), (HGBitmap *)a6);
    v21 = HGGPURenderer::ProcessNodeInternal((HGRenderer *)a1, a2, a3, a4, a5, (char *)v23, a8, a9, a10);
    if (v23)
      (*(void (**)(HGBuffer *))(*(_QWORD *)v23 + 24))(v23);
    return v21;
  }
  if (HGMetalDeviceInfo::isApple(LUTEnd)
    && *(_DWORD *)(a1 + 1268) == 1
    && (*(_BYTE *)(a6 + 12) & 0x30) == 0
    && HGMetalBuffer::canCreateFromBytes((HGBitmap *)a6, v18))
  {
    v19 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)a1, *(HGRect *)(a6 + 20), (HGBitmap *)a6, 1);
    v20 = (HGBuffer *)HGObject::operator new(0x80uLL);
    *(_QWORD *)&v37.var0 = *(_QWORD *)((char *)v19 + 20);
    *(_QWORD *)&v37.var2 = *(_QWORD *)((char *)v19 + 28);
    HGBuffer::HGBuffer(v20, v37, v19);
    v21 = HGGPURenderer::ProcessNodeInternal((HGRenderer *)a1, a2, a3, a4, a5, (char *)v20, a8, a9, a10);
    HGGPURenderer::FinishMetalCommandBuffer((HGGPURenderer *)a1);
    if (v20)
      (*(void (**)(HGBuffer *))(*(_QWORD *)v20 + 24))(v20);
    (*(void (**)(HGBitmap *))(*(_QWORD *)v19 + 24))(v19);
    return v21;
  }
  v24 = HGGPURenderer::ProcessNodeInternal((HGRenderer *)a1, a2, a3, a4, a5, 0, a8, a9, a10);
  v26 = v24;
  v27 = *((_DWORD *)v24 + 3);
  if ((v27 & 1) != 0 || (v27 & 0x30) == 0)
  {
    CVBitmapStorage = (HGCVBitmap *)HGCVBitmap::getCVBitmapStorage((HGBitmap *)v24, v25);
    v31 = CVBitmapStorage;
    if (CVBitmapStorage)
      v32 = CVBitmapStorage;
    else
      v32 = (HGCVBitmap *)v26;
    if (CVBitmapStorage)
      HGCVBitmap::lock(CVBitmapStorage, 0);
    if (*((_DWORD *)v32 + 4) == *(_DWORD *)(a6 + 16))
    {
      HGRenderUtils::BufferCopier::BufferCopier((HGRenderUtils::BufferCopier *)&v36);
      HGRenderUtils::BufferCopier::execute(&v36, (HGBitmap *)a6, (HGBitmap *)v32);
      HGRenderUtils::BufferCopier::~BufferCopier((HGRenderUtils::BufferCopier *)&v36);
      if (!v31)
      {
LABEL_29:
        v35 = atomic_load(HGLogger::_enabled);
        if ((v35 & 1) != 0)
          HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"HGMTL PERF WARNING - HGGPURenderer::ProcessNode: extra memcopy of final render result\n", v33, v34);
        goto LABEL_32;
      }
    }
    else
    {
      HGRenderUtils::BufferReformatter::BufferReformatter((HGRenderUtils::BufferReformatter *)&v36);
      HGRenderUtils::BufferReformatter::execute((HGRenderUtils::BufferReformatter *)&v36, (HGBitmap *)a6, (HGBitmap *)v32);
      HGRenderUtils::BufferReformatter::~BufferReformatter((HGRenderUtils::BufferReformatter *)&v36);
      if (!v31)
        goto LABEL_29;
    }
    HGCVBitmap::unlock(v31, 0);
    goto LABEL_29;
  }
  if ((v27 & 0x20) != 0)
  {
    HGGPURenderer::ReadbackMetalTexture((HGGPURenderer *)a1, (HGBitmap *)v24, (HGBitmap *)a6);
  }
  else if ((v27 & 0x100) != 0)
  {
    (*(void (**)(uint64_t, char *))(*(_QWORD *)a1 + 144))(a1, v24);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 344))(a1, a3, a4, a6);
  }
  else
  {
    *(_QWORD *)&v38.var0 = a3;
    *(_QWORD *)&v38.var2 = a4;
    Buffer = HGGPURenderer::CreateBuffer(a1, v38, a5, 0);
    (*(void (**)(uint64_t, char *))(*(_QWORD *)a1 + 144))(a1, Buffer);
    (*(void (**)(uint64_t, _QWORD, char *, _QWORD, _QWORD))(*(_QWORD *)a1 + 152))(a1, 0, v26, 0, 0);
    *(_QWORD *)&v39.var0 = a3;
    *(_QWORD *)&v39.var2 = a4;
    HGGPURenderer::Copy((HGGPURenderer *)a1, v39, 0, v29);
    (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 152))(a1, 0, 0, 0, 0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 344))(a1, a3, a4, a6);
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
    (*(void (**)(char *))(*(_QWORD *)Buffer + 24))(Buffer);
  }
LABEL_32:
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  (*(void (**)(char *))(*(_QWORD *)v26 + 24))(v26);
  return 0;
}

void sub_1B2A4AC00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;
  void *v11;

  HGObject::operator delete(v11);
  (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  _Unwind_Resume(a1);
}

unsigned int *HGGPURenderer::GetNodeTexture(HGGPURenderer *this, HGNode *a2, HGRect a3, HGBuffer *a4, unsigned __int8 a5)
{
  uint64_t v6;
  uint64_t v7;
  HGBitmap *NodeBitmap;
  HGBitmap *v11;
  uint64_t v12;
  HGBitmap *v13;
  HGBitmap *v14;
  int v15;
  uint64_t v16;
  void *v18;

  v6 = *(_QWORD *)&a3.var2;
  v7 = *(_QWORD *)&a3.var0;
  NodeBitmap = HGGPURenderer::GetNodeBitmap(this, a2, a3, a4, a5);
  if (!NodeBitmap)
    return HGGPURenderer::LoadNullGLTexture(this);
  v11 = NodeBitmap;
  if (!a4)
  {
    v7 = HGRectIntersection(v7, v6, *((_QWORD *)a2 + 19), *((_QWORD *)a2 + 20));
    v6 = v12;
  }
  v13 = HGGPURenderer::ConvertToNonMetalTexture(this, v11);
  v14 = v13;
  v15 = *((_DWORD *)v13 + 3);
  if ((v15 & 0x30) != 0)
  {
    if ((v15 & 0x10) != 0)
    {
      if ((v15 & 0x100) != 0)
      {
        (*(void (**)(HGGPURenderer *, HGBitmap *))(*(_QWORD *)this + 144))(this, v13);
        v16 = (*(uint64_t (**)(HGGPURenderer *))(*(_QWORD *)this + 328))(this);
        goto LABEL_14;
      }
      if ((v15 & 0x200) != 0)
      {
        v16 = (uint64_t)v18;
        if (v18)
          (*(void (**)(void *))(*(_QWORD *)v18 + 16))(v18);
        goto LABEL_14;
      }
    }
    v16 = 0;
  }
  else
  {
    v16 = (*(uint64_t (**)(HGGPURenderer *, uint64_t, uint64_t, HGBitmap *))(*(_QWORD *)this + 352))(this, v7, v6, v13);
  }
LABEL_14:
  (*(void (**)(HGBitmap *))(*(_QWORD *)v14 + 24))(v14);
  (*(void (**)(HGBitmap *))(*(_QWORD *)v11 + 24))(v11);
  return (unsigned int *)v16;
}

HGBitmap *HGGPURenderer::GetNodeBitmap(HGGPURenderer *this, HGNode *a2, HGRect a3, HGBuffer *a4, unsigned __int8 a5)
{
  uint64_t v6;
  uint64_t v7;
  HGBitmap *v10;
  HGBitmap *v11;
  uint64_t v12;
  int NodeRenderAPI;
  char *Buffer;
  const char *v15;
  char *v16;
  unsigned __int8 v17;
  uint64_t v20;
  uint64_t OutputFormat;
  HGRect v22;
  HGRect v23;

  if (!a2)
    return 0;
  v6 = *(_QWORD *)&a3.var2;
  v7 = *(_QWORD *)&a3.var0;
  v10 = (HGBitmap *)*((_QWORD *)a2 + 24);
  if (v10 || (v10 = (HGBitmap *)*((_QWORD *)a2 + 31)) != 0)
  {
    (*(void (**)(HGBitmap *))(*(_QWORD *)v10 + 16))(v10);
    if ((a5 & 1) != 0)
      return v10;
    goto LABEL_5;
  }
  if (!a4)
  {
    v7 = HGRectIntersection(*(uint64_t *)&a3.var0, *(uint64_t *)&a3.var2, *((_QWORD *)a2 + 19), *((_QWORD *)a2 + 20));
    v6 = v20;
  }
  OutputFormat = HGRenderer::GetOutputFormat(this, a2);
  v10 = (HGBitmap *)HGGPURenderer::ProcessNodeInternal(this, (uint64_t)a2, v7, v6, OutputFormat, (char *)a4, 0, 0, a5);
  if ((a5 & 1) == 0)
  {
LABEL_5:
    if (HGBitmapUtils::isPadded((HGBitmapUtils *)v10, v11))
    {
      v12 = *((unsigned int *)v10 + 4);
      NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI(this, a2);
      *(_QWORD *)&v22.var0 = v7;
      *(_QWORD *)&v22.var2 = v6;
      Buffer = HGGPURenderer::CreateBuffer((uint64_t)this, v22, v12, NodeRenderAPI, (*((_DWORD *)a2 + 4) >> 12) & 1, 0, *((_BYTE *)this + 1336) == 0);
      *(_QWORD *)&v23.var0 = v7;
      *(_QWORD *)&v23.var2 = v6;
      HGGPURenderer::CopyBitmapIntoBuffer(this, (HGBuffer *)Buffer, v23, v10);
      v17 = atomic_load(HGLogger::_enabled);
      if ((v17 & 1) != 0)
        HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"Helium WARNING -- buffer copy in HGGPURenderer::GetNodeBitmap(...) due to padding requirements.\n", v15, v16);
      (*(void (**)(HGBitmap *))(*(_QWORD *)v10 + 24))(v10);
      return (HGBitmap *)Buffer;
    }
  }
  return v10;
}

HGBitmap *HGGPURenderer::GetNodeMetalTexture(HGGPURenderer *this, HGNode *a2, HGRect a3, HGBuffer *a4, unsigned __int8 a5)
{
  uint64_t v6;
  uint64_t v7;
  HGBitmap *NodeBitmap;
  HGBitmap *v11;
  uint64_t v12;
  HGBitmap *v13;
  HGRect v15;

  v6 = *(_QWORD *)&a3.var2;
  v7 = *(_QWORD *)&a3.var0;
  NodeBitmap = HGGPURenderer::GetNodeBitmap(this, a2, a3, a4, a5);
  if (!NodeBitmap)
    return (HGBitmap *)HGGPURenderer::LoadNullMetalTexture(this);
  v11 = NodeBitmap;
  if (!a4)
  {
    v7 = HGRectIntersection(v7, v6, *((_QWORD *)a2 + 19), *((_QWORD *)a2 + 20));
    v6 = v12;
  }
  *(_QWORD *)&v15.var0 = v7;
  *(_QWORD *)&v15.var2 = v6;
  v13 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)this, v15, v11, 1);
  (*(void (**)(HGBitmap *))(*(_QWORD *)v11 + 24))(v11);
  return v13;
}

uint64_t HGGPURenderer::CopyBitmapIntoBuffer(uint64_t this, HGBuffer *a2, HGRect a3, HGBitmap *a4)
{
  uint64_t v5;
  uint64_t v6;
  HGMetalTexture **v8;
  int v9;
  HGBitmap *v10;
  void *MetalStorage;
  HGBitmap *v12;
  void *CVBitmapStorage;
  char *v14;
  HGBitmap *v20;
  HGBitmap *v21;
  int v22;
  uint64_t v23;
  void *v24;
  char *v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  __n128 v29;
  HGRect v30;
  HGRect v31;
  HGRect v32;

  if (a2)
  {
    if (a4)
    {
      v5 = *(_QWORD *)&a3.var2;
      v6 = *(_QWORD *)&a3.var0;
      v8 = (HGMetalTexture **)this;
      this = HGRectIsNull(*(_QWORD *)((char *)a2 + 20), *(_QWORD *)((char *)a2 + 28));
      if (!(_DWORD)this)
      {
        v9 = (*((uint64_t (**)(HGMetalTexture **, uint64_t))*v8 + 16))(v8, 43);
        MetalStorage = HGMetalTexture::getMetalStorage((HGBitmap *)a2, v10);
        CVBitmapStorage = HGCVBitmap::getCVBitmapStorage((HGBitmap *)a2, v12);
        if (MetalStorage || CVBitmapStorage && v9 == 1)
        {
          (*((void (**)(HGMetalTexture **, _QWORD))*v8 + 18))(v8, 0);
          *(_QWORD *)&v30.var0 = v6;
          *(_QWORD *)&v30.var2 = v5;
          v14 = (char *)HGGPURenderer::ConvertToMetalTexture(v8, v30, a4, 1);
          __asm { FMOV            V0.4S, #1.0 }
          v29 = _Q0;
          v26 = 0;
          v27 = xmmword_1B309BAB0;
          v28 = 0;
          *(_QWORD *)&v32.var0 = v6;
          *(_QWORD *)&v32.var2 = v5;
          HGGPURenderer::CopyMetal((HGGPURenderer *)v8, (HGBitmap *)a2, v32, v14, (const HGBlendingInfo *)&v26, &v29, 0);
          return (*(uint64_t (**)(char *))(*(_QWORD *)v14 + 24))(v14);
        }
        v20 = HGGPURenderer::ConvertToNonMetalTexture((HGGPURenderer *)v8, a4);
        v21 = v20;
        v22 = *((_DWORD *)v20 + 3);
        if ((v22 & 0x30) != 0)
        {
          if ((v22 & 0x10) != 0)
          {
            if ((v22 & 0x100) != 0)
            {
              (*((void (**)(HGMetalTexture **, HGBitmap *))*v8 + 18))(v8, v20);
              v23 = (*((uint64_t (**)(HGMetalTexture **))*v8 + 41))(v8);
              goto LABEL_18;
            }
            if ((v22 & 0x200) != 0)
            {
              v23 = (uint64_t)v24;
              if (v24)
                (*(void (**)(void *))(*(_QWORD *)v24 + 16))(v24);
              goto LABEL_18;
            }
          }
          v23 = 0;
        }
        else
        {
          v23 = (*((uint64_t (**)(HGMetalTexture **, uint64_t, uint64_t, HGBitmap *))*v8 + 44))(v8, v6, v5, v20);
        }
LABEL_18:
        (*(void (**)(HGBitmap *))(*(_QWORD *)v21 + 24))(v21);
        (*((void (**)(HGMetalTexture **, HGBuffer *))*v8 + 18))(v8, a2);
        (*((void (**)(HGMetalTexture **, _QWORD, uint64_t, _QWORD, _QWORD))*v8 + 19))(v8, 0, v23, 0, 0);
        *(_QWORD *)&v31.var0 = v6;
        *(_QWORD *)&v31.var2 = v5;
        HGGPURenderer::Copy((HGGPURenderer *)v8, v31, 0, v25);
        (*((void (**)(HGMetalTexture **, _QWORD, _QWORD, _QWORD, _QWORD))*v8 + 19))(v8, 0, 0, 0, 0);
        return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v23 + 24))(v23);
      }
    }
  }
  return this;
}

HGBitmap *HGGPURenderer::ConvertToNonGLTexture(HGGPURenderer *this, HGBitmap *a2)
{
  int v3;
  unsigned int v6;
  BOOL v7;
  uint64_t v8;
  const char *v10;
  char *v11;
  unsigned __int8 v12;
  HGBuffer *CVBitmapStorage;
  const HGEdgePolicy *EdgePolicy;
  const char *v15;
  char *v16;
  unsigned __int8 v17;

  v3 = *((_DWORD *)a2 + 3);
  if ((v3 & 0x10) != 0)
  {
    if ((v3 & 1) != 0)
    {
      CVBitmapStorage = (HGBuffer *)HGCVBitmap::getCVBitmapStorage(a2, a2);
      (*(void (**)(HGBuffer *))(*(_QWORD *)CVBitmapStorage + 16))(CVBitmapStorage);
    }
    else
    {
      v6 = *((_DWORD *)a2 + 4);
      v7 = v6 > 0x21;
      v8 = (1 << v6) & 0x38401C000;
      if (v7 || v8 == 0)
      {
        kdebug_trace();
        if (*((_BYTE *)this + 1281) && *((_DWORD *)this + 311))
          glFlush();
        *((_DWORD *)this + 311) = 0;
        v17 = atomic_load(HGLogger::_enabled);
        if ((v17 & 1) != 0)
          HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"HGMTL PERF WARNING - HGGPURenderer::ConvertToNonGLTexture: extra copy from OpenGL texture to IOSurface\n", v15, v16);
        CVBitmapStorage = (HGBuffer *)HGGPURenderer::CreateBuffer((uint64_t)this, *(HGRect *)((char *)a2 + 20), *((unsigned int *)a2 + 4), 0, 1, 0, *((_BYTE *)this + 1336) == 0);
        HGGPURenderer::BufferCopyOpenGL(this, CVBitmapStorage, *(HGRect *)((char *)a2 + 20), a2);
        kdebug_trace();
      }
      else
      {
        kdebug_trace();
        v12 = atomic_load(HGLogger::_enabled);
        if ((v12 & 1) != 0)
          HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"HGMTL PERF WARNING - HGGPURenderer::ConvertToNonGLTexture: extra copy from OpenGL texture through system memory\n", v10, v11);
        CVBitmapStorage = (HGBuffer *)(*(uint64_t (**)(HGGPURenderer *, HGBitmap *, _QWORD))(*(_QWORD *)this + 96))(this, a2, *((unsigned int *)a2 + 4));
        kdebug_trace();
      }
    }
    EdgePolicy = (const HGEdgePolicy *)HGBitmap::GetEdgePolicy(a2);
    HGBitmap::SetEdgePolicy((HGBitmap *)CVBitmapStorage, EdgePolicy);
    return (HGBitmap *)CVBitmapStorage;
  }
  else
  {
    (*(void (**)(HGBitmap *))(*(_QWORD *)a2 + 16))(a2);
    return a2;
  }
}

void sub_1B2A4B4D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  _Unwind_Resume(a1);
}

void sub_1B2A4B4F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)va);
  _Unwind_Resume(a1);
}

void HGGPURenderer::BufferCopyOpenGL(HGGPURenderer *this, HGBuffer *a2, HGRect a3, HGBitmap *a4)
{
  uint64_t v6;
  uint64_t v7;
  _DWORD *v9;
  _DWORD *v10;
  int v11;
  uint64_t v12;
  void *v13;
  char *v14;
  HGRect v15;

  if ((*((_BYTE *)a4 + 12) & 0x20) != 0 || (*((_BYTE *)a2 + 12) & 0x20) != 0)
  {
    HGLogger::warning((HGLogger *)"Can't OpenGL-copy between Metal objects.", (const char *)a2, *(char **)&a3.var0, *(_QWORD *)&a3.var2);
    return;
  }
  v6 = *(_QWORD *)&a3.var2;
  v7 = *(_QWORD *)&a3.var0;
  if (!HGRectIsNull(*(_QWORD *)((char *)a2 + 20), *(_QWORD *)((char *)a2 + 28)))
  {
    v9 = (_DWORD *)HGGPURenderer::ConvertToNonMetalTexture(this, a4);
    v10 = v9;
    v11 = v9[3];
    if ((v11 & 0x30) != 0)
    {
      if ((v11 & 0x10) != 0)
      {
        if ((v11 & 0x100) != 0)
        {
          (*(void (**)(HGGPURenderer *, _DWORD *))(*(_QWORD *)this + 144))(this, v9);
          v12 = (*(uint64_t (**)(HGGPURenderer *))(*(_QWORD *)this + 328))(this);
          goto LABEL_15;
        }
        if ((v11 & 0x200) != 0)
        {
          v12 = (uint64_t)v13;
          if (v13)
            (*(void (**)(void *))(*(_QWORD *)v13 + 16))(v13);
          goto LABEL_15;
        }
      }
      v12 = 0;
    }
    else
    {
      v12 = (*(uint64_t (**)(HGGPURenderer *, uint64_t, uint64_t, _DWORD *))(*(_QWORD *)this + 352))(this, v7, v6, v9);
    }
LABEL_15:
    (*(void (**)(_DWORD *))(*(_QWORD *)v10 + 24))(v10);
    (*(void (**)(HGGPURenderer *, HGBuffer *))(*(_QWORD *)this + 144))(this, a2);
    (*(void (**)(HGGPURenderer *, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)this + 152))(this, 0, v12, 0, 0);
    *(_QWORD *)&v15.var0 = v7;
    *(_QWORD *)&v15.var2 = v6;
    HGGPURenderer::Copy(this, v15, 0, v14);
    (*(void (**)(HGGPURenderer *, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 152))(this, 0, 0, 0, 0);
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
    if (*((_BYTE *)this + 1281))
    {
      if (*((_DWORD *)this + 311))
        glFlush();
    }
    *((_DWORD *)this + 311) = 0;
  }
}

HGBitmap *HGGPURenderer::ConvertToNonMetalTexture(HGGPURenderer *this, HGBitmap *a2)
{
  int v3;
  unsigned int v6;
  BOOL v7;
  uint64_t v8;
  const char *v10;
  char *v11;
  unsigned __int8 v12;
  HGBuffer *CVBitmapStorage;
  const HGEdgePolicy *EdgePolicy;
  HGBitmap *v15;
  const void *v16;
  HGMetalHandler *v17;
  HGMetalHandler *v18;
  id *v19;
  const char *v20;
  char *v21;
  unsigned __int8 v22;

  v3 = *((_DWORD *)a2 + 3);
  if ((v3 & 0x20) != 0)
  {
    if ((v3 & 1) != 0)
    {
      CVBitmapStorage = (HGBuffer *)HGCVBitmap::getCVBitmapStorage(a2, a2);
      (*(void (**)(HGBuffer *))(*(_QWORD *)CVBitmapStorage + 16))(CVBitmapStorage);
    }
    else
    {
      v6 = *((_DWORD *)a2 + 4);
      v7 = v6 > 0x21;
      v8 = (1 << v6) & 0x38401C000;
      if (v7 || v8 == 0)
      {
        kdebug_trace();
        (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
        v16 = (const void *)*((_QWORD *)this + 164);
        if (v16)
        {
          if (v17)
          {
            v18 = v17;
            HGMetalHandler::FinalizeCommandBuffer(v17);
            HGMetalHandler::BindBuffer(v18, 0);
          }
        }
        v19 = (id *)*((_QWORD *)this + 165);
        if (v19)
          HGMetalCommandBufferRef::waitUntilCompleted(v19);
        HGMetalTexture::getMetalStorage(a2, v15);
        v22 = atomic_load(HGLogger::_enabled);
        if ((v22 & 1) != 0)
          HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"HGMTL PERF WARNING - HGGPURenderer::ConvertToNonMetalTexture: extra copy from Metal texture to IOSurface\n", v20, v21);
        CVBitmapStorage = (HGBuffer *)HGGPURenderer::CreateBuffer((uint64_t)this, *(HGRect *)((char *)a2 + 20), *((unsigned int *)a2 + 4), 1, 1, 0, *((_BYTE *)this + 1336) == 0);
        HGGPURenderer::BufferCopyMetal(this, CVBitmapStorage, *(HGRect *)((char *)a2 + 20), a2);
        kdebug_trace();
      }
      else
      {
        kdebug_trace();
        v12 = atomic_load(HGLogger::_enabled);
        if ((v12 & 1) != 0)
          HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"HGMTL PERF WARNING - HGGPURenderer::ConvertToNonMetalTexture: extra copy from Metal texture through system memory\n", v10, v11);
        CVBitmapStorage = (HGBuffer *)(*(uint64_t (**)(HGGPURenderer *, HGBitmap *, _QWORD))(*(_QWORD *)this + 96))(this, a2, *((unsigned int *)a2 + 4));
        kdebug_trace();
      }
    }
    EdgePolicy = (const HGEdgePolicy *)HGBitmap::GetEdgePolicy(a2);
    HGBitmap::SetEdgePolicy((HGBitmap *)CVBitmapStorage, EdgePolicy);
    return (HGBitmap *)CVBitmapStorage;
  }
  else
  {
    (*(void (**)(HGBitmap *))(*(_QWORD *)a2 + 16))(a2);
    return a2;
  }
}

void sub_1B2A4B968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  _Unwind_Resume(a1);
}

void sub_1B2A4B988(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)va);
  _Unwind_Resume(a1);
}

void HGGPURenderer::BufferCopyMetal(HGGPURenderer *this, HGBuffer *a2, HGRect a3, HGBitmap *a4)
{
  uint64_t v6;
  uint64_t v7;
  const void *v14;
  HGMetalHandler *v15;
  HGMetalHandler *v16;
  id *v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  __n128 v21;
  HGRect v22;

  if ((*((_BYTE *)a4 + 12) & 0x10) != 0 || (*((_BYTE *)a2 + 12) & 0x10) != 0)
  {
    HGLogger::warning((HGLogger *)"Can't Metal-copy between OpenGL objects.", (const char *)a2, *(char **)&a3.var0, *(_QWORD *)&a3.var2);
  }
  else
  {
    v6 = *(_QWORD *)&a3.var2;
    v7 = *(_QWORD *)&a3.var0;
    (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
    __asm { FMOV            V0.4S, #1.0 }
    v21 = _Q0;
    v18 = 0;
    v19 = xmmword_1B309BAB0;
    v20 = 0;
    *(_QWORD *)&v22.var0 = v7;
    *(_QWORD *)&v22.var2 = v6;
    HGGPURenderer::CopyMetal(this, (HGBitmap *)a2, v22, (char *)a4, (const HGBlendingInfo *)&v18, &v21, 0);
    (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
    v14 = (const void *)*((_QWORD *)this + 164);
    if (v14)
    {
      if (v15)
      {
        v16 = v15;
        HGMetalHandler::FinalizeCommandBuffer(v15);
        HGMetalHandler::BindBuffer(v16, 0);
      }
    }
    v17 = (id *)*((_QWORD *)this + 165);
    if (v17)
      HGMetalCommandBufferRef::waitUntilCompleted(v17);
  }
}

HGBitmap *HGGPURenderer::ConvertToMetalTexture(HGMetalTexture **this, HGBitmap *a2)
{
  HGRect v4;

  *(_QWORD *)&v4.var0 = *(_QWORD *)((char *)a2 + 20);
  *(_QWORD *)&v4.var2 = *(_QWORD *)((char *)a2 + 28);
  return HGGPURenderer::ConvertToMetalTexture(this, v4, a2, 1);
}

HGBitmap *HGGPURenderer::ConvertToMetalTexture(HGMetalTexture **this, HGRect a2, HGBitmap *a3, int a4)
{
  uint64_t v6;
  HGBitmap *v7;
  HGBitmap *v9;
  uint64_t v10;
  uint64_t v11;
  HGBitmap *v12;
  HGBitmap *NullMetalTexture;
  int v15;
  HGBitmap *v16;
  const HGEdgePolicy *v17;
  const HGEdgePolicy *EdgePolicy;
  char *MetalStorage;
  unsigned int *v20;
  HGMetalBuffer *v21;
  uint64_t v22;
  HGBitmap *v23;
  HGRect v24;
  HGRect v25;

  v6 = *(_QWORD *)&a2.var2;
  v7 = *(HGBitmap **)&a2.var0;
  v9 = HGGPURenderer::ConvertToNonGLTexture((HGGPURenderer *)this, a3);
  v10 = HGRectIntersection((uint64_t)v7, v6, *(_QWORD *)((char *)v9 + 20), *(_QWORD *)((char *)v9 + 28));
  if (HGRectIsNull(v10, v11))
    goto LABEL_2;
  v15 = *((_DWORD *)v9 + 3);
  if ((v15 & 0x30) == 0)
  {
    if ((v15 & 1) == 0 && !*((_QWORD *)v9 + 10))
      goto LABEL_2;
    *(_QWORD *)&v24.var0 = v6;
    *(_QWORD *)&v24.var2 = 1;
    HGMetalTexture::createFromBitmap(this[139], (HGMetalContext *)v9, v7, v24, 0, (HGMetalContext **)&v23);
    NullMetalTexture = v23;
    if (!v23 || !a4)
      goto LABEL_3;
LABEL_18:
    EdgePolicy = (const HGEdgePolicy *)HGBitmap::GetEdgePolicy(a3);
    HGBitmap::SetEdgePolicy(NullMetalTexture, EdgePolicy);
    goto LABEL_3;
  }
  if ((v15 & 0x20) == 0)
  {
LABEL_2:
    NullMetalTexture = 0;
    goto LABEL_3;
  }
  if ((v15 & 0x100) != 0)
  {
    MetalStorage = (char *)HGMetalBuffer::getMetalStorage(v9, v12);
    v20 = (unsigned int *)this[139];
    v21 = (HGMetalBuffer *)HGRectIntersection(*(_QWORD *)(MetalStorage + 20), *(_QWORD *)(MetalStorage + 28), (uint64_t)v7, v6);
    *(_QWORD *)&v25.var0 = v22;
    *(_QWORD *)&v25.var2 = 0;
    HGMetalTexture::createFromBuffer((HGMetalTexture *)v20, (HGMetalContext *)v20[12], (HGMetalContext *)MetalStorage, v21, v25, &v23);
    NullMetalTexture = v23;
    if (!v23)
      goto LABEL_3;
    HGBitmap::SetStorage(v23, (HGObject *)MetalStorage);
    if (!a4)
      goto LABEL_3;
    goto LABEL_18;
  }
  if ((v15 & 0x200) == 0)
    goto LABEL_2;
  v16 = (HGBitmap *)HGMetalTexture::getMetalStorage(v9, v12);
  if (*((_QWORD *)v16 + 17) != *(_QWORD *)(*((_QWORD *)this[139] + 2) + 16))
    goto LABEL_2;
  NullMetalTexture = v16;
  (*(void (**)(HGBitmap *))(*(_QWORD *)v16 + 16))(v16);
  if (a4)
  {
    v17 = (const HGEdgePolicy *)HGBitmap::GetEdgePolicy(a3);
    HGBitmap::SetEdgePolicy(NullMetalTexture, v17);
  }
LABEL_3:
  (*(void (**)(HGBitmap *))(*(_QWORD *)v9 + 24))(v9);
  if (NullMetalTexture
    || (NullMetalTexture = (HGBitmap *)HGGPURenderer::LoadNullMetalTexture((HGGPURenderer *)this)) != 0)
  {
    (*(void (**)(HGBitmap *))(*(_QWORD *)NullMetalTexture + 16))(NullMetalTexture);
    (*(void (**)(HGBitmap *))(*(_QWORD *)NullMetalTexture + 24))(NullMetalTexture);
  }
  return NullMetalTexture;
}

void sub_1B2A4BCB4(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

std::string *HGGPURenderer::CopyMetal(HGGPURenderer *this, HGBitmap *a2, HGRect a3, HGBitmap *a4)
{
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  __n128 v13;

  __asm { FMOV            V0.4S, #1.0 }
  v13 = _Q0;
  v10 = 0;
  v11 = xmmword_1B309BAB0;
  v12 = 0;
  return HGGPURenderer::CopyMetal(this, a2, a3, (char *)a4, (const HGBlendingInfo *)&v10, &v13, 0);
}

BOOL HGGPURenderer::ClearBuffer(_BOOL8 this, HGBuffer *a2, HGRect a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  HGGPURenderer *v9;
  int v10;
  HGBitmap *v11;
  void *MetalStorage;
  HGBitmap *v13;
  void *CVBitmapStorage;
  HGRect v15;
  HGRect v16;
  HGRect v17;
  HGRect v18;

  if (a2)
  {
    v4 = *(_QWORD *)&a4.var2;
    v5 = *(_QWORD *)&a4.var0;
    v6 = *(_QWORD *)&a3.var2;
    v7 = *(_QWORD *)&a3.var0;
    v9 = (HGGPURenderer *)this;
    this = HGRectIsNull(*(_QWORD *)((char *)a2 + 20), *(_QWORD *)((char *)a2 + 28));
    if (!(_DWORD)this)
    {
      v10 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)v9 + 128))(v9, 43);
      MetalStorage = HGMetalTexture::getMetalStorage((HGBitmap *)a2, v11);
      CVBitmapStorage = HGCVBitmap::getCVBitmapStorage((HGBitmap *)a2, v13);
      if (MetalStorage || CVBitmapStorage && v10 == 1)
      {
        (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)v9 + 144))(v9, 0);
        *(_QWORD *)&v16.var0 = v7;
        *(_QWORD *)&v16.var2 = v6;
        *(_QWORD *)&v18.var0 = v5;
        *(_QWORD *)&v18.var2 = v4;
        return HGGPURenderer::ClearMetal(v9, a2, v16, v18);
      }
      else
      {
        (*(void (**)(HGGPURenderer *, HGBuffer *))(*(_QWORD *)v9 + 144))(v9, a2);
        *(_QWORD *)&v15.var0 = v7;
        *(_QWORD *)&v15.var2 = v6;
        *(_QWORD *)&v17.var0 = v5;
        *(_QWORD *)&v17.var2 = v4;
        this = HGGPURenderer::Clear(v9, v15, v17);
        if ((_DWORD)this)
          *((_DWORD *)v9 + 311) = 1;
      }
    }
  }
  return this;
}

BOOL HGGPURenderer::ClearMetal(HGGPURenderer *this, HGBuffer *a2, HGRect a3, HGRect a4)
{
  uint64_t v4;
  signed int var0;
  uint64_t v6;
  signed int v7;
  signed int var1;
  signed int v11;
  _BOOL8 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE v18[16];
  HGRect v19;
  HGRect v20;
  HGRect v21;
  HGRect v22;

  v4 = *(_QWORD *)&a4.var2;
  var0 = a4.var0;
  v6 = *(_QWORD *)&a3.var2;
  v7 = a3.var0;
  var1 = a3.var1;
  v11 = a4.var1;
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v18, "gpu", 2, "clear texture borders to zero");
  v12 = var1 > v11;
  if (var1 > v11)
  {
    *(_QWORD *)&v19.var0 = HGRectMake4i(var0, v11, v4, var1);
    *(_QWORD *)&v19.var2 = v13;
    HGGPURenderer::ClearMetal(this, a2, v19);
  }
  if (SHIDWORD(v6) < SHIDWORD(v4))
  {
    *(_QWORD *)&v20.var0 = HGRectMake4i(var0, HIDWORD(v6), v4, HIDWORD(v4));
    *(_QWORD *)&v20.var2 = v14;
    HGGPURenderer::ClearMetal(this, a2, v20);
    v12 = 1;
  }
  if (v7 > var0)
  {
    *(_QWORD *)&v21.var0 = HGRectMake4i(var0, var1, v7, HIDWORD(v6));
    *(_QWORD *)&v21.var2 = v15;
    HGGPURenderer::ClearMetal(this, a2, v21);
    v12 = 1;
  }
  if ((int)v6 < (int)v4)
  {
    *(_QWORD *)&v22.var0 = HGRectMake4i(v6, var1, v4, HIDWORD(v6));
    *(_QWORD *)&v22.var2 = v16;
    HGGPURenderer::ClearMetal(this, a2, v22);
    v12 = 1;
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v18);
  return v12;
}

void sub_1B2A4BFC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::ClearBuffer(uint64_t this, HGBuffer *a2, HGRect a3)
{
  uint64_t v3;
  uint64_t v4;
  HGGPURenderer *v6;
  int v7;
  HGBitmap *v8;
  void *MetalStorage;
  HGBitmap *v10;
  void *CVBitmapStorage;
  const char *v12;
  char *v13;
  HGRect v14;
  HGRect v15;

  if (a2)
  {
    v3 = *(_QWORD *)&a3.var2;
    v4 = *(_QWORD *)&a3.var0;
    v6 = (HGGPURenderer *)this;
    this = HGRectIsNull(*(_QWORD *)((char *)a2 + 20), *(_QWORD *)((char *)a2 + 28));
    if (!(_DWORD)this)
    {
      v7 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)v6 + 128))(v6, 43);
      MetalStorage = HGMetalTexture::getMetalStorage((HGBitmap *)a2, v8);
      CVBitmapStorage = HGCVBitmap::getCVBitmapStorage((HGBitmap *)a2, v10);
      if (MetalStorage || CVBitmapStorage && v7 == 1)
      {
        (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)v6 + 144))(v6, 0);
        *(_QWORD *)&v15.var0 = v4;
        *(_QWORD *)&v15.var2 = v3;
        return HGGPURenderer::ClearMetal(v6, a2, v15);
      }
      else
      {
        (*(void (**)(HGGPURenderer *, HGBuffer *))(*(_QWORD *)v6 + 144))(v6, a2);
        *(_QWORD *)&v14.var0 = v4;
        *(_QWORD *)&v14.var2 = v3;
        this = HGGPURenderer::Clear(v6, v14, v12, v13);
        *((_DWORD *)v6 + 311) = 1;
      }
    }
  }
  return this;
}

std::string *HGGPURenderer::ClearMetal(HGGPURenderer *this, HGBitmap *a2, HGRect a3, char *a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 v8;
  HGGLShaderCache *v9;
  double v10;
  double v11;
  uint32x4_t v12;
  const char *v13;
  uint64_t Entry;
  uint64_t v15;
  std::string *result;
  HGMetalHandler *v17;
  std::string __p[2];

  v4 = *(_QWORD *)&a3.var2;
  v5 = *(_QWORD *)&a3.var0;
  v8 = atomic_load(HGLogger::_enabled);
  if ((v8 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"clear texture to zero [%d %d %d %d]\n", *(const char **)&a3.var2, a4, *(_QWORD *)&a3.var0, a3.var1, *(_QWORD *)&a3.var2, a3.var3);
  v9 = (HGGLShaderCache *)*((_QWORD *)this + 161);
  HGString::zero((HGString *)0x60B10, 1, __p);
  v13 = HGString::c_str((string_t *)&__p[0].__r_.__value_.__l.__data_, v10, v11, v12);
  Entry = HGGLShaderCache::GetEntry(v9, v13);
  HGString::~HGString((HGString *)__p);
  if ((*(unsigned int (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)this + 432))(this, Entry))
    v15 = 0;
  else
    v15 = Entry;
  result = (std::string *)(*(uint64_t (**)(HGGPURenderer *, uint64_t, HGGPURenderer *))(*(_QWORD *)this + 368))(this, v15, this);
  if (result)
  {
    if (result)
    {
      v17 = (HGMetalHandler *)result;
      *((_BYTE *)&__p[0].__r_.__value_.__s + 23) = 5;
      strcpy((char *)__p, "clear");
      HGMetalHandler::SetDebugLabel(result, __p);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p[0].__r_.__value_.__l.__data_);
      HGMetalHandler::BindBuffer(v17, a2);
      (*(void (**)(HGMetalHandler *))(*(_QWORD *)v17 + 40))(v17);
      (*(void (**)(HGMetalHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v17 + 192))(v17, v5, v4, 1);
      return (std::string *)(*(uint64_t (**)(HGGPURenderer *, HGMetalHandler *))(*(_QWORD *)this + 392))(this, v17);
    }
  }
  return result;
}

void sub_1B2A4C260(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGGPURenderer::Clear(HGGPURenderer *this, HGRect a2, const char *a3, char *a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 v7;
  HGGLShaderCache *v8;
  double v9;
  double v10;
  uint32x4_t v11;
  const char *v12;
  uint64_t Entry;
  uint64_t result;
  BOOL v15;
  HGHandler *v16;
  string_t v17[6];
  HGRect v18;

  v4 = *(_QWORD *)&a2.var2;
  v5 = *(_QWORD *)&a2.var0;
  v7 = atomic_load(HGLogger::_enabled);
  if ((v7 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"clear texture to zero [%d %d %d %d]\n", a3, a4, *(_QWORD *)&a2.var0, a2.var1, *(_QWORD *)&a2.var2, a2.var3);
  v8 = (HGGLShaderCache *)*((_QWORD *)this + 161);
  HGString::zero((HGString *)0x60620, 1, v17);
  v12 = HGString::c_str(v17, v9, v10, v11);
  Entry = HGGLShaderCache::GetEntry(v8, v12);
  HGString::~HGString((HGString *)v17);
  result = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)this + 432))(this, Entry);
  if ((_DWORD)result)
    v15 = 1;
  else
    v15 = Entry == 0;
  if (!v15)
  {
    v16 = (HGHandler *)(*(uint64_t (**)(HGGPURenderer *, uint64_t, HGGPURenderer *))(*(_QWORD *)this + 368))(this, Entry, this);
    (*(void (**)(HGHandler *))(*(_QWORD *)v16 + 40))(v16);
    *(_QWORD *)&v18.var0 = v5;
    *(_QWORD *)&v18.var2 = v4;
    HGGPURenderer::Rect(this, v16, v18, 1);
    return (*(uint64_t (**)(HGGPURenderer *, HGHandler *))(*(_QWORD *)this + 392))(this, v16);
  }
  return result;
}

void sub_1B2A4C3A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

std::string *HGGPURenderer::ClearMetal(HGGPURenderer *this, HGBitmap *a2, HGRect a3, float *a4)
{
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 v9;
  HGGLShaderCache *v10;
  double v11;
  double v12;
  uint32x4_t v13;
  const char *v14;
  uint64_t Entry;
  uint64_t v16;
  std::string *result;
  HGMetalHandler *v18;
  std::string __p[2];

  v5 = *(_QWORD *)&a3.var2;
  v6 = *(_QWORD *)&a3.var0;
  v9 = atomic_load(HGLogger::_enabled);
  if ((v9 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"clear texture to uniform [%d %d %d %d]\n", *(const char **)&a3.var2, (char *)a4, *(_QWORD *)&a3.var0, a3.var1, *(_QWORD *)&a3.var2, a3.var3);
  v10 = (HGGLShaderCache *)*((_QWORD *)this + 161);
  HGString::uniform((HGString *)0x60B10, 1, __p);
  v14 = HGString::c_str((string_t *)&__p[0].__r_.__value_.__l.__data_, v11, v12, v13);
  Entry = HGGLShaderCache::GetEntry(v10, v14);
  HGString::~HGString((HGString *)__p);
  if ((*(unsigned int (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)this + 432))(this, Entry))
    v16 = 0;
  else
    v16 = Entry;
  result = (std::string *)(*(uint64_t (**)(HGGPURenderer *, uint64_t, HGGPURenderer *))(*(_QWORD *)this + 368))(this, v16, this);
  if (result)
  {
    if (result)
    {
      v18 = (HGMetalHandler *)result;
      *((_BYTE *)&__p[0].__r_.__value_.__s + 23) = 11;
      strcpy((char *)__p, "clear2color");
      HGMetalHandler::SetDebugLabel(result, __p);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p[0].__r_.__value_.__l.__data_);
      HGMetalHandler::BindBuffer(v18, a2);
      (*(void (**)(HGMetalHandler *, _QWORD, float *, uint64_t))(*(_QWORD *)v18 + 144))(v18, 0, a4, 1);
      (*(void (**)(HGMetalHandler *))(*(_QWORD *)v18 + 40))(v18);
      (*(void (**)(HGMetalHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v18 + 192))(v18, v6, v5, 1);
      return (std::string *)(*(uint64_t (**)(HGGPURenderer *, HGMetalHandler *))(*(_QWORD *)this + 392))(this, v18);
    }
  }
  return result;
}

void sub_1B2A4C56C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGGPURenderer::Clear(HGGPURenderer *this, HGRect a2, float *a3, char *a4)
{
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 v8;
  HGGLShaderCache *v9;
  double v10;
  double v11;
  uint32x4_t v12;
  const char *v13;
  uint64_t Entry;
  uint64_t result;
  BOOL v16;
  HGHandler *v17;
  string_t v18[6];
  HGRect v19;

  v5 = *(_QWORD *)&a2.var2;
  v6 = *(_QWORD *)&a2.var0;
  v8 = atomic_load(HGLogger::_enabled);
  if ((v8 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"clear texture to uniform [%d %d %d %d]\n", (const char *)a3, a4, *(_QWORD *)&a2.var0, a2.var1, *(_QWORD *)&a2.var2, a2.var3);
  v9 = (HGGLShaderCache *)*((_QWORD *)this + 161);
  HGString::uniform((HGString *)0x60620, 1, v18);
  v13 = HGString::c_str(v18, v10, v11, v12);
  Entry = HGGLShaderCache::GetEntry(v9, v13);
  HGString::~HGString((HGString *)v18);
  result = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)this + 432))(this, Entry);
  if ((_DWORD)result)
    v16 = 1;
  else
    v16 = Entry == 0;
  if (!v16)
  {
    v17 = (HGHandler *)(*(uint64_t (**)(HGGPURenderer *, uint64_t, HGGPURenderer *))(*(_QWORD *)this + 368))(this, Entry, this);
    (*(void (**)(HGHandler *, _QWORD, float *, uint64_t))(*(_QWORD *)v17 + 144))(v17, 0, a3, 1);
    (*(void (**)(HGHandler *))(*(_QWORD *)v17 + 40))(v17);
    *(_QWORD *)&v19.var0 = v6;
    *(_QWORD *)&v19.var2 = v5;
    HGGPURenderer::Rect(this, v17, v19, 1);
    return (*(uint64_t (**)(HGGPURenderer *, HGHandler *))(*(_QWORD *)this + 392))(this, v17);
  }
  return result;
}

void sub_1B2A4C6DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

void HGGPURenderer::Rect(HGGPURenderer *this, HGHandler *a2, HGRect a3, uint64_t a4)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v9;
  uint64_t v10;
  unsigned int v11;
  float v13;
  float v14;
  float v15;
  float v16;
  unint64_t v17;
  const char *v18;
  char *v19;
  const char *v20;
  char *v21;
  const char *v22;
  char *v23;
  unsigned __int8 v24;
  HGRect v25;

  v5 = *(_QWORD *)&a3.var2;
  v6 = *(_QWORD *)&a3.var0;
  if (!HGRenderer::RenderCheckPoint(this))
  {
    v9 = HIDWORD(v6);
    v10 = *((_QWORD *)this + 3);
    if (v10)
    {
      v11 = *(_DWORD *)(v10 + 16);
      if (v11 <= 0x1F && ((1 << v11) & 0x8001C000) != 0)
      {
        v13 = ceilf((float)(int)v6 / 6.0) * 4.0;
        v14 = ceilf((float)(int)v5 / 6.0) * 4.0;
        v15 = ceilf((float)(int)v6 * 0.5);
        v16 = ceilf((float)(int)v5 * 0.5);
        if (v11 - 14 > 2)
          v15 = v13;
        else
          v14 = v16;
        v6 = HGRectMake4i((int)v15, HIDWORD(v6), (int)v14, HIDWORD(v5));
        v5 = v17;
        v9 = HIDWORD(v6);
      }
    }
    if (!a2 || HG_RENDERER_ENV::SCISSORED_LARGE_TRI_TILES == 1)
    {
      if (!HGRenderer::RenderCheckPoint(this))
      {
        HGLogger::warning((HGLogger *)"HGGPURenderer::Rect() needs a HGHandler!\n", v20, v21);
        *(_QWORD *)&v25.var0 = v6;
        *(_QWORD *)&v25.var2 = v5;
        HGGPURenderer::Clear(this, v25, v22, v23);
      }
    }
    else
    {
      (*(void (**)(HGHandler *, unint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 192))(a2, v6, v5, a4);
    }
    v24 = atomic_load(HGLogger::_enabled);
    if ((v24 & 1) != 0)
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"rect[0..%d]: { %d, %d, %d, %d }\n", v18, v19, a4, v6, v9, v5, HIDWORD(v5));
    *((_DWORD *)this + 311) = 1;
  }
}

std::string *HGGPURenderer::CopyMetal(HGGPURenderer *this, HGBitmap *a2, HGRect a3, char *a4, const HGBlendingInfo *a5, __n128 *a6, int a7)
{
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 v15;
  HGGLShaderCache *v16;
  double v17;
  double v18;
  uint32x4_t v19;
  const char *v20;
  uint64_t Entry;
  uint64_t v22;
  std::string *result;
  HGMetalHandler *v24;
  std::string __p[2];
  HGRect v26;

  v7 = *(_QWORD *)&a3.var2;
  v8 = *(_QWORD *)&a3.var0;
  if (!a4)
    return HGGPURenderer::ClearMetal(this, a2, a3, 0);
  v15 = atomic_load(HGLogger::_enabled);
  if ((v15 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"copy texture to buffer [%d %d %d %d]\n", *(const char **)&a3.var2, a4, *(_QWORD *)&a3.var0, a3.var1, *(_QWORD *)&a3.var2, a3.var3);
  v16 = (HGGLShaderCache *)*((_QWORD *)this + 161);
  HGString::sample2d((HGString *)0x60B10, 0, *((_DWORD *)this + 145) == 27, (HGString *)__p);
  v20 = HGString::c_str((string_t *)&__p[0].__r_.__value_.__l.__data_, v17, v18, v19);
  Entry = HGGLShaderCache::GetEntry(v16, v20);
  HGString::~HGString((HGString *)__p);
  if ((*(unsigned int (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)this + 432))(this, Entry))
    v22 = 0;
  else
    v22 = Entry;
  result = (std::string *)(*(uint64_t (**)(HGGPURenderer *, uint64_t, HGGPURenderer *))(*(_QWORD *)this + 368))(this, v22, this);
  if (result)
  {
    if (result)
    {
      v24 = (HGMetalHandler *)result;
      *((_BYTE *)&__p[0].__r_.__value_.__s + 23) = 4;
      strcpy((char *)__p, "copy");
      HGMetalHandler::SetDebugLabel(result, __p);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p[0].__r_.__value_.__l.__data_);
      if (a7)
      {
        HGMetalHandler::EnableBlending((uint64_t)v24);
        HGMetalHandler::SetBlendingInfo(v24, a5);
        HGMetalHandler::SetBlendingColor((__n128 *)v24, a6);
      }
      HGMetalHandler::BindBuffer(v24, a2);
      HGMetalHandler::BindTexture((HGMetalTexture ***)v24, 0, (HGBitmap *)a4);
      *(_QWORD *)&v26.var0 = v8;
      *(_QWORD *)&v26.var2 = v7;
      HGMetalHandler::InitTextureUnit(v24, v26, 0);
      (*(void (**)(HGMetalHandler *, _QWORD, _QWORD))(*(_QWORD *)v24 + 72))(v24, 0, 0);
      (*(void (**)(HGMetalHandler *, _QWORD, _QWORD))(*(_QWORD *)v24 + 48))(v24, 0, 0);
      HGHandler::TexCoord(v24, 0, 0, 0, 0);
      if (!(*(unsigned int (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)this + 128))(this, 46))
        (*(void (**)(HGMetalHandler *))(*(_QWORD *)v24 + 168))(v24);
      (*(void (**)(HGMetalHandler *))(*(_QWORD *)v24 + 40))(v24);
      (*(void (**)(HGMetalHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v24 + 192))(v24, v8, v7, 1);
      return (std::string *)(*(uint64_t (**)(HGGPURenderer *, HGMetalHandler *))(*(_QWORD *)this + 392))(this, v24);
    }
  }
  return result;
}

void sub_1B2A4CB28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGGPURenderer::Rect(HGGPURenderer *this, HGRect a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  const char *v6;
  char *v7;
  const char *v8;
  char *v9;
  HGRect v10;

  v2 = *(_QWORD *)&a2.var2;
  v3 = *(_QWORD *)&a2.var0;
  result = HGRenderer::RenderCheckPoint(this);
  if (!(_DWORD)result)
  {
    HGLogger::warning((HGLogger *)"HGGPURenderer::Rect() needs a HGHandler!\n", v6, v7);
    *(_QWORD *)&v10.var0 = v3;
    *(_QWORD *)&v10.var2 = v2;
    return HGGPURenderer::Clear(this, v10, v8, v9);
  }
  return result;
}

uint64_t HGGPURenderer::PageInit(HGGPURenderer *this, HGNode *a2, HGRect a3, HGRect *a4, int a5)
{
  HGRect *v5;
  uint64_t v7;
  unint64_t v8;
  int *p_var2;
  uint64_t v10;
  _BOOL4 IsMergedWithInput;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  int NodeRenderAPI;
  uint64_t v21;
  int v22;
  _BOOL4 v23;
  BOOL v25;
  HGGPURenderer *v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  _BOOL4 v30;
  _BYTE *v31;
  int v32;
  _BOOL4 v33;
  BOOL v34;
  unsigned int v35;
  BOOL v36;
  char v37;
  unsigned int v38;
  uint64_t v40;
  unsigned int v41;
  uint64_t v43;
  int v44;
  int OutputFormat;
  HGRect v51;

  if (*((_QWORD *)a2 + 10))
  {
    v5 = a4;
    v7 = 0;
    v8 = 0;
    p_var2 = &a4[*((_DWORD *)a2 + 71) + a5].var2;
    do
    {
      v10 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * v8);
      if (!v10 || !*(_QWORD *)(v10 + 16))
        goto LABEL_4;
      IsMergedWithInput = HGNode::IsMergedWithInput(a2, v8);
      v12 = (*(uint64_t (**)(HGNode *, HGGPURenderer *, unint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 400))(a2, this, v8, *(_QWORD *)&a3.var0, *(_QWORD *)&a3.var2);
      v14 = HGRectIntersection(v12, v13, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v10 + 16) + 144) + 152), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v10 + 16) + 144) + 160));
      v16 = v14;
      v17 = v15;
      if (IsMergedWithInput)
      {
        *(_QWORD *)&v51.var0 = v14;
        *(_QWORD *)&v51.var2 = v15;
        if (HGGPURenderer::PageInit(this, *(HGNode **)(*((_QWORD *)a2 + 37) + v7), v51, v5, *(_DWORD *)(*((_QWORD *)a2 + 37) + v7 + 40) + a5))return 0xFFFFFFFFLL;
        goto LABEL_4;
      }
      *((_QWORD *)p_var2 - 1) = v14;
      *(_QWORD *)p_var2 = v15;
      v18 = HIDWORD(v15);
      v19 = HIDWORD(v14);
      OutputFormat = HGRenderer::GetOutputFormat(this, *(HGNode **)(*(_QWORD *)(v10 + 16) + 144));
      NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI(this, *(HGNode **)(*(_QWORD *)(v10 + 16) + 144));
      v21 = *(_QWORD *)(*(_QWORD *)(v10 + 16) + 144);
      v22 = *(_DWORD *)(v21 + 16) & 0x1000;
      v23 = NodeRenderAPI == 1;
      if (NodeRenderAPI == 1 || v22 == 0)
      {
        v33 = NodeRenderAPI == 0;
        if (NodeRenderAPI)
          v25 = v22 == 0;
        else
          v25 = 1;
        if (v25)
        {
LABEL_18:
          v26 = this;
          v27 = v17 - v16;
          v28 = v18 - v19;
          v29 = *((_DWORD *)this + 165);
          if (*(_QWORD *)(v21 + 192))
            goto LABEL_19;
          goto LABEL_26;
        }
      }
      else
      {
        v23 = *(_BYTE *)(v21 + 108) != 0;
        v33 = NodeRenderAPI == 0;
        if (NodeRenderAPI)
          v34 = v22 == 0;
        else
          v34 = 1;
        if (v34)
          goto LABEL_18;
      }
      v33 = *(_BYTE *)(v21 + 107) != 0;
      v26 = this;
      v27 = v17 - v16;
      v28 = v18 - v19;
      v29 = *((_DWORD *)this + 165);
      if (*(_QWORD *)(v21 + 192))
      {
LABEL_19:
        v30 = 1;
        v31 = *(_BYTE **)(*(_QWORD *)(v10 + 16) + 144);
        if (v31[105])
          goto LABEL_20;
        goto LABEL_57;
      }
LABEL_26:
      if (*((_BYTE *)v26 + 1281))
      {
        if (v23)
        {
          v35 = *(_DWORD *)(PCICCTransferFunctionLUT::getLUTEnd(*((PCICCTransferFunctionLUT **)v26 + 139)) + 48);
          v36 = v35 >= v27 && v35 >= v28;
          v37 = !v36;
          if (!v36 || !v33)
          {
            if ((v37 & 1) != 0)
              goto LABEL_51;
            goto LABEL_53;
          }
        }
        else if (!v33)
        {
          goto LABEL_53;
        }
        v40 = *((_QWORD *)this + 184);
        if (!v40)
          goto LABEL_51;
        v41 = HGTextureManager::maxTextureSizeGL(v40, OutputFormat);
        if (v41 < v27 || v41 < v28)
          goto LABEL_51;
      }
      else
      {
        v38 = *(_DWORD *)(PCICCTransferFunctionLUT::getLUTEnd(*((PCICCTransferFunctionLUT **)v26 + 139)) + 48);
        if (v38 < v27 || v38 < v28)
        {
LABEL_51:
          v30 = 0;
          v31 = *(_BYTE **)(*(_QWORD *)(v10 + 16) + 144);
          if (v31[105])
            goto LABEL_20;
          goto LABEL_57;
        }
      }
LABEL_53:
      if (OutputFormat <= 41)
        v43 = s_HGFormatInfos[8 * OutputFormat + 3];
      else
        v43 = 0;
      v30 = v28 * (unint64_t)v27 * v43 < *((_QWORD *)this + 157);
      v31 = *(_BYTE **)(*(_QWORD *)(v10 + 16) + 144);
      if (v31[105])
      {
LABEL_20:
        v32 = 1;
        goto LABEL_58;
      }
LABEL_57:
      v32 = (*(uint64_t (**)(_BYTE *, HGGPURenderer *))(*(_QWORD *)v31 + 304))(v31, this);
LABEL_58:
      if (v28 * v27 < 2 * v29 * v29)
        v44 = 1;
      else
        v44 = v32;
      v5 = a4;
      if ((v44 & v30) != 1)
        return 0xFFFFFFFFLL;
LABEL_4:
      ++v8;
      p_var2 += 4;
      v7 += 56;
    }
    while (v8 != 8);
  }
  return 0;
}

uint64_t HGGPURenderer::GetMaxTileArea(HGGPURenderer *this)
{
  return (2 * *((_DWORD *)this + 165) * *((_DWORD *)this + 165));
}

char *HGGPURenderer::ProcessNodeInternal(HGRenderer *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char *Buffer, int a7, int a8, unsigned __int8 a9)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  __n128 *v23;
  uint64_t v24;
  int NodeRenderAPI;
  HGBuffer *v26;
  HGBuffer *v27;
  uint64_t v29;
  uint64_t v30;
  HGRect v31;
  __n128 *v32;
  uint64_t v33;
  char v34;
  uint64_t (**v35)();
  HGRect v36;
  HGRect v37;
  HGRect v38;
  HGRect v39;
  HGRect v40;

  v17 = HGRectIntersection(a3, a4, *(_QWORD *)(a2 + 152), *(_QWORD *)(a2 + 160));
  if (!a8 || (v19 = a3, v20 = a4, !*((_BYTE *)a1 + 808)))
  {
    v19 = v17;
    v20 = v18;
  }
  *(_QWORD *)&v31.var2 = 0;
  v32 = 0;
  v33 = 0;
  v29 = v18;
  v30 = v17;
  HGGPURenderer::BuildPagesList((uint64_t)a1, (char **)&v31.var2, (HGNode *)a2, v17, v18);
  if ((__n128 *)((char *)v32 - *(_QWORD *)&v31.var2) == (__n128 *)144)
  {
    if (a7)
    {
      *(_QWORD *)&v37.var0 = a3;
      *(_QWORD *)&v37.var2 = a4;
      HGRenderer::SetTilesROI(a1, (HGNode *)a2, v37);
      v35 = off_1E65243E8;
      HGTraversal::RecursiveTraversal<(HGTraversal::NodeInput)1,(HGTraversal::InputOrder)0>::operator()((uint64_t)&v34, a1, a2, (void (***)(uint64_t, HGRenderer *, uint64_t))&v35);
      Buffer = (char *)HGGPURenderer::ProcessOnePage((int64x2_t *)a1, a2, a3, a4, *(uint64_t *)&v31.var2, a5, Buffer, a8, a9);
      v35 = off_1E6524460;
      HGTraversal::RecursiveTraversal<(HGTraversal::NodeInput)1,(HGTraversal::InputOrder)0>::operator()((uint64_t)&v34, a1, a2, (void (***)(uint64_t, HGRenderer *, uint64_t))&v35);
    }
    else
    {
      Buffer = (char *)HGGPURenderer::ProcessOnePage((int64x2_t *)a1, a2, a3, a4, *(uint64_t *)&v31.var2, a5, Buffer, a8, a9);
    }
    goto LABEL_26;
  }
  v35 = (uint64_t (**)())PageSortPredicate;
  v21 = 126 - 2 * __clz(0x8E38E38E38E38E39 * (((uint64_t)v32 - *(_QWORD *)&v31.var2) >> 4));
  if (v32 == *(__n128 **)&v31.var2)
    v22 = 0;
  else
    v22 = v21;
  std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*,false>(*(unint64_t *)&v31.var2, v32, (uint64_t (**)(__n128 *, __n128 *))&v35, v22, 1);
  if (!Buffer)
  {
    NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI(a1, (HGNode *)a2);
    *(_QWORD *)&v36.var0 = v19;
    *(_QWORD *)&v36.var2 = v20;
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)a1, v36, a5, NodeRenderAPI, (*(_DWORD *)(a2 + 16) >> 12) & 1, a9 & ~a8, *((_BYTE *)a1 + 1336) == 0);
    v24 = *(_QWORD *)&v31.var2;
    v23 = v32;
    if (*(__n128 **)&v31.var2 == v32)
      goto LABEL_23;
LABEL_15:
    if ((a7 & 1) != 0)
    {
      do
      {
        HGRenderer::SetTilesROI(a1, (HGNode *)a2, *(HGRect *)v24);
        v35 = off_1E65243E8;
        HGTraversal::RecursiveTraversal<(HGTraversal::NodeInput)1,(HGTraversal::InputOrder)0>::operator()((uint64_t)&v34, a1, a2, (void (***)(uint64_t, HGRenderer *, uint64_t))&v35);
        v27 = HGGPURenderer::ProcessOnePage((int64x2_t *)a1, a2, *(_QWORD *)v24, *(_QWORD *)(v24 + 8), v24, a5, Buffer, 0, a9);
        v35 = off_1E6524460;
        HGTraversal::RecursiveTraversal<(HGTraversal::NodeInput)1,(HGTraversal::InputOrder)0>::operator()((uint64_t)&v34, a1, a2, (void (***)(uint64_t, HGRenderer *, uint64_t))&v35);
        if (v27)
          (*(void (**)(HGBuffer *))(*(_QWORD *)v27 + 24))(v27);
        v24 += 144;
      }
      while ((__n128 *)v24 != v23);
    }
    else
    {
      do
      {
        v26 = HGGPURenderer::ProcessOnePage((int64x2_t *)a1, a2, *(_QWORD *)v24, *(_QWORD *)(v24 + 8), v24, a5, Buffer, 0, a9);
        if (v26)
          (*(void (**)(HGBuffer *))(*(_QWORD *)v26 + 24))(v26);
        v24 += 144;
      }
      while ((__n128 *)v24 != v23);
    }
    goto LABEL_23;
  }
  (*(void (**)(char *))(*(_QWORD *)Buffer + 16))(Buffer);
  v24 = *(_QWORD *)&v31.var2;
  v23 = v32;
  if (*(__n128 **)&v31.var2 != v32)
    goto LABEL_15;
LABEL_23:
  if (v32 == *(__n128 **)&v31.var2)
  {
    *(_QWORD *)&v39.var0 = a3;
    *(_QWORD *)&v39.var2 = a4;
    HGGPURenderer::ClearBuffer((uint64_t)a1, (HGBuffer *)Buffer, v39);
  }
  else
  {
    *(_QWORD *)&v38.var2 = v29;
    *(_QWORD *)&v38.var0 = v30;
    *(_QWORD *)&v40.var0 = a3;
    *(_QWORD *)&v40.var2 = a4;
    HGGPURenderer::ClearBuffer((_BOOL8)a1, (HGBuffer *)Buffer, v38, v40);
  }
LABEL_26:
  if (*(_QWORD *)&v31.var2)
  {
    v32 = *(__n128 **)&v31.var2;
    operator delete(*(void **)&v31.var2);
  }
  return Buffer;
}

void sub_1B2A4D248(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL PageSortPredicate(_DWORD *a1, _DWORD *a2)
{
  int v2;
  int v3;

  v2 = a1[1];
  v3 = a2[1];
  if (v2 < v3)
    return 1;
  if (v2 == v3)
    return *a1 < *a2;
  return 0;
}

void HGGPURenderer::BuildPagesList(uint64_t a1, char **a2, HGNode *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  unint64_t v6;
  HGNode *v7;
  char **v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  HGRect v15;
  char *v16;
  char *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  unint64_t v23;
  unsigned int v24;
  uint64_t *v25;
  uint64_t **v26;
  uint64_t **v27;
  unint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t *v31;
  __int128 v32;
  char *v33;
  __int128 v34;
  __int128 v35;
  HGRect v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  HGRect v65;

  while (1)
  {
    v5 = a5;
    v6 = a4;
    v7 = a3;
    v8 = a2;
    v9 = a1;
    *(_QWORD *)&v56 = a4;
    *((_QWORD *)&v56 + 1) = a5;
    v57 = HGRectNull;
    v58 = HGRectNull;
    v59 = HGRectNull;
    v60 = HGRectNull;
    v61 = HGRectNull;
    v62 = HGRectNull;
    v63 = HGRectNull;
    v64 = HGRectNull;
    if (HGRectIsNull(a4, a5)
      || (*(_QWORD *)&v65.var0 = v6,
          *(_QWORD *)&v65.var2 = v5,
          !HGGPURenderer::PageInit((HGGPURenderer *)v9, v7, v65, (HGRect *)&v57, 0)))
    {
      v11 = v8[1];
      v10 = (unint64_t)v8[2];
      if ((unint64_t)v11 >= v10)
      {
        v17 = *v8;
        v18 = 0x8E38E38E38E38E39 * ((v11 - *v8) >> 4);
        v19 = v18 + 1;
        if (v18 + 1 > 0x1C71C71C71C71C7)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v20 = 0x8E38E38E38E38E39 * ((uint64_t)(v10 - (_QWORD)v17) >> 4);
        if (2 * v20 > v19)
          v19 = 2 * v20;
        if (v20 >= 0xE38E38E38E38E3)
          v21 = 0x1C71C71C71C71C7;
        else
          v21 = v19;
        if (v21)
        {
          if (v21 > 0x1C71C71C71C71C7)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v22 = (char *)operator new(144 * v21);
        }
        else
        {
          v22 = 0;
        }
        v32 = v63;
        v33 = &v22[144 * v18];
        *((_OWORD *)v33 + 6) = v62;
        *((_OWORD *)v33 + 7) = v32;
        *((_OWORD *)v33 + 8) = v64;
        v34 = v59;
        *((_OWORD *)v33 + 2) = v58;
        *((_OWORD *)v33 + 3) = v34;
        v35 = v61;
        *((_OWORD *)v33 + 4) = v60;
        *((_OWORD *)v33 + 5) = v35;
        v36 = (HGRect)v57;
        v16 = v33 + 144;
        *(_OWORD *)v33 = v56;
        *((HGRect *)v33 + 1) = v36;
        if (v11 != v17)
        {
          do
          {
            *((_OWORD *)v33 - 9) = *((_OWORD *)v11 - 9);
            v37 = *((_OWORD *)v11 - 8);
            v38 = *((_OWORD *)v11 - 7);
            v39 = *((_OWORD *)v11 - 5);
            *((_OWORD *)v33 - 6) = *((_OWORD *)v11 - 6);
            *((_OWORD *)v33 - 5) = v39;
            *((_OWORD *)v33 - 8) = v37;
            *((_OWORD *)v33 - 7) = v38;
            v40 = *((_OWORD *)v11 - 4);
            v41 = *((_OWORD *)v11 - 3);
            v42 = *((_OWORD *)v11 - 1);
            *((_OWORD *)v33 - 2) = *((_OWORD *)v11 - 2);
            *((_OWORD *)v33 - 1) = v42;
            *((_OWORD *)v33 - 4) = v40;
            *((_OWORD *)v33 - 3) = v41;
            v33 -= 144;
            v11 -= 144;
          }
          while (v11 != v17);
          v11 = *v8;
        }
        *v8 = v33;
        v8[1] = v16;
        v8[2] = &v22[144 * v21];
        if (v11)
          operator delete(v11);
      }
      else
      {
        v12 = v63;
        *((_OWORD *)v11 + 6) = v62;
        *((_OWORD *)v11 + 7) = v12;
        *((_OWORD *)v11 + 8) = v64;
        v13 = v59;
        *((_OWORD *)v11 + 2) = v58;
        *((_OWORD *)v11 + 3) = v13;
        v14 = v61;
        *((_OWORD *)v11 + 4) = v60;
        *((_OWORD *)v11 + 5) = v14;
        v15 = (HGRect)v57;
        *(_OWORD *)v11 = v56;
        *((HGRect *)v11 + 1) = v15;
        v16 = v11 + 144;
      }
      v8[1] = v16;
      return;
    }
    v23 = HIDWORD(v6);
    v24 = HIDWORD(v5) - HIDWORD(v6);
    if ((v5 - v6) <= 1 && v24 < 2)
      break;
    if ((int)v5 - (int)v6 <= v24)
    {
      v50 = HGRectMake4i(v6, HIDWORD(v6), v5, (HIDWORD(v5) + HIDWORD(v6)) >> 1);
      v52 = v51;
      v53 = HGRectMake4i(v6, (HIDWORD(v5) + HIDWORD(v6)) >> 1, v5, HIDWORD(v5));
      v55 = v54;
      HGGPURenderer::BuildPagesList(v9, v8, v7, v50, v52);
      a1 = v9;
      a2 = v8;
      a3 = v7;
      a4 = v53;
      a5 = v55;
    }
    else
    {
      v43 = ((int)v5 + (int)v6) >> 1;
      v44 = HGRectMake4i(v6, HIDWORD(v6), v43, HIDWORD(v5));
      v46 = v45;
      v47 = HGRectMake4i(v43, v23, v5, HIDWORD(v5));
      v49 = v48;
      HGGPURenderer::BuildPagesList(v9, v8, v7, v44, v46);
      a1 = v9;
      a2 = v8;
      a3 = v7;
      a4 = v47;
      a5 = v49;
    }
  }
  v25 = *(uint64_t **)(v9 + 1448);
  if (v25)
  {
    while (1)
    {
      while (1)
      {
        v27 = (uint64_t **)v25;
        v28 = v25[4];
        if (v28 <= (unint64_t)v7)
          break;
        v25 = *v27;
        v26 = v27;
        if (!*v27)
          goto LABEL_23;
      }
      if (v28 >= (unint64_t)v7)
        break;
      v25 = v27[1];
      if (!v25)
      {
        v26 = v27 + 1;
        goto LABEL_23;
      }
    }
  }
  else
  {
    v26 = (uint64_t **)(v9 + 1448);
    v27 = (uint64_t **)(v9 + 1448);
LABEL_23:
    v29 = (uint64_t *)operator new(0x28uLL);
    v29[4] = (uint64_t)v7;
    *v29 = 0;
    v29[1] = 0;
    v29[2] = (uint64_t)v27;
    *v26 = v29;
    v30 = **(_QWORD **)(v9 + 1440);
    if (v30)
    {
      *(_QWORD *)(v9 + 1440) = v30;
      v31 = *v26;
    }
    else
    {
      v31 = v29;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v9 + 1448), v31);
    ++*(_QWORD *)(v9 + 1456);
  }
}

HGBuffer *HGGPURenderer::ProcessOnePage(int64x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, char *a7, int a8, unsigned __int8 a9)
{
  uint64_t v16;
  uint64_t v17;
  _BOOL4 IsNull;
  HGBitmap *v19;
  int v20;
  char *v21;
  _BOOL4 v22;
  _BOOL4 v23;
  HGBuffer *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  _BOOL8 v30;
  uint64_t v31;
  HGRect v32;
  unsigned __int8 v33;
  int NodeRenderAPI;
  char *Buffer;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int32 v40;
  HGEdgePolicy *EdgePolicy;
  HGRect v44;
  _QWORD v45[4];
  unsigned int v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  uint64_t v60;
  unsigned __int8 v61;
  HGRect v62;

  HGGPURenderer::PurgePostDeleteEvents(a1);
  if (a7)
    (*(void (**)(char *))(*(_QWORD *)a7 + 16))(a7);
  v16 = *(_QWORD *)a5;
  v17 = *(_QWORD *)(a5 + 8);
  *(_QWORD *)&v44.var0 = a3;
  *(_QWORD *)&v44.var2 = a4;
  if (!a8 || !a1[50].i8[8])
  {
    a4 = *(_QWORD *)(a5 + 8);
    a3 = *(_QWORD *)a5;
  }
  IsNull = HGRectIsNull(v16, v17);
  if (IsNull | HGRenderer::RenderCheckPoint((HGRenderer *)a1))
  {
    if ((a8 & 1) == 0)
      goto LABEL_18;
    goto LABEL_17;
  }
  v19 = *(HGBitmap **)(a2 + 192);
  if (v19 || (v19 = *(HGBitmap **)(a2 + 248)) != 0)
  {
    (*(void (**)(HGBitmap *))(*(_QWORD *)v19 + 16))(v19);
    if ((a8 & 1) == 0)
      goto LABEL_43;
  }
  else
  {
    v33 = a9;
    if (((a8 ^ 1) & 1) == 0 && !a7 && a1[50].i8[8])
    {
      NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI((HGGPURenderer *)a1, (HGNode *)a2);
      Buffer = HGGPURenderer::CreateBuffer((uint64_t)a1, v44, a6, NodeRenderAPI, (*(_DWORD *)(a2 + 16) >> 12) & 1, (a8 ^ 1u) & a9, a1[83].i8[8] == 0);
      v33 = a9;
      a7 = Buffer;
    }
    v36 = *(_OWORD *)(a5 + 96);
    v51 = *(_OWORD *)(a5 + 80);
    v52 = v36;
    v37 = *(_OWORD *)(a5 + 128);
    v53 = *(_OWORD *)(a5 + 112);
    v54 = v37;
    v38 = *(_OWORD *)(a5 + 32);
    v47 = *(_OWORD *)(a5 + 16);
    v48 = v38;
    v39 = *(_OWORD *)(a5 + 64);
    v49 = *(_OWORD *)(a5 + 48);
    v59 = a2;
    v60 = 0;
    v50 = v39;
    v55 = 0u;
    v56 = 0u;
    v57 = 0u;
    v58 = 0u;
    v45[0] = a1;
    v45[1] = a7;
    v46 = a6;
    v45[2] = v16;
    v45[3] = v17;
    v61 = v33;
    v19 = HGGPURenderer::RenderPage((HGBitmap **)a1, (HGNode *)a2, (HGPage *)v45);
    v40 = a1[43].i32[2];
    if (*(_QWORD *)(a2 + 64))
      ++v40;
    a1[43].i32[2] = v40;
    a1[77].i32[3] = 1;
    if ((a8 & 1) == 0)
      goto LABEL_43;
  }
  if (!v19)
  {
LABEL_17:
    if (!a7)
    {
      if (a1[50].i8[8])
      {
        v25 = (void *)a1[84].i64[1];
        if (!v25)
        {
          v25 = HGObject::operator new(0x80uLL);
          v26 = HGRectMake4i(0, 0, 0, 0);
          HGBitmap::HGBitmap(v25, v26, v27, 24);
          a1[84].i64[1] = (uint64_t)v25;
        }
        (*(void (**)(void *))(*(_QWORD *)v25 + 16))(v25);
        v19 = (HGBitmap *)a1[84].i64[1];
        v28 = a1[79].i32[1];
        v29 = (*(_DWORD *)(a2 + 16) >> 12) & 1;
        v30 = a1[83].i8[8] == 0;
        v31 = (uint64_t)a1;
        v32 = v44;
        goto LABEL_42;
      }
      v21 = (char *)HGObject::operator new(0x80uLL);
      HGBitmap::HGBitmap(v21, 0, 0, a6);
      a7 = 0;
LABEL_19:
      v22 = a7 != 0;
      v23 = v21 != 0;
      v24 = (HGBuffer *)a7;
      a7 = v21;
      if (!v21)
        goto LABEL_51;
LABEL_20:
      (*(void (**)(char *))(*(_QWORD *)a7 + 16))(a7);
      v19 = (HGBitmap *)a7;
      if (!v23)
        return (HGBuffer *)a7;
      goto LABEL_49;
    }
LABEL_18:
    v21 = 0;
    goto LABEL_19;
  }
  if (HGRectIsEqual(*(_QWORD *)((char *)v19 + 20), *(_QWORD *)((char *)v19 + 28), a3, a4))
  {
    v20 = *((_DWORD *)v19 + 3);
    if ((v20 & 1) == 0)
    {
      if ((~v20 & 0x120) == 0 || (*(_DWORD *)(a2 + 16) & 0x1000) != 0)
        goto LABEL_37;
LABEL_35:
      if (*((_DWORD *)v19 + 4) == a6)
      {
        EdgePolicy = (HGEdgePolicy *)HGBitmap::GetEdgePolicy(v19);
        if (HGEdgePolicy::isDefault(EdgePolicy))
          goto LABEL_43;
      }
      goto LABEL_37;
    }
    if ((~v20 & 0x120) != 0)
      goto LABEL_35;
  }
LABEL_37:
  if (v19 == (HGBitmap *)a7)
  {
    (*(void (**)(HGBitmap *))(*(_QWORD *)v19 + 24))(v19);
LABEL_41:
    v28 = a1[79].i32[1];
    v29 = (*(_DWORD *)(a2 + 16) >> 12) & 1;
    v30 = a1[83].i8[8] == 0;
    v31 = (uint64_t)a1;
    *(_QWORD *)&v32.var0 = a3;
    *(_QWORD *)&v32.var2 = a4;
LABEL_42:
    a7 = HGGPURenderer::CreateBuffer(v31, v32, a6, v28, v29, 0, v30);
    goto LABEL_43;
  }
  if (!a7)
    goto LABEL_41;
LABEL_43:
  v22 = a7 != 0;
  v23 = v19 != 0;
  if (a7 && v19)
  {
    if (v19 != (HGBitmap *)a7)
      HGGPURenderer::CopyBitmapIntoBuffer((HGGPURenderer *)a1, (HGBuffer *)a7, v44, v19);
    if (!HGRectIsEqual(v16, v17, *(uint64_t *)&v44.var0, *(uint64_t *)&v44.var2))
    {
      *(_QWORD *)&v62.var0 = v16;
      *(_QWORD *)&v62.var2 = v17;
      HGGPURenderer::ClearBuffer((_BOOL8)a1, (HGBuffer *)a7, v62, v44);
    }
LABEL_49:
    (*(void (**)(HGBitmap *))(*(_QWORD *)v19 + 24))(v19);
    return (HGBuffer *)a7;
  }
  v24 = (HGBuffer *)a7;
  a7 = (char *)v19;
  if (v19)
    goto LABEL_20;
LABEL_51:
  if (v22)
  {
    HGGPURenderer::ClearBuffer((uint64_t)a1, v24, v44);
    return v24;
  }
  else
  {
    a1[77].i32[3] = 1;
    return HGGPURenderer::LoadNullBuffer((HGGPURenderer *)a1);
  }
}

void sub_1B2A4DAC8(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A4DADC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGBitmap *HGGPURenderer::RenderPage(HGBitmap **this, HGNode *a2, HGPage *a3)
{
  int NodeRenderAPI;
  int v7;
  unsigned __int8 v8;
  const char *v9;
  uint64_t v10;
  const char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  const char *v19;
  size_t v20;
  _QWORD *v21;
  const char *v22;
  char *v23;
  char v24;
  void *p_p;
  int v26;
  uint64_t v27;
  uint64_t v28;
  HGBitmap *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  HGBitmap *v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  void *__p;
  char v40;
  _QWORD v41[2];
  _QWORD v42[11];
  char v43;
  uint64_t v44;

  NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI((HGGPURenderer *)this, a2);
  v7 = NodeRenderAPI;
  v8 = atomic_load(HGLogger::_enabled);
  if ((v8 & 1) != 0)
  {
    if (NodeRenderAPI == 1)
      v9 = "Metal";
    else
      v9 = "GLSL ";
    v10 = (*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 48))(a2);
    HGLogger::log((HGLogger *)"metal", (const char *)3, (HGLogger *)"node render API (%p) : %s  (%s)\n", v11, v12, a2, v9, v10);
  }
  HGGPURenderer::ValidateCurrentContext((const char *)this);
  v14 = *((unsigned int *)a3 + 7);
  v13 = *((unsigned int *)a3 + 8);
  v15 = *((unsigned int *)a3 + 4);
  v16 = *((unsigned int *)a3 + 5);
  v17 = *((unsigned int *)a3 + 6);
  if (v7 == 1)
  {
    v27 = *((_QWORD *)a3 + 1);
    if (v27 && (*(_BYTE *)(v27 + 12) & 0x10) != 0)
      *((_QWORD *)a3 + 1) = 0;
    v28 = (*(uint64_t (**)(HGNode *, HGPage *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 464))(a2, a3, v15, v16, v17, v14);
    goto LABEL_32;
  }
  if (!v7)
  {
    if (*((int *)this + 319) < 1)
      goto LABEL_27;
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v41);
    v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v42, (uint64_t)"OpenGL rendering : Using ", 25);
    v19 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 48))(a2);
    v20 = strlen(v19);
    v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)v19, v20);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"::RenderPage().", 15);
    std::stringbuf::str();
    v24 = v40;
    p_p = __p;
    if (v40 >= 0)
      p_p = &__p;
    v26 = *((_DWORD *)this + 319);
    if (v26 == 2)
    {
      HGLogger::error((HGLogger *)"%s", v22, v23, p_p);
    }
    else
    {
      if (v26 != 1)
      {
LABEL_22:
        if (v24 < 0)
          operator delete(__p);
        v41[0] = *MEMORY[0x1E0DE4F50];
        v32 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
        *(_QWORD *)((char *)v41 + *(_QWORD *)(v41[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
        v42[0] = v32;
        v42[1] = MEMORY[0x1E0DE4FB8] + 16;
        if (v43 < 0)
          operator delete((void *)v42[9]);
        std::streambuf::~streambuf();
        std::iostream::~basic_iostream();
        MEMORY[0x1B5E290BC](&v44);
LABEL_27:
        if (*((_BYTE *)this + 1281))
        {
          v33 = *((_QWORD *)a3 + 1);
          if (v33 && (*(_BYTE *)(v33 + 12) & 0x20) != 0)
            *((_QWORD *)a3 + 1) = 0;
          v28 = (*(uint64_t (**)(HGNode *, HGPage *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 456))(a2, a3, v15, v16, v17, v14);
LABEL_32:
          v34 = (HGBitmap *)v28;
          goto LABEL_37;
        }
        v29 = this[169];
        if (!v29)
        {
          v29 = (HGBitmap *)HGObject::operator new(0x80uLL);
          v35 = HGRectMake4i(0, 0, 0, 0);
          HGBitmap::HGBitmap(v29, v35, v36, 24);
          goto LABEL_35;
        }
        goto LABEL_36;
      }
      HGLogger::warning((HGLogger *)"%s", v22, v23, p_p);
    }
    v24 = v40;
    goto LABEL_22;
  }
  v29 = this[169];
  if (!v29)
  {
    v29 = (HGBitmap *)HGObject::operator new(0x80uLL);
    v30 = HGRectMake4i(0, 0, 0, 0);
    HGBitmap::HGBitmap(v29, v30, v31, 24);
LABEL_35:
    this[169] = v29;
  }
LABEL_36:
  (*(void (**)(HGBitmap *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v29 + 16))(v29, v13, v15, v16, v17, v14);
  v34 = this[169];
LABEL_37:
  HGGPURenderer::ValidateCurrentContext((const char *)this);
  if (v34)
  {
    HGRenderer::DotLogNodeBufferFormat((uint64_t)this, a2, v34);
    if (v7 == 1)
      v37 = "purple";
    else
      v37 = "blue";
    HGDotGraph::fontColor((uint64_t)(this + 105), (unint64_t)a2, v37);
    HGRenderer::DotLogBufferOutput((uint64_t *)this, (HGBitmap *)a2, v34);
  }
  return v34;
}

void sub_1B2A4DE98(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A4DEAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a18 < 0)
  {
    operator delete(__p);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a19);
    _Unwind_Resume(a1);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a19);
  _Unwind_Resume(a1);
}

void HGGPURenderer::EnqueueTextureDelete(HGGPURenderer *this, const unsigned int *a2, HGBitmap *a3, char *a4, int a5)
{
  HGGLContext *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  HGTextureManager *v16;
  const unsigned int *v17;
  char *v18;
  const char *v19;
  PCSharedCount v20;
  _BYTE v21[16];

  v10 = (HGGLContext *)*((_QWORD *)this + *((unsigned int *)this + 290) + 143);
  if (v10)
    HGGLContext::context((uint64_t *)&v20, v10);
  else
    HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v20, 0);
  HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v21, &v20.var0);
  PCSharedCount::PCSharedCount(&v20);
  glFlush();
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v21);
  if ((_DWORD)a4)
  {
    (*(void (**)(HGBitmap *))(*(_QWORD *)a3 + 16))(a3);
    v11 = *((_QWORD *)this + 174);
    v12 = *((_QWORD *)this + 173);
    if (v11 == v12)
      v13 = 0;
    else
      v13 = ((v11 - v12) << 6) - 1;
    v14 = *((_QWORD *)this + 177);
    v15 = v14 + *((_QWORD *)this + 176);
    if (v13 == v15)
    {
      std::deque<HGBitmap *>::__add_back_capacity((uint64_t)this + 1376);
      v14 = *((_QWORD *)this + 177);
      v12 = *((_QWORD *)this + 173);
      v15 = *((_QWORD *)this + 176) + v14;
    }
    *(_QWORD *)(*(_QWORD *)(v12 + ((v15 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v15 & 0x1FF)) = a3;
    *((_QWORD *)this + 177) = v14 + 1;
    v16 = (HGTextureManager *)*((_QWORD *)this + 184);
    v17 = a2;
    v18 = a4;
    v19 = (const char *)a3;
    if (!a5)
      goto LABEL_11;
  }
  else
  {
    v16 = (HGTextureManager *)*((_QWORD *)this + 184);
    v17 = a2;
    v18 = a4;
    v19 = 0;
    if (!a5)
    {
LABEL_11:
      HGTextureManager::dismissTexture(v16, v17, v18, v19);
      return;
    }
  }
  HGTextureManager::deleteTexture(v16, v17, v18, v19);
}

void sub_1B2A4E054(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A4E068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::ReleaseBitmap(int64x2_t *this, HGBitmap *a2, char *a3)
{
  const char *v6;
  char *v7;
  int v8;
  _QWORD *v9;
  uint64_t result;
  _DWORD *v11;

  HGGPURenderer::PurgePostDeleteEvents(this);
  if (!a2)
    goto LABEL_9;
  v8 = *((_DWORD *)a2 + 3);
  if ((v8 & 0x30) == 0)
    goto LABEL_9;
  if ((v8 & 0x100) != 0)
  {
    if (*((int64x2_t **)a2 + 16) == this)
    {
      v11 = (_DWORD *)((char *)a2 + 156);
      if (*((_DWORD *)a2 + 39))
      {
        if (*((_DWORD *)a2 + 40))
        {
          HGGPURenderer::EnqueueTextureDelete((HGGPURenderer *)this, (const unsigned int *)a2 + 40, a2, a3, 1);
          *((_DWORD *)a2 + 40) = 0;
        }
        else if (*((_BYTE *)a2 + 181))
        {
          HGGPURenderer::EnqueueTextureDelete((HGGPURenderer *)this, (const unsigned int *)a2 + 39, a2, a3, 0);
          result = 0;
          *v11 = 0;
          return result;
        }
        result = 0;
        *v11 = 0;
        return result;
      }
      return 0;
    }
LABEL_9:
    HGLogger::warning((HGLogger *)"ReleaseBitmap() : buffer is tied to another renderer", v6, v7);
    return 0xFFFFFFFFLL;
  }
  if (*((int64x2_t **)a2 + 16) != this)
    goto LABEL_9;
  v9 = (_QWORD *)((char *)a2 + 168);
  if (!*((_QWORD *)a2 + 21))
    return 0;
  if (*((_QWORD *)a2 + 22))
  {
    HGGPURenderer::EnqueueTextureDelete((HGGPURenderer *)this, (const unsigned int *)a2 + 44, a2, a3, 1);
    *((_QWORD *)a2 + 22) = 0;
    result = 0;
    *v9 = 0;
  }
  else
  {
    if (!*((_QWORD *)a2 + 17))
    {
      if (*((_BYTE *)a2 + 192))
        HGGPURenderer::EnqueueTextureDelete((HGGPURenderer *)this, (const unsigned int *)a2 + 42, a2, a3, 0);
    }
    result = 0;
    *v9 = 0;
  }
  return result;
}

uint64_t HGGPURenderer::ReleaseTexture(int64x2_t *this, HGGLTexture *a2, char *a3)
{
  uint64_t v6;
  char *v7;
  char *v8;
  int64_t v9;

  v6 = *((_QWORD *)a2 + 17);
  if (v6)
  {
    v7 = (char *)this[76].i64[0];
    v8 = (char *)this[76].i64[1];
    if (v7 != v8)
    {
      while (*(_QWORD *)v7 != v6)
      {
        v7 += 8;
        if (v7 == v8)
        {
          v7 = (char *)this[76].i64[1];
          break;
        }
      }
    }
    v9 = v8 - (v7 + 8);
    if (v8 != v7 + 8)
      memmove(v7, v7 + 8, v8 - (v7 + 8));
    this[76].i64[1] = (uint64_t)&v7[v9];
    this[77].i32[2] = -1;
  }
  return HGGPURenderer::ReleaseBitmap(this, (HGBitmap *)a2, a3);
}

uint64_t HGGPURenderer::TestShader(uint64_t a1, uint64_t a2)
{
  return HGGLShaderCache::TestShader(*(HGGLShaderCache **)(a1 + 1288), a2, 0);
}

uint64_t HGGPURenderer::TestShader(uint64_t a1, HGString *a2, _OWORD *a3, uint64_t *a4)
{
  return HGGLShaderCache::TestShader(*(HGGLShaderCache **)(a1 + 1288), a2, a3, a4);
}

uint64_t HGGPURenderer::TestShader(uint64_t a1, int *a2, _OWORD *a3, uint64_t *a4)
{
  return HGGLShaderCache::TestShader(*(HGGLShaderCache **)(a1 + 1288), a2, a3, a4);
}

void HGGPURenderer::GetString(uint64_t a1@<X1>, HGString *a2@<X8>)
{
  if (a1)
    HGString::HGString(a2, (const HGString *)(a1 + 64));
  else
    HGString::HGString(a2, 0, 1, 0xFFu);
}

uint64_t HGGPURenderer::BindProgram(uint64_t a1)
{
  uint64_t v1;
  unsigned int *v2;
  unsigned int *v3;
  uint64_t v4;
  HGLimits *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *Function;
  const char *v9;
  char *v10;
  uint64_t *FunctionWithSource;
  double v12;
  double v13;
  uint32x4_t v14;
  const char *v15;
  size_t v16;
  double v17;
  double v18;
  uint32x4_t v19;
  size_t v20;
  void **p_dst;
  uint64_t v22;
  const char *v23;
  char *v24;
  unsigned __int8 v25;
  double v26;
  double v27;
  uint32x4_t v28;
  unsigned __int8 v29;
  const char *v30;
  char *v31;
  unsigned __int8 v32;
  const char *v33;
  char *v34;
  unsigned __int8 v35;
  double v36;
  double v37;
  uint32x4_t v38;
  unsigned __int8 v39;
  string_t v40;
  const char *v41;
  char *v42;
  unsigned __int8 v43;
  string_t v44;
  const char *v45;
  char *v46;
  unsigned __int8 v47;
  _QWORD *v48;
  uint64_t v49;
  uint64_t v50;
  void **v51;
  int64_t v52;
  void **v53;
  int64_t size;
  std::string *p_shaders;
  uint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  string_t v60;
  char v61;
  void **v62;
  std::string::size_type v63;
  std::string *v64;
  __int128 v65;
  void **v66;
  std::string::size_type v67;
  std::string *v68;
  __int128 v69;
  double v70;
  uint32x4_t v71;
  const std::string::value_type *v72;
  std::string *v73;
  void *v74;
  char v75;
  char v76;
  unsigned __int8 v77;
  double v78;
  double v79;
  uint32x4_t v80;
  unsigned __int8 v81;
  string_t v82;
  const char *v83;
  char *v84;
  unsigned __int8 v86;
  double v87;
  double v88;
  uint32x4_t v89;
  unsigned __int8 v90;
  string_t v91;
  const char *v92;
  char *v93;
  const char *v94;
  char *v95;
  unsigned __int8 v96;
  unsigned __int8 v97;
  const char *v98;
  unsigned __int8 v99;
  GLuint v100;
  const char *v101;
  char *v102;
  unsigned __int8 v103;
  const char *v104;
  char *v105;
  uint64_t v106;
  unsigned __int8 v107;
  unsigned __int8 v108;
  void *v110[2];
  unsigned __int8 v111;
  void *v112[2];
  unsigned __int8 v113;
  std::string v114;
  std::string v115;
  std::string v116;
  void *__p;
  __int128 v118;
  void **__dst;
  size_t v120;
  int64_t v121;
  std::string source[682];
  _QWORD v123[2];
  std::string shaders;
  uint64_t v125;

  v1 = MEMORY[0x1E0C80A78](a1);
  v125 = *MEMORY[0x1E0C80C00];
  if (!v2)
    return 0;
  v3 = v2;
  v4 = v1;
  v5 = (HGLimits *)(v2 + 4);
  if (HGLimits::ismetal((HGLimits *)(v2 + 4)))
  {
    v6 = *v3 ^ (2 * (v3[2] ^ v3[1] ^ v3[3]));
    v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 1112) + 24) + 168);
    *((_BYTE *)&source[0].__r_.__value_.__s + 23) = 12;
    strcpy((char *)source, "fragmentFunc");
    *((_BYTE *)&shaders.__r_.__value_.__s + 23) = 10;
    strcpy((char *)&shaders, "vertexFunc");
    Function = HGMetalFunctionCache::getFunction(v7, source, v6);
    FunctionWithSource = HGMetalFunctionCache::getFunction(v7, &shaders, v6);
    if (Function)
      goto LABEL_72;
    v15 = HGString::c_str((string_t *)v3 + 8, v12, v13, v14);
    v16 = strlen(v15);
    if (v16 >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v20 = v16;
    if (v16 >= 0x17)
    {
      v49 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v16 | 7) != 0x17)
        v49 = v16 | 7;
      v50 = v49 + 1;
      p_dst = (void **)operator new(v49 + 1);
      v120 = v20;
      v121 = v50 | 0x8000000000000000;
      __dst = p_dst;
    }
    else
    {
      HIBYTE(v121) = v16;
      p_dst = (void **)&__dst;
      if (!v16)
      {
LABEL_26:
        *((_BYTE *)p_dst + v20) = 0;
        v51 = (void **)&__dst;
        if (v121 >= 0)
        {
          v52 = HIBYTE(v121);
        }
        else
        {
          v51 = __dst;
          v52 = v120;
        }
        v53 = (void **)((char *)v51 + v52);
        size = HIBYTE(shaders.__r_.__value_.__r.__words[2]);
        p_shaders = &shaders;
        if ((shaders.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        {
          size = shaders.__r_.__value_.__l.__size_;
          p_shaders = (std::string *)shaders.__r_.__value_.__r.__words[0];
        }
        if (size)
        {
          if (v52 < size || (v56 = (uint64_t)v53 - size + 1, (void **)v56 == v51))
          {
LABEL_43:
            __p = 0;
            v118 = 0uLL;
            goto LABEL_44;
          }
          while (*(unsigned __int8 *)v51 != p_shaders->__r_.__value_.__s.__data_[0])
          {
LABEL_35:
            v51 = (void **)((char *)v51 + 1);
            if (v51 == (void **)v56)
              goto LABEL_43;
          }
          v57 = 1;
          while (size != v57)
          {
            v58 = *((unsigned __int8 *)v51 + v57);
            v59 = p_shaders->__r_.__value_.__s.__data_[v57++];
            if (v58 != v59)
              goto LABEL_35;
          }
        }
        __p = 0;
        v118 = 0uLL;
        if (v51 != v53)
        {
          v60 = HGString::c_str((string_t *)v3 + 8, v17, v18, v19);
          MEMORY[0x1B5E28D80](&__p, v60);
          v61 = 0;
          goto LABEL_64;
        }
LABEL_44:
        HGMetalUtils::stringForMetalHeader((uint64_t)&v114);
        HGMetalUtils::stringForMetalVertexOutputStruct((HGMetalUtils *)*((unsigned __int16 *)v3 + 26), (v3[12] & 0x200) != 0, (uint64_t)v112);
        if ((v113 & 0x80u) == 0)
          v62 = v112;
        else
          v62 = (void **)v112[0];
        if ((v113 & 0x80u) == 0)
          v63 = v113;
        else
          v63 = (std::string::size_type)v112[1];
        v64 = std::string::append(&v114, (const std::string::value_type *)v62, v63);
        v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
        v115.__r_.__value_.__r.__words[2] = v64->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v115.__r_.__value_.__l.__data_ = v65;
        v64->__r_.__value_.__l.__size_ = 0;
        v64->__r_.__value_.__r.__words[2] = 0;
        v64->__r_.__value_.__r.__words[0] = 0;
        HGMetalUtils::stringForMetalFragmentOutputStruct((HGMetalUtils *)*((unsigned __int8 *)v3 + 58), *((_BYTE *)v3 + 57) != 0, (uint64_t)v110);
        if ((v111 & 0x80u) == 0)
          v66 = v110;
        else
          v66 = (void **)v110[0];
        if ((v111 & 0x80u) == 0)
          v67 = v111;
        else
          v67 = (std::string::size_type)v110[1];
        v68 = std::string::append(&v115, (const std::string::value_type *)v66, v67);
        v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
        v116.__r_.__value_.__r.__words[2] = v68->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v116.__r_.__value_.__l.__data_ = v69;
        v68->__r_.__value_.__l.__size_ = 0;
        v68->__r_.__value_.__r.__words[2] = 0;
        v68->__r_.__value_.__r.__words[0] = 0;
        v72 = HGString::c_str((string_t *)v3 + 8, *(double *)&v69, v70, v71);
        v73 = std::string::append(&v116, v72);
        v74 = (void *)v73->__r_.__value_.__r.__words[0];
        v123[0] = v73->__r_.__value_.__l.__size_;
        *(_QWORD *)((char *)v123 + 7) = *(std::string::size_type *)((char *)&v73->__r_.__value_.__r.__words[1] + 7);
        v75 = HIBYTE(v73->__r_.__value_.__r.__words[2]);
        v73->__r_.__value_.__l.__size_ = 0;
        v73->__r_.__value_.__r.__words[2] = 0;
        v73->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v118) < 0)
          operator delete(__p);
        __p = v74;
        *(_QWORD *)&v118 = v123[0];
        *(_QWORD *)((char *)&v118 + 7) = *(_QWORD *)((char *)v123 + 7);
        HIBYTE(v118) = v75;
        if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v116.__r_.__value_.__l.__data_);
          if (((char)v111 & 0x80000000) == 0)
          {
LABEL_60:
            if ((SHIBYTE(v115.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_61;
            goto LABEL_94;
          }
        }
        else if (((char)v111 & 0x80000000) == 0)
        {
          goto LABEL_60;
        }
        operator delete(v110[0]);
        if ((SHIBYTE(v115.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_61:
          if (((char)v113 & 0x80000000) == 0)
            goto LABEL_62;
          goto LABEL_95;
        }
LABEL_94:
        operator delete(v115.__r_.__value_.__l.__data_);
        if (((char)v113 & 0x80000000) == 0)
        {
LABEL_62:
          if ((SHIBYTE(v114.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_63:
            v61 = 1;
LABEL_64:
            Function = HGMetalFunctionCache::getFunctionWithSource(v7, source, v6, (uint64_t *)&__p);
            if (FunctionWithSource)
              v76 = 1;
            else
              v76 = v61;
            if ((v76 & 1) == 0)
              FunctionWithSource = HGMetalFunctionCache::getFunctionWithSource(v7, &shaders, v6, (uint64_t *)&__dst);
            if (SHIBYTE(v118) < 0)
            {
              operator delete(__p);
              if ((SHIBYTE(v121) & 0x80000000) == 0)
              {
LABEL_71:
                if (Function)
                  goto LABEL_72;
                goto LABEL_83;
              }
            }
            else if ((SHIBYTE(v121) & 0x80000000) == 0)
            {
              goto LABEL_71;
            }
            operator delete(__dst);
            if (Function)
            {
LABEL_72:
              v77 = atomic_load(HGLogger::_enabled);
              if ((v77 & 1) != 0)
                HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"bind metal {\n", v9, v10);
              HGLogger::indent(1);
              v81 = atomic_load(HGLogger::_enabled);
              if ((v81 & 1) != 0)
              {
                v82 = HGString::c_str((string_t *)v3 + 8, v78, v79, v80);
                HGLogger::log((HGLogger *)"gpu", (const char *)3, (HGLogger *)"\n%s\n", v83, v84, v82);
              }
              v48 = *(_QWORD **)(v4 + 1312);
              (*(void (**)(_QWORD *, uint64_t))(*v48 + 16))(v48, v4);
              HGMetalHandler::AddMTLFunction(v48, Function);
              HGMetalHandler::SetAttributeFlags((uint64_t)v48, *((_WORD *)v3 + 24));
              HGMetalHandler::SetTextureCoords((uint64_t)v48, *((unsigned __int16 *)v3 + 26));
              if (FunctionWithSource)
                HGMetalHandler::AddMTLFunction(v48, FunctionWithSource);
              if ((SHIBYTE(shaders.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_79;
              goto LABEL_90;
            }
LABEL_83:
            v86 = atomic_load(HGLogger::_enabled);
            if ((v86 & 1) != 0)
              HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"bind metal shader failed(%d) {\n", v9, v10, 4294967237);
            HGLogger::indent(1);
            v90 = atomic_load(HGLogger::_enabled);
            if ((v90 & 1) != 0)
            {
              v91 = HGString::c_str((string_t *)v3 + 8, v87, v88, v89);
              HGLogger::log((HGLogger *)"gpu", (const char *)3, (HGLogger *)"%s\n", v92, v93, v91);
            }
            HGLogger::indent(0xFFFFFFFFLL);
            v96 = atomic_load(HGLogger::_enabled);
            if ((v96 & 1) != 0)
              HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"}\n", v94, v95);
            HGGLShaderCache::DisableEntry(*(_QWORD *)(v4 + 1288), (uint64_t)v3, -59);
            v48 = 0;
            if ((SHIBYTE(shaders.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_79:
              if ((SHIBYTE(source[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                return (uint64_t)v48;
LABEL_91:
              operator delete(source[0].__r_.__value_.__l.__data_);
              return (uint64_t)v48;
            }
LABEL_90:
            operator delete(shaders.__r_.__value_.__l.__data_);
            if ((SHIBYTE(source[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              return (uint64_t)v48;
            goto LABEL_91;
          }
LABEL_96:
          operator delete(v114.__r_.__value_.__l.__data_);
          goto LABEL_63;
        }
LABEL_95:
        operator delete(v112[0]);
        if ((SHIBYTE(v114.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_63;
        goto LABEL_96;
      }
    }
    memmove(p_dst, v15, v20);
    goto LABEL_26;
  }
  v22 = HGGLShaderCache::Enable(*(HGGLShaderCache **)(v4 + 1288), (uint64_t)v3, 0, 0);
  if (!(_DWORD)v22)
  {
    if (HGLimits::isarb(v5))
    {
      v35 = atomic_load(HGLogger::_enabled);
      if ((v35 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"bind arb {\n", v33, v34);
      HGLogger::indent(1);
      v39 = atomic_load(HGLogger::_enabled);
      if ((v39 & 1) != 0)
      {
        v40 = HGString::c_str((string_t *)v3 + 8, v36, v37, v38);
        HGLogger::log((HGLogger *)"gpu", (const char *)3, (HGLogger *)"\n%s\n", v41, v42, v40);
      }
    }
    else if (*(_DWORD *)v5 >> 9 >= 0x303u)
    {
      v97 = atomic_load(HGLogger::_enabled);
      if ((v97 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"bind glsl {\n", v33, v34);
      HGLogger::indent(1);
      v99 = atomic_load(HGLogger::_enabled);
      if ((v99 & 1) != 0 && (int)HGLogger::getLevel((HGLogger *)"gpu", v98) >= 1)
      {
        v100 = *(_DWORD *)(*((_QWORD *)v3 + 15) + 8);
        LODWORD(__dst) = 0;
        glGetAttachedShaders(v100, 3, (GLsizei *)&__dst, (GLuint *)&shaders);
        v103 = atomic_load(HGLogger::_enabled);
        if ((v103 & 1) != 0)
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"num attached shaders : %d\n", v101, v102, __dst);
        HGLogger::indent(1);
        if ((int)__dst >= 1)
        {
          v106 = 0;
          do
          {
            v107 = atomic_load(HGLogger::_enabled);
            if ((v107 & 1) != 0)
              HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"shader #%d : %d\n", v104, v105, v106, *((unsigned int *)&shaders.__r_.__value_.__l.__data_ + v106));
            LODWORD(__p) = 0;
            glGetShaderSource(*((_DWORD *)&shaders.__r_.__value_.__l.__data_ + v106), 0x4000, (GLsizei *)&__p, (GLchar *)source);
            v108 = atomic_load(HGLogger::_enabled);
            if ((v108 & 1) != 0)
              HGLogger::log((HGLogger *)"gpu", (const char *)3, (HGLogger *)"\n%s\n", v104, v105, source);
            ++v106;
          }
          while (v106 < (int)__dst);
        }
        HGLogger::indent(0xFFFFFFFFLL);
      }
    }
    if (HGLimits::isarb(v5))
      return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 1296) + 16))(*(_QWORD *)(v4 + 1296), v4);
    if (*(_DWORD *)v5 >> 9 < 0x303u)
      return 0;
    return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v4 + 1304) + 208))(*(_QWORD *)(v4 + 1304), v4, *(unsigned int *)(*((_QWORD *)v3 + 15) + 8));
  }
  v25 = atomic_load(HGLogger::_enabled);
  if ((v25 & 1) != 0)
  {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"failed(%d) {\n", v23, v24, v22);
    HGLogger::indent(1);
    v43 = atomic_load(HGLogger::_enabled);
    if ((v43 & 1) == 0)
    {
LABEL_11:
      HGLogger::indent(0xFFFFFFFFLL);
      v32 = atomic_load(HGLogger::_enabled);
      if ((v32 & 1) == 0)
        return 0;
      goto LABEL_20;
    }
  }
  else
  {
    HGLogger::indent(1);
    v29 = atomic_load(HGLogger::_enabled);
    if ((v29 & 1) == 0)
      goto LABEL_11;
  }
  v44 = HGString::c_str((string_t *)v3 + 8, v26, v27, v28);
  HGLogger::log((HGLogger *)"gpu", (const char *)3, (HGLogger *)"%s\n", v45, v46, v44);
  HGLogger::indent(0xFFFFFFFFLL);
  v47 = atomic_load(HGLogger::_enabled);
  if ((v47 & 1) != 0)
LABEL_20:
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"}\n", v30, v31);
  return 0;
}

void sub_1B2A4EC0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,void *__p,uint64_t a51,int a52,__int16 a53,char a54,char a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  uint64_t v61;

  if (a49 < 0)
  {
    operator delete(a44);
    if (a55 < 0)
    {
LABEL_3:
      operator delete(__p);
      if (*(char *)(v61 - 105) < 0)
      {
LABEL_7:
        operator delete(*(void **)(v61 - 128));
        if ((a61 & 0x80000000) == 0)
          goto LABEL_11;
LABEL_10:
        operator delete(a56);
LABEL_11:
        _Unwind_Resume(a1);
      }
LABEL_9:
      if ((a61 & 0x80000000) == 0)
        goto LABEL_11;
      goto LABEL_10;
    }
  }
  else if (a55 < 0)
  {
    goto LABEL_3;
  }
  if (*(char *)(v61 - 105) < 0)
    goto LABEL_7;
  goto LABEL_9;
}

_QWORD *HGGPURenderer::BindProgramDescriptor(uint64_t a1, HGProgramDescriptor **a2)
{
  _QWORD *v4;
  const char *v5;
  char *v6;
  unint64_t Hash;
  uint64_t v8;
  const char *FragmentFunctionName;
  size_t v10;
  std::string::size_type v11;
  std::string *p_dst;
  uint64_t v13;
  uint64_t v14;
  uint64_t *Function;
  const char *MetalLibPath;
  size_t v17;
  std::string::size_type v18;
  std::string *p_p;
  uint64_t v20;
  uint64_t v21;
  std::string::size_type size;
  char *v23;
  const char *v24;
  char *v25;
  const char *VertexFunctionName;
  size_t v27;
  std::string::size_type v28;
  std::string *v29;
  uint64_t v30;
  uint64_t v31;
  std::string::size_type v32;
  uint64_t *FunctionWithSource;
  const char *v34;
  size_t v35;
  std::string::size_type v36;
  _BYTE *p_str;
  unsigned __int8 v38;
  const char *v39;
  char *v40;
  unsigned __int8 v41;
  std::string *v42;
  const char *v43;
  char *v44;
  unsigned __int8 v45;
  uint64_t v46;
  uint64_t v47;
  std::string::size_type v48;
  uint64_t *FunctionWithLibrary;
  std::string::size_type v50;
  char *v51;
  uint64_t *v52;
  const char *v53;
  char *v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t *v57;
  const char *v58;
  char *v59;
  std::string::size_type v60;
  void *v61;
  unsigned __int8 v62;
  void *v63;
  const char *v64;
  char *v65;
  unsigned __int8 v66;
  const char *v67;
  char *v68;
  std::string::size_type v69;
  unsigned __int8 v70;
  std::string *v71;
  unsigned __int8 v73;
  _QWORD *v74;
  std::string v75;
  std::string __p;
  unsigned int v77;
  unsigned int v78;
  std::string __str;
  std::string __dst;
  std::string v81;

  v4 = *(_QWORD **)(a1 + 1312);
  (*(void (**)(_QWORD *, uint64_t))(*v4 + 16))(v4, a1);
  Hash = HGProgramDescriptor::GetHash(*a2, v5, v6);
  memset(&v81, 0, sizeof(v81));
  v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 1112) + 24) + 168);
  FragmentFunctionName = HGProgramDescriptor::GetFragmentFunctionName(*a2);
  v10 = strlen(FragmentFunctionName);
  if (v10 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v11 = v10;
  if (v10 >= 0x17)
  {
    v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17)
      v13 = v10 | 7;
    v14 = v13 + 1;
    p_dst = (std::string *)operator new(v13 + 1);
    __dst.__r_.__value_.__l.__size_ = v11;
    __dst.__r_.__value_.__r.__words[2] = v14 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_8;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v10;
  p_dst = &__dst;
  if (v10)
LABEL_8:
    memmove(p_dst, FragmentFunctionName, v11);
  p_dst->__r_.__value_.__s.__data_[v11] = 0;
  Function = HGMetalFunctionCache::getFunction(v8, &__dst, Hash);
  if (Function)
    goto LABEL_25;
  MetalLibPath = (const char *)HGProgramDescriptor::GetMetalLibPath(*a2);
  v17 = strlen(MetalLibPath);
  if (v17 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v18 = v17;
  if (v17 >= 0x17)
  {
    v20 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v17 | 7) != 0x17)
      v20 = v17 | 7;
    v21 = v20 + 1;
    p_p = (std::string *)operator new(v20 + 1);
    __p.__r_.__value_.__l.__size_ = v18;
    __p.__r_.__value_.__r.__words[2] = v21 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
    goto LABEL_17;
  }
  *((_BYTE *)&__p.__r_.__value_.__s + 23) = v17;
  p_p = &__p;
  if (v17)
LABEL_17:
    memmove(p_p, MetalLibPath, v18);
  p_p->__r_.__value_.__s.__data_[v18] = 0;
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (size && (HGProgramDescriptor::IsConcatenated(*a2) & 1) == 0)
  {
    Function = HGMetalFunctionCache::getFunctionWithLibrary(v8, &__dst, (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_42;
    goto LABEL_24;
  }
  memset(&__str, 0, sizeof(__str));
  HGProgramDescriptor::EncodeShaderDeclarations((std::string *)*a2, &__str);
  HGProgramDescriptor::EncodeShaderProgram((uint64_t)*a2, &__str, v23);
  HGProgramDescriptor::EncodeShaderBufferStruct((std::string *)*a2, &__str);
  HGProgramDescriptor::EncodeShaderFunction((uint64_t)*a2, &__str);
  Function = HGMetalFunctionCache::getFunctionWithSource(v8, &__dst, Hash, (uint64_t *)&__str);
  std::string::operator=(&v81, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__str.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_42;
LABEL_24:
    if (Function)
      goto LABEL_25;
LABEL_43:
    v38 = atomic_load(HGLogger::_enabled);
    if ((v38 & 1) != 0)
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"bind metal shader failed {\n", v24, v25);
    HGLogger::indent(1);
    v41 = atomic_load(HGLogger::_enabled);
    if ((v41 & 1) != 0)
    {
      v42 = &v81;
      if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v42 = (std::string *)v81.__r_.__value_.__r.__words[0];
      HGLogger::log((HGLogger *)"gpu", (const char *)3, (HGLogger *)"%s\n", v39, v40, v42);
    }
    HGLogger::indent(0xFFFFFFFFLL);
    v45 = atomic_load(HGLogger::_enabled);
    if ((v45 & 1) != 0)
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"}\n", v43, v44);
    (*(void (**)(_QWORD *, uint64_t))(*v4 + 16))(v4, a1);
    v4 = 0;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_125;
    goto LABEL_117;
  }
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_24;
LABEL_42:
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!Function)
    goto LABEL_43;
LABEL_25:
  HGMetalHandler::AddMTLFunction(v4, Function);
  HGProgramDescriptor::GetSignature(*a2, (uint64_t)&__p);
  HGMetalHandler::SetAttributeFlags((uint64_t)v4, v77);
  HGMetalHandler::SetTextureCoords((uint64_t)v4, (unsigned __int16)v78);
  VertexFunctionName = (const char *)HGProgramDescriptor::GetVertexFunctionName(*a2);
  v27 = strlen(VertexFunctionName);
  if (v27 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v28 = v27;
  if (v27 >= 0x17)
  {
    v30 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v27 | 7) != 0x17)
      v30 = v27 | 7;
    v31 = v30 + 1;
    v29 = (std::string *)operator new(v30 + 1);
    __p.__r_.__value_.__l.__size_ = v28;
    __p.__r_.__value_.__r.__words[2] = v31 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
    goto LABEL_32;
  }
  *((_BYTE *)&__p.__r_.__value_.__s + 23) = v27;
  v29 = &__p;
  if (v27)
LABEL_32:
    memmove(v29, VertexFunctionName, v28);
  v29->__r_.__value_.__s.__data_[v28] = 0;
  v32 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v32 = __p.__r_.__value_.__l.__size_;
  if (v32)
  {
    FunctionWithSource = HGMetalFunctionCache::getFunction(v8, &__p, Hash);
    if (FunctionWithSource)
      goto LABEL_74;
    v34 = (const char *)HGProgramDescriptor::GetMetalLibPath(*a2);
    v35 = strlen(v34);
    if (v35 > 0x7FFFFFFFFFFFFFF7)
      std::string::__throw_length_error[abi:ne180100]();
    v36 = v35;
    if (v35 >= 0x17)
    {
      v46 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v35 | 7) != 0x17)
        v46 = v35 | 7;
      v47 = v46 + 1;
      p_str = operator new(v46 + 1);
      __str.__r_.__value_.__l.__size_ = v36;
      __str.__r_.__value_.__r.__words[2] = v47 | 0x8000000000000000;
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)p_str;
    }
    else
    {
      *((_BYTE *)&__str.__r_.__value_.__s + 23) = v35;
      p_str = &__str;
      if (!v35)
      {
LABEL_57:
        p_str[v36] = 0;
        v48 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v48 = __str.__r_.__value_.__l.__size_;
        if (v48)
        {
          FunctionWithLibrary = HGMetalFunctionCache::getFunctionWithLibrary(v8, &__p, (uint64_t)&__str);
        }
        else
        {
          v50 = HIBYTE(v81.__r_.__value_.__r.__words[2]);
          if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v50 = v81.__r_.__value_.__l.__size_;
          if (!v50)
          {
LABEL_68:
            memset(&v75, 0, sizeof(v75));
            HGProgramDescriptor::EncodeShaderDeclarations((std::string *)*a2, &v75);
            HGProgramDescriptor::EncodeShaderProgram((uint64_t)*a2, &v75, v51);
            HGProgramDescriptor::EncodeShaderBufferStruct((std::string *)*a2, &v75);
            HGProgramDescriptor::EncodeShaderFunction((uint64_t)*a2, &v75);
            FunctionWithSource = HGMetalFunctionCache::getFunctionWithSource(v8, &__p, Hash, (uint64_t *)&v75);
            if (SHIBYTE(v75.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v75.__r_.__value_.__l.__data_);
LABEL_70:
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(__str.__r_.__value_.__l.__data_);
              if (!FunctionWithSource)
                goto LABEL_75;
            }
            else if (!FunctionWithSource)
            {
              goto LABEL_75;
            }
LABEL_74:
            HGMetalHandler::AddMTLFunction(v4, FunctionWithSource);
            goto LABEL_75;
          }
          FunctionWithLibrary = HGMetalFunctionCache::getFunctionWithSource(v8, &__p, Hash, (uint64_t *)&v81);
        }
        FunctionWithSource = FunctionWithLibrary;
        if (FunctionWithLibrary)
          goto LABEL_70;
        goto LABEL_68;
      }
    }
    memmove(p_str, v34, v36);
    goto LABEL_57;
  }
LABEL_75:
  v52 = HGProgramDescriptor::CopyDependencies(*a2);
  v55 = v52;
  if (!v52)
  {
    v62 = atomic_load(HGLogger::_enabled);
    if ((v62 & 1) != 0)
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"bind metal failed due to unexpected error: missing dependency list", v53, v54);
LABEL_123:
    (*(void (**)(_QWORD *, uint64_t))(*v4 + 16))(v4, a1);
    v4 = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_124;
LABEL_116:
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_117;
LABEL_125:
    operator delete(__dst.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v81.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return v4;
LABEL_126:
    operator delete(v81.__r_.__value_.__l.__data_);
    return v4;
  }
  v56 = *v52;
  if (*v52 == v52[1])
  {
    v61 = (void *)*v52;
    if (!v56)
      goto LABEL_103;
LABEL_94:
    v63 = v61;
    if ((void *)v56 == v61)
    {
LABEL_102:
      v55[1] = (uint64_t)v61;
      operator delete(v63);
      goto LABEL_103;
    }
    while (1)
    {
      if (*(char *)(v56 - 1) < 0)
      {
        operator delete(*(void **)(v56 - 24));
        if ((*(char *)(v56 - 25) & 0x80000000) == 0)
          goto LABEL_97;
LABEL_100:
        operator delete(*(void **)(v56 - 48));
        v56 -= 48;
        if ((void *)v56 == v61)
        {
LABEL_101:
          v63 = (void *)*v55;
          goto LABEL_102;
        }
      }
      else
      {
        if (*(char *)(v56 - 25) < 0)
          goto LABEL_100;
LABEL_97:
        v56 -= 48;
        if ((void *)v56 == v61)
          goto LABEL_101;
      }
    }
  }
  do
  {
    v57 = HGMetalFunctionCache::getFunction(v8, (const std::string *)(v56 + 24), Hash);
    if (v57)
      goto LABEL_87;
    if (*(char *)(v56 + 23) < 0)
    {
      if (!*(_QWORD *)(v56 + 8))
      {
LABEL_82:
        v60 = HIBYTE(v81.__r_.__value_.__r.__words[2]);
        if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v60 = v81.__r_.__value_.__l.__size_;
        if (!v60)
        {
LABEL_119:
          v73 = atomic_load(HGLogger::_enabled);
          if ((v73 & 1) != 0)
          {
            v74 = (_QWORD *)(v56 + 24);
            if (*(char *)(v56 + 47) < 0)
              v74 = (_QWORD *)*v74;
            HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"bind metal visible function failed: %s", v58, v59, v74);
          }
          goto LABEL_123;
        }
        v57 = HGMetalFunctionCache::getFunctionWithSource(v8, (std::string *)(v56 + 24), Hash, (uint64_t *)&v81);
        goto LABEL_86;
      }
    }
    else if (!*(_BYTE *)(v56 + 23))
    {
      goto LABEL_82;
    }
    v57 = HGMetalFunctionCache::getFunctionWithLibrary(v8, (std::string *)(v56 + 24), v56);
LABEL_86:
    if (!v57)
      goto LABEL_119;
LABEL_87:
    HGMetalHandler::AddMTLFunction(v4, v57);
    v56 += 48;
  }
  while (v56 != v55[1]);
  v61 = (void *)*v55;
  if (*v55)
    goto LABEL_94;
LABEL_103:
  MEMORY[0x1B5E29170](v55, 0x20C40960023A9);
  v66 = atomic_load(HGLogger::_enabled);
  if ((v66 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"bind metal success {\n", v64, v65);
  HGLogger::indent(1);
  if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v69 = HIBYTE(v81.__r_.__value_.__r.__words[2]);
  else
    v69 = v81.__r_.__value_.__l.__size_;
  v70 = atomic_load(HGLogger::_enabled);
  if (v69)
  {
    if ((v70 & 1) != 0)
    {
      v71 = &v81;
      if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v71 = (std::string *)v81.__r_.__value_.__r.__words[0];
      HGLogger::log((HGLogger *)"gpu", (const char *)3, (HGLogger *)"\n%s\n", v67, v68, v71);
    }
  }
  else if ((v70 & 1) != 0)
  {
    HGLogger::log((HGLogger *)"gpu", (const char *)3, (HGLogger *)"\n%s\n", v67, v68, "[cached shader]");
  }
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_116;
LABEL_124:
  operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_125;
LABEL_117:
  if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_126;
  return v4;
}

void sub_1B2A4F5BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  uint64_t v36;

  if (a30 < 0)
  {
    operator delete(__p);
    if (a21 < 0)
    {
LABEL_5:
      operator delete(a16);
      if ((a36 & 0x80000000) == 0)
        goto LABEL_6;
      goto LABEL_9;
    }
  }
  else if (a21 < 0)
  {
    goto LABEL_5;
  }
  if ((a36 & 0x80000000) == 0)
  {
LABEL_6:
    if (*(char *)(v36 - 89) < 0)
      goto LABEL_7;
    goto LABEL_10;
  }
LABEL_9:
  operator delete(a31);
  if (*(char *)(v36 - 89) < 0)
  {
LABEL_7:
    operator delete(*(void **)(v36 - 112));
    _Unwind_Resume(a1);
  }
LABEL_10:
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::BindProgram(HGGPURenderer *this, const char *a2, void *a3)
{
  int v5;
  _BYTE v7[48];
  uint64_t v8;

  v8 = 0;
  HGString::HGString((HGString *)v7, a2, 0, 0xFFu);
  v5 = (*(uint64_t (**)(HGGPURenderer *, _BYTE *, _QWORD, uint64_t *))(*(_QWORD *)this + 408))(this, v7, 0, &v8);
  HGString::~HGString((HGString *)v7);
  if (v5)
    return 0;
  else
    return (*(uint64_t (**)(HGGPURenderer *, uint64_t, void *))(*(_QWORD *)this + 368))(this, v8, a3);
}

void sub_1B2A4F74C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::UnBindProgram(HGGPURenderer *this, HGHandler *a2)
{
  const char *v3;
  char *v4;
  unsigned __int8 v5;
  uint64_t result;

  if (a2)
  {
    HGLogger::indent(0xFFFFFFFFLL);
    v5 = atomic_load(HGLogger::_enabled);
    if ((v5 & 1) != 0)
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"}\n", v3, v4);
    return (*(uint64_t (**)(HGHandler *))(*(_QWORD *)a2 + 200))(a2);
  }
  return result;
}

uint64_t HGGPURenderer::GetConcatenationMask(HGGPURenderer *this, HGNode *a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  BOOL v7;
  _BYTE v9[12];
  unsigned int v10;
  HGProgramDescriptor *v11;

  HGNode::GetProgramDescriptor(a2, &v11);
  HGProgramDescriptor::GetSignature(v11, (uint64_t)v9);
  v4 = v10;
  if (v10)
  {
    v5 = 0;
    v6 = v10;
    do
    {
      if ((v4 & 1) != 0)
      {
        if (HGRenderer::IsMergeable(this, a2, v5, 0))
          v6 = v6;
        else
          v6 = v6 & ~(1 << v5);
      }
      ++v5;
      v7 = v4 > 1;
      v4 >>= 1;
    }
    while (v7);
  }
  else
  {
    v6 = 0;
  }
  if (v11)
    (*(void (**)(HGProgramDescriptor *))(*(_QWORD *)v11 + 24))(v11);
  return v6;
}

void sub_1B2A4F888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16)
    (*(void (**)(uint64_t))(*(_QWORD *)a16 + 24))(a16);
  _Unwind_Resume(exception_object);
}

uint64_t HGGPURenderer::GenProgram(HGGLShaderCache **this, HGNode *a2, int a3)
{
  const char *v6;
  const char *Program;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *Entry;
  unsigned __int8 *v11;
  int v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  unint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  _QWORD *v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  int64_t v30;
  uint64_t v31;
  unint64_t v32;
  unsigned __int8 *v33;
  double v34;
  char v36[16];
  char __str[256];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v6 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 48))(a2);
  snprintf(__str, 0x100uLL, "GenProgram(node = %p, %s)", a2, v6);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v36, "concat", 1, __str);
  if ((*((_BYTE *)a2 + 16) & 0x10) == 0)
  {
    if (HGGPURenderer::GetNodeRenderAPI((HGGPURenderer *)this, a2) == 1 || !*((_BYTE *)this + 1281))
    {
      v9 = (*((uint64_t (**)(HGGLShaderCache **, uint64_t))*this + 16))(this, 32);
      (*((void (**)(HGGLShaderCache **, uint64_t, uint64_t))*this + 15))(this, 32, 396048);
      Program = (const char *)HGRenderer::GetProgram((HGRenderer *)this, a2);
      (*((void (**)(HGGLShaderCache **, uint64_t, uint64_t))*this + 15))(this, 32, v9);
    }
    else
    {
      Program = (const char *)HGRenderer::GetProgram((HGRenderer *)this, a2);
    }
    if (!Program || !*Program)
    {
      *((_QWORD *)a2 + 40) = 0;
      if (*((_QWORD *)a2 + 8))
      {
        HGNode::ClearNodeChain(a2);
        HGShaderBinding::reset((HGShaderBinding *)((char *)a2 + 260));
        *((_QWORD *)a2 + 8) = 0;
      }
      v8 = 0xFFFFFFFFLL;
      goto LABEL_69;
    }
    Entry = (unsigned __int8 *)HGGLShaderCache::GetEntry(this[161], Program);
    v11 = (unsigned __int8 *)*((_QWORD *)a2 + 8);
    v12 = Entry != v11;
    if (!*Program || (v13 = HGGLShaderCache::GetEntry(this[161], Program), (v14 = *(_DWORD *)(v13 + 28)) == 0))
    {
      *((_QWORD *)a2 + 40) = Entry;
      if (Entry == v11)
        goto LABEL_62;
      goto LABEL_58;
    }
    v15 = 0;
    v16 = *(unsigned int *)(v13 + 28);
    do
    {
      if ((v14 & 1) != 0)
      {
        if (HGRenderer::IsMergeable((HGRenderer *)this, a2, v15, 0))
          v16 = v16;
        else
          v16 = v16 & ~(1 << v15);
      }
      ++v15;
      v17 = v14 >= 2;
      v14 >>= 1;
    }
    while (v17);
    *((_QWORD *)a2 + 40) = Entry;
    if (!(_DWORD)v16)
      goto LABEL_45;
    HGNode::InitNodeChain(a2, 8uLL);
    if (*((_QWORD *)a2 + 10))
    {
      v18 = 0;
      v19 = 8;
      v20 = (const char *)v16;
      do
      {
        if ((v16 & 1) != 0)
        {
          v24 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * v18);
          if (v24 && (v25 = *(_QWORD *)(v24 + 16)) != 0)
          {
            v26 = *(_QWORD *)(v25 + 144);
            if (*(_QWORD *)(v26 + 192) || *(_QWORD *)(v26 + 248) || HGRect::IsNull((HGRect *)(v26 + 168)))
            {
              v21 = 0;
              v20 = (const char *)(v20 & ~(1 << v18));
              v22 = (_QWORD *)(*((_QWORD *)a2 + 37) + v19);
            }
            else
            {
              if (((*((uint64_t (**)(HGGLShaderCache **, uint64_t, _QWORD))*this + 40))(this, v26, 0) & 0x80000000) != 0
                || (v27 = *(_QWORD *)(v26 + 64)) == 0
                || !HGLimits::issafe((HGLimits *)(v27 + 16)))
              {
                v20 = (const char *)(v20 & ~(1 << v18));
              }
              v22 = (_QWORD *)(v26 + 64);
              v21 = *(_QWORD *)(*((_QWORD *)a2 + 37) + v19);
            }
          }
          else
          {
            v21 = 0;
            v22 = (_QWORD *)(*((_QWORD *)a2 + 37) + 56 * v18 + 8);
          }
          v12 = v12 & 1 | (*v22 != v21);
        }
        ++v18;
        v19 += 56;
        v23 = v16 > 1;
        LODWORD(v16) = (int)v16 >> 1;
      }
      while (v23);
      if (!(_DWORD)v20)
      {
LABEL_45:
        if (!v12)
          goto LABEL_62;
        goto LABEL_58;
      }
    }
    else
    {
      v20 = (const char *)v16;
    }
    if (!v12 || HGGPURenderer::Concatenate((HGRenderer *)this, a2, Entry, v20))
    {
      v28 = (char *)*((_QWORD *)a2 + 37);
      v29 = (char *)*((_QWORD *)a2 + 38);
      v30 = v29 - v28;
      if (v29 != v28)
      {
        v31 = 0;
        v32 = v30 / 56;
        if (v32 <= 1)
          v32 = 1;
        do
        {
          if (*(_QWORD *)v28)
            *(_QWORD *)v28 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * v31) + 16) + 144);
          ++v31;
          v28 += 56;
        }
        while (v32 != v31);
      }
      goto LABEL_66;
    }
    v33 = (unsigned __int8 *)*((_QWORD *)a2 + 8);
    HGNode::ClearNodeChain(a2);
    if (v33 == Entry)
      goto LABEL_62;
LABEL_58:
    if (*((_QWORD *)a2 + 8))
    {
      HGNode::ClearNodeChain(a2);
      v34 = HGShaderBinding::reset((HGShaderBinding *)((char *)a2 + 260));
      if (a3
        && (*((unsigned int (**)(HGGLShaderCache **, unsigned __int8 *, double))*this + 54))(this, Entry, v34))
      {
        Entry = 0;
      }
      goto LABEL_65;
    }
LABEL_62:
    if (!a3)
      goto LABEL_66;
    if ((*((unsigned int (**)(HGGLShaderCache **, unsigned __int8 *))*this + 54))(this, Entry))
      Entry = 0;
LABEL_65:
    *((_QWORD *)a2 + 8) = Entry;
LABEL_66:
    if (*((_QWORD *)a2 + 8))
      v8 = 0;
    else
      v8 = 0xFFFFFFFFLL;
LABEL_69:
    *((_DWORD *)a2 + 4) |= 0x10u;
    goto LABEL_70;
  }
  if (*((_QWORD *)a2 + 8))
    v8 = 0;
  else
    v8 = 0xFFFFFFFFLL;
LABEL_70:
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v36);
  return v8;
}

void sub_1B2A4FD24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A4FD38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A4FD4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A4FD64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A4FD78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A4FD8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::GenProgram2(HGGPURenderer *this, HGNode *a2)
{
  const char *v4;
  _BOOL4 IsComplete;
  _DWORD *v6;
  int ConcatenationMask;
  unint64_t v8;
  unsigned int v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  HGProgramDescriptor *v15;
  HGProgramDescriptor *v17;
  char v18[16];
  char __str[256];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 48))(a2);
  snprintf(__str, 0x100uLL, "GenProgram2(node = %p, %s)", a2, v4);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v18, "concat", 1, __str);
  HGNode::GetProgramDescriptor(a2, &v17);
  if (!v17)
  {
    v6 = (_DWORD *)((char *)a2 + 16);
    if ((*((_BYTE *)a2 + 16) & 0x10) != 0)
    {
      v14 = 0xFFFFFFFFLL;
      goto LABEL_32;
    }
    goto LABEL_18;
  }
  IsComplete = HGProgramDescriptor::IsComplete(v17);
  v6 = (_DWORD *)((char *)a2 + 16);
  if ((*((_BYTE *)a2 + 16) & 0x10) != 0)
  {
    v14 = (IsComplete - 1);
    v15 = v17;
    if (!v17)
      goto LABEL_32;
    goto LABEL_31;
  }
  if (!IsComplete)
  {
LABEL_18:
    *((_QWORD *)a2 + 40) = 0;
    if (*((_QWORD *)a2 + 8))
    {
      HGNode::ClearNodeChain(a2);
      HGShaderBinding::reset((HGShaderBinding *)((char *)a2 + 260));
      *((_QWORD *)a2 + 8) = 0;
    }
    v14 = 0xFFFFFFFFLL;
    *v6 |= 0x10u;
    v15 = v17;
    if (v17)
      goto LABEL_31;
    goto LABEL_32;
  }
  ConcatenationMask = HGGPURenderer::GetConcatenationMask(this, a2);
  if (!ConcatenationMask)
  {
    if (!*((_QWORD *)a2 + 10))
      goto LABEL_30;
    goto LABEL_29;
  }
  HGNode::InitNodeChain(a2, 8uLL);
  if (*((_QWORD *)a2 + 10))
  {
    v8 = 0;
    v9 = ConcatenationMask;
    do
    {
      if ((ConcatenationMask & 1) != 0)
      {
        v11 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * v8);
        if (!v11
          || (v12 = *(_QWORD *)(v11 + 16)) == 0
          || (v13 = *(_QWORD *)(v12 + 144), *(_QWORD *)(v13 + 192))
          || *(_QWORD *)(v13 + 248)
          || HGRect::IsNull((HGRect *)(v13 + 168))
          || ((*(uint64_t (**)(HGGPURenderer *, uint64_t, _QWORD))(*(_QWORD *)this + 320))(this, v13, 0) & 0x80000000) != 0)
        {
          HGProgramDescriptor::SetInput(v17, v8, 1);
          v9 &= ~(1 << v8);
        }
      }
      ++v8;
      v10 = ConcatenationMask >= 2;
      ConcatenationMask >>= 1;
    }
    while (v10);
    if (!v9 || !HGGPURenderer::Concatenate(this, a2, v9))
    {
LABEL_29:
      HGShaderBinding::reset((HGShaderBinding *)((char *)a2 + 260));
      HGNode::ClearNodeChain(a2);
    }
  }
LABEL_30:
  v14 = 0;
  *v6 |= 0x10u;
  v15 = v17;
  if (v17)
LABEL_31:
    (*(void (**)(HGProgramDescriptor *))(*(_QWORD *)v15 + 24))(v15);
LABEL_32:
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v18);
  return v14;
}

void sub_1B2A50004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  if (a4)
    (*(void (**)(uint64_t))(*(_QWORD *)a4 + 24))(a4);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

double HGGPURenderer::GetShaderCompileTime(HGGLShaderCache **this)
{
  return HGGLShaderCache::GetShaderCompileTime(this[161]);
}

float HGGPURenderer::BindProbe(HGGPURenderer *this)
{
  return 8.0;
}

void HGGPURenderer::CreateDepthBufferManagers(HGGPURenderer *this)
{
  char **v2;
  DBM_gl *v3;
  unint64_t v4;
  char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _BYTE *v13;
  DBM_gl **v14;
  char *v15;
  char *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  _OWORD *v21;
  char *v22;
  uint64_t v23;
  __int128 v24;
  DBM_gl *v25;

  if (*((_BYTE *)this + 1281))
  {
    v2 = (char **)((char *)this + 224);
    if (*((_QWORD *)this + 28) == *((_QWORD *)this + 29))
    {
      v3 = (DBM_gl *)operator new();
      DBM_gl::DBM_gl(v3, this);
      *((_BYTE *)v3 + 40) = *((_BYTE *)this + 810);
      v5 = (char *)*((_QWORD *)this + 29);
      v4 = *((_QWORD *)this + 30);
      if ((unint64_t)v5 < v4)
      {
        *(_QWORD *)v5 = v3;
        v6 = (uint64_t)(v5 + 8);
LABEL_26:
        *((_QWORD *)this + 29) = v6;
        return;
      }
      v7 = *v2;
      v8 = v5 - *v2;
      v9 = v8 >> 3;
      v10 = (v8 >> 3) + 1;
      if (v10 >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v11 = v4 - (_QWORD)v7;
      if (v11 >> 2 > v10)
        v10 = v11 >> 2;
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
        v12 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v12 = v10;
      if (v12)
      {
        if (v12 >> 61)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v13 = operator new(8 * v12);
        v14 = (DBM_gl **)&v13[8 * v9];
        v15 = &v13[8 * v12];
        *v14 = v3;
        v6 = (uint64_t)(v14 + 1);
        v16 = (char *)(v5 - v7);
        if (v5 == v7)
          goto LABEL_24;
      }
      else
      {
        v13 = 0;
        v14 = (DBM_gl **)(8 * v9);
        v15 = 0;
        *(_QWORD *)(8 * v9) = v3;
        v6 = 8 * v9 + 8;
        v16 = (char *)(v5 - v7);
        if (v5 == v7)
        {
LABEL_24:
          *((_QWORD *)this + 28) = v14;
          *((_QWORD *)this + 29) = v6;
          *((_QWORD *)this + 30) = v15;
          if (v5)
            operator delete(v5);
          goto LABEL_26;
        }
      }
      v17 = (unint64_t)(v16 - 8);
      if (v17 < 0x58)
        goto LABEL_31;
      if ((unint64_t)(v5 - &v13[v8]) < 0x20)
        goto LABEL_31;
      v18 = (v17 >> 3) + 1;
      v19 = 8 * (v18 & 0x3FFFFFFFFFFFFFFCLL);
      v20 = &v5[-v19];
      v14 = (DBM_gl **)((char *)v14 - v19);
      v21 = &v13[8 * v9 - 16];
      v22 = v5 - 16;
      v23 = v18 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v24 = *(_OWORD *)v22;
        *(v21 - 1) = *((_OWORD *)v22 - 1);
        *v21 = v24;
        v21 -= 2;
        v22 -= 32;
        v23 -= 4;
      }
      while (v23);
      v5 = v20;
      if (v18 != (v18 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_31:
        do
        {
          v25 = (DBM_gl *)*((_QWORD *)v5 - 1);
          v5 -= 8;
          *--v14 = v25;
        }
        while (v5 != v7);
      }
      v5 = *v2;
      goto LABEL_24;
    }
  }
}

void sub_1B2A50248(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C408BC0E8B2);
  _Unwind_Resume(a1);
}

void FBOStrategy::cleanupCache(FBOStrategy *this)
{
  const char *v1;
  char *v2;
  unsigned __int8 v3;
  uint64_t v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  uint64_t *v7;
  unint64_t v8;
  _QWORD **v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  uint64_t v19;
  uint64_t v20;
  GLuint framebuffers;
  _BYTE v22[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v22, "framebuffer", 2, "cleanupCache()");
  v3 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
  {
    qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
    qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
    qword_1ED4DAA00 = 0;
    __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
    __cxa_guard_release(&qword_1ED4DA9E8);
  }
  v4 = qword_1ED4DAA00;
  if ((unint64_t)qword_1ED4DAA00 >= 0x20)
  {
    v5 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E0);
    if ((v5 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E0))
    {
      v19 = operator new();
      *(_QWORD *)v19 = 850045863;
      *(_OWORD *)(v19 + 8) = 0u;
      *(_OWORD *)(v19 + 24) = 0u;
      *(_OWORD *)(v19 + 40) = 0u;
      *(_QWORD *)(v19 + 56) = 0;
      qword_1ED4DA9D8 = v19;
      __cxa_guard_release(&qword_1ED4DA9E0);
    }
    std::mutex::lock((std::mutex *)qword_1ED4DA9D8);
    v6 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
    if ((v6 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
    {
      qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DAA00 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4DA9E8);
    }
    v7 = &qword_1ED4DA9F0;
    v8 = v4;
    do
    {
      v13 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
      if ((v13 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
      {
        qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
        qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
        qword_1ED4DAA00 = 0;
        __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
        __cxa_guard_release(&qword_1ED4DA9E8);
      }
      if (v7 == (uint64_t *)qword_1ED4DA9F8)
        break;
      v12 = (_QWORD *)*v7;
      if (!*(_BYTE *)(*v7 + 32))
      {
        framebuffers = *((_DWORD *)v12 + 7);
        glDeleteFramebuffers(1, &framebuffers);
        v14 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
        if ((v14 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
        {
          qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
          qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
          qword_1ED4DAA00 = 0;
          __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4DA9E8);
        }
        v9 = (_QWORD **)*v7;
        v10 = *(_QWORD *)*v7;
        v11 = *(_QWORD **)(*v7 + 8);
        *(_QWORD *)(v10 + 8) = v11;
        *v9[1] = v10;
        --qword_1ED4DAA00;
        operator delete(v9);
        --v8;
        v12 = (_QWORD *)*v11;
      }
      v7 = v12;
    }
    while (v8 > 0x1F);
    v15 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E0);
    if ((v15 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E0))
    {
      v20 = operator new();
      *(_QWORD *)v20 = 850045863;
      *(_OWORD *)(v20 + 8) = 0u;
      *(_OWORD *)(v20 + 24) = 0u;
      *(_OWORD *)(v20 + 40) = 0u;
      *(_QWORD *)(v20 + 56) = 0;
      qword_1ED4DA9D8 = v20;
      __cxa_guard_release(&qword_1ED4DA9E0);
    }
    std::mutex::unlock((std::mutex *)qword_1ED4DA9D8);
    v16 = atomic_load(HGLogger::_enabled);
    if ((v16 & 1) != 0)
      HGLogger::log((HGLogger *)"framebuffer", (const char *)1, (HGLogger *)"removed %lu entries from cache\n", v1, v2, v4 - v8);
  }
  v17 = atomic_load(HGLogger::_enabled);
  if ((v17 & 1) != 0)
  {
    v18 = atomic_load((unsigned __int8 *)&qword_1ED4DA9E8);
    if ((v18 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DA9E8))
    {
      qword_1ED4DA9F0 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DA9F8 = (uint64_t)&qword_1ED4DA9F0;
      qword_1ED4DAA00 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1ED4DA9F0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4DA9E8);
    }
    HGLogger::log((HGLogger *)"framebuffer", (const char *)2, (HGLogger *)"current size of cache = %lu\n", v1, v2, qword_1ED4DAA00);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v22);
}

void sub_1B2A505FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  __cxa_guard_abort(&qword_1ED4DA9E0);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A50620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A50634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A50648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A5065C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void PBOStrategy::PBOStageSetBuffer::~PBOStageSetBuffer(PBOStrategy::PBOStageSetBuffer *this)
{
  JUMPOUT(0x1B5E29170);
}

void PBOStrategy::PBOStageReadPixels::~PBOStageReadPixels(PBOStrategy::PBOStageReadPixels *this)
{
  JUMPOUT(0x1B5E29170);
}

void PBOStrategy::PBOStageMapBuffer::~PBOStageMapBuffer(PBOStrategy::PBOStageMapBuffer *this)
{
  JUMPOUT(0x1B5E29170);
}

void PBOStrategy::PBOStageStartCopy::~PBOStageStartCopy(PBOStrategy::PBOStageStartCopy *this)
{
  JUMPOUT(0x1B5E29170);
}

void PBOStrategy::PBOStageFinishCopy::~PBOStageFinishCopy(PBOStrategy::PBOStageFinishCopy *this)
{
  JUMPOUT(0x1B5E29170);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **,false>(uint64_t result, char *a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t *v9;
  unint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t *v48;
  char *v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t *v53;
  unint64_t *v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t *v57;
  BOOL v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t *v61;
  unint64_t *v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t *v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t *v74;
  unint64_t *v75;
  unint64_t *v76;
  unint64_t v77;
  unint64_t *v78;
  unint64_t *v79;
  unint64_t **v80;
  char *v81;
  BOOL v83;
  uint64_t v84;
  unint64_t *v85;
  unint64_t *v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;

  v9 = (unint64_t *)result;
LABEL_2:
  v10 = v9;
  while (2)
  {
    v9 = v10;
    v11 = a2 - (char *)v10;
    v12 = (a2 - (char *)v10) >> 3;
    switch(v12)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v69 = *((_QWORD *)a2 - 1);
        v70 = *v10;
        if (v69 < *v10)
        {
          *v10 = v69;
          *((_QWORD *)a2 - 1) = v70;
        }
        return result;
      case 3uLL:
        v71 = *v10;
        v72 = v10[1];
        v73 = *((_QWORD *)a2 - 1);
        if (v72 >= *v10)
        {
          if (v73 < v72)
          {
            v10[1] = v73;
            *((_QWORD *)a2 - 1) = v72;
            v91 = *v10;
            v90 = v10[1];
            if (v90 < *v10)
            {
              *v10 = v90;
              v10[1] = v91;
            }
          }
        }
        else
        {
          if (v73 >= v72)
          {
            *v10 = v72;
            v10[1] = v71;
            v98 = *((_QWORD *)a2 - 1);
            if (v98 >= v71)
              return result;
            v10[1] = v98;
          }
          else
          {
            *v10 = v73;
          }
          *((_QWORD *)a2 - 1) = v71;
        }
        return result;
      case 4uLL:
        v74 = v10 + 1;
        v75 = (unint64_t *)v10[1];
        v76 = v10 + 2;
        v77 = v10[2];
        v78 = (unint64_t *)*v10;
        if ((unint64_t)v75 >= *v10)
        {
          if (v77 >= (unint64_t)v75)
          {
LABEL_144:
            v75 = (unint64_t *)v77;
            v92 = *((_QWORD *)a2 - 1);
            if (v92 >= (unint64_t)v75)
              return result;
LABEL_145:
            *v76 = v92;
            *((_QWORD *)a2 - 1) = v75;
            v95 = *v76;
            v96 = *v74;
            if (v95 < v96)
            {
              v10[1] = v95;
              v10[2] = v96;
              v97 = *v10;
              if (v95 < *v10)
              {
                *v10 = v95;
                v10[1] = v97;
              }
            }
            return result;
          }
          *v74 = v77;
          *v76 = (unint64_t)v75;
          v79 = v10;
          v80 = (unint64_t **)(v10 + 1);
          result = (uint64_t)v75;
          if (v77 >= (unint64_t)v78)
          {
LABEL_136:
            v92 = *((_QWORD *)a2 - 1);
            if (v92 >= (unint64_t)v75)
              return result;
            goto LABEL_145;
          }
        }
        else
        {
          v79 = v10;
          v80 = (unint64_t **)(v10 + 2);
          result = *v10;
          if (v77 >= (unint64_t)v75)
          {
            *v10 = (unint64_t)v75;
            v10[1] = (unint64_t)v78;
            v79 = v10 + 1;
            v80 = (unint64_t **)(v10 + 2);
            result = (uint64_t)v78;
            if (v77 >= (unint64_t)v78)
              goto LABEL_144;
          }
        }
        *v79 = v77;
        *v80 = v78;
        v75 = (unint64_t *)result;
        goto LABEL_136;
      case 5uLL:
        return (uint64_t)std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **>(v10, v10 + 1, v10 + 2, v10 + 3, (unint64_t *)a2 - 1);
      default:
        if (v11 > 191)
        {
          if (!a4)
          {
            if (v10 != (unint64_t *)a2)
              return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **,HGBitmap **>((char *)v10, a2, a2);
            return result;
          }
          v13 = v12 >> 1;
          v14 = &v10[v12 >> 1];
          v15 = *((_QWORD *)a2 - 1);
          if ((unint64_t)v11 < 0x401)
          {
            v18 = *v10;
            v19 = *v14;
            if (*v10 >= *v14)
            {
              if (v15 < v18)
              {
                *v10 = v15;
                *((_QWORD *)a2 - 1) = v18;
                v21 = *v14;
                if (*v10 < *v14)
                {
                  *v14 = *v10;
                  *v10 = v21;
                  --a4;
                  v22 = v21;
                  if ((a5 & 1) != 0)
                    goto LABEL_56;
                  goto LABEL_55;
                }
              }
            }
            else
            {
              if (v15 < v18)
              {
                *v14 = v15;
                goto LABEL_31;
              }
              *v14 = v18;
              *v10 = v19;
              v31 = *((_QWORD *)a2 - 1);
              if (v31 < v19)
              {
                *v10 = v31;
LABEL_31:
                *((_QWORD *)a2 - 1) = v19;
              }
            }
            --a4;
            v22 = *v10;
            if ((a5 & 1) != 0)
              goto LABEL_56;
            goto LABEL_55;
          }
          v16 = *v14;
          v17 = *v10;
          if (*v14 >= *v10)
          {
            if (v15 < v16)
            {
              *v14 = v15;
              *((_QWORD *)a2 - 1) = v16;
              v20 = *v10;
              if (*v14 < *v10)
              {
                *v10 = *v14;
                *v14 = v20;
              }
            }
          }
          else
          {
            if (v15 >= v16)
            {
              *v10 = v16;
              *v14 = v17;
              v23 = *((_QWORD *)a2 - 1);
              if (v23 >= v17)
                goto LABEL_23;
              *v14 = v23;
            }
            else
            {
              *v10 = v15;
            }
            *((_QWORD *)a2 - 1) = v17;
          }
LABEL_23:
          v24 = &v10[v13];
          v27 = *(v24 - 1);
          v25 = v24 - 1;
          v26 = v27;
          v28 = v10[1];
          v29 = *((_QWORD *)a2 - 2);
          if (v27 >= v28)
          {
            if (v29 < v26)
            {
              *v25 = v29;
              *((_QWORD *)a2 - 2) = v26;
              v30 = v10[1];
              if (*v25 < v30)
              {
                v10[1] = *v25;
                *v25 = v30;
              }
            }
          }
          else
          {
            if (v29 >= v26)
            {
              v10[1] = v26;
              *v25 = v28;
              v32 = *((_QWORD *)a2 - 2);
              if (v32 >= v28)
                goto LABEL_37;
              *v25 = v32;
            }
            else
            {
              v10[1] = v29;
            }
            *((_QWORD *)a2 - 2) = v28;
          }
LABEL_37:
          v33 = &v10[v13];
          v36 = v33[1];
          v34 = v33 + 1;
          v35 = v36;
          v37 = v10[2];
          v38 = *((_QWORD *)a2 - 3);
          if (v36 >= v37)
          {
            if (v38 < v35)
            {
              *v34 = v38;
              *((_QWORD *)a2 - 3) = v35;
              v39 = v10[2];
              if (*v34 < v39)
              {
                v10[2] = *v34;
                *v34 = v39;
              }
            }
          }
          else
          {
            if (v38 >= v35)
            {
              v10[2] = v35;
              *v34 = v37;
              v40 = *((_QWORD *)a2 - 3);
              if (v40 >= v37)
                goto LABEL_46;
              *v34 = v40;
            }
            else
            {
              v10[2] = v38;
            }
            *((_QWORD *)a2 - 3) = v37;
          }
LABEL_46:
          v41 = *v14;
          v42 = *v25;
          v43 = *v34;
          if (*v14 < *v25)
          {
            if (v43 >= v41)
            {
              *v25 = v41;
              *v14 = v42;
              v25 = v14;
              v41 = v43;
              if (v43 >= v42)
              {
                v44 = *v10;
                *v10 = v42;
                *v14 = v44;
                --a4;
                v22 = *v10;
                if ((a5 & 1) != 0)
                  goto LABEL_56;
                goto LABEL_55;
              }
            }
            goto LABEL_53;
          }
          if (v43 >= v41)
            goto LABEL_54;
          *v14 = v43;
          *v34 = v41;
          v34 = v14;
          v41 = v42;
          if (v43 < v42)
          {
LABEL_53:
            *v25 = v43;
            *v34 = v42;
LABEL_54:
            v45 = *v10;
            *v10 = v41;
            *v14 = v45;
            --a4;
            v22 = *v10;
            if ((a5 & 1) != 0)
              goto LABEL_56;
LABEL_55:
            if (*(v10 - 1) < v22)
              goto LABEL_56;
            if (v22 >= *((_QWORD *)a2 - 1))
            {
              v61 = v10 + 1;
              do
              {
                v10 = v61;
                if (v61 >= (unint64_t *)a2)
                  break;
                ++v61;
              }
              while (v22 >= *v10);
            }
            else
            {
              do
              {
                v60 = v10[1];
                ++v10;
              }
              while (v22 >= v60);
            }
            v62 = (unint64_t *)a2;
            if (v10 < (unint64_t *)a2)
            {
              v62 = (unint64_t *)a2;
              do
                v63 = *--v62;
              while (v22 < v63);
            }
            if (v10 < v62)
            {
              v64 = *v10;
              v65 = *v62;
              do
              {
                *v10 = v65;
                *v62 = v64;
                do
                {
                  v66 = v10[1];
                  ++v10;
                  v64 = v66;
                }
                while (v22 >= v66);
                do
                {
                  v67 = *--v62;
                  v65 = v67;
                }
                while (v22 < v67);
              }
              while (v10 < v62);
            }
            v68 = v10 - 1;
            if (v10 - 1 != v9)
              *v9 = *v68;
            a5 = 0;
            *v68 = v22;
            continue;
          }
          v59 = *v10;
          *v10 = v43;
          *v14 = v59;
          --a4;
          v22 = *v10;
          if ((a5 & 1) == 0)
            goto LABEL_55;
LABEL_56:
          v46 = 0;
          do
            v47 = v10[++v46];
          while (v47 < v22);
          v48 = &v10[v46];
          v49 = a2;
          if (v46 == 1)
          {
            v49 = a2;
            do
            {
              if (v48 >= (unint64_t *)v49)
                break;
              v51 = *((_QWORD *)v49 - 1);
              v49 -= 8;
            }
            while (v51 >= v22);
          }
          else
          {
            do
            {
              v50 = *((_QWORD *)v49 - 1);
              v49 -= 8;
            }
            while (v50 >= v22);
          }
          if (v48 >= (unint64_t *)v49)
          {
            v57 = v48 - 1;
            if (v48 - 1 != v10)
              goto LABEL_73;
          }
          else
          {
            v52 = *(_QWORD *)v49;
            v53 = &v10[v46];
            v54 = (unint64_t *)v49;
            do
            {
              *v53 = v52;
              *v54 = v47;
              do
              {
                v55 = v53[1];
                ++v53;
                v47 = v55;
              }
              while (v55 < v22);
              do
              {
                v56 = *--v54;
                v52 = v56;
              }
              while (v56 >= v22);
            }
            while (v53 < v54);
            v57 = v53 - 1;
            if (v53 - 1 == v10)
              goto LABEL_74;
LABEL_73:
            *v10 = *v57;
          }
LABEL_74:
          *v57 = v22;
          if (v48 < (unint64_t *)v49)
            goto LABEL_77;
          v58 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **>(v10, v57);
          v10 = v57 + 1;
          result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **>(v57 + 1, (unint64_t *)a2);
          if (!(_DWORD)result)
          {
            if (v58)
              continue;
LABEL_77:
            result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **,false>(v9, v57, a3, a4, a5 & 1);
            a5 = 0;
            v10 = v57 + 1;
            continue;
          }
          a2 = (char *)v57;
          if (v58)
            return result;
          goto LABEL_2;
        }
        v81 = (char *)(v10 + 1);
        v83 = v10 == (unint64_t *)a2 || v81 == a2;
        if ((a5 & 1) != 0)
        {
          if (!v83)
          {
            v84 = 0;
            v85 = v10;
            do
            {
              v88 = *v85;
              v87 = v85[1];
              v85 = (unint64_t *)v81;
              if (v87 < v88)
              {
                v89 = v84;
                do
                {
                  *(unint64_t *)((char *)v10 + v89 + 8) = v88;
                  if (!v89)
                  {
                    v86 = v10;
                    goto LABEL_121;
                  }
                  v88 = *(unint64_t *)((char *)v10 + v89 - 8);
                  v89 -= 8;
                }
                while (v87 < v88);
                v86 = (unint64_t *)((char *)v10 + v89 + 8);
LABEL_121:
                *v86 = v87;
              }
              v81 = (char *)(v85 + 1);
              v84 += 8;
            }
            while (v85 + 1 != (unint64_t *)a2);
          }
        }
        else if (!v83)
        {
          do
          {
            v94 = *v9;
            v93 = v9[1];
            v9 = (unint64_t *)v81;
            if (v93 < v94)
            {
              do
              {
                *(_QWORD *)v81 = v94;
                v94 = *((_QWORD *)v81 - 2);
                v81 -= 8;
              }
              while (v93 < v94);
              *(_QWORD *)v81 = v93;
            }
            v81 = (char *)(v9 + 1);
          }
          while (v9 + 1 != (unint64_t *)a2);
        }
        return result;
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **>(unint64_t *a1, unint64_t *a2)
{
  unint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  int v23;
  uint64_t i;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;

  switch(a2 - a1)
  {
    case 0:
    case 1:
      return 1;
    case 2:
      v9 = *(a2 - 1);
      v10 = *a1;
      if (v9 >= *a1)
        return 1;
      *a1 = v9;
      *(a2 - 1) = v10;
      return 1;
    case 3:
      v11 = *a1;
      v12 = a1[1];
      v13 = *(a2 - 1);
      if (v12 >= *a1)
      {
        if (v13 >= v12)
          return 1;
        a1[1] = v13;
        *(a2 - 1) = v12;
        v30 = *a1;
        v29 = a1[1];
        if (v29 >= *a1)
          return 1;
        *a1 = v29;
        a1[1] = v30;
        return 1;
      }
      else if (v13 >= v12)
      {
        *a1 = v12;
        a1[1] = v11;
        v35 = *(a2 - 1);
        if (v35 >= v11)
          return 1;
        a1[1] = v35;
        *(a2 - 1) = v11;
        return 1;
      }
      else
      {
        *a1 = v13;
        *(a2 - 1) = v11;
        return 1;
      }
    case 4:
      v14 = a1 + 1;
      v15 = a1[1];
      v16 = a1 + 2;
      v17 = a1[2];
      v18 = *a1;
      if (v15 < *a1)
      {
        v19 = a1;
        v20 = a1 + 2;
        v21 = *a1;
        if (v17 >= v15)
        {
          *a1 = v15;
          a1[1] = v18;
          v19 = a1 + 1;
          v20 = a1 + 2;
          v21 = v18;
          if (v17 >= v18)
            goto LABEL_38;
        }
LABEL_35:
        *v19 = v17;
        *v20 = v18;
        v15 = v21;
LABEL_36:
        v31 = *(a2 - 1);
        if (v31 >= v15)
          return 1;
        goto LABEL_39;
      }
      if (v17 < v15)
      {
        *v14 = v17;
        *v16 = v15;
        v19 = a1;
        v20 = a1 + 1;
        v21 = v15;
        if (v17 >= v18)
          goto LABEL_36;
        goto LABEL_35;
      }
LABEL_38:
      v15 = v17;
      v31 = *(a2 - 1);
      if (v31 >= v15)
        return 1;
LABEL_39:
      *v16 = v31;
      *(a2 - 1) = v15;
      v32 = *v16;
      v33 = *v14;
      if (v32 >= v33)
        return 1;
      a1[1] = v32;
      a1[2] = v33;
      v34 = *a1;
      if (v32 >= *a1)
        return 1;
      *a1 = v32;
      a1[1] = v34;
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      v4 = a1 + 2;
      v3 = a1[2];
      v5 = a1[1];
      v6 = *a1;
      if (v5 >= *a1)
      {
        if (v3 >= v5)
          goto LABEL_20;
        a1[1] = v3;
        *v4 = v5;
        v7 = a1;
        v8 = a1 + 1;
      }
      else
      {
        v7 = a1;
        v8 = a1 + 2;
        if (v3 < v5)
          goto LABEL_19;
        *a1 = v5;
        a1[1] = v6;
        v7 = a1 + 1;
        v8 = a1 + 2;
      }
      if (v3 >= v6)
        goto LABEL_20;
LABEL_19:
      *v7 = v3;
      *v8 = v6;
LABEL_20:
      v22 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v23 = 0;
      for (i = 24; ; i += 8)
      {
        v25 = *v22;
        v26 = *v4;
        if (*v22 < v26)
          break;
LABEL_23:
        v4 = v22++;
        if (v22 == a2)
          return 1;
      }
      v27 = i;
      do
      {
        *(unint64_t *)((char *)a1 + v27) = v26;
        v28 = v27 - 8;
        if (v27 == 8)
        {
          *a1 = v25;
          if (++v23 != 8)
            goto LABEL_23;
          return v22 + 1 == a2;
        }
        v26 = *(unint64_t *)((char *)a1 + v27 - 16);
        v27 -= 8;
      }
      while (v25 < v26);
      *(unint64_t *)((char *)a1 + v28) = v25;
      if (++v23 != 8)
        goto LABEL_23;
      return v22 + 1 == a2;
  }
}

unint64_t *std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **>(unint64_t *result, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;

  v5 = *a2;
  v6 = *result;
  v7 = *a3;
  if (*a2 >= *result)
  {
    if (v7 >= v5)
    {
      v5 = *a3;
      v9 = *a4;
      if (*a4 >= v7)
        goto LABEL_17;
      goto LABEL_14;
    }
    *a2 = v7;
    *a3 = v5;
    v8 = *result;
    if (*a2 < *result)
    {
      *result = *a2;
      *a2 = v8;
      v5 = *a3;
      v9 = *a4;
      if (*a4 >= *a3)
        goto LABEL_17;
      goto LABEL_14;
    }
  }
  else
  {
    if (v7 >= v5)
    {
      *result = v5;
      *a2 = v6;
      v5 = *a3;
      if (*a3 >= v6)
        goto LABEL_11;
      *a2 = v5;
    }
    else
    {
      *result = v7;
    }
    *a3 = v6;
    v5 = v6;
  }
LABEL_11:
  v9 = *a4;
  if (*a4 >= v5)
    goto LABEL_17;
LABEL_14:
  *a3 = v9;
  *a4 = v5;
  v10 = *a2;
  if (*a3 < *a2)
  {
    *a2 = *a3;
    *a3 = v10;
    v11 = *result;
    if (*a2 < *result)
    {
      *result = *a2;
      *a2 = v11;
    }
  }
LABEL_17:
  v12 = *a4;
  if (*a5 < *a4)
  {
    *a4 = *a5;
    *a5 = v12;
    v13 = *a3;
    if (*a4 < *a3)
    {
      *a3 = *a4;
      *a4 = v13;
      v14 = *a2;
      if (*a3 < *a2)
      {
        *a2 = *a3;
        *a3 = v14;
        v15 = *result;
        if (*a2 < *result)
        {
          *result = *a2;
          *a2 = v15;
        }
      }
    }
  }
  return result;
}

char *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **,HGBitmap **>(char *a1, char *a2, char *a3)
{
  uint64_t v3;
  uint64_t v4;
  char *v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t *v9;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  BOOL v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  unint64_t v21;
  int64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  int64_t v33;
  int64_t v34;
  uint64_t v35;
  char *v36;
  unint64_t v37;
  BOOL v38;
  char *v39;
  unint64_t v40;
  uint64_t v41;

  if (a1 == a2)
    return a3;
  v3 = a2 - a1;
  v4 = (a2 - a1) >> 3;
  if (a2 - a1 >= 9 && (unint64_t)v3 >= 0x10)
  {
    v33 = (unint64_t)(v4 - 2) >> 1;
    v34 = v33;
    do
    {
      if (v33 >= v34)
      {
        v35 = (2 * v34) | 1;
        v36 = &a1[8 * v35];
        if (2 * v34 + 2 >= v4)
        {
          v37 = *(_QWORD *)v36;
          v39 = &a1[8 * v34];
          v40 = *(_QWORD *)v39;
          if (*(_QWORD *)v36 >= *(_QWORD *)v39)
            goto LABEL_71;
        }
        else
        {
          v37 = *((_QWORD *)v36 + 1);
          v38 = *(_QWORD *)v36 >= v37;
          if (*(_QWORD *)v36 < v37)
            v36 += 8;
          else
            v37 = *(_QWORD *)v36;
          if (!v38)
            v35 = 2 * v34 + 2;
          v39 = &a1[8 * v34];
          v40 = *(_QWORD *)v39;
          if (v37 >= *(_QWORD *)v39)
          {
LABEL_71:
            while (1)
            {
              *(_QWORD *)v39 = v37;
              v39 = v36;
              if (v33 < v35)
                break;
              v41 = (2 * v35) | 1;
              v36 = &a1[8 * v41];
              v35 = 2 * v35 + 2;
              if (v35 < v4)
              {
                v37 = *(_QWORD *)v36;
                if (*(_QWORD *)v36 >= *((_QWORD *)v36 + 1))
                {
                  v35 = v41;
                }
                else
                {
                  v37 = *((_QWORD *)v36 + 1);
                  v36 += 8;
                }
                if (v37 < v40)
                  break;
              }
              else
              {
                v37 = *(_QWORD *)v36;
                v35 = v41;
                if (*(_QWORD *)v36 < v40)
                  break;
              }
            }
            *(_QWORD *)v39 = v40;
          }
        }
      }
      v19 = v34-- <= 0;
    }
    while (!v19);
  }
  v5 = a2;
  if (a2 != a3)
  {
    if (v3 < 16)
    {
      v6 = *(_QWORD *)a1;
      v7 = a2;
      do
      {
        v8 = *(_QWORD *)v7;
        if (*(_QWORD *)v7 < v6)
        {
          *(_QWORD *)v7 = v6;
          *(_QWORD *)a1 = v8;
          v6 = v8;
        }
        v7 += 8;
      }
      while (v7 != a3);
LABEL_33:
      v5 = a3;
      goto LABEL_34;
    }
    v9 = (unint64_t *)(a1 + 16);
    v10 = a2;
    while (1)
    {
      v11 = *(_QWORD *)v10;
      if (*(_QWORD *)v10 < *(_QWORD *)a1)
      {
        *(_QWORD *)v10 = *(_QWORD *)a1;
        *(_QWORD *)a1 = v11;
        v12 = *((_QWORD *)a1 + 1);
        if (v3 == 16)
        {
          v13 = a1 + 8;
          v14 = 1;
          if (v12 >= v11)
            goto LABEL_24;
        }
        else
        {
          v15 = v12 >= *v9;
          if (v12 >= *v9)
          {
            v13 = a1 + 8;
          }
          else
          {
            v12 = *v9;
            v13 = a1 + 16;
          }
          if (v15)
            v14 = 1;
          else
            v14 = 2;
          if (v12 >= v11)
          {
LABEL_24:
            v16 = a1;
            while (1)
            {
              *(_QWORD *)v16 = v12;
              v16 = v13;
              if ((uint64_t)((unint64_t)(v4 - 2) >> 1) < v14)
                break;
              v17 = (2 * v14) | 1;
              v13 = &a1[8 * v17];
              v14 = 2 * v14 + 2;
              if (v14 < v4)
              {
                v12 = *(_QWORD *)v13;
                if (*(_QWORD *)v13 >= *((_QWORD *)v13 + 1))
                {
                  v14 = v17;
                }
                else
                {
                  v12 = *((_QWORD *)v13 + 1);
                  v13 += 8;
                }
                if (v12 < v11)
                  break;
              }
              else
              {
                v12 = *(_QWORD *)v13;
                v14 = v17;
                if (*(_QWORD *)v13 < v11)
                  break;
              }
            }
            *(_QWORD *)v16 = v11;
          }
        }
      }
      v10 += 8;
      if (v10 == a3)
        goto LABEL_33;
    }
  }
LABEL_34:
  if (v3 >= 9)
  {
    v18 = (unint64_t)v3 >> 3;
    do
    {
      v20 = 0;
      v21 = *(_QWORD *)a1;
      v22 = (unint64_t)(v18 - 2) >> 1;
      v23 = a1;
      do
      {
        while (1)
        {
          v25 = &v23[8 * v20 + 8];
          v26 = (2 * v20) | 1;
          v20 = 2 * v20 + 2;
          if (v20 < v18)
            break;
          v20 = v26;
          *(_QWORD *)v23 = *(_QWORD *)v25;
          v23 = v25;
          if (v26 > v22)
            goto LABEL_45;
        }
        v24 = *(_QWORD *)v25;
        if (*(_QWORD *)v25 >= *((_QWORD *)v25 + 1))
        {
          v20 = v26;
        }
        else
        {
          v24 = *((_QWORD *)v25 + 1);
          v25 += 8;
        }
        *(_QWORD *)v23 = v24;
        v23 = v25;
      }
      while (v20 <= v22);
LABEL_45:
      a2 -= 8;
      if (v25 == a2)
      {
        *(_QWORD *)v25 = v21;
      }
      else
      {
        *(_QWORD *)v25 = *(_QWORD *)a2;
        *(_QWORD *)a2 = v21;
        v27 = v25 - a1 + 8;
        if (v27 >= 9)
        {
          v28 = (((unint64_t)v27 >> 3) - 2) >> 1;
          v29 = &a1[8 * v28];
          v30 = *(_QWORD *)v29;
          v31 = *(_QWORD *)v25;
          if (*(_QWORD *)v29 < *(_QWORD *)v25)
          {
            do
            {
              *(_QWORD *)v25 = v30;
              v25 = v29;
              if (!v28)
                break;
              v28 = (v28 - 1) >> 1;
              v29 = &a1[8 * v28];
              v30 = *(_QWORD *)v29;
            }
            while (*(_QWORD *)v29 < v31);
            *(_QWORD *)v25 = v31;
          }
        }
      }
      v19 = v18-- <= 2;
    }
    while (!v19);
  }
  return v5;
}

void HGGPURenderer::ProcessOnePageBegin(HGNode *)::RenderBufferedTilesVisitor::visitNodePre(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  a3[60] = a3[59];
  a3[4] &= ~0x10u;
}

void HGGPURenderer::ProcessOnePageBegin(HGNode *)::RenderBufferedTilesVisitor::visitNodePost(uint64_t a1, HGGPURenderer *a2, _QWORD *a3)
{
  int v5;
  unsigned __int8 v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  int v10;
  uint64_t i;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t (**v16)();

  if (!a3[24])
  {
    (*(void (**)(HGGPURenderer *, _QWORD *, uint64_t))(*(_QWORD *)a2 + 320))(a2, a3, 1);
    if (!HGRectIsNull(*(_QWORD *)((char *)a3 + 220), *(_QWORD *)((char *)a3 + 228)))
    {
      v5 = *((_DWORD *)a2 + 154);
      if (v5 == 1 || v5 != 2 && *((int *)a3 + 59) > 1)
      {
        v6 = atomic_load(HGLogger::_enabled);
        if ((v6 & 1) != 0)
        {
          v7 = (*(uint64_t (**)(_QWORD *))(*a3 + 48))(a3);
          HGLogger::log((HGLogger *)"nbfo", (const char *)1, (HGLogger *)"will buffer sub-tile of node %s (%p)\n", v8, v9, v7, a3);
        }
        (*(void (**)(_QWORD *, HGGPURenderer *))(*a3 + 432))(a3, a2);
        a3[31] = HGGPURenderer::GetNodeTexture(a2, (HGNode *)a3, *(HGRect *)((char *)a3 + 220), 0, 1u);
        (*(void (**)(HGGPURenderer *, _QWORD))(*(_QWORD *)a2 + 144))(a2, 0);
      }
    }
    v10 = *((_DWORD *)a3 + 22);
    if (v10 >= 1)
    {
      for (i = 0; i < v10; ++i)
      {
        v12 = *(_QWORD *)(a3[10] + 8 * i);
        if (v12)
        {
          v13 = *(_QWORD *)(v12 + 16);
          if (v13)
          {
            if (a3[31])
            {
              v14 = *(_QWORD *)(v13 + 144);
              v16 = off_1E6524460;
              HGTraversal::RecursiveTraversal<(HGTraversal::NodeInput)1,(HGTraversal::InputOrder)0>::operator()((uint64_t)&v15, a2, v14, (void (***)(uint64_t, HGRenderer *, uint64_t))&v16);
              v10 = *((_DWORD *)a3 + 22);
            }
          }
        }
      }
    }
  }
}

BOOL HGGPURenderer::ProcessOnePageBegin(HGNode *)::RenderBufferedTilesVisitor::willVisitNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(_DWORD *)(a3 + 240) == 0;
}

BOOL HGGPURenderer::ProcessOnePageBegin(HGNode *)::RenderBufferedTilesVisitor::willVisitChildren(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(_QWORD *)(a3 + 192) == 0;
}

uint64_t HGGPURenderer::ProcessOnePageEnd(HGNode *)::ReleaseBufferedTilesVisitor::visitNodePost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = *(_QWORD *)(a3 + 248);
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
    *(_QWORD *)(a3 + 248) = 0;
  }
  return result;
}

void HGGPURenderer::ProcessOnePageEnd(HGNode *)::ReleaseBufferedTilesVisitor::discoverNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  --*(_DWORD *)(a3 + 240);
}

BOOL HGGPURenderer::ProcessOnePageEnd(HGNode *)::ReleaseBufferedTilesVisitor::willVisitNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return !*(_DWORD *)(a3 + 240) && *(_QWORD *)(a3 + 192) == 0;
}

BOOL HGGPURenderer::ProcessOnePageEnd(HGNode *)::ReleaseBufferedTilesVisitor::willVisitChild(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)(*(_QWORD *)(a3 + 80) + 8 * a4);
  return v4 && *(_QWORD *)(v4 + 16) && *(_QWORD *)(a3 + 248) == 0;
}

uint64_t *std::list<FBOStrategy::FBOCacheEntry>::~list(uint64_t *a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;

  if (a1[2])
  {
    v3 = *a1;
    v2 = (uint64_t *)a1[1];
    v4 = *v2;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(*a1 + 8);
    **(_QWORD **)(v3 + 8) = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        v5 = (uint64_t *)v2[1];
        operator delete(v2);
        v2 = v5;
      }
      while (v5 != a1);
    }
  }
  return a1;
}

_QWORD *std::__call_once_proxy[abi:ne180100]<std::tuple<HGFormatUtils::adjustPrecision(unsigned int,unsigned int)::$_0 &&>>()
{
  uint64_t v0;
  unsigned int *v1;
  uint64_t **v2;
  unsigned int *v3;
  _QWORD *v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t **v9;
  _QWORD *v10;
  unsigned int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t *v14;
  unsigned int *v15;
  uint64_t **v16;
  unsigned int *v17;
  _QWORD *v18;
  unsigned int v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t **v23;
  _QWORD *v24;
  unsigned int v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  unsigned int *v30;
  uint64_t **v31;
  _QWORD *v32;
  unsigned int v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t **v39;
  uint64_t **v40;
  unsigned int v41;
  _DWORD *v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t **v47;
  uint64_t **v48;
  unsigned int v49;
  _DWORD *v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t **v55;
  uint64_t **v56;
  unsigned int v57;
  _DWORD *v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t **v63;
  uint64_t **v64;
  unsigned int v65;
  _DWORD *v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t *v70;
  uint64_t **v71;
  uint64_t **v72;
  unsigned int v73;
  _DWORD *v74;
  uint64_t v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t *v78;
  uint64_t **v79;
  uint64_t **v80;
  unsigned int v81;
  _DWORD *v82;
  uint64_t v83;
  uint64_t *v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t **v87;
  uint64_t **v88;
  unsigned int v89;
  _DWORD *v90;
  uint64_t v91;
  uint64_t *v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t **v95;
  uint64_t **v96;
  unsigned int v97;
  _DWORD *v98;
  uint64_t v99;
  uint64_t *v100;
  uint64_t v101;
  uint64_t *v102;
  uint64_t **v103;
  uint64_t **v104;
  unsigned int v105;
  _DWORD *v106;
  uint64_t v107;
  uint64_t *v108;
  uint64_t v109;
  uint64_t *v110;
  uint64_t **v111;
  uint64_t **v112;
  unsigned int v113;
  _DWORD *v114;
  uint64_t v115;
  uint64_t *v116;
  uint64_t v117;
  uint64_t *v118;
  uint64_t **v119;
  uint64_t **v120;
  unsigned int v121;
  _DWORD *v122;
  uint64_t v123;
  uint64_t *v124;
  uint64_t v125;
  uint64_t *v126;
  uint64_t **v127;
  uint64_t **v128;
  unsigned int v129;
  _DWORD *v130;
  uint64_t v131;
  uint64_t *v132;
  uint64_t v133;
  uint64_t *v134;
  uint64_t **v135;
  uint64_t **v136;
  unsigned int v137;
  _DWORD *v138;
  uint64_t v139;
  uint64_t *v140;
  __int128 v142;
  char v143[8];
  uint64_t v144;

  v144 = *MEMORY[0x1E0C80C00];
  v0 = _MergedGlobals_10;
  v2 = (uint64_t **)(_MergedGlobals_10 + 8);
  v1 = *(unsigned int **)(_MergedGlobals_10 + 8);
  if (v1)
  {
    v3 = *(unsigned int **)(_MergedGlobals_10 + 8);
    while (1)
    {
      while (1)
      {
        v4 = v3;
        v5 = v3[7];
        if (v5 < 2)
          break;
        v3 = (unsigned int *)*v4;
        v2 = (uint64_t **)v4;
        if (!*v4)
          goto LABEL_9;
      }
      if (v5)
        break;
      v3 = (unsigned int *)v4[1];
      if (!v3)
      {
        v2 = (uint64_t **)(v4 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    v4 = (_QWORD *)(_MergedGlobals_10 + 8);
LABEL_9:
    v6 = v4;
    v4 = operator new(0x28uLL);
    *(_QWORD *)((char *)v4 + 28) = 1;
    *v4 = 0;
    v4[1] = 0;
    v4[2] = v6;
    *v2 = v4;
    v7 = **(_QWORD **)v0;
    v8 = v4;
    if (v7)
    {
      *(_QWORD *)v0 = v7;
      v8 = *v2;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v0 + 8), v8);
    ++*(_QWORD *)(v0 + 16);
    v0 = _MergedGlobals_10;
    v1 = *(unsigned int **)(_MergedGlobals_10 + 8);
  }
  *((_DWORD *)v4 + 8) = 0;
  if (v1)
  {
    while (1)
    {
      while (1)
      {
        v10 = v1;
        v11 = v1[7];
        if (v11 < 3)
          break;
        v1 = (unsigned int *)*v10;
        v9 = (uint64_t **)v10;
        if (!*v10)
          goto LABEL_19;
      }
      if (v11 == 2)
        break;
      v1 = (unsigned int *)v10[1];
      if (!v1)
      {
        v9 = (uint64_t **)(v10 + 1);
        goto LABEL_19;
      }
    }
  }
  else
  {
    v9 = (uint64_t **)(v0 + 8);
    v10 = (_QWORD *)(v0 + 8);
LABEL_19:
    v12 = v10;
    v10 = operator new(0x28uLL);
    *(_QWORD *)((char *)v10 + 28) = 2;
    *v10 = 0;
    v10[1] = 0;
    v10[2] = v12;
    *v9 = v10;
    v13 = **(_QWORD **)v0;
    v14 = v10;
    if (v13)
    {
      *(_QWORD *)v0 = v13;
      v14 = *v9;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v0 + 8), v14);
    ++*(_QWORD *)(v0 + 16);
    v0 = _MergedGlobals_10;
  }
  *((_DWORD *)v10 + 8) = 1;
  v16 = (uint64_t **)(v0 + 8);
  v15 = *(unsigned int **)(v0 + 8);
  if (v15)
  {
    v17 = *(unsigned int **)(v0 + 8);
    while (1)
    {
      while (1)
      {
        v18 = v17;
        v19 = v17[7];
        if (v19 < 5)
          break;
        v17 = (unsigned int *)*v18;
        v16 = (uint64_t **)v18;
        if (!*v18)
          goto LABEL_30;
      }
      if (v19 == 4)
        break;
      v17 = (unsigned int *)v18[1];
      if (!v17)
      {
        v16 = (uint64_t **)(v18 + 1);
        goto LABEL_30;
      }
    }
  }
  else
  {
    v18 = (_QWORD *)(v0 + 8);
LABEL_30:
    v20 = v18;
    v18 = operator new(0x28uLL);
    *(_QWORD *)((char *)v18 + 28) = 4;
    *v18 = 0;
    v18[1] = 0;
    v18[2] = v20;
    *v16 = v18;
    v21 = **(_QWORD **)v0;
    v22 = v18;
    if (v21)
    {
      *(_QWORD *)v0 = v21;
      v22 = *v16;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v0 + 8), v22);
    ++*(_QWORD *)(v0 + 16);
    v0 = _MergedGlobals_10;
    v15 = *(unsigned int **)(_MergedGlobals_10 + 8);
  }
  *((_DWORD *)v18 + 8) = 2;
  if (v15)
  {
    while (1)
    {
      while (1)
      {
        v24 = v15;
        v25 = v15[7];
        if (v25 < 9)
          break;
        v15 = (unsigned int *)*v24;
        v23 = (uint64_t **)v24;
        if (!*v24)
          goto LABEL_40;
      }
      if (v25 == 8)
        break;
      v15 = (unsigned int *)v24[1];
      if (!v15)
      {
        v23 = (uint64_t **)(v24 + 1);
        goto LABEL_40;
      }
    }
  }
  else
  {
    v23 = (uint64_t **)(v0 + 8);
    v24 = (_QWORD *)(v0 + 8);
LABEL_40:
    v26 = v24;
    v24 = operator new(0x28uLL);
    *(_QWORD *)((char *)v24 + 28) = 8;
    *v24 = 0;
    v24[1] = 0;
    v24[2] = v26;
    *v23 = v24;
    v27 = **(_QWORD **)v0;
    v28 = v24;
    if (v27)
    {
      *(_QWORD *)v0 = v27;
      v28 = *v23;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v0 + 8), v28);
    ++*(_QWORD *)(v0 + 16);
  }
  *((_DWORD *)v24 + 8) = 3;
  v142 = xmmword_1B351FA10;
  v29 = qword_1ED4DA9C0;
  v31 = (uint64_t **)(qword_1ED4DA9C0 + 8);
  v30 = *(unsigned int **)(qword_1ED4DA9C0 + 8);
  if (v30)
  {
    while (1)
    {
      while (1)
      {
        v32 = v30;
        v33 = v30[8];
        if (v33 < 8)
          break;
        v30 = (unsigned int *)*v32;
        v31 = (uint64_t **)v32;
        if (!*v32)
          goto LABEL_50;
      }
      if (v33 == 7)
        break;
      v30 = (unsigned int *)v32[1];
      if (!v30)
      {
        v31 = (uint64_t **)(v32 + 1);
        goto LABEL_50;
      }
    }
  }
  else
  {
    v32 = (_QWORD *)(qword_1ED4DA9C0 + 8);
LABEL_50:
    v34 = v32;
    v32 = operator new(0x40uLL);
    *((_DWORD *)v32 + 8) = 7;
    v32[6] = 0;
    v32[7] = 0;
    v32[5] = 0;
    *v32 = 0;
    v32[1] = 0;
    v32[2] = v34;
    *v31 = v32;
    v35 = **(_QWORD **)v29;
    v36 = v32;
    if (v35)
    {
      *(_QWORD *)v29 = v35;
      v36 = *v31;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v29 + 8), v36);
    ++*(_QWORD *)(v29 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>(v32 + 5, (char *)&v142, v143, 4uLL);
  v142 = xmmword_1B351FA20;
  v37 = qword_1ED4DA9C0;
  v39 = (uint64_t **)(qword_1ED4DA9C0 + 8);
  v38 = *(uint64_t **)(qword_1ED4DA9C0 + 8);
  if (v38)
  {
    while (1)
    {
      while (1)
      {
        v40 = (uint64_t **)v38;
        v41 = *((_DWORD *)v38 + 8);
        if (v41 < 0xC)
          break;
        v38 = *v40;
        v39 = v40;
        if (!*v40)
          goto LABEL_60;
      }
      if (v41 == 11)
        break;
      v38 = v40[1];
      if (!v38)
      {
        v39 = v40 + 1;
        goto LABEL_60;
      }
    }
    v42 = v40;
  }
  else
  {
    v40 = (uint64_t **)(qword_1ED4DA9C0 + 8);
LABEL_60:
    v42 = operator new(0x40uLL);
    v42[8] = 11;
    *((_QWORD *)v42 + 6) = 0;
    *((_QWORD *)v42 + 7) = 0;
    *((_QWORD *)v42 + 5) = 0;
    *(_QWORD *)v42 = 0;
    *((_QWORD *)v42 + 1) = 0;
    *((_QWORD *)v42 + 2) = v40;
    *v39 = (uint64_t *)v42;
    v43 = **(_QWORD **)v37;
    v44 = (uint64_t *)v42;
    if (v43)
    {
      *(_QWORD *)v37 = v43;
      v44 = *v39;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v37 + 8), v44);
    ++*(_QWORD *)(v37 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((_QWORD *)v42 + 5, (char *)&v142, v143, 4uLL);
  v142 = xmmword_1B351FA30;
  v45 = qword_1ED4DA9C0;
  v47 = (uint64_t **)(qword_1ED4DA9C0 + 8);
  v46 = *(uint64_t **)(qword_1ED4DA9C0 + 8);
  if (v46)
  {
    while (1)
    {
      while (1)
      {
        v48 = (uint64_t **)v46;
        v49 = *((_DWORD *)v46 + 8);
        if (v49 < 4)
          break;
        v46 = *v48;
        v47 = v48;
        if (!*v48)
          goto LABEL_71;
      }
      if (v49 == 3)
        break;
      v46 = v48[1];
      if (!v46)
      {
        v47 = v48 + 1;
        goto LABEL_71;
      }
    }
    v50 = v48;
  }
  else
  {
    v48 = (uint64_t **)(qword_1ED4DA9C0 + 8);
LABEL_71:
    v50 = operator new(0x40uLL);
    v50[8] = 3;
    *((_QWORD *)v50 + 6) = 0;
    *((_QWORD *)v50 + 7) = 0;
    *((_QWORD *)v50 + 5) = 0;
    *(_QWORD *)v50 = 0;
    *((_QWORD *)v50 + 1) = 0;
    *((_QWORD *)v50 + 2) = v48;
    *v47 = (uint64_t *)v50;
    v51 = **(_QWORD **)v45;
    v52 = (uint64_t *)v50;
    if (v51)
    {
      *(_QWORD *)v45 = v51;
      v52 = *v47;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v45 + 8), v52);
    ++*(_QWORD *)(v45 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((_QWORD *)v50 + 5, (char *)&v142, v143, 4uLL);
  v142 = xmmword_1B351FA40;
  v53 = qword_1ED4DA9C0;
  v55 = (uint64_t **)(qword_1ED4DA9C0 + 8);
  v54 = *(uint64_t **)(qword_1ED4DA9C0 + 8);
  if (v54)
  {
    while (1)
    {
      while (1)
      {
        v56 = (uint64_t **)v54;
        v57 = *((_DWORD *)v54 + 8);
        if (v57 < 0xE)
          break;
        v54 = *v56;
        v55 = v56;
        if (!*v56)
          goto LABEL_82;
      }
      if (v57 == 13)
        break;
      v54 = v56[1];
      if (!v54)
      {
        v55 = v56 + 1;
        goto LABEL_82;
      }
    }
    v58 = v56;
  }
  else
  {
    v56 = (uint64_t **)(qword_1ED4DA9C0 + 8);
LABEL_82:
    v58 = operator new(0x40uLL);
    v58[8] = 13;
    *((_QWORD *)v58 + 6) = 0;
    *((_QWORD *)v58 + 7) = 0;
    *((_QWORD *)v58 + 5) = 0;
    *(_QWORD *)v58 = 0;
    *((_QWORD *)v58 + 1) = 0;
    *((_QWORD *)v58 + 2) = v56;
    *v55 = (uint64_t *)v58;
    v59 = **(_QWORD **)v53;
    v60 = (uint64_t *)v58;
    if (v59)
    {
      *(_QWORD *)v53 = v59;
      v60 = *v55;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v53 + 8), v60);
    ++*(_QWORD *)(v53 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((_QWORD *)v58 + 5, (char *)&v142, v143, 4uLL);
  v142 = xmmword_1B351FA50;
  v61 = qword_1ED4DA9C0;
  v63 = (uint64_t **)(qword_1ED4DA9C0 + 8);
  v62 = *(uint64_t **)(qword_1ED4DA9C0 + 8);
  if (v62)
  {
    while (1)
    {
      while (1)
      {
        v64 = (uint64_t **)v62;
        v65 = *((_DWORD *)v62 + 8);
        if (v65 < 6)
          break;
        v62 = *v64;
        v63 = v64;
        if (!*v64)
          goto LABEL_93;
      }
      if (v65 == 5)
        break;
      v62 = v64[1];
      if (!v62)
      {
        v63 = v64 + 1;
        goto LABEL_93;
      }
    }
    v66 = v64;
  }
  else
  {
    v64 = (uint64_t **)(qword_1ED4DA9C0 + 8);
LABEL_93:
    v66 = operator new(0x40uLL);
    v66[8] = 5;
    *((_QWORD *)v66 + 6) = 0;
    *((_QWORD *)v66 + 7) = 0;
    *((_QWORD *)v66 + 5) = 0;
    *(_QWORD *)v66 = 0;
    *((_QWORD *)v66 + 1) = 0;
    *((_QWORD *)v66 + 2) = v64;
    *v63 = (uint64_t *)v66;
    v67 = **(_QWORD **)v61;
    v68 = (uint64_t *)v66;
    if (v67)
    {
      *(_QWORD *)v61 = v67;
      v68 = *v63;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v61 + 8), v68);
    ++*(_QWORD *)(v61 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((_QWORD *)v66 + 5, (char *)&v142, v143, 4uLL);
  v142 = xmmword_1B351FA60;
  v69 = qword_1ED4DA9C0;
  v71 = (uint64_t **)(qword_1ED4DA9C0 + 8);
  v70 = *(uint64_t **)(qword_1ED4DA9C0 + 8);
  if (v70)
  {
    while (1)
    {
      while (1)
      {
        v72 = (uint64_t **)v70;
        v73 = *((_DWORD *)v70 + 8);
        if (v73 < 0xA)
          break;
        v70 = *v72;
        v71 = v72;
        if (!*v72)
          goto LABEL_104;
      }
      if (v73 == 9)
        break;
      v70 = v72[1];
      if (!v70)
      {
        v71 = v72 + 1;
        goto LABEL_104;
      }
    }
    v74 = v72;
  }
  else
  {
    v72 = (uint64_t **)(qword_1ED4DA9C0 + 8);
LABEL_104:
    v74 = operator new(0x40uLL);
    v74[8] = 9;
    *((_QWORD *)v74 + 6) = 0;
    *((_QWORD *)v74 + 7) = 0;
    *((_QWORD *)v74 + 5) = 0;
    *(_QWORD *)v74 = 0;
    *((_QWORD *)v74 + 1) = 0;
    *((_QWORD *)v74 + 2) = v72;
    *v71 = (uint64_t *)v74;
    v75 = **(_QWORD **)v69;
    v76 = (uint64_t *)v74;
    if (v75)
    {
      *(_QWORD *)v69 = v75;
      v76 = *v71;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v69 + 8), v76);
    ++*(_QWORD *)(v69 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((_QWORD *)v74 + 5, (char *)&v142, v143, 4uLL);
  v142 = xmmword_1B351FA70;
  v77 = qword_1ED4DA9C0;
  v79 = (uint64_t **)(qword_1ED4DA9C0 + 8);
  v78 = *(uint64_t **)(qword_1ED4DA9C0 + 8);
  if (v78)
  {
    while (1)
    {
      while (1)
      {
        v80 = (uint64_t **)v78;
        v81 = *((_DWORD *)v78 + 8);
        if (v81 < 2)
          break;
        v78 = *v80;
        v79 = v80;
        if (!*v80)
          goto LABEL_115;
      }
      if (v81)
        break;
      v78 = v80[1];
      if (!v78)
      {
        v79 = v80 + 1;
        goto LABEL_115;
      }
    }
    v82 = v80;
  }
  else
  {
    v80 = (uint64_t **)(qword_1ED4DA9C0 + 8);
LABEL_115:
    v82 = operator new(0x40uLL);
    v82[8] = 1;
    *((_QWORD *)v82 + 6) = 0;
    *((_QWORD *)v82 + 7) = 0;
    *((_QWORD *)v82 + 5) = 0;
    *(_QWORD *)v82 = 0;
    *((_QWORD *)v82 + 1) = 0;
    *((_QWORD *)v82 + 2) = v80;
    *v79 = (uint64_t *)v82;
    v83 = **(_QWORD **)v77;
    v84 = (uint64_t *)v82;
    if (v83)
    {
      *(_QWORD *)v77 = v83;
      v84 = *v79;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v77 + 8), v84);
    ++*(_QWORD *)(v77 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((_QWORD *)v82 + 5, (char *)&v142, v143, 4uLL);
  v142 = xmmword_1B351FA80;
  v85 = qword_1ED4DA9C0;
  v87 = (uint64_t **)(qword_1ED4DA9C0 + 8);
  v86 = *(uint64_t **)(qword_1ED4DA9C0 + 8);
  if (v86)
  {
    while (1)
    {
      while (1)
      {
        v88 = (uint64_t **)v86;
        v89 = *((_DWORD *)v86 + 8);
        if (v89 < 0xF)
          break;
        v86 = *v88;
        v87 = v88;
        if (!*v88)
          goto LABEL_126;
      }
      if (v89 == 14)
        break;
      v86 = v88[1];
      if (!v86)
      {
        v87 = v88 + 1;
        goto LABEL_126;
      }
    }
    v90 = v88;
  }
  else
  {
    v88 = (uint64_t **)(qword_1ED4DA9C0 + 8);
LABEL_126:
    v90 = operator new(0x40uLL);
    v90[8] = 14;
    *((_QWORD *)v90 + 6) = 0;
    *((_QWORD *)v90 + 7) = 0;
    *((_QWORD *)v90 + 5) = 0;
    *(_QWORD *)v90 = 0;
    *((_QWORD *)v90 + 1) = 0;
    *((_QWORD *)v90 + 2) = v88;
    *v87 = (uint64_t *)v90;
    v91 = **(_QWORD **)v85;
    v92 = (uint64_t *)v90;
    if (v91)
    {
      *(_QWORD *)v85 = v91;
      v92 = *v87;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v85 + 8), v92);
    ++*(_QWORD *)(v85 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((_QWORD *)v90 + 5, (char *)&v142, v143, 4uLL);
  v142 = xmmword_1B351FA90;
  v93 = qword_1ED4DA9C0;
  v95 = (uint64_t **)(qword_1ED4DA9C0 + 8);
  v94 = *(uint64_t **)(qword_1ED4DA9C0 + 8);
  if (v94)
  {
    while (1)
    {
      while (1)
      {
        v96 = (uint64_t **)v94;
        v97 = *((_DWORD *)v94 + 8);
        if (v97 < 7)
          break;
        v94 = *v96;
        v95 = v96;
        if (!*v96)
          goto LABEL_137;
      }
      if (v97 == 6)
        break;
      v94 = v96[1];
      if (!v94)
      {
        v95 = v96 + 1;
        goto LABEL_137;
      }
    }
    v98 = v96;
  }
  else
  {
    v96 = (uint64_t **)(qword_1ED4DA9C0 + 8);
LABEL_137:
    v98 = operator new(0x40uLL);
    v98[8] = 6;
    *((_QWORD *)v98 + 6) = 0;
    *((_QWORD *)v98 + 7) = 0;
    *((_QWORD *)v98 + 5) = 0;
    *(_QWORD *)v98 = 0;
    *((_QWORD *)v98 + 1) = 0;
    *((_QWORD *)v98 + 2) = v96;
    *v95 = (uint64_t *)v98;
    v99 = **(_QWORD **)v93;
    v100 = (uint64_t *)v98;
    if (v99)
    {
      *(_QWORD *)v93 = v99;
      v100 = *v95;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v93 + 8), v100);
    ++*(_QWORD *)(v93 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((_QWORD *)v98 + 5, (char *)&v142, v143, 4uLL);
  v142 = xmmword_1B351FAA0;
  v101 = qword_1ED4DA9C0;
  v103 = (uint64_t **)(qword_1ED4DA9C0 + 8);
  v102 = *(uint64_t **)(qword_1ED4DA9C0 + 8);
  if (v102)
  {
    while (1)
    {
      while (1)
      {
        v104 = (uint64_t **)v102;
        v105 = *((_DWORD *)v102 + 8);
        if (v105 < 0xB)
          break;
        v102 = *v104;
        v103 = v104;
        if (!*v104)
          goto LABEL_148;
      }
      if (v105 == 10)
        break;
      v102 = v104[1];
      if (!v102)
      {
        v103 = v104 + 1;
        goto LABEL_148;
      }
    }
    v106 = v104;
  }
  else
  {
    v104 = (uint64_t **)(qword_1ED4DA9C0 + 8);
LABEL_148:
    v106 = operator new(0x40uLL);
    v106[8] = 10;
    *((_QWORD *)v106 + 6) = 0;
    *((_QWORD *)v106 + 7) = 0;
    *((_QWORD *)v106 + 5) = 0;
    *(_QWORD *)v106 = 0;
    *((_QWORD *)v106 + 1) = 0;
    *((_QWORD *)v106 + 2) = v104;
    *v103 = (uint64_t *)v106;
    v107 = **(_QWORD **)v101;
    v108 = (uint64_t *)v106;
    if (v107)
    {
      *(_QWORD *)v101 = v107;
      v108 = *v103;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v101 + 8), v108);
    ++*(_QWORD *)(v101 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((_QWORD *)v106 + 5, (char *)&v142, v143, 4uLL);
  v142 = xmmword_1B351FAB0;
  v109 = qword_1ED4DA9C0;
  v111 = (uint64_t **)(qword_1ED4DA9C0 + 8);
  v110 = *(uint64_t **)(qword_1ED4DA9C0 + 8);
  if (v110)
  {
    while (1)
    {
      while (1)
      {
        v112 = (uint64_t **)v110;
        v113 = *((_DWORD *)v110 + 8);
        if (v113 < 3)
          break;
        v110 = *v112;
        v111 = v112;
        if (!*v112)
          goto LABEL_159;
      }
      if (v113 == 2)
        break;
      v110 = v112[1];
      if (!v110)
      {
        v111 = v112 + 1;
        goto LABEL_159;
      }
    }
    v114 = v112;
  }
  else
  {
    v112 = (uint64_t **)(qword_1ED4DA9C0 + 8);
LABEL_159:
    v114 = operator new(0x40uLL);
    v114[8] = 2;
    *((_QWORD *)v114 + 6) = 0;
    *((_QWORD *)v114 + 7) = 0;
    *((_QWORD *)v114 + 5) = 0;
    *(_QWORD *)v114 = 0;
    *((_QWORD *)v114 + 1) = 0;
    *((_QWORD *)v114 + 2) = v112;
    *v111 = (uint64_t *)v114;
    v115 = **(_QWORD **)v109;
    v116 = (uint64_t *)v114;
    if (v115)
    {
      *(_QWORD *)v109 = v115;
      v116 = *v111;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v109 + 8), v116);
    ++*(_QWORD *)(v109 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((_QWORD *)v114 + 5, (char *)&v142, v143, 4uLL);
  v142 = xmmword_1B351FAC0;
  v117 = qword_1ED4DA9C0;
  v119 = (uint64_t **)(qword_1ED4DA9C0 + 8);
  v118 = *(uint64_t **)(qword_1ED4DA9C0 + 8);
  if (v118)
  {
    while (1)
    {
      while (1)
      {
        v120 = (uint64_t **)v118;
        v121 = *((_DWORD *)v118 + 8);
        if (v121 < 0xD)
          break;
        v118 = *v120;
        v119 = v120;
        if (!*v120)
          goto LABEL_170;
      }
      if (v121 == 12)
        break;
      v118 = v120[1];
      if (!v118)
      {
        v119 = v120 + 1;
        goto LABEL_170;
      }
    }
    v122 = v120;
  }
  else
  {
    v120 = (uint64_t **)(qword_1ED4DA9C0 + 8);
LABEL_170:
    v122 = operator new(0x40uLL);
    v122[8] = 12;
    *((_QWORD *)v122 + 6) = 0;
    *((_QWORD *)v122 + 7) = 0;
    *((_QWORD *)v122 + 5) = 0;
    *(_QWORD *)v122 = 0;
    *((_QWORD *)v122 + 1) = 0;
    *((_QWORD *)v122 + 2) = v120;
    *v119 = (uint64_t *)v122;
    v123 = **(_QWORD **)v117;
    v124 = (uint64_t *)v122;
    if (v123)
    {
      *(_QWORD *)v117 = v123;
      v124 = *v119;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v117 + 8), v124);
    ++*(_QWORD *)(v117 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((_QWORD *)v122 + 5, (char *)&v142, v143, 4uLL);
  v142 = xmmword_1B351FAD0;
  v125 = qword_1ED4DA9C0;
  v127 = (uint64_t **)(qword_1ED4DA9C0 + 8);
  v126 = *(uint64_t **)(qword_1ED4DA9C0 + 8);
  if (v126)
  {
    while (1)
    {
      while (1)
      {
        v128 = (uint64_t **)v126;
        v129 = *((_DWORD *)v126 + 8);
        if (v129 < 5)
          break;
        v126 = *v128;
        v127 = v128;
        if (!*v128)
          goto LABEL_181;
      }
      if (v129 == 4)
        break;
      v126 = v128[1];
      if (!v126)
      {
        v127 = v128 + 1;
        goto LABEL_181;
      }
    }
    v130 = v128;
  }
  else
  {
    v128 = (uint64_t **)(qword_1ED4DA9C0 + 8);
LABEL_181:
    v130 = operator new(0x40uLL);
    v130[8] = 4;
    *((_QWORD *)v130 + 6) = 0;
    *((_QWORD *)v130 + 7) = 0;
    *((_QWORD *)v130 + 5) = 0;
    *(_QWORD *)v130 = 0;
    *((_QWORD *)v130 + 1) = 0;
    *((_QWORD *)v130 + 2) = v128;
    *v127 = (uint64_t *)v130;
    v131 = **(_QWORD **)v125;
    v132 = (uint64_t *)v130;
    if (v131)
    {
      *(_QWORD *)v125 = v131;
      v132 = *v127;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v125 + 8), v132);
    ++*(_QWORD *)(v125 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((_QWORD *)v130 + 5, (char *)&v142, v143, 4uLL);
  v142 = xmmword_1B351FAE0;
  v133 = qword_1ED4DA9C0;
  v135 = (uint64_t **)(qword_1ED4DA9C0 + 8);
  v134 = *(uint64_t **)(qword_1ED4DA9C0 + 8);
  if (v134)
  {
    while (1)
    {
      while (1)
      {
        v136 = (uint64_t **)v134;
        v137 = *((_DWORD *)v134 + 8);
        if (v137 < 9)
          break;
        v134 = *v136;
        v135 = v136;
        if (!*v136)
          goto LABEL_192;
      }
      if (v137 == 8)
        break;
      v134 = v136[1];
      if (!v134)
      {
        v135 = v136 + 1;
        goto LABEL_192;
      }
    }
    v138 = v136;
  }
  else
  {
    v136 = (uint64_t **)(qword_1ED4DA9C0 + 8);
LABEL_192:
    v138 = operator new(0x40uLL);
    v138[8] = 8;
    *((_QWORD *)v138 + 6) = 0;
    *((_QWORD *)v138 + 7) = 0;
    *((_QWORD *)v138 + 5) = 0;
    *(_QWORD *)v138 = 0;
    *((_QWORD *)v138 + 1) = 0;
    *((_QWORD *)v138 + 2) = v136;
    *v135 = (uint64_t *)v138;
    v139 = **(_QWORD **)v133;
    v140 = (uint64_t *)v138;
    if (v139)
    {
      *(_QWORD *)v133 = v139;
      v140 = *v135;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v133 + 8), v140);
    ++*(_QWORD *)(v133 + 16);
  }
  return std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((_QWORD *)v138 + 5, (char *)&v142, v143, 4uLL);
}

_QWORD *std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>(_QWORD *result, char *__src, char *a3, size_t __sz)
{
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;
  size_t v14;
  void **v15;
  _BYTE *v16;
  unint64_t v17;
  char *v18;
  void *v19;

  v6 = __src;
  v7 = result;
  v8 = result[2];
  v9 = (char *)*result;
  if (__sz > (v8 - *result) >> 2)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (__sz >> 62)
      goto LABEL_22;
    v10 = v8 >> 1;
    if (v8 >> 1 <= __sz)
      v10 = __sz;
    v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL;
    v12 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v11)
      v12 = v10;
    if (v12 >> 62)
LABEL_22:
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v13 = 4 * v12;
    result = operator new(4 * v12);
    v9 = (char *)result;
    *v7 = result;
    v7[1] = result;
    v7[2] = (char *)result + v13;
    v14 = a3 - v6;
    if (v14)
      result = memcpy(result, v6, v14);
    v15 = (void **)(v7 + 1);
    goto LABEL_21;
  }
  v15 = (void **)(result + 1);
  v16 = (_BYTE *)result[1];
  v17 = (v16 - v9) >> 2;
  if (v17 >= __sz)
  {
    v14 = a3 - __src;
    if (a3 == __src)
      goto LABEL_21;
    v19 = (void *)*result;
LABEL_20:
    result = memmove(v19, __src, v14);
    goto LABEL_21;
  }
  v18 = &__src[4 * v17];
  if (v16 != v9)
  {
    result = memmove((void *)*result, __src, v16 - v9);
    v9 = (char *)*v15;
  }
  v14 = a3 - v18;
  if (v14)
  {
    v19 = v9;
    __src = v18;
    goto LABEL_20;
  }
LABEL_21:
  *v15 = &v9[v14];
  return result;
}

_QWORD *std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>(void **a1, _QWORD *a2)
{
  _BYTE *v3;
  _BYTE *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  _QWORD *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v21;

  v4 = *a1;
  v3 = a1[1];
  v5 = (v3 - (_BYTE *)*a1) >> 3;
  v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) >> 61)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v8 = (_BYTE *)a1[2] - v4;
  if (v8 >> 2 > v6)
    v6 = v8 >> 2;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
    v9 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v9 = v6;
  if (v9)
  {
    if (v9 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v10 = (char *)operator new(8 * v9);
  }
  else
  {
    v10 = 0;
  }
  v11 = &v10[8 * v5];
  *(_QWORD *)v11 = *a2;
  v12 = v11 + 8;
  v13 = &v10[8 * v9];
  *a2 = 0;
  v21 = v13;
  if (v3 != v4)
  {
    v14 = 0;
    do
    {
      v15 = *(_QWORD *)&v3[v14 - 8];
      *(_QWORD *)&v11[v14 - 8] = v15;
      if (v15)
        (*(void (**)(uint64_t))(*(_QWORD *)v15 + 16))(v15);
      v14 -= 8;
    }
    while (&v3[v14] != v4);
    v12 = v11 + 8;
    v13 = v21;
    v11 += v14;
  }
  v16 = (char *)*a1;
  v17 = (char *)a1[1];
  *a1 = v11;
  a1[1] = v12;
  a1[2] = v13;
  while (v17 != v16)
  {
    v19 = *((_QWORD *)v17 - 1);
    v17 -= 8;
    v18 = v19;
    if (v19)
      (*(void (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
  }
  if (v16)
    operator delete(v16);
  return v12;
}

uint64_t std::__split_buffer<HGRef<HGBitmap>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    v5 = *(_QWORD *)(v2 - 8);
    v2 -= 8;
    v4 = v5;
    *(_QWORD *)(a1 + 16) = v2;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
      v2 = *(_QWORD *)(a1 + 16);
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__tree<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::__map_value_compare<HGMetalDeviceInfo const*,std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::less<HGMetalDeviceInfo const*>,true>,std::allocator<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;

  if (a2)
  {
    std::__tree<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::__map_value_compare<HGMetalDeviceInfo const*,std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::less<HGMetalDeviceInfo const*>,true>,std::allocator<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::__map_value_compare<HGMetalDeviceInfo const*,std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::less<HGMetalDeviceInfo const*>,true>,std::allocator<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>>>::destroy(a1, a2[1]);
    v4 = a2[5];
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
    operator delete(a2);
  }
}

_QWORD *std::vector<HGRef<HGPixelBufferObj>>::__push_back_slow_path<HGRef<HGPixelBufferObj>>(void **a1, _QWORD *a2)
{
  _BYTE *v3;
  _BYTE *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  _QWORD *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v21;

  v4 = *a1;
  v3 = a1[1];
  v5 = (v3 - (_BYTE *)*a1) >> 3;
  v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) >> 61)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v8 = (_BYTE *)a1[2] - v4;
  if (v8 >> 2 > v6)
    v6 = v8 >> 2;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
    v9 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v9 = v6;
  if (v9)
  {
    if (v9 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v10 = (char *)operator new(8 * v9);
  }
  else
  {
    v10 = 0;
  }
  v11 = &v10[8 * v5];
  *(_QWORD *)v11 = *a2;
  v12 = v11 + 8;
  v13 = &v10[8 * v9];
  *a2 = 0;
  v21 = v13;
  if (v3 != v4)
  {
    v14 = 0;
    do
    {
      v15 = *(_QWORD *)&v3[v14 - 8];
      *(_QWORD *)&v11[v14 - 8] = v15;
      if (v15)
        (*(void (**)(uint64_t))(*(_QWORD *)v15 + 16))(v15);
      v14 -= 8;
    }
    while (&v3[v14] != v4);
    v12 = v11 + 8;
    v13 = v21;
    v11 += v14;
  }
  v16 = (char *)*a1;
  v17 = (char *)a1[1];
  *a1 = v11;
  a1[1] = v12;
  a1[2] = v13;
  while (v17 != v16)
  {
    v19 = *((_QWORD *)v17 - 1);
    v17 -= 8;
    v18 = v19;
    if (v19)
      (*(void (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
  }
  if (v16)
    operator delete(v16);
  return v12;
}

uint64_t std::__split_buffer<HGRef<HGPixelBufferObj>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    v5 = *(_QWORD *)(v2 - 8);
    v2 -= 8;
    v4 = v5;
    *(_QWORD *)(a1 + 16) = v2;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
      v2 = *(_QWORD *)(a1 + 16);
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*,false>(unint64_t a1, __n128 *a2, uint64_t (**a3)(__n128 *, __n128 *), uint64_t a4, char a5)
{
  __n128 *v8;
  __n128 *v9;
  __n128 *v10;
  unint64_t n128_u64;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  __n128 *v15;
  uint64_t (*v16)(__n128 *, __n128 *);
  char v17;
  int v18;
  __n128 v19;
  __n128 v20;
  __n128 v21;
  __n128 v22;
  __n128 v23;
  __n128 v24;
  __n128 v25;
  __n128 v26;
  __n128 v27;
  __n128 v28;
  __n128 v29;
  __n128 v30;
  char v31;
  int v32;
  __n128 v33;
  __n128 v34;
  __n128 v35;
  __n128 v36;
  __n128 v37;
  __n128 v38;
  __n128 v39;
  __n128 v40;
  __n128 v41;
  __n128 v42;
  __n128 v43;
  __n128 v44;
  __n128 v45;
  __n128 v46;
  __n128 v47;
  __n128 v48;
  __n128 v49;
  __n128 v50;
  __n128 v51;
  __n128 v52;
  __n128 v53;
  __n128 v54;
  __n128 v55;
  __n128 v56;
  __n128 v57;
  __n128 v58;
  __n128 v59;
  __n128 v60;
  __n128 v61;
  __n128 v62;
  __n128 v63;
  __n128 v64;
  __n128 v65;
  __n128 v66;
  __n128 v67;
  __n128 v68;
  __n128 v69;
  __n128 v70;
  __n128 v71;
  __n128 v72;
  __n128 v73;
  __n128 v74;
  __n128 v75;
  __n128 v76;
  __n128 v77;
  __n128 v78;
  __n128 v79;
  __n128 v80;
  __n128 v81;
  __n128 v82;
  __n128 v83;
  __n128 v84;
  __n128 v85;
  __n128 v86;
  __n128 v87;
  __n128 v88;
  __n128 v89;
  __n128 v90;
  __n128 v91;
  __n128 v92;
  __n128 v93;
  __n128 v94;
  __n128 v95;
  __n128 v96;
  __n128 v97;
  __n128 v98;
  __n128 v99;
  __n128 v100;
  __n128 v101;
  __n128 v102;
  __n128 v103;
  __n128 v104;
  __n128 v105;
  __n128 v106;
  __n128 v107;
  __n128 v108;
  __n128 v109;
  __n128 v110;
  __n128 v111;
  __n128 v112;
  __n128 v113;
  __n128 v114;
  __n128 v115;
  __n128 v116;
  __n128 v117;
  __n128 v118;
  __n128 v119;
  __n128 v120;
  __n128 v121;
  __n128 v122;
  __n128 v123;
  __n128 v124;
  __n128 v125;
  __n128 v126;
  __n128 v127;
  __n128 v128;
  __n128 v129;
  __n128 v130;
  __n128 v131;
  __n128 v132;
  __n128 v133;
  __n128 v134;
  __n128 v135;
  __n128 v136;
  __n128 v137;
  __n128 v138;
  __n128 v139;
  __n128 v140;
  __n128 v141;
  __n128 v142;
  __n128 v143;
  __n128 v144;
  __n128 v145;
  __n128 v146;
  __n128 v147;
  __n128 v148;
  __n128 v149;
  __n128 v150;
  __n128 v151;
  __n128 v152;
  __n128 *v153;
  __n128 *v154;
  char v155;
  int v156;
  __n128 v157;
  __n128 v158;
  __n128 v159;
  __n128 v160;
  __n128 v161;
  __n128 v162;
  __n128 v163;
  __n128 v164;
  __n128 v165;
  __n128 v166;
  __n128 v167;
  __n128 v168;
  __n128 v169;
  __n128 v170;
  __n128 v171;
  __n128 v172;
  __n128 v173;
  __n128 v174;
  __n128 v175;
  __n128 v176;
  __n128 v177;
  __n128 v178;
  __n128 v179;
  __n128 v180;
  __n128 v181;
  __n128 v182;
  __n128 v183;
  __n128 v184;
  __n128 v185;
  __n128 v186;
  __n128 v187;
  __n128 v188;
  __n128 v189;
  __n128 v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __n128 v197;
  __n128 v198;
  __n128 v199;
  __n128 v200;
  __n128 v201;
  __n128 v202;
  __n128 v203;
  __n128 v204;
  __n128 v205;
  __n128 v206;
  __n128 v207;
  __n128 v208;
  __n128 v209;
  __n128 v210;
  __n128 v211;
  __n128 v212;
  __n128 v213;
  __n128 v214;
  __n128 v215;
  __n128 v216;
  __n128 v217;
  __n128 v218;
  __n128 v219;
  __n128 v220;
  __n128 v221;
  __n128 v222;
  __n128 v223;
  __n128 v224;
  __n128 v225;
  __n128 v226;
  __n128 v227;
  __n128 v228;
  __n128 v229;
  __n128 v230;
  __n128 v231;
  __n128 v232;
  __n128 v233;
  __n128 v234;
  __n128 v235;
  __n128 v236;
  __n128 v237;
  __n128 v238;
  __n128 v239;
  __n128 v240;
  __n128 v241;
  __n128 v242;
  __n128 v243;
  __int128 v244;
  __int128 v245;
  __int128 v246;
  __int128 v247;
  __int128 v248;
  __int128 v249;
  __n128 v250;
  __n128 v251;
  __n128 v252;
  __n128 v253;
  __n128 v254;
  __n128 v255;
  __n128 v256;
  __n128 v257;
  __n128 v258;
  __n128 v259;
  __n128 v260;
  __n128 v261;
  __n128 v262;
  __n128 v263;
  __n128 v264;
  __n128 v265;
  __n128 v266;
  __n128 v267;
  __n128 v268;
  __n128 v269;
  __n128 v270;
  __n128 v271;
  __n128 v272;
  __n128 v273;
  __n128 *v274;
  __n128 *v275;
  char v276;
  int v277;
  __n128 v278;
  __n128 v279;
  __n128 v280;
  __n128 v281;
  __n128 v282;
  __n128 v283;
  __n128 v284;
  __n128 v285;
  __n128 v286;
  __n128 v287;
  __n128 v288;
  __n128 v289;
  __n128 v290;
  __n128 v291;
  __n128 v292;
  __n128 v293;
  __n128 v294;
  __n128 v295;
  __n128 v296;
  __n128 v297;
  __n128 v298;
  __n128 v299;
  __n128 v300;
  __n128 v301;
  __n128 v302;
  __n128 v303;
  __n128 v304;
  __n128 v305;
  __n128 v306;
  __n128 v307;
  __n128 v308;
  __n128 v309;
  __n128 v310;
  __n128 v311;
  __n128 v312;
  __n128 v313;
  __n128 v314;
  __n128 v315;
  __n128 v316;
  __n128 v317;
  __n128 v318;
  __n128 v319;
  __n128 v320;
  __n128 v321;
  __n128 v322;
  __n128 v323;
  __n128 v324;
  __n128 v325;
  __n128 v326;
  __n128 v327;
  __n128 v328;
  __n128 v329;
  __n128 v330;
  __n128 v331;
  __n128 v332;
  __n128 v333;
  __n128 v334;
  __n128 v335;
  __n128 v336;
  __n128 v337;
  __n128 v338;
  __n128 v339;
  __n128 v340;
  __n128 v341;
  __n128 v342;
  __n128 v343;
  __n128 v344;
  __n128 v345;
  __n128 v346;
  __n128 v347;
  __n128 v348;
  __n128 v349;
  __n128 v350;
  __n128 v351;
  __n128 v352;
  __n128 v353;
  __n128 v354;
  __n128 v355;
  __n128 v356;
  __n128 v357;
  __n128 v358;
  char v359;
  int v360;
  __n128 v361;
  __n128 v362;
  __n128 v363;
  __n128 v364;
  __n128 v365;
  __n128 v366;
  __n128 v367;
  __n128 v368;
  __n128 v369;
  __n128 v370;
  __n128 v371;
  __n128 v372;
  __n128 v373;
  __n128 v374;
  __n128 v375;
  __n128 v376;
  __n128 v377;
  __n128 v378;
  __n128 v379;
  __n128 v380;
  __n128 v381;
  __n128 v382;
  __n128 v383;
  __n128 v384;
  __n128 v385;
  __n128 v386;
  __n128 v387;
  __n128 v388;
  __n128 v389;
  __n128 v390;
  __n128 v391;
  __n128 v392;
  __n128 v393;
  __n128 v394;
  __n128 v395;
  __n128 v396;
  __n128 v397;
  __n128 v398;
  __n128 v399;
  __n128 v400;
  __n128 v401;
  __n128 v402;
  __n128 v403;
  __n128 v404;
  __n128 v405;
  __n128 v406;
  __n128 v407;
  __n128 v408;
  __n128 v409;
  __n128 v410;
  __n128 v411;
  __n128 v412;
  __n128 v413;
  __n128 v414;
  __n128 v415;
  __n128 v416;
  __n128 v417;
  __n128 v418;
  __n128 v419;
  __n128 v420;
  __n128 v421;
  __n128 v422;
  __n128 v423;
  __n128 v424;
  __n128 v425;
  __n128 v426;
  __n128 v427;
  __n128 v428;
  __n128 v429;
  __n128 v430;
  __n128 v431;
  __n128 v432;
  __n128 v433;
  __n128 v434;
  __n128 v435;
  __n128 v436;
  __n128 v437;
  __n128 v438;
  __n128 v439;
  __n128 v440;
  __n128 v441;
  __n128 v442;
  __n128 v443;
  __n128 v444;
  __n128 v445;
  __n128 v446;
  __n128 v447;
  __n128 v448;
  __n128 v449;
  __n128 v450;
  __n128 v451;
  __n128 v452;
  __n128 v453;
  __n128 v454;
  __n128 v455;
  __n128 v456;
  __n128 v457;
  uint64_t v458;
  __n128 v459;
  __n128 v460;
  __n128 v461;
  __n128 v462;
  __n128 v463;
  __n128 v464;
  unint64_t v465;
  __n128 *v466;
  __n128 *v467;
  __n128 *v468;
  __n128 v469;
  __n128 v470;
  __n128 v471;
  __n128 v472;
  __n128 v473;
  __n128 v474;
  __n128 v475;
  __n128 v476;
  __n128 v477;
  __n128 v478;
  __n128 v479;
  __n128 v480;
  __n128 v481;
  __n128 v482;
  __n128 v483;
  __n128 v484;
  __n128 v485;
  __n128 v486;
  __n128 *v487;
  __n128 v488;
  __n128 v489;
  __n128 v490;
  __n128 v491;
  __n128 v492;
  __n128 v493;
  __n128 v494;
  __n128 v495;
  __n128 v496;
  __n128 v497;
  __n128 v498;
  __n128 v499;
  BOOL v500;
  __n128 v501;
  __n128 v502;
  __n128 v503;
  __n128 v504;
  __n128 v505;
  __n128 v506;
  __n128 *v507;
  int v508;
  __n128 *v509;
  __n128 v510;
  __n128 v511;
  __n128 v512;
  __n128 v513;
  __n128 v514;
  __n128 v515;
  __n128 v516;
  __n128 v517;
  __n128 v518;
  __n128 v519;
  __n128 v520;
  __n128 v521;
  __n128 v522;
  __n128 v523;
  __n128 v524;
  __n128 v525;
  __n128 v526;
  __n128 v527;
  __n128 *v528;
  __int128 v529;
  __int128 v530;
  __int128 v531;
  __int128 v532;
  __int128 v533;
  __int128 v534;
  __n128 v535;
  __n128 v536;
  __n128 v537;
  __n128 v538;
  __n128 v539;
  __n128 v540;
  __n128 *v541;
  char v542;
  int v543;
  __n128 v544;
  __n128 v545;
  __n128 v546;
  __n128 v547;
  __n128 v548;
  __n128 v549;
  __n128 v550;
  __n128 v551;
  __n128 v552;
  __n128 v553;
  __n128 v554;
  __n128 v555;
  __n128 v556;
  __n128 v557;
  __n128 v558;
  __n128 v559;
  __n128 v560;
  __n128 v561;
  __n128 *v562;
  __n128 *v563;
  __n128 v564;
  __n128 v565;
  __n128 v566;
  __n128 v567;
  __n128 v568;
  __n128 v569;
  __n128 v570;
  __n128 v571;
  __n128 v572;
  __n128 v573;
  __n128 v574;
  __n128 v575;
  __n128 v576;
  __n128 v577;
  __n128 v578;
  __n128 v579;
  __n128 v580;
  __n128 v581;
  __n128 v582;
  __n128 v583;
  __n128 v584;
  __n128 v585;
  __int128 v586;
  __int128 v587;
  __int128 v588;
  __int128 v589;
  __n128 v590;
  __n128 v591;
  __n128 v592;
  __n128 v593;
  __n128 v594;
  __n128 v595;
  __n128 v596;
  __n128 v597;
  __int128 v598;
  __int128 v599;
  __int128 v600;
  __int128 v601;
  __n128 v602;
  __n128 v603;
  __n128 v604;
  __n128 v605;
  __n128 *v606;
  BOOL v608;
  uint64_t v609;
  __n128 *v610;
  __n128 *v611;
  __n128 v612;
  __n128 v613;
  __n128 v614;
  __n128 v615;
  __n128 v616;
  __n128 v617;
  __n128 *v618;
  __n128 v619;
  __n128 v620;
  __n128 v621;
  __n128 v622;
  __n128 v623;
  __n128 v624;
  uint64_t v625;
  _OWORD *v626;
  __int128 v627;
  __int128 v628;
  __int128 v629;
  __int128 v630;
  __n128 v631;
  __n128 v632;
  __n128 v633;
  __n128 v634;
  __n128 v635;
  __n128 v636;
  __n128 v637;
  __n128 v638;
  __n128 v639;
  __n128 v640;
  __n128 v641;
  __n128 v642;
  __n128 v643;
  __n128 v644;
  __n128 v645;
  __n128 v646;
  __n128 v647;
  __n128 v648;
  __n128 v649;
  __n128 v650;
  __n128 v651;
  __n128 v652;
  __n128 v653;
  __n128 v654;
  __n128 v655;
  __n128 v656;
  __n128 v657;
  __n128 v658;
  __n128 v659;
  __n128 v660;
  __n128 v661;
  __n128 v662;
  __n128 *v663;
  __n128 *v664;
  __n128 v665;
  __n128 v666;
  __n128 v667;
  __n128 v668;
  __n128 v669;
  __n128 v670;
  __n128 *v671;
  __n128 v672;
  __n128 v673;
  __n128 v674;
  __n128 v675;
  char v676;
  __n128 v677;
  __n128 v678;
  __n128 v679;
  __n128 v680;
  __n128 v681;
  __n128 v682;
  __n128 v683;
  __n128 v684;
  __n128 v685;
  __n128 v686;
  __n128 v687;
  __n128 v688;
  __int128 v689;
  __int128 v690;
  __int128 v691;
  __int128 v692;
  __int128 v693;
  __n128 v694;
  __n128 v695;
  __n128 v696;
  __n128 v697;
  __n128 v698;
  __n128 v699;
  __n128 v700;
  __n128 v701;
  __n128 v702;
  __n128 v703;
  __n128 v704;
  __n128 v705;
  __n128 v706;
  __n128 v707;
  __n128 v708;
  __n128 *v709;
  __n128 v712;
  __n128 v713;
  __n128 v714;
  __n128 v715;
  __n128 v716;
  __n128 v717;
  __n128 v718;
  __n128 v719;
  __n128 v720;
  __n128 v721;
  __n128 v722;
  __n128 v723;
  __n128 v724;
  __n128 v725;
  __n128 v726;
  __n128 v727;
  __n128 v728;
  __n128 v729;

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*>(__n128 *a1, __n128 *a2, uint64_t (**a3)(__n128 *, __n128 *))
{
  unint64_t v6;
  _BOOL8 result;
  __n128 *v8;
  __n128 v9;
  __n128 v10;
  __n128 v11;
  __n128 v12;
  __n128 v13;
  __n128 v14;
  __n128 v15;
  __n128 v16;
  __n128 v17;
  __n128 v18;
  __n128 v19;
  __n128 v20;
  __n128 v21;
  __n128 v22;
  __n128 *v23;
  __n128 *v24;
  char v25;
  int v26;
  __n128 v27;
  __n128 v28;
  __n128 v29;
  __n128 v30;
  __n128 v31;
  __n128 v32;
  __n128 v33;
  __n128 v34;
  __n128 v35;
  __n128 v36;
  __n128 *v37;
  __n128 *v38;
  __n128 *v39;
  __n128 v40;
  __n128 v41;
  __n128 v42;
  __n128 v43;
  __n128 v44;
  __n128 v45;
  __n128 v46;
  __n128 v47;
  __n128 v48;
  __n128 v49;
  __n128 v50;
  __n128 v51;
  __n128 v52;
  __n128 v53;
  __n128 v54;
  __n128 v55;
  __n128 v56;
  __n128 v57;
  __n128 v58;
  __n128 v59;
  __n128 v60;
  __n128 v61;
  __n128 v62;
  __n128 v63;
  __n128 v64;
  __n128 v65;
  __n128 v66;
  __n128 v67;
  __n128 v68;
  __n128 v69;
  __n128 v70;
  __n128 v71;
  __n128 v72;
  __n128 v73;
  __n128 v74;
  __n128 v75;
  __n128 v76;
  __n128 v77;
  __n128 v78;
  __n128 *v79;
  __n128 *v80;
  char v81;
  int v82;
  __n128 v83;
  __n128 v84;
  __n128 v85;
  __n128 v86;
  __n128 v87;
  __n128 v88;
  __n128 v89;
  __n128 v90;
  __n128 v91;
  __n128 v92;
  __n128 v93;
  __n128 v94;
  __n128 v95;
  __n128 v96;
  __n128 v97;
  __n128 v98;
  __n128 v99;
  __n128 v100;
  __n128 v101;
  __n128 v102;
  __n128 v103;
  __n128 v104;
  __n128 v105;
  __n128 v106;
  __n128 v107;
  __n128 v108;
  __n128 v109;
  __n128 v110;
  __n128 v111;
  __n128 v112;
  __n128 v113;
  __n128 v114;
  __n128 v115;
  __n128 v116;
  __n128 v117;
  __n128 v118;
  __n128 v119;
  __n128 v120;
  __n128 v121;
  __n128 v122;
  __n128 v123;
  __n128 v124;
  __n128 v125;
  __n128 v126;
  __n128 v127;
  __n128 v128;
  __n128 v129;
  __n128 v130;
  __n128 v131;
  __n128 v132;
  __n128 v133;
  __n128 v134;
  __n128 v135;
  __n128 v136;
  __n128 v137;
  __n128 v138;
  __n128 v139;
  __n128 v140;
  __n128 v141;
  __n128 v142;
  __n128 v143;
  __n128 v144;
  __n128 v145;
  __n128 v146;
  __n128 v147;
  __n128 v148;
  __n128 v149;
  __n128 v150;
  __n128 v151;
  __n128 v152;
  __n128 v153;
  __n128 v154;
  __n128 v155;
  __n128 v156;
  __n128 v157;
  __n128 v158;
  __n128 v159;
  __n128 v160;
  __n128 v161;
  __n128 v162;
  __n128 v163;
  __n128 v164;
  __n128 v165;
  __n128 v166;
  __n128 v167;
  __n128 v168;
  __n128 v169;
  __n128 v170;
  __n128 v171;
  __n128 v172;
  __n128 v173;
  __n128 v174;
  __n128 v175;
  __n128 v176;
  __n128 v177;
  __n128 v178;
  __n128 v179;
  __n128 v180;
  __n128 v181;
  __n128 v182;
  __n128 v183;
  __n128 v184;
  __n128 v185;
  __n128 v186;
  __n128 v187;
  __n128 v188;
  __n128 v189;
  __n128 v190;
  __n128 *v191;
  uint64_t v192;
  int v193;
  __n128 *v194;
  __n128 v195;
  __n128 v196;
  __n128 v197;
  __n128 v198;
  __n128 v199;
  __n128 v200;
  __n128 v201;
  __n128 v202;
  uint64_t v203;
  __n128 *v204;
  __n128 v205;
  __n128 v206;
  __n128 v207;
  __n128 v208;
  __n128 v209;
  __n128 v210;
  __n128 v211;
  __n128 v212;
  __n128 v213;
  __n128 v214;
  __n128 v215;
  __n128 v216;
  __n128 v217;

  v6 = 0x8E38E38E38E38E39 * (a2 - a1);
  result = 1;
  switch(v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v8 = a2 - 9;
      if (!(*a3)(a2 - 9, a1))
        return 1;
      v9 = a1[7];
      v215 = a1[6];
      v216 = v9;
      v217 = a1[8];
      v10 = a1[3];
      v211 = a1[2];
      v212 = v10;
      v11 = a1[5];
      v213 = a1[4];
      v214 = v11;
      v12 = a1[1];
      v209 = *a1;
      v210 = v12;
      *a1 = *v8;
      v13 = a2[-8];
      v14 = a2[-7];
      v15 = a2[-5];
      a1[3] = a2[-6];
      a1[4] = v15;
      a1[1] = v13;
      a1[2] = v14;
      v16 = a2[-4];
      v17 = a2[-3];
      v18 = a2[-1];
      a1[7] = a2[-2];
      a1[8] = v18;
      a1[5] = v16;
      a1[6] = v17;
      v19 = v216;
      a2[-3] = v215;
      a2[-2] = v19;
      a2[-1] = v217;
      v20 = v212;
      a2[-7] = v211;
      a2[-6] = v20;
      v21 = v214;
      a2[-5] = v213;
      a2[-4] = v21;
      v22 = v210;
      result = 1;
      *v8 = v209;
      a2[-8] = v22;
      return result;
    case 3uLL:
      v23 = a1 + 9;
      v24 = a2 - 9;
      v25 = (*a3)(a1 + 9, a1);
      v26 = (*a3)(v24, a1 + 9);
      if ((v25 & 1) == 0)
      {
        if (!v26)
          return 1;
        v91 = a1[16];
        v215 = a1[15];
        v216 = v91;
        v217 = a1[17];
        v92 = a1[12];
        v211 = a1[11];
        v212 = v92;
        v93 = a1[14];
        v213 = a1[13];
        v214 = v93;
        v94 = a1[10];
        v209 = *v23;
        v210 = v94;
        *v23 = *v24;
        v95 = v24[1];
        v96 = v24[2];
        v97 = v24[4];
        a1[12] = v24[3];
        a1[13] = v97;
        a1[10] = v95;
        a1[11] = v96;
        v98 = v24[5];
        v99 = v24[6];
        v100 = v24[8];
        a1[16] = v24[7];
        a1[17] = v100;
        a1[14] = v98;
        a1[15] = v99;
        v101 = v216;
        v24[6] = v215;
        v24[7] = v101;
        v24[8] = v217;
        v102 = v212;
        v24[2] = v211;
        v24[3] = v102;
        v103 = v214;
        v24[4] = v213;
        v24[5] = v103;
        v104 = v210;
        *v24 = v209;
        v24[1] = v104;
        goto LABEL_17;
      }
      if (v26)
      {
        v27 = a1[7];
        v215 = a1[6];
        v216 = v27;
        v217 = a1[8];
        v28 = a1[3];
        v211 = a1[2];
        v212 = v28;
        v29 = a1[5];
        v213 = a1[4];
        v214 = v29;
        v30 = a1[1];
        v209 = *a1;
        v210 = v30;
        *a1 = *v24;
        v31 = v24[1];
        v32 = v24[2];
        v33 = v24[4];
        a1[3] = v24[3];
        a1[4] = v33;
        a1[1] = v31;
        a1[2] = v32;
        v34 = v24[5];
        v35 = v24[6];
        v36 = v24[8];
        a1[7] = v24[7];
        a1[8] = v36;
        a1[5] = v34;
        a1[6] = v35;
      }
      else
      {
        v141 = a1[7];
        v215 = a1[6];
        v216 = v141;
        v217 = a1[8];
        v142 = a1[3];
        v211 = a1[2];
        v212 = v142;
        v143 = a1[5];
        v213 = a1[4];
        v214 = v143;
        v144 = a1[1];
        v209 = *a1;
        v210 = v144;
        v145 = a1[14];
        a1[4] = a1[13];
        a1[5] = v145;
        v146 = a1[16];
        a1[6] = a1[15];
        a1[7] = v146;
        a1[8] = a1[17];
        v147 = a1[12];
        a1[2] = a1[11];
        a1[3] = v147;
        v148 = a1[10];
        *a1 = *v23;
        a1[1] = v148;
        v149 = v214;
        a1[13] = v213;
        a1[14] = v149;
        v150 = v216;
        a1[15] = v215;
        a1[16] = v150;
        a1[17] = v217;
        v151 = v212;
        a1[11] = v211;
        a1[12] = v151;
        v152 = v210;
        *v23 = v209;
        a1[10] = v152;
        if (!(*a3)(v24, a1 + 9))
          return 1;
        v153 = a1[16];
        v215 = a1[15];
        v216 = v153;
        v217 = a1[17];
        v154 = a1[12];
        v211 = a1[11];
        v212 = v154;
        v155 = a1[14];
        v213 = a1[13];
        v214 = v155;
        v156 = a1[10];
        v209 = *v23;
        v210 = v156;
        *v23 = *v24;
        v157 = v24[1];
        v158 = v24[2];
        v159 = v24[4];
        a1[12] = v24[3];
        a1[13] = v159;
        a1[10] = v157;
        a1[11] = v158;
        v160 = v24[5];
        v161 = v24[6];
        v162 = v24[8];
        a1[16] = v24[7];
        a1[17] = v162;
        a1[14] = v160;
        a1[15] = v161;
      }
      v163 = v216;
      v24[6] = v215;
      v24[7] = v163;
      v24[8] = v217;
      v164 = v212;
      v24[2] = v211;
      v24[3] = v164;
      v165 = v214;
      v24[4] = v213;
      v24[5] = v165;
      v166 = v210;
      result = 1;
      *v24 = v209;
      v24[1] = v166;
      return result;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*>(a1, a1 + 9, a1 + 18, a2 - 9, a3);
      return 1;
    case 5uLL:
      v23 = a1 + 9;
      v37 = a1 + 18;
      v38 = a1 + 27;
      v39 = a2 - 9;
      v40 = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*>(a1, a1 + 9, a1 + 18, a1 + 27, a3);
      if (!((unsigned int (*)(__n128 *, __n128 *, __n128))*a3)(v39, &a1[27], v40))
        return 1;
      v41 = a1[34];
      v215 = a1[33];
      v216 = v41;
      v217 = a1[35];
      v42 = a1[30];
      v211 = a1[29];
      v212 = v42;
      v43 = a1[32];
      v213 = a1[31];
      v214 = v43;
      v44 = a1[28];
      v209 = *v38;
      v210 = v44;
      *v38 = *v39;
      v45 = v39[1];
      v46 = v39[2];
      v47 = v39[4];
      a1[30] = v39[3];
      a1[31] = v47;
      a1[28] = v45;
      a1[29] = v46;
      v48 = v39[5];
      v49 = v39[6];
      v50 = v39[8];
      a1[34] = v39[7];
      a1[35] = v50;
      a1[32] = v48;
      a1[33] = v49;
      v51 = v216;
      v39[6] = v215;
      v39[7] = v51;
      v39[8] = v217;
      v52 = v212;
      v39[2] = v211;
      v39[3] = v52;
      v53 = v214;
      v39[4] = v213;
      v39[5] = v53;
      v54 = v210;
      *v39 = v209;
      v39[1] = v54;
      if (!(*a3)(a1 + 27, a1 + 18))
        return 1;
      v55 = a1[25];
      v215 = a1[24];
      v216 = v55;
      v217 = a1[26];
      v56 = a1[21];
      v211 = a1[20];
      v212 = v56;
      v57 = a1[23];
      v213 = a1[22];
      v214 = v57;
      v58 = a1[19];
      v209 = *v37;
      v210 = v58;
      v59 = a1[32];
      a1[22] = a1[31];
      a1[23] = v59;
      v60 = a1[34];
      a1[24] = a1[33];
      a1[25] = v60;
      a1[26] = a1[35];
      v61 = a1[30];
      a1[20] = a1[29];
      a1[21] = v61;
      v62 = a1[28];
      *v37 = *v38;
      a1[19] = v62;
      v63 = v214;
      a1[31] = v213;
      a1[32] = v63;
      v64 = v216;
      a1[33] = v215;
      a1[34] = v64;
      a1[35] = v217;
      v65 = v212;
      a1[29] = v211;
      a1[30] = v65;
      v66 = v210;
      *v38 = v209;
      a1[28] = v66;
      if (!(*a3)(a1 + 18, a1 + 9))
        return 1;
      v67 = a1[16];
      v215 = a1[15];
      v216 = v67;
      v217 = a1[17];
      v68 = a1[12];
      v211 = a1[11];
      v212 = v68;
      v69 = a1[14];
      v213 = a1[13];
      v214 = v69;
      v70 = a1[10];
      v209 = *v23;
      v210 = v70;
      v71 = a1[23];
      a1[13] = a1[22];
      a1[14] = v71;
      v72 = a1[25];
      a1[15] = a1[24];
      a1[16] = v72;
      a1[17] = a1[26];
      v73 = a1[21];
      a1[11] = a1[20];
      a1[12] = v73;
      v74 = a1[19];
      *v23 = *v37;
      a1[10] = v74;
      v75 = v214;
      a1[22] = v213;
      a1[23] = v75;
      v76 = v216;
      a1[24] = v215;
      a1[25] = v76;
      a1[26] = v217;
      v77 = v212;
      a1[20] = v211;
      a1[21] = v77;
      v78 = v210;
      *v37 = v209;
      a1[19] = v78;
LABEL_17:
      if (!(*a3)(v23, a1))
        return 1;
      v105 = a1[7];
      v215 = a1[6];
      v216 = v105;
      v217 = a1[8];
      v106 = a1[3];
      v211 = a1[2];
      v212 = v106;
      v107 = a1[5];
      v213 = a1[4];
      v214 = v107;
      v108 = a1[1];
      v209 = *a1;
      v210 = v108;
      v109 = v23[5];
      a1[4] = v23[4];
      a1[5] = v109;
      v110 = v23[7];
      a1[6] = v23[6];
      a1[7] = v110;
      a1[8] = v23[8];
      v111 = v23[3];
      a1[2] = v23[2];
      a1[3] = v111;
      v112 = v23[1];
      *a1 = *v23;
      a1[1] = v112;
      v113 = v214;
      v23[4] = v213;
      v23[5] = v113;
      v114 = v216;
      v23[6] = v215;
      v23[7] = v114;
      v23[8] = v217;
      v115 = v212;
      v23[2] = v211;
      v23[3] = v115;
      v116 = v210;
      result = 1;
      *v23 = v209;
      v23[1] = v116;
      return result;
    default:
      v79 = a1 + 18;
      v80 = a1 + 9;
      v81 = (*a3)(a1 + 9, a1);
      v82 = (*a3)(a1 + 18, a1 + 9);
      if ((v81 & 1) != 0)
      {
        if (v82)
        {
          v83 = a1[7];
          v215 = a1[6];
          v216 = v83;
          v217 = a1[8];
          v84 = a1[3];
          v211 = a1[2];
          v212 = v84;
          v85 = a1[5];
          v213 = a1[4];
          v214 = v85;
          v86 = a1[1];
          v209 = *a1;
          v210 = v86;
          v87 = a1[23];
          a1[4] = a1[22];
          a1[5] = v87;
          v88 = a1[25];
          a1[6] = a1[24];
          a1[7] = v88;
          a1[8] = a1[26];
          v89 = a1[21];
          a1[2] = a1[20];
          a1[3] = v89;
          v90 = a1[19];
          *a1 = *v79;
          a1[1] = v90;
        }
        else
        {
          v167 = a1[7];
          v215 = a1[6];
          v216 = v167;
          v217 = a1[8];
          v168 = a1[3];
          v211 = a1[2];
          v212 = v168;
          v169 = a1[5];
          v213 = a1[4];
          v214 = v169;
          v170 = a1[1];
          v209 = *a1;
          v210 = v170;
          v171 = a1[14];
          a1[4] = a1[13];
          a1[5] = v171;
          v172 = a1[16];
          a1[6] = a1[15];
          a1[7] = v172;
          a1[8] = a1[17];
          v173 = a1[12];
          a1[2] = a1[11];
          a1[3] = v173;
          v174 = a1[10];
          *a1 = *v80;
          a1[1] = v174;
          v175 = v214;
          a1[13] = v213;
          a1[14] = v175;
          v176 = v216;
          a1[15] = v215;
          a1[16] = v176;
          a1[17] = v217;
          v177 = v212;
          a1[11] = v211;
          a1[12] = v177;
          v178 = v210;
          *v80 = v209;
          a1[10] = v178;
          if (!(*a3)(a1 + 18, a1 + 9))
            goto LABEL_28;
          v179 = a1[16];
          v215 = a1[15];
          v216 = v179;
          v217 = a1[17];
          v180 = a1[12];
          v211 = a1[11];
          v212 = v180;
          v181 = a1[14];
          v213 = a1[13];
          v214 = v181;
          v182 = a1[10];
          v209 = *v80;
          v210 = v182;
          v183 = a1[23];
          a1[13] = a1[22];
          a1[14] = v183;
          v184 = a1[25];
          a1[15] = a1[24];
          a1[16] = v184;
          a1[17] = a1[26];
          v185 = a1[21];
          a1[11] = a1[20];
          a1[12] = v185;
          v186 = a1[19];
          *v80 = *v79;
          a1[10] = v186;
        }
        v187 = v214;
        a1[22] = v213;
        a1[23] = v187;
        v188 = v216;
        a1[24] = v215;
        a1[25] = v188;
        a1[26] = v217;
        v189 = v212;
        a1[20] = v211;
        a1[21] = v189;
        v190 = v210;
        *v79 = v209;
        a1[19] = v190;
      }
      else if (v82)
      {
        v117 = a1[16];
        v215 = a1[15];
        v216 = v117;
        v217 = a1[17];
        v118 = a1[12];
        v211 = a1[11];
        v212 = v118;
        v119 = a1[14];
        v213 = a1[13];
        v214 = v119;
        v120 = a1[10];
        v209 = *v80;
        v210 = v120;
        v121 = a1[23];
        a1[13] = a1[22];
        a1[14] = v121;
        v122 = a1[25];
        a1[15] = a1[24];
        a1[16] = v122;
        a1[17] = a1[26];
        v123 = a1[21];
        a1[11] = a1[20];
        a1[12] = v123;
        v124 = a1[19];
        *v80 = *v79;
        a1[10] = v124;
        v125 = v214;
        a1[22] = v213;
        a1[23] = v125;
        v126 = v216;
        a1[24] = v215;
        a1[25] = v126;
        a1[26] = v217;
        v127 = v212;
        a1[20] = v211;
        a1[21] = v127;
        v128 = v210;
        *v79 = v209;
        a1[19] = v128;
        if ((*a3)(a1 + 9, a1))
        {
          v129 = a1[7];
          v215 = a1[6];
          v216 = v129;
          v217 = a1[8];
          v130 = a1[3];
          v211 = a1[2];
          v212 = v130;
          v131 = a1[5];
          v213 = a1[4];
          v214 = v131;
          v132 = a1[1];
          v209 = *a1;
          v210 = v132;
          v133 = a1[14];
          a1[4] = a1[13];
          a1[5] = v133;
          v134 = a1[16];
          a1[6] = a1[15];
          a1[7] = v134;
          a1[8] = a1[17];
          v135 = a1[12];
          a1[2] = a1[11];
          a1[3] = v135;
          v136 = a1[10];
          *a1 = *v80;
          a1[1] = v136;
          v137 = v214;
          a1[13] = v213;
          a1[14] = v137;
          v138 = v216;
          a1[15] = v215;
          a1[16] = v138;
          a1[17] = v217;
          v139 = v212;
          a1[11] = v211;
          a1[12] = v139;
          v140 = v210;
          *v80 = v209;
          a1[10] = v140;
        }
      }
LABEL_28:
      v191 = a1 + 27;
      if (&a1[27] == a2)
        return 1;
      v192 = 0;
      v193 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(v191, v79))
    {
      v199 = v191[7];
      v215 = v191[6];
      v216 = v199;
      v217 = v191[8];
      v200 = v191[3];
      v211 = v191[2];
      v212 = v200;
      v201 = v191[5];
      v213 = v191[4];
      v214 = v201;
      v202 = v191[1];
      v203 = v192;
      v209 = *v191;
      v210 = v202;
      do
      {
        v204 = (__n128 *)((char *)a1 + v203);
        v205 = *(__n128 *)((char *)a1 + v203 + 400);
        v204[33] = *(__n128 *)((char *)a1 + v203 + 384);
        v204[34] = v205;
        v204[35] = *(__n128 *)((char *)a1 + v203 + 416);
        v206 = *(__n128 *)((char *)a1 + v203 + 336);
        v204[29] = *(__n128 *)((char *)a1 + v203 + 320);
        v204[30] = v206;
        v207 = *(__n128 *)((char *)a1 + v203 + 368);
        v204[31] = *(__n128 *)((char *)a1 + v203 + 352);
        v204[32] = v207;
        v208 = *(__n128 *)((char *)a1 + v203 + 304);
        v204[27] = *(__n128 *)((char *)a1 + v203 + 288);
        v204[28] = v208;
        if (v203 == -288)
        {
          v194 = a1;
          goto LABEL_31;
        }
        v203 -= 144;
      }
      while (((*a3)(&v209, v204 + 9) & 1) != 0);
      v194 = (__n128 *)((char *)a1 + v203 + 432);
LABEL_31:
      v195 = v216;
      v194[6] = v215;
      v194[7] = v195;
      v194[8] = v217;
      v196 = v212;
      v194[2] = v211;
      v194[3] = v196;
      v197 = v214;
      v194[4] = v213;
      v194[5] = v197;
      v198 = v210;
      ++v193;
      *v194 = v209;
      v194[1] = v198;
      if (v193 == 8)
        return &v191[9] == a2;
    }
    v79 = v191;
    v192 += 144;
    v191 += 9;
    if (v191 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, uint64_t (**a5)(__n128 *, __n128 *))
{
  char v10;
  int v11;
  __n128 v12;
  __n128 v13;
  __n128 v14;
  __n128 v15;
  __n128 v16;
  __n128 v17;
  __n128 v18;
  __n128 v19;
  __n128 v20;
  __n128 v21;
  __n128 v22;
  __n128 v23;
  __n128 v24;
  __n128 v25;
  __n128 v26;
  __n128 v27;
  __n128 v28;
  __n128 v29;
  __n128 v30;
  __n128 v31;
  __n128 v32;
  __n128 v33;
  __n128 v34;
  __n128 v35;
  __n128 v36;
  __n128 v37;
  __n128 v38;
  __n128 v39;
  __n128 v40;
  __n128 v41;
  __n128 result;
  __n128 v43;
  __n128 v44;
  __n128 v45;
  __n128 v46;
  __n128 v47;
  __n128 v48;
  __n128 v49;
  __n128 v50;
  __n128 v51;
  __n128 v52;
  __n128 v53;
  __n128 v54;
  __n128 v55;
  __n128 v56;
  __n128 v57;
  __n128 v58;
  __n128 v59;
  __n128 v60;
  __n128 v61;
  __n128 v62;
  __n128 v63;
  __n128 v64;
  __n128 v65;
  __n128 v66;
  __n128 v67;
  __n128 v68;
  __n128 v69;
  __n128 v70;
  __n128 v71;
  __n128 v72;
  __n128 v73;
  __n128 v74;
  __n128 v75;
  __n128 v76;
  __n128 v77;
  __n128 v78;
  __n128 v79;
  __n128 v80;
  __n128 v81;
  __n128 v82;
  __n128 v83;
  __n128 v84;
  __n128 v85;
  __n128 v86;
  __n128 v87;
  __n128 v88;
  __n128 v89;
  __n128 v90;
  __n128 v91;
  __n128 v92;
  __n128 v93;
  __n128 v94;
  __n128 v95;
  __n128 v96;
  __n128 v97;
  __n128 v98;
  __n128 v99;
  __n128 v100;
  __n128 v101;
  __n128 v102;
  __n128 v103;
  __n128 v104;
  __n128 v105;
  __n128 v106;
  __n128 v107;
  __n128 v108;
  __n128 v109;
  __n128 v110;
  __n128 v111;
  __n128 v112;
  __n128 v113;
  __n128 v114;
  __n128 v115;
  __n128 v116;
  __n128 v117;
  __n128 v118;
  __n128 v119;
  __n128 v120;
  __n128 v121;
  __n128 v122;
  __n128 v123;

  v10 = (*a5)(a2, a1);
  v11 = (*a5)(a3, a2);
  if ((v10 & 1) != 0)
  {
    if (v11)
    {
      v103 = a1[6];
      v110 = a1[7];
      v117 = a1[8];
      v75 = a1[2];
      v82 = a1[3];
      v89 = a1[4];
      v96 = a1[5];
      v61 = *a1;
      v68 = a1[1];
      *a1 = *a3;
      v12 = a3[1];
      v13 = a3[2];
      v14 = a3[4];
      a1[3] = a3[3];
      a1[4] = v14;
      a1[1] = v12;
      a1[2] = v13;
      v15 = a3[5];
      v16 = a3[6];
      v17 = a3[8];
      a1[7] = a3[7];
      a1[8] = v17;
      a1[5] = v15;
      a1[6] = v16;
LABEL_9:
      a3[6] = v103;
      a3[7] = v110;
      a3[8] = v117;
      a3[2] = v75;
      a3[3] = v82;
      a3[4] = v89;
      a3[5] = v96;
      *a3 = v61;
      a3[1] = v68;
      goto LABEL_10;
    }
    v106 = a1[6];
    v113 = a1[7];
    v120 = a1[8];
    v78 = a1[2];
    v85 = a1[3];
    v92 = a1[4];
    v99 = a1[5];
    v64 = *a1;
    v71 = a1[1];
    *a1 = *a2;
    v30 = a2[1];
    v31 = a2[2];
    v32 = a2[4];
    a1[3] = a2[3];
    a1[4] = v32;
    a1[1] = v30;
    a1[2] = v31;
    v33 = a2[5];
    v34 = a2[6];
    v35 = a2[8];
    a1[7] = a2[7];
    a1[8] = v35;
    a1[5] = v33;
    a1[6] = v34;
    a2[6] = v106;
    a2[7] = v113;
    a2[8] = v120;
    a2[2] = v78;
    a2[3] = v85;
    a2[4] = v92;
    a2[5] = v99;
    *a2 = v64;
    a2[1] = v71;
    if ((*a5)(a3, a2))
    {
      v103 = a2[6];
      v110 = a2[7];
      v117 = a2[8];
      v75 = a2[2];
      v82 = a2[3];
      v89 = a2[4];
      v96 = a2[5];
      v61 = *a2;
      v68 = a2[1];
      *a2 = *a3;
      v36 = a3[1];
      v37 = a3[2];
      v38 = a3[4];
      a2[3] = a3[3];
      a2[4] = v38;
      a2[1] = v36;
      a2[2] = v37;
      v39 = a3[5];
      v40 = a3[6];
      v41 = a3[8];
      a2[7] = a3[7];
      a2[8] = v41;
      a2[5] = v39;
      a2[6] = v40;
      goto LABEL_9;
    }
  }
  else if (v11)
  {
    v104 = a2[6];
    v111 = a2[7];
    v118 = a2[8];
    v76 = a2[2];
    v83 = a2[3];
    v90 = a2[4];
    v97 = a2[5];
    v62 = *a2;
    v69 = a2[1];
    *a2 = *a3;
    v18 = a3[1];
    v19 = a3[2];
    v20 = a3[4];
    a2[3] = a3[3];
    a2[4] = v20;
    a2[1] = v18;
    a2[2] = v19;
    v21 = a3[5];
    v22 = a3[6];
    v23 = a3[8];
    a2[7] = a3[7];
    a2[8] = v23;
    a2[5] = v21;
    a2[6] = v22;
    a3[6] = v104;
    a3[7] = v111;
    a3[8] = v118;
    a3[2] = v76;
    a3[3] = v83;
    a3[4] = v90;
    a3[5] = v97;
    *a3 = v62;
    a3[1] = v69;
    if ((*a5)(a2, a1))
    {
      v105 = a1[6];
      v112 = a1[7];
      v119 = a1[8];
      v77 = a1[2];
      v84 = a1[3];
      v91 = a1[4];
      v98 = a1[5];
      v63 = *a1;
      v70 = a1[1];
      *a1 = *a2;
      v24 = a2[1];
      v25 = a2[2];
      v26 = a2[4];
      a1[3] = a2[3];
      a1[4] = v26;
      a1[1] = v24;
      a1[2] = v25;
      v27 = a2[5];
      v28 = a2[6];
      v29 = a2[8];
      a1[7] = a2[7];
      a1[8] = v29;
      a1[5] = v27;
      a1[6] = v28;
      a2[6] = v105;
      a2[7] = v112;
      a2[8] = v119;
      a2[2] = v77;
      a2[3] = v84;
      a2[4] = v91;
      a2[5] = v98;
      *a2 = v63;
      a2[1] = v70;
    }
  }
LABEL_10:
  if ((*a5)(a4, a3))
  {
    v107 = a3[6];
    v114 = a3[7];
    v121 = a3[8];
    v79 = a3[2];
    v86 = a3[3];
    v93 = a3[4];
    v100 = a3[5];
    v65 = *a3;
    v72 = a3[1];
    *a3 = *a4;
    v43 = a4[1];
    v44 = a4[2];
    v45 = a4[4];
    a3[3] = a4[3];
    a3[4] = v45;
    a3[1] = v43;
    a3[2] = v44;
    v46 = a4[5];
    v47 = a4[6];
    v48 = a4[8];
    a3[7] = a4[7];
    a3[8] = v48;
    a3[5] = v46;
    a3[6] = v47;
    a4[6] = v107;
    a4[7] = v114;
    a4[8] = v121;
    a4[2] = v79;
    a4[3] = v86;
    a4[4] = v93;
    a4[5] = v100;
    *a4 = v65;
    a4[1] = v72;
    if ((*a5)(a3, a2))
    {
      v108 = a2[6];
      v115 = a2[7];
      v122 = a2[8];
      v80 = a2[2];
      v87 = a2[3];
      v94 = a2[4];
      v101 = a2[5];
      v66 = *a2;
      v73 = a2[1];
      *a2 = *a3;
      v49 = a3[1];
      v50 = a3[2];
      v51 = a3[4];
      a2[3] = a3[3];
      a2[4] = v51;
      a2[1] = v49;
      a2[2] = v50;
      v52 = a3[5];
      v53 = a3[6];
      v54 = a3[8];
      a2[7] = a3[7];
      a2[8] = v54;
      a2[5] = v52;
      a2[6] = v53;
      a3[6] = v108;
      a3[7] = v115;
      a3[8] = v122;
      a3[2] = v80;
      a3[3] = v87;
      a3[4] = v94;
      a3[5] = v101;
      *a3 = v66;
      a3[1] = v73;
      if ((*a5)(a2, a1))
      {
        v109 = a1[6];
        v116 = a1[7];
        v123 = a1[8];
        v81 = a1[2];
        v88 = a1[3];
        v95 = a1[4];
        v102 = a1[5];
        v67 = *a1;
        v74 = a1[1];
        *a1 = *a2;
        v55 = a2[1];
        v56 = a2[2];
        v57 = a2[4];
        a1[3] = a2[3];
        a1[4] = v57;
        a1[1] = v55;
        a1[2] = v56;
        v58 = a2[5];
        v59 = a2[6];
        v60 = a2[8];
        a1[7] = a2[7];
        a1[8] = v60;
        a1[5] = v58;
        a1[6] = v59;
        a2[6] = v109;
        a2[7] = v116;
        a2[8] = v123;
        a2[2] = v81;
        a2[3] = v88;
        a2[4] = v95;
        a2[5] = v102;
        result = v74;
        *a2 = v67;
        a2[1] = v74;
      }
    }
  }
  return result;
}

char *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*,HGROIsInfo*>(char *a1, char *a2, char *a3, unsigned int (**a4)(char *, __int128 *))
{
  uint64_t v4;
  uint64_t v5;
  char *v8;
  char *v9;
  unint64_t v10;
  char *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  char *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  unsigned int v47;
  char *v48;
  int64_t v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  char *v54;
  unsigned int v55;
  char *v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  uint64_t v63;
  int64_t v64;
  BOOL v65;
  uint64_t v66;
  char *v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  uint64_t v83;
  unint64_t v84;
  char *v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  char *v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  int64_t v104;
  int64_t v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  uint64_t v112;
  char *v113;
  char *v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  char *v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  char *v129;
  char *v131;
  uint64_t v132;
  char *v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  uint64_t v152;
  uint64_t v153;

  if (a1 == a2)
    return a3;
  v152 = v4;
  v153 = v5;
  v129 = a3;
  v132 = 0x8E38E38E38E38E39 * ((a2 - a1) >> 4);
  v128 = a2 - a1;
  if (a2 - a1 >= 145 && (unint64_t)v128 >= 0x120)
  {
    v104 = (unint64_t)(v132 - 2) >> 1;
    v105 = v104;
    do
    {
      if (v104 >= v105)
      {
        v112 = (2 * v105) | 1;
        v113 = &a1[144 * v112];
        if (2 * v105 + 2 < v132 && (*a4)(&a1[144 * v112], (__int128 *)v113 + 9))
        {
          v113 += 144;
          v112 = 2 * v105 + 2;
        }
        v114 = &a1[144 * v105];
        if ((((uint64_t (*)(char *, char *))*a4)(v113, v114) & 1) == 0)
        {
          v115 = *((_OWORD *)v114 + 7);
          v149 = *((_OWORD *)v114 + 6);
          v150 = v115;
          v151 = *((_OWORD *)v114 + 8);
          v116 = *((_OWORD *)v114 + 3);
          v145 = *((_OWORD *)v114 + 2);
          v146 = v116;
          v117 = *((_OWORD *)v114 + 5);
          v147 = *((_OWORD *)v114 + 4);
          v148 = v117;
          v118 = *((_OWORD *)v114 + 1);
          v143 = *(_OWORD *)v114;
          v144 = v118;
          do
          {
            v119 = v113;
            *(_OWORD *)v114 = *(_OWORD *)v113;
            v120 = *((_OWORD *)v113 + 1);
            v121 = *((_OWORD *)v113 + 2);
            v122 = *((_OWORD *)v113 + 4);
            *((_OWORD *)v114 + 3) = *((_OWORD *)v113 + 3);
            *((_OWORD *)v114 + 4) = v122;
            *((_OWORD *)v114 + 1) = v120;
            *((_OWORD *)v114 + 2) = v121;
            v123 = *((_OWORD *)v113 + 5);
            v124 = *((_OWORD *)v113 + 6);
            v125 = *((_OWORD *)v113 + 8);
            *((_OWORD *)v114 + 7) = *((_OWORD *)v113 + 7);
            *((_OWORD *)v114 + 8) = v125;
            *((_OWORD *)v114 + 5) = v123;
            *((_OWORD *)v114 + 6) = v124;
            if (v104 < v112)
              break;
            v126 = (2 * v112) | 1;
            v113 = &a1[144 * v126];
            v127 = 2 * v112 + 2;
            if (v127 < v132 && (*a4)(&a1[144 * v126], (__int128 *)v113 + 9))
            {
              v113 += 144;
              v126 = v127;
            }
            v114 = v119;
            v112 = v126;
          }
          while (!(*a4)(v113, &v143));
          *(_OWORD *)v119 = v143;
          v106 = v144;
          v107 = v145;
          v108 = v147;
          *((_OWORD *)v119 + 3) = v146;
          *((_OWORD *)v119 + 4) = v108;
          *((_OWORD *)v119 + 1) = v106;
          *((_OWORD *)v119 + 2) = v107;
          v109 = v148;
          v110 = v149;
          v111 = v151;
          *((_OWORD *)v119 + 7) = v150;
          *((_OWORD *)v119 + 8) = v111;
          *((_OWORD *)v119 + 5) = v109;
          *((_OWORD *)v119 + 6) = v110;
        }
      }
      v65 = v105-- <= 0;
    }
    while (!v65);
  }
  v8 = v129;
  v9 = a2;
  a3 = a2;
  v10 = v128;
  if (a2 != v129)
  {
    if (v128 < 288)
    {
      v11 = a2;
      do
      {
        if (((unsigned int (*)(char *, char *, char *))*a4)(v11, a1, a3))
        {
          v12 = *((_OWORD *)v11 + 7);
          v149 = *((_OWORD *)v11 + 6);
          v150 = v12;
          v151 = *((_OWORD *)v11 + 8);
          v13 = *((_OWORD *)v11 + 3);
          v145 = *((_OWORD *)v11 + 2);
          v146 = v13;
          v14 = *((_OWORD *)v11 + 5);
          v147 = *((_OWORD *)v11 + 4);
          v148 = v14;
          v15 = *((_OWORD *)v11 + 1);
          v143 = *(_OWORD *)v11;
          v144 = v15;
          *(_OWORD *)v11 = *(_OWORD *)a1;
          v16 = *((_OWORD *)a1 + 1);
          v17 = *((_OWORD *)a1 + 2);
          v18 = *((_OWORD *)a1 + 4);
          *((_OWORD *)v11 + 3) = *((_OWORD *)a1 + 3);
          *((_OWORD *)v11 + 4) = v18;
          *((_OWORD *)v11 + 1) = v16;
          *((_OWORD *)v11 + 2) = v17;
          v19 = *((_OWORD *)a1 + 5);
          v20 = *((_OWORD *)a1 + 6);
          v21 = *((_OWORD *)a1 + 8);
          *((_OWORD *)v11 + 7) = *((_OWORD *)a1 + 7);
          *((_OWORD *)v11 + 8) = v21;
          *((_OWORD *)v11 + 5) = v19;
          *((_OWORD *)v11 + 6) = v20;
          v22 = v150;
          *((_OWORD *)a1 + 6) = v149;
          *((_OWORD *)a1 + 7) = v22;
          *((_OWORD *)a1 + 8) = v151;
          v23 = v146;
          *((_OWORD *)a1 + 2) = v145;
          *((_OWORD *)a1 + 3) = v23;
          v24 = v148;
          *((_OWORD *)a1 + 4) = v147;
          *((_OWORD *)a1 + 5) = v24;
          v25 = v144;
          *(_OWORD *)a1 = v143;
          *((_OWORD *)a1 + 1) = v25;
        }
        v11 += 144;
      }
      while (v11 != v129);
      a3 = v129;
      goto LABEL_32;
    }
    v26 = a1 + 144;
    while (1)
    {
      if (((unsigned int (*)(char *, char *, char *))*a4)(v9, a1, a3))
      {
        v33 = *((_OWORD *)v9 + 7);
        v149 = *((_OWORD *)v9 + 6);
        v150 = v33;
        v151 = *((_OWORD *)v9 + 8);
        v34 = *((_OWORD *)v9 + 3);
        v145 = *((_OWORD *)v9 + 2);
        v146 = v34;
        v35 = *((_OWORD *)v9 + 5);
        v147 = *((_OWORD *)v9 + 4);
        v148 = v35;
        v36 = *((_OWORD *)v9 + 1);
        v143 = *(_OWORD *)v9;
        v144 = v36;
        *(_OWORD *)v9 = *(_OWORD *)a1;
        v37 = *((_OWORD *)a1 + 1);
        v38 = *((_OWORD *)a1 + 2);
        v39 = *((_OWORD *)a1 + 4);
        *((_OWORD *)v9 + 3) = *((_OWORD *)a1 + 3);
        *((_OWORD *)v9 + 4) = v39;
        *((_OWORD *)v9 + 1) = v37;
        *((_OWORD *)v9 + 2) = v38;
        v40 = *((_OWORD *)a1 + 5);
        v41 = *((_OWORD *)a1 + 6);
        v42 = *((_OWORD *)a1 + 8);
        *((_OWORD *)v9 + 7) = *((_OWORD *)a1 + 7);
        *((_OWORD *)v9 + 8) = v42;
        *((_OWORD *)v9 + 5) = v40;
        *((_OWORD *)v9 + 6) = v41;
        v43 = v150;
        *((_OWORD *)a1 + 6) = v149;
        *((_OWORD *)a1 + 7) = v43;
        *((_OWORD *)a1 + 8) = v151;
        v44 = v146;
        *((_OWORD *)a1 + 2) = v145;
        *((_OWORD *)a1 + 3) = v44;
        v45 = v148;
        *((_OWORD *)a1 + 4) = v147;
        *((_OWORD *)a1 + 5) = v45;
        v46 = v144;
        *(_OWORD *)a1 = v143;
        *((_OWORD *)a1 + 1) = v46;
        if ((unint64_t)v132 < 3)
        {
          v48 = a1 + 144;
          v49 = 1;
          if ((((uint64_t (*)(char *, char *))*a4)(v26, a1) & 1) == 0)
            goto LABEL_24;
        }
        else
        {
          v47 = (*a4)(v26, (__int128 *)a1 + 18);
          if (v47)
            v48 = a1 + 288;
          else
            v48 = a1 + 144;
          if (v47)
            v49 = 2;
          else
            v49 = 1;
          if ((((uint64_t (*)(char *, char *))*a4)(v48, a1) & 1) == 0)
          {
LABEL_24:
            v50 = *((_OWORD *)a1 + 7);
            v149 = *((_OWORD *)a1 + 6);
            v150 = v50;
            v151 = *((_OWORD *)a1 + 8);
            v51 = *((_OWORD *)a1 + 3);
            v145 = *((_OWORD *)a1 + 2);
            v146 = v51;
            v52 = *((_OWORD *)a1 + 5);
            v147 = *((_OWORD *)a1 + 4);
            v148 = v52;
            v53 = *((_OWORD *)a1 + 1);
            v54 = a1;
            v143 = *(_OWORD *)a1;
            v144 = v53;
            do
            {
              v56 = v48;
              *(_OWORD *)v54 = *(_OWORD *)v48;
              v57 = *((_OWORD *)v48 + 1);
              v58 = *((_OWORD *)v48 + 2);
              v59 = *((_OWORD *)v48 + 4);
              *((_OWORD *)v54 + 3) = *((_OWORD *)v48 + 3);
              *((_OWORD *)v54 + 4) = v59;
              *((_OWORD *)v54 + 1) = v57;
              *((_OWORD *)v54 + 2) = v58;
              v60 = *((_OWORD *)v48 + 5);
              v61 = *((_OWORD *)v48 + 6);
              v62 = *((_OWORD *)v48 + 8);
              *((_OWORD *)v54 + 7) = *((_OWORD *)v48 + 7);
              *((_OWORD *)v54 + 8) = v62;
              *((_OWORD *)v54 + 5) = v60;
              *((_OWORD *)v54 + 6) = v61;
              if ((uint64_t)((unint64_t)(v132 - 2) >> 1) < v49)
                break;
              v63 = (2 * v49) | 1;
              v48 = &a1[144 * v63];
              if (2 * v49 + 2 < v132 && (*a4)(&a1[144 * v63], (__int128 *)v48 + 9))
              {
                v48 += 144;
                v63 = 2 * v49 + 2;
              }
              v55 = (*a4)(v48, &v143);
              v54 = v56;
              v49 = v63;
            }
            while (!v55);
            *(_OWORD *)v56 = v143;
            v27 = v144;
            v28 = v145;
            v29 = v147;
            *((_OWORD *)v56 + 3) = v146;
            *((_OWORD *)v56 + 4) = v29;
            *((_OWORD *)v56 + 1) = v27;
            *((_OWORD *)v56 + 2) = v28;
            v30 = v148;
            v31 = v149;
            v32 = v151;
            *((_OWORD *)v56 + 7) = v150;
            *((_OWORD *)v56 + 8) = v32;
            *((_OWORD *)v56 + 5) = v30;
            *((_OWORD *)v56 + 6) = v31;
            v8 = v129;
          }
        }
      }
      v9 += 144;
      if (v9 == v8)
      {
        a3 = v8;
        v9 = a2;
        v10 = v128;
        goto LABEL_35;
      }
    }
  }
LABEL_32:
  if (v128 >= 145)
  {
LABEL_35:
    v133 = a3;
    v64 = v10 / 0x90;
    do
    {
      v131 = v9;
      v66 = 0;
      v140 = *((_OWORD *)a1 + 6);
      v141 = *((_OWORD *)a1 + 7);
      v142 = *((_OWORD *)a1 + 8);
      v136 = *((_OWORD *)a1 + 2);
      v137 = *((_OWORD *)a1 + 3);
      v138 = *((_OWORD *)a1 + 4);
      v139 = *((_OWORD *)a1 + 5);
      v67 = a1;
      v134 = *(_OWORD *)a1;
      v135 = *((_OWORD *)a1 + 1);
      do
      {
        v74 = &v67[144 * v66 + 144];
        v75 = (2 * v66) | 1;
        v76 = 2 * v66 + 2;
        if (v76 < v64 && (*a4)(&v67[144 * v66 + 144], (__int128 *)&v67[144 * v66 + 288]))
        {
          v74 += 144;
          v75 = v76;
        }
        *(_OWORD *)v67 = *(_OWORD *)v74;
        v68 = *((_OWORD *)v74 + 1);
        v69 = *((_OWORD *)v74 + 2);
        v70 = *((_OWORD *)v74 + 4);
        *((_OWORD *)v67 + 3) = *((_OWORD *)v74 + 3);
        *((_OWORD *)v67 + 4) = v70;
        *((_OWORD *)v67 + 1) = v68;
        *((_OWORD *)v67 + 2) = v69;
        v71 = *((_OWORD *)v74 + 5);
        v72 = *((_OWORD *)v74 + 6);
        v73 = *((_OWORD *)v74 + 8);
        *((_OWORD *)v67 + 7) = *((_OWORD *)v74 + 7);
        *((_OWORD *)v67 + 8) = v73;
        *((_OWORD *)v67 + 5) = v71;
        *((_OWORD *)v67 + 6) = v72;
        v67 = v74;
        v66 = v75;
      }
      while (v75 <= (uint64_t)((unint64_t)(v64 - 2) >> 1));
      v9 = v131 - 144;
      if (v74 == v131 - 144)
      {
        *(_OWORD *)v74 = v134;
        *((_OWORD *)v74 + 3) = v137;
        *((_OWORD *)v74 + 4) = v138;
        *((_OWORD *)v74 + 1) = v135;
        *((_OWORD *)v74 + 2) = v136;
        *((_OWORD *)v74 + 7) = v141;
        *((_OWORD *)v74 + 8) = v142;
        *((_OWORD *)v74 + 5) = v139;
        *((_OWORD *)v74 + 6) = v140;
      }
      else
      {
        *(_OWORD *)v74 = *(_OWORD *)v9;
        v77 = *((_OWORD *)v131 - 8);
        v78 = *((_OWORD *)v131 - 7);
        v79 = *((_OWORD *)v131 - 5);
        *((_OWORD *)v74 + 3) = *((_OWORD *)v131 - 6);
        *((_OWORD *)v74 + 4) = v79;
        *((_OWORD *)v74 + 1) = v77;
        *((_OWORD *)v74 + 2) = v78;
        v80 = *((_OWORD *)v131 - 4);
        v81 = *((_OWORD *)v131 - 3);
        v82 = *((_OWORD *)v131 - 1);
        *((_OWORD *)v74 + 7) = *((_OWORD *)v131 - 2);
        *((_OWORD *)v74 + 8) = v82;
        *((_OWORD *)v74 + 5) = v80;
        *((_OWORD *)v74 + 6) = v81;
        *((_OWORD *)v131 - 3) = v140;
        *((_OWORD *)v131 - 2) = v141;
        *((_OWORD *)v131 - 1) = v142;
        *((_OWORD *)v131 - 7) = v136;
        *((_OWORD *)v131 - 6) = v137;
        *((_OWORD *)v131 - 5) = v138;
        *((_OWORD *)v131 - 4) = v139;
        *(_OWORD *)v9 = v134;
        *((_OWORD *)v131 - 8) = v135;
        v83 = v74 - a1 + 144;
        if (v83 >= 145)
        {
          v84 = (v83 / 0x90uLL - 2) >> 1;
          v85 = &a1[144 * v84];
          if ((*a4)(v85, (__int128 *)v74))
          {
            v143 = *(_OWORD *)v74;
            v86 = *((_OWORD *)v74 + 1);
            v87 = *((_OWORD *)v74 + 2);
            v88 = *((_OWORD *)v74 + 4);
            v146 = *((_OWORD *)v74 + 3);
            v147 = v88;
            v144 = v86;
            v145 = v87;
            v89 = *((_OWORD *)v74 + 5);
            v90 = *((_OWORD *)v74 + 6);
            v91 = *((_OWORD *)v74 + 8);
            v150 = *((_OWORD *)v74 + 7);
            v151 = v91;
            v148 = v89;
            v149 = v90;
            do
            {
              v92 = v85;
              *(_OWORD *)v74 = *(_OWORD *)v85;
              v93 = *((_OWORD *)v85 + 1);
              v94 = *((_OWORD *)v85 + 2);
              v95 = *((_OWORD *)v85 + 4);
              *((_OWORD *)v74 + 3) = *((_OWORD *)v85 + 3);
              *((_OWORD *)v74 + 4) = v95;
              *((_OWORD *)v74 + 1) = v93;
              *((_OWORD *)v74 + 2) = v94;
              v96 = *((_OWORD *)v85 + 5);
              v97 = *((_OWORD *)v85 + 6);
              v98 = *((_OWORD *)v85 + 8);
              *((_OWORD *)v74 + 7) = *((_OWORD *)v85 + 7);
              *((_OWORD *)v74 + 8) = v98;
              *((_OWORD *)v74 + 5) = v96;
              *((_OWORD *)v74 + 6) = v97;
              if (!v84)
                break;
              v84 = (v84 - 1) >> 1;
              v85 = &a1[144 * v84];
              v74 = v92;
            }
            while ((((uint64_t (*)(char *, __int128 *))*a4)(v85, &v143) & 1) != 0);
            v99 = v150;
            *((_OWORD *)v92 + 6) = v149;
            *((_OWORD *)v92 + 7) = v99;
            *((_OWORD *)v92 + 8) = v151;
            v100 = v146;
            *((_OWORD *)v92 + 2) = v145;
            *((_OWORD *)v92 + 3) = v100;
            v101 = v148;
            *((_OWORD *)v92 + 4) = v147;
            *((_OWORD *)v92 + 5) = v101;
            v102 = v144;
            *(_OWORD *)v92 = v143;
            *((_OWORD *)v92 + 1) = v102;
          }
        }
      }
      v65 = v64-- <= 2;
    }
    while (!v65);
    return v133;
  }
  return a3;
}

void std::deque<HGBitmap *>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  void *v26;
  char *v27;
  char *v28;
  char *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  BOOL v37;
  int64_t v38;
  unint64_t v39;
  char *v40;
  _QWORD *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int64_t v45;
  unint64_t v46;
  char *v47;
  unint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  size_t v58;
  unint64_t v59;
  char *v60;
  unint64_t v61;
  int64_t v62;
  unint64_t v63;
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  __int128 *v69;
  char *v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  __int128 *v77;
  _OWORD *v78;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  __int128 *v85;
  _OWORD *v86;
  uint64_t v87;
  __int128 v88;
  uint64_t v89;
  void *v90;
  void *v91;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = v2 >= 0x200;
  v4 = v2 - 512;
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v4;
    v6 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_78:
      *(_QWORD *)v5 = v8;
      *(_QWORD *)(a1 + 16) += 8;
      return;
    }
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v31 = (v5 - v9) >> 2;
      if (v5 == v9)
        v31 = 1;
      if (!(v31 >> 61))
      {
        v32 = v31 >> 2;
        v33 = 8 * v31;
        v34 = (char *)operator new(8 * v31);
        v35 = &v34[8 * v32];
        v36 = &v34[v33];
        v38 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            v74 = &v34[8 * v32];
            v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              v75 = (v39 >> 3) + 1;
              v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              v40 = &v35[v76];
              v7 += v76;
              v77 = (__int128 *)(v6 + 3);
              v78 = v74 + 16;
              v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v40 = &v34[8 * v32];
          }
          do
          {
            v81 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_76;
      }
LABEL_87:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    v11 = v10 >> 3;
    if (v11 >= -1)
      v12 = v11 + 1;
    else
      v12 = v11 + 2;
    v13 = v12 >> 1;
    v14 = -v13;
    v15 = &v7[-8 * v13];
    v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      v7 = *(char **)(a1 + 8);
    }
    v5 = &v15[v16];
    *(_QWORD *)(a1 + 8) = &v7[8 * v14];
    *(_QWORD *)(a1 + 16) = &v15[v16];
    goto LABEL_78;
  }
  v18 = *(_QWORD *)(a1 + 16);
  v17 = *(_QWORD *)(a1 + 24);
  v19 = *(_QWORD *)(a1 + 8);
  v20 = v18 - v19;
  v21 = (v18 - v19) >> 3;
  v22 = v17 - *(_QWORD *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    v41 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v41 + 1);
    v8 = *v41;
    *(_QWORD *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24))
      goto LABEL_78;
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v42 = (v5 - v9) >> 2;
      if (v5 == v9)
        v42 = 1;
      if (!(v42 >> 61))
      {
        v43 = v42 >> 2;
        v44 = 8 * v42;
        v34 = (char *)operator new(8 * v42);
        v35 = &v34[8 * v43];
        v36 = &v34[v44];
        v45 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            v82 = &v34[8 * v43];
            v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              v83 = (v46 >> 3) + 1;
              v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              v47 = &v35[v84];
              v7 += v84;
              v85 = (__int128 *)(v41 + 3);
              v86 = v82 + 16;
              v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v47 = &v34[8 * v43];
          }
          do
          {
            v89 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_76:
        *(_QWORD *)a1 = v34;
        *(_QWORD *)(a1 + 8) = v35;
        *(_QWORD *)(a1 + 16) = v5;
        *(_QWORD *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          v5 = *(char **)(a1 + 16);
        }
        goto LABEL_78;
      }
      goto LABEL_87;
    }
    goto LABEL_5;
  }
  v23 = v22 >> 2;
  if (v17 == *(_QWORD *)a1)
    v24 = 1;
  else
    v24 = v23;
  if (v24 >> 61)
    goto LABEL_87;
  v25 = (char *)operator new(8 * v24);
  v26 = operator new(0x1000uLL);
  v27 = &v25[8 * v21];
  v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19)
        v48 = 1;
      else
        v48 = v20 >> 2;
      if (v48 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v49 = (char *)operator new(8 * v48);
      v27 = &v49[8 * (v48 >> 2)];
      v28 = &v49[8 * v48];
      operator delete(v25);
      v50 = *(_QWORD *)(a1 + 8);
      v18 = *(_QWORD *)(a1 + 16);
      v25 = v49;
      *(_QWORD *)v27 = v90;
      v29 = v27 + 8;
      if (v18 == v50)
        goto LABEL_45;
    }
    else
    {
      v30 = v21 + 2;
      if (v21 >= -1)
        v30 = v21 + 1;
      v27 -= 8 * (v30 >> 1);
      *(_QWORD *)v27 = v26;
      v29 = v27 + 8;
      if (v18 == v19)
        goto LABEL_45;
    }
    do
    {
LABEL_50:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27)
            v59 = 1;
          else
            v59 = (v28 - v27) >> 2;
          if (v59 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v60 = (char *)operator new(8 * v59);
          v25 = v60;
          v61 = (v59 + 3) >> 2;
          v53 = &v60[8 * v61];
          v62 = v29 - v27;
          v37 = v29 == v27;
          v29 = v53;
          if (!v37)
          {
            v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            v63 = v62 - 8;
            v64 = &v60[8 * v61];
            v65 = v27;
            if (v63 < 0x38)
              goto LABEL_91;
            v66 = 8 * v61;
            v64 = &v60[8 * v61];
            v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20)
              goto LABEL_91;
            v67 = (v63 >> 3) + 1;
            v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            v64 = &v53[v68];
            v65 = &v27[v68];
            v69 = (__int128 *)(v27 + 16);
            v70 = &v60[v66 + 16];
            v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_91:
              do
              {
                v73 = *(_QWORD *)v65;
                v65 += 8;
                *(_QWORD *)v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          v55 = (v28 - v29) >> 3;
          if (v55 >= -1)
            v56 = v55 + 1;
          else
            v56 = v55 + 2;
          v57 = &v29[8 * (v56 >> 1)];
          v53 = &v57[-(v29 - v27)];
          v58 = v29 - v27;
          v37 = v29 == v27;
          v29 = v57;
          if (!v37)
            memmove(v53, v27, v58);
          v25 = v27;
        }
      }
      else
      {
        v53 = v27;
      }
      v54 = *(_QWORD *)(v18 - 8);
      v18 -= 8;
      *((_QWORD *)v53 - 1) = v54;
      v51 = v53 - 8;
      v27 = v51;
    }
    while (v18 != *(_QWORD *)(a1 + 8));
    goto LABEL_46;
  }
  *(_QWORD *)v27 = v26;
  v29 = v27 + 8;
  if (v18 != v19)
    goto LABEL_50;
LABEL_45:
  v51 = v27;
LABEL_46:
  v52 = *(char **)a1;
  *(_QWORD *)a1 = v25;
  *(_QWORD *)(a1 + 8) = v51;
  *(_QWORD *)(a1 + 16) = v29;
  *(_QWORD *)(a1 + 24) = v28;
  if (v52)
    operator delete(v52);
}

void sub_1B2A55FC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  void *v9;

  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B2A55FE4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A55FF8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A56010(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void HGGLShaderCache::HGGLShaderCache(HGGLShaderCache *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_QWORD *)this + 4) = 0xFFFFFFFFLL;
  strcpy((char *)this + 104, "mediump");
  *((_BYTE *)this + 127) = 7;
  *((_QWORD *)this + 16) = 0;
  HGProfiler::HGProfiler((HGGLShaderCache *)((char *)this + 136));
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
}

void sub_1B2A560A8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 127) < 0)
    operator delete(*v2);
  HGGLShaderCache::HGGLShaderCache((void **)v1);
  _Unwind_Resume(a1);
}

void HGGLShaderCache::ClearAllShaders(HGGLShaderCache *this)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (*((_QWORD *)this + 1))
  {
    v2 = 0;
    do
    {
      v3 = *(_QWORD *)(*(_QWORD *)this + 8 * v2);
      v4 = *(_QWORD *)(v3 + 120);
      if (v4)
      {
        v5 = operator new();
        v6 = *(_QWORD *)(*(_QWORD *)(v3 + 120) + 40);
        *(_QWORD *)(v5 + 40) = v6;
        *(_QWORD *)(v6 + 24) = v5;
        v7 = *(_QWORD *)(v3 + 120);
        *(_QWORD *)(v5 + 24) = v7;
        *(_QWORD *)(v7 + 40) = v5;
        *(_QWORD *)(v3 + 120) = v5;
        do
        {
          v8 = *(_QWORD *)(v4 + 24);
          *(_QWORD *)(*(_QWORD *)(v4 + 40) + 24) = v8;
          *(_QWORD *)(*(_QWORD *)(v4 + 24) + 40) = *(_QWORD *)(v4 + 40);
          MEMORY[0x1B5E29170](v4, 0x10A0C4011C83829);
          v4 = v8;
        }
        while (v8 != v5);
        *(_QWORD *)(*(_QWORD *)(v5 + 40) + 24) = *(_QWORD *)(v5 + 24);
        *(_QWORD *)(*(_QWORD *)(v5 + 24) + 40) = *(_QWORD *)(v5 + 40);
        MEMORY[0x1B5E29170](v5, 0x10A0C4011C83829);
        *(_QWORD *)(v3 + 120) = 0;
      }
      HGString::~HGString((HGString *)(v3 + 64));
      MEMORY[0x1B5E29170](v3, 0x10B0C408CB6F79ELL);
      ++v2;
    }
    while (v2 < *((_QWORD *)this + 1));
  }
  if (*((_QWORD *)this + 2))
    free(*(void **)this);
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
}

void HGGLShaderCache::~HGGLShaderCache(void **this)
{
  HGGLShaderCache::ClearAllShaders((HGGLShaderCache *)this);
  if (*((char *)this + 127) < 0)
    operator delete(this[13]);
  if (this[2])
    free(*this);
}

double HGGLShaderCache::GetShaderCompileTime(HGGLShaderCache *this)
{
  return HGProfiler::getTime((HGGLShaderCache *)((char *)this + 136));
}

uint64_t HGGLShaderCache::ClearStats(HGGLShaderCache *this)
{
  *((_QWORD *)this + 16) = 0;
  return HGProfiler::init((uint64_t)this + 136);
}

uint64_t HGGLShaderCache::SetCapacity(HGGLShaderCache *this, uint64_t a2)
{
  *((_QWORD *)this + 4) = a2;
  return a2;
}

unint64_t HGGLShaderCache::ClearShaders(HGGLShaderCache *this, int a2)
{
  unint64_t result;
  unint64_t i;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;

  result = *((_QWORD *)this + 1);
  if (!result)
    return result;
  for (i = 0; i < result; ++i)
  {
    v6 = *(_QWORD *)(*(_QWORD *)this + 8 * i);
    if (*(_DWORD *)(v6 + 112) == a2)
    {
      *(_QWORD *)(*(_QWORD *)this + 8 * i) = 0;
      v7 = *(_QWORD *)(v6 + 120);
      if (v7)
      {
        v8 = operator new();
        v9 = *(_QWORD *)(*(_QWORD *)(v6 + 120) + 40);
        *(_QWORD *)(v8 + 40) = v9;
        *(_QWORD *)(v9 + 24) = v8;
        v10 = *(_QWORD *)(v6 + 120);
        *(_QWORD *)(v8 + 24) = v10;
        *(_QWORD *)(v10 + 40) = v8;
        *(_QWORD *)(v6 + 120) = v8;
        do
        {
          v11 = *(_QWORD *)(v7 + 24);
          *(_QWORD *)(*(_QWORD *)(v7 + 40) + 24) = v11;
          *(_QWORD *)(*(_QWORD *)(v7 + 24) + 40) = *(_QWORD *)(v7 + 40);
          MEMORY[0x1B5E29170](v7, 0x10A0C4011C83829);
          v7 = v11;
        }
        while (v11 != v8);
        *(_QWORD *)(*(_QWORD *)(v8 + 40) + 24) = *(_QWORD *)(v8 + 24);
        *(_QWORD *)(*(_QWORD *)(v8 + 24) + 40) = *(_QWORD *)(v8 + 40);
        MEMORY[0x1B5E29170](v8, 0x10A0C4011C83829);
        *(_QWORD *)(v6 + 120) = 0;
      }
      HGString::~HGString((HGString *)(v6 + 64));
      MEMORY[0x1B5E29170](v6, 0x10B0C408CB6F79ELL);
      result = *((_QWORD *)this + 1);
    }
  }
  if (!result)
    return result;
  v12 = 0;
  while (2)
  {
    v13 = *(_QWORD *)this;
    v14 = v12 + 1;
    if (result <= v12 + 1)
      v15 = v12 + 1;
    else
      v15 = result;
    if (*(_QWORD *)(v13 + 8 * v12))
      goto LABEL_13;
    v16 = v15 - v12;
    if (v15 - v12 == 1)
    {
      v17 = 1;
      v18 = result - v14;
      if (result != v14)
        goto LABEL_28;
      goto LABEL_12;
    }
    v17 = 1;
    v19 = v12;
    do
    {
      if (*(_QWORD *)(v13 + 8 * v12 + 8 * v17))
      {
        v15 = v12 + v17;
        if (v17)
          goto LABEL_27;
LABEL_30:
        v12 = v15;
        goto LABEL_13;
      }
      if (!v17)
        v19 = v12;
      ++v17;
    }
    while (v16 != v17);
    v17 = v15 - v12;
    if (!v16)
      goto LABEL_30;
LABEL_27:
    v14 = v19 + v17;
    v12 = v19;
    v18 = result - (v19 + v17);
    if (result == v19 + v17)
      goto LABEL_12;
LABEL_28:
    memmove((void *)(v13 + 8 * v12), (const void *)(v13 + 8 * v14), 8 * v18);
    result = *((_QWORD *)this + 1);
LABEL_12:
    result -= v17;
    *((_QWORD *)this + 1) = result;
LABEL_13:
    if (++v12 < result)
      continue;
    return result;
  }
}

uint64_t HGGLShaderCache::ResetMetal(HGGLShaderCache *this, const HGMetalContext *a2)
{
  unint64_t v3;
  unint64_t i;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;

  if (a2)
    HGMetalRenderPipelineStateCache::clear(*(HGMetalRenderPipelineStateCache **)(*((_QWORD *)a2 + 3) + 144));
  v3 = *((_QWORD *)this + 1);
  if (v3)
  {
    for (i = 0; i < v3; ++i)
    {
      v5 = *(_QWORD *)(*(_QWORD *)this + 8 * i);
      v6 = *(_QWORD *)(v5 + 120);
      if (v6 && *(_DWORD *)(v5 + 112) == 3)
      {
        v7 = *(_QWORD *)(v5 + 120);
        v8 = *(_QWORD *)(v6 + 32);
LABEL_10:
        v9 = *(_QWORD *)(v7 + 8);
        if (v9)
        {
          MEMORY[0x1B5E29170](v9, 0x1000C4052888210);
          --*((_QWORD *)this + 3);
          v6 = *(_QWORD *)(v5 + 120);
        }
        *(_QWORD *)(v7 + 8) = 0;
        while (v8 != v6)
        {
          v7 = v8;
          v8 = *(_QWORD *)(v8 + 32);
          if (*(_DWORD *)(v5 + 112) == 3)
            goto LABEL_10;
        }
        v3 = *((_QWORD *)this + 1);
      }
    }
  }
  v10 = *((_QWORD *)this + 11);
  if (v10)
  {
    v11 = operator new();
    *(_OWORD *)v11 = 0u;
    *(_OWORD *)(v11 + 16) = 0u;
    *(_OWORD *)(v11 + 32) = 0u;
    v12 = *(_QWORD *)(*((_QWORD *)this + 11) + 48);
    *(_QWORD *)(v11 + 48) = v12;
    *(_QWORD *)(v12 + 32) = v11;
    v13 = *((_QWORD *)this + 11);
    *(_QWORD *)(v11 + 32) = v13;
    *(_QWORD *)(v13 + 48) = v11;
    *((_QWORD *)this + 11) = v11;
    do
    {
      v14 = *(_QWORD *)(v10 + 32);
      *(_QWORD *)(*(_QWORD *)(v10 + 48) + 32) = v14;
      *(_QWORD *)(*(_QWORD *)(v10 + 32) + 48) = *(_QWORD *)(v10 + 48);
      v10 = v14;
    }
    while (v14 != v11);
    *((_QWORD *)this + 11) = 0;
    MEMORY[0x1B5E29170]();
  }
  *((_QWORD *)this + 3) = HGGLShaderCache::ClearShaders(this, 3);
  result = *((_QWORD *)this + 12);
  if (result)
  {
    result = MEMORY[0x1B5E29170](result, 0x1000C4052888210);
    *((_QWORD *)this + 12) = 0;
  }
  return result;
}

void HGGLShaderCache::ResetGLSL(HGGLShaderCache *this)
{
  unint64_t v2;
  unint64_t i;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  GLuint shaders;

  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = *(_QWORD *)(*(_QWORD *)this + 8 * i);
      v5 = *(_QWORD *)(v4 + 120);
      if (v5)
      {
        v6 = *(_QWORD *)(v4 + 120);
        do
        {
          v7 = *(_QWORD *)(v6 + 32);
          if ((*(_DWORD *)(v4 + 112) - 1) <= 1)
          {
            v8 = *(_QWORD *)(v6 + 8);
            if (v8)
            {
              shaders = 0;
              glGetAttachedShaders(v8, 1, 0, &shaders);
              glDeleteShader(shaders);
              glDeleteProgram(v8);
              --*((_QWORD *)this + 3);
              v5 = *(_QWORD *)(v4 + 120);
            }
            *(_QWORD *)(v6 + 8) = 0;
          }
          v6 = v7;
        }
        while (v7 != v5);
        v2 = *((_QWORD *)this + 1);
      }
    }
  }
  v9 = *((_QWORD *)this + 7);
  if (v9)
  {
    v10 = operator new();
    *(_OWORD *)v10 = 0u;
    *(_OWORD *)(v10 + 16) = 0u;
    *(_OWORD *)(v10 + 32) = 0u;
    v11 = *(_QWORD *)(*((_QWORD *)this + 7) + 48);
    *(_QWORD *)(v10 + 48) = v11;
    *(_QWORD *)(v11 + 32) = v10;
    v12 = *((_QWORD *)this + 7);
    *(_QWORD *)(v10 + 32) = v12;
    *(_QWORD *)(v12 + 48) = v10;
    *((_QWORD *)this + 7) = v10;
    do
    {
      v13 = *(_QWORD *)(v9 + 32);
      *(_QWORD *)(*(_QWORD *)(v9 + 48) + 32) = v13;
      *(_QWORD *)(*(_QWORD *)(v9 + 32) + 48) = *(_QWORD *)(v9 + 48);
      v9 = v13;
    }
    while (v13 != v10);
    *((_QWORD *)this + 7) = 0;
    MEMORY[0x1B5E29170]();
  }
  v14 = *((_QWORD *)this + 9);
  if (v14)
  {
    v15 = operator new();
    *(_OWORD *)v15 = 0u;
    *(_OWORD *)(v15 + 16) = 0u;
    *(_OWORD *)(v15 + 32) = 0u;
    v16 = *(_QWORD *)(*((_QWORD *)this + 9) + 48);
    *(_QWORD *)(v15 + 48) = v16;
    *(_QWORD *)(v16 + 32) = v15;
    v17 = *((_QWORD *)this + 9);
    *(_QWORD *)(v15 + 32) = v17;
    *(_QWORD *)(v17 + 48) = v15;
    *((_QWORD *)this + 9) = v15;
    do
    {
      v18 = *(_QWORD *)(v14 + 32);
      *(_QWORD *)(*(_QWORD *)(v14 + 48) + 32) = v18;
      *(_QWORD *)(*(_QWORD *)(v14 + 32) + 48) = *(_QWORD *)(v14 + 48);
      v14 = v18;
    }
    while (v18 != v15);
    *((_QWORD *)this + 9) = 0;
    MEMORY[0x1B5E29170]();
  }
  *((_QWORD *)this + 3) = HGGLShaderCache::ClearShaders(this, 1);
  *((_QWORD *)this + 3) = HGGLShaderCache::ClearShaders(this, 2);
  v19 = *((_QWORD *)this + 8);
  if (v19)
  {
    glDeleteShader(v19);
    *((_QWORD *)this + 8) = 0;
  }
  v20 = *((_QWORD *)this + 10);
  if (v20)
  {
    glDeleteShader(v20);
    *((_QWORD *)this + 10) = 0;
  }
}

unint64_t HGGLShaderCache::ResetARB(HGGLShaderCache *this)
{
  unint64_t v2;
  unint64_t i;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t result;
  GLuint shaders;

  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = *(_QWORD *)(*(_QWORD *)this + 8 * i);
      v5 = *(_QWORD *)(v4 + 120);
      if (v5 && !*(_DWORD *)(v4 + 112))
      {
        v6 = *(_QWORD *)(v4 + 120);
        v7 = *(_QWORD *)(v5 + 32);
LABEL_8:
        v8 = *(_QWORD *)(v6 + 8);
        if (v8)
        {
          shaders = 0;
          glGetAttachedShaders(v8, 1, 0, &shaders);
          glDeleteShader(shaders);
          glDeleteProgram(v8);
          --*((_QWORD *)this + 3);
          v5 = *(_QWORD *)(v4 + 120);
        }
        *(_QWORD *)(v6 + 8) = 0;
        while (v7 != v5)
        {
          v6 = v7;
          v7 = *(_QWORD *)(v7 + 32);
          if (!*(_DWORD *)(v4 + 112))
            goto LABEL_8;
        }
        v2 = *((_QWORD *)this + 1);
      }
    }
  }
  v9 = *((_QWORD *)this + 5);
  if (v9)
  {
    v10 = operator new();
    *(_OWORD *)v10 = 0u;
    *(_OWORD *)(v10 + 16) = 0u;
    *(_OWORD *)(v10 + 32) = 0u;
    v11 = *(_QWORD *)(*((_QWORD *)this + 5) + 48);
    *(_QWORD *)(v10 + 48) = v11;
    *(_QWORD *)(v11 + 32) = v10;
    v12 = *((_QWORD *)this + 5);
    *(_QWORD *)(v10 + 32) = v12;
    *(_QWORD *)(v12 + 48) = v10;
    *((_QWORD *)this + 5) = v10;
    do
    {
      v13 = *(_QWORD *)(v9 + 32);
      *(_QWORD *)(*(_QWORD *)(v9 + 48) + 32) = v13;
      *(_QWORD *)(*(_QWORD *)(v9 + 32) + 48) = *(_QWORD *)(v9 + 48);
      v9 = v13;
    }
    while (v13 != v10);
    *((_QWORD *)this + 5) = 0;
    MEMORY[0x1B5E29170]();
  }
  result = HGGLShaderCache::ClearShaders(this, 0);
  *((_QWORD *)this + 3) = result;
  return result;
}

uint64_t HGGLShaderCache::AddEntry(HGGLShaderCache *this, uint64_t a2, const HGString *a3, const HGString::Digest *a4)
{
  uint64_t v8;
  string_t *v9;
  double v10;
  uint32x4_t v11;
  HGString *CGColorSpace;
  const char *FactoryForSerialization;
  const char *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  HGLimits *v20;
  int v21;

  v8 = operator new();
  *(_OWORD *)(v8 + 16) = 0u;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_OWORD *)(v8 + 48) = 0u;
  v9 = (string_t *)(v8 + 64);
  HGString::HGString((HGString *)(v8 + 64));
  *(_OWORD *)(v8 + 144) = 0u;
  *(_OWORD *)(v8 + 160) = 0u;
  *(_OWORD *)(v8 + 112) = 0u;
  *(_OWORD *)(v8 + 128) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 48) = 0u;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_OWORD *)v8 = 0u;
  *(_DWORD *)(v8 + 116) = -1;
  if (*((_QWORD *)a3 + 2))
  {
    HGString::operator=((uint64_t)v9, (uint64_t *)a3);
  }
  else
  {
    if (*((_QWORD *)a3 + 1))
    {
      CGColorSpace = (HGString *)HGString::c_str((string_t *)a3, 0.0, v10, v11);
      FactoryForSerialization = (const char *)OZFactoryBase::getFactoryForSerialization((uint64_t)a3);
    }
    else
    {
      CGColorSpace = (HGString *)PCColorSpaceHandle::getCGColorSpace(a3);
      v14 = (const char *)PCColorSpaceHandle::getCGColorSpace(a3);
      FactoryForSerialization = (const char *)strlen(v14);
    }
    HGString::set(v9, CGColorSpace, FactoryForSerialization, 1, 0xFFu);
  }
  HGString::Digest::operator=(v8, (uint64_t)a4);
  v15 = *((_QWORD *)this + 1);
  v16 = *(char **)this;
  if (v15 == *((_QWORD *)this + 2))
  {
    v17 = v15 + 16;
    *((_QWORD *)this + 2) = v17;
    v16 = (char *)malloc_type_realloc(v16, 8 * v17, 0x2004093837F09uLL);
    *(_QWORD *)this = v16;
    v15 = *((_QWORD *)this + 1);
  }
  v18 = v15 - a2;
  if (v18)
  {
    memmove(&v16[8 * a2 + 8], &v16[8 * a2], 8 * v18);
    v16 = *(char **)this;
    v19 = *((_QWORD *)this + 1);
  }
  else
  {
    v19 = a2;
  }
  *((_QWORD *)this + 1) = v19 + 1;
  *(_QWORD *)&v16[8 * a2] = v8;
  v20 = (const HGString::Digest *)((char *)a4 + 16);
  if (HGLimits::ismetal(v20))
  {
    v21 = 3;
  }
  else if (HGLimits::isfragment(v20))
  {
    v21 = 1;
  }
  else
  {
    v21 = 2;
  }
  *(_DWORD *)(v8 + 112) = v21;
  return v8;
}

void sub_1B2A56B58(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10B0C408CB6F79ELL);
  _Unwind_Resume(a1);
}

uint64_t HGGLShaderCache::CreateShader(HGGLShaderCache *this, int a2)
{
  char *v3;
  uint64_t result;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  GLuint Program;
  GLuint Shader;

  v3 = (char *)this + 16 * a2;
  v6 = *((_QWORD *)v3 + 6);
  v5 = v3 + 48;
  result = v6;
  if (v6)
  {
    *v5 = 0;
  }
  else if (*((_QWORD *)this + 3) >= *((_QWORD *)this + 4))
  {
    v7 = *(_QWORD *)(*((_QWORD *)this + 2 * a2 + 5) + 48);
    if (v7)
    {
      v8 = *(_QWORD *)(v7 + 48);
      v9 = v8;
      while (1)
      {
        result = *(_QWORD *)(v9 + 8);
        if (result)
          break;
        v9 = *(_QWORD *)(v9 + 48);
        if (v9 == v8)
          return 0;
      }
      *(_QWORD *)(v9 + 8) = 0;
    }
    else
    {
      return 0;
    }
  }
  else if (a2 == 1)
  {
    Program = glCreateProgram();
    Shader = glCreateShader(0x8B30u);
    glAttachShader(Program, Shader);
    result = Program;
    ++*((_QWORD *)this + 3);
  }
  else
  {
    if (a2 == 3)
    {
      result = operator new();
      *(_DWORD *)result = 0;
    }
    else
    {
      result = glCreateShader(0x8B31u);
    }
    ++*((_QWORD *)this + 3);
  }
  return result;
}

uint64_t HGGLShaderCache::CancelShader(HGGLShaderCache *this, uint64_t program, int a3)
{
  GLuint v3;
  char *v5;
  _QWORD *v6;
  uint64_t v7;
  GLuint shaders;

  if (program)
  {
    v3 = program;
    v5 = (char *)this + 16 * a3;
    v7 = *((_QWORD *)v5 + 6);
    v6 = v5 + 48;
    if (v7)
    {
      if (a3 == 3)
      {
        MEMORY[0x1B5E29170](program, 0x1000C4052888210);
      }
      else
      {
        shaders = 0;
        glGetAttachedShaders(program, 1, 0, &shaders);
        glDeleteShader(shaders);
        glDeleteProgram(v3);
      }
      --*((_QWORD *)this + 3);
    }
    else
    {
      *v6 = program;
    }
  }
  return 0;
}

uint64_t HGGLShaderCache::CompileShader(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t CGColorSpace;
  uint64_t v7;
  uint64_t v8;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t Entry;
  uint64_t v14;
  int v15;
  GLuint Shader;
  GLint v17;
  int v18;
  GLint UniformLocation;
  GLint v20;
  GLint v21;
  GLint v22;
  GLint v23;
  GLint v24;
  GLint v25;
  GLint v26;
  GLchar *v27;
  const char *v28;
  char *v29;
  GLchar *v30;
  const char *v31;
  char *v32;
  GLint FactoryForSerialization;
  GLint bufsize[2];
  GLint length;
  GLchar *string;
  GLuint shaders;
  GLint params;
  _BYTE v39[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v39, "concat", 1, "HGGLShaderCache::CompileShader");
  if (a2 && !HGLimits::ismetal((HGLimits *)(a2 + 8)))
    HGProfiler::start((HGProfiler *)(a1 + 136));
  CGColorSpace = PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)(a2 + 32));
  params = 0;
  if (!a3)
  {
    v8 = 4294967263;
    goto LABEL_8;
  }
  v7 = CGColorSpace;
  if (!HGLimits::ismetal((HGLimits *)(a2 + 8)) && HGLimits::isfragment((HGLimits *)(a2 + 8)))
  {
    shaders = 0;
    if (*(char *)(a1 + 127) < 0)
    {
      v10 = **(unsigned __int8 **)(a1 + 104);
      if (v10 == 108)
        goto LABEL_15;
    }
    else
    {
      v10 = *(unsigned __int8 *)(a1 + 104);
      if (v10 == 108)
      {
LABEL_15:
        v11 = 0;
LABEL_20:
        HGString::setp((HGString *)(a2 + 32), v11);
        string = (GLchar *)PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)(a2 + 32));
        length = OZFactoryBase::getFactoryForSerialization((uint64_t)(a2 + 32));
        glGetAttachedShaders(a3, 1, 0, &shaders);
        glShaderSource(shaders, 1, (const GLchar *const *)&string, &length);
        glCompileShader(shaders);
        glGetShaderiv(shaders, 0x8B81u, &params);
        if (!params)
        {
          bufsize[0] = 0;
          glGetShaderiv(shaders, 0x8B84u, bufsize);
          v27 = (GLchar *)operator new[]();
          glGetShaderInfoLog(shaders, bufsize[0], bufsize, v27);
          HGLogger::warning((HGLogger *)"GLSL program error: %s\n\nGLSL program follows:\n\n%s\n\n", v28, v29, v27, v7);
          MEMORY[0x1B5E2914C](v27, 0x1000C8077774924);
          v8 = 4294967248;
          goto LABEL_8;
        }
        v12 = a2[26];
        HGString::transform((HGString *)0x50610, v12, bufsize);
        Entry = HGGLShaderCache::GetEntry((HGGLShaderCache *)a1, (const HGString *)bufsize);
        HGString::~HGString((HGString *)bufsize);
        if (Entry)
        {
          v14 = *(_QWORD *)(Entry + 120);
          v15 = *(_DWORD *)(Entry + 116);
          if (v15 == -1)
          {
            *(_QWORD *)bufsize = 0;
            *(_QWORD *)bufsize = PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)(Entry + 64));
            FactoryForSerialization = OZFactoryBase::getFactoryForSerialization(Entry + 64);
            Shader = glCreateShader(0x8B31u);
            *(_QWORD *)(v14 + 8) = Shader;
            glShaderSource(Shader, 1, (const GLchar *const *)bufsize, &FactoryForSerialization);
            glCompileShader(Shader);
            glGetShaderiv(Shader, 0x8B81u, &params);
            v15 = 0;
            v17 = params;
            v18 = params ? 0 : -48;
            *(_DWORD *)(Entry + 116) = v18;
            if (!v17)
            {
              HGGLShaderCache::CancelShader((HGGLShaderCache *)a1, *(_QWORD *)(v14 + 8), *(_DWORD *)(Entry + 112));
              *(_QWORD *)(v14 + 8) = 0;
              v15 = *(_DWORD *)(Entry + 116);
            }
          }
          if (!v15)
            glAttachShader(a3, *(_DWORD *)(v14 + 8));
        }
        glBindAttribLocation(a3, 0, "hg_Position");
        switch(v12)
        {
          case 1:
            goto LABEL_38;
          case 2:
            goto LABEL_37;
          case 3:
            goto LABEL_36;
          case 4:
            goto LABEL_35;
          case 5:
            goto LABEL_34;
          case 6:
            goto LABEL_33;
          case 7:
            goto LABEL_32;
          case 8:
            glBindAttribLocation(a3, 0xFu, "hg_MultiTexCoord7");
LABEL_32:
            glBindAttribLocation(a3, 0xEu, "hg_MultiTexCoord6");
LABEL_33:
            glBindAttribLocation(a3, 0xDu, "hg_MultiTexCoord5");
LABEL_34:
            glBindAttribLocation(a3, 0xCu, "hg_MultiTexCoord4");
LABEL_35:
            glBindAttribLocation(a3, 0xBu, "hg_MultiTexCoord3");
LABEL_36:
            glBindAttribLocation(a3, 0xAu, "hg_MultiTexCoord2");
LABEL_37:
            glBindAttribLocation(a3, 9u, "hg_MultiTexCoord1");
LABEL_38:
            glBindAttribLocation(a3, 8u, "hg_MultiTexCoord0");
            break;
          default:
            break;
        }
        glLinkProgram(a3);
        params = -1;
        glGetProgramiv(a3, 0x8B82u, &params);
        if (!params)
        {
          bufsize[0] = 0;
          glGetShaderiv(a3, 0x8B84u, bufsize);
          v30 = (GLchar *)operator new[]();
          glGetProgramInfoLog(a3, bufsize[0], bufsize, v30);
          HGLogger::warning((HGLogger *)"GLSL linking error: %s\n\nGLSL program follows:\n\n%s\n\n", v31, v32, v30, v7);
          MEMORY[0x1B5E2914C](v30, 0x1000C8077774924);
          v8 = 4294967262;
          goto LABEL_8;
        }
        bufsize[0] = 0;
        glGetIntegerv(0x8B8Du, bufsize);
        glUseProgram(a3);
        UniformLocation = glGetUniformLocation(a3, "hg_Texture0");
        glUniform1i(UniformLocation, 0);
        v20 = glGetUniformLocation(a3, "hg_Texture1");
        glUniform1i(v20, 1);
        v21 = glGetUniformLocation(a3, "hg_Texture2");
        glUniform1i(v21, 2);
        v22 = glGetUniformLocation(a3, "hg_Texture3");
        glUniform1i(v22, 3);
        v23 = glGetUniformLocation(a3, "hg_Texture4");
        glUniform1i(v23, 4);
        v24 = glGetUniformLocation(a3, "hg_Texture5");
        glUniform1i(v24, 5);
        v25 = glGetUniformLocation(a3, "hg_Texture6");
        glUniform1i(v25, 6);
        v26 = glGetUniformLocation(a3, "hg_Texture7");
        glUniform1i(v26, 7);
        glUseProgram(bufsize[0]);
        goto LABEL_6;
      }
    }
    if (v10 == 104)
      v11 = 2;
    else
      v11 = 1;
    goto LABEL_20;
  }
LABEL_6:
  v8 = 0;
LABEL_8:
  if (a2 && !HGLimits::ismetal((HGLimits *)(a2 + 8)))
  {
    HGProfiler::stop((HGProfiler *)(a1 + 136));
    ++*(_QWORD *)(a1 + 128);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v39);
  return v8;
}

void sub_1B2A57288(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A5729C(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A572B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A572C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A572D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A572EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A57300(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  va_list va;

  va_start(va, a4);
  HGString::~HGString((HGString *)va);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v4 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A5731C(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A57330(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A57344(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A57358(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A5736C(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A57380(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A57394(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A573A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A573BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A573D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B2A573E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

uint64_t HGGLShaderCache::GetEntry(HGGLShaderCache *this, const HGString *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  _DWORD v22[15];
  int v23;

  HGString::digest(a2, (uint64_t)v22);
  v4 = *((_QWORD *)this + 1);
  if (v4)
  {
    v5 = *((_QWORD *)this + 1);
    v6 = *(_QWORD *)this;
    while (1)
    {
      v9 = v5 >> 1;
      v10 = (uint64_t *)(v6 + 8 * (v5 >> 1));
      v11 = *v10;
      v12 = v22[0] - (uint64_t)*(int *)*v10;
      if (!v12)
      {
        v12 = v22[1] - (uint64_t)*(int *)(v11 + 4);
        if (!v12)
        {
          v12 = v22[2] - (uint64_t)*(int *)(v11 + 8);
          if (!v12)
          {
            v12 = v22[3] - (uint64_t)*(int *)(v11 + 12);
            if (!v12)
            {
              v12 = v22[4] - (uint64_t)*(int *)(v11 + 16);
              if (!v12)
              {
                v12 = v22[5] - (uint64_t)*(int *)(v11 + 20);
                if (!v12)
                {
                  v12 = v22[6] - (uint64_t)*(int *)(v11 + 24);
                  if (!v12)
                  {
                    v12 = v22[7] - (uint64_t)*(int *)(v11 + 28);
                    if (!v12)
                    {
                      v12 = v22[8] - (uint64_t)*(int *)(v11 + 32);
                      if (!v12)
                      {
                        v12 = v22[9] - (uint64_t)*(int *)(v11 + 36);
                        if (!v12)
                        {
                          v12 = v22[10] - (uint64_t)*(int *)(v11 + 40);
                          if (!v12)
                          {
                            v12 = v22[11] - (uint64_t)*(int *)(v11 + 44);
                            if (!v12)
                            {
                              v12 = v22[12] - (uint64_t)*(int *)(v11 + 48);
                              if (!v12)
                              {
                                v12 = v22[13] - (uint64_t)*(int *)(v11 + 52);
                                if (!v12)
                                {
                                  v12 = v22[14] - (uint64_t)*(int *)(v11 + 56);
                                  if (!v12)
                                  {
                                    v13 = *(int *)(v11 + 60);
                                    if (v23 == (_DWORD)v13)
                                      break;
                                    v12 = v23 - v13;
                                    if (!v12)
                                      break;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v7 = v5 - (v9 + 1);
      if (v12 > 0)
      {
        v8 = v9 + 1;
      }
      else
      {
        v4 = ((uint64_t)v10 - *(_QWORD *)this) >> 3;
        v8 = 0;
      }
      v6 += 8 * v8;
      if (v12 <= 0)
        v5 = v9;
      else
        v5 = v7;
      if (!v5)
        goto LABEL_28;
    }
  }
  else
  {
LABEL_28:
    v11 = HGGLShaderCache::AddEntry(this, v4, a2, (const HGString::Digest *)v22);
    v14 = operator new();
    *(_OWORD *)(v14 + 16) = 0u;
    *(_OWORD *)(v14 + 32) = 0u;
    *(_OWORD *)v14 = 0u;
    *(_QWORD *)(v14 + 40) = v14;
    *(_QWORD *)(v14 + 48) = 0;
    *(_QWORD *)(v14 + 24) = v14;
    *(_QWORD *)(v11 + 120) = v14;
    v15 = (char *)this + 16 * *(int *)(v11 + 112);
    v18 = *((_QWORD *)v15 + 5);
    v16 = (uint64_t *)(v15 + 40);
    v17 = v18;
    if (v18)
    {
      *(_QWORD *)(v14 + 48) = *(_QWORD *)(v17 + 48);
      *(_QWORD *)(*(_QWORD *)(v17 + 48) + 32) = v14;
      v19 = *v16;
      *(_QWORD *)(v14 + 32) = *v16;
      v20 = (uint64_t *)(v19 + 48);
    }
    else
    {
      *(_QWORD *)(v14 + 48) = v14;
      v20 = (uint64_t *)(v14 + 32);
    }
    *v20 = v14;
    *v16 = v14;
  }
  return v11;
}

uint64_t HGGLShaderCache::TestShader(HGGLShaderCache *this, uint64_t a2, _OWORD *a3)
{
  uint64_t result;
  __int128 *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t Shader;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  _QWORD *v16;
  uint64_t v17;
  GLuint shaders;

  if (!a2)
    return 0xFFFFFFFFLL;
  result = *(unsigned int *)(a2 + 116);
  if ((_DWORD)result == -1
    && (v11 = *(_QWORD *)(a2 + 120),
        Shader = HGGLShaderCache::CreateShader(this, *(_DWORD *)(a2 + 112)),
        *(_QWORD *)(v11 + 8) = Shader,
        result = HGGLShaderCache::CompileShader((uint64_t)this, (unsigned __int16 *)a2, Shader),
        (*(_DWORD *)(a2 + 116) = result) != 0))
  {
    v13 = *(_QWORD *)(v11 + 8);
    if (v13)
    {
      v14 = *(int *)(a2 + 112);
      v15 = (char *)this + 16 * v14;
      v17 = *((_QWORD *)v15 + 6);
      v16 = v15 + 48;
      if (v17)
      {
        if ((_DWORD)v14 == 3)
        {
          MEMORY[0x1B5E29170](*(_QWORD *)(v11 + 8), 0x1000C4052888210);
        }
        else
        {
          shaders = 0;
          glGetAttachedShaders(v13, 1, 0, &shaders);
          glDeleteShader(shaders);
          glDeleteProgram(v13);
        }
        --*((_QWORD *)this + 3);
      }
      else
      {
        *v16 = v13;
      }
    }
    *(_QWORD *)(v11 + 8) = 0;
  }
  else
  {
    if (!a3)
      return result;
    v7 = (__int128 *)(a2 + 128);
    if (!*(_DWORD *)(a2 + 128))
    {
      v8 = *(_OWORD *)(a2 + 32);
      *v7 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(a2 + 144) = v8;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)(a2 + 48);
    }
    v9 = *v7;
    v10 = *(_OWORD *)(a2 + 160);
    a3[1] = *(_OWORD *)(a2 + 144);
    a3[2] = v10;
    *a3 = v9;
  }
  return *(unsigned int *)(a2 + 116);
}

uint64_t HGGLShaderCache::TestShader(HGGLShaderCache *a1, HGString *this, _OWORD *a3, uint64_t *a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 *v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t Shader;
  int v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  uint64_t v35;
  _DWORD v37[15];
  int v38;
  GLuint shaders;

  HGString::digest(this, (uint64_t)v37);
  v8 = *((_QWORD *)a1 + 1);
  if (v8)
  {
    v9 = *((_QWORD *)a1 + 1);
    v10 = *(_QWORD *)a1;
    while (1)
    {
      v13 = v9 >> 1;
      v14 = (uint64_t *)(v10 + 8 * (v9 >> 1));
      v15 = *v14;
      v16 = v37[0] - (uint64_t)*(int *)*v14;
      if (!v16)
      {
        v16 = v37[1] - (uint64_t)*(int *)(v15 + 4);
        if (!v16)
        {
          v16 = v37[2] - (uint64_t)*(int *)(v15 + 8);
          if (!v16)
          {
            v16 = v37[3] - (uint64_t)*(int *)(v15 + 12);
            if (!v16)
            {
              v16 = v37[4] - (uint64_t)*(int *)(v15 + 16);
              if (!v16)
              {
                v16 = v37[5] - (uint64_t)*(int *)(v15 + 20);
                if (!v16)
                {
                  v16 = v37[6] - (uint64_t)*(int *)(v15 + 24);
                  if (!v16)
                  {
                    v16 = v37[7] - (uint64_t)*(int *)(v15 + 28);
                    if (!v16)
                    {
                      v16 = v37[8] - (uint64_t)*(int *)(v15 + 32);
                      if (!v16)
                      {
                        v16 = v37[9] - (uint64_t)*(int *)(v15 + 36);
                        if (!v16)
                        {
                          v16 = v37[10] - (uint64_t)*(int *)(v15 + 40);
                          if (!v16)
                          {
                            v16 = v37[11] - (uint64_t)*(int *)(v15 + 44);
                            if (!v16)
                            {
                              v16 = v37[12] - (uint64_t)*(int *)(v15 + 48);
                              if (!v16)
                              {
                                v16 = v37[13] - (uint64_t)*(int *)(v15 + 52);
                                if (!v16)
                                {
                                  v16 = v37[14] - (uint64_t)*(int *)(v15 + 56);
                                  if (!v16)
                                  {
                                    v17 = *(int *)(v15 + 60);
                                    if (v38 == (_DWORD)v17)
                                      break;
                                    v16 = v38 - v17;
                                    if (!v16)
                                      break;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v11 = v9 - (v13 + 1);
      if (v16 > 0)
      {
        v12 = v13 + 1;
      }
      else
      {
        v8 = ((uint64_t)v14 - *(_QWORD *)a1) >> 3;
        v12 = 0;
      }
      v10 += 8 * v12;
      if (v16 <= 0)
        v9 = v13;
      else
        v9 = v11;
      if (!v9)
        goto LABEL_28;
    }
    v18 = *(_QWORD *)(v15 + 120);
  }
  else
  {
LABEL_28:
    v15 = HGGLShaderCache::AddEntry(a1, v8, this, (const HGString::Digest *)v37);
    v19 = operator new();
    v18 = v19;
    *(_OWORD *)(v19 + 16) = 0u;
    *(_OWORD *)(v19 + 32) = 0u;
    *(_OWORD *)v19 = 0u;
    *(_QWORD *)(v19 + 40) = v19;
    *(_QWORD *)(v19 + 48) = 0;
    *(_QWORD *)(v19 + 24) = v19;
    *(_QWORD *)(v15 + 120) = v19;
    v20 = (_QWORD *)((char *)a1 + 16 * *(int *)(v15 + 112));
    v23 = v20[5];
    v21 = v20 + 5;
    v22 = v23;
    if (v23)
    {
      *(_QWORD *)(v19 + 48) = *(_QWORD *)(v22 + 48);
      *(_QWORD *)(*(_QWORD *)(v22 + 48) + 32) = v19;
      v24 = *v21;
      *(_QWORD *)(v19 + 32) = *v21;
      *(_QWORD *)(v24 + 48) = v19;
    }
    else
    {
      *(_QWORD *)(v19 + 48) = v19;
      *(_QWORD *)(v19 + 32) = v19;
    }
    *v21 = v19;
  }
  if (*(_DWORD *)(v15 + 116) == -1
    && (Shader = HGGLShaderCache::CreateShader(a1, *(_DWORD *)(v15 + 112)),
        *(_QWORD *)(v18 + 8) = Shader,
        v30 = HGGLShaderCache::CompileShader((uint64_t)a1, (unsigned __int16 *)v15, Shader),
        (*(_DWORD *)(v15 + 116) = v30) != 0))
  {
    v31 = *(_QWORD *)(v18 + 8);
    if (v31)
    {
      v32 = *(int *)(v15 + 112);
      v33 = (_QWORD *)((char *)a1 + 16 * v32);
      v35 = v33[6];
      v34 = v33 + 6;
      if (v35)
      {
        if ((_DWORD)v32 == 3)
        {
          MEMORY[0x1B5E29170](*(_QWORD *)(v18 + 8), 0x1000C4052888210);
        }
        else
        {
          shaders = 0;
          glGetAttachedShaders(v31, 1, 0, &shaders);
          glDeleteShader(shaders);
          glDeleteProgram(v31);
        }
        --*((_QWORD *)a1 + 3);
      }
      else
      {
        *v34 = v31;
      }
    }
    *(_QWORD *)(v18 + 8) = 0;
  }
  else
  {
    if (a3)
    {
      v25 = (__int128 *)(v15 + 128);
      if (!*(_DWORD *)(v15 + 128))
      {
        v26 = *(_OWORD *)(v15 + 32);
        *v25 = *(_OWORD *)(v15 + 16);
        *(_OWORD *)(v15 + 144) = v26;
        *(_OWORD *)(v15 + 160) = *(_OWORD *)(v15 + 48);
      }
      v27 = *v25;
      v28 = *(_OWORD *)(v15 + 160);
      a3[1] = *(_OWORD *)(v15 + 144);
      a3[2] = v28;
      *a3 = v27;
    }
    if (a4)
      *a4 = v15;
  }
  return *(unsigned int *)(v15 + 116);
}

uint64_t HGGLShaderCache::TestShader(HGGLShaderCache *a1, int *a2, _OWORD *a3, uint64_t *a4)
{
  unint64_t v4;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;

  v4 = *((_QWORD *)a1 + 1);
  if (!v4)
    return 0xFFFFFFFFLL;
  v9 = *(_QWORD *)a1;
  while (1)
  {
    v10 = v4 >> 1;
    v11 = cmp(a2, *(int **)(v9 + 8 * (v4 >> 1)));
    if (!v11)
      break;
    if (v11 > 0)
      v12 = v10 + 1;
    else
      v12 = 0;
    v9 += 8 * v12;
    if (v11 <= 0)
      v4 >>= 1;
    else
      v4 -= v10 + 1;
    if (!v4)
      return 0xFFFFFFFFLL;
  }
  v13 = *(_QWORD *)(v9 + 8 * v10);
  if (!v13)
    return 0xFFFFFFFFLL;
  if (a4)
    *a4 = v13;
  return HGGLShaderCache::TestShader(a1, v13, a3);
}

uint64_t HGGLShaderCache::GetEntry(HGGLShaderCache *this, const char *a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  _DWORD v21[15];
  int v22;
  _BYTE v23[48];

  HGString::HGString((HGString *)v23, a2, 0, 0xFFu);
  HGString::digest((HGString *)v23, (uint64_t)v21);
  v3 = *((_QWORD *)this + 1);
  if (v3)
  {
    v4 = *((_QWORD *)this + 1);
    v5 = *(_QWORD *)this;
    while (1)
    {
      v8 = v4 >> 1;
      v9 = (uint64_t *)(v5 + 8 * (v4 >> 1));
      v10 = *v9;
      v11 = v21[0] - (uint64_t)*(int *)*v9;
      if (!v11)
      {
        v11 = v21[1] - (uint64_t)*(int *)(v10 + 4);
        if (!v11)
        {
          v11 = v21[2] - (uint64_t)*(int *)(v10 + 8);
          if (!v11)
          {
            v11 = v21[3] - (uint64_t)*(int *)(v10 + 12);
            if (!v11)
            {
              v11 = v21[4] - (uint64_t)*(int *)(v10 + 16);
              if (!v11)
              {
                v11 = v21[5] - (uint64_t)*(int *)(v10 + 20);
                if (!v11)
                {
                  v11 = v21[6] - (uint64_t)*(int *)(v10 + 24);
                  if (!v11)
                  {
                    v11 = v21[7] - (uint64_t)*(int *)(v10 + 28);
                    if (!v11)
                    {
                      v11 = v21[8] - (uint64_t)*(int *)(v10 + 32);
                      if (!v11)
                      {
                        v11 = v21[9] - (uint64_t)*(int *)(v10 + 36);
                        if (!v11)
                        {
                          v11 = v21[10] - (uint64_t)*(int *)(v10 + 40);
                          if (!v11)
                          {
                            v11 = v21[11] - (uint64_t)*(int *)(v10 + 44);
                            if (!v11)
                            {
                              v11 = v21[12] - (uint64_t)*(int *)(v10 + 48);
                              if (!v11)
                              {
                                v11 = v21[13] - (uint64_t)*(int *)(v10 + 52);
                                if (!v11)
                                {
                                  v11 = v21[14] - (uint64_t)*(int *)(v10 + 56);
                                  if (!v11)
                                  {
                                    v12 = *(int *)(v10 + 60);
                                    if (v22 == (_DWORD)v12)
                                      break;
                                    v11 = v22 - v12;
                                    if (!v11)
                                      break;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v6 = v4 - (v8 + 1);
      if (v11 > 0)
      {
        v7 = v8 + 1;
      }
      else
      {
        v3 = ((uint64_t)v9 - *(_QWORD *)this) >> 3;
        v7 = 0;
      }
      v5 += 8 * v7;
      if (v11 <= 0)
        v4 = v8;
      else
        v4 = v6;
      if (!v4)
        goto LABEL_28;
    }
  }
  else
  {
LABEL_28:
    v10 = HGGLShaderCache::AddEntry(this, v3, (const HGString *)v23, (const HGString::Digest *)v21);
    v13 = operator new();
    *(_OWORD *)(v13 + 16) = 0u;
    *(_OWORD *)(v13 + 32) = 0u;
    *(_OWORD *)v13 = 0u;
    *(_QWORD *)(v13 + 40) = v13;
    *(_QWORD *)(v13 + 48) = 0;
    *(_QWORD *)(v13 + 24) = v13;
    *(_QWORD *)(v10 + 120) = v13;
    v14 = (char *)this + 16 * *(int *)(v10 + 112);
    v17 = *((_QWORD *)v14 + 5);
    v15 = (uint64_t *)(v14 + 40);
    v16 = v17;
    if (v17)
    {
      *(_QWORD *)(v13 + 48) = *(_QWORD *)(v16 + 48);
      *(_QWORD *)(*(_QWORD *)(v16 + 48) + 32) = v13;
      v18 = *v15;
      *(_QWORD *)(v13 + 32) = *v15;
      v19 = (uint64_t *)(v18 + 48);
    }
    else
    {
      *(_QWORD *)(v13 + 48) = v13;
      v19 = (uint64_t *)(v13 + 32);
    }
    *v19 = v13;
    *v15 = v13;
  }
  HGString::~HGString((HGString *)v23);
  return v10;
}

void sub_1B2A57D10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A57D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGLShaderCache::Enable(HGGLShaderCache *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t Shader;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  GLuint shaders;

  if (!a2)
    return 0xFFFFFFFFLL;
  result = *(unsigned int *)(a2 + 116);
  if ((int)result >= -1)
  {
    v9 = *(_QWORD *)(a2 + 120);
    v10 = v9;
    while (*(_QWORD *)(v10 + 16) != a4)
    {
      v10 = *(_QWORD *)(v10 + 24);
      if (v10 == v9 || v10 == 0)
      {
        v10 = *(_QWORD *)(v9 + 40);
        if ((unint64_t)(a3 - *(_QWORD *)v10) > 1 || *((_QWORD *)a1 + 3) >= *((_QWORD *)a1 + 4))
        {
          *(_QWORD *)(v10 + 16) = a4;
          *(_QWORD *)(a2 + 120) = *(_QWORD *)(v9 + 40);
          *(_QWORD *)v10 = a3;
          if (!*(_QWORD *)(v10 + 8))
            goto LABEL_23;
        }
        else
        {
          v10 = operator new();
          *(_OWORD *)v10 = 0u;
          *(_OWORD *)(v10 + 16) = 0u;
          *(_QWORD *)(v10 + 48) = 0;
          *(_OWORD *)(v10 + 32) = 0u;
          *(_QWORD *)(v10 + 16) = a4;
          v12 = *(_QWORD *)(*(_QWORD *)(a2 + 120) + 40);
          *(_QWORD *)(v10 + 40) = v12;
          *(_QWORD *)(v12 + 24) = v10;
          v13 = *(_QWORD *)(a2 + 120);
          *(_QWORD *)(v10 + 24) = v13;
          *(_QWORD *)(v13 + 40) = v10;
          *(_QWORD *)(a2 + 120) = v10;
          v14 = (_QWORD *)((char *)a1 + 16 * *(int *)(a2 + 112));
          v15 = v14[5];
          *(_QWORD *)(v10 + 48) = *(_QWORD *)(v15 + 48);
          *(_QWORD *)(*(_QWORD *)(v15 + 48) + 32) = v10;
          v16 = v14[5];
          *(_QWORD *)(v10 + 32) = v16;
          *(_QWORD *)(v16 + 48) = v10;
          v14[5] = v10;
          *(_QWORD *)v10 = a3;
          if (!*(_QWORD *)(v10 + 8))
            goto LABEL_23;
        }
LABEL_38:
        if (!HGLimits::ismetal((HGLimits *)(a2 + 16)))
          glUseProgram(*(_DWORD *)(v10 + 8));
        return *(unsigned int *)(a2 + 116);
      }
    }
    if (*(_QWORD *)(v10 + 8))
    {
      if (v9 != v10)
      {
        *(_QWORD *)(*(_QWORD *)(v10 + 40) + 24) = *(_QWORD *)(v10 + 24);
        *(_QWORD *)(*(_QWORD *)(v10 + 24) + 40) = *(_QWORD *)(v10 + 40);
        *(_QWORD *)(v10 + 40) = *(_QWORD *)(*(_QWORD *)(a2 + 120) + 40);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 120) + 40) + 24) = v10;
        *(_QWORD *)(v10 + 24) = *(_QWORD *)(a2 + 120);
        *(_QWORD *)(*(_QWORD *)(a2 + 120) + 40) = v10;
        *(_QWORD *)(a2 + 120) = v10;
      }
      v17 = (_QWORD *)((char *)a1 + 16 * *(int *)(a2 + 112));
      v19 = v17[5];
      v18 = v17 + 5;
      if (v19 != v10)
      {
        *(_QWORD *)(*(_QWORD *)(v10 + 48) + 32) = *(_QWORD *)(v10 + 32);
        *(_QWORD *)(*(_QWORD *)(v10 + 32) + 48) = *(_QWORD *)(v10 + 48);
        *(_QWORD *)(v10 + 48) = *(_QWORD *)(*v18 + 48);
        *(_QWORD *)(*(_QWORD *)(*v18 + 48) + 32) = v10;
        *(_QWORD *)(v10 + 32) = *v18;
        *(_QWORD *)(*v18 + 48) = v10;
        *v18 = v10;
      }
    }
    *(_QWORD *)v10 = a3;
    if (*(_QWORD *)(v10 + 8))
      goto LABEL_38;
LABEL_23:
    if (*(_DWORD *)(a2 + 116) != -1)
    {
      v20 = *(_QWORD **)(*(_QWORD *)(a2 + 120) + 40);
      if ((unint64_t)(a3 - *v20) >= 2 && (v21 = v20[1]) != 0)
      {
        v22 = v20 + 1;
      }
      else
      {
        if (*((_QWORD *)a1 + 3) < *((_QWORD *)a1 + 4))
        {
          Shader = HGGLShaderCache::CreateShader(a1, *(_DWORD *)(a2 + 112));
          *(_QWORD *)(v10 + 8) = Shader;
          if (HGGLShaderCache::CompileShader((uint64_t)a1, (unsigned __int16 *)a2, Shader) == *(_DWORD *)(a2 + 116))
            goto LABEL_37;
          HGGLShaderCache::CancelShader(a1, *(_QWORD *)(v10 + 8), *(_DWORD *)(a2 + 112));
          v20 = *(_QWORD **)(*(_QWORD *)(a2 + 120) + 40);
        }
        v24 = v20[1];
        v22 = v20 + 1;
        v21 = v24;
      }
      *(_QWORD *)(v10 + 8) = v21;
      *v22 = 0;
LABEL_37:
      if (!*(_QWORD *)(v10 + 8))
        return *(unsigned int *)(a2 + 116);
      goto LABEL_38;
    }
    v25 = HGGLShaderCache::CreateShader(a1, *(_DWORD *)(a2 + 112));
    *(_QWORD *)(v10 + 8) = v25;
    v26 = HGGLShaderCache::CompileShader((uint64_t)a1, (unsigned __int16 *)a2, v25);
    *(_DWORD *)(a2 + 116) = v26;
    if (!v26)
      goto LABEL_37;
    v27 = *(_QWORD *)(v10 + 8);
    if (v27)
    {
      v28 = *(int *)(a2 + 112);
      v29 = (_QWORD *)((char *)a1 + 16 * v28);
      v31 = v29[6];
      v30 = v29 + 6;
      if (!v31)
      {
        *v30 = v27;
        *(_QWORD *)(v10 + 8) = 0;
        return *(unsigned int *)(a2 + 116);
      }
      if ((_DWORD)v28 == 3)
      {
        MEMORY[0x1B5E29170](*(_QWORD *)(v10 + 8), 0x1000C4052888210);
      }
      else
      {
        shaders = 0;
        glGetAttachedShaders(v27, 1, 0, &shaders);
        glDeleteShader(shaders);
        glDeleteProgram(v27);
      }
      --*((_QWORD *)a1 + 3);
    }
    *(_QWORD *)(v10 + 8) = 0;
    return *(unsigned int *)(a2 + 116);
  }
  return result;
}

void HGGLShaderCache::DisableEntry(uint64_t a1, uint64_t a2, int a3)
{
  if (a2)
    *(_DWORD *)(a2 + 116) = a3;
}

std::string *HGGLShaderCache::SetPrecisionKeyword(uint64_t a1, const std::string *a2)
{
  return std::string::operator=((std::string *)(a1 + 104), a2);
}

uint64_t cmp(int *a1, int *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v3 = *a1;
  v4 = *a2;
  result = v3 - v4;
  if (v3 == v4)
  {
    v6 = a1[1];
    v7 = a2[1];
    result = v6 - v7;
    if (v6 == v7)
    {
      v8 = a1[2];
      v9 = a2[2];
      result = v8 - v9;
      if (v8 == v9)
      {
        v10 = a1[3];
        v11 = a2[3];
        result = v10 - v11;
        if (v10 == v11)
        {
          v12 = a1[4];
          v13 = a2[4];
          result = v12 - v13;
          if (v12 == v13)
          {
            v14 = a1[5];
            v15 = a2[5];
            result = v14 - v15;
            if (v14 == v15)
            {
              v16 = a1[6];
              v17 = a2[6];
              result = v16 - v17;
              if (v16 == v17)
              {
                v18 = a1[7];
                v19 = a2[7];
                result = v18 - v19;
                if (v18 == v19)
                {
                  v20 = a1[8];
                  v21 = a2[8];
                  result = v20 - v21;
                  if (v20 == v21)
                  {
                    v22 = a1[9];
                    v23 = a2[9];
                    result = v22 - v23;
                    if (v22 == v23)
                    {
                      v24 = a1[10];
                      v25 = a2[10];
                      result = v24 - v25;
                      if (v24 == v25)
                      {
                        v26 = a1[11];
                        v27 = a2[11];
                        result = v26 - v27;
                        if (v26 == v27)
                        {
                          v28 = a1[12];
                          v29 = a2[12];
                          result = v28 - v29;
                          if (v28 == v29)
                          {
                            v30 = a1[13];
                            v31 = a2[13];
                            result = v30 - v31;
                            if (v30 == v31)
                            {
                              v32 = a1[14];
                              v33 = a2[14];
                              result = v32 - v33;
                              if (v32 == v33)
                              {
                                v34 = a1[15];
                                v35 = a2[15];
                                if ((_DWORD)v34 == (_DWORD)v35)
                                  return 0;
                                else
                                  return v34 - v35;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void OUTLINED_FUNCTION_0_2(void **a1)
{
  free(*a1);
}

void HGGLShaderCache::HGGLShaderCache(void **a1)
{
  if (a1[2])
    OUTLINED_FUNCTION_0_2(a1);
}

void HFGrabCut::HFGrabCut(HFGrabCut *this)
{
  *(_QWORD *)this = &off_1E6524518;
  *((_QWORD *)this + 1) = 0;
  *((_BYTE *)this + 16) = 1;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
}

HFGrabCut *HFGrabCut::Reset(HFGrabCut *this)
{
  *((_BYTE *)this + 16) = 1;
  return this;
}

void HFGrabCut::~HFGrabCut(HFGrabCut *this, void *a2)
{
  HGMemory *v3;
  HGMemory *v4;
  HGMemory *v5;

  *(_QWORD *)this = &off_1E6524518;
  *((_BYTE *)this + 16) = 1;
  v3 = (HGMemory *)*((_QWORD *)this + 4);
  if (v3)
  {
    HGMemory::release(v3, a2);
    *((_QWORD *)this + 4) = 0;
  }
  v4 = (HGMemory *)*((_QWORD *)this + 5);
  if (v4)
  {
    HGMemory::release(v4, a2);
    *((_QWORD *)this + 5) = 0;
  }
  v5 = (HGMemory *)*((_QWORD *)this + 6);
  if (v5)
  {
    HGMemory::release(v5, a2);
    *((_QWORD *)this + 6) = 0;
  }
}

{
  HGMemory *v3;
  HGMemory *v4;
  HGMemory *v5;

  *(_QWORD *)this = &off_1E6524518;
  *((_BYTE *)this + 16) = 1;
  v3 = (HGMemory *)*((_QWORD *)this + 4);
  if (v3)
  {
    HGMemory::release(v3, a2);
    *((_QWORD *)this + 4) = 0;
  }
  v4 = (HGMemory *)*((_QWORD *)this + 5);
  if (v4)
  {
    HGMemory::release(v4, a2);
    *((_QWORD *)this + 5) = 0;
  }
  v5 = (HGMemory *)*((_QWORD *)this + 6);
  if (v5)
  {
    HGMemory::release(v5, a2);
    *((_QWORD *)this + 6) = 0;
  }
  JUMPOUT(0x1B5E29170);
}

HFGrabCut *HFGrabCut::InitDataModels(HFGrabCut *this, HGBitmap *a2, HGBitmap *a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t *v5;
  HFGrabCut *v7;
  HGMemory *v8;
  HGMemory *v9;
  HGMemory *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t *v14;
  unint64_t *v15;
  unint64_t *v16;
  soKMeansClassifier *v17;

  v4 = (*((_DWORD *)a2 + 7) - *((_DWORD *)a2 + 5));
  if ((_DWORD)v4 == *((_DWORD *)a3 + 7) - *((_DWORD *)a3 + 5))
  {
    v5 = (unint64_t *)(*((_DWORD *)a2 + 8) - *((_DWORD *)a2 + 6));
    if ((_DWORD)v5 == *((_DWORD *)a3 + 8) - *((_DWORD *)a3 + 6)
      && (*((_DWORD *)a2 + 4) - 23) <= 1
      && *((_DWORD *)a3 + 4) == 1)
    {
      v7 = this;
      if (*((_DWORD *)this + 6) * *((_DWORD *)this + 5) < ((_DWORD)v5 * v4))
      {
        *((_DWORD *)this + 5) = (v4 + 31) & 0xFFFFFFE0;
        *((_DWORD *)this + 6) = ((_DWORD)v5 + 31) & 0xFFFFFFE0;
        v8 = (HGMemory *)*((_QWORD *)this + 4);
        if (v8)
        {
          HGMemory::release(v8, a2);
          *((_QWORD *)v7 + 4) = 0;
        }
        v9 = (HGMemory *)*((_QWORD *)v7 + 5);
        if (v9)
        {
          HGMemory::release(v9, a2);
          *((_QWORD *)v7 + 5) = 0;
        }
        v10 = (HGMemory *)*((_QWORD *)v7 + 6);
        if (v10)
        {
          HGMemory::release(v10, a2);
          *((_QWORD *)v7 + 6) = 0;
        }
        v11 = *((_DWORD *)v7 + 5) * HGFormatUtils::bytesPerPixel(13);
        v12 = *((_DWORD *)v7 + 5) * HGFormatUtils::bytesPerPixel(28);
        v13 = *((_DWORD *)v7 + 5) * HGFormatUtils::bytesPerPixel(1);
        *((_QWORD *)v7 + 4) = HGMemory::allocate((HGMemory *)(*((unsigned int *)v7 + 6) * (unint64_t)v11), 0, v14);
        *((_QWORD *)v7 + 5) = HGMemory::allocate((HGMemory *)(*((unsigned int *)v7 + 6) * (unint64_t)v12), 0, v15);
        *((_QWORD *)v7 + 6) = HGMemory::allocate((HGMemory *)(*((unsigned int *)v7 + 6) * (unint64_t)v13), 0, v16);
      }
      v17 = (soKMeansClassifier *)*((_QWORD *)v7 + 1);
      if (!v17)
      {
        v17 = (soKMeansClassifier *)operator new();
        soKMeansClassifier::soKMeansClassifier(v17);
        *((_QWORD *)v7 + 1) = v17;
      }
      return (HFGrabCut *)soKMeansClassifier::Init(v17, (void *)v4, v5, a4, 1);
    }
  }
  return this;
}

void sub_1B2A58490(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10B0C40BA4AE0DALL);
  _Unwind_Resume(a1);
}

void SetupEdges(HGBitmap *a1, HGBitmap *a2, float a3)
{
  int v3;
  int v4;
  uint64_t v5;
  int v7;
  int v8;
  float v9;
  unint64_t v10;
  int v11;
  int v12;
  unsigned __int8 *v13;
  int v14;
  float v15;
  unsigned __int8 *v16;
  int v17;
  int v18;
  float v19;
  int v20;
  unsigned int v21;
  unint64_t v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  int v29;
  unint64_t v30;
  float v31;
  int v32;
  float v33;
  uint64_t v34;
  int v35;
  float v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  float v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  uint64_t v53;
  float v54;
  unsigned __int8 *v55;
  unsigned __int8 *v56;
  uint64_t v57;
  int v58;
  int v59;
  float v60;
  float v61;
  float v62;
  float v63;
  int v64;
  unint64_t v65;
  float v66;
  uint64_t v67;
  uint64_t v68;
  float v69;
  uint64_t v70;
  uint64_t v71;
  float v72;
  uint64_t v73;
  uint64_t v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;

  v3 = *((_DWORD *)a1 + 6);
  v4 = *((_DWORD *)a1 + 8);
  v5 = (v4 - v3);
  if (v4 == v3)
    return;
  v7 = *((_DWORD *)a1 + 7);
  v8 = *((_DWORD *)a1 + 5);
  v9 = 0.0;
  v10 = (v7 - v8);
  if (v7 == v8)
    goto LABEL_22;
  v11 = 0;
  v12 = 0;
  v13 = (unsigned __int8 *)*((_QWORD *)a1 + 10);
  v14 = v7 + ~v8;
  v15 = 0.0;
  v16 = v13;
  do
  {
    if (v11)
    {
      v17 = *v16;
      v18 = v16[1];
      v19 = (float)(v18 - v13[1]);
      v20 = v16[2];
      v15 = v15
          + (float)((float)((float)((float)(v17 - *v13) * (float)(v17 - *v13)) + (float)(v19 * v19))
                  + (float)((float)(v20 - v13[2]) * (float)(v20 - v13[2])));
      if (v10 >= 2)
      {
        v26 = (float)(v17 - v13[4]);
        v27 = (float)(v18 - v13[5]);
        v28 = (float)(v20 - v13[6]);
        v15 = v15 + (float)((float)((float)(v26 * v26) + (float)(v27 * v27)) + (float)(v28 * v28));
        v12 += 2;
      }
      else
      {
        ++v12;
        if ((_DWORD)v10 == 1)
          goto LABEL_4;
      }
      v29 = 0;
      v30 = 1;
      do
      {
        while (1)
        {
          v34 = (v29 + 4);
          v35 = v16[v34];
          v36 = (float)(v35 - v16[v29]);
          v37 = (v29 + 5);
          v38 = v16[v37];
          v39 = v29 + 1;
          v40 = (float)(v38 - v16[v39]);
          ++v30;
          v41 = (v29 + 6);
          v42 = v16[v41];
          v43 = v29 + 2;
          v44 = v15
              + (float)((float)((float)(v36 * v36) + (float)(v40 * v40))
                      + (float)((float)(v42 - v16[v43]) * (float)(v42 - v16[v43])));
          v45 = (float)(v35 - v13[v29]);
          v46 = (float)(v38 - v13[v39]);
          v47 = (float)(v42 - v13[v43]);
          v48 = (float)((float)(v45 * v45) + (float)(v46 * v46)) + (float)(v47 * v47);
          v49 = (float)(v35 - v13[v34]);
          v50 = v44 + v48;
          v51 = (float)(v38 - v13[v37]);
          v15 = v50
              + (float)((float)((float)(v49 * v49) + (float)(v51 * v51))
                      + (float)((float)(v42 - v13[v41]) * (float)(v42 - v13[v41])));
          if (v30 >= v10)
            break;
          v31 = (float)(v35 - v13[v29 + 8]);
          v32 = v38 - v13[v29 + 9];
          v33 = (float)(v42 - v13[v29 + 10]);
          v15 = v15 + (float)((float)((float)(v31 * v31) + (float)((float)v32 * (float)v32)) + (float)(v33 * v33));
          v12 += 4;
          v29 += 4;
          if (v10 == v30)
            goto LABEL_4;
        }
        v12 += 3;
        v29 += 4;
      }
      while (v10 != v30);
    }
    else if ((_DWORD)v10 != 1)
    {
      v21 = 6;
      v22 = v10 - 1;
      do
      {
        v23 = (float)(v16[v21 - 2] - v16[v21 - 6]);
        v24 = (float)(v16[v21 - 1] - v16[v21 - 5]);
        v25 = (float)(v16[v21] - v16[v21 - 4]);
        v15 = v15 + (float)((float)((float)(v23 * v23) + (float)(v24 * v24)) + (float)(v25 * v25));
        v21 += 4;
        --v22;
      }
      while (v22);
      v12 += v14;
    }
LABEL_4:
    v13 = v16;
    v16 += *((_QWORD *)a1 + 8);
    ++v11;
  }
  while (v11 != (_DWORD)v5);
  if (v12)
  {
    v52 = 1.0 / (float)v12;
    v9 = 0.0;
    if (v15 > 0.00000011921)
      goto LABEL_21;
  }
  else
  {
    v52 = 1.0;
    v9 = 0.0;
    if (v15 > 0.00000011921)
LABEL_21:
      v9 = 1.0 / (float)((float)(v15 + v15) * v52);
  }
LABEL_22:
  v90 = (*((_DWORD *)a1 + 7) - *((_DWORD *)a1 + 5));
  if ((_DWORD)v90)
  {
    v53 = 0;
    v86 = *((_QWORD *)a2 + 8);
    v87 = *((_QWORD *)a2 + 10);
    v54 = -v9;
    v85 = *((_QWORD *)a1 + 8);
    v55 = (unsigned __int8 *)*((_QWORD *)a1 + 10);
    v56 = v55;
    v88 = v5;
    do
    {
      v57 = v87 + v86 * v53;
      *(_QWORD *)v57 = 0;
      v89 = v53;
      if (v53)
      {
        v58 = *v56 - *v55;
        v59 = v56[1] - v55[1];
        v60 = (float)(v56[2] - v55[2]);
        *(float *)(v57 + 8) = expf((float)((float)((float)((float)v58 * (float)v58) + (float)((float)v59 * (float)v59))+ (float)(v60 * v60))* v54)* a3;
        if (v90 >= 2)
        {
          v61 = (float)(*v56 - v55[4]);
          v62 = (float)(v56[1] - v55[5]);
          v63 = (float)(v56[2] - v55[6]);
          *(float *)(v57 + 12) = (float)(expf((float)((float)((float)(v61 * v61) + (float)(v62 * v62)) + (float)(v63 * v63))* v54)* a3)* 0.70711;
LABEL_31:
          v64 = 0;
          v65 = 1;
          do
          {
            v67 = (v64 + 4);
            v68 = v64;
            v69 = (float)(v56[v67] - v56[v64]);
            v70 = (v64 + 5);
            ++v65;
            v71 = v64 + 1;
            v72 = (float)(v56[v70] - v56[v71]);
            v73 = (v64 + 6);
            v74 = v64 + 2;
            v75 = (float)(v56[v73] - v56[v74]);
            *(float *)(v57 + 4 * v67) = expf((float)((float)((float)(v69 * v69) + (float)(v72 * v72))+ (float)(v75 * v75))* v54)* a3;
            if (v89)
            {
              v76 = (float)(v56[v67] - v55[v68]);
              v77 = (float)(v56[v70] - v55[v71]);
              v78 = (float)(v56[v73] - v55[v74]);
              *(float *)(v57 + 4 * v70) = (float)(expf((float)((float)((float)(v76 * v76) + (float)(v77 * v77))+ (float)(v78 * v78))* v54)* a3)* 0.70711;
              v79 = (float)(v56[v67] - v55[v67]);
              v80 = (float)(v56[v70] - v55[v70]);
              v81 = (float)(v56[v73] - v55[v73]);
              *(float *)(v57 + 4 * v73) = expf((float)((float)((float)(v79 * v79) + (float)(v80 * v80)) + (float)(v81 * v81))* v54)* a3;
              v66 = 0.0;
              if (v65 < v90)
              {
                v82 = (float)(v56[v67] - v55[(v68 + 8)]);
                v83 = (float)(v56[v70] - v55[(v68 + 9)]);
                v84 = (float)(v56[v73] - v55[(v68 + 10)]);
                v66 = (float)(expf((float)((float)((float)(v82 * v82) + (float)(v83 * v83)) + (float)(v84 * v84)) * v54)
                            * a3)
                    * 0.70711;
              }
            }
            else
            {
              *(_QWORD *)(v57 + 4 * v70) = 0;
              v66 = 0.0;
            }
            *(float *)(v57 + 4 * (v68 + 7)) = v66;
            v64 = v68 + 4;
          }
          while (v90 != v65);
          goto LABEL_25;
        }
      }
      else
      {
        *(_DWORD *)(v57 + 8) = 0;
      }
      *(_DWORD *)(v57 + 12) = 0;
      if ((_DWORD)v90 != 1)
        goto LABEL_31;
LABEL_25:
      v55 = v56;
      v56 += v85;
      v53 = v89 + 1;
    }
    while (v89 + 1 != v88);
  }
}

soMaxFlow *SetupGraph(soMaxFlow *this, HGBitmap *a2, HGBitmap *a3, HGBitmap *a4, float a5)
{
  soMaxFlow *v5;
  uint64_t i;
  float *v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v16 = (*((_DWORD *)a2 + 8) - *((_DWORD *)a2 + 6));
  if ((_DWORD)v16)
  {
    v15 = (*((_DWORD *)a2 + 7) - *((_DWORD *)a2 + 5));
    if ((_DWORD)v15)
    {
      v5 = this;
      for (i = 0; i != v16; ++i)
      {
        v7 = (float *)(*((_QWORD *)a4 + 10) + *((_QWORD *)a4 + 8) * i);
        v8 = *((_QWORD *)a3 + 10) + *((_QWORD *)a3 + 8) * i;
        v9 = -1;
        v10 = 3;
        v11 = v15;
        do
        {
          v12 = *v7;
          v13 = v7[1];
          v7 += 2;
          soMaxFlow::SetNodeWeights(v5, v9 + 1, i, v12, v13);
          soMaxFlow::SetEdgeCapacity((uint64_t)v5, 0, v9 + 1, i, *(float *)(v8 + 4 * (v10 - 3)));
          soMaxFlow::SetEdgeCapacity((uint64_t)v5, 4, v9, i, *(float *)(v8 + 4 * (v10 - 3)));
          soMaxFlow::SetEdgeCapacity((uint64_t)v5, 1, v9 + 1, i, *(float *)(v8 + 4 * (v10 - 2)));
          soMaxFlow::SetEdgeCapacity((uint64_t)v5, 5, v9, i - 1, *(float *)(v8 + 4 * (v10 - 2)));
          soMaxFlow::SetEdgeCapacity((uint64_t)v5, 2, v9 + 1, i, *(float *)(v8 + 4 * (v10 - 1)));
          soMaxFlow::SetEdgeCapacity((uint64_t)v5, 6, v9 + 1, i - 1, *(float *)(v8 + 4 * (v10 - 1)));
          v14 = 4 * v10;
          soMaxFlow::SetEdgeCapacity((uint64_t)v5, 3, v9 + 1, i, *(float *)(v8 + v14));
          this = (soMaxFlow *)soMaxFlow::SetEdgeCapacity((uint64_t)v5, 7, v9 + 2, (int)i - 1, *(float *)(v8 + v14));
          v10 += 4;
          ++v9;
          --v11;
        }
        while (v11);
      }
    }
  }
  return this;
}

void HFGrabCut::GenerateMask(HFGrabCut *this, HGBitmap *a2, HGBitmap *a3, HGBitmap *a4, double a5, int a6, double a7, __n128 a8)
{
  float v9;
  __n128 v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  char *v21;
  size_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  HGBitmap *v28;
  float v29;
  float v30;
  uint64_t v31;
  double v32;
  int v33;
  uint64_t v34;
  uint8x16_t *v35;
  uint8x16_t *v36;
  int i;
  uint8x16_t *v38;
  char *v39;
  uint64_t v40;
  unsigned int v41;
  char v42;
  void *v43;
  int v44;
  uint8x16_t v45;
  uint64_t v46;
  uint64_t v47;
  uint8x16_t *v48;
  uint8x16_t *v49;
  uint64_t v50;
  uint8x16_t v51;
  uint8x8_t *v52;
  uint8x8_t *v53;
  uint64_t v54;
  uint8x8_t v55;
  uint64_t v56;
  char *v57;
  unsigned __int8 *v58;
  unsigned int v59;
  char v60;
  void *v61;
  int v62;
  HGProfiler **v63[2];
  int v64;

  v9 = *(float *)&a5;
  v64 = 0;
  soKMeansClassifier::LoadBuffer(*((_QWORD **)this + 1), *((unsigned __int8 **)a2 + 10), *((_QWORD *)a2 + 8), a5, a7, a8);
  soKMeansClassifier::LoadMask(*((void **)this + 1), *((_QWORD *)a3 + 10), *((_QWORD *)a3 + 8), &v64);
  if ((v64 - 1) > 1)
  {
    v62 = a6;
    if (*((_BYTE *)this + 16))
    {
      soKMeansClassifier::Cluster(*((soKMeansClassifier **)this + 1), 5, 1, 0, 0, 0, 0, 0, v14, 0, 0);
      *((_BYTE *)this + 16) = 0;
    }
    v23 = *(_QWORD *)((char *)a4 + 20);
    v24 = *(_QWORD *)((char *)a4 + 28);
    v25 = *(_QWORD *)((char *)a2 + 20);
    v26 = *(_QWORD *)((char *)a2 + 28);
    v27 = HGObject::operator new(0x80uLL);
    HGBitmap::HGBitmap((uint64_t)v27, v25, v26, 13, *((_QWORD *)this + 4));
    v28 = (HGBitmap *)HGObject::operator new(0x80uLL);
    HGBitmap::HGBitmap((uint64_t)v28, v25, v26, 28, *((_QWORD *)this + 5));
    v61 = HGObject::operator new(0x80uLL);
    HGBitmap::HGBitmap((uint64_t)v61, v23, v24, 1, *((_QWORD *)this + 6));
    SetupEdges(a2, v28, v9);
    soMaxFlow::soMaxFlow((soMaxFlow *)v63, v26 - v25, (unint64_t *)(HIDWORD(v26) - HIDWORD(v25)));
    if (v62)
    {
      soKMeansClassifier::UpdateClusters(*((soKMeansClassifier **)this + 1), *((unsigned __int8 **)a3 + 10), *((_QWORD *)a3 + 8));
      v29 = v9 * 9.0;
      soKMeansClassifier::GenLikelihoodMap(*((soKMeansClassifier **)this + 1), *((float **)v27 + 10), *((_QWORD *)v27 + 8), 1, 0.0, v29);
      SetupGraph((soMaxFlow *)v63, a2, v28, (HGBitmap *)v27, v30);
      soMaxFlow::Run(v63);
      soMaxFlow::StoreGraphCutToMask((uint64_t)v63, *((unsigned __int8 **)a3 + 10), (*((_DWORD *)a3 + 7) - *((_DWORD *)a3 + 5)), (*((_DWORD *)a3 + 8) - *((_DWORD *)a3 + 6)), *((_QWORD *)a3 + 8), 1u, 0xFEu, 0x80u, 129);
      if (v62 != 1)
      {
        v31 = v62 - 1;
        do
        {
          soKMeansClassifier::UpdateClusters(*((soKMeansClassifier **)this + 1), *((unsigned __int8 **)a3 + 10), *((_QWORD *)a3 + 8));
          soKMeansClassifier::GenLikelihoodMap(*((soKMeansClassifier **)this + 1), *((float **)v27 + 10), *((_QWORD *)v27 + 8), 1, 0.0, v29);
          v32 = soMaxFlow::Reset((soMaxFlow *)v63);
          SetupGraph((soMaxFlow *)v63, a2, v28, (HGBitmap *)v27, *(float *)&v32);
          soMaxFlow::Run(v63);
          soMaxFlow::StoreGraphCutToMask((uint64_t)v63, *((unsigned __int8 **)a3 + 10), (*((_DWORD *)a3 + 7) - *((_DWORD *)a3 + 5)), (*((_DWORD *)a3 + 8) - *((_DWORD *)a3 + 6)), *((_QWORD *)a3 + 8), 1u, 0xFEu, 0x80u, 129);
          --v31;
        }
        while (v31);
      }
    }
    v33 = *((_DWORD *)a3 + 8) - *((_DWORD *)a3 + 6);
    if (!v33)
      goto LABEL_26;
    v34 = (*((_DWORD *)a3 + 7) - *((_DWORD *)a3 + 5));
    if (!(_DWORD)v34)
      goto LABEL_26;
    v35 = (uint8x16_t *)*((_QWORD *)a4 + 10);
    v36 = (uint8x16_t *)*((_QWORD *)a3 + 10);
    if (v34 < 8)
    {
      for (i = 0; i != v33; ++i)
      {
        v38 = v36;
        v39 = (char *)v35;
        v40 = v34;
        do
        {
          v41 = v38->u8[0];
          v38 = (uint8x16_t *)((char *)v38 + 1);
          if (v41 <= 0x80)
            v42 = 0;
          else
            v42 = -1;
          *v39++ = v42;
          --v40;
        }
        while (v40);
        v36 = (uint8x16_t *)((char *)v36 + *((_QWORD *)a3 + 8));
        v35 = (uint8x16_t *)((char *)v35 + *((_QWORD *)a4 + 8));
      }
LABEL_26:
      (*(void (**)(void *))(*(_QWORD *)v27 + 24))(v27);
      (*(void (**)(HGBitmap *))(*(_QWORD *)v28 + 24))(v28);
      (*(void (**)(void *))(*(_QWORD *)v61 + 24))(v61);
      soMaxFlow::~soMaxFlow((soMaxFlow *)v63, v43);
      return;
    }
    v44 = 0;
    v45.i64[0] = 0x8080808080808080;
    v45.i64[1] = 0x8080808080808080;
    while (1)
    {
      if ((unint64_t)((char *)v35 - (char *)v36) < 0x20)
      {
        v46 = 0;
LABEL_41:
        v56 = v34 - v46;
        v57 = &v35->i8[v46];
        v58 = &v36->u8[v46];
        do
        {
          v59 = *v58++;
          if (v59 <= 0x80)
            v60 = 0;
          else
            v60 = -1;
          *v57++ = v60;
          --v56;
        }
        while (v56);
        goto LABEL_29;
      }
      if (v34 >= 0x20)
      {
        v48 = v36 + 1;
        v49 = v35 + 1;
        v50 = v34 & 0xFFFFFFE0;
        do
        {
          v51 = vcgtq_u8(*v48, v45);
          v49[-1] = vcgtq_u8(v48[-1], v45);
          *v49 = v51;
          v48 += 2;
          v49 += 2;
          v50 -= 32;
        }
        while (v50);
        if ((v34 & 0xFFFFFFE0) == v34)
          goto LABEL_29;
        v47 = v34 & 0xFFFFFFE0;
        v46 = v47;
        if ((v34 & 0x18) == 0)
          goto LABEL_41;
      }
      else
      {
        v47 = 0;
      }
      v52 = (uint8x8_t *)&v36->i8[v47];
      v53 = (uint8x8_t *)&v35->i8[v47];
      v54 = v47 - (v34 & 0xFFFFFFF8);
      do
      {
        v55 = *v52++;
        *v53++ = vcgt_u8(v55, (uint8x8_t)0x8080808080808080);
        v54 += 8;
      }
      while (v54);
      v46 = v34 & 0xFFFFFFF8;
      if (v46 != v34)
        goto LABEL_41;
LABEL_29:
      v36 = (uint8x16_t *)((char *)v36 + *((_QWORD *)a3 + 8));
      v35 = (uint8x16_t *)((char *)v35 + *((_QWORD *)a4 + 8));
      if (++v44 == v33)
        goto LABEL_26;
    }
  }
  v15 = *((_DWORD *)a4 + 6);
  v16 = *((_DWORD *)a4 + 8);
  if (v64 == 2)
    v17 = -1;
  else
    v17 = 0;
  v18 = v16 - v15;
  if (v16 != v15)
  {
    v19 = *((_DWORD *)a4 + 7);
    v20 = *((_DWORD *)a4 + 5);
    if (v19 != v20)
    {
      v21 = (char *)*((_QWORD *)a4 + 10);
      v22 = (v19 + ~v20) + 1;
      do
      {
        memset(v21, v17, v22);
        v21 += *((_QWORD *)a4 + 8);
        --v18;
      }
      while (v18);
    }
  }
}

void sub_1B2A591A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p)
{
  HGObject::operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_1B2A591BC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A591D0(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A591E4(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  soMaxFlow::~soMaxFlow((soMaxFlow *)va, a2);
  _Unwind_Resume(a1);
}

void sub_1B2A591F8(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  soMaxFlow::~soMaxFlow((soMaxFlow *)va, a2);
  _Unwind_Resume(a1);
}

void sub_1B2A5920C(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  soMaxFlow::~soMaxFlow((soMaxFlow *)va, a2);
  _Unwind_Resume(a1);
}

uint64_t HGGLTexture::HGGLTexture(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6, uint64_t a7, char a8)
{
  _QWORD *v13;

  v13 = HGTexture::HGTexture(a1, a2, a3, a4, 0);
  *v13 = off_1E6524548;
  v13[16] = a5;
  v13[17] = 0;
  *((_OWORD *)v13 + 9) = HGRectNull;
  *((_DWORD *)v13 + 40) = a6;
  v13[22] = 0;
  v13[23] = 0;
  v13[21] = a7;
  *((_BYTE *)v13 + 192) = a8;
  *((_BYTE *)v13 + 193) = 0;
  *((_DWORD *)v13 + 3) |= 0x210u;
  if (a5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a5 + 16))(a5);
    *(_BYTE *)(a1 + 193) = 1;
  }
  return a1;
}

void sub_1B2A592C8(_Unwind_Exception *a1)
{
  HGBuffer *v1;

  HGBuffer::~HGBuffer(v1);
  _Unwind_Resume(a1);
}

uint64_t HGGLTexture::HGGLTexture(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, char a7)
{
  _QWORD *v11;

  v11 = HGTexture::HGTexture(a1, a2, a3, a4, 0);
  *v11 = off_1E6524548;
  v11[16] = a5;
  v11[17] = 0;
  *((_OWORD *)v11 + 9) = HGRectNull;
  *((_DWORD *)v11 + 40) = 3553;
  v11[22] = 0;
  v11[23] = 0;
  v11[21] = a6;
  *((_BYTE *)v11 + 192) = a7;
  *((_BYTE *)v11 + 193) = 0;
  *((_DWORD *)v11 + 3) |= 0x210u;
  if (a5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a5 + 16))(a5);
    *(_BYTE *)(a1 + 193) = 1;
  }
  return a1;
}

void sub_1B2A5937C(_Unwind_Exception *a1)
{
  HGBuffer *v1;

  HGBuffer::~HGBuffer(v1);
  _Unwind_Resume(a1);
}

void HGGLTexture::HGGLTexture(HGGLTexture *this, HGRect a2, HGBitmap *a3, HGGPURenderer *a4)
{
  uint64_t v6;

  HGTexture::HGTexture((HGTexture *)this, a2, a3);
  *(_QWORD *)v6 = off_1E6524548;
  *(_QWORD *)(v6 + 128) = a4;
  *(_QWORD *)(v6 + 136) = 0;
  *(_OWORD *)(v6 + 144) = HGRectNull;
  *(_DWORD *)(v6 + 160) = 0;
  *(_QWORD *)(v6 + 176) = 0;
  *(_QWORD *)(v6 + 184) = 0;
  *(_QWORD *)(v6 + 168) = 0;
  *(_WORD *)(v6 + 192) = 1;
  *(_DWORD *)(v6 + 12) |= 0x210u;
  if (a4)
  {
    (*(void (**)(HGGPURenderer *))(*(_QWORD *)a4 + 16))(a4);
    *((_BYTE *)this + 193) = 1;
  }
}

void sub_1B2A59418(_Unwind_Exception *a1)
{
  HGBuffer *v1;

  HGBuffer::~HGBuffer(v1);
  _Unwind_Resume(a1);
}

void HGGLTexture::~HGGLTexture(HGGLTexture *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E6524548;
  v2 = *((_QWORD *)this + 16);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    *((_QWORD *)this + 16) = 0;
  }
  v3 = *((_QWORD *)this + 17);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
    *((_QWORD *)this + 17) = 0;
  }
  HGBuffer::~HGBuffer((HGBuffer *)this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_1E6524548;
  v2 = *((_QWORD *)this + 16);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    *((_QWORD *)this + 16) = 0;
  }
  v3 = *((_QWORD *)this + 17);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
    *((_QWORD *)this + 17) = 0;
  }
  HGBuffer::~HGBuffer((HGBuffer *)this);
  HGObject::operator delete(v4);
}

HGGLTexture *HGGLTexture::AssignRenderer(HGGLTexture *this, HGGPURenderer *a2)
{
  HGGLTexture *v2;

  if (a2)
  {
    v2 = this;
    if (!*((_QWORD *)this + 16))
    {
      *((_QWORD *)this + 16) = a2;
      this = (HGGLTexture *)(*(uint64_t (**)(HGGPURenderer *))(*(_QWORD *)a2 + 16))(a2);
      *((_WORD *)v2 + 96) = 257;
    }
  }
  return this;
}

unsigned int *HGGLTexture::Release(HGGLTexture *this)
{
  unsigned int v2;
  uint64_t v3;

  if (*((_QWORD *)this + 16))
  {
    v2 = atomic_load((unsigned int *)this + 2);
    if (v2 == 1)
    {
      HGGPURenderer::ReleaseTexture(*((int64x2_t **)this + 16), this, (char *)1);
      v3 = *((_QWORD *)this + 16);
      if (v3)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
        *((_QWORD *)this + 16) = 0;
      }
    }
  }
  return HGObject::Release((unsigned int *)this);
}

uint64_t HGGLTexture::GetTextureRect(HGGLTexture *this)
{
  _BOOL4 IsZero;
  uint64_t v3;

  IsZero = HGRect::IsZero((HGRect *)this + 9);
  v3 = 144;
  if (IsZero)
    v3 = 20;
  return *(_QWORD *)((char *)this + v3);
}

_QWORD *HGGLTexture::CreateTexture(HGGLTexture *this, HGGLBuffer *a2, HGGPURenderer *a3)
{
  _QWORD *v5;
  uint64_t v6;
  const HGEdgePolicy *EdgePolicy;

  v5 = HGObject::operator new(0xC8uLL);
  HGTexture::HGTexture((uint64_t)v5, *(_QWORD *)((char *)this + 20), *(_QWORD *)((char *)this + 28), *((_DWORD *)this + 4), 0);
  *v5 = off_1E6524548;
  v5[16] = a2;
  v5[17] = 0;
  *((_OWORD *)v5 + 9) = HGRectNull;
  *((_DWORD *)v5 + 40) = 0;
  v5[22] = 0;
  v5[23] = 0;
  v5[21] = 0;
  *((_WORD *)v5 + 96) = 1;
  *((_DWORD *)v5 + 3) |= 0x210u;
  if (a2)
  {
    (*(void (**)(HGGLBuffer *))(*(_QWORD *)a2 + 16))(a2);
    *((_BYTE *)v5 + 193) = 1;
  }
  v5[17] = this;
  v6 = *((unsigned int *)this + 39);
  *((_DWORD *)v5 + 40) = *((_DWORD *)this + 38);
  v5[21] = v6;
  EdgePolicy = (const HGEdgePolicy *)HGBitmap::GetEdgePolicy((HGBitmap *)this);
  HGBitmap::SetEdgePolicy((HGBitmap *)v5, EdgePolicy);
  *((_OWORD *)v5 + 9) = *(_OWORD *)((char *)this + 136);
  (*(void (**)(HGGLTexture *))(*(_QWORD *)this + 16))(this);
  return v5;
}

void sub_1B2A596C8(_Unwind_Exception *a1)
{
  HGBuffer *v1;
  void *v3;

  HGBuffer::~HGBuffer(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B2A596E0(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGGLTexture::ReadPixels(HGGLTexture *this, HGPixelBufferObj *a2, HGRect a3)
{
  uint64_t v3;
  uint64_t v4;
  _BOOL4 IsZero;
  uint64_t v8;

  v3 = *(_QWORD *)&a3.var2;
  v4 = *(_QWORD *)&a3.var0;
  IsZero = HGRect::IsZero((HGRect *)this + 9);
  v8 = 144;
  if (IsZero)
    v8 = 20;
  HGPixelBufferObj::ReadPixels((uint64_t)a2, v4, v3, *(_QWORD *)((char *)this + 20), *(_QWORD *)((char *)this + 28), (*((_DWORD *)this + 5) - *(_DWORD *)((char *)this + v8)), (*((_DWORD *)this + 6) - *(_DWORD *)((char *)this + v8 + 4)), *((_DWORD *)this + 4));
}

HGGLTexture *HGGLTexture::AttachRenderer(HGGLTexture *this, HGGPURenderer *a2)
{
  if (!*((_BYTE *)this + 193) && a2 && !*((_QWORD *)this + 16))
  {
    *((_QWORD *)this + 16) = a2;
    return (HGGLTexture *)(*(uint64_t (**)(HGGPURenderer *))(*(_QWORD *)a2 + 16))(a2);
  }
  return this;
}

HGGLTexture *HGGLTexture::DetachRenderer(HGGLTexture *this)
{
  HGGLTexture *v1;

  if (!*((_BYTE *)this + 193))
  {
    v1 = this;
    this = (HGGLTexture *)*((_QWORD *)this + 16);
    if (this)
    {
      this = (HGGLTexture *)(*(uint64_t (**)(HGGLTexture *))(*(_QWORD *)this + 24))(this);
      *((_QWORD *)v1 + 16) = 0;
    }
  }
  return this;
}

void HGEdgePolicy::HGEdgePolicy(HGEdgePolicy *this)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
}

uint64_t HGEdgePolicy::HGEdgePolicy(uint64_t result, int a2)
{
  *(_DWORD *)result = a2;
  *(_QWORD *)(result + 12) = 0;
  *(_QWORD *)(result + 4) = 0;
  return result;
}

BOOL HGEdgePolicy::isDefault(HGEdgePolicy *this)
{
  return !*(_DWORD *)this
      && *((float *)this + 1) == 0.0
      && *((float *)this + 2) == 0.0
      && *((float *)this + 3) == 0.0
      && *((float *)this + 4) == 0.0;
}

uint64_t HGBitmap::HGBitmap(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8;
  int v9;
  char *v10;
  unsigned int v11;
  unint64_t *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v16;

  HGObject::HGObject((HGObject *)a1);
  *(_QWORD *)v8 = off_1E65245C8;
  *(_DWORD *)(v8 + 12) = 0;
  *(_DWORD *)(v8 + 16) = a4;
  *(_QWORD *)(v8 + 20) = a2;
  *(_QWORD *)(a1 + 28) = a3;
  *(_QWORD *)(a1 + 36) = a2;
  *(_QWORD *)(a1 + 44) = a3;
  *(_QWORD *)(a1 + 120) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 100) = 0u;
  if (!HGRect::IsNull((HGRect *)(v8 + 20)))
  {
    v9 = *(_DWORD *)(a1 + 16);
    if (v9)
    {
      *(_QWORD *)(a1 + 56) = HGFormatUtils::bytesPerPixel(v9);
      v11 = HGFormatUtils::rowBytesHint(a4, (const char *)(*(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 20)), v10);
      *(_QWORD *)(a1 + 64) = v11;
      v13 = HGMemory::allocate((HGMemory *)((*(int *)(a1 + 32) - (uint64_t)*(int *)(a1 + 24)) * v11), &v16, v12);
      v14 = v16;
      *(_QWORD *)(a1 + 80) = v13;
      *(_QWORD *)(a1 + 88) = v13;
      *(_QWORD *)(a1 + 72) = v14;
    }
  }
  return a1;
}

void sub_1B2A5992C(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A59940(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

uint64_t HGBitmap::HGBitmap(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  HGObject::HGObject((HGObject *)a1);
  *(_QWORD *)v10 = off_1E65245C8;
  *(_DWORD *)(v10 + 12) = 0;
  *(_DWORD *)(v10 + 16) = a4;
  *(_QWORD *)(v10 + 20) = a2;
  *(_QWORD *)(a1 + 28) = a3;
  *(_QWORD *)(a1 + 36) = a2;
  *(_QWORD *)(a1 + 44) = a3;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = a5;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  if (!HGRect::IsNull((HGRect *)(v10 + 20)))
  {
    v11 = *(_DWORD *)(a1 + 16);
    if (v11)
    {
      v12 = HGFormatUtils::bytesPerPixel(v11);
      v13 = *(int *)(a1 + 32);
      v14 = *(int *)(a1 + 24);
      v15 = (*(int *)(a1 + 28) - (uint64_t)*(int *)(a1 + 20)) * v12;
      *(_QWORD *)(a1 + 56) = v12;
      *(_QWORD *)(a1 + 64) = v15;
      *(_QWORD *)(a1 + 72) = v15 * (v13 - v14);
    }
  }
  return a1;
}

{
  uint64_t v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  HGObject::HGObject((HGObject *)a1);
  *(_QWORD *)v10 = off_1E65245C8;
  *(_DWORD *)(v10 + 12) = 0;
  *(_DWORD *)(v10 + 16) = a4;
  *(_QWORD *)(v10 + 20) = a2;
  *(_QWORD *)(a1 + 28) = a3;
  *(_QWORD *)(a1 + 36) = a2;
  *(_QWORD *)(a1 + 44) = a3;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = a5;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  if (!HGRect::IsNull((HGRect *)(v10 + 20)))
  {
    v11 = *(_DWORD *)(a1 + 16);
    if (v11)
    {
      v12 = HGFormatUtils::bytesPerPixel(v11);
      v13 = *(int *)(a1 + 32);
      v14 = *(int *)(a1 + 24);
      v15 = (*(int *)(a1 + 28) - (uint64_t)*(int *)(a1 + 20)) * v12;
      *(_QWORD *)(a1 + 56) = v12;
      *(_QWORD *)(a1 + 64) = v15;
      *(_QWORD *)(a1 + 72) = v15 * (v13 - v14);
    }
  }
  return a1;
}

void sub_1B2A59A0C(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A59AD4(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

uint64_t HGBitmap::HGBitmap(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unint64_t a6)
{
  uint64_t v12;
  _OWORD *v13;
  _OWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  _BOOL4 v19;

  HGObject::HGObject((HGObject *)a1);
  *(_QWORD *)v12 = off_1E65245C8;
  *(_DWORD *)(v12 + 12) = 0;
  *(_DWORD *)(v12 + 16) = a4;
  *(_QWORD *)(v12 + 20) = a2;
  v13 = (_OWORD *)(v12 + 20);
  *(_QWORD *)(v12 + 28) = a3;
  *(_QWORD *)(v12 + 36) = a2;
  v14 = (_OWORD *)(v12 + 36);
  *(_QWORD *)(v12 + 44) = a3;
  *(_QWORD *)(v12 + 56) = 0;
  v15 = v12 + 56;
  *(_QWORD *)(v12 + 64) = 0;
  *(_QWORD *)(v12 + 72) = 0;
  *(_QWORD *)(v12 + 120) = 0;
  *(_QWORD *)(v12 + 80) = a5;
  *(_QWORD *)(v12 + 88) = 0;
  *(_QWORD *)(v12 + 96) = 0;
  *(_QWORD *)(v12 + 104) = 0;
  *(_DWORD *)(v12 + 112) = 0;
  if (HGRect::IsNull((HGRect *)(v12 + 20)))
  {
    v16 = *(_QWORD *)(a1 + 56);
    a6 = *(_QWORD *)(a1 + 64);
    v17 = (*(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 20));
    if (*(_DWORD *)(a1 + 16) != 31)
      goto LABEL_8;
LABEL_6:
    v19 = a6 >= 4 * v16 * v17 / 6uLL;
    goto LABEL_9;
  }
  v18 = *(_DWORD *)(a1 + 16);
  if (v18)
  {
    v16 = HGFormatUtils::bytesPerPixel(v18);
    *(_QWORD *)(a1 + 56) = v16;
    *(_QWORD *)(a1 + 64) = a6;
    *(_QWORD *)(a1 + 72) = (*(int *)(a1 + 32) - (uint64_t)*(int *)(a1 + 24)) * a6;
    v17 = (*(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 20));
    if (*(_DWORD *)(a1 + 16) == 31)
      goto LABEL_6;
  }
  else
  {
    v17 = (*(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 20));
    v16 = *(_QWORD *)(a1 + 56);
    a6 = *(_QWORD *)(a1 + 64);
  }
LABEL_8:
  v19 = v17 * v16 <= a6;
LABEL_9:
  if (!v19 || a6 * (*(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 24)) > *(_QWORD *)(a1 + 72))
  {
    *(_DWORD *)(a1 + 16) = 0;
    *v14 = HGRectNull;
    *v13 = HGRectNull;
    *(_OWORD *)v15 = 0u;
    *(_OWORD *)(v15 + 16) = 0u;
    *(_QWORD *)(v15 + 32) = 0;
  }
  return a1;
}

void sub_1B2A59C60(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

uint64_t HGBitmap::HGBitmap(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
  uint64_t v14;
  _OWORD *v15;
  _OWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  _BOOL4 v21;

  HGObject::HGObject((HGObject *)a1);
  *(_QWORD *)v14 = off_1E65245C8;
  *(_DWORD *)(v14 + 12) = 0;
  *(_DWORD *)(v14 + 16) = a4;
  *(_QWORD *)(v14 + 20) = a2;
  v15 = (_OWORD *)(v14 + 20);
  *(_QWORD *)(v14 + 28) = a3;
  *(_QWORD *)(v14 + 36) = a2;
  v16 = (_OWORD *)(v14 + 36);
  *(_QWORD *)(v14 + 44) = a3;
  *(_QWORD *)(v14 + 56) = 0;
  v17 = v14 + 56;
  *(_QWORD *)(v14 + 64) = 0;
  *(_QWORD *)(v14 + 72) = 0;
  *(_QWORD *)(v14 + 120) = 0;
  *(_QWORD *)(v14 + 80) = a5;
  *(_QWORD *)(v14 + 88) = 0;
  *(_QWORD *)(v14 + 96) = 0;
  *(_QWORD *)(v14 + 104) = 0;
  *(_DWORD *)(v14 + 112) = 0;
  if (HGRect::IsNull((HGRect *)(v14 + 20)))
  {
    v18 = *(_QWORD *)(a1 + 56);
    a6 = *(_QWORD *)(a1 + 64);
    v19 = (*(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 20));
    if (*(_DWORD *)(a1 + 16) != 31)
      goto LABEL_8;
LABEL_6:
    v21 = a6 >= 4 * v18 * v19 / 6uLL;
    goto LABEL_9;
  }
  v20 = *(_DWORD *)(a1 + 16);
  if (v20)
  {
    v18 = HGFormatUtils::bytesPerPixel(v20);
    *(_QWORD *)(a1 + 56) = v18;
    *(_QWORD *)(a1 + 64) = a6;
    *(_QWORD *)(a1 + 72) = a7;
    v19 = (*(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 20));
    if (*(_DWORD *)(a1 + 16) == 31)
      goto LABEL_6;
  }
  else
  {
    v19 = (*(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 20));
    v18 = *(_QWORD *)(a1 + 56);
    a6 = *(_QWORD *)(a1 + 64);
  }
LABEL_8:
  v21 = v19 * v18 <= a6;
LABEL_9:
  if (!v21 || a6 * (*(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 24)) > *(_QWORD *)(a1 + 72))
  {
    *(_DWORD *)(a1 + 16) = 0;
    *v16 = HGRectNull;
    *v15 = HGRectNull;
    *(_OWORD *)v17 = 0u;
    *(_OWORD *)(v17 + 16) = 0u;
    *(_QWORD *)(v17 + 32) = 0;
  }
  return a1;
}

void sub_1B2A59DE4(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGBitmap::HGBitmap(HGBitmap *this, HGRect a2, HGBitmap *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  HGRect v18;

  v4 = *(_QWORD *)&a2.var2;
  v5 = *(_QWORD *)&a2.var0;
  HGObject::HGObject((HGObject *)this);
  *(_QWORD *)v7 = off_1E65245C8;
  *(_DWORD *)(v7 + 12) = 0;
  *(_DWORD *)(v7 + 16) = 0;
  *(_OWORD *)(v7 + 20) = HGRectNull;
  *(_OWORD *)(v7 + 36) = HGRectNull;
  *(_QWORD *)(v7 + 120) = 0;
  *(_OWORD *)(v7 + 56) = 0u;
  *(_OWORD *)(v7 + 72) = 0u;
  *(_OWORD *)(v7 + 88) = 0u;
  *(_OWORD *)(v7 + 100) = 0u;
  if (a3)
  {
    *(_QWORD *)&v18.var0 = HGRectIntersection(*(_QWORD *)((char *)a3 + 20), *(_QWORD *)((char *)a3 + 28), v5, v4);
    *(_QWORD *)&v18.var2 = v8;
    if (!HGRect::IsNull(&v18))
    {
      *((_QWORD *)this + 15) = a3;
      (*(void (**)(HGBitmap *))(*(_QWORD *)a3 + 16))(a3);
      *(HGRect *)((char *)this + 20) = v18;
      v9 = *((_DWORD *)a3 + 4);
      *((_DWORD *)this + 4) = v9;
      *(_OWORD *)((char *)this + 36) = *(_OWORD *)((char *)a3 + 36);
      v10 = *((_QWORD *)a3 + 8);
      *((_QWORD *)this + 8) = v10;
      v11 = *((_QWORD *)a3 + 7);
      *((_QWORD *)this + 7) = v11;
      v12 = *((_OWORD *)a3 + 6);
      *((_DWORD *)this + 28) = *((_DWORD *)a3 + 28);
      *((_OWORD *)this + 6) = v12;
      *((_DWORD *)this + 3) = *((_DWORD *)a3 + 3);
      v13 = *((_QWORD *)a3 + 10);
      if (v13)
      {
        v14 = v10 * (*((int *)this + 6) - (uint64_t)*((int *)a3 + 6));
        v15 = *((int *)this + 5) - (uint64_t)*((int *)a3 + 5);
        if (v9 == 31)
          v16 = v11 * 4 * (int)v15 / 6uLL;
        else
          v16 = v11 * v15;
        v17 = v16 + v14;
        *((_QWORD *)this + 10) = v13 + v17;
        *((_QWORD *)this + 9) = *((_QWORD *)a3 + 9) - v17;
      }
    }
  }
}

void sub_1B2A59F60(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGBitmap::~HGBitmap(HGBitmap *this, void *a2)
{
  uint64_t v3;
  HGMemory *v4;

  *(_QWORD *)this = off_1E65245C8;
  v3 = *((_QWORD *)this + 15);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  }
  else
  {
    v4 = (HGMemory *)*((_QWORD *)this + 11);
    if (v4)
      HGMemory::release(v4, a2);
  }
  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 36) = HGRectNull;
  *(_OWORD *)((char *)this + 20) = HGRectNull;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_QWORD *)this + 11) = 0;
  HGObject::~HGObject((HGObject *)this);
}

{
  uint64_t v3;
  HGMemory *v4;

  *(_QWORD *)this = off_1E65245C8;
  v3 = *((_QWORD *)this + 15);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  }
  else
  {
    v4 = (HGMemory *)*((_QWORD *)this + 11);
    if (v4)
      HGMemory::release(v4, a2);
  }
  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 36) = HGRectNull;
  *(_OWORD *)((char *)this + 20) = HGRectNull;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_QWORD *)this + 11) = 0;
  HGObject::~HGObject((HGObject *)this);
}

{
  uint64_t v3;
  HGMemory *v4;
  void *v5;

  *(_QWORD *)this = off_1E65245C8;
  v3 = *((_QWORD *)this + 15);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  }
  else
  {
    v4 = (HGMemory *)*((_QWORD *)this + 11);
    if (v4)
      HGMemory::release(v4, a2);
  }
  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 36) = HGRectNull;
  *(_OWORD *)((char *)this + 20) = HGRectNull;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_QWORD *)this + 11) = 0;
  HGObject::~HGObject((HGObject *)this);
  HGObject::operator delete(v5);
}

unint64_t HGBitmap::byteOffset(HGBitmap *this, int a2, int a3)
{
  unint64_t v3;

  v3 = *((_QWORD *)this + 7) * (a2 - (uint64_t)*((int *)this + 5));
  if (*((_DWORD *)this + 4) == 31)
    v3 = 4 * v3 / 6;
  return v3 + *((_QWORD *)this + 8) * (a3 - (uint64_t)*((int *)this + 6));
}

HGObject *HGBitmap::SetStorage(HGBitmap *this, HGObject *a2)
{
  HGObject *result;

  result = (HGObject *)*((_QWORD *)this + 15);
  if (result != a2)
  {
    if (result)
      result = (HGObject *)(*(uint64_t (**)(HGObject *))(*(_QWORD *)result + 24))(result);
    *((_QWORD *)this + 15) = a2;
    if (a2)
      return (HGObject *)(*(uint64_t (**)(HGObject *))(*(_QWORD *)a2 + 16))(a2);
  }
  return result;
}

uint64_t HGBitmap::GetStorage(HGBitmap *this)
{
  return *((_QWORD *)this + 15);
}

uint64_t HGBitmap::GetEdgePolicy(HGBitmap *this)
{
  return (uint64_t)this + 96;
}

__n128 HGBitmap::SetEdgePolicy(HGBitmap *this, const HGEdgePolicy *a2)
{
  __n128 result;

  result = *(__n128 *)a2;
  *((_DWORD *)this + 28) = *((_DWORD *)a2 + 4);
  *((__n128 *)this + 6) = result;
  return result;
}

void HGBitmap::ReadTile(HGBitmap *this, char *a2, HGRect a3, int a4)
{
  int var2;
  int var0;
  int var1;
  int var3;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  BOOL v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  char *v25;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  char *v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  int v36;
  BOOL v38;
  int v39;
  BOOL v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int v48;
  size_t v49;
  int v50;
  uint64_t v51;
  int v52;
  unint64_t v53;

  var2 = a3.var2;
  var0 = a3.var0;
  var1 = a3.var1;
  var3 = a3.var3;
  v11 = HGRectIntersection(*(uint64_t *)&a3.var0, *(uint64_t *)&a3.var2, *(_QWORD *)((char *)this + 20), *(_QWORD *)((char *)this + 28));
  if (!*((_QWORD *)this + 10) || (v13 = v11, v14 = v12, HGRectIsNull(v11, v12)))
  {
    v15 = var2 - var0;
    v16 = var3 - var1;
    if (a4)
    {
      if (v16 >= 1 && v15 >= 1)
      {
        v17 = 16 * (v15 + a4);
        do
        {
          bzero(a2, 16 * (var2 - var0));
          a2 += v17;
          --v16;
        }
        while (v16);
      }
    }
    else
    {
      v18 = v16 * v15;
      if (v18 >= 1)
        bzero(a2, 16 * v18);
    }
    return;
  }
  v50 = a4;
  v19 = HIDWORD(v13);
  v48 = v14;
  v52 = v13;
  v53 = HIDWORD(v14);
  v20 = __OFSUB__(var3, HIDWORD(v14));
  v21 = var3 - HIDWORD(v14);
  if (!((v21 < 0) ^ v20 | (v21 == 0)))
  {
    v22 = var2 - var0;
    v23 = var2 - var0 + a4;
    v24 = (HIDWORD(v14) - var1) * (uint64_t)v23;
    v25 = &a2[16 * v24];
    if (v50)
    {
      if (v21 >= 1 && v22 >= 1)
      {
        v27 = 16 * v23;
        do
        {
          bzero(v25, 16 * (var2 - var0));
          v25 += v27;
          --v21;
        }
        while (v21);
      }
    }
    else
    {
      v28 = v21 * v22;
      if (v28 >= 1)
        bzero(&a2[16 * v24], 16 * v28);
    }
  }
  v29 = v19 - var1;
  if ((int)v19 <= var1)
  {
    v33 = v50;
    v34 = v14;
    if ((int)v19 >= SHIDWORD(v14))
      return;
    goto LABEL_34;
  }
  v30 = var2 - var0;
  v46 = var2 - var0;
  if (v50)
  {
    if (v29 >= 1 && v46 >= 1)
    {
      v31 = a2;
      v32 = v19 - var1;
      do
      {
        bzero(v31, 16 * (var2 - var0));
        v31 += 16 * v46 + 16 * v50;
        --v32;
      }
      while (v32);
    }
  }
  else if (v29 * v30 >= 1)
  {
    bzero(a2, 16 * (v29 * v30));
  }
  v33 = v50;
  v34 = v48;
  a2 += 16 * v29 * (v46 + v50);
  if ((int)v19 < (int)v53)
  {
LABEL_34:
    v35 = (v34 - v52);
    v36 = v33 - var0;
    v38 = v52 <= var0 || v52 - var0 < 1;
    v49 = 16 * (var2 - v34);
    v51 = 16 * (v52 - var0);
    v39 = v36 + var2;
    v41 = var2 <= v34 || var2 - v34 < 1;
    v47 = 16 * (v34 - var0);
    v42 = 16 * v39;
    v43 = 16 * (v52 - var0);
    do
    {
      if (v38)
      {
        if (v41)
          goto LABEL_51;
      }
      else
      {
        bzero(a2, v51);
        if (v41)
        {
LABEL_51:
          v45 = *((unsigned int *)this + 4);
          if ((_DWORD)v45 == 31)
            goto LABEL_55;
          goto LABEL_47;
        }
      }
      bzero(&a2[v47], v49);
      v45 = *((unsigned int *)this + 4);
      if ((_DWORD)v45 == 31)
      {
LABEL_55:
        v44 = *((_QWORD *)this + 10)
            + *((_QWORD *)this + 8) * ((int)v19 - *((_DWORD *)this + 6))
            + *((_QWORD *)this + 7) * (4 * ((v52 - *((_DWORD *)this + 5)) / 6))
            + _4b10BitYXZX_OffsetList[4 * ((v52 - *((_DWORD *)this + 5)) % 6)];
        goto LABEL_48;
      }
LABEL_47:
      v44 = *((_QWORD *)this + 10)
          + *((_QWORD *)this + 8) * ((int)v19 - *((_DWORD *)this + 6))
          + *((_QWORD *)this + 7) * (v52 - (uint64_t)*((int *)this + 5));
LABEL_48:
      ((void (*)(char *, uint64_t, uint64_t))hg_span_read[v45])(&a2[v43], v35, v44);
      LODWORD(v19) = v19 + 1;
      a2 += v42;
    }
    while ((_DWORD)v53 != (_DWORD)v19);
  }
}

void HGBitmap::WriteTile(HGBitmap *this, char *a2, HGRect a3)
{
  unint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  size_t v15;

  v3 = *((_QWORD *)this + 10);
  if (!v3)
    return;
  v4 = *(_QWORD *)&a3.var0;
  v5 = a2;
  if (*((_DWORD *)this + 4) == 31)
  {
    v7 = *((_QWORD *)this + 7);
    v8 = 715827883 * (a3.var0 - *((_DWORD *)this + 5));
    v9 = (char *)(v3
                + *((_QWORD *)this + 8) * (a3.var1 - (uint64_t)*((int *)this + 6))
                + v7 * 4 * (HIDWORD(v8) + (v8 >> 63)));
    v3 = v7 * (unint64_t)(4 * (a3.var2 - a3.var0)) / 6;
    if (a2)
      goto LABEL_4;
  }
  else
  {
    v13 = *((_QWORD *)this + 7);
    v9 = (char *)(v3
                + *((_QWORD *)this + 8) * (a3.var1 - (uint64_t)*((int *)this + 6))
                + v13 * (a3.var0 - (uint64_t)*((int *)this + 5)));
    LODWORD(v3) = (a3.var2 - a3.var0) * v13;
    if (a2)
    {
LABEL_4:
      v10 = a3.var3 - a3.var1;
      if (a3.var3 > a3.var1)
      {
        v11 = (a3.var2 - a3.var0);
        v12 = 16 * a3.var2 - 16 * a3.var0;
        do
        {
          ((void (*)(char *, uint64_t, char *, uint64_t))hg_span_write[*((unsigned int *)this + 4)])(v9, v11, v5, v4);
          v9 += *((_QWORD *)this + 8);
          v5 += v12;
          --v10;
        }
        while (v10);
      }
      return;
    }
  }
  v14 = a3.var3 - a3.var1;
  if (a3.var3 > a3.var1 && (int)v3 >= 1)
  {
    v15 = v3;
    do
    {
      bzero(v9, v15);
      v9 += *((_QWORD *)this + 8);
      --v14;
    }
    while (v14);
  }
}

void hg_span_read_null(void *a1, int a2)
{
  if (a2 >= 1)
    bzero(a1, 16 * a2);
}

_OWORD *hg_span_read_1b(_OWORD *result, int a2, unsigned __int8 *a3)
{
  unsigned int v3;
  unsigned int v4;
  __int128 v5;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3++;
      *(float *)&v5 = (float)v4 * 0.0039216;
      DWORD1(v5) = 0;
      DWORD2(v5) = 0;
      HIDWORD(v5) = 1.0;
      *result++ = v5;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_1b_m(_OWORD *result, int a2, unsigned __int8 *a3)
{
  unsigned int v3;
  unsigned int v4;
  __int128 v5;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3++;
      *(_QWORD *)&v5 = 0;
      DWORD2(v5) = 0;
      *((float *)&v5 + 3) = (float)v4 * 0.0039216;
      *result++ = v5;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_1s(_OWORD *result, int a2, unsigned __int16 *a3)
{
  unsigned int v3;
  unsigned int v4;
  __int128 v5;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3++;
      *(float *)&v5 = (float)v4 * 0.000015259;
      DWORD1(v5) = 0;
      DWORD2(v5) = 0;
      HIDWORD(v5) = 1.0;
      *result++ = v5;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_1s_m(_OWORD *result, int a2, unsigned __int16 *a3)
{
  unsigned int v3;
  unsigned int v4;
  __int128 v5;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3++;
      *(_QWORD *)&v5 = 0;
      DWORD2(v5) = 0;
      *((float *)&v5 + 3) = (float)v4 * 0.000015259;
      *result++ = v5;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

float32x4_t *hg_span_read_1h(float32x4_t *result, int a2, __int16 *a3)
{
  unsigned int v3;
  unsigned int v4;
  int32x4_t v5;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3++;
      v5.i64[0] = v4;
      v5.i64[1] = 0x3C0000000000;
      *result++ = vcvtq_f32_f16((float16x4_t)vqmovn_s32(v5));
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

float32x4_t *hg_span_read_1h_m(float32x4_t *result, int a2, __int16 *a3)
{
  unsigned int v3;
  __int32 v4;
  int32x4_t v5;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3++;
      v5.i64[0] = 0;
      v5.i32[2] = 0;
      v5.i32[3] = v4;
      *result++ = vcvtq_f32_f16((float16x4_t)vqmovn_s32(v5));
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_1f(_OWORD *result, int a2, unsigned int *a3)
{
  unsigned int v3;
  unsigned int v4;
  __int128 v5;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3++;
      *(_QWORD *)&v5 = v4;
      DWORD2(v5) = 0;
      HIDWORD(v5) = 1.0;
      *result++ = v5;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_1f_m(_OWORD *result, int a2, _DWORD *a3)
{
  unsigned int v3;
  __int128 v4;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      *(_QWORD *)&v4 = 0;
      DWORD2(v4) = 0;
      HIDWORD(v4) = *a3++;
      *result++ = v4;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_2b(_OWORD *result, int a2, unsigned __int8 *a3)
{
  unsigned int v3;
  float32x2_t v4;
  uint32x2_t v5;
  __int128 v6;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    v4 = (float32x2_t)vdup_n_s32(0x3B808081u);
    do
    {
      v5.i32[0] = *a3;
      v5.i32[1] = a3[1];
      *(float32x2_t *)&v6 = vmul_f32(vcvt_f32_u32(v5), v4);
      *((_QWORD *)&v6 + 1) = 0x3F80000000000000;
      *result++ = v6;
      a3 += 2;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_2s(_OWORD *result, int a2, unsigned __int16 *a3)
{
  unsigned int v3;
  float32x2_t v4;
  uint32x2_t v5;
  __int128 v6;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    v4 = (float32x2_t)vdup_n_s32(0x37800080u);
    do
    {
      v5.i32[0] = *a3;
      v5.i32[1] = a3[1];
      *(float32x2_t *)&v6 = vmul_f32(vcvt_f32_u32(v5), v4);
      *((_QWORD *)&v6 + 1) = 0x3F80000000000000;
      *result++ = v6;
      a3 += 2;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

float32x4_t *hg_span_read_2h(float32x4_t *result, int a2, __int16 *a3)
{
  unsigned int v3;
  int32x4_t v4;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4.i32[0] = *a3;
      v4.i32[1] = a3[1];
      v4.i64[1] = 0x3C0000000000;
      *result++ = vcvtq_f32_f16((float16x4_t)vqmovn_s32(v4));
      --v3;
      a3 += 2;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_2f(_OWORD *result, int a2, uint64_t *a3)
{
  unsigned int v3;
  uint64_t v4;
  __int128 v5;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3++;
      *(_QWORD *)&v5 = v4;
      *((_QWORD *)&v5 + 1) = 0x3F80000000000000;
      *result++ = v5;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

float32x4_t hg_span_read_2b_yxzx(uint64_t a1, int a2, int8x16_t *_X2, float32x4_t result, float a5, __n128 a6, float32x4_t a7, float a8, __n128 a9)
{
  __int8 *v9;
  unsigned int v10;
  float32x4_t v11;
  uint64_t v12;
  int8x16_t *v13;
  int8x16_t v14;
  unsigned int v15;
  float32x4_t v21;
  int32x4_t v22;
  __int128 v23;
  int32x4_t v24;
  float32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  float32x4_t v28;
  int32x4_t v29;
  int32x4_t v30;
  float32x4_t v31;
  int32x4_t v32;
  int32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  unsigned int v36;
  float32x4_t v37;

  if ((_X2 & 3) != 0)
  {
    result.i8[0] = _X2[-1].i8[14];
    LOBYTE(a5) = _X2->i8[0];
    a6.n128_u8[0] = _X2->u8[1];
    a6.n128_f32[0] = (float)a6.n128_u32[0];
    a7.i8[12] = 0;
    a7.i8[13] = 0;
    a7.i8[14] = 0;
    a7.i8[15] = 0;
    a7.i32[0] = a6.n128_u32[0];
    a7.f32[1] = (float)result.u32[0];
    a7.f32[2] = (float)LODWORD(a5);
    a5 = 0.0;
    result = vaddq_f32(vmulq_f32(a7, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
    *(float32x4_t *)a1 = result;
    a1 += 16;
    _X2 = (int8x16_t *)((char *)_X2 + 2);
    --a2;
  }
  if (a2 >= 2 && (_X2 & 0xF) != 0)
  {
    v9 = &_X2->i8[4];
    result = (float32x4_t)xmmword_1B351FB30;
    a5 = 0.0;
    do
    {
      v10 = a2;
      a6.n128_u8[0] = _X2->i8[0];
      a7.i8[0] = _X2->i8[1];
      LOBYTE(a8) = _X2->i8[2];
      a8 = (float)LODWORD(a8);
      a9.n128_u8[0] = _X2->u8[3];
      v11.f32[0] = (float)a7.u32[0];
      v11.f32[1] = (float)a6.n128_u32[0];
      v11.i64[1] = LODWORD(a8);
      a7.f32[0] = (float)a9.n128_u32[0];
      a9 = (__n128)vaddq_f32(vmulq_f32(v11, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
      v11.i32[0] = a7.i32[0];
      v11.i64[1] = LODWORD(a8);
      a6 = (__n128)vaddq_f32(vmulq_f32(v11, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
      *(__n128 *)a1 = a9;
      *(__n128 *)(a1 + 16) = a6;
      a1 += 32;
      _X2 = (int8x16_t *)((char *)_X2 + 4);
      a2 -= 2;
      if (v10 < 4)
        break;
      v12 = v9 & 0xF;
      v9 += 4;
    }
    while (v12);
  }
  if (a2 >= 8)
  {
    result.i64[0] = 0xFFFFFF01FFFFFF00;
    a5 = NAN;
    a6.n128_u32[0] = 998277249;
    a7.i32[0] = 998277249;
    a8 = 0.0;
    a9.n128_u32[0] = -248;
    v13 = _X2;
    do
    {
      v14 = *v13++;
      v15 = a2;
      __asm { PRFM            #0, [X2,#0x80] }
      v21 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v14, (int8x16_t)xmmword_1B351FB40));
      v22 = (int32x4_t)vaddq_f32(vmulq_f32(v21, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
      *(_QWORD *)&v23 = vrev64q_s32(v22).u64[0];
      *((_QWORD *)&v23 + 1) = v22.i64[1];
      v24 = (int32x4_t)vaddq_f32(vmulq_f32(v21, (float32x4_t)xmmword_1B351FB60), (float32x4_t)xmmword_1B304F240);
      *(_OWORD *)a1 = v23;
      *(int8x16_t *)(a1 + 16) = vextq_s8((int8x16_t)v24, (int8x16_t)vuzp1q_s32(v24, vdupq_lane_s32(*(int32x2_t *)v24.i8, 1)), 0xCuLL);
      v25 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v14, (int8x16_t)xmmword_1B351FB50));
      v26 = (int32x4_t)vaddq_f32(vmulq_f32(v25, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
      v22.i64[0] = vrev64q_s32(v26).u64[0];
      v22.i64[1] = v26.i64[1];
      v27 = (int32x4_t)vaddq_f32(vmulq_f32(v25, (float32x4_t)xmmword_1B351FB60), (float32x4_t)xmmword_1B304F240);
      *(int32x4_t *)(a1 + 32) = v22;
      *(int8x16_t *)(a1 + 48) = vextq_s8((int8x16_t)v27, (int8x16_t)vuzp1q_s32(v27, vdupq_lane_s32(*(int32x2_t *)v27.i8, 1)), 0xCuLL);
      v28 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v14, (int8x16_t)xmmword_1B351FB70));
      v29 = (int32x4_t)vaddq_f32(vmulq_f32(v28, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
      v22.i64[0] = vrev64q_s32(v29).u64[0];
      v22.i64[1] = v29.i64[1];
      v30 = (int32x4_t)vaddq_f32(vmulq_f32(v28, (float32x4_t)xmmword_1B351FB60), (float32x4_t)xmmword_1B304F240);
      *(int32x4_t *)(a1 + 64) = v22;
      *(int8x16_t *)(a1 + 80) = vextq_s8((int8x16_t)v30, (int8x16_t)vuzp1q_s32(v30, vdupq_lane_s32(*(int32x2_t *)v30.i8, 1)), 0xCuLL);
      v31 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v14, (int8x16_t)xmmword_1B351FB80));
      v32 = (int32x4_t)vaddq_f32(vmulq_f32(v31, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
      v29.i64[0] = vrev64q_s32(v32).u64[0];
      v29.i64[1] = v32.i64[1];
      v33 = (int32x4_t)vaddq_f32(vmulq_f32(v31, (float32x4_t)xmmword_1B351FB60), (float32x4_t)xmmword_1B304F240);
      *(int32x4_t *)(a1 + 96) = v29;
      *(int8x16_t *)(a1 + 112) = vextq_s8((int8x16_t)v33, (int8x16_t)vuzp1q_s32(v33, vdupq_lane_s32(*(int32x2_t *)v33.i8, 1)), 0xCuLL);
      _X2 = v13;
      a1 += 128;
      a2 -= 8;
    }
    while (v15 > 0xF);
  }
  if (a2 >= 2)
  {
    result = (float32x4_t)xmmword_1B351FB30;
    a5 = 0.0;
    do
    {
      a6.n128_u8[0] = _X2->i8[0];
      a7.i8[0] = _X2->i8[1];
      LOBYTE(a8) = _X2->i8[2];
      a8 = (float)LODWORD(a8);
      a9.n128_u8[0] = _X2->u8[3];
      a9.n128_f32[0] = (float)a9.n128_u32[0];
      v34.f32[0] = (float)a7.u32[0];
      v34.f32[1] = (float)a6.n128_u32[0];
      v34.i64[1] = LODWORD(a8);
      v35.i32[0] = a9.n128_u32[0];
      v35.f32[1] = (float)a6.n128_u32[0];
      a6 = (__n128)vaddq_f32(vmulq_f32(v34, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
      v35.i64[1] = LODWORD(a8);
      a7 = vaddq_f32(vmulq_f32(v35, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
      v36 = a2;
      *(__n128 *)a1 = a6;
      *(float32x4_t *)(a1 + 16) = a7;
      a1 += 32;
      _X2 = (int8x16_t *)((char *)_X2 + 4);
      a2 -= 2;
    }
    while (v36 > 3);
  }
  if (a2 == 1)
  {
    result.i8[0] = _X2->i8[0];
    LOBYTE(a5) = _X2->i8[1];
    a6.n128_u8[0] = _X2->u8[2];
    v37.i32[3] = 0;
    v37.f32[0] = (float)LODWORD(a5);
    v37.f32[1] = (float)result.u32[0];
    v37.f32[2] = (float)a6.n128_u32[0];
    result = vaddq_f32(vmulq_f32(v37, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
    *(float32x4_t *)a1 = result;
  }
  return result;
}

float32x4_t hg_span_read_2b_xyxz(uint64_t a1, int a2, int8x16_t *_X2, float32x4_t result, float a5, __n128 a6, float32x4_t a7, float a8)
{
  unsigned __int8 *v8;
  unsigned int v9;
  uint32x2_t v10;
  float32x4_t v11;
  float32x4_t v12;
  unsigned int v13;
  uint64_t v14;
  int8x16_t *v15;
  int8x16_t v16;
  unsigned int v17;
  float32x4_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  float32x4_t v27;
  int32x4_t v28;
  int32x4_t v29;
  int32x4_t v30;
  float32x4_t v31;
  int32x4_t v32;
  int32x4_t v33;
  int32x4_t v34;
  float32x4_t v35;
  int32x4_t v36;
  int32x4_t v37;
  int32x4_t v38;
  uint32x2_t v39;
  unsigned int v40;
  float32x4_t v41;
  float32x4_t v42;
  unsigned int v43;
  float32x4_t v44;

  if ((_X2 & 3) != 0)
  {
    result.i8[0] = _X2[-1].i8[15];
    LOBYTE(a5) = _X2->i8[1];
    a6.n128_u8[0] = _X2->i8[0];
    a6.n128_f32[0] = (float)a6.n128_u32[0];
    a7.i8[12] = 0;
    a7.i8[13] = 0;
    a7.i8[14] = 0;
    a7.i8[15] = 0;
    a7.i32[0] = a6.n128_u32[0];
    a7.f32[1] = (float)result.u32[0];
    a7.f32[2] = (float)LODWORD(a5);
    a5 = 0.0;
    result = vaddq_f32(vmulq_f32(a7, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
    *(float32x4_t *)a1 = result;
    a1 += 16;
    _X2 = (int8x16_t *)((char *)_X2 + 2);
    --a2;
  }
  if (a2 >= 2 && (_X2 & 0xF) != 0)
  {
    v8 = &_X2->u8[4];
    result = (float32x4_t)xmmword_1B351FB30;
    a5 = 0.0;
    do
    {
      v9 = a2;
      v10.i32[0] = _X2->u8[0];
      v10.i32[1] = _X2->u8[1];
      *(float32x2_t *)v11.f32 = vcvt_f32_u32(v10);
      a7.i8[0] = _X2->i8[3];
      LOBYTE(a8) = _X2->i8[2];
      a8 = (float)LODWORD(a8);
      v12.i64[0] = __PAIR64__(v11.u32[1], LODWORD(a8));
      *(float *)&v13 = (float)a7.u32[0];
      v11.i64[1] = v13;
      a6 = (__n128)vaddq_f32(vmulq_f32(v11, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
      v12.i64[1] = v13;
      a7 = vaddq_f32(vmulq_f32(v12, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
      *(__n128 *)a1 = a6;
      *(float32x4_t *)(a1 + 16) = a7;
      a1 += 32;
      _X2 = (int8x16_t *)((char *)_X2 + 4);
      a2 -= 2;
      if (v9 < 4)
        break;
      v14 = v8 & 0xF;
      v8 += 4;
    }
    while (v14);
  }
  if (a2 >= 8)
  {
    result.i64[0] = 0xFFFFFF01FFFFFF00;
    a5 = NAN;
    a6.n128_u32[0] = 998277249;
    a7.i32[0] = 0;
    a8 = 0.0;
    v15 = _X2;
    do
    {
      v16 = *v15++;
      v17 = a2;
      __asm { PRFM            #0, [X2,#0x80] }
      v23 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_1B351FB40));
      v24 = (int32x4_t)vaddq_f32(vmulq_f32(v23, (float32x4_t)xmmword_1B351FB90), (float32x4_t)xmmword_1B304F250);
      v25 = vrev64q_s32(v24);
      v25.i64[0] = v24.i64[0];
      v26 = (int32x4_t)vaddq_f32(vmulq_f32(v23, (float32x4_t)xmmword_1B351FBA0), (float32x4_t)xmmword_1B304F230);
      *(int32x4_t *)a1 = v25;
      *(int32x4_t *)(a1 + 16) = vzip2q_s32(v26, vzip1q_s32(v26, vdupq_lane_s32(*(int32x2_t *)v26.i8, 0)));
      v27 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_1B351FB50));
      v28 = (int32x4_t)vaddq_f32(vmulq_f32(v27, (float32x4_t)xmmword_1B351FB90), (float32x4_t)xmmword_1B304F250);
      v29 = vrev64q_s32(v28);
      v29.i64[0] = v28.i64[0];
      v30 = (int32x4_t)vaddq_f32(vmulq_f32(v27, (float32x4_t)xmmword_1B351FBA0), (float32x4_t)xmmword_1B304F230);
      *(int32x4_t *)(a1 + 32) = v29;
      *(int32x4_t *)(a1 + 48) = vzip2q_s32(v30, vzip1q_s32(v30, vdupq_lane_s32(*(int32x2_t *)v30.i8, 0)));
      v31 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_1B351FB70));
      v32 = (int32x4_t)vaddq_f32(vmulq_f32(v31, (float32x4_t)xmmword_1B351FB90), (float32x4_t)xmmword_1B304F250);
      v33 = vrev64q_s32(v32);
      v33.i64[0] = v32.i64[0];
      v34 = (int32x4_t)vaddq_f32(vmulq_f32(v31, (float32x4_t)xmmword_1B351FBA0), (float32x4_t)xmmword_1B304F230);
      *(int32x4_t *)(a1 + 64) = v33;
      *(int32x4_t *)(a1 + 80) = vzip2q_s32(v34, vzip1q_s32(v34, vdupq_lane_s32(*(int32x2_t *)v34.i8, 0)));
      v35 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_1B351FB80));
      v36 = (int32x4_t)vaddq_f32(vmulq_f32(v35, (float32x4_t)xmmword_1B351FB90), (float32x4_t)xmmword_1B304F250);
      v37 = vrev64q_s32(v36);
      v37.i64[0] = v36.i64[0];
      v38 = (int32x4_t)vaddq_f32(vmulq_f32(v35, (float32x4_t)xmmword_1B351FBA0), (float32x4_t)xmmword_1B304F230);
      *(int32x4_t *)(a1 + 96) = v37;
      *(int32x4_t *)(a1 + 112) = vzip2q_s32(v38, vzip1q_s32(v38, vdupq_lane_s32(*(int32x2_t *)v38.i8, 0)));
      _X2 = v15;
      a1 += 128;
      a2 -= 8;
    }
    while (v17 > 0xF);
  }
  if (a2 >= 2)
  {
    result = (float32x4_t)xmmword_1B351FB30;
    a5 = 0.0;
    do
    {
      v39.i32[0] = _X2->u8[0];
      v39.i32[1] = _X2->u8[1];
      a7.i8[0] = _X2->i8[3];
      *(float *)&v40 = (float)a7.u32[0];
      LOBYTE(a8) = _X2->i8[2];
      *(float32x2_t *)v41.f32 = vcvt_f32_u32(v39);
      a8 = (float)LODWORD(a8);
      v42.i64[0] = __PAIR64__(v41.u32[1], LODWORD(a8));
      v41.i64[1] = v40;
      a6 = (__n128)vaddq_f32(vmulq_f32(v41, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
      v42.i64[1] = v40;
      a7 = vaddq_f32(vmulq_f32(v42, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
      v43 = a2;
      *(__n128 *)a1 = a6;
      *(float32x4_t *)(a1 + 16) = a7;
      a1 += 32;
      _X2 = (int8x16_t *)((char *)_X2 + 4);
      a2 -= 2;
    }
    while (v43 > 3);
  }
  if (a2 == 1)
  {
    result.i8[0] = _X2->i8[1];
    LOBYTE(a5) = _X2->i8[0];
    a6.n128_u8[0] = _X2->u8[3];
    v44.i32[3] = 0;
    v44.f32[0] = (float)LODWORD(a5);
    v44.f32[1] = (float)result.u32[0];
    v44.f32[2] = (float)a6.n128_u32[0];
    result = vaddq_f32(vmulq_f32(v44, (float32x4_t)xmmword_1B351FB30), (float32x4_t)xmmword_1B304EFF0);
    *(float32x4_t *)a1 = result;
  }
  return result;
}

float32x4_t hg_span_read_2s_yxzx(uint64_t a1, int a2, _WORD *a3, float32x4_t result, float a5, __n128 a6, float32x4_t a7, float a8, __n128 a9)
{
  _WORD *v9;
  unsigned int v10;
  float32x4_t v11;
  uint64_t v12;
  int16x8_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int32x4_t v16;
  __int128 v17;
  int32x4_t v18;
  int32x4_t v19;
  __int128 v20;
  unsigned int v21;
  int32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  unsigned int v25;
  float32x4_t v26;

  if ((a3 & 7) != 0)
  {
    result.i16[0] = *(a3 - 2);
    LOWORD(a5) = *a3;
    a6.n128_u16[0] = a3[1];
    a6.n128_f32[0] = (float)a6.n128_u32[0];
    a7.i8[12] = 0;
    a7.i8[13] = 0;
    a7.i8[14] = 0;
    a7.i8[15] = 0;
    a7.i32[0] = a6.n128_u32[0];
    a7.f32[1] = (float)result.u32[0];
    a7.f32[2] = (float)LODWORD(a5);
    HIWORD(a5) = 0;
    result = vaddq_f32(vmulq_f32(a7, (float32x4_t)xmmword_1B351FBB0), (float32x4_t)xmmword_1B304EFF0);
    *(float32x4_t *)a1 = result;
    a1 += 16;
    a3 += 2;
    --a2;
  }
  if (a2 >= 2 && (a3 & 0xF) != 0)
  {
    v9 = a3 + 4;
    result = (float32x4_t)xmmword_1B351FBB0;
    HIWORD(a5) = 0;
    do
    {
      v10 = a2;
      a6.n128_u16[0] = *a3;
      a7.i16[0] = a3[1];
      LOWORD(a8) = a3[2];
      a8 = (float)LODWORD(a8);
      a9.n128_u16[0] = a3[3];
      v11.f32[0] = (float)a7.u32[0];
      v11.f32[1] = (float)a6.n128_u32[0];
      v11.i64[1] = LODWORD(a8);
      a7.f32[0] = (float)a9.n128_u32[0];
      a9 = (__n128)vaddq_f32(vmulq_f32(v11, (float32x4_t)xmmword_1B351FBB0), (float32x4_t)xmmword_1B304EFF0);
      v11.i32[0] = a7.i32[0];
      v11.i64[1] = LODWORD(a8);
      a6 = (__n128)vaddq_f32(vmulq_f32(v11, (float32x4_t)xmmword_1B351FBB0), (float32x4_t)xmmword_1B304EFF0);
      *(__n128 *)a1 = a9;
      *(__n128 *)(a1 + 16) = a6;
      a1 += 32;
      a3 += 4;
      a2 -= 2;
      if (v10 < 4)
        break;
      v12 = v9 & 0xF;
      v9 += 4;
    }
    while (v12);
  }
  if (a2 >= 4)
  {
    result = 0uLL;
    HIWORD(a5) = -1;
    a6.n128_u16[1] = 14208;
    a7.i16[1] = 0;
    HIWORD(a8) = 14208;
    a9.n128_u16[1] = 0;
    do
    {
      v13 = *(int16x8_t *)a3;
      a3 += 8;
      v14 = vcvtq_f32_s32((int32x4_t)vzip1q_s16(v13, (int16x8_t)0));
      v15 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v13, (int8x16_t)xmmword_1B351FBC0));
      v16 = (int32x4_t)vaddq_f32(vmulq_f32(v14, (float32x4_t)xmmword_1B351FBB0), (float32x4_t)xmmword_1B304EFF0);
      *(_QWORD *)&v17 = vrev64q_s32(v16).u64[0];
      *((_QWORD *)&v17 + 1) = v16.i64[1];
      v18 = (int32x4_t)vaddq_f32(vmulq_f32(v14, (float32x4_t)xmmword_1B351FBD0), (float32x4_t)xmmword_1B304F240);
      v19 = (int32x4_t)vaddq_f32(vmulq_f32(v15, (float32x4_t)xmmword_1B351FBB0), (float32x4_t)xmmword_1B304EFF0);
      *(_QWORD *)&v20 = vrev64q_s32(v19).u64[0];
      *((_QWORD *)&v20 + 1) = v19.i64[1];
      v21 = a2;
      *(_OWORD *)a1 = v17;
      *(int8x16_t *)(a1 + 16) = vextq_s8((int8x16_t)v18, (int8x16_t)vuzp1q_s32(v18, vdupq_lane_s32(*(int32x2_t *)v18.i8, 1)), 0xCuLL);
      v22 = (int32x4_t)vaddq_f32(vmulq_f32(v15, (float32x4_t)xmmword_1B351FBD0), (float32x4_t)xmmword_1B304F240);
      *(_OWORD *)(a1 + 32) = v20;
      *(int8x16_t *)(a1 + 48) = vextq_s8((int8x16_t)v22, (int8x16_t)vuzp1q_s32(v22, vdupq_lane_s32(*(int32x2_t *)v22.i8, 1)), 0xCuLL);
      a1 += 64;
      a2 -= 4;
    }
    while (v21 > 7);
  }
  if (a2 >= 2)
  {
    result = (float32x4_t)xmmword_1B351FBB0;
    HIWORD(a5) = 0;
    do
    {
      a6.n128_u16[0] = *a3;
      a7.i16[0] = a3[1];
      LOWORD(a8) = a3[2];
      a8 = (float)LODWORD(a8);
      a9.n128_u16[0] = a3[3];
      a9.n128_f32[0] = (float)a9.n128_u32[0];
      v23.f32[0] = (float)a7.u32[0];
      v23.f32[1] = (float)a6.n128_u32[0];
      v23.i64[1] = LODWORD(a8);
      v24.i32[0] = a9.n128_u32[0];
      v24.f32[1] = (float)a6.n128_u32[0];
      a6 = (__n128)vaddq_f32(vmulq_f32(v23, (float32x4_t)xmmword_1B351FBB0), (float32x4_t)xmmword_1B304EFF0);
      v24.i64[1] = LODWORD(a8);
      a7 = vaddq_f32(vmulq_f32(v24, (float32x4_t)xmmword_1B351FBB0), (float32x4_t)xmmword_1B304EFF0);
      v25 = a2;
      *(__n128 *)a1 = a6;
      *(float32x4_t *)(a1 + 16) = a7;
      a1 += 32;
      a3 += 4;
      a2 -= 2;
    }
    while (v25 > 3);
  }
  if (a2 == 1)
  {
    result.i16[0] = *a3;
    LOWORD(a5) = a3[1];
    a6.n128_u16[0] = a3[2];
    v26.i32[3] = 0;
    v26.f32[0] = (float)LODWORD(a5);
    v26.f32[1] = (float)result.u32[0];
    v26.f32[2] = (float)a6.n128_u32[0];
    result = vaddq_f32(vmulq_f32(v26, (float32x4_t)xmmword_1B351FBB0), (float32x4_t)xmmword_1B304EFF0);
    *(float32x4_t *)a1 = result;
  }
  return result;
}

uint64_t hg_span_read_3b(uint64_t result, int a2, int8x16_t *a3, double a4, double a5, __n128 a6, float a7, float32x4_t a8)
{
  __int8 *v8;
  float32x4_t v9;
  unsigned int v10;
  float32x4_t v11;
  uint64_t v12;
  unsigned int v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t v36;
  int8x16_t v37;
  float32x4_t v38;
  int8x16_t v39;
  unsigned int v40;
  float32x4_t v41;
  float32x4_t v42;

  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    v8 = &a3->i8[3];
    v9 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      v10 = a2;
      a6.n128_u8[0] = a3->i8[0];
      LOBYTE(a7) = a3->i8[1];
      a7 = (float)LODWORD(a7);
      a8.i8[0] = a3->i8[2];
      v11.i32[3] = 0;
      v11.f32[0] = (float)a6.n128_u32[0];
      v11.f32[1] = a7;
      v11.f32[2] = (float)a8.u32[0];
      a6 = (__n128)vaddq_f32(vmulq_f32(v11, v9), (float32x4_t)xmmword_1B304EFF0);
      *(__n128 *)result = a6;
      result += 16;
      a3 = (int8x16_t *)((char *)a3 + 3);
      --a2;
      if (v10 < 2)
        break;
      v12 = v8 & 0xF;
      v8 += 3;
    }
    while (v12);
  }
  if (a2 >= 16)
  {
    a6.n128_u32[0] = -248;
    a7 = NAN;
    a8 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      v13 = a2;
      v14 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B351FB40)), a8);
      v15 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B351FB50)), a8);
      v16 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B351FB70)), a8);
      v17 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B351FB80)), a8);
      v18 = vaddq_f32(vmulq_f32(v14, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      v19 = (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v14, v15, 8uLL), (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
      *(float32x4_t *)result = v18;
      *(int8x16_t *)(result + 16) = vextq_s8(v19, v19, 4uLL);
      v20 = vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v15, (int8x16_t)v16, 8uLL), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      v21 = (int8x16_t)vaddq_f32(vmulq_f32(v16, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
      *(float32x4_t *)(result + 32) = v20;
      *(int8x16_t *)(result + 48) = vextq_s8(v21, v21, 4uLL);
      *(float32x4_t *)(result + 64) = vaddq_f32(vmulq_f32(v17, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      v22 = a3[1];
      v23 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1B351FB40)), a8);
      v24 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1B351FB50)), a8);
      v25 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1B351FB70)), a8);
      v26 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1B351FB80)), a8);
      v27 = (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v17, v23, 8uLL), (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
      *(int8x16_t *)(result + 80) = vextq_s8(v27, v27, 4uLL);
      *(float32x4_t *)(result + 96) = vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v23, (int8x16_t)v24, 8uLL), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      v28 = (int8x16_t)vaddq_f32(vmulq_f32(v24, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
      *(int8x16_t *)(result + 112) = vextq_s8(v28, v28, 4uLL);
      *(float32x4_t *)(result + 128) = vaddq_f32(vmulq_f32(v25, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      v29 = (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v25, v26, 8uLL), (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
      *(int8x16_t *)(result + 144) = vextq_s8(v29, v29, 4uLL);
      v30 = a3[2];
      v31 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v30, (int8x16_t)xmmword_1B351FB40)), a8);
      v32 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v30, (int8x16_t)xmmword_1B351FB50)), a8);
      v33 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v30, (int8x16_t)xmmword_1B351FB70)), a8);
      v34 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v30, (int8x16_t)xmmword_1B351FB80)), a8);
      v35 = vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v26, (int8x16_t)v31, 8uLL), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      v36 = (int8x16_t)vaddq_f32(vmulq_f32(v31, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
      *(float32x4_t *)(result + 160) = v35;
      *(int8x16_t *)(result + 176) = vextq_s8(v36, v36, 4uLL);
      v37 = (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v32, v33, 8uLL), (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
      *(float32x4_t *)(result + 192) = vaddq_f32(vmulq_f32(v32, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      *(int8x16_t *)(result + 208) = vextq_s8(v37, v37, 4uLL);
      v38 = vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v33, (int8x16_t)v34, 8uLL), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      v39 = (int8x16_t)vaddq_f32(vmulq_f32(v34, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
      *(float32x4_t *)(result + 224) = v38;
      *(int8x16_t *)(result + 240) = vextq_s8(v39, v39, 4uLL);
      a3 += 3;
      result += 256;
      a2 -= 16;
    }
    while (v13 > 0x1F);
  }
  if (a2 >= 1)
  {
    v40 = a2 + 1;
    v41 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      a6.n128_u8[0] = a3->i8[0];
      LOBYTE(a7) = a3->i8[1];
      a7 = (float)LODWORD(a7);
      a8.i8[0] = a3->i8[2];
      v42.i32[3] = 0;
      v42.f32[0] = (float)a6.n128_u32[0];
      v42.f32[1] = a7;
      v42.f32[2] = (float)a8.u32[0];
      a6 = (__n128)vaddq_f32(vmulq_f32(v42, v41), (float32x4_t)xmmword_1B304EFF0);
      *(__n128 *)result = a6;
      result += 16;
      a3 = (int8x16_t *)((char *)a3 + 3);
      --v40;
    }
    while (v40 > 1);
  }
  return result;
}

uint64_t hg_span_read_3b_zyx(uint64_t result, int a2, int8x16_t *a3, double a4, double a5, __n128 a6, float a7, float32x4_t a8)
{
  __int8 *v8;
  float32x4_t v9;
  unsigned int v10;
  float32x4_t v11;
  uint64_t v12;
  unsigned int v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t v36;
  float32x4_t v37;
  int8x16_t v38;
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t v41;
  int8x16_t v42;
  int8x16_t v43;
  unsigned int v44;
  unsigned __int8 *v45;
  float32x4_t v46;
  float32x4_t v47;

  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    v8 = &a3->i8[3];
    v9 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      v10 = a2;
      a6.n128_u8[0] = a3->u8[2];
      LOBYTE(a7) = a3->i8[1];
      a7 = (float)LODWORD(a7);
      a8.i8[0] = a3->i8[0];
      v11.i32[3] = 0;
      v11.f32[0] = (float)a6.n128_u32[0];
      v11.f32[1] = a7;
      v11.f32[2] = (float)a8.u32[0];
      a6 = (__n128)vaddq_f32(vmulq_f32(v11, v9), (float32x4_t)xmmword_1B304EFF0);
      *(__n128 *)result = a6;
      result += 16;
      a3 = (int8x16_t *)((char *)a3 + 3);
      --a2;
      if (v10 < 2)
        break;
      v12 = v8 & 0xF;
      v8 += 3;
    }
    while (v12);
  }
  if (a2 >= 16)
  {
    a6.n128_u32[0] = -248;
    a7 = NAN;
    a8 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      v13 = a2;
      v14 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B351FB40)), a8);
      v15 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B351FB50)), a8);
      v16 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B351FB70)), a8);
      v17 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B351FB80)), a8);
      v18 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v14, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0));
      v19 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v14, v15, 8uLL), (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230));
      *(int8x16_t *)result = vextq_s8(v18, v18, 0xCuLL);
      *(int8x16_t *)(result + 16) = vextq_s8(v19, v19, 8uLL);
      v20 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v15, (int8x16_t)v16, 8uLL), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0));
      v21 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v16, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230));
      *(int8x16_t *)(result + 32) = vextq_s8(v20, v20, 0xCuLL);
      *(int8x16_t *)(result + 48) = vextq_s8(v21, v21, 8uLL);
      v22 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v17, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0));
      *(int8x16_t *)(result + 64) = vextq_s8(v22, v22, 0xCuLL);
      v23 = a3[1];
      v24 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v23, (int8x16_t)xmmword_1B351FB40)), a8);
      v25 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v23, (int8x16_t)xmmword_1B351FB50)), a8);
      v26 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v23, (int8x16_t)xmmword_1B351FB70)), a8);
      v27 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v23, (int8x16_t)xmmword_1B351FB80)), a8);
      v28 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v17, v24, 8uLL), (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230));
      v29 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v24, (int8x16_t)v25, 8uLL), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0));
      *(int8x16_t *)(result + 80) = vextq_s8(v28, v28, 8uLL);
      *(int8x16_t *)(result + 96) = vextq_s8(v29, v29, 0xCuLL);
      v30 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v25, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230));
      v31 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v26, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0));
      *(int8x16_t *)(result + 112) = vextq_s8(v30, v30, 8uLL);
      *(int8x16_t *)(result + 128) = vextq_s8(v31, v31, 0xCuLL);
      v32 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v26, v27, 8uLL), (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230));
      *(int8x16_t *)(result + 144) = vextq_s8(v32, v32, 8uLL);
      v33 = a3[2];
      v34 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v33, (int8x16_t)xmmword_1B351FB40)), a8);
      v35 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v33, (int8x16_t)xmmword_1B351FB50)), a8);
      v36 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v33, (int8x16_t)xmmword_1B351FB70)), a8);
      v37 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v33, (int8x16_t)xmmword_1B351FB80)), a8);
      v38 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v27, (int8x16_t)v34, 8uLL), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0));
      v39 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v34, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230));
      *(int8x16_t *)(result + 160) = vextq_s8(v38, v38, 0xCuLL);
      *(int8x16_t *)(result + 176) = vextq_s8(v39, v39, 8uLL);
      v40 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v35, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0));
      v41 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v35, v36, 8uLL), (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230));
      *(int8x16_t *)(result + 192) = vextq_s8(v40, v40, 0xCuLL);
      *(int8x16_t *)(result + 208) = vextq_s8(v41, v41, 8uLL);
      v42 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v36, (int8x16_t)v37, 8uLL), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0));
      v43 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v37, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230));
      *(int8x16_t *)(result + 224) = vextq_s8(v42, v42, 0xCuLL);
      *(int8x16_t *)(result + 240) = vextq_s8(v43, v43, 8uLL);
      a3 += 3;
      result += 256;
      a2 -= 16;
    }
    while (v13 > 0x1F);
  }
  if (a2 >= 1)
  {
    v44 = a2 + 1;
    v45 = &a3->u8[2];
    v46 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      a6.n128_u8[0] = *v45;
      LOBYTE(a7) = *(v45 - 1);
      a7 = (float)LODWORD(a7);
      a8.i8[0] = *(v45 - 2);
      v47.i32[3] = 0;
      v47.f32[0] = (float)a6.n128_u32[0];
      v47.f32[1] = a7;
      v47.f32[2] = (float)a8.u32[0];
      a6 = (__n128)vaddq_f32(vmulq_f32(v47, v46), (float32x4_t)xmmword_1B304EFF0);
      *(__n128 *)result = a6;
      result += 16;
      --v44;
      v45 += 3;
    }
    while (v44 > 1);
  }
  return result;
}

uint64_t hg_span_read_3s(uint64_t result, int a2, int16x8_t *a3, double a4, double a5, float32x4_t a6, float a7, float a8)
{
  __int8 *v8;
  float32x4_t v9;
  unsigned int v10;
  float32x4_t v11;
  uint64_t v12;
  unsigned int v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int16x8_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int16x8_t v23;
  int8x16_t v24;
  float32x4_t v25;
  int8x16_t v26;
  int8x16_t v27;
  unsigned int v28;
  float32x4_t v29;
  float32x4_t v30;

  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    v8 = &a3->i8[6];
    v9 = (float32x4_t)vdupq_n_s32(0x37800080u);
    do
    {
      v10 = a2;
      a6.i16[0] = a3->i16[0];
      LOWORD(a7) = a3->i16[1];
      a7 = (float)LODWORD(a7);
      LOWORD(a8) = a3->i16[2];
      v11.i32[3] = 0;
      v11.f32[0] = (float)a6.u32[0];
      v11.f32[1] = a7;
      v11.f32[2] = (float)LODWORD(a8);
      a6 = vaddq_f32(vmulq_f32(v11, v9), (float32x4_t)xmmword_1B304EFF0);
      *(float32x4_t *)result = a6;
      result += 16;
      a3 = (int16x8_t *)((char *)a3 + 6);
      --a2;
      if (v10 < 2)
        break;
      v12 = v8 & 0xF;
      v8 += 6;
    }
    while (v12);
  }
  if (a2 >= 8)
  {
    a6 = (float32x4_t)vdupq_n_s32(0x37800080u);
    HIWORD(a7) = 16256;
    HIWORD(a8) = 0;
    do
    {
      v13 = a2;
      v14 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(*a3, (int16x8_t)0)), a6);
      v15 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*(int8x16_t *)a3, (int8x16_t)xmmword_1B351FBC0)), a6);
      v16 = vaddq_f32(vmulq_f32(v14, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      v17 = (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v14, v15, 8uLL), (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
      *(float32x4_t *)result = v16;
      *(int8x16_t *)(result + 16) = vextq_s8(v17, v17, 4uLL);
      v18 = a3[1];
      v19 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(v18, (int16x8_t)0)), a6);
      v20 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v18, (int8x16_t)xmmword_1B351FBC0)), a6);
      v21 = vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v15, (int8x16_t)v19, 8uLL), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      v22 = (int8x16_t)vaddq_f32(vmulq_f32(v19, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
      *(float32x4_t *)(result + 32) = v21;
      *(int8x16_t *)(result + 48) = vextq_s8(v22, v22, 4uLL);
      *(float32x4_t *)(result + 64) = vaddq_f32(vmulq_f32(v20, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      v23 = a3[2];
      v24 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(v23, (int16x8_t)0)), a6);
      v25 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v23, (int8x16_t)xmmword_1B351FBC0)), a6);
      v26 = (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v20, v24, 8uLL), (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
      *(int8x16_t *)(result + 80) = vextq_s8(v26, v26, 4uLL);
      *(float32x4_t *)(result + 96) = vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v24, (int8x16_t)v25, 8uLL), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      v27 = (int8x16_t)vaddq_f32(vmulq_f32(v25, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
      *(int8x16_t *)(result + 112) = vextq_s8(v27, v27, 4uLL);
      a3 += 3;
      result += 128;
      a2 -= 8;
    }
    while (v13 > 0xF);
  }
  if (a2 >= 1)
  {
    v28 = a2 + 1;
    v29 = (float32x4_t)vdupq_n_s32(0x37800080u);
    do
    {
      a6.i16[0] = a3->i16[0];
      LOWORD(a7) = a3->i16[1];
      a7 = (float)LODWORD(a7);
      LOWORD(a8) = a3->i16[2];
      v30.i32[3] = 0;
      v30.f32[0] = (float)a6.u32[0];
      v30.f32[1] = a7;
      v30.f32[2] = (float)LODWORD(a8);
      a6 = vaddq_f32(vmulq_f32(v30, v29), (float32x4_t)xmmword_1B304EFF0);
      *(float32x4_t *)result = a6;
      result += 16;
      --v28;
      a3 = (int16x8_t *)((char *)a3 + 6);
    }
    while (v28 > 1);
  }
  return result;
}

uint64_t hg_span_read_3f(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  float32x4_t v5;
  uint64_t v6;
  unsigned int v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;
  float32x4_t v11;
  float32x4_t v12;
  int8x16_t v13;
  unsigned int v14;
  float32x4_t v15;

  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    v3 = a3 + 12;
    do
    {
      v4 = a2;
      v5.i64[0] = *(_QWORD *)a3;
      v5.i64[1] = *(unsigned int *)(a3 + 8);
      *(float32x4_t *)result = vaddq_f32(v5, (float32x4_t)xmmword_1B304EFF0);
      result += 16;
      a3 += 12;
      --a2;
      if (v4 < 2)
        break;
      v6 = v3 & 0xF;
      v3 += 12;
    }
    while (v6);
  }
  if (a2 >= 4)
  {
    do
    {
      v7 = a2;
      v8 = *(int8x16_t *)a3;
      *(float32x4_t *)result = vaddq_f32(vmulq_f32(*(float32x4_t *)a3, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      v9 = *(int8x16_t *)(a3 + 16);
      v10 = (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v8, v9, 8uLL), (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
      *(int8x16_t *)(result + 16) = vextq_s8(v10, v10, 4uLL);
      v11 = *(float32x4_t *)(a3 + 32);
      v12 = vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v9, (int8x16_t)v11, 8uLL), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      v13 = (int8x16_t)vaddq_f32(vmulq_f32(v11, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
      *(float32x4_t *)(result + 32) = v12;
      *(int8x16_t *)(result + 48) = vextq_s8(v13, v13, 4uLL);
      a3 += 48;
      result += 64;
      a2 -= 4;
    }
    while (v7 > 7);
  }
  if (a2 >= 1)
  {
    v14 = a2 + 1;
    do
    {
      v15.i64[0] = *(_QWORD *)a3;
      v15.i64[1] = *(unsigned int *)(a3 + 8);
      *(float32x4_t *)result = vaddq_f32(v15, (float32x4_t)xmmword_1B304EFF0);
      result += 16;
      --v14;
      a3 += 12;
    }
    while (v14 > 1);
  }
  return result;
}

int32x4_t hg_span_read_4b_wxyz(int8x16_t *a1, int a2, const float *a3, int32x4_t result)
{
  const float *v4;
  unsigned int v5;
  uint8x8_t v6;
  int8x16_t v7;
  unsigned int v9;
  uint8x16_t v10;
  uint16x8_t v11;
  uint16x8_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  unsigned int v17;
  float32x4_t v18;
  int8x16_t v19;

  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    v4 = a3 + 1;
    result = vdupq_n_s32(0x3B808081u);
    do
    {
      v5 = a2;
      v6 = (uint8x8_t)vld1_dup_f32(a3++);
      v7 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v6))), (float32x4_t)result);
      *a1++ = vextq_s8(v7, v7, 4uLL);
      --a2;
      if (v5 < 2)
        break;
    }
    while (v4++ & 0xF);
  }
  if (a2 >= 4)
  {
    result = vdupq_n_s32(0x3B808081u);
    do
    {
      v9 = a2;
      v10 = *(uint8x16_t *)a3;
      a3 += 4;
      v11 = vmovl_u8(*(uint8x8_t *)v10.i8);
      v12 = vmovl_high_u8(v10);
      v13 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v11.i8)), (float32x4_t)result);
      v14 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_high_u16(v11)), (float32x4_t)result);
      v15 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v12.i8)), (float32x4_t)result);
      v16 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_high_u16(v12)), (float32x4_t)result);
      *a1 = vextq_s8(v13, v13, 4uLL);
      a1[1] = vextq_s8(v14, v14, 4uLL);
      a1[2] = vextq_s8(v15, v15, 4uLL);
      a1[3] = vextq_s8(v16, v16, 4uLL);
      a1 += 4;
      a2 -= 4;
    }
    while (v9 > 7);
  }
  if (a2 >= 1)
  {
    result = *(int32x4_t *)a3;
    v17 = a2 + 1;
    v18 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      v19 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)result.i8))), v18);
      *a1++ = vextq_s8(v19, v19, 4uLL);
      result = (int32x4_t)vextq_s8((int8x16_t)result, (int8x16_t)result, 4uLL);
      --v17;
    }
    while (v17 > 1);
  }
  return result;
}

int32x4_t hg_span_read_4b_zyxw(int32x4_t *a1, int a2, const float *a3, int32x4_t result)
{
  const float *v4;
  uint8x8_t v5;
  unsigned int v6;
  int8x16_t v7;
  uint8x16_t v9;
  unsigned int v10;
  uint16x8_t v11;
  uint16x8_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  unsigned int v17;
  float32x4_t v18;
  int8x16_t v19;

  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    v4 = a3 + 1;
    result = vdupq_n_s32(0x3B808081u);
    do
    {
      v5 = (uint8x8_t)vld1_dup_f32(a3++);
      v6 = a2;
      v7 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v5))), (float32x4_t)result);
      *a1++ = vrev64q_s32((int32x4_t)vextq_s8(v7, v7, 4uLL));
      --a2;
      if (v6 < 2)
        break;
    }
    while (v4++ & 0xF);
  }
  if (a2 >= 4)
  {
    result = vdupq_n_s32(0x3B808081u);
    do
    {
      v9 = *(uint8x16_t *)a3;
      a3 += 4;
      v10 = a2;
      v11 = vmovl_u8(*(uint8x8_t *)v9.i8);
      v12 = vmovl_high_u8(v9);
      v13 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v11.i8)), (float32x4_t)result);
      v14 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_high_u16(v11)), (float32x4_t)result);
      v15 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v12.i8)), (float32x4_t)result);
      v16 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_high_u16(v12)), (float32x4_t)result);
      *a1 = vrev64q_s32((int32x4_t)vextq_s8(v13, v13, 4uLL));
      a1[1] = vrev64q_s32((int32x4_t)vextq_s8(v14, v14, 4uLL));
      a1[2] = vrev64q_s32((int32x4_t)vextq_s8(v15, v15, 4uLL));
      a1[3] = vrev64q_s32((int32x4_t)vextq_s8(v16, v16, 4uLL));
      a1 += 4;
      a2 -= 4;
    }
    while (v10 > 7);
  }
  if (a2 >= 1)
  {
    result = *(int32x4_t *)a3;
    v17 = a2 + 1;
    v18 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      v19 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)result.i8))), v18);
      *a1++ = vrev64q_s32((int32x4_t)vextq_s8(v19, v19, 4uLL));
      result = (int32x4_t)vextq_s8((int8x16_t)result, (int8x16_t)result, 4uLL);
      --v17;
    }
    while (v17 > 1);
  }
  return result;
}

int32x4_t hg_span_read_4b_xyzw(float32x4_t *a1, int a2, const float *a3, int32x4_t result)
{
  const float *v4;
  unsigned int v5;
  uint8x8_t v6;
  unsigned int v8;
  uint8x16_t v9;
  uint16x8_t v10;
  uint16x8_t v11;
  unsigned int v12;
  float32x4_t v13;

  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    v4 = a3 + 1;
    result = vdupq_n_s32(0x3B808081u);
    do
    {
      v5 = a2;
      v6 = (uint8x8_t)vld1_dup_f32(a3++);
      *a1++ = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v6))), (float32x4_t)result);
      --a2;
      if (v5 < 2)
        break;
    }
    while (v4++ & 0xF);
  }
  if (a2 >= 4)
  {
    result = vdupq_n_s32(0x3B808081u);
    do
    {
      v8 = a2;
      v9 = *(uint8x16_t *)a3;
      a3 += 4;
      v10 = vmovl_u8(*(uint8x8_t *)v9.i8);
      v11 = vmovl_high_u8(v9);
      *a1 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v10.i8)), (float32x4_t)result);
      a1[1] = vmulq_f32(vcvtq_f32_u32(vmovl_high_u16(v10)), (float32x4_t)result);
      a1[2] = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v11.i8)), (float32x4_t)result);
      a1[3] = vmulq_f32(vcvtq_f32_u32(vmovl_high_u16(v11)), (float32x4_t)result);
      a1 += 4;
      a2 -= 4;
    }
    while (v8 > 7);
  }
  if (a2 >= 1)
  {
    result = *(int32x4_t *)a3;
    v12 = a2 + 1;
    v13 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      *a1++ = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)result.i8))), v13);
      result = (int32x4_t)vextq_s8((int8x16_t)result, (int8x16_t)result, 4uLL);
      --v12;
    }
    while (v12 > 1);
  }
  return result;
}

float32x4_t hg_span_read_4s(float32x4_t *a1, int a2, int16x8_t *a3)
{
  float32x4_t result;
  float32x4_t v4;
  int16x8_t v5;
  unsigned int v6;

  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    result = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*(int8x16_t *)((char *)&a3[-1] + 8), (int8x16_t)xmmword_1B351FBC0)), (float32x4_t)vdupq_n_s32(0x37800080u));
    *a1++ = result;
    a3 = (int16x8_t *)((char *)a3 + 8);
    --a2;
  }
  if (a2 > 1)
  {
    result = 0uLL;
    v4 = (float32x4_t)vdupq_n_s32(0x37800080u);
    do
    {
      v5 = *a3++;
      v6 = a2;
      *a1 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(v5, (int16x8_t)0)), v4);
      a1[1] = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v5, (int8x16_t)xmmword_1B351FBC0)), v4);
      a1 += 2;
      a2 -= 2;
    }
    while (v6 > 3);
  }
  if (a2)
  {
    result = vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(*a3, (int16x8_t)0)), (float32x4_t)vdupq_n_s32(0x37800080u));
    *a1 = result;
  }
  return result;
}

int8x16_t hg_span_read_4s_wxyz(int8x16_t *a1, int a2, int16x8_t *a3)
{
  int8x16_t v3;
  int8x16_t result;
  float32x4_t v5;
  unsigned int v6;
  int16x8_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;

  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    v3 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*(int8x16_t *)((char *)&a3[-1] + 8), (int8x16_t)xmmword_1B351FBC0)), (float32x4_t)vdupq_n_s32(0x37800080u));
    result = vextq_s8(v3, v3, 4uLL);
    *a1++ = result;
    a3 = (int16x8_t *)((char *)a3 + 8);
    --a2;
  }
  if (a2 > 1)
  {
    result = 0uLL;
    v5 = (float32x4_t)vdupq_n_s32(0x37800080u);
    do
    {
      v6 = a2;
      v7 = *a3++;
      v8 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(v7, (int16x8_t)0)), v5);
      v9 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v7, (int8x16_t)xmmword_1B351FBC0)), v5);
      *a1 = vextq_s8(v8, v8, 4uLL);
      a1[1] = vextq_s8(v9, v9, 4uLL);
      a1 += 2;
      a2 -= 2;
    }
    while (v6 > 3);
  }
  if (a2)
  {
    v10 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(*a3, (int16x8_t)0)), (float32x4_t)vdupq_n_s32(0x37800080u));
    result = vextq_s8(v10, v10, 4uLL);
    *a1 = result;
  }
  return result;
}

float32x4_t *hg_span_read_4h(float32x4_t *result, int a2, float16x4_t *a3)
{
  unsigned int v3;
  float16x4_t v4;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3++;
      *result++ = vcvtq_f32_f16(v4);
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_4f_xyzw(_OWORD *result, int a2, __int128 *a3)
{
  unsigned int v3;
  __int128 v4;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3++;
      *result++ = v4;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

int8x16_t *hg_span_read_4f_wxyz(int8x16_t *result, int a2, int8x16_t *a3)
{
  unsigned int v3;
  int8x16_t v4;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3++;
      *result++ = vextq_s8(v4, v4, 4uLL);
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

float32x4_t hg_span_read_4b_10bit_yxzx_little_endian(float32x4_t *a1, int a2, uint64_t _X2, float32x4_t result)
{
  uint64_t v4;
  int v5;
  int v6;
  int8x16_t *v7;
  int8x16_t v8;
  int32x4_t v9;
  int32x4_t v10;
  int8x16_t v11;
  float32x4_t v12;
  int32x4_t v13;
  int32x4_t v14;
  float32x4_t v15;
  int32x4_t v16;
  int32x4_t v17;
  int32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int v22;
  uint64_t v23;
  float32x4_t *v24;
  int8x16_t v25;
  float32x4_t v26;
  int32x4_t v27;
  int32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int v31;
  uint64_t v32;
  float32x4_t *v33;
  int8x16_t v34;
  int8x16_t v35;
  float32x4_t v36;
  int32x4_t v37;
  float32x4_t v38;
  int32x4_t v39;
  int8x16_t v40;
  float32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int32x4_t v47;
  int32x4_t v48;
  int32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int32x4_t v54;
  int32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int8x16_t v64;
  int32x4_t v65;
  int32x4_t v66;
  int8x16_t v67;
  float32x4_t v68;
  int32x4_t v69;
  int32x4_t v70;
  int32x4_t v71;
  int32x4_t v72;
  int32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int8x16_t v77;
  int32x4_t v78;
  int32x4_t v79;
  float32x4_t v80;

  if (a2 >= 1)
  {
    if (_X2 <= 0)
      v4 = -(-_X2 & 0xF);
    else
      LOBYTE(v4) = _X2 & 0xF;
    v5 = v4;
    if ((_BYTE)v4)
    {
      v6 = v4 - 2;
      v7 = (int8x16_t *)(_X2 - v4);
      v8.i64[0] = 0x300000003;
      v8.i64[1] = 0x300000003;
      result = vcvtq_f32_s32((int32x4_t)vandq_s8(*v7, v8));
      v9 = (int32x4_t)vcvtq_f32_s32((int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(*(uint32x4_t *)v7, 0xAuLL), v8));
      v10 = (int32x4_t)vcvtq_f32_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*(uint32x4_t *)v7, 0x14uLL) & __PAIR128__(0xFFFFF3FFFFFFF3FFLL, 0xFFFFF3FFFFFFF3FFLL)));
      switch(v6)
      {
        case 0:
          v11 = vextq_s8((int8x16_t)v9, (int8x16_t)vtrn1q_s32(v9, v10), 0xCuLL);
          v12.i64[0] = result.i64[0];
          v12.i64[1] = __PAIR64__(v11.u32[1], v11.u32[2]);
          v13 = (int32x4_t)vaddq_f32(vmulq_f32(vmulq_f32(v12, (float32x4_t)vdupq_n_s32(0x3A802008u)), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
          v14 = vtrn1q_s32(v13, (int32x4_t)vextq_s8((int8x16_t)v13, (int8x16_t)v13, 0xCuLL));
          v12.i64[0] = vrev64q_s32(v14).u64[0];
          v12.i64[1] = v14.i64[1];
          v15 = v12;
          v15.i32[0] = v12.i32[3];
          v15.i32[3] = v12.i32[0];
          *a1++ = v15;
          --a2;
          goto LABEL_8;
        case 3:
        case 6:
LABEL_8:
          v16 = vuzp2q_s32(vuzp1q_s32((int32x4_t)result, (int32x4_t)result), v10);
          v17 = (int32x4_t)vmulq_f32((float32x4_t)vzip2q_s32(vzip1q_s32(v9, v16), vtrn1q_s32(v9, v16)), (float32x4_t)vdupq_n_s32(0x3A802008u));
          v18 = vtrn1q_s32(v17, (int32x4_t)vextq_s8((int8x16_t)v17, (int8x16_t)v17, 0xCuLL));
          v19.i64[0] = vrev64q_s32(v18).u64[0];
          v19.i64[1] = v18.i64[1];
          v20 = vaddq_f32(vmulq_f32(v19, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
          v21 = v20;
          v21.i32[0] = v20.i32[3];
          v21.i32[3] = v20.i32[0];
          if (v5 == 8)
          {
            v22 = -1;
            v23 = 1;
            v24 = a1;
          }
          else
          {
            *a1 = vaddq_f32(vmulq_f32(v19, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
            v24 = a1 + 1;
            v22 = -2;
            v23 = 2;
          }
          *v24 = v21;
          a1 += v23;
          a2 += v22;
          goto LABEL_12;
        case 8:
        case 11:
LABEL_12:
          v25 = vextq_s8((int8x16_t)vtrn2q_s32((int32x4_t)result, v9), (int8x16_t)result, 4uLL);
          v26 = (float32x4_t)vextq_s8((int8x16_t)v10, v25, 8uLL);
          v26.i32[2] = v25.i32[2];
          v27 = (int32x4_t)vmulq_f32(v26, (float32x4_t)vdupq_n_s32(0x3A802008u));
          v28 = vtrn1q_s32(v27, (int32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 0xCuLL));
          v29.i64[0] = vrev64q_s32(v28).u64[0];
          v29.i64[1] = v28.i64[1];
          v30 = vaddq_f32(vmulq_f32(v29, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
          result = v30;
          result.i32[0] = v30.i32[3];
          result.i32[3] = v30.i32[0];
          if (v5 == 13)
          {
            v31 = -1;
            v32 = 1;
            v33 = a1;
          }
          else
          {
            *a1 = vaddq_f32(vmulq_f32(v29, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
            v33 = a1 + 1;
            v31 = -2;
            v32 = 2;
          }
          *v33 = result;
          a1 += v32;
          a2 += v31;
          break;
        default:
          break;
      }
      _X2 += 16 - v5;
    }
    if (a2 >= 6)
    {
      v34 = *(int8x16_t *)_X2;
      v35 = 0uLL;
      result.i64[0] = 0x300000003;
      result.i64[1] = 0x300000003;
      v36 = (float32x4_t)vdupq_n_s32(0x3A802008u);
      do
      {
        if (a2 >= 0xC)
        {
          v35 = *(int8x16_t *)(_X2 + 16);
          __asm { PRFM            #0, [X2,#0x40] }
        }
        v37 = (int32x4_t)vcvtq_f32_s32((int32x4_t)vandq_s8(v34, (int8x16_t)result));
        v38 = vcvtq_f32_s32((int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v34, 0xAuLL), (int8x16_t)result));
        v39 = (int32x4_t)vcvtq_f32_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v34, 0x14uLL) & __PAIR128__(0xFFFFF3FFFFFFF3FFLL, 0xFFFFF3FFFFFFF3FFLL)));
        v40 = vextq_s8((int8x16_t)v38, (int8x16_t)vtrn1q_s32((int32x4_t)v38, v39), 0xCuLL);
        v41.i64[0] = v37.i64[0];
        v41.i64[1] = __PAIR64__(v40.u32[1], v40.u32[2]);
        v42 = (int32x4_t)vmulq_f32(v41, v36);
        v43 = vtrn1q_s32(v42, (int32x4_t)vextq_s8((int8x16_t)v42, (int8x16_t)v42, 0xCuLL));
        v41.i64[0] = vrev64q_s32(v43).u64[0];
        v41.i64[1] = v43.i64[1];
        v44 = vextq_s8((int8x16_t)vtrn2q_s32(v37, (int32x4_t)v38), (int8x16_t)v37, 4uLL);
        v45 = vaddq_f32(vmulq_f32(v41, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
        v46 = v45;
        v46.i32[0] = v45.i32[3];
        v46.i32[3] = v45.i32[0];
        a2 -= 6;
        *a1 = vaddq_f32(vmulq_f32(v41, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
        a1[1] = v46;
        v47 = vuzp2q_s32(vuzp1q_s32(v37, v37), v39);
        v48 = (int32x4_t)vmulq_f32((float32x4_t)vzip2q_s32(vzip1q_s32((int32x4_t)v38, v47), vtrn1q_s32((int32x4_t)v38, v47)), v36);
        v49 = vtrn1q_s32(v48, (int32x4_t)vextq_s8((int8x16_t)v48, (int8x16_t)v48, 0xCuLL));
        v38.i64[0] = vrev64q_s32(v49).u64[0];
        v38.i64[1] = v49.i64[1];
        v50 = vmulq_f32(v38, (float32x4_t)xmmword_1B3051560);
        v51 = vaddq_f32(vmulq_f32(v38, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
        v52 = v51;
        v52.i32[0] = v51.i32[3];
        v52.i32[3] = v51.i32[0];
        a1[2] = vaddq_f32(v50, (float32x4_t)xmmword_1B304EFF0);
        a1[3] = v52;
        v53 = (float32x4_t)vextq_s8((int8x16_t)v39, v44, 8uLL);
        v53.i32[2] = v44.i32[2];
        v54 = (int32x4_t)vmulq_f32(v53, v36);
        v55 = vtrn1q_s32(v54, (int32x4_t)vextq_s8((int8x16_t)v54, (int8x16_t)v54, 0xCuLL));
        v50.i64[0] = vrev64q_s32(v55).u64[0];
        v50.i64[1] = v55.i64[1];
        v56 = vaddq_f32(vmulq_f32(v50, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
        v57 = vaddq_f32(vmulq_f32(v50, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
        v58 = v57;
        v58.i32[0] = v57.i32[3];
        v58.i32[3] = v57.i32[0];
        a1[4] = v56;
        a1[5] = v58;
        _X2 += 16;
        a1 += 6;
        v34 = v35;
      }
      while ((a2 + 6) > 0xB);
    }
    if (a2 >= 1)
    {
      v64.i64[0] = 0x300000003;
      v64.i64[1] = 0x300000003;
      result = vcvtq_f32_s32((int32x4_t)vandq_s8(*(int8x16_t *)_X2, v64));
      v65 = (int32x4_t)vcvtq_f32_s32((int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(*(uint32x4_t *)_X2, 0xAuLL), v64));
      v66 = (int32x4_t)vcvtq_f32_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*(uint32x4_t *)_X2, 0x14uLL) & __PAIR128__(0xFFFFF3FFFFFFF3FFLL, 0xFFFFF3FFFFFFF3FFLL)));
      if ((a2 - 1) >= 2)
      {
        if ((a2 - 3) >= 2)
        {
          if (a2 != 5)
            return result;
          v67 = vextq_s8((int8x16_t)vtrn2q_s32((int32x4_t)result, v65), (int8x16_t)result, 4uLL);
          v68 = (float32x4_t)vextq_s8((int8x16_t)v66, v67, 8uLL);
          v68.i32[2] = v67.i32[2];
          v69 = (int32x4_t)vaddq_f32(vmulq_f32(vmulq_f32(v68, (float32x4_t)vdupq_n_s32(0x3A802008u)), (float32x4_t)xmmword_1B3052DE0), (float32x4_t)xmmword_1B304F240);
          v70 = vtrn1q_s32(v69, (int32x4_t)vextq_s8((int8x16_t)v69, (int8x16_t)v69, 0xCuLL));
          v68.i64[0] = vrev64q_s32(v70).u64[0];
          v68.i64[1] = v70.i64[1];
          a1[4] = v68;
        }
        v71 = vuzp2q_s32(vuzp1q_s32((int32x4_t)result, (int32x4_t)result), v66);
        v72 = (int32x4_t)vmulq_f32((float32x4_t)vzip2q_s32(vzip1q_s32(v65, v71), vtrn1q_s32(v65, v71)), (float32x4_t)vdupq_n_s32(0x3A802008u));
        v73 = vtrn1q_s32(v72, (int32x4_t)vextq_s8((int8x16_t)v72, (int8x16_t)v72, 0xCuLL));
        v74.i64[0] = vrev64q_s32(v73).u64[0];
        v74.i64[1] = v73.i64[1];
        a1[2] = vaddq_f32(vmulq_f32(v74, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
        if (a2 >= 4)
        {
          v75 = vaddq_f32(vmulq_f32(v74, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
          v76 = v75;
          v76.i32[0] = v75.i32[3];
          v76.i32[3] = v75.i32[0];
          a1[3] = v76;
        }
      }
      v77 = vextq_s8((int8x16_t)v65, (int8x16_t)vtrn1q_s32(v65, v66), 0xCuLL);
      result.i64[1] = __PAIR64__(v77.u32[1], v77.u32[2]);
      v78 = (int32x4_t)vmulq_f32(result, (float32x4_t)vdupq_n_s32(0x3A802008u));
      v79 = vtrn1q_s32(v78, (int32x4_t)vextq_s8((int8x16_t)v78, (int8x16_t)v78, 0xCuLL));
      result.i64[0] = vrev64q_s32(v79).u64[0];
      result.i64[1] = v79.i64[1];
      *a1 = vaddq_f32(vmulq_f32(result, (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      if (a2 >= 2)
      {
        result = vaddq_f32(vmulq_f32(result, (float32x4_t)xmmword_1B351FBE0), (float32x4_t)xmmword_1B304F230);
        v80 = result;
        v80.i32[0] = result.i32[3];
        v80.i32[3] = result.i32[0];
        a1[1] = v80;
      }
    }
  }
  return result;
}

float32x4_t hg_span_read_4b_10bit_big_endian(float32x4_t *a1, int a2, uint64_t _X2, float32x4_t result)
{
  uint64_t v4;
  uint32x4_t v5;
  int8x16_t v6;
  int32x4_t v7;
  int32x4_t v8;
  int32x4_t v9;
  int32x4_t v10;
  int32x4_t v11;
  int32x4_t v12;
  int8x16_t v13;
  int8x16_t v14;
  uint32x4_t v15;
  int32x4_t v16;
  int32x4_t v17;
  int32x4_t v18;
  int32x4_t v19;
  uint32x4_t v25;
  int8x16_t v26;
  int32x4_t v27;
  int32x4_t v28;
  int32x4_t v29;
  int32x4_t v30;
  int32x4_t v31;
  int32x4_t v32;

  if (a2 < 1)
    return result;
  LOBYTE(v4) = _X2 & 0xF;
  if (_X2 <= 0)
    v4 = -(-_X2 & 0xF);
  if ((_BYTE)v4)
  {
    v5 = (uint32x4_t)vrev32q_s8(*(int8x16_t *)(_X2 - v4));
    v6.i64[0] = 0x300000003;
    v6.i64[1] = 0x300000003;
    v7 = (int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v5, 2uLL), v6);
    v8 = (int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v5, 0xCuLL), v6);
    v9 = (int32x4_t)vshrq_n_u32(v5, 0x16uLL);
    result = vcvtq_f32_s32(v7);
    v10 = (int32x4_t)vcvtq_f32_s32(v8);
    v11 = (int32x4_t)vcvtq_f32_s32(v9);
    if (v4 != 12)
    {
      if (v4 != 8)
      {
        if (v4 != 4)
        {
LABEL_11:
          _X2 += 16 - v4;
          goto LABEL_12;
        }
        *a1++ = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(vuzp2q_s32(v11, v10)), vdupq_lane_s32(*(int32x2_t *)result.f32, 1)), (float32x4_t)xmmword_1B351FBF0), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
        --a2;
      }
      v12 = v10;
      v12.i32[0] = v11.i32[2];
      *a1++ = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(v12), vdupq_laneq_s32((int32x4_t)result, 2)), (float32x4_t)xmmword_1B351FBF0), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      --a2;
    }
    result = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(vtrn2q_s32(vuzp2q_s32(v11, v10), v11)), vdupq_laneq_s32((int32x4_t)result, 3)), (float32x4_t)xmmword_1B351FBF0), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
    *a1++ = result;
    --a2;
    goto LABEL_11;
  }
LABEL_12:
  if (a2 >= 4)
  {
    v13 = *(int8x16_t *)_X2;
    v14 = 0uLL;
    result.i64[0] = 0x300000003;
    result.i64[1] = 0x300000003;
    do
    {
      if (a2 >= 8)
      {
        v14 = *(int8x16_t *)(_X2 + 16);
        __asm { PRFM            #0, [X2,#0x40] }
      }
      v15 = (uint32x4_t)vrev32q_s8(v13);
      v16 = (int32x4_t)vcvtq_f32_s32((int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v15, 2uLL), (int8x16_t)result));
      v17 = (int32x4_t)vcvtq_f32_s32((int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v15, 0xCuLL), (int8x16_t)result));
      v18 = (int32x4_t)vcvtq_f32_s32((int32x4_t)vshrq_n_u32(v15, 0x16uLL));
      v19 = vuzp2q_s32(v18, v17);
      a2 -= 4;
      *a1 = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(vuzp1q_s32(v18, v17)), vdupq_lane_s32(*(int32x2_t *)v16.i8, 0)), (float32x4_t)xmmword_1B351FBF0), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      a1[1] = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(v19), vdupq_lane_s32(*(int32x2_t *)v16.i8, 1)), (float32x4_t)xmmword_1B351FBF0), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      v17.i32[0] = v18.i32[2];
      a1[2] = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(v17), vdupq_laneq_s32(v16, 2)), (float32x4_t)xmmword_1B351FBF0), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      a1[3] = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(vtrn2q_s32(v19, v18)), vdupq_laneq_s32(v16, 3)), (float32x4_t)xmmword_1B351FBF0), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      _X2 += 16;
      a1 += 4;
      v13 = v14;
    }
    while ((a2 + 4) > 7);
  }
  if (a2 >= 1)
  {
    v25 = (uint32x4_t)vrev32q_s8(*(int8x16_t *)_X2);
    v26.i64[0] = 0x300000003;
    v26.i64[1] = 0x300000003;
    v27 = (int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v25, 2uLL), v26);
    v28 = (int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v25, 0xCuLL), v26);
    v29 = (int32x4_t)vshrq_n_u32(v25, 0x16uLL);
    result = vcvtq_f32_s32(v27);
    v30 = (int32x4_t)vcvtq_f32_s32(v28);
    v31 = (int32x4_t)vcvtq_f32_s32(v29);
    if (a2 != 1)
    {
      if (a2 != 2)
      {
        if (a2 != 3)
          return result;
        v32 = v30;
        v32.i32[0] = v31.i32[2];
        a1[2] = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(v32), vdupq_laneq_s32((int32x4_t)result, 2)), (float32x4_t)xmmword_1B351FBF0), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
      }
      a1[1] = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(vuzp2q_s32(v31, v30)), vdupq_lane_s32(*(int32x2_t *)result.f32, 1)), (float32x4_t)xmmword_1B351FBF0), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
    }
    result = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(vuzp1q_s32(v31, v30)), vdupq_lane_s32(*(int32x2_t *)result.f32, 0)), (float32x4_t)xmmword_1B351FBF0), (float32x4_t)xmmword_1B3051560), (float32x4_t)xmmword_1B304EFF0);
    *a1 = result;
  }
  return result;
}

float32x4_t hg_span_read_4s_wxyz_big_endian(float32x4_t *a1, int a2, int8x16_t *a3)
{
  float32x4_t result;
  float32x4_t v4;
  unsigned int v5;
  int8x16_t v6;
  int16x8_t v7;

  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    result = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(vqtbl1q_s8(*(int8x16_t *)((char *)a3 - 8), (int8x16_t)xmmword_1B351FC00), (int8x16_t)xmmword_1B351FBC0)), (float32x4_t)vdupq_n_s32(0x37800080u));
    *a1++ = result;
    a3 = (int8x16_t *)((char *)a3 + 8);
    --a2;
  }
  if (a2 > 1)
  {
    result.i64[0] = 0x1060704050203;
    v4 = (float32x4_t)vdupq_n_s32(0x37800080u);
    do
    {
      v5 = a2;
      v6 = *a3++;
      v7 = (int16x8_t)vqtbl1q_s8(v6, (int8x16_t)xmmword_1B351FC10);
      *a1 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(v7, (int16x8_t)0)), v4);
      a1[1] = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v7, (int8x16_t)xmmword_1B351FBC0)), v4);
      a1 += 2;
      a2 -= 2;
    }
    while (v5 > 3);
  }
  if (a2)
  {
    result = vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16((int16x8_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B351FC20), (int16x8_t)0)), (float32x4_t)vdupq_n_s32(0x37800080u));
    *a1 = result;
  }
  return result;
}

_BYTE *hg_span_write_1b(_BYTE *result, int a2, float *a3)
{
  unsigned int v3;
  float v4;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3;
      a3 += 4;
      *result++ = (uint64_t)rintf(fminf(fmaxf(v4, 0.0), 1.0) * 255.0);
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_WORD *hg_span_write_1s(_WORD *result, int a2, float *a3)
{
  unsigned int v3;
  float v4;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3;
      a3 += 4;
      *result++ = (uint64_t)rintf(fminf(fmaxf(v4, 0.0), 1.0) * 65535.0);
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_WORD *hg_span_write_1h(_WORD *result, int a2, _DWORD *a3)
{
  int v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    while (1)
    {
      v5 = HIWORD(*a3) & 0x8000;
      v6 = (*a3 >> 23);
      v7 = *a3 & 0x7FFFFF;
      v8 = v6 - 112;
      if (v6 <= 0x70)
      {
        if (v6 >= 0x66)
        {
          v4 = (v7 | 0x800000) >> (113 - v6);
          if ((v4 & 0x1000) != 0)
            v4 += 0x2000;
          v5 |= v4 >> 13;
        }
        else
        {
          LOWORD(v5) = 0;
        }
        goto LABEL_6;
      }
      if (v6 != 255)
        break;
      if (!v7)
        goto LABEL_22;
      v5 |= (v7 < 0x2000) | (v7 >> 13) | 0x7C00;
LABEL_6:
      *result++ = v5;
      a3 += 4;
      if (--v3 <= 1)
        return result;
    }
    v9 = v7 + 0x2000;
    v10 = v6 - 111;
    if (v7 >= 0x7FE000)
      v9 = 0;
    else
      v10 = v8;
    if ((*a3 & 0x1000) != 0)
      v11 = v10;
    else
      v11 = v8;
    if ((*a3 & 0x1000) != 0)
      v7 = v9;
    if (v11 < 0x1F)
    {
      v5 |= (v11 << 10) | (v7 >> 13);
      goto LABEL_6;
    }
LABEL_22:
    LOWORD(v5) = v5 | 0x7C00;
    goto LABEL_6;
  }
  return result;
}

_DWORD *hg_span_write_1f(_DWORD *result, int a2, _DWORD *a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  unsigned __int128 *v8;
  const float *v9;
  const float *v10;
  unsigned __int128 v11;
  unsigned __int128 v12;
  unsigned int v13;
  int v14;

  v3 = a2 - 1;
  if (a2 >= 1)
  {
    if (a2 >= 0x11 && (&a3[4 * v3 + 1] <= result || &result[v3 + 1] <= a3))
    {
      v4 = a2 & 7;
      if (!v4)
        v4 = 8;
      v5 = a2 - v4;
      v6 = &a3[4 * v5];
      v7 = &result[v5];
      a2 -= v5;
      v8 = (unsigned __int128 *)(result + 4);
      v9 = (const float *)(a3 + 16);
      do
      {
        v10 = v9 - 16;
        v11 = (unsigned __int128)vld4q_f32(v10);
        v12 = (unsigned __int128)vld4q_f32(v9);
        *(v8 - 1) = v11;
        *v8 = v12;
        v8 += 2;
        v9 += 32;
        v5 -= 8;
      }
      while (v5);
      a3 = v6;
      result = v7;
    }
    v13 = a2 + 1;
    do
    {
      v14 = *a3;
      a3 += 4;
      *result++ = v14;
      --v13;
    }
    while (v13 > 1);
  }
  return result;
}

_BYTE *hg_span_write_2b(_BYTE *result, int a2, float *a3)
{
  unsigned int v3;
  float v4;
  float v5;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3;
      v5 = a3[1];
      a3 += 4;
      *result = (uint64_t)rintf(fminf(fmaxf(v4, 0.0), 1.0) * 255.0);
      result[1] = (uint64_t)rintf(fminf(fmaxf(v5, 0.0), 1.0) * 255.0);
      result += 2;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_WORD *hg_span_write_2s(_WORD *result, int a2, float *a3)
{
  unsigned int v3;
  float v4;
  float v5;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3;
      v5 = a3[1];
      a3 += 4;
      *result = (uint64_t)rintf(fminf(fmaxf(v4, 0.0), 1.0) * 65535.0);
      result[1] = (uint64_t)rintf(fminf(fmaxf(v5, 0.0), 1.0) * 65535.0);
      --v3;
      result += 2;
    }
    while (v3 > 1);
  }
  return result;
}

_WORD *hg_span_write_2h(_WORD *result, int a2, _DWORD *a3)
{
  int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  BOOL v7;
  int v8;
  __int16 v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  __int16 v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v11 = HIWORD(*a3) & 0x8000;
      v12 = (*a3 >> 23);
      v13 = *a3 & 0x7FFFFF;
      v14 = v12 - 112;
      if (v12 > 0x70)
      {
        v17 = v13 + 0x2000;
        v18 = v12 - 111;
        if (v13 >= 0x7FE000)
          v17 = 0;
        else
          v18 = v14;
        if ((*a3 & 0x1000) != 0)
        {
          v19 = v17;
        }
        else
        {
          v18 = v14;
          v19 = *a3 & 0x7FFFFF;
        }
        v7 = v18 >= 0x1F;
        v20 = (v18 << 10) | (v19 >> 13) | v11;
        v21 = v11 | 0x7C00;
        if (v7)
          LOWORD(v20) = v11 | 0x7C00;
        v16 = (v13 < 0x2000) | (v13 >> 13) | v11 | 0x7C00;
        if (!v13)
          LOWORD(v16) = v21;
        if (v14 != 143)
          LOWORD(v16) = v20;
      }
      else
      {
        v15 = (v13 | 0x800000) >> (113 - v12);
        if ((v15 & 0x1000) != 0)
          v15 += 0x2000;
        v16 = v11 | (v15 >> 13);
        if (v12 < 0x66)
          LOWORD(v16) = 0;
      }
      v22 = a3[1];
      v23 = HIWORD(v22) & 0x8000;
      v24 = (v22 >> 23);
      v25 = v22 & 0x7FFFFF;
      v26 = v24 - 112;
      if (v24 > 0x70)
      {
        v4 = v25 + 0x2000;
        v5 = v24 - 111;
        if (v25 >= 0x7FE000)
          v4 = 0;
        else
          v5 = v26;
        if ((v22 & 0x1000) != 0)
        {
          v6 = v4;
        }
        else
        {
          v5 = v26;
          v6 = v22 & 0x7FFFFF;
        }
        v7 = v5 >= 0x1F;
        v8 = (v5 << 10) | (v6 >> 13) | v23;
        v9 = v23 | 0x7C00;
        if (v7)
          LOWORD(v8) = v23 | 0x7C00;
        v10 = (v25 < 0x2000) | (v25 >> 13) | v23 | 0x7C00;
        if (!v25)
          LOWORD(v10) = v9;
        if (v26 != 143)
          LOWORD(v10) = v8;
      }
      else
      {
        v27 = (v25 | 0x800000) >> (113 - v24);
        if ((v27 & 0x1000) != 0)
          v27 += 0x2000;
        v10 = v23 | (v27 >> 13);
        if (v24 < 0x66)
          LOWORD(v10) = 0;
      }
      *result = v16;
      result[1] = v10;
      --v3;
      a3 += 4;
      result += 2;
    }
    while (v3 > 1);
  }
  return result;
}

_DWORD *hg_span_write_2f(_DWORD *result, int a2, _DWORD *a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  float *v8;
  const float *v9;
  const float *v10;
  float *v11;
  unsigned int v12;
  float32x4x4_t v13;
  float32x4x4_t v14;

  v3 = a2 - 1;
  if (a2 >= 1)
  {
    if (a2 >= 9 && (&a3[4 * v3 + 2] <= result || &result[2 * v3 + 2] <= a3))
    {
      v4 = a2 & 7;
      if (!v4)
        v4 = 8;
      v5 = a2 - v4;
      v6 = &a3[4 * v5];
      v7 = &result[2 * v5];
      a2 -= v5;
      v8 = (float *)(result + 8);
      v9 = (const float *)(a3 + 16);
      do
      {
        v10 = v9 - 16;
        v13 = vld4q_f32(v10);
        v14 = vld4q_f32(v9);
        v11 = v8 - 8;
        vst2q_f32(v11, *(float32x4x2_t *)v13.val[0].f32);
        vst2q_f32(v8, *(float32x4x2_t *)v14.val[0].f32);
        v8 += 16;
        v9 += 32;
        v5 -= 8;
      }
      while (v5);
      a3 = v6;
      result = v7;
    }
    v12 = a2 + 1;
    do
    {
      *result = *a3;
      result[1] = a3[1];
      --v12;
      a3 += 4;
      result += 2;
    }
    while (v12 > 1);
  }
  return result;
}

double hg_span_write_2b_yxzx(int8x16_t *a1, int a2, int32x4_t *a3, char a4, int32x4_t a5)
{
  __int32 *v5;
  int32x4_t v6;
  int32x4_t v7;
  int8x16_t v8;
  float32x4_t v9;
  unsigned int v10;
  int16x8_t v11;
  int8x16_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  unsigned int v21;
  int32x4_t v22;
  int32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  unsigned int v26;
  int16x8_t v27;
  float32x4_t v28;
  int32x4_t v29;

  if ((a1 & 1) == 0 && (a4 & 1) == 0)
  {
    if (a2 >= 1 && (a1 & 0xF) != 0)
    {
      v5 = &a1->i32[1];
      a5 = vdupq_n_s32(0x437F0000u);
      do
      {
        v6 = *a3;
        v7 = a3[1];
        a3 += 2;
        v8 = vextq_s8((int8x16_t)vuzp1q_s32(v6, v7), (int8x16_t)v6, 4uLL);
        v9 = (float32x4_t)vextq_s8(v8, v8, 8uLL);
        v9.i32[0] = v6.i32[1];
        v10 = a2;
        v11 = (int16x8_t)vcvtnq_s32_f32(vminq_f32(vmulq_f32(v9, (float32x4_t)a5), (float32x4_t)a5));
        *(int16x4_t *)v11.i8 = vqmovun_s32((int32x4_t)v11);
        a1->i32[0] = vqmovun_s16(v11).u32[0];
        a1 = (int8x16_t *)((char *)a1 + 4);
        a2 -= 2;
        if (v10 < 3)
          break;
      }
      while (v5++ & 0xF);
    }
    if (a2 >= 8)
    {
      a5 = vdupq_n_s32(0x437F0000u);
      do
      {
        v13 = vextq_s8((int8x16_t)vuzp1q_s32(*a3, a3[1]), *(int8x16_t *)a3, 4uLL);
        v14 = (float32x4_t)vextq_s8(v13, v13, 8uLL);
        v14.i32[0] = HIDWORD(a3->i64[0]);
        v15 = vextq_s8((int8x16_t)vuzp1q_s32(a3[2], a3[3]), (int8x16_t)a3[2], 4uLL);
        v16 = (float32x4_t)vextq_s8(v15, v15, 8uLL);
        v16.i32[0] = HIDWORD(a3[2].i64[0]);
        v17 = vextq_s8((int8x16_t)vuzp1q_s32(a3[4], a3[5]), (int8x16_t)a3[4], 4uLL);
        v18 = (float32x4_t)vextq_s8(v17, v17, 8uLL);
        v18.i32[0] = HIDWORD(a3[4].i64[0]);
        v19 = vextq_s8((int8x16_t)vuzp1q_s32(a3[6], a3[7]), (int8x16_t)a3[6], 4uLL);
        v20 = (float32x4_t)vextq_s8(v19, v19, 8uLL);
        v20.i32[0] = HIDWORD(a3[6].i64[0]);
        v21 = a2;
        *a1++ = vqmovun_high_s16(vqmovun_s16(vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(v14, (float32x4_t)a5), (float32x4_t)a5))), vcvtnq_s32_f32(vminq_f32(vmulq_f32(v16, (float32x4_t)a5), (float32x4_t)a5)))), vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(v18, (float32x4_t)a5), (float32x4_t)a5))), vcvtnq_s32_f32(vminq_f32(vmulq_f32(v20, (float32x4_t)a5), (float32x4_t)a5))));
        a3 += 8;
        a2 -= 8;
      }
      while (v21 > 0xF);
    }
    if (a2 > 1)
    {
      a5 = vdupq_n_s32(0x437F0000u);
      do
      {
        v22 = *a3;
        v23 = a3[1];
        a3 += 2;
        v24 = vextq_s8((int8x16_t)vuzp1q_s32(v22, v23), (int8x16_t)v22, 4uLL);
        v25 = (float32x4_t)vextq_s8(v24, v24, 8uLL);
        v25.i32[0] = v22.i32[1];
        v26 = a2;
        v27 = (int16x8_t)vcvtnq_s32_f32(vminq_f32(vmulq_f32(v25, (float32x4_t)a5), (float32x4_t)a5));
        *(int16x4_t *)v27.i8 = vqmovun_s32((int32x4_t)v27);
        a1->i32[0] = vqmovun_s16(v27).u32[0];
        a1 = (int8x16_t *)((char *)a1 + 4);
        a2 -= 2;
      }
      while (v26 > 3);
    }
    if (a2 >= 1)
    {
      v28 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      v29.i64[0] = vmulq_f32(*(float32x4_t *)a3, v28).u64[0];
      v29.i64[1] = v29.i64[0];
      a5 = vcvtnq_s32_f32(vminq_f32((float32x4_t)vrev64q_s32(v29), v28));
      *(int16x4_t *)a5.i8 = vqmovun_s32(a5);
      *(int8x8_t *)a5.i8 = vqmovun_s16((int16x8_t)a5);
      a1->i32[0] = a5.i32[0];
    }
  }
  return *(double *)a5.i64;
}

double hg_span_write_2b_xyxz(int8x16_t *a1, int a2, uint64_t a3, char a4, int32x4_t a5)
{
  __int32 *v5;
  float32x4_t v6;
  int32x4_t v7;
  int32x4_t v8;
  unsigned int v9;
  int16x8_t v10;
  float32x4_t v12;
  float32x4_t v13;
  int32x4_t v14;
  int32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  int32x4_t v18;
  float32x4_t v19;
  int32x4_t v20;
  unsigned int v21;
  float32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  unsigned int v25;
  int16x8_t v26;
  float32x4_t v27;

  if ((a1 & 1) == 0 && (a4 & 1) == 0)
  {
    if (a2 >= 1 && (a1 & 0xF) != 0)
    {
      v5 = &a1->i32[1];
      a5 = vdupq_n_s32(0x437F0000u);
      do
      {
        v6 = *(float32x4_t *)a3;
        v7 = *(int32x4_t *)(a3 + 16);
        a3 += 32;
        v8 = vuzp1q_s32((int32x4_t)v6, v7);
        v6.i64[1] = __PAIR64__(v8.u32[1], v8.u32[2]);
        v9 = a2;
        v10 = (int16x8_t)vcvtnq_s32_f32(vminq_f32(vmulq_f32(v6, (float32x4_t)a5), (float32x4_t)a5));
        *(int16x4_t *)v10.i8 = vqmovun_s32((int32x4_t)v10);
        a1->i32[0] = vqmovun_s16(v10).u32[0];
        a1 = (int8x16_t *)((char *)a1 + 4);
        a2 -= 2;
        if (v9 < 3)
          break;
      }
      while (v5++ & 0xF);
    }
    if (a2 >= 8)
    {
      a5 = vdupq_n_s32(0x437F0000u);
      do
      {
        v12 = *(float32x4_t *)a3;
        v13 = *(float32x4_t *)(a3 + 32);
        v14 = vuzp1q_s32(*(int32x4_t *)a3, *(int32x4_t *)(a3 + 16));
        v15 = vuzp1q_s32((int32x4_t)v13, *(int32x4_t *)(a3 + 48));
        v12.i64[1] = __PAIR64__(v14.u32[1], v14.u32[2]);
        v13.i64[1] = __PAIR64__(v15.u32[1], v15.u32[2]);
        v16 = vmulq_f32(v13, (float32x4_t)a5);
        v17 = *(float32x4_t *)(a3 + 64);
        v18 = vuzp1q_s32((int32x4_t)v17, *(int32x4_t *)(a3 + 80));
        v17.i64[1] = __PAIR64__(v18.u32[1], v18.u32[2]);
        v19 = *(float32x4_t *)(a3 + 96);
        v20 = vuzp1q_s32((int32x4_t)v19, *(int32x4_t *)(a3 + 112));
        v19.i64[1] = __PAIR64__(v20.u32[1], v20.u32[2]);
        v21 = a2;
        *a1++ = vqmovun_high_s16(vqmovun_s16(vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(v12, (float32x4_t)a5), (float32x4_t)a5))), vcvtnq_s32_f32(vminq_f32(v16, (float32x4_t)a5)))), vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(v17, (float32x4_t)a5), (float32x4_t)a5))), vcvtnq_s32_f32(vminq_f32(vmulq_f32(v19, (float32x4_t)a5), (float32x4_t)a5))));
        a3 += 128;
        a2 -= 8;
      }
      while (v21 > 0xF);
    }
    if (a2 > 1)
    {
      a5 = vdupq_n_s32(0x437F0000u);
      do
      {
        v22 = *(float32x4_t *)a3;
        v23 = *(int32x4_t *)(a3 + 16);
        a3 += 32;
        v24 = vuzp1q_s32((int32x4_t)v22, v23);
        v22.i64[1] = __PAIR64__(v24.u32[1], v24.u32[2]);
        v25 = a2;
        v26 = (int16x8_t)vcvtnq_s32_f32(vminq_f32(vmulq_f32(v22, (float32x4_t)a5), (float32x4_t)a5));
        *(int16x4_t *)v26.i8 = vqmovun_s32((int32x4_t)v26);
        a1->i32[0] = vqmovun_s16(v26).u32[0];
        a1 = (int8x16_t *)((char *)a1 + 4);
        a2 -= 2;
      }
      while (v25 > 3);
    }
    if (a2 >= 1)
    {
      v27 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      a5 = vcvtnq_s32_f32(vminq_f32((float32x4_t)vdupq_lane_s64(vmulq_f32(*(float32x4_t *)a3, v27).i64[0], 0), v27));
      *(int16x4_t *)a5.i8 = vqmovun_s32(a5);
      *(int8x8_t *)a5.i8 = vqmovun_s16((int16x8_t)a5);
      a1->i32[0] = a5.i32[0];
    }
  }
  return *(double *)a5.i64;
}

double hg_span_write_2s_yxzx(int16x4_t *a1, int a2, int32x4_t *a3, char a4, int32x4_t a5)
{
  int16x4_t *v5;
  unsigned int v6;
  int32x4_t v7;
  int32x4_t v8;
  unsigned int v10;
  int32x4_t v11;
  int32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int32x4_t v15;

  if ((a1 & 1) == 0 && (a4 & 1) == 0)
  {
    if (a2 >= 1 && (a1 & 0xF) != 0)
    {
      v5 = a1 + 1;
      a5 = vdupq_n_s32(0x477FFF00u);
      do
      {
        v6 = a2;
        v7 = *a3;
        v8 = a3[1];
        a3 += 2;
        *a1++ = vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vzip1q_s32(v7, v7), (int8x16_t)vuzp1q_s32(v7, v8), 0xCuLL), (float32x4_t)a5), (float32x4_t)a5)));
        a2 -= 2;
        if (v6 < 3)
          break;
      }
      while (v5++ & 0xF);
    }
    if (a2 >= 4)
    {
      a5 = vdupq_n_s32(0x477FFF00u);
      do
      {
        v10 = a2;
        *(int16x8_t *)a1->i8 = vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vzip1q_s32(*a3, *a3), (int8x16_t)vuzp1q_s32(*a3, a3[1]), 0xCuLL), (float32x4_t)a5), (float32x4_t)a5))), vcvtnq_s32_f32(vminq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vzip1q_s32(a3[2], a3[2]), (int8x16_t)vuzp1q_s32(a3[2], a3[3]), 0xCuLL), (float32x4_t)a5), (float32x4_t)a5)));
        a1 += 2;
        a3 += 4;
        a2 -= 4;
      }
      while (v10 > 7);
    }
    if (a2 > 1)
    {
      v11 = *a3;
      v12 = a3[1];
      a3 += 2;
      a5 = (int32x4_t)vextq_s8((int8x16_t)vzip1q_s32(v11, v11), (int8x16_t)vuzp1q_s32(v11, v12), 0xCuLL);
      v13 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
      *(int16x4_t *)a5.i8 = vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32((float32x4_t)a5, v13), v13)));
      *a1++ = *(int16x4_t *)a5.i8;
      a2 -= 2;
    }
    if (a2 >= 1)
    {
      v14 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
      v15 = (int32x4_t)vmulq_f32(*(float32x4_t *)a3, v14);
      a5 = vuzp1q_s32(v15, vzip1q_s32(v15, v15));
      *(int16x4_t *)a5.i8 = vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8((int8x16_t)a5, (int8x16_t)a5, 0xCuLL), v14)));
      *a1 = *(int16x4_t *)a5.i8;
    }
  }
  return *(double *)a5.i64;
}

_BYTE *hg_span_write_3b(_BYTE *result, int a2, float *a3)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = (uint64_t)rintf(fminf(fmaxf(a3[1], 0.0), 1.0) * 255.0);
      v5 = (uint64_t)rintf(fminf(fmaxf(a3[2], 0.0), 1.0) * 255.0);
      *result = (uint64_t)rintf(fminf(fmaxf(*a3, 0.0), 1.0) * 255.0);
      result[1] = v4;
      result[2] = v5;
      result += 3;
      --v3;
      a3 += 4;
    }
    while (v3 > 1);
  }
  return result;
}

_BYTE *hg_span_write_3b_zyx(_BYTE *result, int a2, float *a3)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = (uint64_t)rintf(fminf(fmaxf(*a3, 0.0), 1.0) * 255.0);
      v5 = (uint64_t)rintf(fminf(fmaxf(a3[1], 0.0), 1.0) * 255.0);
      *result = (uint64_t)rintf(fminf(fmaxf(a3[2], 0.0), 1.0) * 255.0);
      result[1] = v5;
      result[2] = v4;
      result += 3;
      --v3;
      a3 += 4;
    }
    while (v3 > 1);
  }
  return result;
}

_WORD *hg_span_write_3s(_WORD *result, int a2, float *a3)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = (uint64_t)rintf(fminf(fmaxf(a3[1], 0.0), 1.0) * 65535.0);
      v5 = (uint64_t)rintf(fminf(fmaxf(a3[2], 0.0), 1.0) * 65535.0);
      *result = (uint64_t)rintf(fminf(fmaxf(*a3, 0.0), 1.0) * 65535.0);
      result[1] = v4;
      result[2] = v5;
      --v3;
      a3 += 4;
      result += 3;
    }
    while (v3 > 1);
  }
  return result;
}

unint64_t hg_span_write_3f(unint64_t result, int a2, _DWORD *a3)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  unint64_t v7;
  const float *v8;
  const float *v9;
  unint64_t v10;
  float *v11;
  unsigned int v12;
  float32x4x4_t v13;
  float32x4x4_t v14;

  v3 = a2 - 1;
  if (a2 >= 1)
  {
    if (a2 >= 9
      && ((unint64_t)&a3[4 * v3 + 3] <= result || result + 12 * v3 + 12 <= (unint64_t)a3))
    {
      v4 = a2 & 7;
      if (!v4)
        v4 = 8;
      v5 = a2 - v4;
      v6 = &a3[4 * v5];
      v7 = result + 12 * v5;
      a2 -= v5;
      v8 = (const float *)(a3 + 16);
      do
      {
        v9 = v8 - 16;
        v13 = vld4q_f32(v9);
        v14 = vld4q_f32(v8);
        v10 = result + 96;
        vst3q_f32((float *)result, *(float32x4x3_t *)v13.val[0].f32);
        v11 = (float *)(result + 48);
        vst3q_f32(v11, *(float32x4x3_t *)v14.val[0].f32);
        v8 += 32;
        result = v10;
        v5 -= 8;
      }
      while (v5);
      a3 = v6;
      result = v7;
    }
    v12 = a2 + 1;
    do
    {
      *(_DWORD *)result = *a3;
      *(_DWORD *)(result + 4) = a3[1];
      *(_DWORD *)(result + 8) = a3[2];
      --v12;
      a3 += 4;
      result += 12;
    }
    while (v12 > 1);
  }
  return result;
}

uint8x16_t *hg_span_write_4b_wxyz(uint8x16_t *result, int a2, float32x4_t *a3)
{
  __int32 *v3;
  float32x4_t v4;
  float32x4_t v5;
  unsigned int v6;
  int8x16_t v7;
  int32x4_t v8;
  float32x4_t v10;
  unsigned int v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  unsigned int v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int32x4_t v20;

  if (a2 >= 1 && (result & 0xF) != 0)
  {
    v3 = &result->i32[1];
    v4 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      v5 = *a3++;
      v6 = a2;
      v7 = (int8x16_t)vmulq_f32(v5, v4);
      v8 = vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v7, v7, 0xCuLL), v4));
      *(int16x4_t *)v8.i8 = vqmovun_s32(v8);
      result->i32[0] = vqmovn_u16((uint16x8_t)v8).u32[0];
      result = (uint8x16_t *)((char *)result + 4);
      --a2;
      if (v6 < 2)
        break;
    }
    while (v3++ & 0xF);
  }
  if (a2 >= 4)
  {
    v10 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      v11 = a2;
      v12 = (int8x16_t)vmulq_f32(*a3, v10);
      v13 = (int8x16_t)vmulq_f32(a3[1], v10);
      v14 = (int8x16_t)vmulq_f32(a3[2], v10);
      v15 = (int8x16_t)vmulq_f32(a3[3], v10);
      *result++ = vqmovn_high_u16(vqmovn_u16((uint16x8_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v12, v12, 0xCuLL), v10))), vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v13, v13, 0xCuLL), v10)))), (uint16x8_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v14, v14, 0xCuLL), v10))), vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v15, v15, 0xCuLL), v10))));
      a3 += 4;
      a2 -= 4;
    }
    while (v11 > 7);
  }
  if (a2 >= 1)
  {
    v16 = a2 + 1;
    v17 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      v18 = *a3++;
      v19 = (int8x16_t)vmulq_f32(v18, v17);
      v20 = vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v19, v19, 0xCuLL), v17));
      *(int16x4_t *)v20.i8 = vqmovun_s32(v20);
      result->i32[0] = vqmovn_u16((uint16x8_t)v20).u32[0];
      result = (uint8x16_t *)((char *)result + 4);
      --v16;
    }
    while (v16 > 1);
  }
  return result;
}

uint8x16_t *hg_span_write_4b_zyxw(uint8x16_t *result, int a2, float32x4_t *a3)
{
  __int32 *v3;
  float32x4_t v4;
  unsigned int v5;
  float32x4_t v6;
  int8x16_t v7;
  int32x4_t v8;
  float32x4_t v10;
  int8x16_t v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  unsigned int v15;
  unsigned int v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int32x4_t v20;

  if (a2 >= 1 && (result & 0xF) != 0)
  {
    v3 = &result->i32[1];
    v4 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      v5 = a2;
      v6 = *a3++;
      v7 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(v6, v4));
      v8 = vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v7, v7, 0xCuLL), v4));
      *(int16x4_t *)v8.i8 = vqmovun_s32(v8);
      result->i32[0] = vqmovn_u16((uint16x8_t)v8).u32[0];
      result = (uint8x16_t *)((char *)result + 4);
      --a2;
      if (v5 < 2)
        break;
    }
    while (v3++ & 0xF);
  }
  if (a2 >= 4)
  {
    v10 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      v11 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(*a3, v10));
      v12 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(a3[1], v10));
      v13 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(a3[2], v10));
      v14 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(a3[3], v10));
      v15 = a2;
      *result++ = vqmovn_high_u16(vqmovn_u16((uint16x8_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v11, v11, 0xCuLL), v10))), vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v12, v12, 0xCuLL), v10)))), (uint16x8_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v13, v13, 0xCuLL), v10))), vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v14, v14, 0xCuLL), v10))));
      a3 += 4;
      a2 -= 4;
    }
    while (v15 > 7);
  }
  if (a2 >= 1)
  {
    v16 = a2 + 1;
    v17 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      v18 = *a3++;
      v19 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(v18, v17));
      v20 = vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v19, v19, 0xCuLL), v17));
      *(int16x4_t *)v20.i8 = vqmovun_s32(v20);
      result->i32[0] = vqmovn_u16((uint16x8_t)v20).u32[0];
      result = (uint8x16_t *)((char *)result + 4);
      --v16;
    }
    while (v16 > 1);
  }
  return result;
}

uint8x16_t *hg_span_write_4b_xyzw(uint8x16_t *result, int a2, float32x4_t *a3)
{
  __int32 *v3;
  float32x4_t v4;
  unsigned int v5;
  float32x4_t v6;
  int32x4_t v7;
  float32x4_t v9;
  unsigned int v10;
  unsigned int v11;
  float32x4_t v12;
  float32x4_t v13;
  int32x4_t v14;

  if (a2 >= 1 && (result & 0xF) != 0)
  {
    v3 = &result->i32[1];
    v4 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      v5 = a2;
      v6 = *a3++;
      v7 = vcvtnq_s32_f32(vminq_f32(vmulq_f32(v6, v4), v4));
      *(int16x4_t *)v7.i8 = vqmovun_s32(v7);
      result->i32[0] = vqmovn_u16((uint16x8_t)v7).u32[0];
      result = (uint8x16_t *)((char *)result + 4);
      --a2;
      if (v5 < 2)
        break;
    }
    while (v3++ & 0xF);
  }
  if (a2 >= 4)
  {
    v9 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      v10 = a2;
      *result++ = vqmovn_high_u16(vqmovn_u16((uint16x8_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(*a3, v9), v9))), vcvtnq_s32_f32(vminq_f32(vmulq_f32(a3[1], v9), v9)))), (uint16x8_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(a3[2], v9), v9))), vcvtnq_s32_f32(vminq_f32(vmulq_f32(a3[3], v9), v9))));
      a3 += 4;
      a2 -= 4;
    }
    while (v10 > 7);
  }
  if (a2 >= 1)
  {
    v11 = a2 + 1;
    v12 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      v13 = *a3++;
      v14 = vcvtnq_s32_f32(vminq_f32(vmulq_f32(v13, v12), v12));
      *(int16x4_t *)v14.i8 = vqmovun_s32(v14);
      result->i32[0] = vqmovn_u16((uint16x8_t)v14).u32[0];
      result = (uint8x16_t *)((char *)result + 4);
      --v11;
    }
    while (v11 > 1);
  }
  return result;
}

double hg_span_write_4s(int16x8_t *a1, int a2, float32x4_t *a3, float32x4_t a4)
{
  float32x4_t v4;
  float32x4_t v5;
  unsigned int v6;
  float32x4_t v7;
  float32x4_t v8;

  if (a2 >= 1 && (a1 & 0xF) != 0)
  {
    v4 = *a3++;
    v5 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    *(int16x4_t *)a4.f32 = vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(v4, v5), v5)));
    a1->i64[0] = a4.i64[0];
    a1 = (int16x8_t *)((char *)a1 + 8);
    --a2;
  }
  if (a2 > 1)
  {
    a4 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    do
    {
      v6 = a2;
      v7 = *a3;
      v8 = a3[1];
      a3 += 2;
      *a1++ = vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(v7, a4), a4))), vcvtnq_s32_f32(vminq_f32(vmulq_f32(v8, a4), a4)));
      a2 -= 2;
    }
    while (v6 > 3);
  }
  if (a2 == 1)
  {
    a4 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    *(int16x4_t *)a4.f32 = vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(*a3, a4), a4)));
    a1->i64[0] = a4.i64[0];
  }
  return *(double *)a4.i64;
}

double hg_span_write_4s_wxyz(int16x8_t *a1, int a2, float32x4_t *a3, float32x4_t a4)
{
  float32x4_t v4;
  float32x4_t v5;
  unsigned int v6;
  float32x4_t v7;
  float32x4_t v8;
  int8x16_t v9;
  int8x16_t v10;
  float32x4_t v11;

  if (a2 >= 1 && (a1 & 0xF) != 0)
  {
    v4 = *a3++;
    v5 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    a4 = vmulq_f32(v4, v5);
    *(int16x4_t *)a4.f32 = vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8((int8x16_t)a4, (int8x16_t)a4, 0xCuLL), v5)));
    a1->i64[0] = a4.i64[0];
    a1 = (int16x8_t *)((char *)a1 + 8);
    --a2;
  }
  if (a2 > 1)
  {
    a4 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    do
    {
      v6 = a2;
      v7 = *a3;
      v8 = a3[1];
      a3 += 2;
      v9 = (int8x16_t)vmulq_f32(v7, a4);
      v10 = (int8x16_t)vmulq_f32(v8, a4);
      *a1++ = vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v9, v9, 0xCuLL), a4))), vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v10, v10, 0xCuLL), a4)));
      a2 -= 2;
    }
    while (v6 > 3);
  }
  if (a2 == 1)
  {
    v11 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    a4 = vmulq_f32(*a3, v11);
    *(int16x4_t *)a4.f32 = vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8((int8x16_t)a4, (int8x16_t)a4, 0xCuLL), v11)));
    a1->i64[0] = a4.i64[0];
  }
  return *(double *)a4.i64;
}

float16x4_t *hg_span_write_4h(float16x4_t *result, int a2, float32x4_t *a3)
{
  unsigned int v3;
  float32x4_t v4;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3++;
      *result++ = vcvt_f16_f32(v4);
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_write_4f_xyzw(_OWORD *result, int a2, __int128 *a3)
{
  unsigned int v3;
  __int128 v4;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3++;
      *result++ = v4;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

int8x16_t *hg_span_write_4f_wxyz(int8x16_t *result, int a2, int8x16_t *a3)
{
  unsigned int v3;
  int8x16_t v4;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      v4 = *a3++;
      *result++ = vextq_s8(v4, v4, 0xCuLL);
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

float32x4_t hg_span_write_4b_10bit_yxzx_little_endian(int8x16_t *a1, int a2, int32x4_t *a3, int a4, float32x4_t result)
{
  int8x16_t v5;
  int8x16_t v6;
  int8x16_t v7;
  float32x4_t v8;
  int8x16_t v9;
  float32x4_t v10;
  int32x4_t v11;
  int8x16_t v12;
  float32x4_t v13;
  int32x4_t v14;
  int32x4_t v15;
  int32x4_t v16;
  int32x4_t v17;
  int8x16_t v18;
  int32x4_t v19;
  int8x16_t v20;
  int32x4_t v21;
  int32x4_t v22;
  unsigned int v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  int8x16_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int32x4_t v33;
  int32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  int32x4_t v37;
  int32x4_t v38;
  int8x16_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  int32x4_t v44;
  int8x16_t v45;
  int32x4_t v46;

  if ((a1 & 0xF) == 0 && !(a4 % 6))
  {
    if (a2 >= 6)
    {
      result = (float32x4_t)vdupq_n_s32(0x447FC000u);
      v5.i64[0] = 0x300000003;
      v5.i64[1] = 0x300000003;
      v6 = (int8x16_t)vdupq_n_s32(0xFFC00u);
      do
      {
        v7 = vextq_s8((int8x16_t)vuzp1q_s32(*a3, a3[1]), *(int8x16_t *)a3, 4uLL);
        v8 = (float32x4_t)vextq_s8(v7, v7, 8uLL);
        v8.i32[0] = HIDWORD(a3->i64[0]);
        v9 = vextq_s8((int8x16_t)vuzp1q_s32(a3[2], a3[3]), (int8x16_t)a3[2], 4uLL);
        v10 = (float32x4_t)vextq_s8(v9, v9, 8uLL);
        v10.i32[0] = HIDWORD(a3[2].i64[0]);
        v11 = vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v8, result), (float32x4_t)0), result));
        v12 = vextq_s8((int8x16_t)vuzp1q_s32(a3[4], a3[5]), (int8x16_t)a3[4], 4uLL);
        v13 = (float32x4_t)vextq_s8(v12, v12, 8uLL);
        v14 = vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v10, result), (float32x4_t)0), result));
        v13.i32[0] = HIDWORD(a3[4].i64[0]);
        v15 = vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v13, result), (float32x4_t)0), result));
        v16 = (int32x4_t)vextq_s8((int8x16_t)vuzp2q_s32(vuzp1q_s32(v14, v14), v15), (int8x16_t)v11, 4uLL);
        v17 = vuzp1q_s32(v11, v11);
        v18 = vextq_s8((int8x16_t)vtrn2q_s32(v16, v11), (int8x16_t)v16, 8uLL);
        v11.i32[2] = v15.i32[2];
        v19 = (int32x4_t)vextq_s8((int8x16_t)v11, (int8x16_t)v14, 4uLL);
        v20 = (int8x16_t)vtrn2q_s32(v19, v14);
        v21 = (int32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)vuzp2q_s32(v17, v14), 0xCuLL);
        v22 = (int32x4_t)vandq_s8((int8x16_t)vshlq_n_s32((int32x4_t)vextq_s8(v20, (int8x16_t)v19, 8uLL), 0xAuLL), v6);
        v23 = a2;
        *a1++ = vorrq_s8(vorrq_s8((int8x16_t)(*(_OWORD *)&vshlq_n_s32((int32x4_t)vextq_s8((int8x16_t)v21, (int8x16_t)vzip1q_s32(v15, v21), 8uLL), 0x14uLL) & __PAIR128__(0x3FFFFFFF3FFFFFFFLL, 0x3FFFFFFF3FFFFFFFLL)), vandq_s8(v18, v5)), (int8x16_t)vuzp2q_s32((int32x4_t)vextq_s8((int8x16_t)v22, (int8x16_t)v22, 4uLL), v22));
        a3 += 6;
        a2 -= 6;
      }
      while (v23 > 0xB);
    }
    if (a2 >= 1)
    {
      v24 = 0uLL;
      v25 = 0uLL;
      v26 = 0uLL;
      v27 = 0uLL;
      if (a2 != 1)
      {
        v26 = a3[1];
        if (a2 >= 3)
        {
          v25 = a3[2];
          if (a2 != 3)
            v27 = a3[3];
        }
      }
      v28 = vextq_s8((int8x16_t)vuzp1q_s32(*a3, v26), *(int8x16_t *)a3, 4uLL);
      v29 = (float32x4_t)vextq_s8(v28, v28, 8uLL);
      v29.i32[0] = HIDWORD(a3->i64[0]);
      v30 = vextq_s8((int8x16_t)vuzp1q_s32(v25, v27), (int8x16_t)v25, 4uLL);
      v31 = (float32x4_t)vextq_s8(v30, v30, 8uLL);
      v31.i32[0] = v25.i32[1];
      v32 = (float32x4_t)vdupq_n_s32(0x447FC000u);
      v33 = vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v29, v32), (float32x4_t)0), v32));
      v34 = vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v31, v32), (float32x4_t)0), v32));
      if (a2 >= 5)
        v24 = a3[4];
      v35 = vextq_s8((int8x16_t)vuzp1q_s32(v24, (int32x4_t)0), (int8x16_t)v24, 4uLL);
      v36 = (float32x4_t)vextq_s8(v35, v35, 8uLL);
      v36.i32[0] = v24.i32[1];
      v37 = vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v36, v32), (float32x4_t)0), v32));
      v38 = (int32x4_t)vextq_s8((int8x16_t)vuzp2q_s32(vuzp1q_s32(v34, v34), v37), (int8x16_t)v33, 4uLL);
      v39 = vextq_s8((int8x16_t)vtrn2q_s32(v38, v33), (int8x16_t)v38, 8uLL);
      v40 = vuzp1q_s32(v33, v33);
      v33.i32[2] = v37.i32[2];
      v41 = (int32x4_t)vextq_s8((int8x16_t)v33, (int8x16_t)v34, 4uLL);
      v42 = (int32x4_t)vextq_s8((int8x16_t)vtrn2q_s32(v41, v34), (int8x16_t)v41, 8uLL);
      v43 = (int32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)vuzp2q_s32(v40, v34), 0xCuLL);
      v44 = (int32x4_t)vextq_s8((int8x16_t)v43, (int8x16_t)vzip1q_s32(v37, v43), 8uLL);
      v45 = (int8x16_t)vshlq_n_s32(v42, 0xAuLL);
      v42.i64[0] = 0x300000003;
      v42.i64[1] = 0x300000003;
      v46 = (int32x4_t)vandq_s8(v45, (int8x16_t)vdupq_n_s32(0xFFC00u));
      result = (float32x4_t)vorrq_s8(vorrq_s8((int8x16_t)(*(_OWORD *)&vshlq_n_s32(v44, 0x14uLL) & __PAIR128__(0x3FFFFFFF3FFFFFFFLL, 0x3FFFFFFF3FFFFFFFLL)), vandq_s8(v39, (int8x16_t)v42)), (int8x16_t)vuzp2q_s32((int32x4_t)vextq_s8((int8x16_t)v46, (int8x16_t)v46, 4uLL), v46));
      *a1 = (int8x16_t)result;
    }
  }
  return result;
}

int8x16_t *hg_span_write_4b_10bit_big_endian(int8x16_t *result, int a2, float32x4_t *a3)
{
  __int32 *v3;
  float32x4_t v4;
  int8x16_t v5;
  float32x4_t v6;
  int8x16_t v7;
  int32x4_t v8;
  int32x4_t v9;
  float32x4_t v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int32x2_t v16;
  int8x16_t v17;
  unsigned int v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int32x4_t v23;
  int32x4_t v24;

  if (a2 >= 1)
  {
    if ((result & 0xF) != 0)
    {
      v3 = &result->i32[1];
      v4 = (float32x4_t)vdupq_n_s32(0x447FC000u);
      v5.i64[0] = 0x300000003;
      v5.i64[1] = 0x300000003;
      do
      {
        v6 = *a3++;
        v7 = (int8x16_t)vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v6, (float32x4_t)xmmword_1B351FC30), (float32x4_t)0), v4));
        v8 = (int32x4_t)vandq_s8(v7, (int8x16_t)xmmword_1B351FC40);
        v9 = (int32x4_t)vandq_s8(v7, v5);
        result->i32[0] = vrev32q_s8(vorrq_s8(vorrq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshlq_n_s32(v9, 0xCuLL), 1), (int8x16_t)vshlq_n_s32(v8, 0x16uLL)), (int8x16_t)vdupq_laneq_s32(vshlq_n_s32(v9, 2uLL), 2))).u32[0];
        result = (int8x16_t *)((char *)result + 4);
        if (!--a2)
          break;
      }
      while (v3++ & 0xF);
    }
    if (a2 >= 4)
    {
      v11 = (float32x4_t)vdupq_n_s32(0x447FC000u);
      do
      {
        v12 = (int8x16_t)vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(*a3, (float32x4_t)xmmword_1B351FC30), (float32x4_t)0), v11));
        v13 = (int8x16_t)vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(a3[1], (float32x4_t)xmmword_1B351FC30), (float32x4_t)0), v11));
        v14 = (int8x16_t)vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(a3[2], (float32x4_t)xmmword_1B351FC30), (float32x4_t)0), v11));
        v15 = (int8x16_t)vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(a3[3], (float32x4_t)xmmword_1B351FC30), (float32x4_t)0), v11));
        v16 = (int32x2_t)vorrq_s8(vorrq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshlq_n_s32((int32x4_t)vandq_s8(v14, (int8x16_t)xmmword_1B351FC50), 0xCuLL), 1), (int8x16_t)vshlq_n_s32((int32x4_t)vandq_s8(v14, (int8x16_t)xmmword_1B351FC40), 0x16uLL)), (int8x16_t)vdupq_laneq_s32(vshlq_n_s32((int32x4_t)vandq_s8(v14, (int8x16_t)xmmword_1B351FC60), 2uLL), 2)).u64[0];
        v14.i32[0] = 0;
        v14.i32[1] = vdupq_lane_s32((int32x2_t)vorrq_s8(vorrq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)vshlq_n_s32((int32x4_t)vandq_s8(v13, (int8x16_t)xmmword_1B351FC50), 0xCuLL), 1), (int8x16_t)vshlq_n_s32((int32x4_t)vandq_s8(v13, (int8x16_t)xmmword_1B351FC40), 0x16uLL)), (int8x16_t)vdupq_laneq_s32(vshlq_n_s32((int32x4_t)vandq_s8(v13, (int8x16_t)xmmword_1B351FC60), 2uLL), 2)), 0).i32[1];
        v13.i64[0] = 0;
        v13.i64[1] = vdupq_lane_s32(v16, 0).u32[2];
        v17.i64[0] = 0;
        v17.i32[2] = 0;
        v17.i32[3] = vdupq_lane_s32((int32x2_t)vorrq_s8(vorrq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)vshlq_n_s32((int32x4_t)vandq_s8(v15, (int8x16_t)xmmword_1B351FC50), 0xCuLL), 1), (int8x16_t)vshlq_n_s32((int32x4_t)vandq_s8(v15, (int8x16_t)xmmword_1B351FC40), 0x16uLL)), (int8x16_t)vdupq_laneq_s32(vshlq_n_s32((int32x4_t)vandq_s8(v15, (int8x16_t)xmmword_1B351FC60), 2uLL), 2)), 0).i32[3];
        *result++ = vrev32q_s8(vorrq_s8(vorrq_s8((int8x16_t)v14.u64[0], (int8x16_t)vorrq_s8(vorrq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshlq_n_s32((int32x4_t)vandq_s8(v12, (int8x16_t)xmmword_1B351FC50), 0xCuLL), 1), (int8x16_t)vshlq_n_s32((int32x4_t)vandq_s8(v12, (int8x16_t)xmmword_1B351FC40), 0x16uLL)), (int8x16_t)vdupq_laneq_s32(vshlq_n_s32((int32x4_t)vandq_s8(v12, (int8x16_t)xmmword_1B351FC60), 2uLL),
                                                    2)).u32[0]),
                        vorrq_s8(v13, v17)));
        a3 += 4;
        a2 -= 4;
      }
      while (a2 > 3);
    }
    if (a2)
    {
      v18 = a2 + 1;
      v19 = (float32x4_t)vdupq_n_s32(0x447FC000u);
      v20.i64[0] = 0x300000003;
      v20.i64[1] = 0x300000003;
      do
      {
        v21 = *a3++;
        v22 = (int8x16_t)vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v21, (float32x4_t)xmmword_1B351FC30), (float32x4_t)0), v19));
        v23 = (int32x4_t)vandq_s8(v22, (int8x16_t)xmmword_1B351FC40);
        v24 = (int32x4_t)vandq_s8(v22, v20);
        result->i32[0] = vrev32q_s8(vorrq_s8(vorrq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshlq_n_s32(v24, 0xCuLL), 1), (int8x16_t)vshlq_n_s32(v23, 0x16uLL)), (int8x16_t)vdupq_laneq_s32(vshlq_n_s32(v24, 2uLL), 2))).u32[0];
        result = (int8x16_t *)((char *)result + 4);
        --v18;
      }
      while (v18 > 1);
    }
  }
  return result;
}

double hg_span_write_4s_wxyz_big_endian(int8x16_t *a1, int a2, float32x4_t *a3, int32x4_t a4)
{
  float32x4_t v4;
  float32x4_t v5;
  int32x4_t v6;
  unsigned int v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;

  if (a2 >= 1 && (a1 & 0xF) != 0)
  {
    v4 = *a3++;
    v5 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    v6 = vcvtnq_s32_f32(vminq_f32(vmulq_f32(v4, v5), v5));
    a4 = (int32x4_t)vqtbl1q_s8((int8x16_t)vqmovun_high_s32(*(int16x4_t *)v6.i8, v6), (int8x16_t)xmmword_1B351FC70);
    a4.i64[0] = vextq_s8((int8x16_t)a4, (int8x16_t)a4, 8uLL).u64[0];
    a1->i64[0] = a4.i64[0];
    a1 = (int8x16_t *)((char *)a1 + 8);
    --a2;
  }
  if (a2 > 1)
  {
    a4 = vdupq_n_s32(0x477FFF00u);
    do
    {
      v7 = a2;
      v8 = *a3;
      v9 = a3[1];
      a3 += 2;
      *a1++ = vqtbl1q_s8((int8x16_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(v8, (float32x4_t)a4), (float32x4_t)a4))), vcvtnq_s32_f32(vminq_f32(vmulq_f32(v9, (float32x4_t)a4), (float32x4_t)a4))), (int8x16_t)xmmword_1B351FC80);
      a2 -= 2;
    }
    while (v7 > 3);
  }
  if (a2 == 1)
  {
    v10 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    a4 = vcvtnq_s32_f32(vminq_f32(vmulq_f32(*a3, v10), v10));
    *(int8x8_t *)a4.i8 = vqtbl1_s8((int8x16_t)vqmovun_high_s32(vqmovun_s32(a4), a4), (int8x8_t)0x405020300010607);
    a1->i64[0] = a4.i64[0];
  }
  return *(double *)a4.i64;
}

void HGHandler::HGHandler(HGHandler *this)
{
  *(_QWORD *)this = off_1E65248E8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = xmmword_1B304F230;
  *((_OWORD *)this + 6) = xmmword_1B304F240;
  *((_OWORD *)this + 7) = xmmword_1B304F250;
  *((_OWORD *)this + 8) = xmmword_1B304EFF0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *(_OWORD *)((char *)this + 172) = 0u;
}

uint64_t HGHandler::Reset(uint64_t a1, uint64_t a2)
{
  int v3;
  _OWORD v5[4];

  *(_QWORD *)(a1 + 144) = a2;
  *(_DWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  v3 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *(_QWORD *)(a1 + 240) = 0;
  *(_DWORD *)(a1 + 236) = v3;
  v5[0] = xmmword_1B304F230;
  v5[1] = xmmword_1B304F240;
  v5[2] = xmmword_1B304F250;
  v5[3] = xmmword_1B304EFF0;
  (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)a1 + 176))(a1, v5);
  return a1;
}

uint64_t HGHandler::LoadIdentityModelViewMatrix(HGHandler *this)
{
  _OWORD v2[4];

  v2[0] = xmmword_1B304F230;
  v2[1] = xmmword_1B304F240;
  v2[2] = xmmword_1B304F250;
  v2[3] = xmmword_1B304EFF0;
  return (*(uint64_t (**)(HGHandler *, _OWORD *))(*(_QWORD *)this + 176))(this, v2);
}

uint64_t HGHandler::Init(uint64_t this, HGRect a2, HGRect a3, int a4, int a5)
{
  *(HGRect *)(this + 188) = a2;
  *(HGRect *)(this + 204) = a3;
  *(HGRect *)(this + 220) = a3;
  *(_DWORD *)(this + 240) = a4;
  *(_DWORD *)(this + 244) = a5;
  return this;
}

uint64_t HGHandler::InitTexture(uint64_t this, int a2, HGRect a3, HGRect a4, HGRect a5, int a6, int a7)
{
  *(HGRect *)(this + 188) = a3;
  *(HGRect *)(this + 204) = a4;
  *(HGRect *)(this + 220) = a5;
  *(_DWORD *)(this + 240) = a4.var0 + a6 - a5.var0;
  *(_DWORD *)(this + 244) = a4.var1 + a7 - a5.var1;
  return this;
}

int32x4_t HGHandler::Push(int32x4_t *this, const HGShaderBinding *a2)
{
  int32x4_t result;

  this[9].i32[2] += *(_DWORD *)a2;
  result = vaddq_s32(this[10], *(int32x4_t *)((char *)a2 + 8));
  this[10] = result;
  this[11].i32[0] += *((_DWORD *)a2 + 6);
  return result;
}

int32x4_t HGHandler::Pop(int32x4_t *this, const HGShaderBinding *a2)
{
  int32x4_t result;

  this[9].i32[2] -= *(_DWORD *)a2;
  result = vsubq_s32(this[10], *(int32x4_t *)((char *)a2 + 8));
  this[10] = result;
  this[11].i32[0] -= *((_DWORD *)a2 + 6);
  return result;
}

uint64_t HGHandler::TexCoord(HGHandler *this, int a2, int a3, int a4, const double *a5)
{
  uint64_t v9;

  v9 = (*(uint64_t (**)(HGHandler *))(*(_QWORD *)this + 80))(this);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)this + 96))(this, (double)(*((_DWORD *)this + 60) + a3), (double)(*((_DWORD *)this + 61) + a4), 0.0);
  if (a5)
    (*(void (**)(HGHandler *, const double *))(*(_QWORD *)this + 112))(this, a5);
  return v9;
}

uint64_t HGHandler::TexOffset(HGHandler *this, int a2, int a3, int a4)
{
  uint64_t v7;

  v7 = (*(uint64_t (**)(HGHandler *))(*(_QWORD *)this + 80))(this);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)this + 96))(this, (double)(*((_DWORD *)this + 60) + a3), (double)(*((_DWORD *)this + 61) + a4), 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)this + 104))(this, 0.0, 0.0, 0.0);
  return v7;
}

__n128 HGHandler::LoadModelViewMatrix(HGHandler *this, const simd::float4x4 *a2)
{
  __n128 result;
  simd_float4 v3;
  simd_float4 v4;

  result = (__n128)a2->columns[0];
  v3 = a2->columns[1];
  v4 = a2->columns[3];
  *((_OWORD *)this + 3) = a2->columns[2];
  *((simd_float4 *)this + 4) = v4;
  *((__n128 *)this + 1) = result;
  *((simd_float4 *)this + 2) = v3;
  return result;
}

__n128 HGHandler::LoadProjectionMatrix(HGHandler *this, const simd::float4x4 *a2)
{
  __n128 result;
  simd_float4 v3;
  simd_float4 v4;

  result = (__n128)a2->columns[0];
  v3 = a2->columns[1];
  v4 = a2->columns[3];
  *((_OWORD *)this + 7) = a2->columns[2];
  *((simd_float4 *)this + 8) = v4;
  *((__n128 *)this + 5) = result;
  *((simd_float4 *)this + 6) = v3;
  return result;
}

uint64_t HGHandler::EnvParameters(HGHandler *this, int a2, const float *a3)
{
  return 0xFFFFFFFFLL;
}

void HGLinearFilter2D::HGLinearFilter2D(HGLinearFilter2D *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
}

uint64_t HGLinearFilter2D::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;

  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  v4 = *(_DWORD *)(a2 + 16);
  v5 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 16) = v4;
  *(_DWORD *)(a1 + 20) = v5;
  if ((*(_BYTE *)(a2 + 28) & 2) != 0)
  {
    v6 = v5 * v4;
    if (*(_DWORD *)(a1 + 24) < v5 * v4)
    {
      if ((*(_BYTE *)(a1 + 28) & 2) != 0 && *(_QWORD *)a1)
        MEMORY[0x1B5E2914C]();
      *(_DWORD *)(a1 + 24) = v6;
      *(_QWORD *)a1 = operator new[]();
    }
    if (v6 >= 1)
    {
      v7 = 0;
      do
      {
        *(_OWORD *)(*(_QWORD *)a1 + v7) = *(_OWORD *)(*(_QWORD *)a2 + v7);
        v7 += 16;
      }
      while (16 * v6 != v7);
    }
  }
  else
  {
    if ((*(_BYTE *)(a1 + 28) & 2) != 0)
    {
      if (*(_QWORD *)a1)
        MEMORY[0x1B5E2914C]();
      *(_QWORD *)a1 = 0;
      *(_DWORD *)(a1 + 24) = 0;
    }
    *(_QWORD *)a1 = *(_QWORD *)a2;
  }
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  return a1;
}

uint64_t HGLinearFilter2D::operator==(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  unint64_t v4;
  uint64_t v5;
  BOOL v6;
  int8x16_t v7;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  if (*(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12))
    return 0;
  v2 = *(_DWORD *)(a1 + 16);
  if (v2 != *(_DWORD *)(a2 + 16))
    return 0;
  v3 = *(_DWORD *)(a1 + 20);
  if (v3 != *(_DWORD *)(a2 + 20))
    return 0;
  if (*(_QWORD *)a1 == *(_QWORD *)a2)
    return 1;
  if ((*(_DWORD *)(a1 + 28) & *(_DWORD *)(a2 + 28) & 2) == 0)
    return 0;
  v4 = (v3 * v2);
  if ((int)v4 < 1)
    return 1;
  v5 = 0;
  v6 = 0;
  do
  {
    v7 = vmvnq_s8((int8x16_t)vceqq_f32(*(float32x4_t *)(*(_QWORD *)a1 + 16 * v5), *(float32x4_t *)(*(_QWORD *)a2 + 16 * v5)));
    *(int32x2_t *)v7.i8 = vpmin_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
    if (vpmin_s32(*(int32x2_t *)v7.i8, *(int32x2_t *)v7.i8).u32[0])
      break;
    v6 = ++v5 >= v4;
  }
  while (v4 != v5);
  return v6;
}

BOOL HGLinearFilter2D::setType(HGLinearFilter2D *this, unsigned int a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  signed int v10;
  signed int v11;
  int v12;
  signed int v13;
  signed int v14;
  unsigned int v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  int8x16_t v24;
  uint64_t v25;

  if (a2 <= 0x39)
  {
    v6 = 4 * (int)a2;
    v7 = *(unsigned int *)((char *)&unk_1B3521F88 + v6);
    v8 = *(_DWORD *)((char *)&unk_1B3522070 + v6);
    v9 = (uint64_t)*(&off_1E65249C8 + (int)a2);
    v10 = (v7 - 1) >> 1;
    v11 = (v8 - 1) >> 1;
    if (a3 == 4)
    {
      v12 = *((_DWORD *)this + 7);
      if ((v12 & 2) != 0 && *(_QWORD *)this)
      {
        MEMORY[0x1B5E2914C]();
        v12 = *((_DWORD *)this + 7);
      }
      *((_DWORD *)this + 4) = v7;
      *((_DWORD *)this + 5) = v8;
      *(_QWORD *)this = v9;
      *((_DWORD *)this + 7) = v12 & 0xFFFFFFFD;
      *((_DWORD *)this + 2) = -v10;
      *((_DWORD *)this + 3) = -v11;
    }
    else
    {
      v13 = *((_DWORD *)this + 2);
      v14 = *((_DWORD *)this + 3);
      if (v10 >= v13)
        v15 = *((_DWORD *)this + 2);
      else
        v15 = (v7 - 1) >> 1;
      v16 = *((_DWORD *)this + 5);
      v17 = v13 + *((_DWORD *)this + 4);
      if (v11 >= v14)
        v18 = *((_DWORD *)this + 3);
      else
        v18 = (v8 - 1) >> 1;
      v19 = v17 - 1;
      if ((int)v7 - 1 + v10 <= v19)
        v20 = v19;
      else
        v20 = v7 - 1 + v10;
      if (v8 - 1 + v11 <= v14 + v16 - 1)
        v21 = v14 + v16 - 1;
      else
        v21 = v8 - 1 + v11;
      HGLinearFilter2D::resize(this, v15, v18, v20, v21, 0);
      v22 = 0;
      v23 = *(_QWORD *)this
          + 16 * (v10 - *((_DWORD *)this + 2) + (v11 - *((_DWORD *)this + 3)) * *((_DWORD *)this + 4));
      v24 = g_Mask[a3];
      do
      {
        v25 = 0;
        do
        {
          *(int8x16_t *)(v23 + 16 * v25) = vbslq_s8(v24, *(int8x16_t *)(v9 + 16 * v25), *(int8x16_t *)(v23 + 16 * v25));
          ++v25;
        }
        while (v7 != v25);
        v23 += 16 * *((int *)this + 4);
        ++v22;
        v9 += 16 * v7;
      }
      while (v22 != v8);
    }
  }
  return a2 < 0x3A;
}

HGLinearFilter2D *HGLinearFilter2D::HGLinearFilter2D(HGLinearFilter2D *a1, unsigned int a2)
{
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  HGLinearFilter2D::setType(a1, a2, 4);
  return a1;
}

void HGLinearFilter2D::~HGLinearFilter2D(HGLinearFilter2D *this)
{
  if ((*((_BYTE *)this + 28) & 2) != 0)
  {
    if (*(_QWORD *)this)
      MEMORY[0x1B5E2914C]();
  }
}

uint64_t HGLinearFilter2D::resize(HGLinearFilter2D *this, int a2, int a3, int a4, int a5, int a6)
{
  uint64_t v7;
  int v8;
  uint64_t v10;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  int v35;
  unint64_t v36;
  int v37;
  uint64_t v38;
  unint64_t i;
  uint64_t v41;
  __int128 *v42;
  _OWORD *v43;
  __int128 v44;
  int v45;
  int v46;

  v7 = (a4 - a2 + 1);
  v8 = a5 - a3 + 1;
  if ((int)v7 < 1 || v8 < 1)
  {
    if ((*((_BYTE *)this + 28) & 2) != 0 && *(_QWORD *)this)
      MEMORY[0x1B5E2914C]();
    v10 = 0;
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
  }
  else
  {
    v16 = (v8 * v7);
    if (!a6
      && *((_DWORD *)this + 2) == a2
      && *((_DWORD *)this + 3) == a3
      && __PAIR64__(v8, v7) == *((_QWORD *)this + 2))
    {
      if ((*((_BYTE *)this + 28) & 2) != 0)
      {
        if ((int)v16 <= *((_DWORD *)this + 6))
          return *(_QWORD *)this;
        *((_DWORD *)this + 6) = v16;
        v41 = operator new[]();
        v10 = v41;
        v42 = *(__int128 **)this;
        if (*(_QWORD *)this && (int)v16 >= 1)
        {
          v43 = (_OWORD *)v41;
          do
          {
            v44 = *v42++;
            *v43++ = v44;
            --v16;
          }
          while (v16);
        }
      }
      else
      {
        *((_DWORD *)this + 6) = v16;
        v17 = operator new[]();
        v10 = v17;
        v18 = *(_QWORD *)this;
        if (*(_QWORD *)this)
        {
          v19 = 0;
          v20 = 16 * *((int *)this + 4);
          v21 = 16 * v7;
          v22 = v17;
          do
          {
            v23 = 0;
            do
            {
              *(_OWORD *)(v22 + v23) = *(_OWORD *)(v18 + v23);
              v23 += 16;
            }
            while (v21 != v23);
            ++v19;
            v18 += v20;
            v22 += v21;
          }
          while (v19 != v8);
        }
      }
      *(_QWORD *)this = v10;
      *((_DWORD *)this + 7) |= 2u;
    }
    else
    {
      v45 = *((_DWORD *)this + 4);
      v46 = *((_DWORD *)this + 5);
      *((_DWORD *)this + 6) = v16 + a6;
      v24 = operator new[]();
      v25 = v24;
      if ((int)v16 >= 1)
        bzero((void *)(v24 + 16 * a6), 16 * (v8 * v7));
      v10 = v25 + 16 * a6;
      if (*(_QWORD *)this)
      {
        v27 = *((_DWORD *)this + 2);
        v26 = *((_DWORD *)this + 3);
        if (a2 <= v27)
          v28 = 0;
        else
          v28 = a2 - v27;
        if (a2 <= v27)
          v29 = -(uint64_t)(a2 - v27);
        else
          v29 = 0;
        v30 = v10 + 16 * v29;
        v31 = *(_QWORD *)this + 16 * v28;
        v32 = *((_DWORD *)this + 4);
        v33 = a3 - v26;
        if (a3 <= v26)
        {
          v30 -= 16 * v33 * (int)v7;
          v34 = v46;
        }
        else
        {
          v34 = v46 - v33;
          v31 += 16 * v33 * v32;
        }
        v35 = v34 - ((v26 + ~a5 + *((_DWORD *)this + 5)) & ~((v26 + ~a5 + *((_DWORD *)this + 5)) >> 31));
        if (v35 >= 1)
        {
          v36 = v45 - v28 - ((v27 + ~a4 + v32) & ~((v27 + ~a4 + v32) >> 31));
          if ((int)v36 >= 1)
          {
            v37 = 0;
            v38 = 16 * *((int *)this + 4);
            do
            {
              for (i = 0; i < v36; ++i)
                *(_OWORD *)(v30 + 16 * i) = *(_OWORD *)(v31 + 16 * i);
              ++v37;
              v31 += v38;
              v30 += 16 * v7;
            }
            while (v37 < v35);
          }
        }
        if ((*((_BYTE *)this + 28) & 2) != 0 && *(_QWORD *)this)
          MEMORY[0x1B5E2914C](*(_QWORD *)this, 0x1000C80451B5BE8);
      }
      *(_QWORD *)this = v25;
      *((_DWORD *)this + 7) |= 2u;
      *((_DWORD *)this + 2) = a2;
      *((_DWORD *)this + 3) = a3;
      *((_DWORD *)this + 4) = v7;
      *((_DWORD *)this + 5) = v8;
    }
  }
  return v10;
}

int8x16_t HGLinearFilter2D::set(HGLinearFilter2D *this, int a2, int a3, int32x2_t a4, int a5)
{
  int v6;
  int v7;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  int8x16_t result;

  v6 = a3;
  v7 = a2;
  if (*(_QWORD *)this)
  {
    v9 = *((_DWORD *)this + 2);
    v10 = *((_DWORD *)this + 3);
    if (a2 >= v9)
      a2 = *((_DWORD *)this + 2);
    v12 = v9 + *((_DWORD *)this + 4);
    if (a3 >= v10)
      a3 = *((_DWORD *)this + 3);
    v13 = v12 - 1;
    if (v7 <= v13)
      v14 = v13;
    else
      v14 = v7;
    v11 = *((_DWORD *)this + 5);
    if (v6 <= v10 + v11 - 1)
      v15 = v10 + v11 - 1;
    else
      v15 = v6;
    HGLinearFilter2D::resize(this, a2, a3, v14, v15, 0);
    v16 = *(_QWORD *)this;
    v18 = *((_DWORD *)this + 2);
    v17 = *((_DWORD *)this + 3);
    v19 = *((_DWORD *)this + 4);
  }
  else
  {
    v19 = 1;
    *((_DWORD *)this + 6) = 1;
    v16 = operator new[]();
    *(_QWORD *)this = v16;
    *((_DWORD *)this + 2) = v7;
    *((_DWORD *)this + 3) = v6;
    *((_QWORD *)this + 2) = 0x100000001;
    *((_DWORD *)this + 7) |= 2u;
    v17 = v6;
    v18 = v7;
  }
  v20 = 16 * (v7 - v18 + (v6 - v17) * v19);
  result = vbslq_s8(g_Mask[a5], (int8x16_t)vdupq_lane_s32(a4, 0), *(int8x16_t *)(v16 + v20));
  *(int8x16_t *)(v16 + v20) = result;
  return result;
}

uint64_t HGLinearFilter2D::reset(uint64_t this, int a2, int a3)
{
  uint64_t v3;
  int v6;
  uint64_t v7;
  _QWORD *v8;

  v3 = this;
  if (a2 && a3)
  {
    v6 = a3 * a2;
    if (*(_DWORD *)(this + 20) * *(_DWORD *)(this + 16) != a3 * a2)
    {
      if ((*(_BYTE *)(this + 28) & 2) != 0 && *(_QWORD *)this)
        MEMORY[0x1B5E2914C]();
      *(_DWORD *)(v3 + 24) = v6;
      this = operator new[]();
      *(_QWORD *)v3 = this;
      *(_DWORD *)(v3 + 28) |= 2u;
    }
    *(_QWORD *)(v3 + 8) = 0;
    *(_DWORD *)(v3 + 16) = a2;
    *(_DWORD *)(v3 + 20) = a3;
    if (v6 >= 1)
    {
      v7 = 0;
      do
      {
        v8 = (_QWORD *)(*(_QWORD *)v3 + v7);
        *v8 = 0;
        v8[1] = 0;
        v7 += 16;
      }
      while (16 * v6 != v7);
    }
  }
  else
  {
    if ((*(_BYTE *)(this + 28) & 2) != 0)
    {
      this = *(_QWORD *)this;
      if (*(_QWORD *)v3)
        this = MEMORY[0x1B5E2914C]();
    }
    *(_QWORD *)v3 = 0;
    *(_QWORD *)(v3 + 8) = 0;
    *(_QWORD *)(v3 + 16) = 0;
  }
  return this;
}

_DWORD *HGLinearFilter2D::translate(_DWORD *this, int a2, int a3)
{
  int v3;

  if (a3 | a2)
    this[7] &= ~1u;
  v3 = this[3] + a3;
  this[2] += a2;
  this[3] = v3;
  return this;
}

int32x2_t *HGLinearFilter2D::transpose(int32x2_t *this)
{
  uint64_t v2;
  int32x2_t v3;
  uint64_t v4;
  uint64_t v5;
  int v7;
  uint64_t v8;
  _OWORD *v9;
  uint64_t v10;
  _OWORD *v11;
  __int32 v12;

  if (*this)
  {
    this[3].i32[0] = this[2].i32[1] * this[2].i32[0];
    v2 = operator new[]();
    v3 = *this;
    v4 = this[2].u32[0];
    v5 = this[2].u32[1];
    if ((int)v4 >= 1 && (int)v5 >= 1)
    {
      v7 = 0;
      v8 = v2;
      v9 = (_OWORD *)*this;
      do
      {
        v10 = 0;
        v11 = v9;
        do
        {
          *(_OWORD *)(v8 + v10) = *v11;
          v10 += 16;
          v11 += v4;
        }
        while (16 * v5 != v10);
        ++v9;
        ++v7;
        v8 += 16 * (int)v5;
      }
      while (v7 != (_DWORD)v4);
    }
    this[2].i32[0] = v5;
    this[2].i32[1] = v4;
    this[1] = vrev64_s32(this[1]);
    v12 = this[3].i32[1];
    if ((v12 & 2) != 0 && *(_QWORD *)&v3)
    {
      MEMORY[0x1B5E2914C](*(_QWORD *)&v3, 0x1000C80451B5BE8);
      v12 = this[3].i32[1];
    }
    *this = (int32x2_t)v2;
    this[3].i32[1] = v12 | 2;
  }
  return this;
}

int32x2_t *HGLinearFilter2D::mirror(int32x2_t *this, int a2, int a3)
{
  int v6;
  int32x2_t v7;
  __int32 v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int32x2_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int32x2_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  int32x2_t v38;

  if ((this[3].i8[4] & 2) == 0)
    HGLinearFilter2D::resize((HGLinearFilter2D *)this, this[1].i32[0], this[1].i32[1], this[1].i32[0] + this[2].i32[0] - 1, this[1].i32[1] + this[2].i32[1] - 1, 0);
  if (a3)
  {
    if (a2)
    {
      v6 = 0;
      v7 = *this;
      v9 = this[2].i32[0];
      v8 = this[2].i32[1];
      v10 = *(_QWORD *)this + 16 * (v8 - 1) * v9;
      if (v9 >= 2)
        goto LABEL_6;
LABEL_10:
      LODWORD(v11) = 0;
      if (v9 != 1)
        goto LABEL_12;
LABEL_11:
      v16 = 16 * v11;
      v17 = *(_OWORD *)(*(_QWORD *)&v7 + v16);
      v18 = 16 * (int)v11;
      *(_OWORD *)(*(_QWORD *)&v7 + v16) = *(_OWORD *)(v10 + v18);
      *(_OWORD *)(v10 + v18) = v17;
LABEL_12:
      while (v6 != --v8)
      {
        ++v6;
        v9 = this[2].i32[0];
        if (v6 == v8)
          goto LABEL_34;
        v19 = 16 * v9;
        *(_QWORD *)&v7 += v19;
        v10 -= v19;
        if (v9 < 2)
          goto LABEL_10;
LABEL_6:
        v11 = 0;
        v12 = v9;
        v13 = v10 - 16;
        do
        {
          v14 = *(_OWORD *)(*(_QWORD *)&v7 + 16 * v11);
          *(_OWORD *)(*(_QWORD *)&v7 + 16 * v11) = *(_OWORD *)(v13 + 16 * v12);
          *(_OWORD *)(v13 + 16 * v12) = v14;
          ++v11;
          v15 = v12 - 2;
          --v12;
        }
        while (v11 < v15);
        if ((_DWORD)v11 == ~(_DWORD)v11 + v9)
          goto LABEL_11;
      }
      v9 = this[2].i32[0];
LABEL_34:
      v38.i32[0] = v9;
      v38.i32[1] = this[2].i32[1];
      this[1] = vsub_s32((int32x2_t)0x100000001, vadd_s32(this[1], v38));
      return this;
    }
    v27 = this[2].i32[1];
    if (v27 >= 2)
    {
      v28 = this[2].i32[0];
      if (v28 >= 1)
      {
        v29 = 0;
        v30 = v27 - 1;
        v31 = *this;
        v32 = *(_QWORD *)this + 16 * v30 * v28;
        do
        {
          if (v28 < 1)
          {
            v33 = v28;
          }
          else
          {
            v35 = 0;
            do
            {
              v36 = 16 * v35;
              v37 = *(_OWORD *)(*(_QWORD *)&v31 + 16 * v35);
              *(_OWORD *)(*(_QWORD *)&v31 + v36) = *(_OWORD *)(v32 + 16 * v35);
              *(_OWORD *)(v32 + v36) = v37;
              ++v35;
              v33 = this[2].i32[0];
            }
            while (v35 < v33);
            v28 = this[2].i32[0];
          }
          v34 = 16 * v33;
          *(_QWORD *)&v31 += v34;
          v32 -= v34;
          ++v29;
          --v30;
        }
        while (v29 < v30);
        v27 = this[2].i32[1];
      }
    }
    this[1].i32[1] = 1 - v27 - this[1].i32[1];
    return this;
  }
  else
  {
    if (!a2)
      return this;
    v20 = this[2].i32[1];
    if (v20 <= 0)
    {
      v23 = this[2].i32[0];
    }
    else
    {
      v21 = 0;
      v22 = *this;
      v23 = this[2].i32[0];
      do
      {
        if (v23 >= 2)
        {
          v24 = 0;
          v25 = v23 - 1;
          do
          {
            v26 = *(_OWORD *)(*(_QWORD *)&v22 + 16 * v24);
            *(_OWORD *)(*(_QWORD *)&v22 + 16 * v24) = *(_OWORD *)(*(_QWORD *)&v22 + 16 * v25);
            *(_OWORD *)(*(_QWORD *)&v22 + 16 * v25) = v26;
            ++v24;
            --v25;
          }
          while (v24 < v25);
          v23 = this[2].i32[0];
          v20 = this[2].i32[1];
        }
        *(_QWORD *)&v22 += 16 * v23;
        ++v21;
      }
      while (v21 < v20);
    }
    this[1].i32[0] = 1 - v23 - this[1].i32[0];
    return this;
  }
}

uint64_t HGLinearFilter2D::normalize(uint64_t result, unsigned int a2, float32x4_t a3)
{
  int v3;
  float32x4_t v4;
  uint64_t v5;
  int v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t *v26;
  uint64_t v27;
  float32x4_t *v28;
  int v29;

  v3 = *(_DWORD *)(result + 20);
  v4 = 0uLL;
  if (v3 >= 1)
  {
    v5 = *(int *)(result + 16);
    if ((int)v5 >= 1)
    {
      v6 = 0;
      v7 = *(float32x4_t **)result;
      v8 = 16 * v5;
      do
      {
        v9 = 0;
        do
          v4 = vaddq_f32(v4, v7[v9++]);
        while (*(unsigned int *)(result + 16) != v9);
        ++v6;
        v7 = (float32x4_t *)((char *)v7 + v8);
      }
      while (v6 != v3);
    }
  }
  if (v3 >= 1)
  {
    v10 = *(_DWORD *)(result + 16);
    if (v10 >= 1)
    {
      v11 = 0;
      __asm { FMOV            V3.4S, #1.0 }
      v17.i64[0] = 0x80000000800000;
      v17.i64[1] = 0x80000000800000;
      v18 = vmaxq_f32(vaddq_f32(v4, (float32x4_t)vandq_s8(_Q3, (int8x16_t)vceqzq_f32(v4))), v17);
      v19 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
      v20 = vminq_f32(v18, v19);
      v21 = vminq_f32(vmaxq_f32(vrecpeq_f32(v20), v17), v19);
      v22 = vmulq_f32(v21, vrecpsq_f32(v20, v21));
      v23 = g_Mask[a2];
      v24 = vminq_f32(vmaxq_f32(v22, v17), v19);
      v25 = vmulq_f32(vmulq_f32(v24, vrecpsq_f32(v20, v24)), a3);
      v26 = *(float32x4_t **)result;
      do
      {
        while (v10 < 1)
        {
          v26 += v10;
          if (++v11 >= v3)
            return result;
        }
        v27 = 0;
        v28 = v26;
        do
        {
          *(int8x16_t *)v28 = vbslq_s8(v23, (int8x16_t)vmulq_f32(v25, *v28), *(int8x16_t *)v28);
          ++v28;
          ++v27;
          v29 = *(_DWORD *)(result + 16);
        }
        while (v27 < v29);
        v3 = *(_DWORD *)(result + 20);
        v10 = *(_DWORD *)(result + 16);
        v26 += v29;
        ++v11;
      }
      while (v11 < v3);
    }
  }
  return result;
}

HGLinearFilter2D *HGLinearFilter2D::convolve(int32x2_t *this, const HGLinearFilter2D *a2)
{
  int v4;
  int32x2_t v6;
  __int128 v7;
  int v8;
  int v9;

  if (!*(_QWORD *)this || !*(_QWORD *)a2)
    return (HGLinearFilter2D *)this;
  v4 = *((_DWORD *)a2 + 7);
  if ((v4 & 1) == 0)
  {
    v6 = *(int32x2_t *)a2;
    v7 = *(_OWORD *)((char *)a2 + 8);
    v8 = 0;
    v9 = v4;
    HGLinearFilter2D::mirror(&v6, 1, 1);
    HGLinearFilter2D::correlate(this, &v6);
    if (*(_QWORD *)&v6 == *(_QWORD *)a2)
    {
      HGLinearFilter2D::mirror(&v6, 1, 1);
    }
    else if ((v9 & 2) != 0)
    {
      if (v6)
        MEMORY[0x1B5E2914C]();
    }
    return (HGLinearFilter2D *)this;
  }
  return HGLinearFilter2D::correlate(this, (int32x2_t *)a2);
}

void sub_1B2A5F214(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
  if ((a13 & 2) != 0)
    HGLinearFilter2D::convolve(&a9);
  _Unwind_Resume(exception_object);
}

HGLinearFilter2D *HGLinearFilter2D::correlate(int32x2_t *this, int32x2_t *a2)
{
  BOOL v3;
  int v5;
  __int32 v6;
  int v7;
  __int32 v8;
  int32x2_t v9;
  int32x2_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int32x2_t v14;
  float32x4_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t (*v24)();
  uint64_t v25;
  int32x2_t v27;
  __int32 v28;
  __int32 v29;
  uint64_t v30;
  int v31;
  int v32;
  int32x2_t v33;
  int v34;
  uint64_t v35;
  int v36;

  if (*this)
    v3 = *a2 == 0;
  else
    v3 = 1;
  if (!v3)
  {
    v5 = *(_QWORD *)&a2[2] - 1;
    v6 = v5 + this[2].i32[0];
    v7 = HIDWORD(*(_QWORD *)&a2[2]) - 1;
    v8 = v7 + this[2].i32[1];
    v9 = this[1];
    v10 = vadd_s32(vsub_s32(v9, vadd_s32(a2[2], a2[1])), (int32x2_t)0x100000001);
    v11 = HGLinearFilter2D::resize((HGLinearFilter2D *)this, v9.i32[0] - v5, v9.i32[1] - v7, v6 + v9.i32[0] - 1, v8 + v9.i32[1] - 1, v8 * v6);
    v12 = this[2].i32[0];
    v13 = this[1].i32[0] + this[1].i32[1] * v12;
    v14 = *this;
    v30 = 0;
    v31 = v6;
    v32 = v8;
    v33 = v14;
    v34 = v6;
    v35 = v11 + 16 * -v13;
    v36 = v12;
    v15 = (float32x4_t *)*a2;
    v16 = a2[2].u32[0];
    v17 = a2[2].i32[1];
    v28 = v8;
    v29 = v6;
    v27 = v14;
    if ((int)v16 < 2)
    {
      if ((int)v17 < 7)
      {
        ((void (*)(uint64_t *, float32x4_t *, _QWORD))cy[v17])(&v30, v15, v13);
      }
      else
      {
        v21 = c4y((uint64_t)&v30, v15, v13);
        v22 = v17 - v21;
        if ((int)v17 - v21 >= 7)
        {
          do
          {
            v21 += cadd4y((uint64_t)&v30, &v15[v21], v13 + v21 * (int)v12);
            v22 = v17 - v21;
          }
          while ((int)v17 - v21 > 6);
        }
        ((void (*)(uint64_t *, float32x4_t *, _QWORD))caddy[v22])(&v30, &v15[v21], v13 + v21 * (int)v12);
      }
      goto LABEL_24;
    }
    if (v16 < 7)
    {
      ((void (*)(uint64_t *, float32x4_t *, _QWORD))cx[v16])(&v30, v15, v13);
      v20 = v17 - 1;
      if (!v20)
      {
LABEL_24:
        *this = v27;
        this[2].i32[0] = v29;
        this[2].i32[1] = v28;
        this[1] = v10;
        this[3].i32[1] = this[3].i32[1] & a2[3].i32[1] & 1 | 2;
        return (HGLinearFilter2D *)this;
      }
    }
    else
    {
      LODWORD(v18) = c4x((uint64_t)&v30, v15, v13);
      v19 = v16 - v18;
      if ((int)v16 - (int)v18 >= 7)
      {
        do
        {
          v18 = cadd4x((uint64_t)&v30, &v15[(int)v18], (int)v18 + v13) + (int)v18;
          v19 = v16 - v18;
        }
        while ((int)v16 - (int)v18 > 6);
      }
      ((void (*)(uint64_t *, float32x4_t *, _QWORD))caddx[v19])(&v30, &v15[(int)v18], (int)v18 + v13);
      v20 = v17 - 1;
      if (!v20)
        goto LABEL_24;
    }
    if ((int)v16 < 7)
    {
      v24 = caddx[(int)v16];
      v25 = v12 + v13;
      do
      {
        v15 += a2[2].i32[0];
        ((void (*)(uint64_t *, float32x4_t *, uint64_t))v24)(&v30, v15, v25);
        v25 += v12;
        --v20;
      }
      while (v20);
    }
    else
    {
      do
      {
        v23 = 0;
        v13 += v12;
        v15 += a2[2].i32[0];
        do
          v23 += cadd4x((uint64_t)&v30, &v15[v23], v23 + v13);
        while ((int)v16 - v23 > 6);
        ((void (*)(uint64_t *, float32x4_t *, _QWORD))caddx[(int)v16 - v23])(&v30, &v15[v23], v23 + v13);
        --v20;
      }
      while (v20);
    }
    goto LABEL_24;
  }
  return (HGLinearFilter2D *)this;
}

float HGLinearFilter::rect(HGLinearFilter *this, float a2, float a3, float a4)
{
  BOOL v4;
  float result;

  v4 = fabsf(a2) < 1.0;
  result = 0.0;
  if (v4)
    return 1.0;
  return result;
}

float HGLinearFilter::bicubic(HGLinearFilter *this, float a2, float a3, float a4)
{
  float v4;
  float result;

  v4 = fabsf(a2);
  if (v4 < 1.0)
    return (float)((float)(a3 * -0.33333) + 1.0)
         + (float)(v4
                 * (float)((float)(v4 * (float)((float)((float)(a3 + a3) + a4) + -3.0))
                         + (float)(v4 * (float)(v4 * (float)((float)((float)(a3 * -1.5) + 2.0) - a4)))));
  result = 0.0;
  if (v4 < 2.0)
    return (float)((float)(a3 * 1.3333) + (float)(a4 * 4.0))
         + (float)(v4
                 * (float)((float)((float)(a4 * -8.0) - (float)(a3 + a3))
                         + (float)(v4
                                 * (float)((float)(v4 * (float)((float)(a3 * -0.16667) - a4))
                                         + (float)((float)(a4 * 5.0) + a3)))));
  return result;
}

void HGLinearFilter::lanczos(HGLinearFilter *this, float a2, float a3, float a4)
{
  float v6;

  if (fabsf(a2) < a3)
  {
    if ((float)((float)((float)(a2 * 3.1416) * (float)(a2 * 3.1416)) + 1.0) != 1.0)
      sinf(a2 * 3.1416);
    v6 = (float)(a2 / a3) * 3.1416;
    if ((float)((float)(v6 * v6) + 1.0) != 1.0)
      sinf(v6);
  }
}

uint64_t HGLinearFilter2D::convolve(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  if (result)
    return MEMORY[0x1B5E2914C](result, 0x1000C80451B5BE8);
  return result;
}

_QWORD *HGLUTCache::LUTEntry::LUTEntry(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  *a1 = off_1E6524BA8;
  a1[1] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  a1[2] = a3;
  return a1;
}

void HGLUTCache::LUTEntry::~LUTEntry(HGLUTCache::LUTEntry *this)
{
  uint64_t v1;

  *(_QWORD *)this = off_1E6524BA8;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
}

BOOL HGLUTCache::isLUTCached(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(uint64_t **)(a1 + 8);
  v3 = *v2;
  v4 = v2[1];
  if (*v2 == v4)
    return 0;
  while (((*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(*(_QWORD *)v3 + 8)) & 1) == 0)
  {
    v3 += 8;
    if (v3 == v4)
    {
      v3 = v4;
      return v3 != *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
    }
  }
  return v3 != *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
}

uint64_t HGLUTCache::getNewLUT(uint64_t a1, uint64_t a2)
{
  uint64_t **v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t **v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  _BYTE *v19;
  uint64_t *v20;
  uint64_t *v21;
  char *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  _OWORD *v27;
  uint64_t *v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;

  v4 = *(uint64_t ***)(a1 + 8);
  v5 = *v4;
  v6 = v4[1];
  if (*v4 == v6)
    goto LABEL_7;
  while (((*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(*v5 + 8)) & 1) == 0)
  {
    if (++v5 == v6)
    {
      v5 = v6;
      break;
    }
  }
  if (v5 == *(uint64_t **)(*(_QWORD *)(a1 + 8) + 8))
  {
LABEL_7:
    v8 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), a2, *(_QWORD *)a1);
    v7 = v8;
    v9 = *(uint64_t ***)(a1 + 8);
    v11 = v9[1];
    v10 = (unint64_t)v9[2];
    if ((unint64_t)v11 < v10)
    {
      *v11 = v8;
      v12 = (uint64_t)(v11 + 1);
LABEL_29:
      v9[1] = (uint64_t *)v12;
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
    }
    v13 = *v9;
    v14 = (char *)v11 - (char *)*v9;
    v15 = v14 >> 3;
    v16 = (v14 >> 3) + 1;
    if (v16 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v17 = v10 - (_QWORD)v13;
    if (v17 >> 2 > v16)
      v16 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v16;
    if (v18)
    {
      if (v18 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v19 = operator new(8 * v18);
      v20 = (uint64_t *)&v19[8 * v15];
      v21 = (uint64_t *)&v19[8 * v18];
      *v20 = v7;
      v12 = (uint64_t)(v20 + 1);
      v22 = (char *)((char *)v11 - (char *)v13);
      if (v11 == v13)
        goto LABEL_27;
    }
    else
    {
      v19 = 0;
      v20 = (uint64_t *)(8 * v15);
      v21 = 0;
      *(_QWORD *)(8 * v15) = v7;
      v12 = 8 * v15 + 8;
      v22 = (char *)((char *)v11 - (char *)v13);
      if (v11 == v13)
      {
LABEL_27:
        *v9 = v20;
        v9[1] = (uint64_t *)v12;
        v9[2] = v21;
        if (v11)
          operator delete(v11);
        goto LABEL_29;
      }
    }
    v23 = (unint64_t)(v22 - 8);
    if (v23 < 0x58)
      goto LABEL_35;
    if ((unint64_t)((char *)v11 - v19 - v14) < 0x20)
      goto LABEL_35;
    v24 = (v23 >> 3) + 1;
    v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
    v26 = &v11[v25 / 0xFFFFFFFFFFFFFFF8];
    v20 = (uint64_t *)((char *)v20 - v25);
    v27 = &v19[8 * v15 - 16];
    v28 = v11 - 2;
    v29 = v24 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v30 = *(_OWORD *)v28;
      *(v27 - 1) = *((_OWORD *)v28 - 1);
      *v27 = v30;
      v27 -= 2;
      v28 -= 4;
      v29 -= 4;
    }
    while (v29);
    v11 = v26;
    if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_35:
      do
      {
        v31 = *--v11;
        *--v20 = v31;
      }
      while (v11 != v13);
    }
    v11 = *v9;
    goto LABEL_27;
  }
  v7 = *v5;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
}

_QWORD *HGLUTCacheManager::HGLUTCacheManager(_QWORD *result, uint64_t a2)
{
  result[3] = 0;
  result[2] = 0;
  *result = a2;
  result[1] = result + 2;
  return result;
}

void HGLUTCacheManager::clear(HGLUTCacheManager *this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  BOOL v12;

  while (*((_QWORD *)this + 3))
  {
    v3 = (uint64_t *)*((_QWORD *)this + 1);
    v4 = v3[5];
    if (v4)
    {
LABEL_5:
      v5 = *(_QWORD *)(v4 + 8);
      v6 = *(_QWORD **)v5;
      while (1)
      {
        v7 = *(_QWORD **)(v5 + 8);
        if (v6 == v7)
          break;
        v8 = *(v7 - 1);
        *(_QWORD *)(v5 + 8) = v7 - 1;
        if (v8)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
          goto LABEL_5;
        }
      }
      if (v6)
      {
        *(_QWORD *)(v5 + 8) = v6;
        operator delete(v6);
      }
      MEMORY[0x1B5E29170](v5, 0x80C40D6874129);
      MEMORY[0x1B5E29170](v4, 0x20C40960023A9);
    }
    v9 = (uint64_t *)v3[1];
    v10 = v3;
    if (v9)
    {
      do
      {
        v11 = v9;
        v9 = (uint64_t *)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        v11 = (uint64_t *)v10[2];
        v12 = *v11 == (_QWORD)v10;
        v10 = v11;
      }
      while (!v12);
    }
    if (*((uint64_t **)this + 1) == v3)
      *((_QWORD *)this + 1) = v11;
    v2 = (uint64_t *)*((_QWORD *)this + 2);
    --*((_QWORD *)this + 3);
    std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v2, v3);
    operator delete(v3);
  }
}

void HGLUTCacheManager::~HGLUTCacheManager(HGLUTCacheManager *this)
{
  HGLUTCacheManager::clear(this);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 8, *((_QWORD **)this + 2));
}

uint64_t HGLUTCacheManager::getLUTCache(uint64_t a1, unint64_t a2)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t *v14;
  _QWORD *v15;
  uint64_t **v16;
  uint64_t **v17;
  uint64_t *v18;
  unint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v22;
  unint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t *v26;

  v5 = (uint64_t *)(a1 + 16);
  v4 = *(uint64_t **)(a1 + 16);
  v6 = (uint64_t **)(a1 + 16);
  v7 = (uint64_t **)(a1 + 16);
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v4;
        v8 = v4[4];
        if (v8 <= a2)
          break;
        v4 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_8;
      }
      if (v8 >= a2)
        break;
      v4 = v7[1];
      if (!v4)
      {
        v6 = v7 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x30uLL);
    v7[4] = (uint64_t *)a2;
    v7[5] = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = **(_QWORD **)(a1 + 8);
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *(_QWORD *)(a1 + 8) = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 16), v11);
    ++*(_QWORD *)(a1 + 24);
  }
  if (v7[5])
  {
    v12 = (uint64_t *)*v5;
    v13 = v5;
    if (*v5)
      goto LABEL_27;
LABEL_31:
    v24 = v13;
    v13 = (uint64_t *)operator new(0x30uLL);
    v13[4] = a2;
    v13[5] = 0;
    *v13 = 0;
    v13[1] = 0;
    v13[2] = (uint64_t)v24;
    *v5 = (uint64_t)v13;
    v25 = **(_QWORD **)(a1 + 8);
    v26 = v13;
    if (v25)
    {
      *(_QWORD *)(a1 + 8) = v25;
      v26 = (uint64_t *)*v5;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 16), v26);
    ++*(_QWORD *)(a1 + 24);
    return v13[5];
  }
  v14 = (uint64_t *)operator new();
  *v14 = *(_QWORD *)a1;
  v14[2] = a2;
  v15 = (_QWORD *)operator new();
  *v15 = 0;
  v15[1] = 0;
  v15[2] = 0;
  v14[1] = (uint64_t)v15;
  v16 = (uint64_t **)v5;
  v17 = (uint64_t **)v5;
  v18 = (uint64_t *)*v5;
  if (*v5)
  {
    while (1)
    {
      while (1)
      {
        v17 = (uint64_t **)v18;
        v19 = v18[4];
        if (v19 <= a2)
          break;
        v18 = *v17;
        v16 = v17;
        if (!*v17)
          goto LABEL_21;
      }
      if (v19 >= a2)
        break;
      v18 = v17[1];
      if (!v18)
      {
        v16 = v17 + 1;
        goto LABEL_21;
      }
    }
  }
  else
  {
LABEL_21:
    v20 = (uint64_t *)v17;
    v17 = (uint64_t **)operator new(0x30uLL);
    v17[4] = (uint64_t *)a2;
    v17[5] = 0;
    *v17 = 0;
    v17[1] = 0;
    v17[2] = v20;
    *v16 = (uint64_t *)v17;
    v21 = **(_QWORD **)(a1 + 8);
    v22 = (uint64_t *)v17;
    if (v21)
    {
      *(_QWORD *)(a1 + 8) = v21;
      v22 = *v16;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 16), v22);
    ++*(_QWORD *)(a1 + 24);
  }
  v17[5] = v14;
  v12 = (uint64_t *)*v5;
  v13 = v5;
  if (!*v5)
    goto LABEL_31;
  while (1)
  {
LABEL_27:
    while (1)
    {
      v13 = v12;
      v23 = v12[4];
      if (v23 <= a2)
        break;
      v12 = (uint64_t *)*v13;
      v5 = v13;
      if (!*v13)
        goto LABEL_31;
    }
    if (v23 >= a2)
      return v13[5];
    v12 = (uint64_t *)v13[1];
    if (!v12)
    {
      v5 = v13 + 1;
      goto LABEL_31;
    }
  }
}

void sub_1B2A5FDCC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x20C40960023A9);
  _Unwind_Resume(a1);
}

void HGGradientLinear::HGGradientLinear(HGGradientLinear *this)
{
  uint64_t v2;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v2 = off_1E6524BE0;
  *(_QWORD *)(v2 + 416) = 0;
  HGNode::SetFlags((HGNode *)v2, 0, 5);
  *((_DWORD *)this + 4) |= 0x621u;
  *((_DWORD *)this + 102) = 3;
}

void sub_1B2A5FE48(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 416);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGGradientLinear::~HGGradientLinear(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6524BE0;
  v2 = *((_QWORD *)this + 52);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6524BE0;
  v2 = *((_QWORD *)this + 52);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGGradientLinear::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGNode *Input;
  uint64_t DOD;
  uint64_t v6;
  __n128 v7;
  __n128 v8;
  __n128 v9;
  _BOOL4 v10;
  int v11;
  uint64_t v13;
  uint64_t v14;
  HGTextureWrap *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  HGNode *v19;
  HGNode *v20;
  float v21;
  int32x2_t v22;
  int v23;
  uint64_t v24;
  HgcGradientLinearIdentity *v25;
  HgcGradientLinearIdentity *v26;
  _QWORD *v27;
  uint64_t v28;
  float v30;
  float v31;
  float v32;
  float v33;
  int32x4_t v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39[4];
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  HGRect v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  Input = HGRenderer::GetInput(a2, this, 0);
  if (!(*(unsigned int (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2)
    || (DOD = HGRenderer::GetDOD(a2, Input), (HIDWORD(v6) - HIDWORD(DOD)) > 1))
  {
    (*(void (**)(HGNode *, uint64_t, HGRect *))(*(_QWORD *)this + 104))(this, 3, &v46);
    (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 4, &v43);
    (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 5, &v40);
    v10 = *(float *)&v46.var0 == 1.0;
    if (*(float *)&v46.var1 != 0.0)
      v10 = 0;
    v9.n128_f32[0] = v40;
    v8.n128_f32[0] = v41;
    v7.n128_f32[0] = v42;
    if (v10
      && *(float *)&v46.var3 == 0.0
      && v43 == 0.0
      && v44 == 1.0
      && v45 == 0.0
      && v40 == 0.0
      && v41 == 0.0
      && v42 == 1.0)
    {
      v11 = 0;
LABEL_33:
      *((_DWORD *)this + 102) = v11;
      (*(void (**)(HGNode *, _QWORD, float *, __n128, __n128, __n128))(*(_QWORD *)this + 104))(this, 0, v39, v7, v8, v9);
      (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 1, &v35);
      (*(void (**)(HGNode *, uint64_t, int32x4_t *))(*(_QWORD *)this + 104))(this, 2, &v34);
      v21 = (float)(v39[0] * *(float *)v34.i32) - (float)(v35 * v39[0]);
      *(float *)v22.i32 = 1.0
                        / (float)((float)((float)((float)(v21 * v21)
                                                + (float)((float)(*(float *)&v34.i32[1] - v36)
                                                        * (float)(*(float *)&v34.i32[1] - v36)))
                                        + (float)((float)(*(float *)&v34.i32[2] - v37)
                                                * (float)(*(float *)&v34.i32[2] - v37)))
                                + (float)((float)(*(float *)&v34.i32[3] - v38) * (float)(*(float *)&v34.i32[3] - v38)));
      v39[0] = v35 * v39[0];
      v39[1] = v36;
      v39[2] = v37;
      v39[3] = v38;
      v35 = v21;
      v36 = *(float *)&v34.i32[1] - v36;
      v37 = *(float *)&v34.i32[2] - v37;
      v38 = *(float *)&v34.i32[3] - v38;
      v34 = vdupq_lane_s32(v22, 0);
      (*(void (**)(HGNode *, _QWORD))(*(_QWORD *)this + 96))(this, 0);
      (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)this + 96))(this, 1, v35, v36, v37, v38);
      (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)this + 96))(this, 2, *(float *)v34.i32, *(float *)&v34.i32[1], *(float *)&v34.i32[2], *(float *)((unint64_t)&v34 | 0xC));
      v23 = *((_DWORD *)this + 102) - 1;
      if (v23 > 2)
        v24 = 3;
      else
        v24 = dword_1B3522188[v23];
      (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)this + 96))(this, v24, 0.99708, 0.001462, 0.0, 0.0);
      switch(*((_DWORD *)this + 102))
      {
        case 0:
          v25 = (HgcGradientLinearIdentity *)HGObject::operator new(0x1A0uLL);
          HgcGradientLinearIdentity::HgcGradientLinearIdentity(v25);
          v26 = (HgcGradientLinearIdentity *)*((_QWORD *)this + 52);
          if (v26 != v25)
          {
            if (!v26)
              goto LABEL_49;
            goto LABEL_48;
          }
          if (v25)
            goto LABEL_61;
          break;
        case 1:
          v25 = (HgcGradientLinearIdentity *)HGObject::operator new(0x1A0uLL);
          HgcGradientLinearTranslate::HgcGradientLinearTranslate(v25);
          v26 = (HgcGradientLinearIdentity *)*((_QWORD *)this + 52);
          if (v26 != v25)
          {
            if (!v26)
              goto LABEL_49;
            goto LABEL_48;
          }
          if (v25)
            goto LABEL_61;
          break;
        case 2:
          v25 = (HgcGradientLinearIdentity *)HGObject::operator new(0x1A0uLL);
          HgcGradientLinearAffine::HgcGradientLinearAffine(v25);
          v26 = (HgcGradientLinearIdentity *)*((_QWORD *)this + 52);
          if (v26 != v25)
          {
            if (!v26)
              goto LABEL_49;
            goto LABEL_48;
          }
          if (v25)
            goto LABEL_61;
          break;
        case 3:
          v25 = (HgcGradientLinearIdentity *)HGObject::operator new(0x1A0uLL);
          HgcGradientLinearPerspective::HgcGradientLinearPerspective(v25);
          v26 = (HgcGradientLinearIdentity *)*((_QWORD *)this + 52);
          if (v26 == v25)
          {
            if (v25)
LABEL_61:
              (*(void (**)(HgcGradientLinearIdentity *))(*(_QWORD *)v25 + 24))(v25);
          }
          else
          {
            if (v26)
LABEL_48:
              (*(void (**)(HgcGradientLinearIdentity *))(*(_QWORD *)v26 + 24))(v26);
LABEL_49:
            *((_QWORD *)this + 52) = v25;
          }
          break;
        default:
          break;
      }
      (*(void (**)(_QWORD, _QWORD, HGNode *))(**((_QWORD **)this + 52) + 120))(*((_QWORD *)this + 52), 0, Input);
      (*(void (**)(HGNode *, _QWORD, float *))(*(_QWORD *)this + 104))(this, 0, &v30);
      v27 = (_QWORD *)((char *)this + 416);
      (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 0, v30, v31, v32, v33);
      (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 1, &v30);
      (*(void (**)(_QWORD, uint64_t, float, float, float, float))(*(_QWORD *)*v27 + 96))(*v27, 1, v30, v31, v32, v33);
      (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 2, &v30);
      (*(void (**)(_QWORD, uint64_t, float, float, float, float))(*(_QWORD *)*v27 + 96))(*v27, 2, v30, v31, v32, v33);
      (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 3, &v30);
      (*(void (**)(_QWORD, uint64_t, float, float, float, float))(*(_QWORD *)*v27 + 96))(*v27, 3, v30, v31, v32, v33);
      (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 4, &v30);
      (*(void (**)(_QWORD, uint64_t, float, float, float, float))(*(_QWORD *)*v27 + 96))(*v27, 4, v30, v31, v32, v33);
      (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 5, &v30);
      (*(void (**)(_QWORD, uint64_t, float, float, float, float))(*(_QWORD *)*v27 + 96))(*v27, 5, v30, v31, v32, v33);
      (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 6, &v30);
      (*(void (**)(_QWORD, uint64_t, float, float, float, float))(*(_QWORD *)*v27 + 96))(*v27, 6, v30, v31, v32, v33);
      return *((_QWORD *)this + 52);
    }
    if (v43 != 0.0)
      v10 = 0;
    if (v10 && v44 == 1.0)
    {
      if (v40 != 0.0)
        goto LABEL_32;
      if (v41 == 0.0 && v42 == 1.0)
      {
        v11 = 1;
        goto LABEL_33;
      }
    }
    if (v40 == 0.0 && v41 == 0.0)
    {
      v8.n128_u32[0] = 1.0;
      if (v42 == 1.0)
      {
        v11 = 2;
        goto LABEL_33;
      }
    }
LABEL_32:
    v11 = 3;
    goto LABEL_33;
  }
  v13 = DOD;
  v14 = v6;
  v15 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v15);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v15, (const char *)3, v16);
  v17 = HGRectMake4i(0, 0, 0, 1u);
  *(_QWORD *)&v46.var0 = HGRectGrow(v13, v14, v17);
  *(_QWORD *)&v46.var2 = v18;
  HGTextureWrap::SetCropRect(v15, &v46);
  (*(void (**)(HGTextureWrap *, _QWORD, HGNode *))(*(_QWORD *)v15 + 120))(v15, 0, Input);
  v19 = (HGNode *)HGObject::operator new(0x1B0uLL);
  HGNode::HGNode(v19);
  *(_QWORD *)v19 = off_1E6524BE0;
  *((_QWORD *)v19 + 52) = 0;
  HGNode::SetFlags(v19, 0, 5);
  *((_DWORD *)v19 + 4) |= 0x621u;
  *((_DWORD *)v19 + 102) = 3;
  v20 = (HGNode *)*((_QWORD *)this + 52);
  if (v20 == v19)
  {
    (*(void (**)(HGNode *))(*(_QWORD *)v19 + 24))(v19);
    v19 = (HGNode *)*((_QWORD *)this + 52);
  }
  else
  {
    if (v20)
      (*(void (**)(HGNode *))(*(_QWORD *)v20 + 24))(v20);
    *((_QWORD *)this + 52) = v19;
  }
  (*(void (**)(HGNode *, _QWORD, HGTextureWrap *))(*(_QWORD *)v19 + 120))(v19, 0, v15);
  (*(void (**)(HGNode *, _QWORD, HGRect *))(*(_QWORD *)this + 104))(this, 0, &v46);
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 0, *(float *)&v46.var0, *(float *)&v46.var1, *(float *)&v46.var2, *(float *)&v46.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(_QWORD *)this + 104))(this, 1, &v46);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 1, *(float *)&v46.var0, *(float *)&v46.var1, *(float *)&v46.var2, *(float *)&v46.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(_QWORD *)this + 104))(this, 2, &v46);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 2, *(float *)&v46.var0, *(float *)&v46.var1, *(float *)&v46.var2, *(float *)&v46.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(_QWORD *)this + 104))(this, 3, &v46);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 3, *(float *)&v46.var0, *(float *)&v46.var1, *(float *)&v46.var2, *(float *)&v46.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(_QWORD *)this + 104))(this, 4, &v46);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 4, *(float *)&v46.var0, *(float *)&v46.var1, *(float *)&v46.var2, *(float *)&v46.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(_QWORD *)this + 104))(this, 5, &v46);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 5, *(float *)&v46.var0, *(float *)&v46.var1, *(float *)&v46.var2, *(float *)&v46.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(_QWORD *)this + 104))(this, 6, &v46);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 6, *(float *)&v46.var0, *(float *)&v46.var1, *(float *)&v46.var2, *(float *)&v46.var3);
  v28 = *((_QWORD *)this + 52);
  (*(void (**)(HGTextureWrap *))(*(_QWORD *)v15 + 24))(v15);
  return v28;
}

void sub_1B2A607F0(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

const char *HGGradientLinear::label_B(HGGradientLinear *this)
{
  uint64_t v1;

  v1 = *((int *)this + 102);
  if (v1 > 2)
    return "kXFormPerspective";
  else
    return off_1E6524E38[v1];
}

void HGGradientLinear::info(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void HGMetalHandler::HGMetalHandler(HGMetalHandler *this, HGMetalContext *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  HGHandler::HGHandler(this);
  *v4 = &off_1E6524E60;
  if (a2)
    (*(void (**)(HGMetalContext *))(*(_QWORD *)a2 + 16))(a2);
  *((_QWORD *)this + 31) = a2;
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 33) = 0;
  *((_QWORD *)this + 34) = 0;
  *((_QWORD *)this + 35) = (char *)this + 288;
  *((_QWORD *)this + 36) = 0;
  *((_DWORD *)this + 122) = 0;
  *((_QWORD *)this + 38) = 0;
  *((_QWORD *)this + 39) = 0;
  *((_QWORD *)this + 37) = 0;
  *((_BYTE *)this + 320) = 0;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 508));
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 540));
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 572));
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 604));
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 636));
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 668));
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 700));
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 732));
  bzero((char *)this + 752, 0x270uLL);
  *((_DWORD *)this + 350) = 1;
  *((_QWORD *)this + 183) = 0;
  *((_OWORD *)this + 88) = 0u;
  *((_OWORD *)this + 89) = 0u;
  *((_OWORD *)this + 90) = 0u;
  *((_BYTE *)this + 1456) = 0;
  *((_QWORD *)this + 184) = 1;
  *((_DWORD *)this + 370) = 1;
  *(_OWORD *)((char *)this + 1484) = 0u;
  *((_DWORD *)this + 375) = 0;
  *((_QWORD *)this + 188) = 1;
  *((_DWORD *)this + 378) = 1;
  *(_OWORD *)((char *)this + 1516) = 0u;
  *((_DWORD *)this + 383) = 0;
  *((_QWORD *)this + 192) = 1;
  *((_DWORD *)this + 386) = 1;
  *((_DWORD *)this + 391) = 0;
  *(_OWORD *)((char *)this + 1548) = 0u;
  *((_QWORD *)this + 196) = 1;
  *((_DWORD *)this + 394) = 1;
  *((_DWORD *)this + 399) = 0;
  *(_OWORD *)((char *)this + 1580) = 0u;
  *((_QWORD *)this + 200) = 1;
  *((_DWORD *)this + 402) = 1;
  *((_DWORD *)this + 407) = 0;
  *(_OWORD *)((char *)this + 1612) = 0u;
  *((_QWORD *)this + 204) = 1;
  *((_DWORD *)this + 410) = 1;
  *((_DWORD *)this + 415) = 0;
  *(_OWORD *)((char *)this + 1644) = 0u;
  *((_QWORD *)this + 208) = 1;
  *((_DWORD *)this + 418) = 1;
  *((_DWORD *)this + 423) = 0;
  *(_OWORD *)((char *)this + 1676) = 0u;
  *((_OWORD *)this + 106) = xmmword_1B309BAB0;
  *((_QWORD *)this + 214) = 0;
  *((_BYTE *)this + 1744) = 0;
  *((_DWORD *)this + 445) = 0;
  *(_OWORD *)((char *)this + 1764) = 0u;
  *((_WORD *)this + 892) = 257;
  *((_BYTE *)this + 1786) = 0;
  *((_OWORD *)this + 112) = 0u;
  *((_QWORD *)this + 226) = 850045863;
  *((_QWORD *)this + 233) = 0;
  *(_OWORD *)((char *)this + 1848) = 0u;
  *(_OWORD *)((char *)this + 1832) = 0u;
  *(_OWORD *)((char *)this + 1816) = 0u;
  *((_QWORD *)this + 234) = 1018212795;
  *((_QWORD *)this + 239) = 0;
  *(_OWORD *)((char *)this + 1896) = 0u;
  *(_OWORD *)((char *)this + 1880) = 0u;
  v5 = (_QWORD *)operator new();
  *v5 = 0;
  v5[1] = 0;
  v5[2] = 0;
  *((_QWORD *)this + 34) = v5;
  v6 = operator new();
  *(_QWORD *)(v6 + 240) = 0;
  *(_OWORD *)(v6 + 208) = 0u;
  *(_OWORD *)(v6 + 224) = 0u;
  *(_OWORD *)(v6 + 176) = 0u;
  *(_OWORD *)(v6 + 192) = 0u;
  *(_OWORD *)(v6 + 144) = 0u;
  *(_OWORD *)(v6 + 160) = 0u;
  *(_OWORD *)(v6 + 112) = 0u;
  *(_OWORD *)(v6 + 128) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_OWORD *)(v6 + 96) = 0u;
  *(_OWORD *)(v6 + 48) = 0u;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  *(_OWORD *)(v6 + 32) = 0u;
  *(_OWORD *)v6 = 0u;
  *((_QWORD *)this + 39) = v6;
}

void sub_1B2A60C04(_Unwind_Exception *a1, const PCString *a2)
{
  OZChannelBase *v2;

  OZChannelBase::setRangeName(v2, a2);
  _Unwind_Resume(a1);
}

void sub_1B2A60C18()
{
  uint64_t v0;
  std::condition_variable *v1;
  std::mutex *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  std::condition_variable::~condition_variable(v1);
  std::mutex::~mutex(v2);
  v4 = *(void **)(v0 + 1432);
  if (v4)
  {
    *(_QWORD *)(v0 + 1440) = v4;
    operator delete(v4);
    if ((*(char *)(v0 + 1367) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v0 + 1343) & 0x80000000) == 0)
        goto LABEL_4;
      goto LABEL_9;
    }
  }
  else if ((*(char *)(v0 + 1367) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(v0 + 1344));
  if ((*(char *)(v0 + 1343) & 0x80000000) == 0)
  {
LABEL_4:
    if ((*(char *)(v0 + 1319) & 0x80000000) == 0)
      goto LABEL_5;
    goto LABEL_10;
  }
LABEL_9:
  operator delete(*(void **)(v0 + 1320));
  if ((*(char *)(v0 + 1319) & 0x80000000) == 0)
  {
LABEL_5:
    v5 = *(_QWORD *)(v0 + 1288);
    if (!v5)
    {
LABEL_12:
      v6 = *(_QWORD *)(v0 + 464);
      if (v6)
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
      v7 = *(_QWORD *)(v0 + 456);
      if (v7)
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
      v8 = *(_QWORD *)(v0 + 448);
      if (v8)
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
      v9 = *(_QWORD *)(v0 + 440);
      if (v9)
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
      v10 = *(_QWORD *)(v0 + 432);
      if (v10)
        (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
      v11 = *(_QWORD *)(v0 + 424);
      if (v11)
        (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
      v12 = *(_QWORD *)(v0 + 416);
      if (v12)
        (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
      v13 = *(_QWORD *)(v0 + 408);
      if (v13)
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
      v14 = *(_QWORD *)(v0 + 400);
      if (v14)
        (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
      v15 = *(_QWORD *)(v0 + 392);
      if (v15)
        (*(void (**)(uint64_t))(*(_QWORD *)v15 + 24))(v15);
      v16 = *(_QWORD *)(v0 + 384);
      if (v16)
        (*(void (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
      v17 = *(_QWORD *)(v0 + 376);
      if (v17)
        (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
      v18 = *(_QWORD *)(v0 + 368);
      if (v18)
        (*(void (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
      v19 = *(_QWORD *)(v0 + 360);
      if (v19)
        (*(void (**)(uint64_t))(*(_QWORD *)v19 + 24))(v19);
      v20 = *(_QWORD *)(v0 + 352);
      if (v20)
        (*(void (**)(uint64_t))(*(_QWORD *)v20 + 24))(v20);
      v21 = *(_QWORD *)(v0 + 344);
      if (v21)
        (*(void (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
      v22 = *(_QWORD *)(v0 + 336);
      if (v22)
        (*(void (**)(uint64_t))(*(_QWORD *)v22 + 24))(v22);
      if (*v3)
        (*(void (**)(_QWORD))(*(_QWORD *)*v3 + 24))(*v3);
      std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v0 + 280, *(_QWORD **)(v0 + 288));
      v23 = *(_QWORD *)(v0 + 248);
      if (v23)
        (*(void (**)(uint64_t))(*(_QWORD *)v23 + 24))(v23);
      JUMPOUT(0x1B2A60C08);
    }
LABEL_11:
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    goto LABEL_12;
  }
LABEL_10:
  operator delete(*(void **)(v0 + 1296));
  v5 = *(_QWORD *)(v0 + 1288);
  if (!v5)
    goto LABEL_12;
  goto LABEL_11;
}

void HGMetalHandler::~HGMetalHandler(HGMetalHandler *this)
{
  HGMetalHandler::CommandEncoderCargo *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  id *v9;
  id *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const PCString *v31;
  uint64_t v32;

  *(_QWORD *)this = &off_1E6524E60;
  v2 = (HGMetalHandler::CommandEncoderCargo *)*((_QWORD *)this + 39);
  if (v2)
  {
    HGMetalHandler::CommandEncoderCargo::~CommandEncoderCargo(v2);
    MEMORY[0x1B5E29170]();
  }
  v3 = *((_QWORD *)this + 34);
  if (v3)
  {
    v4 = *(void **)v3;
    if (*(_QWORD *)v3)
    {
      *(_QWORD *)(v3 + 8) = v4;
      operator delete(v4);
    }
    MEMORY[0x1B5E29170](v3, 0x80C40D6874129);
  }
  v5 = (void *)*((_QWORD *)this + 159);
  if (v5)
    free(v5);
  v6 = (void *)*((_QWORD *)this + 176);
  if (v6)

  *((_QWORD *)this + 176) = 0;
  v7 = (void *)*((_QWORD *)this + 177);
  if (v7)

  *((_QWORD *)this + 177) = 0;
  v8 = (void *)*((_QWORD *)this + 178);
  if (v8)

  *((_QWORD *)this + 178) = 0;
  v9 = (id *)*((_QWORD *)this + 179);
  v10 = (id *)*((_QWORD *)this + 180);
  if (v9 != v10)
  {
    do

    while (v9 != v10);
    v9 = (id *)*((_QWORD *)this + 179);
  }
  *((_QWORD *)this + 180) = v9;
  std::condition_variable::~condition_variable((std::condition_variable *)this + 39);
  std::mutex::~mutex((std::mutex *)((char *)this + 1808));
  v11 = (void *)*((_QWORD *)this + 179);
  if (v11)
  {
    *((_QWORD *)this + 180) = v11;
    operator delete(v11);
  }
  if (*((char *)this + 1367) < 0)
  {
    operator delete(*((void **)this + 168));
    if ((*((char *)this + 1343) & 0x80000000) == 0)
    {
LABEL_22:
      if ((*((char *)this + 1319) & 0x80000000) == 0)
        goto LABEL_23;
LABEL_27:
      operator delete(*((void **)this + 162));
      v12 = *((_QWORD *)this + 161);
      if (!v12)
        goto LABEL_29;
      goto LABEL_28;
    }
  }
  else if ((*((char *)this + 1343) & 0x80000000) == 0)
  {
    goto LABEL_22;
  }
  operator delete(*((void **)this + 165));
  if (*((char *)this + 1319) < 0)
    goto LABEL_27;
LABEL_23:
  v12 = *((_QWORD *)this + 161);
  if (v12)
LABEL_28:
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
LABEL_29:
  v13 = *((_QWORD *)this + 58);
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
  v14 = *((_QWORD *)this + 57);
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
  v15 = *((_QWORD *)this + 56);
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 24))(v15);
  v16 = *((_QWORD *)this + 55);
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
  v17 = *((_QWORD *)this + 54);
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
  v18 = *((_QWORD *)this + 53);
  if (v18)
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
  v19 = *((_QWORD *)this + 52);
  if (v19)
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 24))(v19);
  v20 = *((_QWORD *)this + 51);
  if (v20)
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 24))(v20);
  v21 = *((_QWORD *)this + 50);
  if (v21)
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
  v22 = *((_QWORD *)this + 49);
  if (v22)
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 24))(v22);
  v23 = *((_QWORD *)this + 48);
  if (v23)
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 24))(v23);
  v24 = *((_QWORD *)this + 47);
  if (v24)
    (*(void (**)(uint64_t))(*(_QWORD *)v24 + 24))(v24);
  v25 = *((_QWORD *)this + 46);
  if (v25)
    (*(void (**)(uint64_t))(*(_QWORD *)v25 + 24))(v25);
  v26 = *((_QWORD *)this + 45);
  if (v26)
    (*(void (**)(uint64_t))(*(_QWORD *)v26 + 24))(v26);
  v27 = *((_QWORD *)this + 44);
  if (v27)
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 24))(v27);
  v28 = *((_QWORD *)this + 43);
  if (v28)
    (*(void (**)(uint64_t))(*(_QWORD *)v28 + 24))(v28);
  v29 = *((_QWORD *)this + 42);
  if (v29)
    (*(void (**)(uint64_t))(*(_QWORD *)v29 + 24))(v29);
  v30 = *((_QWORD *)this + 41);
  if (v30)
    (*(void (**)(uint64_t))(*(_QWORD *)v30 + 24))(v30);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 280, *((_QWORD **)this + 36));
  v32 = *((_QWORD *)this + 31);
  if (v32)
    (*(void (**)(uint64_t))(*(_QWORD *)v32 + 24))(v32);
  OZChannelBase::setRangeName((OZChannelBase *)this, v31);
}

{
  HGMetalHandler::~HGMetalHandler(this);
  JUMPOUT(0x1B5E29170);
}

HGBitmap *HGMetalHandler::BindBuffer(HGMetalHandler *this, HGBitmap *a2)
{
  HGMetalHandler::BindBuffer(this, 0, a2, (const char *)1);
  HGMetalHandler::BindBuffer(this, 1, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 2, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 3, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 4, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 5, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 6, 0, (const char *)1);
  return HGMetalHandler::BindBuffer(this, 7, 0, (const char *)1);
}

HGBitmap *HGMetalHandler::BindBuffer(HGMetalHandler *this, HGBitmap *a2, const char *a3)
{
  HGMetalHandler::BindBuffer(this, 0, a2, a3);
  HGMetalHandler::BindBuffer(this, 1, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 2, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 3, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 4, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 5, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 6, 0, (const char *)1);
  return HGMetalHandler::BindBuffer(this, 7, 0, (const char *)1);
}

HGBitmap *HGMetalHandler::BindBuffer(HGMetalHandler *this, int a2, HGBitmap *a3, const char *a4)
{
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  HGMetalDeviceInfo *LUTEnd;
  char *v24;
  HGBitmap *result;
  int v26;
  HGBitmap **v27;
  HGBitmap **v28;
  HGBitmap *v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t *v32;
  HGBitmap *v33;
  uint64_t *v34;
  uint64_t v35;
  const char *v36;
  char *v37;
  HGBitmap *NodeMetalTexture;
  float32x2_t v39;
  float32x2_t v40;
  float32x2_t v41;
  float32x2_t v42;
  float32x2_t v48;
  unsigned int v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  HGMetalContext *v53;
  void *v54;
  uint64_t *v55;
  char *TextureRect;
  uint64_t v57;
  HGBitmap *v58;
  uint64_t v59;
  HGBitmap *v60;
  uint64_t v61;
  uint64_t v62;
  HGRect v63;

  v8 = (_QWORD *)*((_QWORD *)this + 39);
  v9 = v8;
  if (*v8)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)*v8 + 24))(*v8);
    v9 = (_QWORD *)*((_QWORD *)this + 39);
  }
  *v8 = 0;
  v10 = v9[1];
  v11 = v9;
  if (v10)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
    v11 = (_QWORD *)*((_QWORD *)this + 39);
  }
  v9[1] = 0;
  v12 = v11[2];
  v13 = v11;
  if (v12)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
    v13 = (_QWORD *)*((_QWORD *)this + 39);
  }
  v11[2] = 0;
  v14 = v13[3];
  v15 = v13;
  if (v14)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
    v15 = (_QWORD *)*((_QWORD *)this + 39);
  }
  v13[3] = 0;
  v16 = v15[4];
  v17 = v15;
  if (v16)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
    v17 = (_QWORD *)*((_QWORD *)this + 39);
  }
  v15[4] = 0;
  v18 = v17[5];
  v19 = v17;
  if (v18)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
    v19 = (_QWORD *)*((_QWORD *)this + 39);
  }
  v17[5] = 0;
  v20 = v19[6];
  v21 = v19;
  if (v20)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 24))(v20);
    v21 = (_QWORD *)*((_QWORD *)this + 39);
  }
  v19[6] = 0;
  v22 = v21[7];
  if (v22)
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 24))(v22);
  v21[7] = 0;
  if (a3)
  {
    LUTEnd = (HGMetalDeviceInfo *)PCICCTransferFunctionLUT::getLUTEnd(*((PCICCTransferFunctionLUT **)this + 31));
    result = (HGBitmap *)HGMetalDeviceInfo::validateTextureSampleCount(LUTEnd, a4, v24);
    v26 = (int)result;
    v27 = (HGBitmap **)((char *)this + 8 * a2);
    if (v27[41] != a3 || (_DWORD)result != *((_DWORD *)this + 118))
    {
      v28 = v27 + 41;
      HGMetalHandler::FinalizeCommandEncoder(this, *(_DWORD *)(*((_QWORD *)this + 31) + 64), *(_QWORD *)(*((_QWORD *)this + 31) + 72), *(_QWORD *)(*((_QWORD *)this + 31) + 88));
      *((_DWORD *)this + 118) = v26;
      (*(void (**)(HGBitmap *))(*(_QWORD *)a3 + 16))(a3);
      v29 = *v28;
      if (*v28 == a3)
      {
        (*(void (**)(HGBitmap *))(*(_QWORD *)a3 + 24))(a3);
      }
      else
      {
        if (v29)
          (*(void (**)(HGBitmap *))(*(_QWORD *)v29 + 24))(v29);
        *v28 = a3;
      }
      v33 = HGGPURenderer::ConvertToMetalTexture(*((HGMetalTexture ***)this + 18), a3);
      v34 = (uint64_t *)((char *)this + 8 * a2 + 392);
      v35 = *v34;
      if ((HGBitmap *)*v34 == v33)
      {
        if (v33)
          (*(void (**)(HGBitmap *))(*(_QWORD *)v33 + 24))(v33);
      }
      else
      {
        if (v35)
          (*(void (**)(uint64_t))(*(_QWORD *)v35 + 24))(v35);
        *v34 = (uint64_t)v33;
      }
      *(_QWORD *)&v63.var0 = 0;
      *(_QWORD *)&v63.var2 = 0;
      NodeMetalTexture = HGGPURenderer::GetNodeMetalTexture(*((HGGPURenderer **)this + 18), 0, v63, 0, 1u);
      result = (HGBitmap *)*v34;
      if (!*v34 || result == NodeMetalTexture)
      {
        if (*v28)
        {
          (*(void (**)(HGBitmap *))(*(_QWORD *)*v28 + 24))(*v28);
          result = (HGBitmap *)*v34;
        }
        *v28 = 0;
        if (result)
          (*(void (**)(HGBitmap *))(*(_QWORD *)result + 24))(result);
        *v34 = 0;
        *((_BYTE *)this + 1785) = 0;
        result = (HGBitmap *)HGLogger::warning((HGLogger *)"HGMetalHandler::BindBuffer -- null buffer target!!", v36, v37);
      }
      else
      {
        v39 = vcvt_f32_s32(*(int32x2_t *)((char *)result + 28));
        v40 = vcvt_f32_s32(*(int32x2_t *)((char *)result + 20));
        v41 = (float32x2_t)__PAIR64__(v39.u32[1], v40.u32[0]);
        v42 = vadd_f32(v39, v40);
        v39.i32[1] = v40.i32[1];
        __asm { FMOV            V1.2S, #1.0 }
        v48 = vdiv_f32(_D1, vsub_f32(v39, v41));
        v41.i32[0] = 0;
        *(float *)&v49 = v48.f32[0] + v48.f32[0];
        v41.f32[1] = v48.f32[1] + v48.f32[1];
        *(float32x2_t *)&v50 = vmul_f32(v42, vneg_f32(v48));
        *((_QWORD *)&v50 + 1) = 0x3F8000003F000000;
        *((_OWORD *)this + 5) = v49;
        *((_OWORD *)this + 6) = (unint64_t)v41;
        *((_OWORD *)this + 7) = xmmword_1B35221A0;
        *((_OWORD *)this + 8) = v50;
      }
      if (*((_BYTE *)this + 1785) && *((_DWORD *)this + 118) >= 2u)
      {
        v51 = *((_QWORD *)this + 58);
        v52 = *((_QWORD *)this + 49);
        if (v51 != v52)
        {
          if (v51)
          {
            (*(void (**)(_QWORD))(*(_QWORD *)v51 + 24))(*((_QWORD *)this + 58));
            v52 = *((_QWORD *)this + 49);
          }
          *((_QWORD *)this + 58) = v52;
          if (v52)
            (*(void (**)(uint64_t))(*(_QWORD *)v52 + 16))(v52);
        }
        v53 = (HGMetalContext *)*((_QWORD *)this + 31);
        v54 = *(void **)(*((_QWORD *)v53 + 2) + 16);
        v55 = (uint64_t *)HGMetalContext::texturePool(v53);
        TextureRect = (char *)HGMetalTexture::GetTextureRect(*((HGMetalTexture **)this + 58));
        HGMetalTexture::createMSAA(v54, v55, TextureRect, v57, *(_DWORD *)(*((_QWORD *)this + 58) + 16), *((_DWORD *)this + 118), &v62);
        v58 = *v28;
        v59 = v62;
        if (*v28 != (HGBitmap *)v62)
        {
          if (v58)
          {
            (*(void (**)(HGBitmap *))(*(_QWORD *)v58 + 24))(*v28);
            v59 = v62;
          }
          *v28 = (HGBitmap *)v59;
          if (v59)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v59 + 16))(v59);
            v58 = (HGBitmap *)v62;
          }
          else
          {
            v58 = 0;
          }
        }
        v60 = HGGPURenderer::ConvertToMetalTexture(*((HGMetalTexture ***)this + 18), v58);
        v61 = *v34;
        if ((HGBitmap *)*v34 == v60)
        {
          if (v60)
            (*(void (**)(HGBitmap *))(*(_QWORD *)v60 + 24))(v60);
        }
        else
        {
          if (v61)
            (*(void (**)(uint64_t))(*(_QWORD *)v61 + 24))(v61);
          *v34 = (uint64_t)v60;
        }
        result = (HGBitmap *)v62;
        if (v62)
          result = (HGBitmap *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v62 + 24))(v62);
      }
      if (NodeMetalTexture)
        return (HGBitmap *)(*(uint64_t (**)(HGBitmap *))(*(_QWORD *)NodeMetalTexture + 24))(NodeMetalTexture);
    }
  }
  else
  {
    v30 = a2;
    v31 = (_QWORD *)((char *)this + 8 * a2 + 328);
    if (*v31)
      (*(void (**)(_QWORD))(*(_QWORD *)*v31 + 24))(*v31);
    *v31 = 0;
    v32 = (uint64_t *)((char *)this + 8 * v30 + 392);
    result = (HGBitmap *)*v32;
    if (*v32)
      result = (HGBitmap *)(*(uint64_t (**)(HGBitmap *))(*(_QWORD *)result + 24))(result);
    *v32 = 0;
  }
  return result;
}

void sub_1B2A617B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;
  uint64_t v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  _Unwind_Resume(exception_object);
}

__n128 HGMetalHandler::BindTexture(HGMetalTexture ***this, int a2, HGBitmap *a3)
{
  HGBitmap *v6;
  HGMetalTexture **v7;
  HGBitmap *v8;
  HGMetalTexture **v9;
  HGMetalTexture *v10;
  __n128 result;
  __n128 *EdgePolicy;
  HGMetalTexture ***v13;
  unsigned __int32 v14;
  HGRect v15;

  if (a3)
  {
    *(_QWORD *)&v15.var0 = *(_QWORD *)((char *)a3 + 20);
    *(_QWORD *)&v15.var2 = *(_QWORD *)((char *)a3 + 28);
    v6 = HGGPURenderer::ConvertToMetalTexture(this[18], v15, a3, 0);
    v7 = this[39];
    v8 = (HGBitmap *)v7[a2];
    if (v8 == v6)
    {
      if (v6)
        (*(void (**)(HGBitmap *))(*(_QWORD *)v6 + 24))(v6);
    }
    else
    {
      if (v8)
        (*(void (**)(HGBitmap *))(*(_QWORD *)v8 + 24))(v8);
      v7[a2] = (HGMetalTexture *)v6;
    }
    EdgePolicy = (__n128 *)HGBitmap::GetEdgePolicy(a3);
    v13 = &this[4 * a2];
    v14 = EdgePolicy[1].n128_u32[0];
    result = *EdgePolicy;
    *(__n128 *)((char *)v13 + 508) = *EdgePolicy;
    *((_DWORD *)v13 + 131) = v14;
  }
  else
  {
    v9 = this[39];
    v10 = v9[a2];
    if (v10)
      (*(void (**)(HGMetalTexture *))(*(_QWORD *)v10 + 24))(v10);
    v9[a2] = 0;
  }
  return result;
}

void sub_1B2A6195C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

HGMetalHandler *HGMetalHandler::Reset(HGMetalHandler *this, HGRenderer *a2)
{
  uint64_t v4;
  void *v5;
  size_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void **v10;
  void **v11;
  void *v12;
  __int128 v14;
  int v15;

  HGHandler::Reset((uint64_t)this, (uint64_t)a2);
  *((_DWORD *)this + 124) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 125) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_BYTE *)this + 504) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 508) = v14;
  *((_DWORD *)this + 131) = v15;
  *((_DWORD *)this + 132) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 133) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_BYTE *)this + 536) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 540) = v14;
  *((_DWORD *)this + 139) = v15;
  *((_DWORD *)this + 140) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 141) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_BYTE *)this + 568) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 572) = v14;
  *((_DWORD *)this + 147) = v15;
  *((_DWORD *)this + 148) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 149) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_BYTE *)this + 600) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 604) = v14;
  *((_DWORD *)this + 155) = v15;
  *((_DWORD *)this + 156) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 157) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_BYTE *)this + 632) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 636) = v14;
  *((_DWORD *)this + 163) = v15;
  *((_DWORD *)this + 164) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 165) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_BYTE *)this + 664) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 668) = v14;
  *((_DWORD *)this + 171) = v15;
  *((_DWORD *)this + 172) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 173) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_BYTE *)this + 696) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 700) = v14;
  *((_DWORD *)this + 179) = v15;
  *((_DWORD *)this + 180) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 181) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  *((_BYTE *)this + 728) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 732) = v14;
  *((_DWORD *)this + 187) = v15;
  v4 = *((_QWORD *)this + 58);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
    *((_QWORD *)this + 58) = 0;
  }
  *((_DWORD *)this + 118) = 1;
  *(_QWORD *)((char *)this + 484) = 0;
  *(_QWORD *)((char *)this + 476) = 0;
  v5 = (void *)*((_QWORD *)this + 159);
  if (v5)
  {
    v6 = *((_QWORD *)this + 158);
    if (v6)
      bzero(v5, v6);
  }
  v7 = *((_QWORD *)this + 161);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  *((_QWORD *)this + 161) = 0;
  *((_QWORD *)this + 158) = 0;
  *((_BYTE *)this + 492) = 0;
  v8 = (void *)*((_QWORD *)this + 177);
  if (v8)

  *((_QWORD *)this + 177) = 0;
  v9 = (void *)*((_QWORD *)this + 178);
  if (v9)

  *((_QWORD *)this + 178) = 0;
  v10 = (void **)*((_QWORD *)this + 179);
  v11 = (void **)*((_QWORD *)this + 180);
  if (v10 != v11)
  {
    do
    {
      v12 = *v10++;

    }
    while (v10 != v11);
    v10 = (void **)*((_QWORD *)this + 179);
  }
  *((_QWORD *)this + 180) = v10;
  *((_OWORD *)this + 47) = xmmword_1B304F230;
  *((_OWORD *)this + 48) = xmmword_1B304F240;
  *((_OWORD *)this + 49) = xmmword_1B304F250;
  *((_OWORD *)this + 50) = xmmword_1B304EFF0;
  *((_OWORD *)this + 51) = xmmword_1B304F230;
  *((_OWORD *)this + 52) = xmmword_1B304F240;
  *((_OWORD *)this + 53) = xmmword_1B304F250;
  *((_OWORD *)this + 54) = xmmword_1B304EFF0;
  *((_OWORD *)this + 55) = xmmword_1B304F230;
  *((_OWORD *)this + 56) = xmmword_1B304F240;
  *((_OWORD *)this + 57) = xmmword_1B304F250;
  *((_OWORD *)this + 58) = xmmword_1B304EFF0;
  *((_OWORD *)this + 59) = xmmword_1B304F230;
  *((_OWORD *)this + 60) = xmmword_1B304F240;
  *((_OWORD *)this + 61) = xmmword_1B304F250;
  *((_OWORD *)this + 62) = xmmword_1B304EFF0;
  *((_OWORD *)this + 63) = xmmword_1B304F230;
  *((_OWORD *)this + 64) = xmmword_1B304F240;
  *((_OWORD *)this + 65) = xmmword_1B304F250;
  *((_OWORD *)this + 66) = xmmword_1B304EFF0;
  *((_OWORD *)this + 67) = xmmword_1B304F230;
  *((_OWORD *)this + 68) = xmmword_1B304F240;
  *((_OWORD *)this + 69) = xmmword_1B304F250;
  *((_OWORD *)this + 70) = xmmword_1B304EFF0;
  *((_OWORD *)this + 71) = xmmword_1B304F230;
  *((_OWORD *)this + 72) = xmmword_1B304F240;
  *((_OWORD *)this + 73) = xmmword_1B304F250;
  *((_OWORD *)this + 74) = xmmword_1B304EFF0;
  *((_OWORD *)this + 75) = xmmword_1B304F230;
  *((_OWORD *)this + 76) = xmmword_1B304F240;
  *((_OWORD *)this + 77) = xmmword_1B304F250;
  *((_OWORD *)this + 78) = xmmword_1B304EFF0;
  *((_BYTE *)this + 1456) = 0;
  if (*((char *)this + 1319) < 0)
    operator delete(*((void **)this + 162));
  strcpy((char *)this + 1296, "HGMetalHandler");
  *((_BYTE *)this + 1319) = 14;
  *((_WORD *)this + 892) = 257;
  return this;
}

HGMetalHandler *HGMetalHandler::InitTextureUnit(HGMetalHandler *this, HGRect a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  HGRect v12;
  HGRect v13;
  HGRect v14;

  v4 = *((_QWORD *)this + 39);
  v5 = *(_QWORD *)(v4 + 8 * a3);
  if (v5)
  {
    v6 = *(_QWORD *)&a2.var2;
    v7 = *(_QWORD *)&a2.var0;
    v8 = *(_QWORD *)(v5 + 20);
    v9 = *(_QWORD *)(v5 + 28);
    *(_QWORD *)&v14.var0 = HGMetalTexture::GetTextureRect(*(HGMetalTexture **)(v4 + 8 * a3));
    *(_QWORD *)&v14.var2 = v10;
    *(_QWORD *)&v12.var0 = v7;
    *(_QWORD *)&v12.var2 = v6;
    *(_QWORD *)&v13.var0 = v8;
    *(_QWORD *)&v13.var2 = v9;
    HGHandler::InitTexture((uint64_t)this, 0, v12, v13, v14, -*(_DWORD *)(v5 + 20), -*(_DWORD *)(v5 + 24));
  }
  return this;
}

int32x2_t HGMetalHandler::SetFilter(int32x2_t *this, unsigned int a2, unsigned int a3)
{
  int32x2_t v3;
  int32x2_t result;

  v3 = vcltz_s32((int32x2_t)__PAIR64__(a3, a2));
  result = vsub_s32((int32x2_t)vbic_s8((int8x8_t)__PAIR64__(a3, a2), (int8x8_t)v3), v3);
  this[4 * this[59].u32[1] + 62] = result;
  return result;
}

__n128 HGMetalHandler::SetEdgePolicy(HGMetalHandler *this, const HGEdgePolicy *a2)
{
  char *v2;
  __n128 result;

  v2 = (char *)this + 32 * *((unsigned int *)this + 119);
  result = *(__n128 *)a2;
  *((_DWORD *)v2 + 131) = *((_DWORD *)a2 + 4);
  *(__n128 *)(v2 + 508) = result;
  return result;
}

uint64_t HGMetalHandler::SetTextureCoordinateNormalization(uint64_t this, char a2)
{
  *(_BYTE *)(this + 32 * *(unsigned int *)(this + 476) + 504) = a2;
  return this;
}

uint64_t HGMetalHandler::SetParamBufferDesc(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t result;

  v3 = *(_QWORD *)(a1 + 1288);
  result = *a2;
  if (v3 != *a2)
  {
    if (v3)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
      result = *a2;
    }
    *(_QWORD *)(a1 + 1288) = result;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  }
  return result;
}

uint64_t HGMetalHandler::ActiveTexture(HGMetalHandler *this, int a2)
{
  uint64_t v2;

  v2 = (*((_DWORD *)this + 44) + a2);
  *((_DWORD *)this + 119) = v2;
  return v2;
}

uint64_t HGMetalHandler::ActiveTextureMatrix(HGMetalHandler *this, int a2)
{
  uint64_t v2;

  v2 = (*((_DWORD *)this + 40) + a2);
  *((_DWORD *)this + 120) = v2;
  return v2;
}

double HGMetalHandler::LoadIdentity(HGMetalHandler *this)
{
  uint64_t v1;
  _OWORD *v2;
  double result;

  v1 = *((unsigned int *)this + 120);
  v2 = (_OWORD *)((char *)this + 64 * v1);
  v2[47] = xmmword_1B304F230;
  v2[48] = xmmword_1B304F240;
  result = 0.0;
  v2[49] = xmmword_1B304F250;
  v2[50] = xmmword_1B304EFF0;
  *((_DWORD *)this + 121) |= 1 << v1;
  return result;
}

float32x4_t HGMetalHandler::Translate(HGMetalHandler *this, double a2, double a3, double a4)
{
  float v4;
  float v5;
  float v6;
  uint64_t v7;
  float32x4_t *v8;
  float32x4_t result;

  v4 = a2;
  v5 = a3;
  v6 = a4;
  v7 = *((unsigned int *)this + 120);
  v8 = (float32x4_t *)((char *)this + 64 * v7);
  result = vaddq_f32(v8[50], vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v8[47], v4), v8[48], v5), v8[49], v6));
  v8[50] = result;
  *((_DWORD *)this + 121) |= 1 << v7;
  return result;
}

float32x4_t HGMetalHandler::Scale(HGMetalHandler *this, double a2, double a3, double a4)
{
  float v4;
  float v5;
  float v6;
  uint64_t v7;
  float32x4_t *v8;
  float32x4_t result;
  float32x4_t v10;
  float32x4_t v11;

  v4 = a2;
  v5 = a3;
  v6 = a4;
  v7 = *((unsigned int *)this + 120);
  v8 = (float32x4_t *)((char *)this + 64 * v7);
  result = vmulq_n_f32(v8[47], v4);
  v10 = vmulq_n_f32(v8[48], v5);
  v11 = vmulq_n_f32(v8[49], v6);
  v8[47] = result;
  v8[48] = v10;
  v8[49] = v11;
  *((_DWORD *)this + 121) |= 1 << v7;
  return result;
}

float32x4_t HGMetalHandler::MultMatrix(HGMetalHandler *this, const double *a2)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  float32x4_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t result;

  v2 = *a2;
  v3 = a2[1];
  v4 = a2[2];
  v5 = a2[3];
  v6 = a2[4];
  v7 = a2[5];
  v8 = a2[6];
  v9 = a2[7];
  v10 = a2[8];
  v11 = a2[9];
  v12 = a2[10];
  v13 = a2[11];
  v14 = a2[12];
  v15 = a2[13];
  v16 = a2[14];
  v17 = a2[15];
  v18 = *((unsigned int *)this + 120);
  v19 = (float32x4_t *)((char *)this + 64 * v18);
  v20 = v19[47];
  v21 = v19[48];
  v22 = v19[49];
  v23 = v19[50];
  result = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v20, v2), v21, v3), v22, v4), v23, v5);
  v19[47] = result;
  v19[48] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v20, v6), v21, v7), v22, v8), v23, v9);
  v19[49] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v20, v10), v21, v11), v22, v12), v23, v13);
  v19[50] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v20, v14), v21, v15), v22, v16), v23, v17);
  *((_DWORD *)this + 121) |= 1 << v18;
  return result;
}

float32x4_t HGMetalHandler::MultMatrix(HGMetalHandler *this, float *a2)
{
  uint64_t v2;
  float32x4_t *v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t result;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;

  v2 = *((unsigned int *)this + 120);
  v3 = (float32x4_t *)((char *)this + 64 * v2);
  v4 = v3[47];
  v5 = v3[48];
  v6 = v3[49];
  v7 = v3[50];
  result = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v4, *a2), v5, a2[1]), v6, a2[2]), v7, a2[3]);
  v9 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v4, a2[4]), v5, a2[5]), v6, a2[6]), v7, a2[7]);
  v10 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v4, a2[8]), v5, a2[9]), v6, a2[10]), v7, a2[11]);
  v11 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v4, a2[12]), v5, a2[13]), v6, a2[14]), v7, a2[15]);
  v3[47] = result;
  v3[48] = v9;
  v3[49] = v10;
  v3[50] = v11;
  *((_DWORD *)this + 121) |= 1 << v2;
  return result;
}

uint64_t HGMetalHandler::LocalParameter(HGMetalHandler *this, uint64_t a2, float a3, float a4, float a5, float a6)
{
  _DWORD v7[4];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  *(float *)v7 = a3;
  *(float *)&v7[1] = a4;
  *(float *)&v7[2] = a5;
  *(float *)&v7[3] = a6;
  return (*(uint64_t (**)(HGMetalHandler *, uint64_t, _DWORD *, uint64_t))(*(_QWORD *)this + 144))(this, a2, v7, 1);
}

uint64_t HGMetalHandler::LocalParameters(HGMetalHandler *this, int a2, const float *a3, int a4)
{
  return (*(uint64_t (**)(HGMetalHandler *, const float *, uint64_t, uint64_t))(*(_QWORD *)this + 152))(this, a3, 16 * a4, 16 * a2);
}

uint64_t HGMetalHandler::LocalParametersBuffer(HGMetalHandler *this, void *__src, size_t __n, uint64_t a4)
{
  uint64_t result;
  uint64_t v8;
  size_t v9;
  void *v10;
  void *v11;
  const char *v12;
  char *v13;

  result = 0;
  if (!__src || !__n)
    return result;
  v8 = *((int *)this + 43) + a4;
  v9 = v8 + __n;
  if (*((_QWORD *)this + 160) <= v8 + __n)
  {
    v10 = (void *)*((_QWORD *)this + 159);
    if (v10)
    {
      v11 = malloc_type_realloc(v10, (v9 & 0xFFFFFFFFFFFFFF80) + 128, 0x38661485uLL);
      if (v11)
      {
LABEL_6:
        *((_QWORD *)this + 159) = v11;
        *((_QWORD *)this + 160) = (v9 & 0xFFFFFFFFFFFFFF80) + 128;
        goto LABEL_7;
      }
    }
    else
    {
      v11 = malloc_type_malloc((v9 & 0xFFFFFFFFFFFFFF80) + 128, 0xF7309BC3uLL);
      if (v11)
        goto LABEL_6;
    }
    HGLogger::warning((HGLogger *)"HGMetalHandler::LocalParametersBuffer -- failed to allocate memory", v12, v13);
    return 0xFFFFFFFFLL;
  }
LABEL_7:
  if (*((_QWORD *)this + 158) < v9)
    *((_QWORD *)this + 158) = v9;
  memcpy((void *)(*((_QWORD *)this + 159) + v8), __src, __n);
  return 0;
}

float32x4_t HGMetalHandler::Normalize(HGMetalHandler *this)
{
  int32x2_t v1;
  uint64x2_t v2;
  float32x4_t v8;
  uint64_t v9;
  float32x4_t *v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t result;

  v1 = vsub_s32(*(int32x2_t *)((char *)this + 228), *(int32x2_t *)((char *)this + 220));
  v2.i64[0] = v1.u32[0];
  v2.i64[1] = v1.u32[1];
  __asm { FMOV            V1.2D, #1.0 }
  *(float32x2_t *)v8.f32 = vcvt_f32_f64(vdivq_f64(_Q1, vcvtq_f64_u64(v2)));
  __asm { FMOV            V1.2S, #1.0 }
  v8.i64[1] = *(_QWORD *)&_Q1.f64[0];
  v9 = *((unsigned int *)this + 120);
  v10 = (float32x4_t *)((char *)this + 64 * v9);
  v11 = vmulq_f32(v10[47], v8);
  v12 = vmulq_f32(v10[48], v8);
  v13 = vmulq_f32(v10[49], v8);
  result = vmulq_f32(v10[50], v8);
  v10[47] = v11;
  v10[48] = v12;
  v10[49] = v13;
  v10[50] = result;
  *((_DWORD *)this + 121) |= 1 << v9;
  return result;
}

void HGMetalHandler::Rect(HGMetalHandler *this, HGRect a2, const char *a3, char *a4)
{
  uint64_t v6;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  unsigned __int8 v12;
  HGRect v13;
  _OWORD v14[4];
  _OWORD v15[4];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  v6 = *((_QWORD *)this + 41);
  if (v6)
  {
    v7 = HGFormatUtils::collapseRectForFormat((uint64_t *)&v13.var0, *(_DWORD *)(v6 + 16));
    *(_QWORD *)&a2.var2 = *(_QWORD *)&a2.var0;
    *(_QWORD *)&v13.var0 = v7;
    *(_QWORD *)&v13.var2 = *(_QWORD *)&a2.var0;
  }
  else
  {
    v7 = *(_QWORD *)&a2.var0;
  }
  v8 = xmmword_1B304EFF0;
  v9 = xmmword_1B304EFF0;
  *(float *)&v9 = (float)(int)v7;
  v10 = v9;
  *((float *)&v10 + 1) = (float)a2.var3;
  *((float *)&v9 + 1) = (float)SHIDWORD(v7);
  *(float *)&v8 = (float)a2.var2;
  v11 = v8;
  *((float *)&v11 + 1) = (float)a2.var3;
  v15[0] = v10;
  v15[1] = v9;
  *((float *)&v8 + 1) = (float)SHIDWORD(v7);
  v15[2] = v11;
  v15[3] = v8;
  v14[0] = v10;
  v14[1] = v9;
  v14[2] = v11;
  v14[3] = v8;
  v12 = atomic_load(HGLogger::_enabled);
  if ((v12 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"rect[0..%d]: { %d, %d, %d, %d }\n", a3, a4, a3, v13.var0, v13.var1, v13.var2, v13.var3);
  HGMetalHandler::PrimitivesDraw((uint64_t)this, 4u, v15, 4u, v14);
}

void HGMetalHandler::PrimitivesDraw(uint64_t a1, unsigned int a2, void *a3, unsigned int a4, void *a5)
{
  void *v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  char *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  char *v21;
  uint64_t v22;
  const char *v23;
  char *v24;
  uint64_t v25;
  unsigned __int8 v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  char *v30;
  uint64_t v31;
  const char *v32;
  char *v33;
  uint64_t v34;
  unsigned __int8 v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  char *v39;
  uint64_t v40;
  const char *v41;
  char *v42;
  uint64_t v43;
  unsigned __int8 v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  char *v48;
  uint64_t v49;
  const char *v50;
  char *v51;
  uint64_t v52;
  unsigned __int8 v53;
  uint64_t v54;
  uint64_t v55;
  const char *v56;
  char *v57;
  uint64_t v58;
  const char *v59;
  char *v60;
  uint64_t v61;
  unsigned __int8 v62;
  uint64_t v63;
  uint64_t v64;
  const char *v65;
  char *v66;
  uint64_t v67;
  const char *v68;
  char *v69;
  uint64_t v70;
  unsigned __int8 v71;
  uint64_t v72;
  uint64_t v73;
  const char *v74;
  char *v75;
  uint64_t v76;
  const char *v77;
  char *v78;
  uint64_t v79;
  unsigned __int8 v80;
  uint64_t v81;
  uint64_t v82;
  const char *v83;
  char *v84;
  uint64_t v85;

  if (*(_BYTE *)(a1 + 1785))
  {
    v10 = (void *)MEMORY[0x1B5E29C50]();
    *(_QWORD *)(a1 + 1368) = a4;
    v11 = 16 * a4;
    *(_QWORD *)(a1 + 1376) = v11;
    *(_QWORD *)(a1 + 1392) = v11;
    *(_BYTE *)(a1 + 320) = a4 > 4;
    HGMetalHandler::_updateBuffers((HGMetalHandler *)a1, a3, a5);
    HGMetalHandler::_startEncoding((HGMetalHandler *)a1);
    if (*(_BYTE *)(a1 + 1785))
    {
      v15 = **(_QWORD **)(a1 + 312);
      if (v15)
      {
        objc_msgSend(*(id *)(a1 + 264), "setFragmentTexture:atIndex:", *(_QWORD *)(v15 + 144), 0);
        v16 = atomic_load(HGLogger::_enabled);
        if ((v16 & 1) != 0)
        {
          v17 = *(uint64_t **)(a1 + 312);
          v18 = *v17;
          v19 = objc_msgSend((id)objc_msgSend(*(id *)(*v17 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v20, v21, 0, v18, v19);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)a1, 0, v12, v13, v14);
      v25 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 8);
      if (v25)
      {
        objc_msgSend(*(id *)(a1 + 264), "setFragmentTexture:atIndex:", *(_QWORD *)(v25 + 144), 1);
        v26 = atomic_load(HGLogger::_enabled);
        if ((v26 & 1) != 0)
        {
          v27 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 8);
          v28 = objc_msgSend((id)objc_msgSend(*(id *)(v27 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v29, v30, 1, v27, v28);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)a1, 1, v22, v23, v24);
      v34 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 16);
      if (v34)
      {
        objc_msgSend(*(id *)(a1 + 264), "setFragmentTexture:atIndex:", *(_QWORD *)(v34 + 144), 2);
        v35 = atomic_load(HGLogger::_enabled);
        if ((v35 & 1) != 0)
        {
          v36 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 16);
          v37 = objc_msgSend((id)objc_msgSend(*(id *)(v36 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v38, v39, 2, v36, v37);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)a1, 2, v31, v32, v33);
      v43 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 24);
      if (v43)
      {
        objc_msgSend(*(id *)(a1 + 264), "setFragmentTexture:atIndex:", *(_QWORD *)(v43 + 144), 3);
        v44 = atomic_load(HGLogger::_enabled);
        if ((v44 & 1) != 0)
        {
          v45 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 24);
          v46 = objc_msgSend((id)objc_msgSend(*(id *)(v45 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v47, v48, 3, v45, v46);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)a1, 3, v40, v41, v42);
      v52 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 32);
      if (v52)
      {
        objc_msgSend(*(id *)(a1 + 264), "setFragmentTexture:atIndex:", *(_QWORD *)(v52 + 144), 4);
        v53 = atomic_load(HGLogger::_enabled);
        if ((v53 & 1) != 0)
        {
          v54 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 32);
          v55 = objc_msgSend((id)objc_msgSend(*(id *)(v54 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v56, v57, 4, v54, v55);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)a1, 4, v49, v50, v51);
      v61 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 40);
      if (v61)
      {
        objc_msgSend(*(id *)(a1 + 264), "setFragmentTexture:atIndex:", *(_QWORD *)(v61 + 144), 5);
        v62 = atomic_load(HGLogger::_enabled);
        if ((v62 & 1) != 0)
        {
          v63 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 40);
          v64 = objc_msgSend((id)objc_msgSend(*(id *)(v63 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v65, v66, 5, v63, v64);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)a1, 5, v58, v59, v60);
      v70 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 48);
      if (v70)
      {
        objc_msgSend(*(id *)(a1 + 264), "setFragmentTexture:atIndex:", *(_QWORD *)(v70 + 144), 6);
        v71 = atomic_load(HGLogger::_enabled);
        if ((v71 & 1) != 0)
        {
          v72 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 48);
          v73 = objc_msgSend((id)objc_msgSend(*(id *)(v72 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v74, v75, 6, v72, v73);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)a1, 6, v67, v68, v69);
      v79 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 56);
      if (v79)
      {
        objc_msgSend(*(id *)(a1 + 264), "setFragmentTexture:atIndex:", *(_QWORD *)(v79 + 144), 7);
        v80 = atomic_load(HGLogger::_enabled);
        if ((v80 & 1) != 0)
        {
          v81 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 56);
          v82 = objc_msgSend((id)objc_msgSend(*(id *)(v81 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v83, v84, 7, v81, v82);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)a1, 7, v76, v77, v78);
    }
    HGMetalHandler::_encodeBuffers((const char *)a1);
    HGMetalHandler::_encodeDraw(a1, a2);
    HGMetalHandler::_finalizeSourceTextures((HGMetalHandler *)a1);
    HGMetalHandler::_transferEncoderResourcesToCommandBuffer((HGMetalHandler *)a1);
    v85 = *(_QWORD *)(a1 + 248);
    if (*(_DWORD *)(a1 + 1764) >= *(_DWORD *)(v85 + 56))
      HGMetalHandler::FinalizeCommandEncoder((HGMetalHandler *)a1, *(_DWORD *)(v85 + 64), *(_QWORD *)(v85 + 72), *(_QWORD *)(v85 + 88));
    objc_autoreleasePoolPop(v10);
  }
}

void HGMetalHandler::_updateBuffers(HGMetalHandler *a1, void *a2, void *a3)
{
  int v6;
  const float *v7;
  const char *v8;
  char *v9;
  _BYTE v10[16];

  if (*((_BYTE *)a1 + 1785))
  {
    HGMetalHandler::_createBuffers(a1);
    if (*((_BYTE *)a1 + 1785))
    {
      HGTraceGuard::HGTraceGuard((HGTraceGuard *)v10, "metal", 2, "HGMetalHandler::updateBuffers()");
      HGMetalHandler::_updateModelViewProjectionMatrix(a1);
      HGMetalHandler::_updateTextureMatrices(a1, v6, v7, v8, v9);
      HGMetalHandler::_updateParametersBuffer(a1);
      HGMetalHandler::_updateVerticesBuffer((uint64_t)a1, a2);
      HGMetalHandler::_updateTexCoordsBuffer((char *)a1, a3);
      HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v10);
    }
  }
}

void sub_1B2A629EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HGMetalHandler::_startEncoding(HGMetalHandler *this)
{
  void *v2;
  id v3;
  const char *v4;
  char *v5;
  double v6;
  double v7;
  double v8;
  double v9;

  if (!*((_QWORD *)this + 32) && *((_BYTE *)this + 1785))
  {
    v2 = (void *)objc_msgSend(*(id *)(*((_QWORD *)this + 31) + 32), "commandBuffer");
    *((_QWORD *)this + 32) = v2;
    v3 = v2;
    *((_DWORD *)this + 442) = 0;
    HGMetalHandler::_setCommandBufferDebugLabel(this);
  }
  HGMetalHandler::_setupCommandEncoder(this);
  HGMetalHandler::_validateMetalFunctions(this, v4, v5);
  HGMetalHandler::_updatePipelineState(this);
  LODWORD(v6) = *((_DWORD *)this + 432);
  LODWORD(v7) = *((_DWORD *)this + 433);
  LODWORD(v8) = *((_DWORD *)this + 434);
  LODWORD(v9) = *((_DWORD *)this + 435);
  objc_msgSend(*((id *)this + 33), "setBlendColorRed:green:blue:alpha:", v6, v7, v8, v9);
  return HGMetalHandler::_setupScissorRect((uint64_t)this);
}

const char *HGMetalHandler::_encodeBuffers(const char *this)
{
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;

  if (!this[1785])
    return this;
  v1 = this;
  v2 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 39) + 64) + 144);
  objc_msgSend(*((id *)this + 33), "setVertexBuffer:offset:atIndex:", v2, 0, 0);
  v3 = *((_QWORD *)v1 + 39);
  v4 = *(_QWORD *)(v3 + 160);
  if (v4)
  {
    this = (const char *)objc_msgSend(*((id *)v1 + 33), "setVertexBuffer:offset:atIndex:", *(_QWORD *)(v4 + 144), 0, 1);
    v7 = (_QWORD *)*((_QWORD *)v1 + 39);
    if (!v7[20])
      goto LABEL_12;
  }
  else if (v1[320] && (v8 = *(_QWORD *)(v3 + 72)) != 0)
  {
    this = (const char *)objc_msgSend(*((id *)v1 + 33), "setVertexBuffer:offset:atIndex:", *(_QWORD *)(v8 + 144), 0, 1);
    v7 = (_QWORD *)*((_QWORD *)v1 + 39);
    if (!v7[20])
      goto LABEL_12;
  }
  else
  {
    this = (const char *)objc_msgSend(*((id *)v1 + 33), "setVertexBuffer:offset:atIndex:", v2, 576, 1);
    v7 = (_QWORD *)*((_QWORD *)v1 + 39);
    if (!v7[20])
      goto LABEL_12;
  }
  v9 = v7[21];
  if (v9)
  {
    v10 = (void *)*((_QWORD *)v1 + 33);
    v11 = *(_QWORD *)(v9 + 144);
    goto LABEL_15;
  }
LABEL_12:
  if (!v1[320] || (v12 = v7[10]) == 0)
  {
    if (v1[492])
    {
      *((_BYTE *)v1 + 1785) = 0;
      this = HGLogger::warning((HGLogger *)"vertex shader needs color data.", v5, v6);
    }
    goto LABEL_18;
  }
  v10 = (void *)*((_QWORD *)v1 + 33);
  v11 = *(_QWORD *)(v12 + 144);
LABEL_15:
  this = (const char *)objc_msgSend(v10, "setVertexBuffer:offset:atIndex:", v11, 0, 2);
LABEL_18:
  if (*((_DWORD *)v1 + 122))
  {
    v13 = 0;
    v14 = 640;
    do
    {
      while (1)
      {
        v15 = *((_QWORD *)v1 + 39);
        if (!*(_QWORD *)(v15 + 160))
          break;
        v16 = *(_QWORD *)(v15 + 8 * v13 + 176);
        if (!v16)
          break;
        v17 = (void *)*((_QWORD *)v1 + 33);
        v18 = *(_QWORD *)(v16 + 144);
LABEL_27:
        this = (const char *)objc_msgSend(v17, "setVertexBuffer:offset:atIndex:", v18, 0, v13 + 3);
        ++v13;
        v14 += 64;
        if (v13 >= *((unsigned int *)v1 + 122))
          goto LABEL_28;
      }
      if (v1[320])
      {
        v19 = *(_QWORD *)(v15 + 8 * v13 + 88);
        if (v19)
        {
          v17 = (void *)*((_QWORD *)v1 + 33);
          v18 = *(_QWORD *)(v19 + 144);
          goto LABEL_27;
        }
      }
      this = (const char *)objc_msgSend(*((id *)v1 + 33), "setVertexBuffer:offset:atIndex:", v2, v14, v13 + 3);
      ++v13;
      v14 += 64;
    }
    while (v13 < *((unsigned int *)v1 + 122));
  }
LABEL_28:
  if (*((_QWORD *)v1 + 158))
    return (const char *)objc_msgSend(*((id *)v1 + 33), "setFragmentBuffer:offset:atIndex:", v2, 1152, 0);
  return this;
}

void HGMetalHandler::_encodeDraw(uint64_t a1, unsigned int a2)
{
  int v3;
  size_t v4;
  unint64_t v5;
  void **p_dst;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  const std::string::value_type *v10;
  std::string::size_type v11;
  void **__dst;
  std::string::size_type v13;
  int64_t v14;

  if (!*(_BYTE *)(a1 + 1785))
    return;
  objc_msgSend(*(id *)(a1 + 264), "drawPrimitives:vertexStart:vertexCount:instanceCount:", a2, 0, *(_QWORD *)(a1 + 1368), 1);
  ++*(_DWORD *)(a1 + 1764);
  ++*(_DWORD *)(a1 + 1772);
  kdebug_trace();
  v3 = *(char *)(a1 + 1319);
  if (v3 >= 0)
    v4 = *(unsigned __int8 *)(a1 + 1319);
  else
    v4 = *(_QWORD *)(a1 + 1304);
  v5 = v4 + 3;
  if (v4 + 3 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (v5 >= 0x17)
  {
    v7 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v7 = v5 | 7;
    v8 = v7 + 1;
    p_dst = (void **)operator new(v7 + 1);
    v13 = v4 + 3;
    v14 = v8 | 0x8000000000000000;
    __dst = p_dst;
    goto LABEL_12;
  }
  v13 = 0;
  v14 = 0;
  __dst = 0;
  p_dst = (void **)&__dst;
  HIBYTE(v14) = v4 + 3;
  if (v4)
  {
LABEL_12:
    if (v3 >= 0)
      v9 = (const void *)(a1 + 1296);
    else
      v9 = *(const void **)(a1 + 1296);
    memmove(p_dst, v9, v4);
  }
  *(_DWORD *)((char *)p_dst + v4) = 2128928;
  if (v14 >= 0)
    v10 = (const std::string::value_type *)&__dst;
  else
    v10 = (const std::string::value_type *)__dst;
  if (v14 >= 0)
    v11 = HIBYTE(v14);
  else
    v11 = v13;
  std::string::append((std::string *)(a1 + 1320), v10, v11);
  if (SHIBYTE(v14) < 0)
    operator delete(__dst);
}

void sub_1B2A62DE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGMetalHandler::_finalizeSourceTextures(HGMetalHandler *this)
{
  HGMetalTexture **v2;
  HGMetalTexture *v3;
  HGMetalTexture *v4;
  HGMetalTexture *v5;
  HGMetalTexture *v6;
  HGMetalTexture *v7;
  HGMetalTexture *v8;
  HGMetalTexture *v9;

  if (*((_BYTE *)this + 1785))
  {
    v2 = (HGMetalTexture **)*((_QWORD *)this + 39);
    if (*v2)
    {
      HGMetalTexture::WaitForCopy(*v2);
      v2 = (HGMetalTexture **)*((_QWORD *)this + 39);
    }
    v3 = v2[1];
    if (v3)
    {
      HGMetalTexture::WaitForCopy(v3);
      v2 = (HGMetalTexture **)*((_QWORD *)this + 39);
    }
    v4 = v2[2];
    if (v4)
    {
      HGMetalTexture::WaitForCopy(v4);
      v2 = (HGMetalTexture **)*((_QWORD *)this + 39);
    }
    v5 = v2[3];
    if (v5)
    {
      HGMetalTexture::WaitForCopy(v5);
      v2 = (HGMetalTexture **)*((_QWORD *)this + 39);
    }
    v6 = v2[4];
    if (v6)
    {
      HGMetalTexture::WaitForCopy(v6);
      v2 = (HGMetalTexture **)*((_QWORD *)this + 39);
    }
    v7 = v2[5];
    if (v7)
    {
      HGMetalTexture::WaitForCopy(v7);
      v2 = (HGMetalTexture **)*((_QWORD *)this + 39);
    }
    v8 = v2[6];
    if (v8)
    {
      HGMetalTexture::WaitForCopy(v8);
      v2 = (HGMetalTexture **)*((_QWORD *)this + 39);
    }
    v9 = v2[7];
    if (v9)
      HGMetalTexture::WaitForCopy(v9);
  }
}

void HGMetalHandler::_transferEncoderResourcesToCommandBuffer(HGMetalHandler *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t **v4;
  unint64_t v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t **v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t **v12;
  char **v13;
  unint64_t v14;
  char *v15;
  char *v16;
  int *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t *v22;
  uint64_t **v23;
  BOOL v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  _BYTE *v31;
  char *v32;
  char *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  _OWORD *v38;
  char *v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  HGMetalHandler::CommandEncoderCargo *v43;
  uint64_t v44;
  _BYTE v45[16];
  _BYTE v46[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v45, "metal", 2, "HGMetalHandler::_transferEncoderResourcesToCommandBuffer()");
  v2 = 0;
  v3 = *((_QWORD *)this + 39);
  v4 = (uint64_t **)((char *)this + 288);
  do
  {
    v5 = *(_QWORD *)(v3 + 8 * v2);
    if (v5)
    {
      (*(void (**)(_QWORD))(*(_QWORD *)v5 + 16))(*(_QWORD *)(v3 + 8 * v2));
      v6 = *v4;
      v7 = (uint64_t **)((char *)this + 288);
      v8 = (uint64_t **)((char *)this + 288);
      if (*v4)
      {
        while (1)
        {
          while (1)
          {
            v8 = (uint64_t **)v6;
            v9 = v6[4];
            if (v5 >= v9)
              break;
            v6 = *v8;
            v7 = v8;
            if (!*v8)
              goto LABEL_13;
          }
          if (v9 >= v5)
            break;
          v6 = v8[1];
          if (!v6)
          {
            v7 = v8 + 1;
            goto LABEL_13;
          }
        }
      }
      else
      {
LABEL_13:
        v10 = (uint64_t *)operator new(0x28uLL);
        v10[4] = v5;
        *v10 = 0;
        v10[1] = 0;
        v10[2] = (uint64_t)v8;
        *v7 = v10;
        v11 = **((_QWORD **)this + 35);
        if (v11)
        {
          *((_QWORD *)this + 35) = v11;
          v10 = *v7;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 36), v10);
        ++*((_QWORD *)this + 37);
      }
      (*(void (**)(unint64_t))(*(_QWORD *)v5 + 24))(v5);
    }
    ++v2;
  }
  while (v2 != 8);
  *((_QWORD *)this + 38) = 0;
  v12 = (uint64_t **)*((_QWORD *)this + 35);
  if (v12 != v4)
  {
    do
    {
      v17 = (int *)v12[4];
      v18 = v17[7];
      v19 = v17[8];
      v20 = v17[5];
      v21 = v17[6];
      *((_QWORD *)this + 38) += (v19 - v21) * (v18 - v20) * HGFormatUtils::bytesPerPixel(v17[4]);
      v22 = v12[1];
      if (v22)
      {
        do
        {
          v23 = (uint64_t **)v22;
          v22 = (uint64_t *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          v23 = (uint64_t **)v12[2];
          v24 = *v23 == (uint64_t *)v12;
          v12 = v23;
        }
        while (!v24);
      }
      v12 = v23;
    }
    while (v23 != v4);
  }
  v13 = (char **)*((_QWORD *)this + 34);
  v15 = v13[1];
  v14 = (unint64_t)v13[2];
  if ((unint64_t)v15 >= v14)
  {
    v25 = *v13;
    v26 = v15 - *v13;
    v27 = v26 >> 3;
    v28 = (v26 >> 3) + 1;
    if (v28 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v29 = v14 - (_QWORD)v25;
    if (v29 >> 2 > v28)
      v28 = v29 >> 2;
    if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8)
      v30 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v30 = v28;
    if (v30)
    {
      if (v30 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v31 = operator new(8 * v30);
    }
    else
    {
      v31 = 0;
    }
    v32 = &v31[8 * v27];
    v33 = &v31[8 * v30];
    *(_QWORD *)v32 = *((_QWORD *)this + 39);
    v16 = v32 + 8;
    if (v15 != v25)
    {
      v34 = v15 - v25 - 8;
      if (v34 < 0x58)
        goto LABEL_52;
      if ((unint64_t)(v15 - v31 - v26) < 0x20)
        goto LABEL_52;
      v35 = (v34 >> 3) + 1;
      v36 = 8 * (v35 & 0x3FFFFFFFFFFFFFFCLL);
      v37 = &v15[-v36];
      v32 -= v36;
      v38 = &v31[8 * v27 - 16];
      v39 = v15 - 16;
      v40 = v35 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v41 = *(_OWORD *)v39;
        *(v38 - 1) = *((_OWORD *)v39 - 1);
        *v38 = v41;
        v38 -= 2;
        v39 -= 32;
        v40 -= 4;
      }
      while (v40);
      v15 = v37;
      if (v35 != (v35 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_52:
        do
        {
          v42 = *((_QWORD *)v15 - 1);
          v15 -= 8;
          *((_QWORD *)v32 - 1) = v42;
          v32 -= 8;
        }
        while (v15 != v25);
      }
      v15 = *v13;
    }
    *v13 = v32;
    v13[1] = v16;
    v13[2] = v33;
    if (v15)
      operator delete(v15);
  }
  else
  {
    *(_QWORD *)v15 = *((_QWORD *)this + 39);
    v16 = v15 + 8;
  }
  v13[1] = v16;
  *((_QWORD *)this + 39) = 0;
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v46, "metal", 2, "HGMetalHandler::releaseBuffers()");
  v43 = (HGMetalHandler::CommandEncoderCargo *)*((_QWORD *)this + 39);
  if (v43)
  {
    HGMetalHandler::CommandEncoderCargo::~CommandEncoderCargo(v43);
    MEMORY[0x1B5E29170]();
  }
  v44 = operator new();
  *(_QWORD *)(v44 + 240) = 0;
  *(_OWORD *)(v44 + 208) = 0u;
  *(_OWORD *)(v44 + 224) = 0u;
  *(_OWORD *)(v44 + 176) = 0u;
  *(_OWORD *)(v44 + 192) = 0u;
  *(_OWORD *)(v44 + 144) = 0u;
  *(_OWORD *)(v44 + 160) = 0u;
  *(_OWORD *)(v44 + 112) = 0u;
  *(_OWORD *)(v44 + 128) = 0u;
  *(_OWORD *)(v44 + 80) = 0u;
  *(_OWORD *)(v44 + 96) = 0u;
  *(_OWORD *)(v44 + 48) = 0u;
  *(_OWORD *)(v44 + 64) = 0u;
  *(_OWORD *)(v44 + 16) = 0u;
  *(_OWORD *)(v44 + 32) = 0u;
  *(_OWORD *)v44 = 0u;
  *((_QWORD *)this + 39) = v44;
  *((_BYTE *)this + 320) = 0;
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v46);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v45);
}

void sub_1B2A6321C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a11);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B2A63238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

char *HGMetalHandler::SetVertices(HGMetalHandler *this, const void *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v7;
  uint64_t v8;
  HGMetalContext *v9;
  void *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;

  v7 = a4;
  *((_QWORD *)this + 171) = a4;
  v8 = 16 * a4;
  *((_QWORD *)this + 172) = v8;
  *((_QWORD *)this + 174) = v8;
  *((_BYTE *)this + 320) = 1;
  v9 = (HGMetalContext *)*((_QWORD *)this + 31);
  v10 = *(void **)(*((_QWORD *)v9 + 2) + 16);
  v11 = (uint64_t *)HGMetalContext::bufferPool(v9);
  *((_QWORD *)this + 172) = v7 * a3;
  HGMetalBuffer::create(v10, v11, v7 * a3, &v16);
  v12 = *((_QWORD *)this + 39);
  v13 = *(_QWORD *)(v12 + 72);
  v14 = v16;
  if (v13 == v16)
  {
    if (v13)
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
  }
  else
  {
    if (v13)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
      v14 = v16;
    }
    *(_QWORD *)(v12 + 72) = v14;
  }
  return HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*((_QWORD *)this + 39) + 72), 0, *((_QWORD *)this + 172), a2);
}

void sub_1B2A63350(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalHandler::SetVertices(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;

  result = *a2;
  *(_QWORD *)(a1 + 1368) = (*(_DWORD *)(*a2 + 28) - *(_DWORD *)(*a2 + 20));
  v4 = *(_QWORD *)(a1 + 312);
  v5 = *(_QWORD *)(v4 + 160);
  if (v5 != result)
  {
    if (v5)
    {
      (*(void (**)(_QWORD))(*(_QWORD *)v5 + 24))(*(_QWORD *)(v4 + 160));
      result = *a2;
      *(_QWORD *)(v4 + 160) = *a2;
      if (result)
        return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
    }
    else
    {
      *(_QWORD *)(v4 + 160) = result;
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
    }
  }
  return result;
}

char *HGMetalHandler::SetColors(HGMetalHandler *this, const void *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v7;
  uint64_t v8;
  HGMetalContext *v9;
  void *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;

  v7 = a4;
  *((_QWORD *)this + 171) = a4;
  v8 = 16 * a4;
  *((_QWORD *)this + 172) = v8;
  *((_QWORD *)this + 174) = v8;
  *((_BYTE *)this + 320) = 1;
  v9 = (HGMetalContext *)*((_QWORD *)this + 31);
  v10 = *(void **)(*((_QWORD *)v9 + 2) + 16);
  v11 = (uint64_t *)HGMetalContext::bufferPool(v9);
  *((_QWORD *)this + 173) = v7 * a3;
  HGMetalBuffer::create(v10, v11, v7 * a3, &v16);
  v12 = *((_QWORD *)this + 39);
  v13 = *(_QWORD *)(v12 + 80);
  v14 = v16;
  if (v13 == v16)
  {
    if (v13)
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
  }
  else
  {
    if (v13)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
      v14 = v16;
    }
    *(_QWORD *)(v12 + 80) = v14;
  }
  return HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*((_QWORD *)this + 39) + 80), 0, *((_QWORD *)this + 173), a2);
}

void sub_1B2A634E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalHandler::SetColors(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 312);
  v3 = *(_QWORD *)(v2 + 168);
  result = *a2;
  if (v3 != *a2)
  {
    if (v3)
    {
      (*(void (**)(_QWORD))(*(_QWORD *)v3 + 24))(*(_QWORD *)(v2 + 168));
      result = *a2;
    }
    *(_QWORD *)(v2 + 168) = result;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  }
  return result;
}

char *HGMetalHandler::SetTextureCoords(HGMetalHandler *this, const void *a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  uint64_t v9;
  uint64_t v10;
  HGMetalContext *v11;
  void *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  v9 = a4;
  *((_QWORD *)this + 171) = a4;
  v10 = 16 * a4;
  *((_QWORD *)this + 172) = v10;
  *((_QWORD *)this + 174) = v10;
  *((_BYTE *)this + 320) = 1;
  v11 = (HGMetalContext *)*((_QWORD *)this + 31);
  v12 = *(void **)(*((_QWORD *)v11 + 2) + 16);
  v13 = (uint64_t *)HGMetalContext::bufferPool(v11);
  *((_QWORD *)this + 174) = v9 * a3;
  HGMetalBuffer::create(v12, v13, v9 * a3, &v20);
  v14 = *((_QWORD *)this + 39) + 8 * a5;
  v17 = *(_QWORD *)(v14 + 88);
  v16 = (_QWORD *)(v14 + 88);
  v15 = v17;
  v18 = v20;
  if (v17 == v20)
  {
    if (v15)
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 24))(v15);
  }
  else
  {
    if (v15)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 24))(v15);
      v18 = v20;
    }
    *v16 = v18;
  }
  return HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*((_QWORD *)this + 39) + 8 * a5 + 88), 0, *((_QWORD *)this + 174), a2);
}

void sub_1B2A63654(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalHandler::SetTextureCoords(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t result;

  v3 = *(_QWORD *)(a1 + 312) + 8 * a3;
  v6 = *(_QWORD *)(v3 + 176);
  v5 = (uint64_t *)(v3 + 176);
  v4 = v6;
  result = *a2;
  if (v6 != *a2)
  {
    if (v4)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
      result = *a2;
    }
    *v5 = result;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  }
  return result;
}

uint64_t HGMetalHandler::SetTextureCoords(uint64_t this, int a2)
{
  *(_DWORD *)(this + 488) = a2;
  return this;
}

char *HGMetalHandler::SetIndices(HGMetalHandler *this, const void *a2, unint64_t a3, unsigned int a4)
{
  size_t v6;
  HGMetalContext *v7;
  void *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;

  *((_DWORD *)this + 350) = a3 > 2;
  v6 = a4 * a3;
  v7 = (HGMetalContext *)*((_QWORD *)this + 31);
  v8 = *(void **)(*((_QWORD *)v7 + 2) + 16);
  v9 = (uint64_t *)HGMetalContext::bufferPool(v7);
  HGMetalBuffer::create(v8, v9, v6, &v14);
  v10 = *((_QWORD *)this + 39);
  v11 = *(_QWORD *)(v10 + 152);
  v12 = v14;
  if (v11 == v14)
  {
    if (v11)
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
  }
  else
  {
    if (v11)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
      v12 = v14;
    }
    *(_QWORD *)(v10 + 152) = v12;
  }
  return HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*((_QWORD *)this + 39) + 152), 0, v6, a2);
}

void sub_1B2A637AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalHandler::SetIndices(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;

  result = *a2;
  *(_DWORD *)(a1 + 1400) = *(_DWORD *)(*a2 + 16) != 3;
  v4 = *(_QWORD *)(a1 + 312);
  v5 = *(_QWORD *)(v4 + 240);
  if (v5 != result)
  {
    if (v5)
    {
      (*(void (**)(_QWORD))(*(_QWORD *)v5 + 24))(*(_QWORD *)(v4 + 240));
      result = *a2;
      *(_QWORD *)(v4 + 240) = *a2;
      if (result)
        return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
    }
    else
    {
      *(_QWORD *)(v4 + 240) = result;
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
    }
  }
  return result;
}

void HGMetalHandler::PrimitivesStart(HGMetalHandler *this)
{
  void *v2;
  int v3;
  const float *v4;
  const char *v5;
  char *v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  uint64_t v10;
  unsigned __int8 v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  char *v16;
  uint64_t v17;
  const char *v18;
  char *v19;
  uint64_t v20;
  unsigned __int8 v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  char *v25;
  uint64_t v26;
  const char *v27;
  char *v28;
  uint64_t v29;
  unsigned __int8 v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  char *v34;
  uint64_t v35;
  const char *v36;
  char *v37;
  uint64_t v38;
  unsigned __int8 v39;
  uint64_t v40;
  uint64_t v41;
  const char *v42;
  char *v43;
  uint64_t v44;
  const char *v45;
  char *v46;
  uint64_t v47;
  unsigned __int8 v48;
  uint64_t v49;
  uint64_t v50;
  const char *v51;
  char *v52;
  uint64_t v53;
  const char *v54;
  char *v55;
  uint64_t v56;
  unsigned __int8 v57;
  uint64_t v58;
  uint64_t v59;
  const char *v60;
  char *v61;
  uint64_t v62;
  const char *v63;
  char *v64;
  uint64_t v65;
  unsigned __int8 v66;
  uint64_t v67;
  uint64_t v68;
  const char *v69;
  char *v70;
  uint64_t v71;
  const char *v72;
  char *v73;
  uint64_t v74;
  unsigned __int8 v75;
  uint64_t v76;
  uint64_t v77;
  const char *v78;
  char *v79;

  *((_BYTE *)this + 1786) = 1;
  v2 = (void *)MEMORY[0x1B5E29C50]();
  HGMetalHandler::_createBuffers(this);
  HGMetalHandler::_updateModelViewProjectionMatrix(this);
  HGMetalHandler::_updateTextureMatrices(this, v3, v4, v5, v6);
  HGMetalHandler::_updateParametersBuffer(this);
  HGMetalHandler::_startEncoding(this);
  if (*((_BYTE *)this + 1785))
  {
    v10 = **((_QWORD **)this + 39);
    if (v10)
    {
      objc_msgSend(*((id *)this + 33), "setFragmentTexture:atIndex:", *(_QWORD *)(v10 + 144), 0);
      v11 = atomic_load(HGLogger::_enabled);
      if ((v11 & 1) != 0)
      {
        v12 = (uint64_t *)*((_QWORD *)this + 39);
        v13 = *v12;
        v14 = objc_msgSend((id)objc_msgSend(*(id *)(*v12 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v15, v16, 0, v13, v14);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 0, v7, v8, v9);
    v20 = *(_QWORD *)(*((_QWORD *)this + 39) + 8);
    if (v20)
    {
      objc_msgSend(*((id *)this + 33), "setFragmentTexture:atIndex:", *(_QWORD *)(v20 + 144), 1);
      v21 = atomic_load(HGLogger::_enabled);
      if ((v21 & 1) != 0)
      {
        v22 = *(_QWORD *)(*((_QWORD *)this + 39) + 8);
        v23 = objc_msgSend((id)objc_msgSend(*(id *)(v22 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v24, v25, 1, v22, v23);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 1, v17, v18, v19);
    v29 = *(_QWORD *)(*((_QWORD *)this + 39) + 16);
    if (v29)
    {
      objc_msgSend(*((id *)this + 33), "setFragmentTexture:atIndex:", *(_QWORD *)(v29 + 144), 2);
      v30 = atomic_load(HGLogger::_enabled);
      if ((v30 & 1) != 0)
      {
        v31 = *(_QWORD *)(*((_QWORD *)this + 39) + 16);
        v32 = objc_msgSend((id)objc_msgSend(*(id *)(v31 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v33, v34, 2, v31, v32);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 2, v26, v27, v28);
    v38 = *(_QWORD *)(*((_QWORD *)this + 39) + 24);
    if (v38)
    {
      objc_msgSend(*((id *)this + 33), "setFragmentTexture:atIndex:", *(_QWORD *)(v38 + 144), 3);
      v39 = atomic_load(HGLogger::_enabled);
      if ((v39 & 1) != 0)
      {
        v40 = *(_QWORD *)(*((_QWORD *)this + 39) + 24);
        v41 = objc_msgSend((id)objc_msgSend(*(id *)(v40 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v42, v43, 3, v40, v41);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 3, v35, v36, v37);
    v47 = *(_QWORD *)(*((_QWORD *)this + 39) + 32);
    if (v47)
    {
      objc_msgSend(*((id *)this + 33), "setFragmentTexture:atIndex:", *(_QWORD *)(v47 + 144), 4);
      v48 = atomic_load(HGLogger::_enabled);
      if ((v48 & 1) != 0)
      {
        v49 = *(_QWORD *)(*((_QWORD *)this + 39) + 32);
        v50 = objc_msgSend((id)objc_msgSend(*(id *)(v49 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v51, v52, 4, v49, v50);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 4, v44, v45, v46);
    v56 = *(_QWORD *)(*((_QWORD *)this + 39) + 40);
    if (v56)
    {
      objc_msgSend(*((id *)this + 33), "setFragmentTexture:atIndex:", *(_QWORD *)(v56 + 144), 5);
      v57 = atomic_load(HGLogger::_enabled);
      if ((v57 & 1) != 0)
      {
        v58 = *(_QWORD *)(*((_QWORD *)this + 39) + 40);
        v59 = objc_msgSend((id)objc_msgSend(*(id *)(v58 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v60, v61, 5, v58, v59);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 5, v53, v54, v55);
    v65 = *(_QWORD *)(*((_QWORD *)this + 39) + 48);
    if (v65)
    {
      objc_msgSend(*((id *)this + 33), "setFragmentTexture:atIndex:", *(_QWORD *)(v65 + 144), 6);
      v66 = atomic_load(HGLogger::_enabled);
      if ((v66 & 1) != 0)
      {
        v67 = *(_QWORD *)(*((_QWORD *)this + 39) + 48);
        v68 = objc_msgSend((id)objc_msgSend(*(id *)(v67 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v69, v70, 6, v67, v68);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 6, v62, v63, v64);
    v74 = *(_QWORD *)(*((_QWORD *)this + 39) + 56);
    if (v74)
    {
      objc_msgSend(*((id *)this + 33), "setFragmentTexture:atIndex:", *(_QWORD *)(v74 + 144), 7);
      v75 = atomic_load(HGLogger::_enabled);
      if ((v75 & 1) != 0)
      {
        v76 = *(_QWORD *)(*((_QWORD *)this + 39) + 56);
        v77 = objc_msgSend((id)objc_msgSend(*(id *)(v76 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v78, v79, 7, v76, v77);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 7, v71, v72, v73);
  }
  HGMetalHandler::_encodeBuffers((const char *)this);
  objc_autoreleasePoolPop(v2);
}

void HGMetalHandler::PrimitivesEnd(HGMetalHandler *this)
{
  void *v2;
  uint64_t v3;

  v2 = (void *)MEMORY[0x1B5E29C50]();
  HGMetalHandler::_finalizeSourceTextures(this);
  HGMetalHandler::_transferEncoderResourcesToCommandBuffer(this);
  v3 = *((_QWORD *)this + 31);
  if (*((_DWORD *)this + 441) >= *(_DWORD *)(v3 + 56))
    HGMetalHandler::FinalizeCommandEncoder(this, *(_DWORD *)(v3 + 64), *(_QWORD *)(v3 + 72), *(_QWORD *)(v3 + 88));
  objc_autoreleasePoolPop(v2);
  *((_BYTE *)this + 1786) = 0;
}

void HGMetalHandler::_createBuffers(HGMetalHandler *this)
{
  unint64_t v2;
  _DWORD *v3;
  HGMetalContext *v4;
  void *v5;
  uint64_t *v6;
  const char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v13, "metal", 2, "HGMetalHandler::createBuffers()");
  v2 = *((_QWORD *)this + 158) + 1152;
  v3 = *(_DWORD **)(*((_QWORD *)this + 39) + 64);
  if (!v3 || v2 > ((v3[8] - v3[6]) * (v3[7] - v3[5])))
  {
    v4 = (HGMetalContext *)*((_QWORD *)this + 31);
    v5 = *(void **)(*((_QWORD *)v4 + 2) + 16);
    v6 = (uint64_t *)HGMetalContext::bufferPool(v4);
    HGMetalBuffer::create(v5, v6, v2, &v12);
    v9 = *((_QWORD *)this + 39);
    v10 = *(_QWORD *)(v9 + 64);
    v11 = v12;
    if (v10 == v12)
    {
      if (v10)
        (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
    }
    else
    {
      if (v10)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
        v11 = v12;
      }
      *(_QWORD *)(v9 + 64) = v11;
    }
    if (!*(_QWORD *)(*((_QWORD *)this + 39) + 64))
    {
      *((_BYTE *)this + 1785) = 0;
      HGLogger::warning((HGLogger *)"HGMetalHandler::_createBuffers -- null buffer!!", v7, v8);
    }
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v13);
}

void sub_1B2A63D8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGMetalHandler::_updateModelViewProjectionMatrix(HGMetalHandler *this)
{
  float *v1;
  float *v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  const char *v11;
  unsigned __int8 v12;
  int v13;
  const float *v14;
  const char *v15;
  char *v16;
  unsigned __int8 v17;
  int v18;
  const float *v19;
  const char *v20;
  char *v21;
  unsigned __int8 v22;
  int v23;
  const float *v24;
  const char *v25;
  char *v26;
  unsigned __int8 v27;
  int v28;
  const float *v29;
  const char *v30;
  char *v31;
  unsigned __int8 v32;
  int v33;
  const float *v34;
  const char *v35;
  char *v36;
  unsigned __int8 v37;
  _OWORD v38[4];

  v1 = (float *)((char *)this + 16);
  v2 = (float *)((char *)this + 80);
  v3 = *((float32x4_t *)this + 5);
  v4 = *((float32x4_t *)this + 6);
  v5 = *((float32x4_t *)this + 7);
  v6 = *((float32x4_t *)this + 8);
  v7 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v3, COERCE_FLOAT(*((_OWORD *)this + 1))), v4, *(float32x2_t *)((char *)this + 16), 1), v5, *((float32x4_t *)this + 1), 2), v6, *((float32x4_t *)this + 1), 3);
  v8 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v3, COERCE_FLOAT(*((_OWORD *)this + 2))), v4, *(float32x2_t *)((char *)this + 32), 1), v5, *((float32x4_t *)this + 2), 2), v6, *((float32x4_t *)this + 2), 3);
  v9 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v3, COERCE_FLOAT(*((_OWORD *)this + 3))), v4, *(float32x2_t *)((char *)this + 48), 1), v5, *((float32x4_t *)this + 3), 2), v6, *((float32x4_t *)this + 3), 3);
  v10 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v3, COERCE_FLOAT(*((_OWORD *)this + 4))), v4, *(float32x2_t *)((char *)this + 64), 1), v5, *((float32x4_t *)this + 4), 2), v6, *((float32x4_t *)this + 4), 3);
  v38[0] = v7;
  v38[1] = v8;
  v38[2] = v9;
  v38[3] = v10;
  HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*((_QWORD *)this + 39) + 64), 0, 0x40uLL, v38);
  v12 = atomic_load(HGLogger::_enabled);
  if ((v12 & 1) != 0 && (int)HGLogger::getLevel((HGLogger *)"gpu", v11) >= 1)
  {
    v17 = atomic_load(HGLogger::_enabled);
    if ((v17 & 1) != 0)
    {
      HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"projection matrix :\n", v15, v16);
      log_matrix(v2, v28, v29, v30, v31);
      v32 = atomic_load(HGLogger::_enabled);
      if ((v32 & 1) == 0)
      {
LABEL_5:
        log_matrix(v1, v18, v19, v20, v21);
        v27 = atomic_load(HGLogger::_enabled);
        if ((v27 & 1) == 0)
        {
LABEL_7:
          log_matrix((float *)v38, v23, v24, v25, v26);
          return;
        }
LABEL_6:
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"model view projection matrix :\n", v25, v26);
        goto LABEL_7;
      }
    }
    else
    {
      log_matrix(v2, v13, v14, v15, v16);
      v22 = atomic_load(HGLogger::_enabled);
      if ((v22 & 1) == 0)
        goto LABEL_5;
    }
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"model view matrix :\n", v20, v21);
    log_matrix(v1, v33, v34, v35, v36);
    v37 = atomic_load(HGLogger::_enabled);
    if ((v37 & 1) == 0)
      goto LABEL_7;
    goto LABEL_6;
  }
}

void HGMetalHandler::_updateTextureMatrices(HGMetalHandler *this, int a2, const float *a3, const char *a4, char *a5)
{
  unint64_t v5;
  unint64_t i;
  unint64_t v8;
  unint64_t v9;
  float *v10;
  unsigned __int8 v11;

  v5 = *((unsigned int *)this + 122);
  if ((_DWORD)v5)
  {
    for (i = 0; i < v5; ++i)
    {
      while (((*((_DWORD *)this + 121) >> i) & 1) != 0)
      {
        v8 = i + 1;
        HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*((_QWORD *)this + 39) + 64), (i + 1) << 6, 0x40uLL, (char *)this + 64 * i + 752);
        v5 = *((unsigned int *)this + 122);
        i = v8;
        if (v8 >= v5)
          goto LABEL_6;
      }
    }
LABEL_6:
    if (v5)
    {
      v9 = 0;
      v10 = (float *)((char *)this + 752);
      do
      {
        if (((*((_DWORD *)this + 121) >> v9) & 1) != 0)
        {
          v11 = atomic_load(HGLogger::_enabled);
          if ((v11 & 1) != 0)
            HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"texture matrix %d :\n", a4, a5, v9);
          log_matrix(v10, a2, a3, a4, a5);
          v5 = *((unsigned int *)this + 122);
        }
        ++v9;
        v10 += 16;
      }
      while (v9 < v5);
    }
  }
}

void HGMetalHandler::_updateParametersBuffer(HGMetalHandler *this)
{
  size_t v1;
  const char *v3;
  unsigned __int8 v4;
  const char *v5;
  char *v6;
  HGParamBufferDesc *v7;
  std::string *v8;
  __int128 v9;
  std::locale::id *v10;
  const std::locale::facet *v11;
  unsigned __int8 v12;
  _QWORD *v13;
  const char *v14;
  char *v15;
  unsigned __int8 v16;
  std::string *v17;
  unsigned __int8 v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  std::string::size_type v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  const char *v30;
  char *v31;
  unsigned __int8 v32;
  unsigned __int8 v33;
  std::string *v34;
  std::string::size_type v35;
  std::string::size_type v36;
  std::string v37;
  uint64_t v38;
  void *__p;
  void *v40;
  char v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  std::string v45;
  std::string v46;
  std::locale v47;

  v1 = *((_QWORD *)this + 158);
  if (!v1)
    return;
  HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*((_QWORD *)this + 39) + 64), 1152, v1, *((const void **)this + 159));
  v4 = atomic_load(HGLogger::_enabled);
  if ((v4 & 1) == 0 || (int)HGLogger::getLevel((HGLogger *)"gpu", v3) < 1)
    return;
  v7 = (HGParamBufferDesc *)*((_QWORD *)this + 161);
  if (v7)
  {
    HGParamBufferDesc::printParamValuesFromBuffer(v7, *((unsigned __int8 **)this + 159), *((_QWORD *)this + 158), &v37);
    v8 = std::string::insert(&v37, 0, "parameter buffer 0 :\n");
    v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v46.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v37.__r_.__value_.__l.__data_);
    std::istringstream::basic_istringstream[abi:ne180100]((uint64_t)&v37, (uint64_t)&v46, 8);
    memset(&v45, 0, sizeof(v45));
    v10 = (std::locale::id *)MEMORY[0x1E0DE4A90];
    while (1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)&v37 + *(_QWORD *)(v37.__r_.__value_.__r.__words[0] - 24)));
      v11 = std::locale::use_facet(&v47, v10);
      v12 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
      std::locale::~locale(&v47);
      v13 = std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v37, (uint64_t)&v45, v12);
      if ((*((_BYTE *)v13 + *(_QWORD *)(*v13 - 24) + 32) & 5) != 0)
        break;
      std::string::append(&v45, "\n");
      v16 = atomic_load(HGLogger::_enabled);
      if ((v16 & 1) != 0)
      {
        if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v17 = &v45;
        else
          v17 = (std::string *)v45.__r_.__value_.__r.__words[0];
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%s", v14, v15, v17);
      }
    }
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v45.__r_.__value_.__l.__data_);
    v37.__r_.__value_.__r.__words[0] = *MEMORY[0x1E0DE4F58];
    *(std::string::size_type *)((char *)v37.__r_.__value_.__r.__words
                              + *(_QWORD *)(v37.__r_.__value_.__r.__words[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F58]
                                                                                                + 24);
    v37.__r_.__value_.__r.__words[2] = MEMORY[0x1E0DE4FB8] + 16;
    if (v41 < 0)
      operator delete(__p);
    std::streambuf::~streambuf();
    std::istream::~istream();
    MEMORY[0x1B5E290BC](&v43);
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v46.__r_.__value_.__l.__data_);
    return;
  }
  v18 = atomic_load(HGLogger::_enabled);
  if ((v18 & 1) != 0)
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%s", v5, v6, "parameter buffer 0 :\n");
  v19 = *((_QWORD *)this + 158);
  if ((int)(v19 >> 4) >= 1)
  {
    v20 = 0;
    v21 = 0;
    v22 = *MEMORY[0x1E0DE4F50];
    v35 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
    v36 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
    v23 = v19 & 0xFFFFFFFF0;
    v24 = MEMORY[0x1E0DE4FB8] + 16;
    do
    {
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v37);
      memset(&v46, 0, sizeof(v46));
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v37.__r_.__value_.__r.__words[2], (uint64_t)"parameter(", 10);
      v25 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)"): {", 4);
      v26 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)", ", 2);
      v27 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)", ", 2);
      v28 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, (uint64_t)", ", 2);
      v29 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v29, (uint64_t)"} \n", 3);
      std::stringbuf::str();
      if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v46.__r_.__value_.__l.__data_);
        v46 = v45;
        v33 = atomic_load(HGLogger::_enabled);
        if ((v33 & 1) != 0)
        {
LABEL_29:
          v34 = &v46;
          if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v34 = (std::string *)v46.__r_.__value_.__r.__words[0];
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%s", v30, v31, v34);
        }
      }
      else
      {
        v46 = v45;
        v32 = atomic_load(HGLogger::_enabled);
        if ((v32 & 1) != 0)
          goto LABEL_29;
      }
      if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v46.__r_.__value_.__l.__data_);
      v37.__r_.__value_.__r.__words[0] = v22;
      *(std::string::size_type *)((char *)v37.__r_.__value_.__r.__words + *(_QWORD *)(v22 - 24)) = v36;
      v37.__r_.__value_.__r.__words[2] = v35;
      v38 = v24;
      if (v42 < 0)
        operator delete(v40);
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x1B5E290BC](&v44);
      v21 += 16;
      ++v20;
    }
    while (v23 != v21);
  }
}

void sub_1B2A6449C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  uint64_t v18;

  if (*(char *)(v18 - 137) < 0)
  {
    operator delete(*(void **)(v18 - 160));
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalHandler::_encodeDrawIndexed(uint64_t result, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  int v10;
  size_t v11;
  unint64_t v12;
  void **p_dst;
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  const std::string::value_type *v17;
  std::string::size_type v18;
  void **__dst;
  std::string::size_type v20;
  int64_t v21;

  if (!*(_BYTE *)(result + 1785))
    return result;
  v7 = result;
  v8 = *(_QWORD **)(result + 312);
  if (v8[20] && (v9 = v8[30]) != 0 || (v9 = v8[19]) != 0)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 16))(v9);
  if (!a4)
    a4 = *(_DWORD *)(v9 + 28) - *(_DWORD *)(v9 + 20);
  objc_msgSend(*(id *)(v7 + 264), "drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:", a2, a4, *(unsigned int *)(v7 + 1400), *(_QWORD *)(v9 + 144), a3);
  ++*(_DWORD *)(v7 + 1764);
  ++*(_DWORD *)(v7 + 1772);
  kdebug_trace();
  v10 = *(char *)(v7 + 1319);
  if (v10 >= 0)
    v11 = *(unsigned __int8 *)(v7 + 1319);
  else
    v11 = *(_QWORD *)(v7 + 1304);
  v12 = v11 + 3;
  if (v11 + 3 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (v12 >= 0x17)
  {
    v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17)
      v14 = v12 | 7;
    v15 = v14 + 1;
    p_dst = (void **)operator new(v14 + 1);
    v20 = v11 + 3;
    v21 = v15 | 0x8000000000000000;
    __dst = p_dst;
    goto LABEL_18;
  }
  v20 = 0;
  v21 = 0;
  __dst = 0;
  p_dst = (void **)&__dst;
  HIBYTE(v21) = v11 + 3;
  if (v11)
  {
LABEL_18:
    if (v10 >= 0)
      v16 = (const void *)(v7 + 1296);
    else
      v16 = *(const void **)(v7 + 1296);
    memmove(p_dst, v16, v11);
  }
  *(_DWORD *)((char *)p_dst + v11) = 2128928;
  if (v21 >= 0)
    v17 = (const std::string::value_type *)&__dst;
  else
    v17 = (const std::string::value_type *)__dst;
  if (v21 >= 0)
    v18 = HIBYTE(v21);
  else
    v18 = v20;
  std::string::append((std::string *)(v7 + 1320), v17, v18);
  if (SHIBYTE(v21) < 0)
    operator delete(__dst);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
}

void sub_1B2A646FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  (*(void (**)(uint64_t))(*(_QWORD *)v15 + 24))(v15);
  _Unwind_Resume(a1);
}

char *HGMetalHandler::AddMTLFunction(_QWORD *a1, void *a2)
{
  uint64_t v3;
  void *v4;
  char *result;
  char *v6;
  unint64_t v7;
  void *v8;
  uint64_t v9;
  const char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  char *v19;
  _QWORD *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;

  v3 = objc_msgSend(a2, "functionType");
  if (v3 == 5)
  {
    v6 = (char *)a1[180];
    v7 = a1[181];
    if ((unint64_t)v6 >= v7)
    {
      v12 = (char *)a1[179];
      v13 = (v6 - v12) >> 3;
      v14 = v13 + 1;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v15 = v7 - (_QWORD)v12;
      if (v15 >> 2 > v14)
        v14 = v15 >> 2;
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v16 = v14;
      if (v16)
      {
        if (v16 >> 61)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v17 = (char *)operator new(8 * v16);
      }
      else
      {
        v17 = 0;
      }
      v18 = &v17[8 * v13];
      v19 = &v17[8 * v16];
      *(_QWORD *)v18 = a2;
      v20 = v18 + 8;
      if (v6 != v12)
      {
        v21 = v6 - v12 - 8;
        if (v21 < 0x58)
          goto LABEL_44;
        if ((unint64_t)(v12 - v17) < 0x20)
          goto LABEL_44;
        v22 = (v21 >> 3) + 1;
        v23 = 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        v24 = &v6[-v23];
        v18 -= v23;
        v25 = &v17[8 * v13 - 16];
        v26 = v6 - 16;
        v27 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v28 = *(_OWORD *)v26;
          *((_OWORD *)v25 - 1) = *((_OWORD *)v26 - 1);
          *(_OWORD *)v25 = v28;
          v25 -= 32;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v6 = v24;
        if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_44:
          do
          {
            v29 = *((_QWORD *)v6 - 1);
            v6 -= 8;
            *((_QWORD *)v18 - 1) = v29;
            v18 -= 8;
          }
          while (v6 != v12);
        }
        v6 = (char *)a1[179];
      }
      a1[179] = v18;
      a1[180] = v20;
      a1[181] = v19;
      if (v6)
        operator delete(v6);
      result = (char *)a2;
      a1[180] = v20;
    }
    else
    {
      result = (char *)a2;
      *(_QWORD *)v6 = a2;
      a1[180] = v6 + 8;
    }
    return result;
  }
  if (v3 == 2)
  {
    v8 = (void *)a1[178];
    result = (char *)a2;
    if (v8 == a2)
      return result;
    if (v8)
    {

      result = (char *)a2;
    }
    a1[178] = result;
    if (!result)
      return result;
    return result;
  }
  if (v3 != 1)
  {
    v9 = objc_msgSend((id)objc_msgSend(a2, "name"), "UTF8String");
    return (char *)HGLogger::warning((HGLogger *)"Metal function %s is not supported", v10, v11, v9);
  }
  v4 = (void *)a1[177];
  result = (char *)a2;
  if (v4 != a2)
  {
    if (v4)
    {

      result = (char *)a2;
    }
    a1[177] = result;
    if (result)
      return result;
  }
  return result;
}

uint64_t HGMetalHandler::SetAttributeFlags(uint64_t this, __int16 a2)
{
  *(_BYTE *)(this + 492) = (a2 & 0x200) != 0;
  return this;
}

std::string *HGMetalHandler::SetDebugLabel(std::string *a1, const std::string *a2)
{
  return std::string::operator=(a1 + 54, a2);
}

__n128 HGMetalHandler::SetBlendingInfo(HGMetalHandler *this, const HGBlendingInfo *a2)
{
  _OWORD *v4;
  __n128 result;
  __int128 v6;

  v4 = (_OWORD *)((char *)this + 1464);
  if (!HGBlendingInfo::operator==((uint64_t)a2, (uint64_t)this + 1464))
  {
    result = *(__n128 *)a2;
    v6 = *((_OWORD *)a2 + 1);
    *v4 = *(_OWORD *)a2;
    v4[1] = v6;
    *((_BYTE *)this + 1784) = 1;
  }
  return result;
}

uint64_t HGMetalHandler::EnableBlending(uint64_t this)
{
  if ((*(_BYTE *)(this + 1456) & 1) == 0)
  {
    *(_BYTE *)(this + 1456) |= 1u;
    *(_BYTE *)(this + 1784) = 1;
  }
  return this;
}

uint64_t HGMetalHandler::DisableBlending(uint64_t this)
{
  if ((*(_BYTE *)(this + 1456) & 1) != 0)
  {
    *(_BYTE *)(this + 1456) &= ~1u;
    *(_BYTE *)(this + 1784) = 1;
  }
  return this;
}

_QWORD *HGMetalHandler::EnableDepthBuffer(_QWORD *this)
{
  _QWORD *v1;
  HGMetalContext *MetalContext;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t *v7;
  _QWORD *v8;
  _QWORD *v9;

  if (!this[57])
  {
    v1 = this;
    HGMetalHandler::FinalizeCommandEncoder((HGMetalHandler *)this, *(_DWORD *)(this[31] + 64), *(_QWORD *)(this[31] + 72), *(_QWORD *)(this[31] + 88));
    MetalContext = (HGMetalContext *)HGGPURenderer::GetMetalContext((HGGPURenderer *)v1[18]);
    v3 = v1[49];
    v4 = *(_QWORD *)(v3 + 20);
    v5 = *(_QWORD *)(v3 + 28);
    v6 = *(void **)(*((_QWORD *)MetalContext + 2) + 16);
    v7 = (uint64_t *)HGMetalContext::texturePool(MetalContext);
    HGMetalTexture::createDepth(v6, v7, v4, v5, *((_DWORD *)v1 + 118), &v9);
    this = (_QWORD *)v1[57];
    v8 = v9;
    if (this == v9)
    {
      if (this)
        this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 24))(this);
    }
    else
    {
      if (this)
      {
        this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 24))(this);
        v8 = v9;
      }
      v1[57] = v8;
    }
    *((_BYTE *)v1 + 1784) = 1;
  }
  return this;
}

void sub_1B2A64AE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalHandler::DisableDepthBuffer(HGMetalHandler *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 57);
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
    *((_QWORD *)this + 57) = 0;
    *((_BYTE *)this + 1784) = 1;
  }
  return result;
}

uint64_t HGMetalHandler::SetScissorTest(uint64_t this, char a2)
{
  *(_BYTE *)(this + 1744) = a2;
  return this;
}

__n128 HGMetalHandler::SetScissorRect(HGMetalHandler *this, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *(__n128 *)((char *)this + 1748) = *a2;
  return result;
}

__n128 HGMetalHandler::SetBlendingColor(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  a1[108] = *a2;
  return result;
}

void HGMetalHandler::FinalizeCommandEncoder(HGMetalHandler *this, unsigned int a2, unint64_t a3, unint64_t a4)
{
  unint64_t v8;

  if (*((_QWORD *)this + 33))
  {
    HGMetalHandler::_setCommandEncoderDebugLabel(this);
    objc_msgSend(*((id *)this + 33), "endEncoding");
    ++*((_DWORD *)this + 442);
    ++*((_DWORD *)this + 444);
    kdebug_trace();

    *((_QWORD *)this + 33) = 0;
  }
  if (*((_QWORD *)this + 32))
  {
    if (*((_DWORD *)this + 442) >= a2
      || *((_QWORD *)this + 38) >= a3
      || (v8 = atomic_load((unint64_t *)this + 225), *((_QWORD *)this + 38) + v8 >= a4))
    {
      HGMetalHandler::_commitCommandBuffer(this);

      *((_QWORD *)this + 32) = 0;
    }
  }
}

void HGMetalHandler::_commitCommandBuffer(HGMetalHandler *this)
{
  _QWORD *v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  void *v9;
  _DWORD v10[4];
  _QWORD v11[8];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v16[4];
  _BYTE v17[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v17, "metal", 2, "HGMetalHandler::_commitCommandBuffer()");
  v16[0] = 0;
  v16[1] = v16;
  v16[2] = 0x2020000000;
  v16[3] = *((_QWORD *)this + 34);
  v2 = (_QWORD *)operator new();
  *v2 = 0;
  v2[1] = 0;
  v2[2] = 0;
  *((_QWORD *)this + 34) = v2;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 280, *((_QWORD **)this + 36));
  *((_QWORD *)this + 36) = 0;
  *((_QWORD *)this + 37) = 0;
  *((_QWORD *)this + 35) = (char *)this + 288;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = *((_QWORD *)this + 38);
  v3 = (unint64_t *)((char *)this + 1792);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 + 1, v3));
  v5 = v13[3];
  v6 = (unint64_t *)((char *)this + 1800);
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 + v5, v6));
  *((_QWORD *)this + 38) = 0;
  v8 = *(unsigned int *)(*((_QWORD *)this + 18) + 1016);
  atomic_load((unint64_t *)this + 224);
  atomic_load((unint64_t *)this + 225);
  kdebug_trace();
  v9 = (void *)*((_QWORD *)this + 32);
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = ___ZN14HGMetalHandler20_commitCommandBufferEv_block_invoke;
  v11[3] = &unk_1E6524F40;
  v11[6] = this;
  v11[7] = v8;
  v11[4] = &v12;
  v11[5] = v16;
  objc_msgSend(v9, "addCompletedHandler:", v11);
  objc_msgSend(*((id *)this + 32), "commit");
  HGGPURenderer::SetLastMetalCmdBuffer(*((_QWORD *)this + 18), *((void **)this + 32));
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)this + 18) + 128))(*((_QWORD *)this + 18), 41))
  {
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v10, "metal", 1, "HGMetalHandler::_commitCommandBuffer() -- and wait...");
    objc_msgSend(*((id *)this + 32), "waitUntilCompleted");
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v10);
  }
  v10[0] = 4648;
  kdebug_trace();
  HGMetalHandler::_waitForCommandBuffers(this, *(unsigned int *)(*((_QWORD *)this + 31) + 80), *(unsigned int *)(*((_QWORD *)this + 31) + 84), *(_QWORD *)(*((_QWORD *)this + 31) + 88));
  kdebug_trace();
  ++*((_DWORD *)this + 445);
  kdebug_trace();
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(v16, 8);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v17);
}

void sub_1B2A64E88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  uint64_t v19;

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Block_object_dispose(&a19, 8);
  _Block_object_dispose((const void *)(v19 - 80), 8);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v19 - 48));
  _Unwind_Resume(a1);
}

void HGMetalHandler::FinalizeCommandBuffer(HGMetalHandler *this)
{
  HGMetalHandler::FinalizeCommandEncoder(this, 1u, 1uLL, 1uLL);
}

uint64_t HGMetalHandler::FrameEnd(uint64_t this)
{
  *(_QWORD *)(this + 1772) = 0;
  *(_DWORD *)(this + 1780) = 0;
  if (*(_QWORD *)(this + 144))
  {
    kdebug_trace();
    kdebug_trace();
    return kdebug_trace();
  }
  return this;
}

_DWORD *HGMetalHandler::GetFrameCounters(_DWORD *this, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  *a2 = this[443];
  *a3 = this[444];
  *a4 = this[445];
  return this;
}

uint64_t HGMetalHandler::WaitForCommandBuffersCount(HGMetalHandler *this, unint64_t a2)
{
  kdebug_trace();
  HGMetalHandler::_waitForCommandBuffers(this, 0, a2, 0xFFFFFFFFFFFFFFFFLL);
  return kdebug_trace();
}

void sub_1B2A6502C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  _Unwind_Resume(a1);
}

void HGMetalHandler::_waitForCommandBuffers(HGMetalHandler *this, unint64_t a2, unint64_t a3, unint64_t a4)
{
  std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  std::chrono::system_clock::time_point v12;
  std::unique_lock<std::mutex> v13;

  v13.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 1808);
  v13.__owns_ = 1;
  std::mutex::lock((std::mutex *)((char *)this + 1808));
  while (1)
  {
    v9 = atomic_load((unint64_t *)this + 224);
    if (v9 <= a3)
    {
      v10 = atomic_load((unint64_t *)this + 224);
      if (v10 <= a2)
        break;
      v11 = atomic_load((unint64_t *)this + 225);
      if (v11 <= a4)
        break;
    }
    std::chrono::steady_clock::now();
    v12.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    v8.__d_.__rep_ = 15000000;
    if (!v12.__d_.__rep_)
      goto LABEL_3;
    if (v12.__d_.__rep_ < 1)
    {
      if ((unint64_t)v12.__d_.__rep_ < 0xFFDF3B645A1CAC09)
      {
        v8.__d_.__rep_ = 0x8000000000E4E1C0;
        goto LABEL_3;
      }
    }
    else if ((unint64_t)v12.__d_.__rep_ > 0x20C49BA5E353F7)
    {
      goto LABEL_2;
    }
    if (v12.__d_.__rep_ >= 0x20C49BA5E31960)
    {
LABEL_2:
      v8.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
      goto LABEL_3;
    }
    v8.__d_.__rep_ = 1000 * v12.__d_.__rep_ + 15000000;
LABEL_3:
    std::condition_variable::__do_timed_wait((std::condition_variable *)this + 39, &v13, v8);
    std::chrono::steady_clock::now();
  }
  if (v13.__owns_)
    std::mutex::unlock(v13.__m_);
}

char *HGMetalHandler::_updateVerticesBuffer(uint64_t a1, void *a2)
{
  uint64_t v4;
  id *v5;
  HGMetalContext *v6;
  void *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;

  v4 = *(_QWORD *)(a1 + 312);
  if (!*(_BYTE *)(a1 + 320))
    return HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(v4 + 64), 576, *(_QWORD *)(a1 + 1376), a2);
  v5 = *(id **)(v4 + 72);
  if (!v5)
  {
    v6 = *(HGMetalContext **)(a1 + 248);
    v7 = *(void **)(*((_QWORD *)v6 + 2) + 16);
    v8 = (uint64_t *)HGMetalContext::bufferPool(v6);
    HGMetalBuffer::create(v7, v8, *(_QWORD *)(a1 + 1376), &v13);
    v9 = *(_QWORD *)(a1 + 312);
    v10 = *(_QWORD *)(v9 + 72);
    v11 = v13;
    if (v10 == v13)
    {
      if (v10)
        (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
    }
    else
    {
      if (v10)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
        v11 = v13;
      }
      *(_QWORD *)(v9 + 72) = v11;
    }
    v5 = *(id **)(*(_QWORD *)(a1 + 312) + 72);
  }
  return HGMetalBuffer::ModifyRangeAndMarkAsDirty(v5, 0, *(_QWORD *)(a1 + 1376), a2);
}

void sub_1B2A65270(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(exception_object);
}

char *HGMetalHandler::_updateTexCoordsBuffer(char *result, void *a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  id *v6;
  unint64_t v7;
  HGMetalContext *v8;
  void *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v3 = (uint64_t)result;
  v4 = *((unsigned int *)result + 122);
  if (result[320])
  {
    if (*((_DWORD *)result + 122))
    {
      v5 = 11;
      do
      {
        if (((*(_DWORD *)(v3 + 484) >> (v5 - 11)) & 1) != 0)
        {
          v6 = *(id **)(*(_QWORD *)(v3 + 312) + 8 * v5);
          if (!v6)
          {
            v8 = *(HGMetalContext **)(v3 + 248);
            v9 = *(void **)(*((_QWORD *)v8 + 2) + 16);
            v10 = (uint64_t *)HGMetalContext::bufferPool(v8);
            HGMetalBuffer::create(v9, v10, *(_QWORD *)(v3 + 1392), &v16);
            v11 = *(_QWORD *)(v3 + 312);
            v12 = *(_QWORD *)(v11 + 8 * v5);
            v13 = v16;
            if (v12 == v16)
            {
              if (v12)
                (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
            }
            else
            {
              if (v12)
              {
                (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
                v13 = v16;
              }
              *(_QWORD *)(v11 + 8 * v5) = v13;
            }
            v6 = *(id **)(*(_QWORD *)(v3 + 312) + 8 * v5);
          }
          result = HGMetalBuffer::ModifyRangeAndMarkAsDirty(v6, 0, *(_QWORD *)(v3 + 1392), a2);
          v4 = *(unsigned int *)(v3 + 488);
        }
        v7 = v5 - 10;
        ++v5;
      }
      while (v7 < v4);
    }
  }
  else if (*((_DWORD *)result + 122))
  {
    v14 = 0;
    v15 = 640;
    do
    {
      if (((*(_DWORD *)(v3 + 484) >> v14) & 1) != 0)
      {
        result = HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*(_QWORD *)(v3 + 312) + 64), v15, *(_QWORD *)(v3 + 1392), a2);
        v4 = *(unsigned int *)(v3 + 488);
      }
      ++v14;
      v15 += 64;
    }
    while (v14 < v4);
  }
  return result;
}

void sub_1B2A653DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(exception_object);
}

void HGMetalHandler::_setCommandBufferDebugLabel(HGMetalHandler *this)
{
  void **v2;
  std::string *v3;
  std::string v4;

  std::to_string(&v4, *((_DWORD *)this + 445) + 1);
  v2 = (void **)((char *)this + 1344);
  if (*((char *)this + 1367) < 0)
    operator delete(*v2);
  *(_OWORD *)v2 = *(_OWORD *)&v4.__r_.__value_.__l.__data_;
  *((_QWORD *)this + 170) = *((_QWORD *)&v4.__r_.__value_.__l + 2);
  std::operator+<char>();
  if ((v4.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v3 = &v4;
  else
    v3 = (std::string *)v4.__r_.__value_.__r.__words[0];
  objc_msgSend(*((id *)this + 32), "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v3));
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v4.__r_.__value_.__l.__data_);
}

void sub_1B2A654C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGMetalHandler::_setupCommandEncoder(HGMetalHandler *this)
{
  const char *v2;
  char *v3;
  void *v4;
  uint64_t v5;
  char *v6;
  void *v7;
  const char *v8;
  char *v9;
  unsigned __int8 v10;
  std::string *p_p;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  char *v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  void *v19;
  const char *v20;
  char *v21;
  unsigned __int8 v22;
  void *v23;
  id v24;
  uint64_t v25;
  int v26;
  int TextureRect;
  int v28;
  int v29;
  void *v30;
  int32x2_t v31;
  uint64x2_t v32;
  const char *v33;
  char *v34;
  unsigned __int8 v35;
  unsigned __int8 v36;
  uint64_t *DepthStencilState;
  int v38;
  size_t v39;
  unint64_t v40;
  std::string *p_dst;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  std::string *v45;
  std::string::size_type size;
  std::string *v47;
  __int128 v48;
  std::string *v49;
  std::string::size_type v50;
  char v51;
  std::string v52;
  std::string __dst;
  double v54[2];
  float64x2_t v55;
  __int128 v56;
  std::string __p;
  _BYTE v58[16];
  _QWORD v59[5];

  v59[2] = *MEMORY[0x1E0C80C00];
  if (!*((_QWORD *)this + 33) && *((_BYTE *)this + 1785))
  {
    if (HGRectIsNull(*(_QWORD *)(*((_QWORD *)this + 41) + 20), *(_QWORD *)(*((_QWORD *)this + 41) + 28)))
    {
      *((_BYTE *)this + 1785) = 0;
      HGLogger::warning((HGLogger *)"HGMetalHandler::_setupCommandEncoder -- null buffer target!!", v2, v3);
      return;
    }
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v58, "metal", 2, "HGMetalHandler::_createCommandBufferAndEncoder()");
    v4 = (void *)objc_msgSend(MEMORY[0x1E0CC6B50], "renderPassDescriptor");
    v5 = 0;
    v6 = (char *)this + 392;
    do
    {
      if (*(_QWORD *)&v6[8 * v5])
      {
        v7 = (void *)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v5);
        objc_msgSend(v7, "setTexture:", *(_QWORD *)(*(_QWORD *)&v6[8 * v5] + 144));
        v10 = atomic_load(HGLogger::_enabled);
        if ((v10 & 1) != 0)
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"destination texture [%d] (%p)\n", v8, v9, v5, *(_QWORD *)&v6[8 * v5]);
        std::operator+<char>();
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_p = &__p;
        else
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        objc_msgSend((id)objc_msgSend(v7, "texture"), "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", p_p));
        if (*((_QWORD *)this + 58))
          v12 = 2;
        else
          v12 = 1;
        objc_msgSend(v7, "setStoreAction:", v12);
        if (*(_BYTE *)(*(_QWORD *)&v6[8 * v5] + 168))
          v13 = 1;
        else
          v13 = 2;
        objc_msgSend(v7, "setLoadAction:", v13);
        objc_msgSend(v7, "setClearColor:", 0.0, 0.0, 0.0, 0.0);
        *(_BYTE *)(*(_QWORD *)&v6[8 * v5] + 168) = 1;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }
      ++v5;
    }
    while (v5 != 8);
    v14 = *((_QWORD *)this + 58);
    if (v14)
    {
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setResolveTexture:", *(_QWORD *)(v14 + 144));
      v17 = atomic_load(HGLogger::_enabled);
      if ((v17 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"destination resolve texture (%p)\n", v15, v16, *((_QWORD *)this + 58));
      v18 = atomic_load(HGLogger::_enabled);
      if ((v18 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"MSAA samples: %d\n", v15, v16, *((unsigned int *)this + 118));
    }
    if (*((_QWORD *)this + 57))
    {
      v19 = (void *)objc_msgSend(v4, "depthAttachment");
      objc_msgSend(v19, "setStoreAction:", 0);
      objc_msgSend(v19, "setLoadAction:", 2);
      objc_msgSend(v19, "setClearDepth:", 1.0);
      objc_msgSend(v19, "setTexture:", *(_QWORD *)(*((_QWORD *)this + 57) + 144));
      v22 = atomic_load(HGLogger::_enabled);
      if ((v22 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"depth texture (%p)\n", v20, v21, *((_QWORD *)this + 57));
    }
    v23 = (void *)objc_msgSend(*((id *)this + 32), "renderCommandEncoderWithDescriptor:", v4);
    *((_QWORD *)this + 33) = v23;
    v24 = v23;
    objc_msgSend(*((id *)this + 33), "setFrontFacingWinding:", 1);
    v25 = *((_QWORD *)this + 58);
    if (!v25)
      v25 = *((_QWORD *)this + 49);
    v26 = *(_DWORD *)(v25 + 20);
    TextureRect = HGMetalTexture::GetTextureRect((HGMetalTexture *)v25);
    v28 = *(_DWORD *)(v25 + 24);
    v29 = v28 - ((unint64_t)HGMetalTexture::GetTextureRect((HGMetalTexture *)v25) >> 32);
    v30 = (void *)*((_QWORD *)this + 33);
    v54[0] = (double)(v26 - TextureRect);
    v54[1] = (double)v29;
    v31 = vsub_s32(*(int32x2_t *)(v25 + 28), *(int32x2_t *)(v25 + 20));
    v32.i64[0] = v31.u32[0];
    v32.i64[1] = v31.u32[1];
    v55 = vcvtq_f64_u64(v32);
    v56 = xmmword_1B304EEE0;
    objc_msgSend(v30, "setViewport:", v54);
    if (*((_QWORD *)this + 57))
    {
      __p.__r_.__value_.__s.__data_[0] = 1;
      v35 = atomic_load(HGLogger::_enabled);
      if ((v35 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"depth writing: enabled\n", v33, v34);
      __p.__r_.__value_.__l.__size_ = 1;
      v36 = atomic_load(HGLogger::_enabled);
      if ((v36 & 1) != 0)
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"depth compare function: less\n", v33, v34);
      DepthStencilState = HGMetalDepthStencilStateCache::getDepthStencilState(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 31) + 24) + 160), (unsigned __int8 *)&__p);
      objc_msgSend(*((id *)this + 33), "setDepthStencilState:", DepthStencilState);

    }
    v38 = *((char *)this + 1367);
    if (v38 >= 0)
      v39 = *((unsigned __int8 *)this + 1367);
    else
      v39 = *((_QWORD *)this + 169);
    v40 = v39 + 1;
    if (v39 + 1 >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    if (v40 >= 0x17)
    {
      v42 = (v40 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v40 | 7) != 0x17)
        v42 = v40 | 7;
      v43 = v42 + 1;
      p_dst = (std::string *)operator new(v42 + 1);
      __dst.__r_.__value_.__l.__size_ = v39 + 1;
      __dst.__r_.__value_.__r.__words[2] = v43 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      p_dst = &__dst;
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v39 + 1;
      if (!v39)
        goto LABEL_52;
    }
    if (v38 >= 0)
      v44 = (char *)this + 1344;
    else
      v44 = (char *)*((_QWORD *)this + 168);
    memmove(p_dst, v44, v39);
LABEL_52:
    *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v39) = 46;
    std::to_string(&v52, *((_DWORD *)this + 442) + 1);
    if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v45 = &v52;
    else
      v45 = (std::string *)v52.__r_.__value_.__r.__words[0];
    if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v52.__r_.__value_.__r.__words[2]);
    else
      size = v52.__r_.__value_.__l.__size_;
    v47 = std::string::append(&__dst, (const std::string::value_type *)v45, size);
    v48 = *(_OWORD *)&v47->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v47->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v48;
    v47->__r_.__value_.__l.__size_ = 0;
    v47->__r_.__value_.__r.__words[2] = 0;
    v47->__r_.__value_.__r.__words[0] = 0;
    v49 = std::string::append(&__p, " ");
    v50 = v49->__r_.__value_.__r.__words[0];
    v59[0] = v49->__r_.__value_.__l.__size_;
    *(_QWORD *)((char *)v59 + 7) = *(std::string::size_type *)((char *)&v49->__r_.__value_.__r.__words[1] + 7);
    v51 = HIBYTE(v49->__r_.__value_.__r.__words[2]);
    v49->__r_.__value_.__l.__size_ = 0;
    v49->__r_.__value_.__r.__words[2] = 0;
    v49->__r_.__value_.__r.__words[0] = 0;
    if (*((char *)this + 1343) < 0)
      operator delete(*((void **)this + 165));
    *((_QWORD *)this + 165) = v50;
    *((_QWORD *)this + 166) = v59[0];
    *(_QWORD *)((char *)this + 1335) = *(_QWORD *)((char *)v59 + 7);
    *((_BYTE *)this + 1343) = v51;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_62:
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_63:
          *((_BYTE *)this + 1784) = 1;
          *((_DWORD *)this + 441) = 0;
          HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v58);
          return;
        }
LABEL_66:
        operator delete(__dst.__r_.__value_.__l.__data_);
        goto LABEL_63;
      }
    }
    else if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_62;
    }
    operator delete(v52.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_63;
    goto LABEL_66;
  }
}

void sub_1B2A65AC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a26);
  _Unwind_Resume(a1);
}

void sub_1B2A65AD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a26);
  _Unwind_Resume(a1);
}

void sub_1B2A65AEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35)
{
  if (a34 < 0)
  {
    operator delete(__p);
    if ((a16 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a22 & 0x80000000) == 0)
      {
LABEL_8:
        HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a35);
        _Unwind_Resume(a1);
      }
LABEL_7:
      operator delete(a17);
      goto LABEL_8;
    }
  }
  else if ((a16 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a11);
  if ((a22 & 0x80000000) == 0)
    goto LABEL_8;
  goto LABEL_7;
}

void HGMetalHandler::_updatePipelineState(HGMetalHandler *this)
{
  void *v2;
  uint64_t v3;
  char v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  __int128 v20;
  const char *v21;
  void *RenderPipelineState;
  uint64_t v23;
  __int128 v24;
  _BYTE v25[24];
  uint64_t v26;
  __int128 v27;
  _BYTE v28[24];
  uint64_t v29;
  __int128 v30;
  _BYTE v31[24];
  uint64_t v32;
  _BYTE v33[40];
  uint64_t v34;
  __int128 v35;
  _BYTE v36[24];
  uint64_t v37;
  __int128 v38;
  _BYTE v39[24];
  uint64_t v40;
  _BYTE v41[40];
  uint64_t v42;
  __int128 v43;
  _BYTE v44[32];
  uint64_t v45;
  uint64_t v46;
  void *__p;
  void *v48;
  uint64_t v49;
  _BYTE v50[16];

  if (*((_BYTE *)this + 1784))
  {
    v2 = (void *)*((_QWORD *)this + 176);
    if (v2)

    *((_QWORD *)this + 176) = 0;
  }
  if (*((_BYTE *)this + 1785) && !*((_QWORD *)this + 176))
  {
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v50, "metal", 2, "HGMetalHandler::_createPipelineState()");
    LODWORD(v23) = 0;
    *(_QWORD *)&v24 = 0;
    *((_QWORD *)&v24 + 1) = 1;
    *(_DWORD *)v25 = 1;
    *(_QWORD *)&v25[4] = 0;
    *(_QWORD *)&v25[9] = 0;
    LODWORD(v26) = 0;
    *(_QWORD *)&v27 = 0;
    *((_QWORD *)&v27 + 1) = 1;
    *(_DWORD *)v28 = 1;
    *(_QWORD *)&v28[4] = 0;
    *(_QWORD *)&v28[9] = 0;
    LODWORD(v29) = 0;
    *(_QWORD *)&v30 = 0;
    *((_QWORD *)&v30 + 1) = 1;
    *(_DWORD *)v31 = 1;
    *(_QWORD *)&v31[4] = 0;
    *(_QWORD *)&v31[9] = 0;
    LODWORD(v32) = 0;
    *(_QWORD *)v33 = 0;
    *(_QWORD *)&v33[8] = 1;
    *(_QWORD *)&v33[25] = 0;
    *(_QWORD *)&v33[20] = 0;
    *(_DWORD *)&v33[16] = 1;
    LODWORD(v34) = 0;
    *(_QWORD *)&v35 = 0;
    *((_QWORD *)&v35 + 1) = 1;
    *(_QWORD *)&v36[4] = 0;
    *(_QWORD *)&v36[9] = 0;
    *(_DWORD *)v36 = 1;
    LODWORD(v37) = 0;
    *(_QWORD *)&v38 = 0;
    *((_QWORD *)&v38 + 1) = 1;
    *(_DWORD *)v39 = 1;
    *(_QWORD *)&v39[4] = 0;
    *(_QWORD *)&v39[9] = 0;
    LODWORD(v40) = 0;
    *(_QWORD *)v41 = 0;
    *(_QWORD *)&v41[8] = 1;
    *(_DWORD *)&v41[16] = 1;
    *(_QWORD *)&v41[25] = 0;
    *(_QWORD *)&v41[20] = 0;
    LODWORD(v42) = 0;
    *(_QWORD *)&v43 = 0;
    *((_QWORD *)&v43 + 1) = 1;
    *(_DWORD *)v44 = 1;
    *(_QWORD *)&v44[4] = 0;
    *(_QWORD *)&v44[9] = 0;
    __p = 0;
    v48 = 0;
    *(_DWORD *)&v44[24] = *((_DWORD *)this + 118);
    v44[28] = *((_QWORD *)this + 57) != 0;
    v3 = *((_QWORD *)this + 178);
    v45 = *((_QWORD *)this + 177);
    v46 = v3;
    v49 = 0;
    if (&__p != (void **)((char *)this + 1432))
      std::vector<HGMTLFunctionType>::__assign_with_size[abi:ne180100]<HGMTLFunctionType*,HGMTLFunctionType*>(&__p, *((char **)this + 179), *((char **)this + 180), (uint64_t)(*((_QWORD *)this + 180) - *((_QWORD *)this + 179)) >> 3);
    v4 = *((_BYTE *)this + 1456);
    v5 = *((_QWORD *)this + 49);
    if (v5)
      LODWORD(v5) = *(_DWORD *)(v5 + 16);
    LODWORD(v23) = v5;
    if ((v4 & 1) != 0)
    {
      v25[16] = 1;
      v6 = *(_OWORD *)((char *)this + 1480);
      v24 = *(_OWORD *)((char *)this + 1464);
      *(_OWORD *)v25 = v6;
    }
    v7 = *((_QWORD *)this + 50);
    if (v7)
      LODWORD(v7) = *(_DWORD *)(v7 + 16);
    LODWORD(v26) = v7;
    if ((v4 & 2) != 0)
    {
      v28[16] = 1;
      v8 = *(_OWORD *)((char *)this + 1512);
      v27 = *(_OWORD *)((char *)this + 1496);
      *(_OWORD *)v28 = v8;
    }
    v9 = *((_QWORD *)this + 51);
    if (v9)
      LODWORD(v9) = *(_DWORD *)(v9 + 16);
    LODWORD(v29) = v9;
    if ((v4 & 4) != 0)
    {
      v31[16] = 1;
      v10 = *(_OWORD *)((char *)this + 1544);
      v30 = *(_OWORD *)((char *)this + 1528);
      *(_OWORD *)v31 = v10;
    }
    v11 = *((_QWORD *)this + 52);
    if (v11)
      LODWORD(v11) = *(_DWORD *)(v11 + 16);
    LODWORD(v32) = v11;
    if ((v4 & 8) != 0)
    {
      v33[32] = 1;
      v12 = *(_OWORD *)((char *)this + 1576);
      *(_OWORD *)v33 = *(_OWORD *)((char *)this + 1560);
      *(_OWORD *)&v33[16] = v12;
    }
    v13 = *((_QWORD *)this + 53);
    if (v13)
      LODWORD(v13) = *(_DWORD *)(v13 + 16);
    LODWORD(v34) = v13;
    if ((v4 & 0x10) != 0)
    {
      v36[16] = 1;
      v14 = *(_OWORD *)((char *)this + 1608);
      v35 = *(_OWORD *)((char *)this + 1592);
      *(_OWORD *)v36 = v14;
    }
    v15 = *((_QWORD *)this + 54);
    if (v15)
      LODWORD(v15) = *(_DWORD *)(v15 + 16);
    LODWORD(v37) = v15;
    if ((v4 & 0x20) != 0)
    {
      v39[16] = 1;
      v16 = *(_OWORD *)((char *)this + 1640);
      v38 = *(_OWORD *)((char *)this + 1624);
      *(_OWORD *)v39 = v16;
    }
    v17 = *((_QWORD *)this + 55);
    if (v17)
      LODWORD(v17) = *(_DWORD *)(v17 + 16);
    LODWORD(v40) = v17;
    if ((v4 & 0x40) != 0)
    {
      v41[32] = 1;
      v18 = *(_OWORD *)((char *)this + 1672);
      *(_OWORD *)v41 = *(_OWORD *)((char *)this + 1656);
      *(_OWORD *)&v41[16] = v18;
    }
    v19 = *((_QWORD *)this + 56);
    if (v19)
      LODWORD(v19) = *(_DWORD *)(v19 + 16);
    LODWORD(v42) = v19;
    if (v4 < 0)
    {
      v44[16] = 1;
      v20 = *(_OWORD *)((char *)this + 1704);
      v43 = *(_OWORD *)((char *)this + 1688);
      *(_OWORD *)v44 = v20;
    }
    RenderPipelineState = HGMetalRenderPipelineStateCache::getRenderPipelineState(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 31) + 24) + 144), (int *)&v23);
    *((_QWORD *)this + 176) = RenderPipelineState;
    if (RenderPipelineState)
    {
      objc_msgSend(*((id *)this + 33), "setRenderPipelineState:", RenderPipelineState, v23, v24, *(_OWORD *)v25, *(_QWORD *)&v25[16], v26, v27, *(_OWORD *)v28, *(_QWORD *)&v28[16], v29, v30, *(_OWORD *)v31, *(_QWORD *)&v31[16], v32, *(_QWORD *)v33, *(_OWORD *)&v33[8], *(_OWORD *)&v33[24],
        v34,
        v35,
        *(_OWORD *)v36,
        *(_QWORD *)&v36[16],
        v37,
        v38,
        *(_OWORD *)v39,
        *(_QWORD *)&v39[16],
        v40,
        *(_QWORD *)v41,
        *(_OWORD *)&v41[8],
        *(_OWORD *)&v41[24],
        v42,
        v43,
        *(_OWORD *)v44,
        *(_OWORD *)&v44[16],
        v45,
        v46);
    }
    else
    {
      *((_BYTE *)this + 1785) = 0;
      HGLogger::warning((HGLogger *)"nil pipeline state.", v21, 0, v23, v24, *(_OWORD *)v25, *(_QWORD *)&v25[16], v26, v27, *(_OWORD *)v28, *(_QWORD *)&v28[16], v29, v30, *(_OWORD *)v31, *(_QWORD *)&v31[16], v32, *(_QWORD *)v33, *(_OWORD *)&v33[8], *(_OWORD *)&v33[24],
        v34,
        v35,
        *(_OWORD *)v36,
        *(_QWORD *)&v36[16],
        v37,
        v38,
        *(_OWORD *)v39,
        *(_QWORD *)&v39[16],
        v40,
        *(_QWORD *)v41,
        *(_OWORD *)&v41[8],
        *(_OWORD *)&v41[24],
        v42,
        v43,
        *(_OWORD *)v44,
        *(_OWORD *)&v44[16],
        v45,
        v46);
    }
    if (__p)
    {
      v48 = __p;
      operator delete(__p);
    }
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v50);
    *((_BYTE *)this + 1784) = 0;
  }
  else
  {
    *((_BYTE *)this + 1784) = 0;
  }
}

void sub_1B2A65FB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,void *__p,uint64_t a61)
{
  uint64_t v61;

  if (__p)
    operator delete(__p);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v61 - 48));
  _Unwind_Resume(a1);
}

void HGMetalHandler::_validateMetalFunctions(HGMetalHandler *this, const char *a2, char *a3)
{
  std::string *v4;
  __int128 v5;
  std::string *v6;
  std::string::size_type size;
  unint64_t v8;
  std::string *v9;
  __int128 v10;
  std::string *v11;
  std::string::size_type v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t *Function;
  void **v16;
  std::string::size_type v17;
  std::string *v18;
  __int128 v19;
  HGMetalUtils *v20;
  void **v21;
  std::string::size_type v22;
  std::string *v23;
  __int128 v24;
  uint64_t *v25;
  void *__p[2];
  unsigned __int8 v27;
  void *v28[2];
  unsigned __int8 v29;
  std::string v30;
  std::string v31;
  std::string v32;
  std::string v33;

  if (*((_QWORD *)this + 178))
  {
    if (*((_QWORD *)this + 177))
      return;
  }
  else
  {
    HGLogger::warning((HGLogger *)"missing fragment function.", a2, a3);
    if (*((_QWORD *)this + 177))
      return;
  }
  std::to_string(&v32, *((_DWORD *)this + 122));
  v4 = std::string::insert(&v32, 0, "NumTexcoords:");
  v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v33.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v6 = &v33;
  else
    v6 = (std::string *)v33.__r_.__value_.__r.__words[0];
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v33.__r_.__value_.__r.__words[2]);
  else
    size = v33.__r_.__value_.__l.__size_;
  v8 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v31, (uint64_t *)v6, size);
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v33.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_13;
  }
  else if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_13;
  }
  operator delete(v32.__r_.__value_.__l.__data_);
LABEL_13:
  std::to_string(&v32, *((unsigned __int8 *)this + 492));
  v9 = std::string::insert(&v32, 0, "UseVertexColors:");
  v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v33.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = &v33;
  else
    v11 = (std::string *)v33.__r_.__value_.__r.__words[0];
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v12 = HIBYTE(v33.__r_.__value_.__r.__words[2]);
  else
    v12 = v33.__r_.__value_.__l.__size_;
  v13 = v8 ^ (2
            * std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v31, (uint64_t *)v11, v12));
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v33.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_21;
  }
  else if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_21;
  }
  operator delete(v32.__r_.__value_.__l.__data_);
LABEL_21:
  *((_BYTE *)&v33.__r_.__value_.__s + 23) = 10;
  strcpy((char *)&v33, "vertexFunc");
  v14 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 31) + 24) + 168);
  Function = HGMetalFunctionCache::getFunction(v14, &v33, v13);
  if (!Function)
  {
    HGMetalUtils::stringForMetalHeader((uint64_t)&v30);
    HGMetalUtils::stringForMetalVertexOutputStruct((HGMetalUtils *)*((unsigned int *)this + 122), *((_BYTE *)this + 492), (uint64_t)v28);
    if ((v29 & 0x80u) == 0)
      v16 = v28;
    else
      v16 = (void **)v28[0];
    if ((v29 & 0x80u) == 0)
      v17 = v29;
    else
      v17 = (std::string::size_type)v28[1];
    v18 = std::string::append(&v30, (const std::string::value_type *)v16, v17);
    v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v20 = (HGMetalUtils *)&v33;
    else
      v20 = (HGMetalUtils *)v33.__r_.__value_.__r.__words[0];
    HGMetalUtils::stringForMetalVertexShader(v20, (const char *)*((unsigned int *)this + 122), *((_BYTE *)this + 492), (uint64_t)__p);
    if ((v27 & 0x80u) == 0)
      v21 = __p;
    else
      v21 = (void **)__p[0];
    if ((v27 & 0x80u) == 0)
      v22 = v27;
    else
      v22 = (std::string::size_type)__p[1];
    v23 = std::string::append(&v31, (const std::string::value_type *)v21, v22);
    v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    if ((char)v27 < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_39:
        if (((char)v29 & 0x80000000) == 0)
          goto LABEL_40;
        goto LABEL_51;
      }
    }
    else if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_39;
    }
    operator delete(v31.__r_.__value_.__l.__data_);
    if (((char)v29 & 0x80000000) == 0)
    {
LABEL_40:
      if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_41;
LABEL_52:
      operator delete(v30.__r_.__value_.__l.__data_);
LABEL_41:
      Function = HGMetalFunctionCache::getFunctionWithSource(v14, &v33, v13, (uint64_t *)&v32);
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v32.__r_.__value_.__l.__data_);
      goto LABEL_43;
    }
LABEL_51:
    operator delete(v28[0]);
    if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_41;
    goto LABEL_52;
  }
LABEL_43:
  *((_QWORD *)this + 177) = Function;
  v25 = Function;
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v33.__r_.__value_.__l.__data_);
}

void sub_1B2A662FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;

  if (*(char *)(v33 - 73) < 0)
    operator delete(*(void **)(v33 - 96));
  if (*(char *)(v33 - 41) < 0)
    operator delete(*(void **)(v33 - 64));
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalHandler::_setupScissorRect(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  _QWORD v12[4];
  __int128 v13;

  if (*(_BYTE *)(this + 1785))
  {
    v1 = this;
    if (*(_BYTE *)(this + 1744))
    {
      *(_QWORD *)&v13 = HGRectIntersection(*(_QWORD *)(this + 1748), *(_QWORD *)(this + 1756), *(_QWORD *)(*(_QWORD *)(this + 328) + 20), *(_QWORD *)(*(_QWORD *)(this + 328) + 28));
      *((_QWORD *)&v13 + 1) = v2;
      v3 = *(_QWORD *)(v1 + 328);
    }
    else
    {
      v3 = *(_QWORD *)(this + 328);
      v13 = *(_OWORD *)(v3 + 20);
    }
    v4 = HGFormatUtils::collapseRectForFormat((uint64_t *)&v13, *(_DWORD *)(v3 + 16));
    v5 = v4;
    v7 = v6;
    v8 = HIDWORD(v4);
    v9 = v4 - HGMetalTexture::GetTextureRect(*(HGMetalTexture **)(v1 + 392));
    v10 = (v8 - ((unint64_t)HGMetalTexture::GetTextureRect(*(HGMetalTexture **)(v1 + 392)) >> 32));
    v11 = *(void **)(v1 + 264);
    v12[0] = v9;
    v12[1] = v10;
    v12[2] = (v7 - v5);
    v12[3] = (HIDWORD(v7) - v8);
    return objc_msgSend(v11, "setScissorRect:", v12);
  }
  return this;
}

void HGMetalHandler::_setCommandEncoderDebugLabel(HGMetalHandler *this)
{
  const std::string::value_type *v2;
  unint64_t v3;
  const std::string::value_type *v4;
  const std::string::value_type *v5;
  const std::string::value_type *v6;
  BOOL v7;
  unint64_t v8;
  std::string::size_type v9;
  unsigned int v10;
  std::string *v11;
  __int128 v12;
  std::string *v13;
  __int128 v14;
  void **v15;
  std::string::size_type v16;
  std::string *v17;
  std::string v18;
  std::string v19;
  void *__p[2];
  int64_t v21;
  std::string v22;

  if ((*((char *)this + 1343) & 0x80000000) == 0)
  {
    v2 = (char *)this + 1320;
    v3 = *((unsigned __int8 *)this + 1343);
    v4 = (char *)this + v3 + 1320;
    if (*((_BYTE *)this + 1343))
      goto LABEL_3;
LABEL_14:
    v6 = v4;
    goto LABEL_15;
  }
  v2 = (const std::string::value_type *)*((_QWORD *)this + 165);
  v3 = *((_QWORD *)this + 166);
  v4 = &v2[v3];
  if (!v3)
    goto LABEL_14;
LABEL_3:
  v5 = v2;
  v6 = v4;
  while (1)
  {
    ++v5;
    while (*(v5 - 1) != 124)
    {
      v7 = v5++ == v4;
      if (v7)
        goto LABEL_15;
    }
    if (v5 == v4)
      break;
    if (*v5 == 32)
      v6 = v5 - 1;
  }
LABEL_15:
  v7 = v6 - v2 == -1 || v6 == v4;
  if (v7)
    v8 = v3;
  else
    v8 = v6 - v2;
  if (v8 >= 0x32)
    v9 = 50;
  else
    v9 = v8;
  *((_BYTE *)&v22.__r_.__value_.__s + 23) = 5;
  strcpy((char *)&v22, "HGCE ");
  std::string::append(&v22, v2, v9);
  if (v8 >= 0x33)
    std::string::append(&v22, " ... ");
  v10 = *((_DWORD *)this + 441);
  if (v10 >= 2)
  {
    std::to_string(&v18, v10);
    v11 = std::string::insert(&v18, 0, "(");
    v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v19.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    v13 = std::string::append(&v19, ")");
    v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v21 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    if (v21 >= 0)
      v15 = __p;
    else
      v15 = (void **)__p[0];
    if (v21 >= 0)
      v16 = HIBYTE(v21);
    else
      v16 = (std::string::size_type)__p[1];
    std::string::append(&v22, (const std::string::value_type *)v15, v16);
    if (SHIBYTE(v21) < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_35:
        if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_36;
LABEL_43:
        operator delete(v18.__r_.__value_.__l.__data_);
        goto LABEL_36;
      }
    }
    else if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_35;
    }
    operator delete(v19.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_36;
    goto LABEL_43;
  }
LABEL_36:
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = &v22;
  else
    v17 = (std::string *)v22.__r_.__value_.__r.__words[0];
  objc_msgSend(*((id *)this + 33), "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v17));
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
}

void sub_1B2A666BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;

  if (a28 < 0)
  {
    operator delete(__p);
    if ((a21 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a15 & 0x80000000) == 0)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else if ((a21 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a16);
  if ((a15 & 0x80000000) == 0)
  {
LABEL_4:
    if ((*(char *)(v28 - 17) & 0x80000000) == 0)
      goto LABEL_5;
    goto LABEL_9;
  }
LABEL_8:
  operator delete(a10);
  if ((*(char *)(v28 - 17) & 0x80000000) == 0)
LABEL_5:
    _Unwind_Resume(exception_object);
LABEL_9:
  operator delete(*(void **)(v28 - 40));
  _Unwind_Resume(exception_object);
}

void HGMetalHandler::_encodeSourceSampler(HGMetalHandler *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  uint64_t v7;
  int32x2_t *v8;
  int32x2_t v9;
  int8x16_t v10;
  unsigned __int8 v11;
  const char *v12;
  const char *v13;
  __int32 v14;
  const char *v15;
  char *v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  const char *v19;
  void *SamplerState;
  uint64_t v21;
  unsigned __int8 v22;
  int8x16_t v23;
  uint64_t v24;
  char v25;

  v7 = (int)a2;
  v8 = (int32x2_t *)((char *)this + 32 * (int)a2);
  v9 = vtst_s32(v8[62], v8[62]);
  v10.i64[0] = v9.u32[0];
  v10.i64[1] = v9.u32[1];
  v23 = vandq_s8(v10, (int8x16_t)vdupq_n_s64(1uLL));
  v11 = atomic_load(HGLogger::_enabled);
  if ((v11 & 1) != 0)
  {
    v12 = "linear";
    if (v23.i64[0])
      v13 = "linear";
    else
      v13 = "nearest";
    if (!v23.i64[1])
      v12 = "nearest";
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"%d: %s / %s\n", a4, a5, a2, v13, v12);
  }
  v14 = v8[63].i32[1];
  if (!*(_BYTE *)(PCICCTransferFunctionLUT::getLUTEnd(*((PCICCTransferFunctionLUT **)this + 31)) + 56))
  {
    v21 = *(_QWORD *)(*((_QWORD *)this + 39) + 8 * v7);
    if (v21)
    {
      if (!*(_BYTE *)(v21 + 169))
      {
        v24 = 0;
        v22 = atomic_load(HGLogger::_enabled);
        if ((v22 & 1) == 0)
          goto LABEL_12;
LABEL_11:
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"sampler address mode : ClampToEdge\n", v15, v16);
        goto LABEL_12;
      }
    }
  }
  v24 = 4 * (v14 != 1);
  if (v14 == 1)
  {
    v17 = atomic_load(HGLogger::_enabled);
    if ((v17 & 1) != 0)
      goto LABEL_11;
  }
LABEL_12:
  v25 = *((_BYTE *)this + 32 * v7 + 504);
  v18 = atomic_load(HGLogger::_enabled);
  if ((v18 & 1) != 0)
  {
    if (v25)
      v19 = "normalized";
    else
      v19 = "rectangular";
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"%d: %s\n", v15, v16, a2, v19);
  }
  SamplerState = HGMetalSamplerStateCache::getSamplerState(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 31) + 24) + 152), (uint64_t)&v23);
  objc_msgSend(*((id *)this + 33), "setFragmentSamplerState:atIndex:", SamplerState, v7);

}

void HGMetalHandler::CommandEncoderCargo::~CommandEncoderCargo(HGMetalHandler::CommandEncoderCargo *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v2 = *((_QWORD *)this + 30);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 29);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = *((_QWORD *)this + 28);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *((_QWORD *)this + 27);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  v6 = *((_QWORD *)this + 26);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  v7 = *((_QWORD *)this + 25);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  v8 = *((_QWORD *)this + 24);
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
  v9 = *((_QWORD *)this + 23);
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  v10 = *((_QWORD *)this + 22);
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  v11 = *((_QWORD *)this + 21);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
  v12 = *((_QWORD *)this + 20);
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
  v13 = *((_QWORD *)this + 19);
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
  v14 = *((_QWORD *)this + 18);
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
  v15 = *((_QWORD *)this + 17);
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 24))(v15);
  v16 = *((_QWORD *)this + 16);
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
  v17 = *((_QWORD *)this + 15);
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
  v18 = *((_QWORD *)this + 14);
  if (v18)
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
  v19 = *((_QWORD *)this + 13);
  if (v19)
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 24))(v19);
  v20 = *((_QWORD *)this + 12);
  if (v20)
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 24))(v20);
  v21 = *((_QWORD *)this + 11);
  if (v21)
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
  v22 = *((_QWORD *)this + 10);
  if (v22)
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 24))(v22);
  v23 = *((_QWORD *)this + 9);
  if (v23)
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 24))(v23);
  v24 = *((_QWORD *)this + 8);
  if (v24)
    (*(void (**)(uint64_t))(*(_QWORD *)v24 + 24))(v24);
  v25 = *((_QWORD *)this + 7);
  if (v25)
    (*(void (**)(uint64_t))(*(_QWORD *)v25 + 24))(v25);
  v26 = *((_QWORD *)this + 6);
  if (v26)
    (*(void (**)(uint64_t))(*(_QWORD *)v26 + 24))(v26);
  v27 = *((_QWORD *)this + 5);
  if (v27)
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 24))(v27);
  v28 = *((_QWORD *)this + 4);
  if (v28)
    (*(void (**)(uint64_t))(*(_QWORD *)v28 + 24))(v28);
  v29 = *((_QWORD *)this + 3);
  if (v29)
    (*(void (**)(uint64_t))(*(_QWORD *)v29 + 24))(v29);
  v30 = *((_QWORD *)this + 2);
  if (v30)
    (*(void (**)(uint64_t))(*(_QWORD *)v30 + 24))(v30);
  v31 = *((_QWORD *)this + 1);
  if (v31)
    (*(void (**)(uint64_t))(*(_QWORD *)v31 + 24))(v31);
  if (*(_QWORD *)this)
    (*(void (**)(_QWORD))(**(_QWORD **)this + 24))(*(_QWORD *)this);
}

_QWORD *std::vector<HGMTLFunctionType>::__assign_with_size[abi:ne180100]<HGMTLFunctionType*,HGMTLFunctionType*>(_QWORD *result, char *__src, char *a3, size_t __sz)
{
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;
  size_t v14;
  void **v15;
  _BYTE *v16;
  unint64_t v17;
  char *v18;
  void *v19;

  v6 = __src;
  v7 = result;
  v8 = result[2];
  v9 = (char *)*result;
  if (__sz > (v8 - *result) >> 3)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (__sz >> 61)
      goto LABEL_22;
    v10 = v8 >> 2;
    if (v8 >> 2 <= __sz)
      v10 = __sz;
    v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8;
    v12 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v11)
      v12 = v10;
    if (v12 >> 61)
LABEL_22:
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v13 = v12;
    result = operator new(8 * v12);
    v9 = (char *)result;
    *v7 = result;
    v7[1] = result;
    v7[2] = &result[v13];
    v14 = a3 - v6;
    if (v14)
      result = memcpy(result, v6, v14);
    v15 = (void **)(v7 + 1);
    goto LABEL_21;
  }
  v15 = (void **)(result + 1);
  v16 = (_BYTE *)result[1];
  v17 = (v16 - v9) >> 3;
  if (v17 >= __sz)
  {
    v14 = a3 - __src;
    if (a3 == __src)
      goto LABEL_21;
    v19 = (void *)*result;
LABEL_20:
    result = memmove(v19, __src, v14);
    goto LABEL_21;
  }
  v18 = &__src[8 * v17];
  if (v16 != v9)
  {
    result = memmove((void *)*result, __src, v16 - v9);
    v9 = (char *)*v15;
  }
  v14 = a3 - v18;
  if (v14)
  {
    v19 = v9;
    __src = v18;
    goto LABEL_20;
  }
LABEL_21:
  *v15 = &v9[v14];
  return result;
}

uint64_t HGTile::Renderer(HGTile *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 42) + 152);
}

uint64_t HGPage::ReleaseTextures(HGPage *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;

  v2 = *((_QWORD *)this + 21);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    *((_QWORD *)this + 21) = 0;
  }
  v3 = *((_QWORD *)this + 22);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
    *((_QWORD *)this + 22) = 0;
  }
  v4 = *((_QWORD *)this + 23);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
    *((_QWORD *)this + 23) = 0;
  }
  v5 = *((_QWORD *)this + 24);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    *((_QWORD *)this + 24) = 0;
  }
  v6 = *((_QWORD *)this + 25);
  if (v6)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
    *((_QWORD *)this + 25) = 0;
  }
  v7 = *((_QWORD *)this + 26);
  if (v7)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
    *((_QWORD *)this + 26) = 0;
  }
  v8 = *((_QWORD *)this + 27);
  if (v8)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
    *((_QWORD *)this + 27) = 0;
  }
  result = *((_QWORD *)this + 28);
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
    *((_QWORD *)this + 28) = 0;
  }
  return result;
}

void HGPagePullTexturesGuard::HGPagePullTexturesGuard(HGPagePullTexturesGuard *this, HGNode *a2, HGPage *a3)
{
  *(_QWORD *)this = a3;
  if (a2)
    (*(void (**)(HGNode *, HGPage *, _QWORD))(*(_QWORD *)a2 + 472))(a2, a3, 0);
}

void HGPagePullTexturesGuard::~HGPagePullTexturesGuard(HGPage **this)
{
  HGPage *v1;

  v1 = *this;
  if (v1)
    HGPage::ReleaseTextures(v1);
}

void HGPagePullMetalTexturesGuard::HGPagePullMetalTexturesGuard(HGPagePullMetalTexturesGuard *this, HGNode *a2, HGPage *a3)
{
  *(_QWORD *)this = a3;
  if (a2)
    (*(void (**)(HGNode *, HGPage *, _QWORD))(*(_QWORD *)a2 + 480))(a2, a3, 0);
}

void HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard(HGPage **this)
{
  HGPage *v1;

  v1 = *this;
  if (v1)
    HGPage::ReleaseTextures(v1);
}

HGNode *HGNode::ClearNodeChain(HGNode *this)
{
  *((_QWORD *)this + 38) = *((_QWORD *)this + 37);
  return this;
}

void HGNode::HGNode(HGNode *this)
{
  uint64_t v1;

  HGObject::HGObject((HGObject *)this);
  *(_QWORD *)v1 = off_1E6524F88;
  *(_DWORD *)(v1 + 12) = 0;
  *(_QWORD *)(v1 + 24) = 0;
  *(_QWORD *)(v1 + 32) = 0xF00000004;
  *(_QWORD *)(v1 + 120) = 0;
  *(_QWORD *)(v1 + 112) = v1 + 120;
  *(_QWORD *)(v1 + 128) = 0;
  *(_QWORD *)(v1 + 40) = 0;
  *(_QWORD *)(v1 + 72) = 0;
  *(_QWORD *)(v1 + 80) = 0;
  *(_QWORD *)(v1 + 64) = 0;
  *(_DWORD *)(v1 + 88) = 0;
  *(_QWORD *)(v1 + 96) = 0;
  *(_QWORD *)(v1 + 101) = 0;
  *(_DWORD *)(v1 + 136) = 0;
  *(_QWORD *)(v1 + 144) = 0;
  *(_OWORD *)(v1 + 152) = HGRectNull;
  *(_OWORD *)(v1 + 168) = HGRectNull;
  *(_OWORD *)(v1 + 248) = 0u;
  *(_DWORD *)(v1 + 216) = 0;
  *(_OWORD *)(v1 + 184) = 0u;
  *(_OWORD *)(v1 + 200) = 0u;
  *(_OWORD *)(v1 + 220) = HGRectNull;
  *(_QWORD *)(v1 + 236) = 0;
  *(_OWORD *)(v1 + 264) = 0u;
  *(_OWORD *)(v1 + 280) = 0u;
  *(_OWORD *)(v1 + 296) = 0u;
  *(_OWORD *)(v1 + 312) = 0u;
  *(_DWORD *)(v1 + 328) = -1;
  *(_BYTE *)(v1 + 332) = 0;
  *(_QWORD *)(v1 + 336) = 0;
  *(_OWORD *)(v1 + 344) = xmmword_1B309BAB0;
  *(_QWORD *)(v1 + 360) = 0;
  *(_DWORD *)(v1 + 368) = 1065353216;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v1 + 384) = _Q0;
  *(_QWORD *)(v1 + 400) = 0;
  *(_DWORD *)(v1 + 16) = 512;
  *(_QWORD *)(v1 + 48) = 0;
  *(_DWORD *)(v1 + 56) = 2;
  HGShaderBinding::reset((HGShaderBinding *)(v1 + 260));
}

void sub_1B2A67108(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  void *v5;

  v4 = *(_QWORD *)(v1 + 400);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *(void **)(v1 + 296);
  if (v5)
  {
    *(_QWORD *)(v1 + 304) = v5;
    operator delete(v5);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v2, *(_QWORD **)(v1 + 120));
  HGObject::~HGObject((HGObject *)v1);
  _Unwind_Resume(a1);
}

void HGNode::~HGNode(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;

  *(_QWORD *)this = off_1E6524F88;
  v2 = *((_QWORD *)this + 24);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    *((_QWORD *)this + 24) = 0;
  }
  v3 = *((_QWORD *)this + 31);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
    *((_QWORD *)this + 31) = 0;
  }
  v4 = *((_QWORD *)this + 12);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
    *((_QWORD *)this + 12) = 0;
  }
  if (*((int *)this + 22) >= 1)
  {
    v5 = 0;
    do
    {
      if (*(_QWORD *)(*((_QWORD *)this + 10) + 8 * v5))
      {
        (*(void (**)(HGNode *, uint64_t, _QWORD))(*(_QWORD *)this + 120))(this, v5, 0);
        v6 = *(_QWORD *)(*((_QWORD *)this + 10) + 8 * v5);
        if (v6)
          MEMORY[0x1B5E29170](v6, 0x1020C402AEDCB0CLL);
      }
      ++v5;
    }
    while (v5 < *((int *)this + 22));
  }
  v7 = (void *)*((_QWORD *)this + 10);
  if (v7)
    free(v7);
  if (*((_DWORD *)this + 14))
  {
    v8 = *((_QWORD *)this + 6);
    if (v8)
      HGFree(v8);
  }
  *((_DWORD *)this + 4) |= 0x80000000;
  v9 = *((_QWORD *)this + 50);
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  v10 = (void *)*((_QWORD *)this + 37);
  if (v10)
  {
    *((_QWORD *)this + 38) = v10;
    operator delete(v10);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 112, *((_QWORD **)this + 15));
  HGObject::~HGObject((HGObject *)this);
}

{
  void *v1;

  HGNode::~HGNode(this);
  HGObject::operator delete(v1);
}

uint64_t HGNode::dotLabel(HGNode *this)
{
  return 0;
}

uint64_t HGNode::label_A(HGNode *this)
{
  uint64_t result;
  int v2;

  if (!this)
    __cxa_bad_typeid();
  result = (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this - 8) + 8) & 0x7FFFFFFFFFFFFFFFLL) - 1;
  do
    v2 = *(unsigned __int8 *)++result;
  while ((v2 - 48) < 0xA);
  return result;
}

uint64_t HGNode::label_B(HGNode *this)
{
  return 0;
}

void HGNode::info(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t HGNode::debugDescription(HGNode *this)
{
  void *p_p;
  uint64_t v3;
  const char *v4;
  size_t v5;
  const char *v6;
  _QWORD *v7;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  const std::locale::facet *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void *v16;
  char v17;
  std::locale v18;
  char v19;
  void *__p;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD v23[2];
  _QWORD v24[11];
  char v25;
  uint64_t v26;

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v23);
  HGObject::debugDescription(&__p);
  if ((v22 & 0x80u) == 0)
    p_p = &__p;
  else
    p_p = __p;
  if ((v22 & 0x80u) == 0)
    v3 = v22;
  else
    v3 = v21;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)p_p, v3);
  if ((char)v22 < 0)
    operator delete(__p);
  v4 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 48))(this);
  v5 = strlen(v4);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)v4, v5);
  v6 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 56))(this);
  if (v6)
  {
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)", ", 2);
    v8 = strlen(v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)v6, v8);
  }
  v19 = 0;
  LOBYTE(v18.__locale_) = 0;
  v17 = 0;
  LOBYTE(v16) = 0;
  (*(void (**)(void **__return_ptr, HGNode *, uint64_t, std::locale *, void **))(*(_QWORD *)this + 64))(&__p, this, 3, &v18, &v16);
  if (v17 < 0)
  {
    operator delete(v16);
    if ((v19 & 0x80000000) == 0)
    {
LABEL_13:
      v9 = v22;
      if ((v22 & 0x80u) != 0)
        v9 = v21;
      if (!v9)
        goto LABEL_28;
LABEL_21:
      std::ios_base::getloc((const std::ios_base *)((char *)v24 + *(_QWORD *)(v24[0] - 24)));
      v11 = std::locale::use_facet(&v18, MEMORY[0x1E0DE4A90]);
      ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
      std::locale::~locale(&v18);
      std::ostream::put();
      std::ostream::flush();
      if ((v22 & 0x80u) == 0)
        v12 = &__p;
      else
        v12 = __p;
      if ((v22 & 0x80u) == 0)
        v13 = v22;
      else
        v13 = v21;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)v12, v13);
      goto LABEL_28;
    }
  }
  else if ((v19 & 0x80000000) == 0)
  {
    goto LABEL_13;
  }
  operator delete(v18.__locale_);
  v10 = v22;
  if ((v22 & 0x80u) != 0)
    v10 = v21;
  if (v10)
    goto LABEL_21;
LABEL_28:
  std::stringbuf::str();
  if ((char)v22 < 0)
    operator delete(__p);
  v23[0] = *MEMORY[0x1E0DE4F50];
  v14 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)v23 + *(_QWORD *)(v23[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v24[0] = v14;
  v24[1] = MEMORY[0x1E0DE4FB8] + 16;
  if (v25 < 0)
    operator delete((void *)v24[9]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1B5E290BC](&v26);
}

void sub_1B2A67588(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15.__locale_);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a27);
  _Unwind_Resume(a1);
}

uint64_t HGNode::shaderDescription(HGNode *this)
{
  const char *FragmentFunctionName;
  size_t v3;
  uint64_t v4;
  _QWORD v6[2];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[64];
  int v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  int v21;
  _QWORD v22[2];
  _QWORD v23[11];
  char v24;
  uint64_t v25;

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v22);
  HGObject::HGObject((HGObject *)v6);
  v6[0] = &unk_1E6525468;
  memset(&v16[32], 0, 32);
  v7 = 0u;
  v8 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  memset(v16, 0, 28);
  v20 = 0u;
  v18 = 0u;
  v19 = 0u;
  v17 = 1;
  v21 = 0;
  (*(void (**)(HGNode *, _QWORD *))(*(_QWORD *)this + 328))(this, v6);
  FragmentFunctionName = HGProgramDescriptor::GetFragmentFunctionName((HGProgramDescriptor *)v6);
  v3 = strlen(FragmentFunctionName);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)FragmentFunctionName, v3);
  std::stringbuf::str();
  HGProgramDescriptor::~HGProgramDescriptor((HGProgramDescriptor *)v6);
  v22[0] = *MEMORY[0x1E0DE4F50];
  v4 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)v22 + *(_QWORD *)(v22[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v23[0] = v4;
  v23[1] = MEMORY[0x1E0DE4FB8] + 16;
  if (v24 < 0)
    operator delete((void *)v23[9]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1B5E290BC](&v25);
}

void sub_1B2A6776C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a44);
  _Unwind_Resume(a1);
}

void sub_1B2A67780(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  HGProgramDescriptor::~HGProgramDescriptor((HGProgramDescriptor *)&a9);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a44);
  _Unwind_Resume(a1);
}

uint64_t HGNode::SetInput(HGNode *this, unsigned int a2, HGNode *a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  BOOL v13;
  _QWORD *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  BOOL v23;
  uint64_t *v24;
  uint64_t **v25;
  unint64_t v26;
  uint64_t **v27;
  unint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t *v31;

  if ((a2 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  if (*((_DWORD *)this + 22) > (signed int)a2)
  {
    v6 = a2;
    v7 = *(_QWORD *)(*((_QWORD *)this + 10) + 8 * a2);
    if (v7)
      goto LABEL_4;
LABEL_25:
    v21 = operator new();
    *(_QWORD *)v21 = this;
    *(_DWORD *)(v21 + 8) = a2;
    *(_QWORD *)(v21 + 20) = 0;
    *(_QWORD *)(v21 + 12) = 0;
    *(_DWORD *)(v21 + 28) = 0;
    *(_OWORD *)(v21 + 32) = HGRectNull;
    *(_QWORD *)(v21 + 48) = 0;
    *(_QWORD *)(*((_QWORD *)this + 10) + 8 * v6) = v21;
    v7 = *(_QWORD *)(*((_QWORD *)this + 10) + 8 * v6);
    v8 = *(_QWORD *)(v7 + 16);
    if ((HGNode *)v8 != a3)
      goto LABEL_5;
    return 0;
  }
  v18 = (a2 & 0xFFFFFFF8) + 8;
  v19 = (void *)*((_QWORD *)this + 10);
  if (v19)
  {
    *((_QWORD *)this + 10) = malloc_type_realloc(v19, 8 * v18, 0x2004093837F09uLL);
    v20 = *((int *)this + 22);
    if ((int)v20 >= (int)v18)
      goto LABEL_24;
  }
  else
  {
    *((_QWORD *)this + 10) = malloc_type_malloc(8 * ((a2 & 0xFFFFFFF8) + 8), 0x2004093837F09uLL);
    v20 = *((int *)this + 22);
    if ((int)v20 >= (int)v18)
      goto LABEL_24;
  }
  do
    *(_QWORD *)(*((_QWORD *)this + 10) + 8 * v20++) = 0;
  while (v18 != v20);
LABEL_24:
  *((_DWORD *)this + 22) = v18;
  v6 = a2;
  v7 = *(_QWORD *)(*((_QWORD *)this + 10) + 8 * a2);
  if (!v7)
    goto LABEL_25;
LABEL_4:
  v8 = *(_QWORD *)(v7 + 16);
  if ((HGNode *)v8 == a3)
    return 0;
LABEL_5:
  if (v8)
  {
    v9 = *(uint64_t **)(v8 + 120);
    if (v9)
    {
      v10 = (uint64_t *)(v8 + 120);
      v11 = *(_QWORD **)(v8 + 120);
      do
      {
        v12 = v11[4];
        v13 = v12 >= v7;
        if (v12 >= v7)
          v14 = v11;
        else
          v14 = v11 + 1;
        if (v13)
          v10 = v11;
        v11 = (_QWORD *)*v14;
      }
      while (*v14);
      if (v10 != (uint64_t *)(v8 + 120) && v7 >= v10[4])
      {
        v15 = (uint64_t *)v10[1];
        if (v15)
        {
          do
          {
            v16 = v15;
            v15 = (uint64_t *)*v15;
          }
          while (v15);
        }
        else
        {
          v22 = v10;
          do
          {
            v16 = (uint64_t *)v22[2];
            v23 = *v16 == (_QWORD)v22;
            v22 = v16;
          }
          while (!v23);
        }
        if (*(uint64_t **)(v8 + 112) == v10)
          *(_QWORD *)(v8 + 112) = v16;
        --*(_QWORD *)(v8 + 128);
        std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v9, v10);
        operator delete(v10);
        v8 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 10) + 8 * v6) + 16);
      }
    }
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
    v7 = *(_QWORD *)(*((_QWORD *)this + 10) + 8 * v6);
  }
  *(_QWORD *)(v7 + 16) = a3;
  if (a3)
  {
    (*(void (**)(HGNode *))(*(_QWORD *)a3 + 16))(a3);
    v25 = (uint64_t **)((char *)a3 + 120);
    v24 = (uint64_t *)*((_QWORD *)a3 + 15);
    v26 = *(_QWORD *)(*((_QWORD *)this + 10) + 8 * v6);
    if (v24)
    {
      while (1)
      {
        while (1)
        {
          v27 = (uint64_t **)v24;
          v28 = v24[4];
          if (v26 >= v28)
            break;
          v24 = *v27;
          v25 = v27;
          if (!*v27)
            goto LABEL_44;
        }
        if (v28 >= v26)
          break;
        v24 = v27[1];
        if (!v24)
        {
          v25 = v27 + 1;
          goto LABEL_44;
        }
      }
    }
    else
    {
      v27 = (uint64_t **)((char *)a3 + 120);
LABEL_44:
      v29 = (uint64_t *)operator new(0x28uLL);
      v29[4] = v26;
      *v29 = 0;
      v29[1] = 0;
      v29[2] = (uint64_t)v27;
      *v25 = v29;
      v30 = **((_QWORD **)a3 + 14);
      if (v30)
      {
        *((_QWORD *)a3 + 14) = v30;
        v31 = *v25;
      }
      else
      {
        v31 = v29;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)a3 + 15), v31);
      ++*((_QWORD *)a3 + 16);
    }
  }
  HGNode::ClearBits(this, (const char *)0xFFFF, (char *)a3);
  return 1;
}

HGNode *HGNode::ClearBits(HGNode *this, uint64_t a2, char *a3)
{
  return HGNode::ClearBits(this, (const char *)0xFFFF, a3);
}

uint64_t HGNode::GetNumInputs(HGNode *this)
{
  return *((unsigned int *)this + 22);
}

uint64_t HGNode::GetInput(HGNode *this, unsigned int a2)
{
  uint64_t v2;

  if ((a2 & 0x80000000) != 0)
    return 0;
  if (*((_DWORD *)this + 22) <= (signed int)a2)
    return 0;
  v2 = *(_QWORD *)(*((_QWORD *)this + 10) + 8 * a2);
  if (!v2)
    return 0;
  else
    return *(_QWORD *)(v2 + 16);
}

uint64_t HGNode::SetFlags(HGNode *this, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  int v11;
  uint64_t v12;

  if ((a3 & 0x80) != 0)
  {
    v10 = *((unsigned int *)this + 4);
    v11 = *((_DWORD *)this + 4);
    if (a3 != 128)
    {
      (*(void (**)(HGNode *, uint64_t, _QWORD))(*(_QWORD *)this + 136))(this, a2, a3 & 0xFFFFFF7F);
      v11 = *((_DWORD *)this + 4);
    }
    *((_DWORD *)this + 4) = v11 | 0x94;
    return v10;
  }
  else if ((a2 & 0x80000000) != 0)
  {
    v12 = *((unsigned int *)this + 4);
    *((_DWORD *)this + 4) = v12 | a3;
    return v12;
  }
  else
  {
    v5 = *((_QWORD *)this + 10);
    v6 = a2;
    if (!v5 || (v7 = *(_QWORD *)(v5 + 8 * a2)) == 0)
    {
      (*(void (**)(HGNode *))(*(_QWORD *)this + 120))(this);
      v7 = *(_QWORD *)(*((_QWORD *)this + 10) + 8 * v6);
    }
    v8 = *(unsigned int *)(v7 + 12);
    *(_DWORD *)(v7 + 12) = v8 | a3;
    return v8;
  }
}

uint64_t HGNode::ClearFlags(HGNode *this, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  int v11;
  uint64_t v12;

  if ((a3 & 0x80) != 0)
  {
    v10 = *((unsigned int *)this + 4);
    v11 = *((_DWORD *)this + 4);
    if (a3 != 128)
    {
      (*(void (**)(HGNode *, uint64_t, _QWORD))(*(_QWORD *)this + 144))(this, a2, a3 & 0xFFFFFF7F);
      v11 = *((_DWORD *)this + 4);
    }
    *((_DWORD *)this + 4) = v11 & 0xFFFFFF7F;
    return v10;
  }
  else if ((a2 & 0x80000000) != 0)
  {
    v12 = *((unsigned int *)this + 4);
    *((_DWORD *)this + 4) = v12 & ~a3;
    return v12;
  }
  else
  {
    v5 = *((_QWORD *)this + 10);
    v6 = a2;
    if (!v5 || (v7 = *(_QWORD *)(v5 + 8 * a2)) == 0)
    {
      (*(void (**)(HGNode *))(*(_QWORD *)this + 120))(this);
      v7 = *(_QWORD *)(*((_QWORD *)this + 10) + 8 * v6);
    }
    v8 = *(unsigned int *)(v7 + 12);
    *(_DWORD *)(v7 + 12) = v8 & ~a3;
    return v8;
  }
}

uint64_t HGNode::GetFlags(HGNode *this, unsigned int a2)
{
  uint64_t v2;

  if ((a2 & 0x80000000) != 0)
    return *((unsigned int *)this + 4);
  if (*((_DWORD *)this + 22) > (signed int)a2)
  {
    v2 = *(_QWORD *)(*((_QWORD *)this + 10) + 8 * a2);
    if (v2)
      return *(unsigned int *)(v2 + 12);
  }
  return 0;
}

uint64_t HGNode::GetParameterCount(HGNode *this)
{
  return *((unsigned int *)this + 11);
}

char *HGNode::GetParameterName(HGNode *this, int a2)
{
  int v3;
  char *v4;

  v3 = (*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 80))(this);
  v4 = (char *)&unk_1B3522214;
  if (a2 < 9)
    v4 = (char *)&HGNode::GetParameterName(int)::names + 4 * a2;
  if (v3 <= a2)
    return 0;
  else
    return v4;
}

uint64_t HGNode::SetParameter(HGNode *this, int a2, float a3, float a4, float a5, float a6, char *a7)
{
  int v13;
  unsigned int v14;
  const void *v15;
  int v16;
  char *v17;
  float *v19;

  if (a2 < 0)
    return 0xFFFFFFFFLL;
  v13 = *((_DWORD *)this + 14);
  if (v13 < 2)
  {
    if (*((_DWORD *)this + 11) <= a2)
      return 0xFFFFFFFFLL;
  }
  else
  {
    v14 = (a2 & 0xFFFFFFFC) + 4;
    if (v14 > v13)
    {
      v15 = (const void *)*((_QWORD *)this + 6);
      if (v15)
        v16 = v13;
      else
        v16 = 0;
      v17 = (char *)HGRealloc(v15, (int)(16 * v14));
      *((_QWORD *)this + 6) = v17;
      bzero(&v17[16 * v16], 16 * (v14 - v16));
      *((_DWORD *)this + 14) = v14;
    }
    if (*((_DWORD *)this + 11) <= a2)
      *((_DWORD *)this + 11) = a2 + 1;
  }
  v19 = (float *)(*((_QWORD *)this + 6) + 16 * a2);
  if (*v19 == a3 && v19[1] == a4 && v19[2] == a5 && v19[3] == a6)
    return 0;
  *v19 = a3;
  v19[1] = a4;
  v19[2] = a5;
  v19[3] = a6;
  HGNode::ClearBits(this, (const char *)0xFFFF, a7);
  return 1;
}

uint64_t HGNode::GetParameter(HGNode *this, int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 < 0 || *((_DWORD *)this + 11) <= a2)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 6) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

void HGNode::WriteDotGraph(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  const char *v7;
  char *v8;
  char *v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  std::locale::__imp *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  char *v30;
  char *v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  char *v36;
  unint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  std::locale::__imp *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  char *v51;
  char *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  char *v57;
  char *v58;
  uint64_t v59;
  __int128 v60;
  uint64_t v61;
  char *v62;
  char *v63;
  unint64_t v64;
  _QWORD *v65;
  uint64_t v66;
  std::locale::__imp *v67;
  std::locale::__imp *v68;
  char *v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  char *v76;
  char *v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  char *v81;
  char *v82;
  char *v83;
  uint64_t v84;
  __int128 v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  char *v91;
  char *v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  char *v97;
  char *v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  char *v102;
  char *v103;
  char *v104;
  uint64_t v105;
  __int128 v106;
  uint64_t v107;
  _QWORD *v108;
  unint64_t *v109;
  _QWORD *v110;
  unint64_t *v111;
  _QWORD *v112;
  unint64_t *v113;
  _QWORD *v114;
  unint64_t *v115;
  _QWORD *v116;
  unint64_t *v117;
  _QWORD *v118;
  unint64_t *v119;
  char *v120;
  uint64_t v121;
  char *v122;
  uint64_t v123;
  unint64_t v124;
  uint64_t v125;
  uint64_t v126;
  _QWORD *v127;
  uint64_t v128;
  std::string::size_type *v129;
  _QWORD *v130;
  std::locale::__imp *v131;
  uint64_t v132;
  _QWORD *v133;
  uint64_t v134;
  _QWORD *v135;
  std::string::size_type *v136;
  _QWORD *v137;
  const char *v138;
  size_t v139;
  std::string::size_type v140;
  std::string *p_dst;
  unint64_t v142;
  const char *v143;
  size_t v144;
  _QWORD *v145;
  const std::locale::facet *v146;
  _QWORD *v147;
  void *v148;
  int v149;
  uint64_t v150;
  uint64_t v151;
  std::string *v152;
  uint64_t m;
  uint64_t v154;
  unint64_t v155;
  void **v156;
  _QWORD *v157;
  _QWORD *v158;
  void *v159;
  void **v160;
  void **v161;
  unint64_t v162;
  unint64_t v163;
  uint64_t v164;
  char *v165;
  uint64_t v166;
  char *v167;
  uint64_t v168;
  unint64_t v169;
  uint64_t v170;
  uint64_t v171;
  _QWORD *v172;
  unint64_t *v173;
  std::locale::__imp *v174;
  uint64_t v175;
  unint64_t v176;
  const char *v177;
  size_t v178;
  _QWORD *v179;
  const std::locale::facet *v180;
  _QWORD *v181;
  void *v182;
  int v183;
  uint64_t k;
  uint64_t v185;
  std::ios_base *v186;
  unint64_t v187;
  void **v188;
  _QWORD *v189;
  _QWORD *v190;
  void *v191;
  void **v192;
  void **v193;
  unint64_t v194;
  unint64_t v195;
  uint64_t v196;
  char *v197;
  uint64_t v198;
  char *v199;
  uint64_t v200;
  unint64_t v201;
  uint64_t v202;
  uint64_t v203;
  _QWORD *v204;
  unint64_t *v205;
  std::locale::__imp *v206;
  uint64_t v207;
  unint64_t v208;
  const char *v209;
  size_t v210;
  _QWORD *v211;
  const std::locale::facet *v212;
  _QWORD *v213;
  void *locale;
  int v215;
  uint64_t j;
  unint64_t v217;
  _QWORD *v218;
  unint64_t v219;
  int v220;
  uint64_t i;
  _QWORD *v222;
  _QWORD *v223;
  BOOL v224;
  unint64_t v225;
  std::ios_base *v226;
  void **v227;
  _QWORD *v228;
  _QWORD *v229;
  void *v230;
  void **v231;
  void **v232;
  unint64_t v233;
  unint64_t v234;
  uint64_t v235;
  void *v236;
  void *v237;
  char *v238;
  void *v239;
  unint64_t *v240;
  unint64_t *v241;
  _QWORD *v242;
  _QWORD *v243;
  uint64_t v244;
  uint64_t v245;
  std::locale::__imp *v246;
  std::locale::__imp *v247;
  std::locale::__imp *v248;
  std::locale::__imp *v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  int64_t v253;
  int64_t v254;
  std::locale::__imp *v255;
  std::locale::__imp *v256;
  std::string::size_type v257;
  std::locale::__imp *v258;
  std::locale::__imp *v259;
  std::locale::__imp *v260;
  std::string::size_type v261;
  std::string::size_type v262;
  std::locale::__imp *v263;
  std::locale::__imp *v264;
  void *__p[2];
  char v266;
  std::locale v267;
  uint64_t v268;
  int64_t v269;
  _QWORD v270[8];
  __int128 v271;
  __int128 v272;
  int v273;
  _QWORD v274[19];
  std::string __dst;
  _QWORD v276[8];
  void *v277;
  char v278;
  _BYTE v279[152];
  __int128 v280;
  __int128 v281;
  int v282;
  __int128 v283;
  __int128 v284;
  __int128 v285;
  char *v286;
  char *v287;
  char *v288;
  std::string v289[4];

  HGDotGraph::HGDotGraph((HGDotGraph *)v289);
  PCImage::setIsPremultiplied(v6, 1);
  HGDotGraph::footnode((uint64_t)v289, 0);
  if (*(char *)(a2 + 23) >= 0)
    v7 = (const char *)a2;
  else
    v7 = *(const char **)a2;
  HGDotGraph::begin((HGDotGraph *)v289, v7);
  if (a3 == 2)
  {
    v284 = 0u;
    v285 = 0u;
    v283 = 0u;
    v280 = 0u;
    v281 = 0u;
    v282 = 1065353216;
    v62 = (char *)operator new(8uLL);
    *(_QWORD *)v62 = a1;
    v63 = v62 + 8;
    v287 = v62 + 8;
    v288 = v62 + 8;
    v286 = v62;
    while (1)
    {
      v267.__locale_ = 0;
      v267.__locale_ = (std::locale::__imp *)*((_QWORD *)v63 - 1);
      v287 = v63 - 8;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v267;
      if (!*((_BYTE *)std::__hash_table<std::__hash_value_type<HGNode const*,BOOL>,std::__unordered_map_hasher<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::hash<HGNode const*>,std::equal_to<HGNode const*>,true>,std::__unordered_map_equal<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::equal_to<HGNode const*>,std::hash<HGNode const*>,true>,std::allocator<std::__hash_value_type<HGNode const*,BOOL>>>::__emplace_unique_key_args<HGNode const*,std::piecewise_construct_t const&,std::tuple<HGNode const* const&>,std::tuple<>>((uint64_t)&v280, (uint64_t *)&v267, (uint64_t)&std::piecewise_construct, &__dst)+ 24))break;
LABEL_85:
      v63 = v287;
      if (v286 == v287)
      {
        v116 = (_QWORD *)(*((_QWORD *)&v283 + 1) + 8 * ((unint64_t)v285 >> 9));
        if ((_QWORD)v284 == *((_QWORD *)&v283 + 1))
        {
          v117 = 0;
          v119 = 0;
          v118 = (_QWORD *)(v284 + 8 * ((*((_QWORD *)&v285 + 1) + (_QWORD)v285) >> 9));
        }
        else
        {
          v117 = (unint64_t *)(*v116 + 8 * (v285 & 0x1FF));
          v118 = (_QWORD *)(*((_QWORD *)&v283 + 1) + 8 * ((*((_QWORD *)&v285 + 1) + (_QWORD)v285) >> 9));
          v119 = (unint64_t *)(*v118 + 8 * ((*((_QWORD *)&v285 + 1) + v285) & 0x1FF));
        }
        v197 = (char *)hgstd::stable_unique<std::__deque_iterator<HGNode const*,HGNode const**,HGNode const*&,HGNode const***,long,512l>>(v116, v117, (uint64_t)v118, v119);
        v199 = (char *)(*((_QWORD *)&v283 + 1) + 8 * ((unint64_t)v285 >> 9));
        if ((_QWORD)v284 == *((_QWORD *)&v283 + 1))
        {
          v200 = 0;
          if (!v198)
            goto LABEL_269;
LABEL_267:
          v201 = ((v198 - *(_QWORD *)v197) >> 3) + ((v197 - v199) << 6) - ((v200 - *(_QWORD *)v199) >> 3);
        }
        else
        {
          v200 = *(_QWORD *)v199 + 8 * (v285 & 0x1FF);
          if (v198 != v200)
            goto LABEL_267;
LABEL_269:
          v201 = 0;
        }
        std::deque<HGNode const*>::resize(&v283, v201);
        v202 = *((_QWORD *)&v283 + 1);
        v203 = v284;
        v204 = (_QWORD *)(*((_QWORD *)&v283 + 1) + 8 * ((unint64_t)v285 >> 9));
        if ((_QWORD)v284 == *((_QWORD *)&v283 + 1))
          v205 = 0;
        else
          v205 = (unint64_t *)(*v204 + 8 * (v285 & 0x1FF));
        v259 = *(std::locale::__imp **)(MEMORY[0x1E0DE4F50] + 16);
        v256 = *(std::locale::__imp **)(MEMORY[0x1E0DE4F50] + 24);
        v254 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 32);
        v251 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 40);
        v249 = *(std::locale::__imp **)(MEMORY[0x1E0DE4F50] + 48);
        v206 = (std::locale::__imp *)*MEMORY[0x1E0DE4F50];
        v247 = *(std::locale::__imp **)(MEMORY[0x1E0DE4F50] + 8);
        v264 = *(std::locale::__imp **)(MEMORY[0x1E0DE4F50] + 64);
        v262 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
        v245 = MEMORY[0x1E0DE4FB8] + 16;
        v207 = MEMORY[0x1E0DE4FD0];
        while (2)
        {
          if (v203 == v202)
          {
            if (!v205)
            {
LABEL_319:
              v228 = (_QWORD *)v281;
              if ((_QWORD)v281)
              {
                do
                {
                  v229 = (_QWORD *)*v228;
                  operator delete(v228);
                  v228 = v229;
                }
                while (v229);
              }
              v230 = (void *)v280;
              *(_QWORD *)&v280 = 0;
              if (v230)
                operator delete(v230);
              v231 = (void **)*((_QWORD *)&v283 + 1);
              v232 = (void **)v284;
              *((_QWORD *)&v285 + 1) = 0;
              v233 = v284 - *((_QWORD *)&v283 + 1);
              if ((_QWORD)v284 - *((_QWORD *)&v283 + 1) >= 0x11uLL)
              {
                do
                {
                  operator delete(*v231);
                  v232 = (void **)v284;
                  v231 = (void **)(*((_QWORD *)&v283 + 1) + 8);
                  *((_QWORD *)&v283 + 1) = v231;
                  v233 = v284 - (_QWORD)v231;
                }
                while ((_QWORD)v284 - (_QWORD)v231 > 0x10uLL);
              }
              v234 = v233 >> 3;
              if (v234 == 1)
              {
                v235 = 256;
LABEL_344:
                *(_QWORD *)&v285 = v235;
              }
              else if (v234 == 2)
              {
                v235 = 512;
                goto LABEL_344;
              }
              if (v231 != v232)
              {
                do
                {
                  v239 = *v231++;
                  operator delete(v239);
                }
                while (v231 != v232);
                if ((_QWORD)v284 != *((_QWORD *)&v283 + 1))
                  *(_QWORD *)&v284 = v284 + ((*((_QWORD *)&v283 + 1) - v284 + 7) & 0xFFFFFFFFFFFFFFF8);
              }
              if ((_QWORD)v283)
                operator delete((void *)v283);
              v238 = v286;
              if (!v286)
                goto LABEL_354;
              v287 = v286;
LABEL_353:
              operator delete(v238);
              goto LABEL_354;
            }
          }
          else if (v205 == (unint64_t *)(*(_QWORD *)(v202
                                                           + (((*((_QWORD *)&v285 + 1) + (_QWORD)v285) >> 6) & 0x3FFFFFFFFFFFFF8))
                                               + 8 * ((*((_QWORD *)&v285 + 1) + v285) & 0x1FF)))
          {
            goto LABEL_319;
          }
          v208 = *v205;
          std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&__dst);
          v209 = (const char *)(*(uint64_t (**)(unint64_t))(*(_QWORD *)v208 + 48))(v208);
          v210 = strlen(v209);
          v211 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__dst.__r_.__value_.__r.__words[2], (uint64_t)v209, v210);
          std::ios_base::getloc((const std::ios_base *)((char *)v211 + *(_QWORD *)(*v211 - 24)));
          v212 = std::locale::use_facet(&v267, MEMORY[0x1E0DE4A90]);
          ((void (*)(const std::locale::facet *, uint64_t))v212->__vftable[2].~facet_0)(v212, 10);
          std::locale::~locale(&v267);
          std::ostream::put();
          std::ostream::flush();
          *(_DWORD *)((char *)v276 + *(_QWORD *)(__dst.__r_.__value_.__r.__words[2] - 24)) = *(_DWORD *)((_BYTE *)v276 + *(_QWORD *)(__dst.__r_.__value_.__r.__words[2] - 24)) & 0xFFFFFFB5 | 8;
          v213 = (_QWORD *)std::ostream::operator<<();
          *(_DWORD *)((char *)v213 + *(_QWORD *)(*v213 - 24) + 8) = *(_DWORD *)((_BYTE *)v213
                                                                                + *(_QWORD *)(*v213 - 24)
                                                                                + 8) & 0xFFFFFFB5 | 2;
          std::stringbuf::str();
          if (v269 >= 0)
            locale = &v267;
          else
            locale = v267.__locale_;
          HGDotGraph::node((uint64_t *)v289, v208, (uint64_t)locale, 0);
          if (SHIBYTE(v269) < 0)
          {
            operator delete(v267.__locale_);
            v215 = *(_DWORD *)(v208 + 88);
            if (v215 < 1)
            {
LABEL_290:
              if (*(_QWORD *)(v208 + 128))
              {
                v218 = *(_QWORD **)(v208 + 112);
                HGDotGraph::beginRank((uint64_t)v289);
                if (v218 != (_QWORD *)(v208 + 120))
                {
                  do
                  {
                    HGDotGraph::link((uint64_t *)v289, v208, v218[4], 0, 0);
                    HGDotGraph::rank(v289, (const void *)v218[4]);
                    v222 = (_QWORD *)v218[1];
                    if (v222)
                    {
                      do
                      {
                        v223 = v222;
                        v222 = (_QWORD *)*v222;
                      }
                      while (v222);
                    }
                    else
                    {
                      do
                      {
                        v223 = (_QWORD *)v218[2];
                        v224 = *v223 == (_QWORD)v218;
                        v218 = v223;
                      }
                      while (!v224);
                    }
                    v218 = v223;
                  }
                  while (v223 != (_QWORD *)(v208 + 120));
                }
                HGDotGraph::endRank((uint64_t)v289);
              }
              v219 = *(_QWORD *)(v208 + 144);
              if (v219)
              {
                HGDotGraph::link((uint64_t *)v289, v219, v208, 0, 1);
                HGDotGraph::linkStyle((uint64_t *)v289, *(uint64_t **)(v208 + 144), (uint64_t *)v208, 1, 1);
                HGDotGraph::filled((uint64_t)v289, *(_QWORD *)(v208 + 144), 0);
              }
              v241 = v205;
              v243 = v204;
              v220 = *(_DWORD *)(v208 + 88);
              if (v220 >= 1)
              {
                for (i = 0; i < v220; ++i)
                {
                  v225 = *(_QWORD *)(*(_QWORD *)(v208 + 80) + 8 * i);
                  if (v225 && *(_QWORD *)(v225 + 16))
                  {
                    v274[0] = v207 + 104;
                    v269 = v207 + 64;
                    v267.__locale_ = v259;
                    *(std::locale::__imp **)((char *)&v267.__locale_ + *((_QWORD *)v259 - 3)) = v256;
                    v268 = 0;
                    v226 = (std::ios_base *)((char *)&v267 + *((_QWORD *)v267.__locale_ - 3));
                    std::ios_base::init(v226, v270);
                    v226[1].__vftable = 0;
                    v226[1].__fmtflags_ = -1;
                    v269 = v254;
                    *(_QWORD *)((char *)&v270[-1] + *(_QWORD *)(v254 - 24)) = v251;
                    v267.__locale_ = v247;
                    *(std::locale::__imp **)((char *)&v267.__locale_ + *((_QWORD *)v247 - 3)) = v249;
                    v274[0] = v207 + 104;
                    v267.__locale_ = (std::locale::__imp *)(v207 + 24);
                    v269 = v207 + 64;
                    std::streambuf::basic_streambuf();
                    v270[0] = v245;
                    v271 = 0u;
                    v272 = 0u;
                    v273 = 24;
                    std::ostream::operator<<();
                    std::stringbuf::str();
                    if (v266 >= 0)
                      v227 = __p;
                    else
                      v227 = (void **)__p[0];
                    HGDotGraph::link((uint64_t *)v289, v225, v208, (const char *)v227, 0);
                    if (v266 < 0)
                      operator delete(__p[0]);
                    v267.__locale_ = v206;
                    *(std::locale::__imp **)((char *)&v267.__locale_ + *((_QWORD *)v206 - 3)) = v264;
                    v269 = v262;
                    v270[0] = MEMORY[0x1E0DE4FB8] + 16;
                    if (SBYTE7(v272) < 0)
                      operator delete((void *)v271);
                    std::streambuf::~streambuf();
                    std::iostream::~basic_iostream();
                    MEMORY[0x1B5E290BC](v274);
                    v220 = *(_DWORD *)(v208 + 88);
                  }
                }
              }
              __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v206;
              *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + *((_QWORD *)v206 - 3)) = (std::string::size_type)v264;
              __dst.__r_.__value_.__r.__words[2] = v262;
              v276[0] = MEMORY[0x1E0DE4FB8] + 16;
              if (v278 < 0)
                operator delete(v277);
              std::streambuf::~streambuf();
              std::iostream::~basic_iostream();
              MEMORY[0x1B5E290BC](v279);
              ++v205;
              if ((unint64_t *)((char *)v241 - *v204 + 8) == (unint64_t *)4096)
              {
                ++v204;
                v205 = (unint64_t *)v243[1];
              }
              v202 = *((_QWORD *)&v283 + 1);
              v203 = v284;
              continue;
            }
          }
          else
          {
            v215 = *(_DWORD *)(v208 + 88);
            if (v215 < 1)
              goto LABEL_290;
          }
          break;
        }
        for (j = 0; j < v215; ++j)
        {
          v217 = *(_QWORD *)(*(_QWORD *)(v208 + 80) + 8 * j);
          if (v217)
          {
            HGDotGraph::node((uint64_t *)v289, v217, 0, 3);
            v215 = *(_DWORD *)(v208 + 88);
          }
        }
        goto LABEL_290;
      }
    }
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v267;
    *((_BYTE *)std::__hash_table<std::__hash_value_type<HGNode const*,BOOL>,std::__unordered_map_hasher<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::hash<HGNode const*>,std::equal_to<HGNode const*>,true>,std::__unordered_map_equal<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::equal_to<HGNode const*>,std::hash<HGNode const*>,true>,std::allocator<std::__hash_value_type<HGNode const*,BOOL>>>::__emplace_unique_key_args<HGNode const*,std::piecewise_construct_t const&,std::tuple<HGNode const* const&>,std::tuple<>>((uint64_t)&v280, (uint64_t *)&v267, (uint64_t)&std::piecewise_construct, &__dst)+ 24) = 1;
    v64 = v285;
    if (!(_QWORD)v285)
    {
      std::deque<HGNode const*>::__add_front_capacity((uint64_t)&v283);
      v64 = v285;
    }
    v65 = (_QWORD *)(*((_QWORD *)&v283 + 1) + 8 * (v64 >> 9));
    if ((_QWORD)v284 == *((_QWORD *)&v283 + 1))
      v66 = 0;
    else
      v66 = *v65 + 8 * (v64 & 0x1FF);
    if (v66 == *v65)
      v66 = *(v65 - 1) + 4096;
    *(std::locale *)(v66 - 8) = v267;
    *(_QWORD *)&v285 = v64 - 1;
    ++*((_QWORD *)&v285 + 1);
    v67 = v267.__locale_;
    v68 = (std::locale::__imp *)*((_QWORD *)v267.__locale_ + 18);
    if (!v68 || v68 == v267.__locale_)
    {
LABEL_119:
      if (*((int *)v67 + 22) >= 1)
      {
        v87 = 0;
        while (2)
        {
          v89 = *(_QWORD *)(*((_QWORD *)v67 + 10) + 8 * v87);
          if (!v89)
            goto LABEL_123;
          v90 = *(_QWORD *)(v89 + 16);
          if (!v90)
            goto LABEL_123;
          v91 = v287;
          if (v287 >= v288)
          {
            v92 = v286;
            v93 = (v287 - v286) >> 3;
            v94 = v93 + 1;
            if ((unint64_t)(v93 + 1) >> 61)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v95 = v288 - v286;
            if ((v288 - v286) >> 2 > v94)
              v94 = v95 >> 2;
            if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFF8)
              v96 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v96 = v94;
            if (v96)
            {
              if (v96 >> 61)
                std::__throw_bad_array_new_length[abi:ne180100]();
              v97 = (char *)operator new(8 * v96);
              v98 = &v97[8 * v93];
              *(_QWORD *)v98 = *(_QWORD *)(v89 + 16);
              v88 = (uint64_t)(v98 + 8);
              if (v91 == v92)
              {
LABEL_145:
                v286 = v98;
                v287 = (char *)v88;
                v288 = &v97[8 * v96];
                if (v91)
                  operator delete(v91);
LABEL_122:
                v287 = (char *)v88;
                v67 = v267.__locale_;
LABEL_123:
                if (++v87 >= *((int *)v67 + 22))
                  goto LABEL_85;
                continue;
              }
            }
            else
            {
              v97 = 0;
              v98 = (char *)(8 * v93);
              *(_QWORD *)(8 * v93) = v90;
              v88 = 8 * v93 + 8;
              if (v91 == v92)
                goto LABEL_145;
            }
            v99 = v91 - 8 - v92;
            if (v99 < 0x58)
              goto LABEL_366;
            if ((unint64_t)(v92 - v97) < 0x20)
              goto LABEL_366;
            v100 = (v99 >> 3) + 1;
            v101 = 8 * (v100 & 0x3FFFFFFFFFFFFFFCLL);
            v102 = &v91[-v101];
            v98 -= v101;
            v103 = &v97[8 * v93 - 16];
            v104 = v91 - 16;
            v105 = v100 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v106 = *(_OWORD *)v104;
              *((_OWORD *)v103 - 1) = *((_OWORD *)v104 - 1);
              *(_OWORD *)v103 = v106;
              v103 -= 32;
              v104 -= 32;
              v105 -= 4;
            }
            while (v105);
            v91 = v102;
            if (v100 != (v100 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_366:
              do
              {
                v107 = *((_QWORD *)v91 - 1);
                v91 -= 8;
                *((_QWORD *)v98 - 1) = v107;
                v98 -= 8;
              }
              while (v91 != v92);
            }
            v91 = v286;
            goto LABEL_145;
          }
          break;
        }
        *(_QWORD *)v287 = v90;
        v88 = (uint64_t)(v91 + 8);
        goto LABEL_122;
      }
      goto LABEL_85;
    }
    v69 = v287;
    if (v287 < v288)
    {
      *(_QWORD *)v287 = v68;
      v70 = (uint64_t)(v69 + 8);
LABEL_118:
      v287 = (char *)v70;
      v67 = v267.__locale_;
      goto LABEL_119;
    }
    v71 = v286;
    v72 = (v287 - v286) >> 3;
    v73 = v72 + 1;
    if ((unint64_t)(v72 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v74 = v288 - v286;
    if ((v288 - v286) >> 2 > v73)
      v73 = v74 >> 2;
    if ((unint64_t)v74 >= 0x7FFFFFFFFFFFFFF8)
      v75 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v75 = v73;
    if (v75)
    {
      if (v75 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v76 = (char *)operator new(8 * v75);
      v77 = &v76[8 * v72];
      *(_QWORD *)v77 = *((_QWORD *)v67 + 18);
      v70 = (uint64_t)(v77 + 8);
      if (v69 == v71)
        goto LABEL_116;
    }
    else
    {
      v76 = 0;
      v77 = (char *)(8 * v72);
      *(_QWORD *)(8 * v72) = v68;
      v70 = 8 * v72 + 8;
      if (v69 == v71)
      {
LABEL_116:
        v286 = v77;
        v287 = (char *)v70;
        v288 = &v76[8 * v75];
        if (v69)
          operator delete(v69);
        goto LABEL_118;
      }
    }
    v78 = v69 - 8 - v71;
    if (v78 < 0x58)
      goto LABEL_367;
    if ((unint64_t)(v71 - v76) < 0x20)
      goto LABEL_367;
    v79 = (v78 >> 3) + 1;
    v80 = 8 * (v79 & 0x3FFFFFFFFFFFFFFCLL);
    v81 = &v69[-v80];
    v77 -= v80;
    v82 = &v76[8 * v72 - 16];
    v83 = v69 - 16;
    v84 = v79 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v85 = *(_OWORD *)v83;
      *((_OWORD *)v82 - 1) = *((_OWORD *)v83 - 1);
      *(_OWORD *)v82 = v85;
      v82 -= 32;
      v83 -= 32;
      v84 -= 4;
    }
    while (v84);
    v69 = v81;
    if (v79 != (v79 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_367:
      do
      {
        v86 = *((_QWORD *)v69 - 1);
        v69 -= 8;
        *((_QWORD *)v77 - 1) = v86;
        v77 -= 8;
      }
      while (v69 != v71);
    }
    v69 = v286;
    goto LABEL_116;
  }
  if (a3 != 1)
  {
    if (a3)
      goto LABEL_354;
    v287 = 0;
    v284 = 0u;
    v285 = 0u;
    v283 = 0u;
    v280 = 0u;
    v281 = 0u;
    v282 = 1065353216;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = a1;
    v9 = v8 + 8;
    v286 = v8;
    v288 = v8 + 8;
    while (1)
    {
      v267.__locale_ = 0;
      v267.__locale_ = (std::locale::__imp *)*((_QWORD *)v9 - 1);
      v287 = v9 - 8;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v267;
      if (!*((_BYTE *)std::__hash_table<std::__hash_value_type<HGNode const*,BOOL>,std::__unordered_map_hasher<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::hash<HGNode const*>,std::equal_to<HGNode const*>,true>,std::__unordered_map_equal<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::equal_to<HGNode const*>,std::hash<HGNode const*>,true>,std::allocator<std::__hash_value_type<HGNode const*,BOOL>>>::__emplace_unique_key_args<HGNode const*,std::piecewise_construct_t const&,std::tuple<HGNode const* const&>,std::tuple<>>((uint64_t)&v280, (uint64_t *)&v267, (uint64_t)&std::piecewise_construct, &__dst)+ 24))
      {
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v267;
        *((_BYTE *)std::__hash_table<std::__hash_value_type<HGNode const*,BOOL>,std::__unordered_map_hasher<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::hash<HGNode const*>,std::equal_to<HGNode const*>,true>,std::__unordered_map_equal<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::equal_to<HGNode const*>,std::hash<HGNode const*>,true>,std::allocator<std::__hash_value_type<HGNode const*,BOOL>>>::__emplace_unique_key_args<HGNode const*,std::piecewise_construct_t const&,std::tuple<HGNode const* const&>,std::tuple<>>((uint64_t)&v280, (uint64_t *)&v267, (uint64_t)&std::piecewise_construct, &__dst)+ 24) = 1;
        v10 = v285;
        if (!(_QWORD)v285)
        {
          std::deque<HGNode const*>::__add_front_capacity((uint64_t)&v283);
          v10 = v285;
        }
        v11 = (_QWORD *)(*((_QWORD *)&v283 + 1) + 8 * (v10 >> 9));
        if ((_QWORD)v284 == *((_QWORD *)&v283 + 1))
          v12 = 0;
        else
          v12 = *v11 + 8 * (v10 & 0x1FF);
        if (v12 == *v11)
          v12 = *(v11 - 1) + 4096;
        *(std::locale *)(v12 - 8) = v267;
        *(_QWORD *)&v285 = v10 - 1;
        ++*((_QWORD *)&v285 + 1);
        v13 = v267.__locale_;
        if (*((int *)v267.__locale_ + 22) >= 1)
          break;
      }
LABEL_8:
      v9 = v287;
      if (v286 == v287)
      {
        v112 = (_QWORD *)(*((_QWORD *)&v283 + 1) + 8 * ((unint64_t)v285 >> 9));
        if ((_QWORD)v284 == *((_QWORD *)&v283 + 1))
        {
          v113 = 0;
          v115 = 0;
          v114 = (_QWORD *)(v284 + 8 * ((*((_QWORD *)&v285 + 1) + (_QWORD)v285) >> 9));
        }
        else
        {
          v113 = (unint64_t *)(*v112 + 8 * (v285 & 0x1FF));
          v114 = (_QWORD *)(*((_QWORD *)&v283 + 1) + 8 * ((*((_QWORD *)&v285 + 1) + (_QWORD)v285) >> 9));
          v115 = (unint64_t *)(*v114 + 8 * ((*((_QWORD *)&v285 + 1) + v285) & 0x1FF));
        }
        v165 = (char *)hgstd::stable_unique<std::__deque_iterator<HGNode const*,HGNode const**,HGNode const*&,HGNode const***,long,512l>>(v112, v113, (uint64_t)v114, v115);
        v167 = (char *)(*((_QWORD *)&v283 + 1) + 8 * ((unint64_t)v285 >> 9));
        if ((_QWORD)v284 == *((_QWORD *)&v283 + 1))
        {
          v168 = 0;
          if (!v166)
            goto LABEL_222;
LABEL_220:
          v169 = ((v166 - *(_QWORD *)v165) >> 3) + ((v165 - v167) << 6) - ((v168 - *(_QWORD *)v167) >> 3);
        }
        else
        {
          v168 = *(_QWORD *)v167 + 8 * (v285 & 0x1FF);
          if (v166 != v168)
            goto LABEL_220;
LABEL_222:
          v169 = 0;
        }
        std::deque<HGNode const*>::resize(&v283, v169);
        v170 = *((_QWORD *)&v283 + 1);
        v171 = v284;
        v172 = (_QWORD *)(*((_QWORD *)&v283 + 1) + 8 * ((unint64_t)v285 >> 9));
        if ((_QWORD)v284 == *((_QWORD *)&v283 + 1))
          v173 = 0;
        else
          v173 = (unint64_t *)(*v172 + 8 * (v285 & 0x1FF));
        v258 = *(std::locale::__imp **)(MEMORY[0x1E0DE4F50] + 16);
        v255 = *(std::locale::__imp **)(MEMORY[0x1E0DE4F50] + 24);
        v253 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 32);
        v250 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 40);
        v248 = *(std::locale::__imp **)(MEMORY[0x1E0DE4F50] + 48);
        v174 = (std::locale::__imp *)*MEMORY[0x1E0DE4F50];
        v246 = *(std::locale::__imp **)(MEMORY[0x1E0DE4F50] + 8);
        v263 = *(std::locale::__imp **)(MEMORY[0x1E0DE4F50] + 64);
        v261 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
        v244 = MEMORY[0x1E0DE4FB8] + 16;
        v175 = MEMORY[0x1E0DE4FD0];
        while (2)
        {
          if (v171 == v170)
          {
            if (!v173)
            {
LABEL_255:
              v189 = (_QWORD *)v281;
              if ((_QWORD)v281)
              {
                do
                {
                  v190 = (_QWORD *)*v189;
                  operator delete(v189);
                  v189 = v190;
                }
                while (v190);
              }
              v191 = (void *)v280;
              *(_QWORD *)&v280 = 0;
              if (v191)
                operator delete(v191);
              v192 = (void **)*((_QWORD *)&v283 + 1);
              v193 = (void **)v284;
              *((_QWORD *)&v285 + 1) = 0;
              v194 = v284 - *((_QWORD *)&v283 + 1);
              if ((_QWORD)v284 - *((_QWORD *)&v283 + 1) >= 0x11uLL)
              {
                do
                {
                  operator delete(*v192);
                  v193 = (void **)v284;
                  v192 = (void **)(*((_QWORD *)&v283 + 1) + 8);
                  *((_QWORD *)&v283 + 1) = v192;
                  v194 = v284 - (_QWORD)v192;
                }
                while ((_QWORD)v284 - (_QWORD)v192 > 0x10uLL);
              }
              v195 = v194 >> 3;
              if (v195 == 1)
              {
                v196 = 256;
LABEL_334:
                *(_QWORD *)&v285 = v196;
              }
              else if (v195 == 2)
              {
                v196 = 512;
                goto LABEL_334;
              }
              if (v192 != v193)
              {
                do
                {
                  v237 = *v192++;
                  operator delete(v237);
                }
                while (v192 != v193);
LABEL_337:
                if ((_QWORD)v284 != *((_QWORD *)&v283 + 1))
                  *(_QWORD *)&v284 = v284 + ((*((_QWORD *)&v283 + 1) - v284 + 7) & 0xFFFFFFFFFFFFFFF8);
              }
              goto LABEL_339;
            }
          }
          else if (v173 == (unint64_t *)(*(_QWORD *)(v170
                                                           + (((*((_QWORD *)&v285 + 1) + (_QWORD)v285) >> 6) & 0x3FFFFFFFFFFFFF8))
                                               + 8 * ((*((_QWORD *)&v285 + 1) + v285) & 0x1FF)))
          {
            goto LABEL_255;
          }
          v176 = *v173;
          std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&__dst);
          v177 = (const char *)(*(uint64_t (**)(unint64_t))(*(_QWORD *)v176 + 48))(v176);
          v178 = strlen(v177);
          v179 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__dst.__r_.__value_.__r.__words[2], (uint64_t)v177, v178);
          std::ios_base::getloc((const std::ios_base *)((char *)v179 + *(_QWORD *)(*v179 - 24)));
          v180 = std::locale::use_facet(&v267, MEMORY[0x1E0DE4A90]);
          ((void (*)(const std::locale::facet *, uint64_t))v180->__vftable[2].~facet_0)(v180, 10);
          std::locale::~locale(&v267);
          std::ostream::put();
          std::ostream::flush();
          *(_DWORD *)((char *)v276 + *(_QWORD *)(__dst.__r_.__value_.__r.__words[2] - 24)) = *(_DWORD *)((_BYTE *)v276 + *(_QWORD *)(__dst.__r_.__value_.__r.__words[2] - 24)) & 0xFFFFFFB5 | 8;
          v181 = (_QWORD *)std::ostream::operator<<();
          *(_DWORD *)((char *)v181 + *(_QWORD *)(*v181 - 24) + 8) = *(_DWORD *)((_BYTE *)v181
                                                                                + *(_QWORD *)(*v181 - 24)
                                                                                + 8) & 0xFFFFFFB5 | 2;
          std::stringbuf::str();
          if (v269 >= 0)
            v182 = &v267;
          else
            v182 = v267.__locale_;
          HGDotGraph::node((uint64_t *)v289, v176, (uint64_t)v182, 0);
          v240 = v173;
          v242 = v172;
          if (SHIBYTE(v269) < 0)
          {
            operator delete(v267.__locale_);
            v183 = *(_DWORD *)(v176 + 88);
            if (v183 < 1)
            {
LABEL_251:
              __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v174;
              *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + *((_QWORD *)v174 - 3)) = (std::string::size_type)v263;
              __dst.__r_.__value_.__r.__words[2] = v261;
              v276[0] = MEMORY[0x1E0DE4FB8] + 16;
              if (v278 < 0)
                operator delete(v277);
              std::streambuf::~streambuf();
              std::iostream::~basic_iostream();
              MEMORY[0x1B5E290BC](v279);
              ++v173;
              if ((unint64_t *)((char *)v240 - *v172 + 8) == (unint64_t *)4096)
              {
                ++v172;
                v173 = (unint64_t *)v242[1];
              }
              v170 = *((_QWORD *)&v283 + 1);
              v171 = v284;
              continue;
            }
          }
          else
          {
            v183 = *(_DWORD *)(v176 + 88);
            if (v183 < 1)
              goto LABEL_251;
          }
          break;
        }
        for (k = 0; k < v183; ++k)
        {
          v185 = *(_QWORD *)(*(_QWORD *)(v176 + 80) + 8 * k);
          if (v185 && *(_QWORD *)(v185 + 16))
          {
            v274[0] = v175 + 104;
            v269 = v175 + 64;
            v267.__locale_ = v258;
            *(std::locale::__imp **)((char *)&v267.__locale_ + *((_QWORD *)v258 - 3)) = v255;
            v268 = 0;
            v186 = (std::ios_base *)((char *)&v267 + *((_QWORD *)v267.__locale_ - 3));
            std::ios_base::init(v186, v270);
            v186[1].__vftable = 0;
            v186[1].__fmtflags_ = -1;
            v269 = v253;
            *(_QWORD *)((char *)&v270[-1] + *(_QWORD *)(v253 - 24)) = v250;
            v267.__locale_ = v246;
            *(std::locale::__imp **)((char *)&v267.__locale_ + *((_QWORD *)v246 - 3)) = v248;
            v274[0] = v175 + 104;
            v267.__locale_ = (std::locale::__imp *)(v175 + 24);
            v269 = v175 + 64;
            std::streambuf::basic_streambuf();
            v270[0] = v244;
            v271 = 0u;
            v272 = 0u;
            v273 = 24;
            std::ostream::operator<<();
            v187 = *(_QWORD *)(v185 + 16);
            std::stringbuf::str();
            if (v266 >= 0)
              v188 = __p;
            else
              v188 = (void **)__p[0];
            HGDotGraph::link((uint64_t *)v289, v187, v176, (const char *)v188, 0);
            if (v266 < 0)
              operator delete(__p[0]);
            v267.__locale_ = v174;
            *(std::locale::__imp **)((char *)&v267.__locale_ + *((_QWORD *)v174 - 3)) = v263;
            v269 = v261;
            v270[0] = MEMORY[0x1E0DE4FB8] + 16;
            if (SBYTE7(v272) < 0)
              operator delete((void *)v271);
            std::streambuf::~streambuf();
            std::iostream::~basic_iostream();
            MEMORY[0x1B5E290BC](v274);
            v183 = *(_DWORD *)(v176 + 88);
          }
        }
        goto LABEL_251;
      }
    }
    v14 = 0;
    while (1)
    {
      v16 = *(_QWORD *)(*((_QWORD *)v13 + 10) + 8 * v14);
      if (!v16)
        goto LABEL_21;
      v17 = *(_QWORD *)(v16 + 16);
      if (!v17)
        goto LABEL_21;
      v18 = v287;
      if (v287 >= v288)
        break;
      *(_QWORD *)v287 = v17;
      v15 = (uint64_t)(v18 + 8);
LABEL_20:
      v287 = (char *)v15;
      v13 = v267.__locale_;
LABEL_21:
      if (++v14 >= *((int *)v13 + 22))
        goto LABEL_8;
    }
    v19 = v286;
    v20 = (v287 - v286) >> 3;
    v21 = v20 + 1;
    if ((unint64_t)(v20 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v22 = v288 - v286;
    if ((v288 - v286) >> 2 > v21)
      v21 = v22 >> 2;
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8)
      v23 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v23 = v21;
    if (v23)
    {
      if (v23 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v24 = (char *)operator new(8 * v23);
      v25 = &v24[8 * v20];
      *(_QWORD *)v25 = *(_QWORD *)(v16 + 16);
      v15 = (uint64_t)(v25 + 8);
      if (v18 == v19)
        goto LABEL_43;
    }
    else
    {
      v24 = 0;
      v25 = (char *)(8 * v20);
      *(_QWORD *)(8 * v20) = v17;
      v15 = 8 * v20 + 8;
      if (v18 == v19)
      {
LABEL_43:
        v286 = v25;
        v288 = &v24[8 * v23];
        if (v18)
          operator delete(v18);
        goto LABEL_20;
      }
    }
    v26 = v18 - 8 - v19;
    if (v26 < 0x58)
      goto LABEL_368;
    if ((unint64_t)(v19 - v24) < 0x20)
      goto LABEL_368;
    v27 = (v26 >> 3) + 1;
    v28 = 8 * (v27 & 0x3FFFFFFFFFFFFFFCLL);
    v29 = &v18[-v28];
    v25 -= v28;
    v30 = &v24[8 * v20 - 16];
    v31 = v18 - 16;
    v32 = v27 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v33 = *(_OWORD *)v31;
      *((_OWORD *)v30 - 1) = *((_OWORD *)v31 - 1);
      *(_OWORD *)v30 = v33;
      v30 -= 32;
      v31 -= 32;
      v32 -= 4;
    }
    while (v32);
    v18 = v29;
    if (v27 != (v27 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_368:
      do
      {
        v34 = *((_QWORD *)v18 - 1);
        v18 -= 8;
        *((_QWORD *)v25 - 1) = v34;
        v25 -= 8;
      }
      while (v18 != v19);
    }
    v18 = v286;
    goto LABEL_43;
  }
  v287 = 0;
  v284 = 0u;
  v285 = 0u;
  v283 = 0u;
  v280 = 0u;
  v281 = 0u;
  v282 = 1065353216;
  v35 = (char *)operator new(8uLL);
  *(_QWORD *)v35 = a1;
  v36 = v35 + 8;
  v286 = v35;
  v288 = v35 + 8;
  do
  {
    v267.__locale_ = 0;
    v267.__locale_ = (std::locale::__imp *)*((_QWORD *)v36 - 1);
    v287 = v36 - 8;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v267;
    if (!*((_BYTE *)std::__hash_table<std::__hash_value_type<HGNode const*,BOOL>,std::__unordered_map_hasher<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::hash<HGNode const*>,std::equal_to<HGNode const*>,true>,std::__unordered_map_equal<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::equal_to<HGNode const*>,std::hash<HGNode const*>,true>,std::allocator<std::__hash_value_type<HGNode const*,BOOL>>>::__emplace_unique_key_args<HGNode const*,std::piecewise_construct_t const&,std::tuple<HGNode const* const&>,std::tuple<>>((uint64_t)&v280, (uint64_t *)&v267, (uint64_t)&std::piecewise_construct, &__dst)+ 24))
    {
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v267;
      *((_BYTE *)std::__hash_table<std::__hash_value_type<HGNode const*,BOOL>,std::__unordered_map_hasher<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::hash<HGNode const*>,std::equal_to<HGNode const*>,true>,std::__unordered_map_equal<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::equal_to<HGNode const*>,std::hash<HGNode const*>,true>,std::allocator<std::__hash_value_type<HGNode const*,BOOL>>>::__emplace_unique_key_args<HGNode const*,std::piecewise_construct_t const&,std::tuple<HGNode const* const&>,std::tuple<>>((uint64_t)&v280, (uint64_t *)&v267, (uint64_t)&std::piecewise_construct, &__dst)+ 24) = 1;
      v37 = v285;
      if (!(_QWORD)v285)
      {
        std::deque<HGNode const*>::__add_front_capacity((uint64_t)&v283);
        v37 = v285;
      }
      v38 = (_QWORD *)(*((_QWORD *)&v283 + 1) + 8 * (v37 >> 9));
      if ((_QWORD)v284 == *((_QWORD *)&v283 + 1))
        v39 = 0;
      else
        v39 = *v38 + 8 * (v37 & 0x1FF);
      if (v39 == *v38)
        v39 = *(v38 - 1) + 4096;
      *(std::locale *)(v39 - 8) = v267;
      *(_QWORD *)&v285 = v37 - 1;
      ++*((_QWORD *)&v285 + 1);
      if ((*((_BYTE *)v267.__locale_ + 136) & 2) != 0)
      {
        v40 = (std::locale::__imp *)*((_QWORD *)v267.__locale_ + 18);
        v267.__locale_ = v40;
        if (*((int *)v40 + 22) >= 1)
        {
          v41 = 0;
          while (1)
          {
            v43 = *(_QWORD *)(*((_QWORD *)v40 + 10) + 8 * v41);
            if (!v43)
              goto LABEL_60;
            v44 = *(_QWORD *)(v43 + 16);
            if (!v44)
              goto LABEL_60;
            v45 = v287;
            if (v287 >= v288)
              break;
            *(_QWORD *)v287 = v44;
            v42 = (uint64_t)(v45 + 8);
LABEL_59:
            v287 = (char *)v42;
            v40 = v267.__locale_;
LABEL_60:
            if (++v41 >= *((int *)v40 + 22))
              goto LABEL_46;
          }
          v46 = v286;
          v47 = (v287 - v286) >> 3;
          v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v49 = v288 - v286;
          if ((v288 - v286) >> 2 > v48)
            v48 = v49 >> 2;
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8)
            v50 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v50 = v48;
          if (v50)
          {
            if (v50 >> 61)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v51 = (char *)operator new(8 * v50);
            v52 = &v51[8 * v47];
            *(_QWORD *)v52 = *(_QWORD *)(v43 + 16);
            v42 = (uint64_t)(v52 + 8);
            if (v45 == v46)
              goto LABEL_82;
          }
          else
          {
            v51 = 0;
            v52 = (char *)(8 * v47);
            *(_QWORD *)(8 * v47) = v44;
            v42 = 8 * v47 + 8;
            if (v45 == v46)
            {
LABEL_82:
              v286 = v52;
              v288 = &v51[8 * v50];
              if (v45)
                operator delete(v45);
              goto LABEL_59;
            }
          }
          v53 = v45 - 8 - v46;
          if (v53 < 0x58)
            goto LABEL_369;
          if ((unint64_t)(v46 - v51) < 0x20)
            goto LABEL_369;
          v54 = (v53 >> 3) + 1;
          v55 = 8 * (v54 & 0x3FFFFFFFFFFFFFFCLL);
          v56 = &v45[-v55];
          v52 -= v55;
          v57 = &v51[8 * v47 - 16];
          v58 = v45 - 16;
          v59 = v54 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v60 = *(_OWORD *)v58;
            *((_OWORD *)v57 - 1) = *((_OWORD *)v58 - 1);
            *(_OWORD *)v57 = v60;
            v57 -= 32;
            v58 -= 32;
            v59 -= 4;
          }
          while (v59);
          v45 = v56;
          if (v54 != (v54 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_369:
            do
            {
              v61 = *((_QWORD *)v45 - 1);
              v45 -= 8;
              *((_QWORD *)v52 - 1) = v61;
              v52 -= 8;
            }
            while (v45 != v46);
          }
          v45 = v286;
          goto LABEL_82;
        }
      }
    }
LABEL_46:
    v36 = v287;
  }
  while (v286 != v287);
  v108 = (_QWORD *)(*((_QWORD *)&v283 + 1) + 8 * ((unint64_t)v285 >> 9));
  if ((_QWORD)v284 == *((_QWORD *)&v283 + 1))
  {
    v109 = 0;
    v111 = 0;
    v110 = (_QWORD *)(v284 + 8 * ((*((_QWORD *)&v285 + 1) + (_QWORD)v285) >> 9));
  }
  else
  {
    v109 = (unint64_t *)(*v108 + 8 * (v285 & 0x1FF));
    v110 = (_QWORD *)(*((_QWORD *)&v283 + 1) + 8 * ((*((_QWORD *)&v285 + 1) + (_QWORD)v285) >> 9));
    v111 = (unint64_t *)(*v110 + 8 * ((*((_QWORD *)&v285 + 1) + v285) & 0x1FF));
  }
  v120 = (char *)hgstd::stable_unique<std::__deque_iterator<HGNode const*,HGNode const**,HGNode const*&,HGNode const***,long,512l>>(v108, v109, (uint64_t)v110, v111);
  v122 = (char *)(*((_QWORD *)&v283 + 1) + 8 * ((unint64_t)v285 >> 9));
  if ((_QWORD)v284 == *((_QWORD *)&v283 + 1))
  {
    v123 = 0;
    if (!v121)
      goto LABEL_158;
LABEL_156:
    v124 = ((v121 - *(_QWORD *)v120) >> 3) + ((v120 - v122) << 6) - ((v123 - *(_QWORD *)v122) >> 3);
  }
  else
  {
    v123 = *(_QWORD *)v122 + 8 * (v285 & 0x1FF);
    if (v121 != v123)
      goto LABEL_156;
LABEL_158:
    v124 = 0;
  }
  std::deque<HGNode const*>::resize(&v283, v124);
  v125 = *((_QWORD *)&v283 + 1);
  v126 = v284;
  v127 = (_QWORD *)(*((_QWORD *)&v283 + 1) + 8 * ((unint64_t)v285 >> 9));
  if ((_QWORD)v284 == *((_QWORD *)&v283 + 1))
    v128 = 0;
  else
    v128 = *v127 + 8 * (v285 & 0x1FF);
  v129 = &__dst.__r_.__value_.__r.__words[2];
  v130 = v276;
  v131 = (std::locale::__imp *)*MEMORY[0x1E0DE4F50];
  v257 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  v260 = *(std::locale::__imp **)(MEMORY[0x1E0DE4F50] + 64);
  v252 = MEMORY[0x1E0DE4FB8] + 16;
  while (2)
  {
    if (v126 != v125)
    {
      if (v128 == *(_QWORD *)(v125 + (((*((_QWORD *)&v285 + 1) + (_QWORD)v285) >> 6) & 0x3FFFFFFFFFFFFF8))
                 + 8 * ((*((_QWORD *)&v285 + 1) + (_QWORD)v285) & 0x1FFLL))
        goto LABEL_208;
LABEL_169:
      v133 = *(_QWORD **)v128;
      if ((*(_BYTE *)(*(_QWORD *)v128 + 136) & 2) == 0)
      {
        v134 = v128;
        v135 = v130;
        v136 = v129;
        v137 = v127;
        v138 = (const char *)(*(uint64_t (**)(_QWORD *))(*v133 + 48))(v133);
        v139 = strlen(v138);
        if (v139 >= 0x7FFFFFFFFFFFFFF8)
          std::string::__throw_length_error[abi:ne180100]();
        v140 = v139;
        if (v139 >= 0x17)
        {
          v150 = (v139 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v139 | 7) != 0x17)
            v150 = v139 | 7;
          v151 = v150 + 1;
          p_dst = (std::string *)operator new(v150 + 1);
          __dst.__r_.__value_.__l.__size_ = v140;
          __dst.__r_.__value_.__r.__words[2] = v151 | 0x8000000000000000;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
        }
        else
        {
          *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v139;
          p_dst = &__dst;
          if (!v139)
          {
LABEL_184:
            p_dst->__r_.__value_.__s.__data_[v140] = 0;
            std::string::append(&__dst, "\n[kRendererOutput flag is NOT set. Call GetOutput()]");
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v152 = &__dst;
            else
              v152 = (std::string *)__dst.__r_.__value_.__r.__words[0];
            HGDotGraph::node((uint64_t *)v289, (unint64_t)v133, (uint64_t)v152, 0);
            v127 = v137;
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__dst.__r_.__value_.__l.__data_);
            v129 = v136;
            v130 = v135;
            v128 = v134 + 8;
            if (v134 + 8 - *v127 == 4096)
              goto LABEL_163;
            goto LABEL_164;
          }
        }
        memmove(p_dst, v138, v140);
        goto LABEL_184;
      }
      v142 = v133[18];
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&__dst);
      v143 = (const char *)(*(uint64_t (**)(unint64_t))(*(_QWORD *)v142 + 48))(v142);
      v144 = strlen(v143);
      v145 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v129, (uint64_t)v143, v144);
      std::ios_base::getloc((const std::ios_base *)((char *)v145 + *(_QWORD *)(*v145 - 24)));
      v146 = std::locale::use_facet(&v267, MEMORY[0x1E0DE4A90]);
      ((void (*)(const std::locale::facet *, uint64_t))v146->__vftable[2].~facet_0)(v146, 10);
      std::locale::~locale(&v267);
      std::ostream::put();
      std::ostream::flush();
      *(_DWORD *)((char *)v130 + *(_QWORD *)(__dst.__r_.__value_.__r.__words[2] - 24)) = *(_DWORD *)((_BYTE *)v130 + *(_QWORD *)(__dst.__r_.__value_.__r.__words[2] - 24)) & 0xFFFFFFB5 | 8;
      v147 = (_QWORD *)std::ostream::operator<<();
      *(_DWORD *)((char *)v147 + *(_QWORD *)(*v147 - 24) + 8) = *(_DWORD *)((_BYTE *)v147
                                                                            + *(_QWORD *)(*v147 - 24)
                                                                            + 8) & 0xFFFFFFB5 | 2;
      std::stringbuf::str();
      if (v269 >= 0)
        v148 = &v267;
      else
        v148 = v267.__locale_;
      HGDotGraph::node((uint64_t *)v289, v142, (uint64_t)v148, 0);
      if (SHIBYTE(v269) < 0)
      {
        operator delete(v267.__locale_);
        v149 = *(_DWORD *)(v142 + 88);
        if (v149 < 1)
          goto LABEL_204;
      }
      else
      {
        v149 = *(_DWORD *)(v142 + 88);
        if (v149 < 1)
          goto LABEL_204;
      }
      for (m = 0; m < v149; ++m)
      {
        v154 = *(_QWORD *)(*(_QWORD *)(v142 + 80) + 8 * m);
        if (v154 && *(_QWORD *)(v154 + 16))
        {
          std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v267);
          std::ostream::operator<<();
          v155 = *(_QWORD *)(*(_QWORD *)(v154 + 16) + 144);
          std::stringbuf::str();
          if (v266 >= 0)
            v156 = __p;
          else
            v156 = (void **)__p[0];
          HGDotGraph::link((uint64_t *)v289, v155, v142, (const char *)v156, 0);
          if (v266 < 0)
            operator delete(__p[0]);
          v267.__locale_ = v131;
          *(std::locale::__imp **)((char *)&v267.__locale_ + *((_QWORD *)v131 - 3)) = v260;
          v269 = v257;
          v270[0] = v252;
          if (SBYTE7(v272) < 0)
            operator delete((void *)v271);
          std::streambuf::~streambuf();
          std::iostream::~basic_iostream();
          MEMORY[0x1B5E290BC](v274);
          v149 = *(_DWORD *)(v142 + 88);
        }
      }
LABEL_204:
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v131;
      *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + *((_QWORD *)v131 - 3)) = (std::string::size_type)v260;
      __dst.__r_.__value_.__r.__words[2] = v257;
      v276[0] = MEMORY[0x1E0DE4FB8] + 16;
      if (v278 < 0)
        operator delete(v277);
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x1B5E290BC](v279);
      v128 += 8;
      if (v128 - *v127 == 4096)
      {
LABEL_163:
        v132 = v127[1];
        ++v127;
        v128 = v132;
      }
LABEL_164:
      v125 = *((_QWORD *)&v283 + 1);
      v126 = v284;
      continue;
    }
    break;
  }
  if (v128)
    goto LABEL_169;
LABEL_208:
  v157 = (_QWORD *)v281;
  if ((_QWORD)v281)
  {
    do
    {
      v158 = (_QWORD *)*v157;
      operator delete(v157);
      v157 = v158;
    }
    while (v158);
  }
  v159 = (void *)v280;
  *(_QWORD *)&v280 = 0;
  if (v159)
    operator delete(v159);
  v160 = (void **)*((_QWORD *)&v283 + 1);
  v161 = (void **)v284;
  *((_QWORD *)&v285 + 1) = 0;
  v162 = v284 - *((_QWORD *)&v283 + 1);
  if ((_QWORD)v284 - *((_QWORD *)&v283 + 1) >= 0x11uLL)
  {
    do
    {
      operator delete(*v160);
      v161 = (void **)v284;
      v160 = (void **)(*((_QWORD *)&v283 + 1) + 8);
      *((_QWORD *)&v283 + 1) = v160;
      v162 = v284 - (_QWORD)v160;
    }
    while ((_QWORD)v284 - (_QWORD)v160 > 0x10uLL);
  }
  v163 = v162 >> 3;
  if (v163 == 1)
  {
    v164 = 256;
LABEL_329:
    *(_QWORD *)&v285 = v164;
  }
  else if (v163 == 2)
  {
    v164 = 512;
    goto LABEL_329;
  }
  if (v160 != v161)
  {
    do
    {
      v236 = *v160++;
      operator delete(v236);
    }
    while (v160 != v161);
    goto LABEL_337;
  }
LABEL_339:
  if ((_QWORD)v283)
    operator delete((void *)v283);
  v238 = v286;
  if (v286)
    goto LABEL_353;
LABEL_354:
  HGDotGraph::end((HGDotGraph *)v289);
  HGDotGraph::~HGDotGraph((HGDotGraph *)v289);
}

void sub_1B2A69AF4(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;

  std::__hash_table<std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>,std::__unordered_map_hasher<OZSceneNode *,std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>,std::hash<OZSceneNode *>,std::equal_to<OZSceneNode *>,true>,std::__unordered_map_equal<OZSceneNode *,std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>,std::equal_to<OZSceneNode *>,std::hash<OZSceneNode *>,true>,std::allocator<std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>>>::~__hash_table((uint64_t)&STACK[0x2D0]);
  std::deque<HGNode *>::~deque[abi:ne180100](v1 - 256);
  v3 = *(void **)(v1 - 208);
  if (v3)
  {
    *(_QWORD *)(v1 - 200) = v3;
    operator delete(v3);
  }
  HGDotGraph::~HGDotGraph((HGDotGraph *)(v1 - 184));
  _Unwind_Resume(a1);
}

_QWORD *hgstd::stable_unique<std::__deque_iterator<HGNode const*,HGNode const**,HGNode const*&,HGNode const***,long,512l>>(_QWORD *a1, unint64_t *a2, uint64_t a3, unint64_t *a4)
{
  unint64_t *v4;
  _QWORD *v5;
  uint64_t *v7;
  unint64_t *v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t **v11;
  uint64_t **v12;
  uint64_t **v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t **v16;
  unint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  uint64_t *v20;
  unint64_t *v21;
  unint64_t *v22;
  unint64_t *v23;
  uint64_t **v25;
  uint64_t *v26;
  uint64_t v27;

  v4 = a2;
  v5 = a1;
  v26 = 0;
  v27 = 0;
  v25 = &v26;
  if (a2 != a4)
  {
    v7 = 0;
    v8 = a2;
    v9 = a1;
    while (1)
    {
      v10 = *v8;
      v11 = &v26;
      v12 = &v26;
      if (v7)
      {
        v13 = &v26;
        v14 = v7;
        do
        {
          v15 = v14;
          v16 = v13;
          v17 = v14[4];
          if (v17 >= v10)
            v13 = (uint64_t **)v14;
          else
            ++v14;
          v14 = (uint64_t *)*v14;
        }
        while (v14);
        if (v13 != &v26)
        {
          if (v17 < v10)
            v15 = (uint64_t *)v16;
          if (v10 >= v15[4])
            goto LABEL_26;
        }
        v18 = v7;
        while (1)
        {
          while (1)
          {
            v12 = (uint64_t **)v18;
            v19 = v18[4];
            if (v10 >= v19)
              break;
            v18 = *v12;
            v11 = v12;
            if (!*v12)
              goto LABEL_20;
          }
          if (v19 >= v10)
            break;
          v18 = v12[1];
          if (!v18)
          {
            v11 = v12 + 1;
            goto LABEL_20;
          }
        }
      }
      else
      {
LABEL_20:
        v20 = (uint64_t *)operator new(0x28uLL);
        v20[4] = v10;
        *v20 = 0;
        v20[1] = 0;
        v20[2] = (uint64_t)v12;
        *v11 = v20;
        if (*v25)
        {
          v25 = (uint64_t **)*v25;
          v20 = *v11;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v26, v20);
        ++v27;
        v10 = *v8;
      }
      v21 = v4 + 1;
      if ((unint64_t *)((char *)v4 - *v5 + 8) == (unint64_t *)4096)
      {
        v22 = (unint64_t *)v5[1];
        ++v5;
        v21 = v22;
      }
      *v4 = v10;
      v4 = v21;
LABEL_26:
      if ((unint64_t *)((char *)++v8 - *v9) == (unint64_t *)4096)
      {
        v23 = (unint64_t *)v9[1];
        ++v9;
        v8 = v23;
      }
      v7 = v26;
      if (v8 == a4)
        goto LABEL_29;
    }
  }
  v7 = 0;
LABEL_29:
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v25, v7);
  return v5;
}

void sub_1B2A69E48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  _QWORD *v2;
  va_list va;

  va_start(va, a2);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)va, v2);
  _Unwind_Resume(a1);
}

void std::deque<HGNode const*>::resize(_QWORD *a1, unint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v3 = a1[5];
  if (a2 > v3)
  {
    std::deque<HGNode const*>::__append(a1, a2 - v3);
    return;
  }
  if (a2 < v3)
  {
    v4 = a1[4];
    v6 = a1[1];
    v5 = a1[2];
    v7 = (char *)(v6 + 8 * (v4 >> 9));
    if (v5 == v6)
    {
      v8 = 0;
      if (!a2)
        goto LABEL_10;
    }
    else
    {
      v8 = *(_QWORD *)v7 + 8 * (a1[4] & 0x1FFLL);
      if (!a2)
        goto LABEL_10;
    }
    v9 = a2 + ((v8 - *(_QWORD *)v7) >> 3);
    if (v9 < 1)
    {
      v14 = 511 - v9;
      v7 -= 8 * (v14 >> 9);
      v8 = *(_QWORD *)v7 + 8 * (~(_WORD)v14 & 0x1FF);
      v10 = v4 + v3;
      v11 = (char *)(v6 + 8 * ((v4 + v3) >> 9));
      v12 = v5 - v6;
      if (v5 != v6)
      {
LABEL_11:
        v13 = *(_QWORD *)v11 + 8 * (v10 & 0x1FF);
        if (v8 == v13)
          return;
        goto LABEL_15;
      }
LABEL_14:
      v13 = 0;
      if (!v8)
        return;
LABEL_15:
      v15 = ((v13 - *(_QWORD *)v11) >> 3) + ((v11 - v7) << 6) - ((v8 - *(_QWORD *)v7) >> 3);
      if (v15 >= 1)
      {
        v16 = v5 == v6 ? 0 : (v12 << 6) - 1;
        v17 = v3 - v15;
        a1[5] = v17;
        if (v16 - v4 - v17 >= 0x400)
        {
          do
          {
            operator delete(*(void **)(v5 - 8));
            v18 = a1[1];
            v5 = a1[2] - 8;
            a1[2] = v5;
            if (v5 == v18)
              v19 = 0;
            else
              v19 = ((v5 - v18) << 6) - 1;
          }
          while ((unint64_t)(v19 - (a1[5] + a1[4])) > 0x3FF);
        }
      }
      return;
    }
    v7 += 8 * ((unint64_t)v9 >> 9);
    v8 = *(_QWORD *)v7 + 8 * (v9 & 0x1FF);
LABEL_10:
    v10 = v4 + v3;
    v11 = (char *)(v6 + 8 * ((v4 + v3) >> 9));
    v12 = v5 - v6;
    if (v5 != v6)
      goto LABEL_11;
    goto LABEL_14;
  }
}

uint64_t HGNode::SetState(uint64_t result, uint64_t a2, int a3)
{
  *(_DWORD *)(result + 40) = a3;
  return result;
}

const char *HGNode::SetOutputFormatComponents(const char *result, const char *a2, char *a3)
{
  if (a2 > 4 || ((1 << (char)a2) & 0x16) == 0)
    return HGLogger::warning((HGLogger *)"HGNode::SetOutputFormatComponents -- invalid HGFormatComponents value", a2, a3);
  *((_DWORD *)result + 8) = (_DWORD)a2;
  return result;
}

HGNode *HGNode::SetSupportedFormatPrecisions(HGNode *this, const char *a2, char *a3)
{
  if ((a2 & 0xF) == 0)
    return (HGNode *)HGLogger::warning((HGLogger *)"HGNode::SetSupportedFormatPrecisions -- invalid precision mask value", a2, a3);
  *((_DWORD *)this + 9) = (_DWORD)a2;
  return this;
}

void HGNode::EnableGLHardwareBlending(HGNode *this)
{
  const HGBlendingInfo *v2;
  GLenum Size;
  GLenum DstRGBFactor;
  GLenum v5;
  GLenum DstAlphaFactor;
  GLenum RGBOperation;
  GLenum AlphaOperation;
  GLfloat *v9;
  _BYTE v10[24];

  if (*((_BYTE *)this + 332))
  {
    glEnable(0xBE2u);
    v2 = (const HGBlendingInfo *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 256))(this);
    HGGLBlendingInfo::HGGLBlendingInfo((HGGLBlendingInfo *)v10, v2);
    Size = PVPerfStats::FrameStats::GetSize((PVPerfStats::FrameStats *)v10);
    DstRGBFactor = HGGLBlendingInfo::GetDstRGBFactor((HGGLBlendingInfo *)v10);
    v5 = LiImageSource::imageSpace((LiImageSource *)v10);
    DstAlphaFactor = HGGLBlendingInfo::GetDstAlphaFactor((HGGLBlendingInfo *)v10);
    glBlendFuncSeparate(Size, DstRGBFactor, v5, DstAlphaFactor);
    RGBOperation = HGGLBlendingInfo::GetRGBOperation((HGGLBlendingInfo *)v10);
    AlphaOperation = HGGLBlendingInfo::GetAlphaOperation((HGGLBlendingInfo *)v10);
    glBlendEquationSeparate(RGBOperation, AlphaOperation);
    v9 = (GLfloat *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 272))(this);
    glBlendColor(*v9, v9[1], v9[2], v9[3]);
  }
}

uint64_t HGNode::IsInPlaceHardwareBlendingEnabled(HGNode *this)
{
  return *((unsigned __int8 *)this + 332);
}

void HGNode::DisableGLHardwareBlending(HGNode *this)
{
  glDisable(0xBE2u);
}

uint64_t HGNode::SupportsEarlyConcatenation(HGNode *this)
{
  return 0;
}

HGNode *HGNode::GetGuardedOutput(HGNode *this, HGRenderer *a2)
{
  HGNode *result;
  HGNode *v4;
  BOOL v5;
  char *v6;
  uint64_t v7;
  const char *v8;
  char *v9;

  result = (HGNode *)(*(uint64_t (**)(HGNode *, HGRenderer *))(*(_QWORD *)this + 384))(this, a2);
  v4 = result;
  if (result)
    v5 = result == this;
  else
    v5 = 1;
  if (!v5)
  {
    if ((*((_DWORD *)result + 4) & 0x80000000) != 0)
    {
      v4 = 0;
      v6 = "HGNode::GetOutput (%s) received a de-allocated HGNode.";
    }
    else
    {
      if ((*((_DWORD *)result + 34) & 0x80000000) == 0)
        return result;
      *((_DWORD *)result + 34) = 0;
      v6 = "HGNode::GetOutput (%s) received an invalid HGNode.";
    }
    v7 = (*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 48))(this);
    HGLogger::error((HGLogger *)v6, v8, v9, v7);
    return v4;
  }
  return result;
}

HGNode *HGNode::GetOutput(HGNode *this, HGRenderer *a2)
{
  unint64_t v4;
  int v5;

  if (!this)
    __cxa_bad_typeid();
  v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this - 8) + 8);
  if (((char *)v4 == "6HGNode"
     || ((v4 & (unint64_t)"6HGNode" & 0x8000000000000000) != 0) != __OFSUB__(v4, "6HGNode")
     && !strcmp((const char *)(v4 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"6HGNode" & 0x7FFFFFFFFFFFFFFFLL)))&& (v5 = *((_DWORD *)this + 4), *((_DWORD *)this + 4) = v5 | 0x400, (v5 & 6) == 0))
  {
    return HGRenderer::GetInput(a2, this, 0);
  }
  else
  {
    return this;
  }
}

uint64_t HGNode::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

uint64_t HGNode::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

uint64_t HGNode::GetProgram()
{
  return 0;
}

uint64_t HGNode::GetUserRegion()
{
  return 0;
}

HGNode *HGNode::ClearBits(HGNode *this, const char *a2, char *a3)
{
  int v3;
  HGNode *v4;
  int v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  BOOL v10;

  v3 = (int)a2;
  v4 = this;
  if (*((_DWORD *)this + 10) == 1)
    this = (HGNode *)HGLogger::warning((HGLogger *)"ClearBits() : called during render\n", a2, a3);
  v5 = *((_DWORD *)v4 + 34);
  if ((v5 & v3) != 0)
  {
    *((_DWORD *)v4 + 34) = v5 & ~v3;
    v6 = (_QWORD *)*((_QWORD *)v4 + 14);
    v7 = (_QWORD *)((char *)v4 + 120);
    if (v6 != v7)
    {
      do
      {
        this = (HGNode *)HGNode::ClearBits(*(HGNode **)v6[4], 255);
        v8 = (_QWORD *)v6[1];
        if (v8)
        {
          do
          {
            v9 = v8;
            v8 = (_QWORD *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            v9 = (_QWORD *)v6[2];
            v10 = *v9 == (_QWORD)v6;
            v6 = v9;
          }
          while (!v10);
        }
        v6 = v9;
      }
      while (v9 != v7);
    }
  }
  return this;
}

uint64_t HGNode::RenderTileDispatch(HGNode *this, HGTile *a2, char *a3)
{
  int v5;
  unsigned int *v6;
  int v7;
  uint64_t v8;
  void (*v9)(__int128 *, _QWORD *, uint64_t *, _QWORD *, _QWORD *);
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v32;
  __int128 v33;
  _BYTE v34[32];
  _QWORD v35[4];
  _QWORD v36[3];
  int v37;
  _OWORD v38[3];
  _QWORD *v39;
  _QWORD v40[2];
  _QWORD v41[3];
  int v42;
  _OWORD v43[3];
  _QWORD *v44;
  _QWORD v45[2];
  _QWORD v46[3];
  int v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  _QWORD *v51;
  _QWORD v52[2];
  _QWORD v53[3];
  int v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  _QWORD *v58;
  _QWORD v59[2];
  _QWORD v60[8];
  _QWORD v61[3];
  int v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  _QWORD *v66;
  _QWORD v67[2];
  _QWORD v68[3];
  int v69;
  _QWORD v70[7];
  _QWORD v71[2];
  _QWORD v72[3];
  int v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  _QWORD *v77;
  _QWORD v78[2];
  _QWORD v79[3];
  int v80;
  __int128 v81;
  uint64_t v82;
  _BYTE v83[24];
  _QWORD *v84;
  _QWORD v85[2];
  _QWORD v86[3];
  int v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  _QWORD *v91;
  _QWORD v92[2];
  _QWORD v93[3];
  int v94;
  _QWORD v95[7];
  _QWORD v96[2];
  _QWORD v97[3];
  int v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  _QWORD *v102;
  _QWORD v103[2];
  _QWORD v104[3];
  int v105;
  _QWORD v106[7];
  _QWORD v107[2];
  _QWORD v108[8];
  __int16 v109;
  char v110;
  int v111;
  char v112;
  __int16 v113;
  char v114;
  int v115;
  char v116;
  __int16 v117;
  char v118;
  int v119;
  char v120;
  __int16 v121;
  char v122;
  int v123;
  char v124;
  __int16 v125;
  char v126;
  int v127;
  char v128;
  __int16 v129;
  char v130;
  int v131;
  char v132;
  __int16 v133;
  char v134;
  int v135;
  char v136;
  __int16 v137;
  char v138;
  int v139;
  char v140;
  _BYTE v141[16];

  v5 = *((_DWORD *)this + 4);
  if ((v5 & 0x20000) != 0)
  {
    if ((~v5 & 0x82) != 0)
    {
      HGLogger::warning((HGLogger *)"HGNode::RenderTileDispatch - improper flags for RenderSingleBufferedTile!", (const char *)a2, a3);
    }
    else
    {
      v6 = (unsigned int *)((char *)this + 256);
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 + 1, v6));
      if (v7 >= 1)
        return 0;
    }
  }
  HGStats::ProfilerScopeGuard::ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)v141, *(HGStats::UnitStats **)(*((_QWORD *)a2 + 42) + 424), this, (*((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1)) * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2));
  v9 = (void (*)(__int128 *, _QWORD *, uint64_t *, _QWORD *, _QWORD *))*((_QWORD *)this + 9);
  if (v9)
  {
    v36[0] = 0x100000001;
    v56 = 0u;
    v57 = 0u;
    *(_QWORD *)v34 = 0;
    v11 = *(_QWORD *)a2;
    v10 = *((_QWORD *)a2 + 1);
    *(_QWORD *)&v12 = (int)v10;
    *((_QWORD *)&v12 + 1) = SHIDWORD(v10);
    *(_OWORD *)&v34[8] = v12;
    *(_QWORD *)&v34[24] = 1;
    v35[0] = v36;
    v56 = *(_OWORD *)v34;
    v57 = *(_OWORD *)&v34[16];
    v36[2] = 0x10DE000010B5;
    v41[0] = 0x100000001;
    v41[2] = 0x10DE000010B5;
    v46[0] = 0x100000001;
    v46[2] = 0x10DE000010B5;
    v49 = 0u;
    v48 = 0u;
    v53[0] = 0x100000001;
    v35[3] = v53;
    v55 = 0u;
    v53[2] = 0x10DE000010B5;
    v61[0] = 0x100000001;
    v61[2] = 0x10DE000010B5;
    v64 = 0u;
    v65 = 0u;
    v63 = 0u;
    v68[0] = 0x100000001;
    memset(v70, 0, 48);
    v68[2] = 0x10DE000010B5;
    v72[0] = 0x100000001;
    v72[2] = 0x10DE000010B5;
    v75 = 0u;
    v76 = 0u;
    v74 = 0u;
    v79[0] = 0x100000001;
    memset(v83, 0, sizeof(v83));
    v60[3] = v79;
    v82 = 0;
    v81 = 0u;
    v79[2] = 0x10DE000010B5;
    v86[0] = 0x100000001;
    v86[2] = 0x10DE000010B5;
    v88 = 0u;
    v89 = 0u;
    v90 = 0u;
    v93[0] = 0x100000001;
    v93[2] = 0x10DE000010B5;
    memset(&v95[2], 0, 32);
    memset(v95, 0, 24);
    v97[0] = 0x100000001;
    v97[2] = 0x10DE000010B5;
    v101 = 0u;
    v100 = 0u;
    v99 = 0u;
    v104[0] = 0x100000001;
    v104[2] = 0x10DE000010B5;
    memset(&v106[2], 0, 32);
    memset(v106, 0, 24);
    *(_QWORD *)&v12 = (int)v11;
    *((_QWORD *)&v12 + 1) = SHIDWORD(v11);
    v33 = v12;
    v38[1] = *(_OWORD *)v34;
    v38[2] = *(_OWORD *)&v34[16];
    v43[2] = *(_OWORD *)&v34[16];
    v43[1] = *(_OWORD *)v34;
    v38[0] = v12;
    v43[0] = v12;
    v50 = *(_OWORD *)&v34[16];
    v36[1] = v38;
    v37 = 3;
    v41[1] = v43;
    v42 = 3;
    v46[1] = &v48;
    v47 = 3;
    v53[1] = &v55;
    v54 = 3;
    v35[1] = v41;
    v35[2] = v46;
    v61[1] = &v63;
    v62 = 3;
    v66 = v67;
    v69 = 3;
    v70[6] = v71;
    v72[1] = &v74;
    v73 = 3;
    v77 = v78;
    v80 = 3;
    v84 = v85;
    v86[1] = &v88;
    v91 = v92;
    v93[1] = v95;
    v95[6] = v96;
    v97[1] = &v99;
    v102 = v103;
    v104[1] = v106;
    v87 = 3;
    v94 = 3;
    v98 = 3;
    v105 = 3;
    v106[6] = v107;
    v60[1] = v68;
    v60[2] = v72;
    v60[4] = v86;
    v60[6] = v97;
    v111 = 2080374784;
    v112 &= 0x7Cu;
    v116 &= 0x7Cu;
    v120 &= 0x7Cu;
    v124 &= 0x7Cu;
    v128 &= 0x7Cu;
    v132 &= 0x7Cu;
    v136 &= 0x7Cu;
    v110 = 16;
    v109 = -24503;
    v108[0] = &v109;
    v115 = 2080374784;
    v113 = -24503;
    v68[1] = v70;
    v114 = 16;
    v108[1] = &v113;
    v119 = 2080374784;
    v117 = -24503;
    v79[1] = &v81;
    v118 = 16;
    v108[2] = &v117;
    v123 = 2080374784;
    v121 = -24503;
    v60[5] = v93;
    v122 = 16;
    v108[3] = &v121;
    v127 = 2080374784;
    v125 = -24503;
    v60[7] = v104;
    v126 = 16;
    v108[4] = &v125;
    v131 = 2080374784;
    v129 = -24503;
    v130 = 16;
    v108[5] = &v129;
    v135 = 2080374784;
    v133 = -24503;
    v134 = 16;
    v108[6] = &v133;
    v139 = 2080374784;
    v137 = -24503;
    v140 &= 0x7Cu;
    v138 = 16;
    v108[7] = &v137;
    v13 = *((_QWORD *)a2 + 2);
    v14 = 16 * *((int *)a2 + 6);
    v39 = v40;
    v40[0] = v14;
    v40[1] = v13;
    v15 = *((_QWORD *)a2 + 4);
    v16 = 16 * *((int *)a2 + 10);
    v44 = v45;
    v45[0] = v16;
    v45[1] = v15;
    v48 = v12;
    v49 = *(_OWORD *)v34;
    v17 = *((_QWORD *)a2 + 6);
    v18 = 16 * *((int *)a2 + 14);
    v51 = v52;
    v52[0] = v18;
    v52[1] = v17;
    v55 = v12;
    v59[1] = *((_QWORD *)a2 + 8);
    v60[0] = v61;
    v19 = 16 * *((int *)a2 + 18);
    v58 = v59;
    v59[0] = v19;
    v20 = *((_QWORD *)a2 + 26);
    *(_QWORD *)&v12 = (int)v20;
    *((_QWORD *)&v12 + 1) = SHIDWORD(v20);
    v63 = v12;
    *(_QWORD *)&v64 = 0;
    v21 = *((int *)a2 + 55);
    *((_QWORD *)&v64 + 1) = *((int *)a2 + 54);
    *(_QWORD *)&v65 = v21;
    *((_QWORD *)&v65 + 1) = 1;
    v67[1] = *((_QWORD *)a2 + 10);
    v67[0] = 16 * *((int *)a2 + 22);
    v22 = *((int *)a2 + 57);
    v70[0] = *((int *)a2 + 56);
    v70[1] = v22;
    v70[2] = 0;
    v23 = *((_QWORD *)a2 + 29);
    v24 = *((_QWORD *)a2 + 30);
    *(_QWORD *)&v12 = (int)v23;
    *((_QWORD *)&v12 + 1) = SHIDWORD(v23);
    *(_OWORD *)&v70[3] = v12;
    v70[5] = 1;
    v71[1] = *((_QWORD *)a2 + 12);
    v71[0] = 16 * *((int *)a2 + 26);
    *(_QWORD *)&v12 = (int)v24;
    *((_QWORD *)&v12 + 1) = SHIDWORD(v24);
    v74 = v12;
    *(_QWORD *)&v75 = 0;
    v25 = *((int *)a2 + 63);
    *((_QWORD *)&v75 + 1) = *((int *)a2 + 62);
    *(_QWORD *)&v76 = v25;
    *((_QWORD *)&v76 + 1) = 1;
    v78[1] = *((_QWORD *)a2 + 14);
    v78[0] = 16 * *((int *)a2 + 30);
    *(_QWORD *)&v81 = *((int *)a2 + 64);
    *((_QWORD *)&v81 + 1) = *((int *)a2 + 65);
    v26 = *((_QWORD *)a2 + 33);
    v27 = *((_QWORD *)a2 + 34);
    *(_QWORD *)&v12 = (int)v26;
    *((_QWORD *)&v12 + 1) = SHIDWORD(v26);
    *(_OWORD *)v83 = v12;
    *(_QWORD *)&v83[16] = 1;
    v85[1] = *((_QWORD *)a2 + 16);
    v85[0] = 16 * *((int *)a2 + 34);
    *(_QWORD *)&v12 = (int)v27;
    *((_QWORD *)&v12 + 1) = SHIDWORD(v27);
    v88 = v12;
    *(_QWORD *)&v89 = 0;
    *((_QWORD *)&v89 + 1) = *((int *)a2 + 70);
    *(_QWORD *)&v90 = *((int *)a2 + 71);
    *((_QWORD *)&v90 + 1) = 1;
    v92[1] = *((_QWORD *)a2 + 18);
    v92[0] = 16 * *((int *)a2 + 38);
    v95[0] = *((int *)a2 + 72);
    v95[1] = *((int *)a2 + 73);
    v28 = *((_QWORD *)a2 + 37);
    v29 = *((_QWORD *)a2 + 38);
    *(_QWORD *)&v12 = (int)v28;
    *((_QWORD *)&v12 + 1) = SHIDWORD(v28);
    *(_OWORD *)&v95[3] = v12;
    v95[5] = 1;
    v96[1] = *((_QWORD *)a2 + 20);
    v96[0] = 16 * *((int *)a2 + 42);
    *(_QWORD *)&v12 = (int)v29;
    *((_QWORD *)&v12 + 1) = SHIDWORD(v29);
    v99 = v12;
    *(_QWORD *)&v100 = 0;
    *((_QWORD *)&v100 + 1) = *((int *)a2 + 78);
    *(_QWORD *)&v101 = *((int *)a2 + 79);
    *((_QWORD *)&v101 + 1) = 1;
    v103[1] = *((_QWORD *)a2 + 22);
    v103[0] = 16 * *((int *)a2 + 46);
    v106[0] = *((int *)a2 + 80);
    v106[1] = *((int *)a2 + 81);
    v30 = *((_QWORD *)a2 + 41);
    *(_QWORD *)&v12 = (int)v30;
    *((_QWORD *)&v12 + 1) = SHIDWORD(v30);
    *(_OWORD *)&v106[3] = v12;
    v106[5] = 1;
    v107[1] = *((_QWORD *)a2 + 24);
    v107[0] = 16 * *((int *)a2 + 50);
    v32 = (*(uint64_t (**)(HGNode *, _QWORD))(*(_QWORD *)this + 320))(this, 0);
    v9(&v33, v35, &v32, v108, v60);
    v8 = 0;
  }
  else
  {
    v8 = (*(uint64_t (**)(HGNode *, HGTile *))(*(_QWORD *)this + 176))(this, a2);
  }
  HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)v141);
  return v8;
}

void sub_1B2A6A9E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)(v1 - 64));
  _Unwind_Resume(a1);
}

void sub_1B2A6A9F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)(v1 - 64));
  _Unwind_Resume(a1);
}

uint64_t HGNode::RenderTile(HGNode *this, HGTile *a2)
{
  return 0;
}

uint64_t HGNode::GetProperty(HGNode *this, int a2, uint64_t a3)
{
  unsigned int v3;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v3 = a3;
  result = 1;
  switch(a2)
  {
    case 0:
      return result;
    case 2:
      v6 = *((_QWORD *)this + 40);
      if (v6)
        return HGLimits::isenv((HGLimits *)(v6 + 16));
      return 0;
    case 3:
      v7 = *((_QWORD *)this + 40);
      if (!v7)
        return result;
      return *(unsigned __int16 *)(v7 + 52);
    case 4:
      v8 = *((_QWORD *)this + 40);
      if (!v8)
        return result;
      return *(unsigned __int8 *)(v8 + 56);
    case 5:
      v9 = *((_QWORD *)this + 40);
      if (!v9)
        goto LABEL_35;
      v10 = *(unsigned __int16 *)(v9 + 52);
      if (v10 >= a3)
        return a3;
      else
        return v10;
    case 6:
      v11 = *((_QWORD *)this + 40);
      if (v11)
      {
        v12 = *(unsigned __int8 *)(v11 + 56);
        if (v12 >= a3)
          return a3;
        else
          return v12;
      }
      else
      {
LABEL_35:
        if (a3 <= 1)
          return a3;
        else
          return 1;
      }
    case 7:
      v6 = *((_QWORD *)this + 8);
      if (!v6)
        return 0;
      return HGLimits::isenv((HGLimits *)(v6 + 16));
    case 8:
      v7 = *((_QWORD *)this + 8);
      if (!v7)
        return result;
      return *(unsigned __int16 *)(v7 + 52);
    case 9:
      v8 = *((_QWORD *)this + 8);
      if (!v8)
        return result;
      return *(unsigned __int8 *)(v8 + 56);
    case 10:
      v7 = *((_QWORD *)this + 8);
      if (!v7)
        return (_DWORD)a3 != 0;
      v13 = *((_QWORD *)this + 40);
      if (v13)
        v14 = *(unsigned __int16 *)(v13 + 52);
      else
        v14 = 1;
      if (v14 <= a3)
        return *(unsigned __int16 *)(v7 + 52);
      v18 = *((_QWORD *)this + 37);
      if (0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 38) - v18) >> 3) > (unint64_t)a3
        && *(_QWORD *)(v18 + 56 * a3))
      {
        return *(unsigned int *)(v18 + 56 * a3 + 24);
      }
      else
      {
        return (*((_DWORD *)this + 67) + a3);
      }
    case 11:
      v8 = *((_QWORD *)this + 8);
      if (!v8)
        return (_DWORD)a3 != 0;
      v15 = *((_QWORD *)this + 40);
      if (v15)
        v16 = *(unsigned __int8 *)(v15 + 56);
      else
        v16 = 1;
      if (v16 <= a3)
        return *(unsigned __int8 *)(v8 + 56);
      v19 = *((_QWORD *)this + 37);
      if (0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 38) - v19) >> 3) > (unint64_t)a3
        && *(_QWORD *)(v19 + 56 * a3))
      {
        return *(unsigned int *)(v19 + 56 * a3 + 40);
      }
      else
      {
        return (*((_DWORD *)this + 71) + a3);
      }
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
      return 0xFFFFFFFFLL;
    case 23:
      result = (*(uint64_t (**)(HGNode *, uint64_t))(*(_QWORD *)this + 128))(this, a3);
      if (!result)
        return result;
      v17 = *((_QWORD *)this + 37);
      return 0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 38) - v17) >> 3) > (unint64_t)v3
          && *(_QWORD *)(v17 + 56 * v3) != 0;
    default:
      return 0;
  }
}

BOOL HGNode::IsMergedWithInput(HGNode *this, unint64_t a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 37);
  return 0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 38) - v2) >> 3) > a2 && *(_QWORD *)(v2 + 56 * a2) != 0;
}

void HGNode::PreBuffering(HGNode *this, HGRenderer *a2)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  const char *v9;
  char *v10;
  unsigned __int8 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 v16;
  void *v17;
  const char *v18;
  char *v19;
  unsigned __int8 v20;
  dispatch_group_t *v21;
  unsigned __int8 v22[16];
  unsigned __int8 v23[24];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 105))
  {
    *((_BYTE *)this + 105) = 1;
    if ((*(unsigned int (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2))
    {
      if (*(_BYTE *)(HGRenderer::DepthManager(a2, 0) + 40))
      {
        v4 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 1);
        v5 = *((_DWORD *)this + 42);
        v6 = *((_DWORD *)this + 43);
        v7 = *((_DWORD *)this + 44);
        v8 = *((_DWORD *)this + 45);
        HGTraceGuard::HGTraceGuard((HGTraceGuard *)v22, "depth", 1, "HGNode::BufferingNode");
        v11 = atomic_load(HGLogger::_enabled);
        if ((v11 & 1) != 0)
          HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"node will be cached! pre-alloc the depth buffer...\n", v9, v10);
        v12 = (v5 - v4);
        v13 = (v4 + v7);
        v14 = (v6 - v4);
        v15 = (v4 + v8);
        v16 = atomic_load(HGLogger::_enabled);
        if ((v16 & 1) != 0)
          HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"allocated depth : %d %d %d %d\n", v9, v10, v12, v14, v13, v15);
        v17 = HGObject::operator new(0x80uLL);
        HGBuffer::HGBuffer((uint64_t)v17, v12 | (v14 << 32), v13 | (v15 << 32), 28);
        *((_QWORD *)this + 12) = v17;
        v20 = atomic_load(HGLogger::_enabled);
        if ((v20 & 1) != 0)
          HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"cached : %p\n", v18, v19, *((_QWORD *)this + 12));
        *(_OWORD *)v23 = xmmword_1B3051560;
        HGRenderUtils::BufferFiller::BufferFiller((HGRenderUtils::BufferFiller *)&v21);
        HGRenderUtils::BufferFiller::start(&v21, *((HGBitmap **)this + 12), v23, *(unsigned int *)(*((_QWORD *)this + 12) + 56));
        HGRenderUtils::BufferFiller::~BufferFiller((HGRenderUtils::BufferFiller *)&v21);
        HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v22);
      }
    }
  }
}

void sub_1B2A6AED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  HGRenderUtils::BufferFiller::~BufferFiller((HGRenderUtils::BufferFiller *)va);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va1);
  _Unwind_Resume(a1);
}

void sub_1B2A6AEF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A6AF04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  void *v15;

  HGObject::operator delete(v15);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a15);
  _Unwind_Resume(a1);
}

void sub_1B2A6AF24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGNode::PreTileBuffering(uint64_t result)
{
  if (!*(_BYTE *)(result + 106))
    *(_BYTE *)(result + 106) = 1;
  return result;
}

uint64_t HGNode::RenderInputOrder(HGNode *this, uint64_t a2)
{
  return a2;
}

uint64_t HGNode::PullTextures(HGNode *this, HGGPURenderer **a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  HGGPURenderer **v15;
  unsigned int **v16;
  HGGPURenderer *v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  char *v21;
  unsigned __int8 v22;

  if (!*((_QWORD *)this + 10) || (*((_BYTE *)this + 18) & 1) != 0)
    return 0;
  v6 = 0;
  v7 = 0;
  v8 = *((_DWORD *)this + 71) + a3;
  do
  {
    v10 = (*(uint64_t (**)(HGNode *, uint64_t))(*(_QWORD *)this + 440))(this, v7);
    v11 = (*(uint64_t (**)(HGNode *, uint64_t))(*(_QWORD *)this + 128))(this, v10);
    if (v11)
    {
      v12 = *(_QWORD *)(*((_QWORD *)this + 10) + 8 * (int)v10);
      if (v12)
      {
        if ((*(_BYTE *)(v12 + 14) & 1) == 0)
        {
          v13 = *((_QWORD *)this + 37);
          if (0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 38) - v13) >> 3) > (unint64_t)(int)v10
            && (v9 = *(_QWORD *)(v13 + 56 * (int)v10)) != 0)
          {
            v6 = (*(unsigned int (**)(uint64_t, HGGPURenderer **, _QWORD))(*(_QWORD *)v9 + 472))(v9, a2, (*(_DWORD *)(v13 + 56 * (int)v10 + 40) + a3))+ v6;
          }
          else
          {
            v14 = v8 + v10;
            v15 = &a2[v8] + (int)v10;
            v17 = v15[21];
            v16 = (unsigned int **)(v15 + 21);
            if (!v17)
            {
              v18 = v14;
              v19 = *(_QWORD *)(v11 + 144);
              *v16 = HGGPURenderer::GetNodeTexture(*a2, (HGNode *)v19, *(HGRect *)((char *)&a2[2 * v14 + 4] + 4), 0, 1u);
              v22 = atomic_load(HGLogger::_enabled);
              if ((v22 & 1) != 0)
                HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"rendering leaf (%p, %x) to texture(%p, %d)\n", v20, v21, v19, *(unsigned int *)(v19 + 12), *v16, v18);
              v6 = (v6 + 1);
            }
          }
        }
      }
    }
    v7 = (v7 + 1);
  }
  while ((_DWORD)v7 != 8);
  return v6;
}

uint64_t HGNode::PullMetalTextures(HGNode *this, HGRenderer **a2, int a3)
{
  int v4;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  HGNode *v13;
  uint64_t v14;
  uint64_t v15;
  HGRenderer **v16;
  HGTexture **v17;
  HGRenderer *v18;
  uint64_t v19;
  HGNode *Output;
  HGRenderer **v21;
  uint64_t *v22;
  uint64_t v23;
  HGBitmap *NodeBitmap;
  HGBitmap *v25;
  HGBitmap *v26;
  int v27;
  HGTexture *v29;
  const char *v30;
  char *v31;
  unsigned __int8 v32;
  uint64_t v33;
  int v34;
  HGRect v36;

  if (*((_QWORD *)this + 10) && (*((_BYTE *)this + 18) & 1) == 0)
  {
    v4 = a3;
    v6 = 0;
    v7 = 0;
    v8 = *((_DWORD *)this + 71) + a3;
    v34 = v8;
    while (1)
    {
      v10 = (*(uint64_t (**)(HGNode *, uint64_t))(*(_QWORD *)this + 440))(this, v7);
      v11 = (*(uint64_t (**)(HGNode *, uint64_t))(*(_QWORD *)this + 128))(this, v10);
      if (v11)
      {
        v12 = *(_QWORD *)(*((_QWORD *)this + 10) + 8 * (int)v10);
        if (v12)
        {
          if ((*(_BYTE *)(v12 + 14) & 1) == 0)
          {
            v13 = (HGNode *)v11;
            v14 = *((_QWORD *)this + 37);
            if (0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 38) - v14) >> 3) > (unint64_t)(int)v10
              && (v15 = *(_QWORD *)(v14 + 56 * (int)v10)) != 0)
            {
              v6 = (*(unsigned int (**)(uint64_t, HGRenderer **, _QWORD))(*(_QWORD *)v15 + 480))(v15, a2, (*(_DWORD *)(v14 + 56 * (int)v10 + 40) + v4))+ v6;
            }
            else
            {
              v16 = &a2[v8] + (int)v10;
              v18 = v16[21];
              v17 = v16 + 21;
              if (!v18)
              {
                v19 = v8 + (int)v10;
                Output = HGRenderer::GetOutput(*a2, v13);
                v21 = &a2[2 * v19];
                v23 = *(uint64_t *)((char *)v21 + 36);
                v22 = (uint64_t *)((char *)v21 + 36);
                *(_QWORD *)&v36.var0 = v23;
                *(_QWORD *)&v36.var2 = v22[1];
                NodeBitmap = HGGPURenderer::GetNodeBitmap(*a2, Output, v36, 0, 1u);
                v25 = HGGPURenderer::ConvertToNonGLTexture(*a2, NodeBitmap);
                v26 = v25;
                v27 = *((_DWORD *)v25 + 3);
                v33 = v19;
                if ((v27 & 0x30) != 0)
                {
                  if ((~v27 & 0x120) != 0)
                    goto LABEL_23;
LABEL_22:
                  if (HGRectIsNull(*v22, v22[1]))
                    goto LABEL_23;
                  v29 = (HGTexture *)HGObject::operator new(0x80uLL);
                  HGTexture::HGTexture(v29, *(HGRect *)v22, v26);
                }
                else
                {
                  if ((~v27 & 0x120) == 0 || *((_QWORD *)v25 + 10) != 0)
                    goto LABEL_22;
LABEL_23:
                  v29 = (HGTexture *)HGObject::operator new(0x80uLL);
                  HGTexture::HGTexture(v29, *(HGRect *)((char *)v26 + 20), v26);
                }
                *v17 = v29;
                (*(void (**)(HGBitmap *))(*(_QWORD *)v26 + 24))(v26);
                (*(void (**)(HGBitmap *))(*(_QWORD *)NodeBitmap + 24))(NodeBitmap);
                v32 = atomic_load(HGLogger::_enabled);
                if ((v32 & 1) != 0)
                  HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"rendering leaf (%p, %x) to texture(%p, %d)\n", v30, v31, Output, *((unsigned int *)Output + 3), *v17, v33);
                v6 = (v6 + 1);
                v8 = v34;
                v4 = a3;
              }
            }
          }
        }
      }
      v7 = (v7 + 1);
      if ((_DWORD)v7 == 8)
        return v6;
    }
  }
  return 0;
}

void sub_1B2A6B388(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A6B39C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGNode::PageBegin(HGNode *this, HGPage *a2, uint64_t a3, int32x4_t *a4)
{
  uint64_t DOD;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  char v12;
  int v13;
  int32x4_t v14;
  uint64_t v15;
  int32x4_t v16;
  uint64_t v17;
  HGNode *v18;
  uint64_t v19;
  _BYTE *v20;
  char *v21;
  HGMetalHandler *v22;
  HGMetalHandler *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int *v27;
  uint64_t v28;
  HGPage *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t TextureRect;
  unsigned int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  HGNode *v42;
  uint64_t v43;
  _BYTE *v44;
  HGMetalHandler *v45;
  HGMetalHandler *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v61;
  uint64_t v62;
  unsigned int v63;
  uint64_t v64;
  HGShaderBinding *v65;
  unsigned int v66;
  int v67;
  HGPage *v68;
  char *v69;
  unsigned int v70;
  HGRect v71;
  HGRect v72;

  if (!a4)
    return 0;
  if ((*(unsigned int (**)(HGNode *, uint64_t, _QWORD))(*(_QWORD *)this + 168))(this, 2, 0))
    *((_QWORD *)a2 + 30) = this;
  v65 = (HGShaderBinding *)((char *)this + 260);
  HGHandler::Push(a4, (const HGShaderBinding *)((char *)this + 260));
  DOD = HGRenderer::GetDOD(*(HGRenderer **)a2, this);
  (*(void (**)(int32x4_t *, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(a4->i64[0] + 24))(a4, DOD, v9, *((_QWORD *)a2 + 2), *((_QWORD *)a2 + 3), 0, 0);
  (*(void (**)(HGNode *, int32x4_t *))(*(_QWORD *)this + 200))(this, a4);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = a4[11].i32[0] + a3;
  v64 = v13;
  v67 = v13 + 1;
  v68 = a2;
  v69 = (char *)a2 + 8 * v13 + 176;
  v63 = a3;
  do
  {
    v17 = (*(uint64_t (**)(HGNode *, unint64_t))(*(_QWORD *)this + 128))(this, v10);
    if (v17)
    {
      v18 = (HGNode *)v17;
      v19 = *((_QWORD *)this + 37);
      if (0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 38) - v19) >> 3) > v10 && *(_QWORD *)(v19 + 56 * v10))
      {
        if ((v12 & 1) != 0)
        {
LABEL_5:
          v14 = HGHandler::Push(a4, (const HGShaderBinding *)(v19 + 56 * v10 + 16));
          v15 = *(_QWORD *)(*((_QWORD *)this + 37) + 56 * v10);
          v11 = (*(unsigned int (**)(uint64_t, HGPage *, uint64_t, int32x4_t *, int32x4_t))(*(_QWORD *)v15 + 488))(v15, a2, a3, a4, v14)+ v11;
          v16 = HGHandler::Pop(a4, (const HGShaderBinding *)(*((_QWORD *)this + 37) + 56 * v10 + 16));
          v12 = 1;
          goto LABEL_6;
        }
      }
      else
      {
        v66 = v11;
        if ((v12 & 1) != 0)
          v16 = HGHandler::Push(a4, v65);
        v20 = (_BYTE *)*((_QWORD *)a2 + v10 + v64 + 21);
        v21 = v69;
        if (v20)
        {
          if ((v20[12] & 0x10) != 0)
          {
            v28 = v27[40];
            v29 = a2;
            v30 = HGRenderer::GetDOD(*(HGRenderer **)a2, v18);
            v32 = v31;
            v33 = *(_QWORD *)(v27 + 5);
            v34 = *(_QWORD *)(v27 + 7);
            TextureRect = HGGLTexture::GetTextureRect((HGGLTexture *)v27);
            v36 = v27[5];
            v37 = v27[6];
            v21 = v69;
            LODWORD(v61) = -v36;
            HIDWORD(v61) = -v37;
            v38 = v30;
            a2 = v29;
            (*(void (**)(int32x4_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a4->i64[0] + 32))(a4, v28, v38, v32, v33, v34, TextureRect, v39, v61);
          }
          else
          {
            if (v22)
            {
              v23 = v22;
              v24 = HGRenderer::GetDOD(*(HGRenderer **)a2, v18);
              v26 = v25;
              *(_QWORD *)&v71.var0 = v24;
              *(_QWORD *)&v71.var2 = v26;
              HGMetalHandler::InitTextureUnit(v23, v71, v10 + v64);
            }
          }
        }
        else
        {
          (*(void (**)(int32x4_t *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, int32x4_t, _QWORD))(a4->i64[0] + 32))(a4, 0, 0, 0, 0, 0, 0, 0, v16, 0);
        }
        (*(void (**)(HGNode *, int32x4_t *, unint64_t))(*(_QWORD *)this + 208))(this, a4, v10);
        if (v10 == 7)
        {
LABEL_35:
          v11 = v66;
LABEL_36:
          v16 = HGHandler::Pop(a4, v65);
          goto LABEL_37;
        }
        v40 = 56 * v10 + 56;
        while (1)
        {
          v41 = (*(uint64_t (**)(HGNode *, unint64_t))(*(_QWORD *)this + 128))(this, v10 + 1);
          if (!v41)
          {
            v12 = 0;
            ++v10;
            a3 = v63;
            v11 = v66;
            goto LABEL_6;
          }
          v42 = (HGNode *)v41;
          v43 = *((_QWORD *)this + 37);
          if (0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 38) - v43) >> 3) > v10 + 1)
          {
            if (*(_QWORD *)(v43 + v40))
              break;
          }
          v44 = *(_BYTE **)&v21[8 * v10];
          if (v44)
          {
            if ((v44[12] & 0x10) != 0)
            {
              v70 = *((_DWORD *)v50 + 40);
              v51 = HGRenderer::GetDOD(*(HGRenderer **)a2, v42);
              v53 = v52;
              v54 = *(_QWORD *)(v50 + 20);
              v55 = *(_QWORD *)(v50 + 28);
              v56 = HGGLTexture::GetTextureRect((HGGLTexture *)v50);
              LODWORD(v62) = -*((_DWORD *)v50 + 5);
              HIDWORD(v62) = -*((_DWORD *)v50 + 6);
              v57 = v53;
              v58 = v54;
              a2 = v68;
              v21 = v69;
              (*(void (**)(int32x4_t *, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a4->i64[0] + 32))(a4, v70, v51, v57, v58, v55, v56, v59, v62);
            }
            else
            {
              if (v45)
              {
                v46 = v45;
                v47 = HGRenderer::GetDOD(*(HGRenderer **)a2, v42);
                v49 = v48;
                *(_QWORD *)&v72.var0 = v47;
                *(_QWORD *)&v72.var2 = v49;
                HGMetalHandler::InitTextureUnit(v46, v72, v67 + v10);
              }
            }
          }
          else
          {
            (*(void (**)(int32x4_t *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a4->i64[0] + 32))(a4, 0, 0, 0, 0, 0, 0, 0, 0);
          }
          (*(void (**)(HGNode *, int32x4_t *, unint64_t))(*(_QWORD *)this + 208))(this, a4, ++v10);
          v40 += 56;
          if (v10 == 7)
            goto LABEL_35;
        }
        ++v10;
        a3 = v63;
        LODWORD(v11) = v66;
      }
      HGHandler::Pop(a4, v65);
      v19 = *((_QWORD *)this + 37);
      goto LABEL_5;
    }
LABEL_6:
    ++v10;
  }
  while (v10 != 8);
  if ((v12 & 1) == 0)
    goto LABEL_36;
LABEL_37:
  (*(void (**)(int32x4_t *, int32x4_t))(a4->i64[0] + 40))(a4, v16);
  return v11;
}

HGNode *HGNode::PageEnd(HGNode *this, HGPage *a2, int a3, HGHandler *a4)
{
  if (a4)
  {
    if (*((_QWORD *)a2 + 30))
      this = (HGNode *)*((_QWORD *)a2 + 30);
    (*(void (**)(HGNode *, HGHandler *))(*(_QWORD *)this + 216))(this, a4);
    return (HGNode *)(*(uint64_t (**)(_QWORD, HGHandler *))(**(_QWORD **)a2 + 392))(*(_QWORD *)a2, a4);
  }
  return this;
}

uint64_t HGNode::RenderPage(HGNode *this, HGRect *a2)
{
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  HGHandler *v7;
  _BYTE v9[16];
  HGRect *v10;
  char __str[256];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v10 = a2;
  if (this)
    (*(void (**)(HGNode *, HGRect *, _QWORD))(*(_QWORD *)this + 472))(this, a2, 0);
  v4 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 48))(this);
  snprintf(__str, 0x100uLL, "%s::RenderPage( [%d %d %d %d])", v4, a2[1].var0, a2[1].var1, a2[1].var2, a2[1].var3);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v9, "gpu", 1, __str);
  v5 = (*(uint64_t (**)(HGNode *, HGRect *, _QWORD))(*(_QWORD *)this + 504))(this, a2, 0);
  v6 = v5;
  if (*(_QWORD *)&a2->var2 != v5)
    *(_QWORD *)&a2->var2 = v5;
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)&a2->var0 + 144))(*(_QWORD *)&a2->var0, v5);
  (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 0, *(_QWORD *)&a2[10].var2, 0, 0);
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 1, *(_QWORD *)&a2[11].var0, 0, 0);
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 2, *(_QWORD *)&a2[11].var2, 0, 0);
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 3, *(_QWORD *)&a2[12].var0, 0, 0);
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 4, *(_QWORD *)&a2[12].var2, 0, 0);
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 5, *(_QWORD *)&a2[13].var0, 0, 0);
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 6, *(_QWORD *)&a2[13].var2, 0, 0);
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 7, *(_QWORD *)&a2[14].var0, 0, 0);
  v7 = (HGHandler *)(*(uint64_t (**)(_QWORD, _QWORD, HGNode *))(**(_QWORD **)&a2->var0 + 368))(*(_QWORD *)&a2->var0, *((_QWORD *)this + 8), this);
  (*(void (**)(HGNode *, HGRect *, _QWORD, HGHandler *))(*(_QWORD *)this + 488))(this, a2, 0, v7);
  (*(void (**)(HGNode *))(*(_QWORD *)this + 344))(this);
  HGGPURenderer::Rect(*(HGGPURenderer **)&a2->var0, v7, a2[1], 8);
  (*(void (**)(HGNode *))(*(_QWORD *)this + 352))(this);
  (*(void (**)(HGNode *, HGRect *, _QWORD, HGHandler *))(*(_QWORD *)this + 496))(this, a2, 0, v7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v9);
  HGPage::ReleaseTextures((HGPage *)a2);
  return v6;
}

void sub_1B2A6BC38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t HGNode::RenderPageMetal(HGNode *this, HGPage *a2)
{
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  const char *v8;
  char *v9;
  uint64_t v10;
  _BYTE v12[16];
  HGPage *v13;
  char __str[256];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  if (this)
    (*(void (**)(HGNode *, HGPage *, _QWORD))(*(_QWORD *)this + 480))(this, a2, 0);
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)a2 + 144))(*(_QWORD *)a2, 0);
  v4 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 48))(this);
  snprintf(__str, 0x100uLL, "%s::RenderPageMetal( [%d %d %d %d])", v4, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), *((_DWORD *)a2 + 6), *((_DWORD *)a2 + 7));
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v12, "gpu", 1, __str);
  v5 = (*(uint64_t (**)(HGNode *, HGPage *, uint64_t))(*(_QWORD *)this + 504))(this, a2, 1);
  v6 = v5;
  if (*((_QWORD *)a2 + 1) != v5)
    *((_QWORD *)a2 + 1) = v5;
  v7 = (*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 520))(this);
  if (v7 > 1)
  {
    if (*((_QWORD *)a2 + 1))
      HGNode::RenderPageDeluxe(this, a2);
    else
      HGLogger::warning((HGLogger *)"HGNode::RenderPageMetal() could not find a valid rendering path.", v8, v9);
  }
  else if (v7 || (v10 = (*(uint64_t (**)(HGNode *, HGPage *))(*(_QWORD *)this + 512))(this, a2)) == 0)
  {
    (*(void (**)(HGNode *, HGPage *))(*(_QWORD *)this + 536))(this, a2);
  }
  else
  {
    (*(void (**)(HGNode *, HGPage *, uint64_t))(*(_QWORD *)this + 528))(this, a2, v10);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v12);
  HGPage::ReleaseTextures(a2);
  return v6;
}

void sub_1B2A6BE28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard((HGPage **)va1);
  _Unwind_Resume(a1);
}

const char *HGNode::RenderPageDeluxe(HGNode *this, const HGPage *a2)
{
  HGBitmap *v4;
  HGBitmap *v5;
  HGBitmap *v6;
  HGBitmap *v7;
  HGBitmap *v8;
  HGBitmap *v9;
  HGBitmap *v10;
  HGBitmap *v11;
  HGBitmap *v12;
  HGBitmap *v13;
  HGBitmap *v14;
  const char *result;
  HGBitmap *v16;
  HGBitmap *v17;
  HGBitmap *v18;
  HGBitmap *v19;
  HGBitmap *v20;
  HGBitmap *v21;
  HGBitmap *v22;
  HGBitmap *v23;
  HGBitmap *v24;
  HGBitmap *v25;
  HGBitmap *v26;
  HGBitmap *v27;
  HGBitmap *v28;
  HGBitmap *v29;
  HGBitmap *v30;
  HGBitmap *v31;
  HGBitmap *v32;
  HGGPURenderer *v33;
  __int128 v34;
  void *CVBitmapStorage;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;

  HGGPURenderer::FlushMetalCommandBuffer(*(HGGPURenderer **)a2);
  if ((*(unsigned int (**)(HGNode *))(*(_QWORD *)this + 520))(this) == 5)
  {
    v5 = (HGBitmap *)*((_QWORD *)a2 + 1);
    v33 = *(HGGPURenderer **)a2;
    v34 = *((_OWORD *)a2 + 1);
    CVBitmapStorage = HGCVBitmap::getCVBitmapStorage(v5, v4);
    v7 = (HGBitmap *)*((_QWORD *)a2 + 21);
    if (v7)
      v36 = HGCVBitmap::getCVBitmapStorage(v7, v6);
    v8 = (HGBitmap *)*((_QWORD *)a2 + 22);
    if (v8)
      v37 = HGCVBitmap::getCVBitmapStorage(v8, v6);
    v9 = (HGBitmap *)*((_QWORD *)a2 + 23);
    if (v9)
      v38 = HGCVBitmap::getCVBitmapStorage(v9, v6);
    v10 = (HGBitmap *)*((_QWORD *)a2 + 24);
    if (v10)
      v39 = HGCVBitmap::getCVBitmapStorage(v10, v6);
    v11 = (HGBitmap *)*((_QWORD *)a2 + 25);
    if (v11)
      v40 = HGCVBitmap::getCVBitmapStorage(v11, v6);
    v12 = (HGBitmap *)*((_QWORD *)a2 + 26);
    if (v12)
      v41 = HGCVBitmap::getCVBitmapStorage(v12, v6);
    v13 = (HGBitmap *)*((_QWORD *)a2 + 27);
    if (v13)
      v42 = HGCVBitmap::getCVBitmapStorage(v13, v6);
    v14 = (HGBitmap *)*((_QWORD *)a2 + 28);
    if (v14)
      v43 = HGCVBitmap::getCVBitmapStorage(v14, v6);
    return (const char *)(*(uint64_t (**)(HGNode *, HGGPURenderer **))(*(_QWORD *)this + 544))(this, &v33);
  }
  v32 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, *((HGBitmap **)a2 + 1));
  v16 = (HGBitmap *)*((_QWORD *)a2 + 21);
  if (v16)
  {
    v17 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v16);
    v18 = (HGBitmap *)*((_QWORD *)a2 + 22);
    if (v18)
      goto LABEL_21;
  }
  else
  {
    v17 = 0;
    v18 = (HGBitmap *)*((_QWORD *)a2 + 22);
    if (v18)
    {
LABEL_21:
      v19 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v18);
      v20 = (HGBitmap *)*((_QWORD *)a2 + 23);
      if (v20)
        goto LABEL_22;
      goto LABEL_30;
    }
  }
  v19 = 0;
  v20 = (HGBitmap *)*((_QWORD *)a2 + 23);
  if (v20)
  {
LABEL_22:
    v21 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v20);
    v22 = (HGBitmap *)*((_QWORD *)a2 + 24);
    if (v22)
      goto LABEL_23;
    goto LABEL_31;
  }
LABEL_30:
  v21 = 0;
  v22 = (HGBitmap *)*((_QWORD *)a2 + 24);
  if (v22)
  {
LABEL_23:
    v23 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v22);
    v24 = (HGBitmap *)*((_QWORD *)a2 + 25);
    if (v24)
      goto LABEL_24;
    goto LABEL_32;
  }
LABEL_31:
  v23 = 0;
  v24 = (HGBitmap *)*((_QWORD *)a2 + 25);
  if (v24)
  {
LABEL_24:
    v25 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v24);
    v26 = (HGBitmap *)*((_QWORD *)a2 + 26);
    if (v26)
      goto LABEL_25;
    goto LABEL_33;
  }
LABEL_32:
  v25 = 0;
  v26 = (HGBitmap *)*((_QWORD *)a2 + 26);
  if (v26)
  {
LABEL_25:
    v27 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v26);
    v28 = (HGBitmap *)*((_QWORD *)a2 + 27);
    if (v28)
      goto LABEL_26;
LABEL_34:
    v29 = 0;
    v30 = (HGBitmap *)*((_QWORD *)a2 + 28);
    if (v30)
      goto LABEL_27;
LABEL_35:
    v31 = 0;
    goto LABEL_36;
  }
LABEL_33:
  v27 = 0;
  v28 = (HGBitmap *)*((_QWORD *)a2 + 27);
  if (!v28)
    goto LABEL_34;
LABEL_26:
  v29 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v28);
  v30 = (HGBitmap *)*((_QWORD *)a2 + 28);
  if (!v30)
    goto LABEL_35;
LABEL_27:
  v31 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v30);
LABEL_36:
  v33 = *(HGGPURenderer **)a2;
  v34 = *((_OWORD *)a2 + 1);
  CVBitmapStorage = v32;
  v36 = v17;
  v37 = v19;
  v38 = v21;
  v39 = v23;
  v40 = v25;
  v41 = v27;
  v42 = v29;
  v43 = v31;
  result = HGNode::RenderPageDeluxeMetalTextures((uint64_t)this, &v33);
  if (v31)
    result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(_QWORD *)v31 + 24))(v31);
  if (v29)
    result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(_QWORD *)v29 + 24))(v29);
  if (v27)
    result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(_QWORD *)v27 + 24))(v27);
  if (v25)
    result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(_QWORD *)v25 + 24))(v25);
  if (v23)
    result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(_QWORD *)v23 + 24))(v23);
  if (v21)
    result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(_QWORD *)v21 + 24))(v21);
  if (v19)
    result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(_QWORD *)v19 + 24))(v19);
  if (v17)
    result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(_QWORD *)v17 + 24))(v17);
  if (v32)
    return (const char *)(*(uint64_t (**)(HGBitmap *))(*(_QWORD *)v32 + 24))(v32);
  return result;
}

void sub_1B2A6C1F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 24))(v15);
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a9)
    (*(void (**)(uint64_t))(*(_QWORD *)a9 + 24))(a9);
  _Unwind_Resume(exception_object);
}

char *HGNode::CreateOutputBuffer(uint64_t a1, uint64_t a2, int a3)
{
  int v6;
  uint64_t v7;
  HGMetalTexture *MetalStorage;
  HGMetalTexture *v9;
  int v10;
  unsigned int v11;
  _BOOL4 v12;
  BOOL v13;

  v6 = 0;
  v7 = *(_QWORD *)(a2 + 8);
  if ((*(_BYTE *)(a1 + 17) & 0x40) != 0 && v7)
    v6 = !HGRectIsEqual(*(_QWORD *)(v7 + 20), *(_QWORD *)(v7 + 28), *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24));
  if (!v6 && v7 && (~*(_DWORD *)(v7 + 12) & 0x220) == 0)
  {
    MetalStorage = (HGMetalTexture *)HGMetalTexture::getMetalStorage((HGBitmap *)v7, (HGBitmap *)a2);
    v9 = MetalStorage;
    v10 = *(_DWORD *)(a1 + 16);
    if ((v10 & 0x8000) != 0)
    {
      v11 = HGMetalTexture::hasComputeUsage(MetalStorage) ^ 1;
      if ((*(_DWORD *)(a1 + 16) & 0x1000) != 0)
        goto LABEL_9;
    }
    else
    {
      v11 = 0;
      if ((v10 & 0x1000) != 0)
      {
LABEL_9:
        v12 = (*((_BYTE *)v9 + 12) & 1) == 0;
LABEL_12:
        v6 = v11 | v12;
        goto LABEL_13;
      }
    }
    v12 = 0;
    goto LABEL_12;
  }
LABEL_13:
  if (v7)
    v13 = v6 == 0;
  else
    v13 = 0;
  if (!v13)
    return HGGPURenderer::CreateBuffer(*(_QWORD *)a2, *(HGRect *)(a2 + 16), *(unsigned int *)(a2 + 32), a3, (*(_DWORD *)(a1 + 16) >> 12) & 1, *(unsigned __int8 *)(a2 + 248), (*(_DWORD *)(a1 + 16) >> 15) & 1);
  (*(void (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
  return (char *)v7;
}

void *HGNode::PrepareMetalHandler(HGNode *this, const HGPage *a2)
{
  void *result;

  result = (void *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)a2 + 368))(*(_QWORD *)a2, *((_QWORD *)this + 8));
  if (result)
  return result;
}

uint64_t HGNode::RenderPageClassic(HGNode *this, HGBitmap **a2, std::string *a3)
{
  const char *v6;
  size_t v7;
  std::string::size_type v8;
  std::string *p_dst;
  uint64_t v10;
  uint64_t v11;
  __n128 v12;
  HGBitmap *v13;
  HGBitmap *v14;
  HGBitmap *v15;
  HGBitmap *v16;
  HGBitmap *v17;
  HGBitmap *v18;
  HGBitmap *v19;
  HGBitmap *v20;
  __n128 v21;
  const HGBlendingInfo *v22;
  __n128 v23;
  __n128 *v24;
  std::string __dst;

  v6 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 48))(this);
  v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v8 = v7;
  if (v7 >= 0x17)
  {
    v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v10 = v7 | 7;
    v11 = v10 + 1;
    p_dst = (std::string *)operator new(v10 + 1);
    __dst.__r_.__value_.__l.__size_ = v8;
    __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_8;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v7;
  p_dst = &__dst;
  if (v7)
LABEL_8:
    memmove(p_dst, v6, v8);
  p_dst->__r_.__value_.__s.__data_[v8] = 0;
  HGMetalHandler::SetDebugLabel(a3, &__dst);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
  HGMetalHandler::BindBuffer((HGMetalHandler *)a3, a2[1]);
  v13 = a2[21];
  if (v13)
    v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 0, v13);
  v14 = a2[22];
  if (v14)
    v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 1, v14);
  v15 = a2[23];
  if (v15)
    v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 2, v15);
  v16 = a2[24];
  if (v16)
    v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 3, v16);
  v17 = a2[25];
  if (v17)
    v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 4, v17);
  v18 = a2[26];
  if (v18)
    v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 5, v18);
  v19 = a2[27];
  if (v19)
    v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 6, v19);
  v20 = a2[28];
  if (v20)
    v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 7, v20);
  (*(void (**)(HGNode *, HGBitmap **, _QWORD, std::string *, __n128))(*(_QWORD *)this + 488))(this, a2, 0, a3, v12);
  if (*((_BYTE *)this + 332))
  {
    HGMetalHandler::EnableBlending((uint64_t)a3);
    v22 = (const HGBlendingInfo *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 256))(this);
    v23 = HGMetalHandler::SetBlendingInfo((HGMetalHandler *)a3, v22);
    v24 = (__n128 *)(*(uint64_t (**)(HGNode *, __n128))(*(_QWORD *)this + 272))(this, v23);
    v21 = HGMetalHandler::SetBlendingColor((__n128 *)a3, v24);
  }
  (*(void (**)(std::string *, HGBitmap *, HGBitmap *, uint64_t, __n128))(a3->__r_.__value_.__r.__words[0] + 192))(a3, a2[2], a2[3], 8, v21);
  return (*(uint64_t (**)(HGNode *, HGBitmap **, _QWORD, std::string *))(*(_QWORD *)this + 496))(this, a2, 0, a3);
}

void sub_1B2A6C654(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

std::string *HGNode::RenderPageCustom(HGNode *this, const HGPage *a2)
{
  return HGGPURenderer::CopyMetal(*(HGGPURenderer **)a2, *((HGBitmap **)a2 + 1), *((HGRect *)a2 + 1), *((HGBitmap **)a2 + 21));
}

const char *HGNode::RenderPageIOSurfaces(uint64_t a1, const char *a2, char *a3)
{
  return HGLogger::error((HGLogger *)"HGNode::RenderPageIOSurfaces is NOT implemented!", a2, a3);
}

const char *HGNode::RenderPageWithCommandBuffer(uint64_t a1, const char *a2, char *a3)
{
  return HGLogger::error((HGLogger *)"HGNode::RenderPageWithCommandBuffer is NOT implemented!", a2, a3);
}

const char *HGNode::RenderPageWithCommandEncoder(uint64_t a1, const char *a2, char *a3)
{
  return HGLogger::error((HGLogger *)"HGNode::RenderPageWithCommandEncoder is NOT implemented!", a2, a3);
}

const char *HGNode::RenderPageMetalTextures(uint64_t a1, const char *a2, char *a3)
{
  return HGLogger::error((HGLogger *)"HGNode::RenderPageMetalTextures is NOT implemented!", a2, a3);
}

uint64_t HGNode::SetFilter(uint64_t a1, int a2, char *a3)
{
  if (*(_DWORD *)(a1 + 328) == a2)
    return 0;
  *(_DWORD *)(a1 + 328) = a2;
  HGNode::ClearBits((HGNode *)a1, (const char *)0xFFFF, a3);
  return 1;
}

uint64_t HGNode::GetFilter(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(unsigned int *)(a1 + 328);
  if (a2)
  {
    if ((_DWORD)result == -1)
      return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 128))(a2, 23);
  }
  return result;
}

uint64_t HGNode::BindTexture(HGNode *this, HGHandler *a2, int a3)
{
  HGHandler::TexCoord(a2, a3, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  return 0;
}

uint64_t HGNode::Bind(HGNode *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 6), *((unsigned int *)this + 11));
  (*(void (**)(HGNode *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HGNode::UnBind(HGNode *this, HGHandler *a2)
{
  return 0;
}

uint64_t HGNode::DoInplaceHardwareBlending(HGNode *this, HGGPURenderer *a2, HGNode *a3, float a4)
{
  int NodeRenderAPI;
  int v9;
  BOOL v10;

  NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI(a2, this);
  v9 = HGGPURenderer::GetNodeRenderAPI(a2, a3);
  if (*((_BYTE *)this + 105))
    v10 = 0;
  else
    v10 = NodeRenderAPI == v9;
  if (v10)
    return (*(uint64_t (**)(HGNode *, float))(*(_QWORD *)this + 232))(this, a4);
  else
    return 0;
}

uint64_t HGNode::SupportsInplaceHardwareBlending(HGNode *this, float a2)
{
  return 0;
}

HGNode *HGNode::EnableInplaceHardwareBlending(HGNode *this)
{
  *((_BYTE *)this + 332) = 1;
  return this;
}

HGNode *HGNode::DisableInplaceHardwareBlending(HGNode *this)
{
  *((_BYTE *)this + 332) = 0;
  return this;
}

__n128 HGNode::SetInPlaceHardwareBlendingInfo(HGNode *this, const HGBlendingInfo *a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a2;
  v3 = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 21) = *(_OWORD *)a2;
  *((_OWORD *)this + 22) = v3;
  return result;
}

uint64_t HGNode::GetInPlaceHardwareBlendingInfo(HGNode *this)
{
  return (uint64_t)this + 336;
}

__n128 HGNode::SetInPlaceHardwareBlendingColor(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  a1[24] = *a2;
  return result;
}

uint64_t HGNode::GetInPlaceHardwareBlendingColor(HGNode *this)
{
  return (uint64_t)this + 384;
}

HGNode *HGNode::SetInPlaceHardwareBlendingOpacity(HGNode *this, float a2)
{
  *((float *)this + 92) = a2;
  return this;
}

float HGNode::GetInPlaceHardwareBlendingOpacity(HGNode *this)
{
  return *((float *)this + 92);
}

uint64_t HGNode::IntermediateFormat(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t HGNode::CanBypassTiling()
{
  return 0;
}

uint64_t HGNode::SupportsGLSL(HGNode *this)
{
  return (*((unsigned __int8 *)this + 17) >> 1) & 1;
}

uint64_t HGNode::SupportsMetal(HGNode *this)
{
  return (*((unsigned __int8 *)this + 17) >> 2) & 1;
}

uint64_t HGNode::SupportsSWAIR(HGNode *this)
{
  return (*((unsigned __int8 *)this + 17) >> 3) & 1;
}

uint64_t HGNode::GetSWAIRProgram(HGNode *this)
{
  return 0;
}

uint64_t HGNode::GetParameterBuffer(HGNode *this, int a2)
{
  if (*((_DWORD *)this + 11) <= a2)
    return 0;
  else
    return *((_QWORD *)this + 6) + 4 * a2;
}

void HGNode3D::HGNode3D(HGNode3D *this)
{
  _QWORD *v1;

  HGNode::HGNode((HGNode *)this);
  *v1 = off_1E65251F0;
}

void HGNode3D::~HGNode3D(HGNode *this)
{
  void *v1;

  HGNode::~HGNode(this);
  HGObject::operator delete(v1);
}

uint64_t HGNode3D::RenderFragment(uint64_t a1, const char *a2, char *a3)
{
  HGLogger::warning((HGLogger *)"WARNING - RenderFragment invoked on non -fragment compiled node\n", a2, a3);
  return 0;
}

uint64_t HGNode3D::RenderFragment_DEBUG(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 576))(a1);
}

uint64_t HGNode3D::RenderTile(HGNode3D *this, int32x2_t *a2)
{
  __int32 v3;
  int v4;
  int v10;
  int v11;
  float32x4_t v12;
  int v13;
  int32x2_t v14;
  int32x2_t v15;
  int32x2_t v16;
  int32x2_t v17;
  __int32 v18;
  __int32 v19;
  float32x4_t v21;
  int32x2_t v22;
  float32x4_t v23;
  int32x2_t __dst[44];
  _OWORD v25[15];

  v3 = a2[1].i32[0];
  v22 = *a2;
  v4 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  __asm { FMOV            V0.4S, #1.0 }
  v25[9] = _Q0;
  v25[10] = xmmword_1B304EFF0;
  v25[11] = xmmword_1B30530B0;
  v25[12] = xmmword_1B304FAB0;
  memcpy(__dst, a2, sizeof(__dst));
  __dst[1] = vadd_s32(__dst[0], (int32x2_t)0x100000001);
  if (v4 >= 1)
  {
    v10 = v3 - v22.i32[0];
    if (v10 >= 1)
    {
      v11 = 0;
      *(float32x2_t *)v12.f32 = vadd_f32(vcvt_f32_s32(v22), (float32x2_t)0x3F0000003F000000);
      v12.i64[1] = 0x3F80000000000000;
      do
      {
        v13 = v10;
        v21 = v12;
        do
        {
          v23 = v12;
          v25[0] = v12;
          v25[1] = v12;
          v25[2] = v12;
          v25[3] = v12;
          v25[4] = v12;
          v25[5] = v12;
          v25[6] = v12;
          v25[7] = v12;
          v25[8] = v12;
          (*(void (**)(HGNode3D *, _OWORD *, int32x2_t *))(*(_QWORD *)this + 576))(this, v25, __dst);
          v14 = __dst[2];
          v15 = __dst[4];
          *(_QWORD *)&__dst[2] += 16;
          *(_QWORD *)&__dst[4] += 16;
          v16 = __dst[6];
          v17 = __dst[8];
          *(_QWORD *)&__dst[6] += 16;
          *(_QWORD *)&__dst[8] += 16;
          v18 = __dst[0].i32[0] + 1;
          v19 = __dst[1].i32[0] + 1;
          ++__dst[0].i32[0];
          ++__dst[1].i32[0];
          v12 = vaddq_f32(v23, (float32x4_t)xmmword_1B304F230);
          --v13;
        }
        while (v13);
        __dst[2] = (int32x2_t)(*(_QWORD *)&v14 - 16 * v10 + 16 * __dst[3].i32[0] + 16);
        __dst[4] = (int32x2_t)(*(_QWORD *)&v15 - 16 * v10 + 16 * __dst[5].i32[0] + 16);
        __dst[6] = (int32x2_t)(*(_QWORD *)&v16 - 16 * v10 + 16 * __dst[7].i32[0] + 16);
        __dst[8] = (int32x2_t)(*(_QWORD *)&v17 - 16 * v10 + 16 * __dst[9].i32[0] + 16);
        __dst[0] = (int32x2_t)(__PAIR64__(__dst[0].u32[1], v18 - v10) + 0x100000000);
        __dst[1] = (int32x2_t)(__PAIR64__(__dst[1].u32[1], v19 - v10) + 0x100000000);
        v12 = vaddq_f32(v21, (float32x4_t)xmmword_1B304F240);
        ++v11;
      }
      while (v11 != v4);
    }
  }
  return 0;
}

uint64_t HGNode::GetProgramDescriptor@<X0>(HGNode *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  uint64_t result;
  char *v6;
  char *v7;

  v4 = *((_QWORD *)this + 50);
  if (v4)
  {
    *a2 = v4;
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
  }
  else
  {
    v6 = (char *)HGObject::operator new(0x118uLL);
    HGObject::HGObject((HGObject *)v6);
    *(_QWORD *)v6 = &unk_1E6525468;
    *((_OWORD *)v6 + 12) = 0u;
    *((_OWORD *)v6 + 13) = 0u;
    *(_OWORD *)(v6 + 172) = 0u;
    *((_OWORD *)v6 + 9) = 0u;
    *((_OWORD *)v6 + 10) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *((_OWORD *)v6 + 8) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *((_DWORD *)v6 + 56) = 1;
    *(_OWORD *)(v6 + 228) = 0u;
    *(_OWORD *)(v6 + 244) = 0u;
    *((_DWORD *)v6 + 69) = 0;
    *(_OWORD *)(v6 + 260) = 0u;
    v7 = (char *)*((_QWORD *)this + 50);
    if (v7 == v6)
    {
      HGObject::Release((unsigned int *)v6);
      v6 = (char *)*((_QWORD *)this + 50);
    }
    else
    {
      if (v7)
        (*(void (**)(char *))(*(_QWORD *)v7 + 24))(v7);
      *((_QWORD *)this + 50) = v6;
    }
    (*(void (**)(HGNode *, char *))(*(_QWORD *)this + 328))(this, v6);
    result = *((_QWORD *)this + 50);
    *a2 = result;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  }
  return result;
}

void sub_1B2A6CCA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void HGNode::InitNodeChain(HGNode *this, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;

  if (!a2)
  {
    v4 = *((_QWORD *)this + 37);
LABEL_6:
    *((_QWORD *)this + 38) = v4;
    return;
  }
  v2 = *((_QWORD *)this + 37);
  v3 = 0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 38) - v2) >> 3);
  if (a2 != v3)
  {
    if (a2 > v3)
    {
      std::vector<HGNodeChain>::__append((char **)this + 37, a2 - v3);
      return;
    }
    if (a2 < v3)
    {
      v4 = v2 + 56 * a2;
      goto LABEL_6;
    }
  }
}

void HGProgramDescriptor::~HGProgramDescriptor(HGProgramDescriptor *this)
{
  void *v1;

  HGProgramDescriptor::~HGProgramDescriptor(this);
  HGObject::operator delete(v1);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)this = &unk_1E6525468;
  v2 = *((_QWORD *)this + 32);
  if (v2)
  {
    v3 = *((_QWORD *)this + 33);
    v4 = (void *)*((_QWORD *)this + 32);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 17) < 0)
          operator delete(*(void **)(v3 - 40));
        v3 -= 48;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 32);
    }
    *((_QWORD *)this + 33) = v2;
    operator delete(v4);
  }
  v5 = *((_QWORD *)this + 29);
  if (v5)
  {
    v6 = *((_QWORD *)this + 30);
    v7 = (void *)*((_QWORD *)this + 29);
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 17) < 0)
          operator delete(*(void **)(v6 - 40));
        v6 -= 48;
      }
      while (v6 != v5);
      v7 = (void *)*((_QWORD *)this + 29);
    }
    *((_QWORD *)this + 30) = v5;
    operator delete(v7);
  }
  if (*((char *)this + 215) < 0)
  {
    operator delete(*((void **)this + 24));
    if ((*((char *)this + 183) & 0x80000000) == 0)
    {
LABEL_19:
      if ((*((char *)this + 159) & 0x80000000) == 0)
        goto LABEL_20;
      goto LABEL_29;
    }
  }
  else if ((*((char *)this + 183) & 0x80000000) == 0)
  {
    goto LABEL_19;
  }
  operator delete(*((void **)this + 20));
  if ((*((char *)this + 159) & 0x80000000) == 0)
  {
LABEL_20:
    v8 = (char *)*((_QWORD *)this + 14);
    if (!v8)
      goto LABEL_21;
LABEL_30:
    v9 = (char *)*((_QWORD *)this + 15);
    if (v9 == v8)
    {
      *((_QWORD *)this + 15) = v8;
      operator delete(v8);
      if (*((char *)this + 111) < 0)
        goto LABEL_37;
    }
    else
    {
      do
      {
        v10 = *((_QWORD *)v9 - 1);
        if (v10)
          (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
        v9 -= 16;
      }
      while (v9 != v8);
      v11 = (void *)*((_QWORD *)this + 14);
      *((_QWORD *)this + 15) = v8;
      operator delete(v11);
      if (*((char *)this + 111) < 0)
        goto LABEL_37;
    }
LABEL_22:
    if ((*((char *)this + 87) & 0x80000000) == 0)
      goto LABEL_23;
    goto LABEL_38;
  }
LABEL_29:
  operator delete(*((void **)this + 17));
  v8 = (char *)*((_QWORD *)this + 14);
  if (v8)
    goto LABEL_30;
LABEL_21:
  if ((*((char *)this + 111) & 0x80000000) == 0)
    goto LABEL_22;
LABEL_37:
  operator delete(*((void **)this + 11));
  if ((*((char *)this + 87) & 0x80000000) == 0)
  {
LABEL_23:
    if ((*((char *)this + 63) & 0x80000000) == 0)
      goto LABEL_24;
LABEL_39:
    operator delete(*((void **)this + 5));
    if ((*((char *)this + 39) & 0x80000000) == 0)
      goto LABEL_25;
LABEL_40:
    operator delete(*((void **)this + 2));
    HGObject::~HGObject(this);
    return;
  }
LABEL_38:
  operator delete(*((void **)this + 8));
  if (*((char *)this + 63) < 0)
    goto LABEL_39;
LABEL_24:
  if (*((char *)this + 39) < 0)
    goto LABEL_40;
LABEL_25:
  HGObject::~HGObject(this);
}

_QWORD *std::__hash_table<std::__hash_value_type<HGNode const*,BOOL>,std::__unordered_map_hasher<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::hash<HGNode const*>,std::equal_to<HGNode const*>,true>,std::__unordered_map_equal<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::equal_to<HGNode const*>,std::hash<HGNode const*>,true>,std::allocator<std::__hash_value_type<HGNode const*,BOOL>>>::__emplace_unique_key_args<HGNode const*,std::piecewise_construct_t const&,std::tuple<HGNode const* const&>,std::tuple<>>(uint64_t a1, uint64_t *a2, uint64_t a3, _QWORD **a4)
{
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v18;
  float v19;
  float v20;
  uint64_t v21;
  _QWORD *v22;
  _BOOL8 v23;
  unint64_t v24;
  unint64_t v25;
  size_t prime;
  unint64_t v27;
  uint8x8_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;

  v7 = *a2;
  v8 = HIDWORD(*a2);
  v9 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v8);
  v10 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
      if (v10 >= v11)
        v4 = v10 % v11;
    }
    else
    {
      v4 = v10 & (v11 - 1);
    }
    v13 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
    if (v13)
    {
      v14 = (_QWORD *)*v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            v16 = v14[1];
            if (v16 == v10)
            {
              if (v14[2] == v7)
                return v14;
            }
            else if ((v16 & (v11 - 1)) != v4)
            {
              goto LABEL_23;
            }
            v14 = (_QWORD *)*v14;
            if (!v14)
              goto LABEL_23;
          }
        }
        do
        {
          v15 = v14[1];
          if (v15 == v10)
          {
            if (v14[2] == v7)
              return v14;
          }
          else
          {
            if (v15 >= v11)
              v15 %= v11;
            if (v15 != v4)
              break;
          }
          v14 = (_QWORD *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_23:
  v18 = operator new(0x20uLL);
  *v18 = 0;
  v18[1] = v10;
  v18[2] = **a4;
  *((_BYTE *)v18 + 24) = 0;
  v19 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v20 = *(float *)(a1 + 32);
  if (v11 && (float)(v20 * (float)v11) >= v19)
  {
    v21 = *(_QWORD *)a1;
    v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
    if (v22)
    {
LABEL_26:
      *v18 = *v22;
LABEL_61:
      *v22 = v18;
      goto LABEL_62;
    }
  }
  else
  {
    v23 = 1;
    if (v11 >= 3)
      v23 = (v11 & (v11 - 1)) != 0;
    v24 = v23 | (2 * v11);
    v25 = vcvtps_u32_f32(v19 / v20);
    if (v24 <= v25)
      prime = v25;
    else
      prime = v24;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
      v11 = *(_QWORD *)(a1 + 8);
    }
    if (prime > v11)
      goto LABEL_37;
    if (prime < v11)
    {
      v27 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (v28 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        v27 = std::__next_prime(v27);
      }
      else
      {
        v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2)
          v27 = v29;
      }
      if (prime <= v27)
        prime = v27;
      if (prime < v11)
LABEL_37:
        std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__do_rehash<true>(a1, prime);
    }
    v11 = *(_QWORD *)(a1 + 8);
    v30 = v11 - 1;
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
      {
        v4 = v10 % v11;
        v21 = *(_QWORD *)a1;
        v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * (v10 % v11));
        if (v22)
          goto LABEL_26;
      }
      else
      {
        v4 = v10;
        v21 = *(_QWORD *)a1;
        v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v10);
        if (v22)
          goto LABEL_26;
      }
    }
    else
    {
      v4 = v30 & v10;
      v21 = *(_QWORD *)a1;
      v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * (v30 & v10));
      if (v22)
        goto LABEL_26;
    }
  }
  *v18 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v18;
  *(_QWORD *)(v21 + 8 * v4) = a1 + 16;
  if (*v18)
  {
    v31 = *(_QWORD *)(*v18 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v31 >= v11)
        v31 %= v11;
    }
    else
    {
      v31 &= v11 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v31);
    goto LABEL_61;
  }
LABEL_62:
  ++*(_QWORD *)(a1 + 24);
  return v18;
}

void sub_1B2A6D274(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::deque<HGNode const*>::__add_front_capacity(uint64_t a1)
{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  void *v12;
  void *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  void *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  unint64_t v34;
  int64_t v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int128 *v43;
  char *v44;
  uint64_t v45;
  __int128 v46;
  void *v47;

  v3 = *(char **)(a1 + 8);
  v2 = *(char **)(a1 + 16);
  if (v2 == v3)
    v4 = 0;
  else
    v4 = ((v2 - v3) << 6) - 1;
  v5 = *(_QWORD *)(a1 + 32);
  if ((unint64_t)(v4 - (*(_QWORD *)(a1 + 40) + v5)) >= 0x200)
  {
    *(_QWORD *)(a1 + 32) = v5 + 512;
    v47 = (void *)*((_QWORD *)v2 - 1);
    *(_QWORD *)(a1 + 16) = v2 - 8;
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
    return;
  }
  v6 = *(char **)(a1 + 24);
  v7 = *(char **)a1;
  v8 = (uint64_t)&v6[-*(_QWORD *)a1];
  if (v2 - v3 < (unint64_t)v8)
  {
    if (v3 == v7)
    {
      v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v47);
      v17 = *(_QWORD *)(a1 + 16);
      v47 = *(void **)(v17 - 8);
      *(_QWORD *)(a1 + 16) = v17 - 8;
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) == 8)
        goto LABEL_9;
    }
    else
    {
      v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) == 8)
      {
LABEL_9:
        v9 = 256;
LABEL_19:
        *(_QWORD *)(a1 + 32) = v9;
        return;
      }
    }
    v9 = *(_QWORD *)(a1 + 32) + 512;
    goto LABEL_19;
  }
  if (v6 == v7)
    v10 = 1;
  else
    v10 = v8 >> 2;
  if (v10 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v11 = (char *)operator new(8 * v10);
  v12 = operator new(0x1000uLL);
  v13 = v12;
  if (v10)
  {
    v14 = &v11[8 * v10];
    *(_QWORD *)v11 = v12;
    v15 = v11 + 8;
    v16 = v11;
    if (v3 != v2)
      goto LABEL_27;
    goto LABEL_21;
  }
  v18 = (char *)operator new(8uLL);
  v14 = v18 + 8;
  operator delete(v11);
  v3 = *(char **)(a1 + 8);
  v19 = *(char **)(a1 + 16);
  v11 = v18;
  *(_QWORD *)v18 = v13;
  v15 = v18 + 8;
  v16 = v18;
  if (v3 != v19)
  {
    while (1)
    {
LABEL_27:
      if (v15 == v14)
      {
        if (v11 <= v16)
        {
          if (v15 == v16)
            v31 = 1;
          else
            v31 = (v15 - v16) >> 2;
          if (v31 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v32 = (char *)operator new(8 * v31);
          v33 = v32;
          v34 = v31 >> 2;
          v20 = &v32[8 * (v31 >> 2)];
          v23 = v20;
          v35 = v15 - v11;
          if (v15 != v11)
          {
            v23 = &v20[v35 & 0xFFFFFFFFFFFFFFF8];
            v36 = v35 - 8;
            if (v36 < 0x38 || (v37 = 8 * v34, (unint64_t)(&v32[8 * v34] - v11) < 0x20))
            {
              v38 = &v32[8 * (v31 >> 2)];
              v39 = v11;
              goto LABEL_43;
            }
            v41 = (v36 >> 3) + 1;
            v42 = 8 * (v41 & 0x3FFFFFFFFFFFFFFCLL);
            v38 = &v20[v42];
            v39 = &v11[v42];
            v43 = (__int128 *)(v11 + 16);
            v44 = &v32[v37 + 16];
            v45 = v41 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v46 = *v43;
              *((_OWORD *)v44 - 1) = *(v43 - 1);
              *(_OWORD *)v44 = v46;
              v43 += 2;
              v44 += 32;
              v45 -= 4;
            }
            while (v45);
            if (v41 != (v41 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_43:
                v40 = *(_QWORD *)v39;
                v39 += 8;
                *(_QWORD *)v38 = v40;
                v38 += 8;
              }
              while (v38 != v23);
            }
          }
          v15 = &v32[8 * v31];
          if (v16)
            operator delete(v16);
          v16 = v33;
          goto LABEL_26;
        }
        v25 = (v11 - v16) >> 3;
        if (v25 >= -1)
          v26 = v25 + 1;
        else
          v26 = v25 + 2;
        v27 = v26 >> 1;
        v28 = &v11[-8 * (v26 >> 1)];
        v29 = v15;
        if (v15 != v11)
        {
          memmove(v28, v11, v15 - v11);
          v29 = v11;
        }
        v30 = -v27;
        v23 = &v28[v15 - v11];
        v20 = &v29[8 * v30];
      }
      else
      {
        v20 = v11;
        v23 = v15;
        v15 = v14;
      }
LABEL_26:
      v14 = v15;
      v24 = *(_QWORD *)v3;
      v3 += 8;
      *(_QWORD *)v23 = v24;
      v21 = v23 + 8;
      v15 = v21;
      v11 = v20;
      if (v3 == *(char **)(a1 + 16))
        goto LABEL_22;
    }
  }
LABEL_21:
  v20 = v11;
  v21 = v15;
LABEL_22:
  v22 = *(void **)a1;
  *(_QWORD *)a1 = v16;
  *(_QWORD *)(a1 + 8) = v20;
  *(_QWORD *)(a1 + 16) = v21;
  *(_QWORD *)(a1 + 24) = v14;
  if (v21 - v20 == 8)
  {
    *(_QWORD *)(a1 + 32) = 256;
    if (v22)
LABEL_24:
      operator delete(v22);
  }
  else
  {
    *(_QWORD *)(a1 + 32) += 512;
    if (v22)
      goto LABEL_24;
  }
}

void sub_1B2A6D5FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v1);
  operator delete(v2);
  _Unwind_Resume(a1);
}

void std::deque<HGNode const*>::__append(_QWORD *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  BOOL v10;
  unint64_t v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int64_t v19;
  void *v20;

  v4 = a1[1];
  v5 = a1[2];
  if (v5 == v4)
    v6 = 0;
  else
    v6 = ((v5 - v4) << 6) - 1;
  v7 = a1[5];
  v8 = v7 + a1[4];
  v9 = v6 - v8;
  v10 = a2 > v9;
  v11 = a2 - v9;
  if (v10)
  {
    std::deque<HGNode const*>::__add_back_capacity((uint64_t)a1, v11);
    v7 = a1[5];
    v4 = a1[1];
    v5 = a1[2];
    v8 = a1[4] + v7;
  }
  v12 = (_QWORD *)(v4 + 8 * (v8 >> 9));
  if (v5 == v4)
  {
    v13 = 0;
    if (!a2)
      return;
  }
  else
  {
    v13 = (void *)(*v12 + 8 * (v8 & 0x1FF));
    if (!a2)
      return;
  }
  v14 = a2 + (((uint64_t)v13 - *v12) >> 3);
  if (v14 < 1)
  {
    v17 = 511 - v14;
    v15 = &v12[-(v17 >> 9)];
    v16 = *v15 + 8 * (~(_WORD)v17 & 0x1FF);
    if (v13 != (void *)v16)
    {
      do
      {
LABEL_15:
        v18 = v16;
        if (v12 != v15)
          v18 = *v12 + 4096;
        if (v13 == (void *)v18)
        {
          if (v12 == v15)
            break;
        }
        else
        {
          v19 = ((v18 - (_QWORD)v13 - 8) & 0xFFFFFFFFFFFFFFF8) + 8;
          bzero(v13, v19);
          v7 += v19 >> 3;
          if (v12 == v15)
            break;
        }
        v20 = (void *)v12[1];
        ++v12;
        v13 = v20;
      }
      while (v20 != (void *)v16);
      a1[5] = v7;
    }
  }
  else
  {
    v15 = &v12[(unint64_t)v14 >> 9];
    v16 = *v15 + 8 * (v14 & 0x1FF);
    if (v13 != (void *)v16)
      goto LABEL_15;
  }
}

void std::deque<HGNode const*>::__add_back_capacity(uint64_t a1, unint64_t a2)
{
  char *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  _QWORD *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  int64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  char *v27;
  char *v28;
  BOOL v29;
  int64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  __int128 *v35;
  char *v36;
  uint64_t v37;
  __int128 v38;
  uint64_t v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  void *v44;
  char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  char *v50;
  unint64_t v51;
  char *v52;
  char *v53;
  unint64_t v54;
  char *v55;
  int64_t v56;
  unint64_t v57;
  uint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  __int128 *v64;
  char *v65;
  uint64_t v66;
  __int128 v67;
  _QWORD *v68;
  char *v69;
  _QWORD *v70;
  char *v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  char *v77;
  unint64_t v78;
  char *v79;
  char *v80;
  unint64_t v81;
  int64_t v82;
  unint64_t v83;
  uint64_t v84;
  char *v85;
  char *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  __int128 *v90;
  char *v91;
  uint64_t v92;
  __int128 v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  char *v97;
  uint64_t v98;
  char *v99;
  unint64_t v100;
  char *v101;
  unint64_t v102;
  int64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  __int128 *v110;
  char *v111;
  uint64_t v112;
  __int128 v113;
  uint64_t v114;
  uint64_t i;
  uint64_t v116;
  uint64_t v117;
  char *v118;
  char *v119;
  _QWORD *v120;
  char *v121;
  uint64_t v122;
  char *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  char *v127;
  int64_t v128;
  unint64_t v129;
  unint64_t v130;
  uint64_t v131;
  char *v132;
  char *v133;
  int64_t v134;
  unint64_t v135;
  char *v136;
  uint64_t v137;
  uint64_t v138;
  __int128 *v139;
  char *v140;
  uint64_t v141;
  __int128 v142;
  uint64_t v143;
  uint64_t v144;
  void *v145;

  v3 = *(char **)(a1 + 16);
  v4 = (uint64_t)&v3[-*(_QWORD *)(a1 + 8)];
  if (v4)
    v5 = a2;
  else
    v5 = a2 + 1;
  if ((v5 & 0x1FF) != 0)
    v6 = (v5 >> 9) + 1;
  else
    v6 = v5 >> 9;
  v7 = *(_QWORD *)(a1 + 32);
  if (v6 >= v7 >> 9)
    v8 = v7 >> 9;
  else
    v8 = v6;
  if (v6 <= v7 >> 9)
  {
    *(_QWORD *)(a1 + 32) = v7 - (v8 << 9);
    if (!v8)
      return;
    while (1)
    {
      v15 = *(_QWORD **)(a1 + 8);
      v16 = (char *)(v15 + 1);
      v17 = *v15;
      *(_QWORD *)(a1 + 8) = v15 + 1;
      if (v3 == *(char **)(a1 + 24))
      {
        v18 = *(char **)a1;
        if ((unint64_t)v16 <= *(_QWORD *)a1)
        {
          v24 = (v3 - v18) >> 2;
          if (v3 == v18)
            v24 = 1;
          if (v24 >> 61)
            goto LABEL_159;
          v25 = v24 >> 2;
          v26 = 8 * v24;
          v27 = (char *)operator new(8 * v24);
          v28 = &v27[8 * v25];
          v30 = v3 - v16;
          v29 = v3 == v16;
          v3 = v28;
          if (!v29)
          {
            v3 = &v28[v30 & 0xFFFFFFFFFFFFFFF8];
            v31 = v30 - 8;
            if ((unint64_t)(v30 - 8) < 0x38)
            {
              v32 = &v27[8 * v25];
              goto LABEL_39;
            }
            v32 = &v27[8 * v25];
            if ((unint64_t)(v32 - v16) < 0x20)
              goto LABEL_165;
            v33 = (v31 >> 3) + 1;
            v34 = 8 * (v33 & 0x3FFFFFFFFFFFFFFCLL);
            v32 = &v28[v34];
            v16 += v34;
            v35 = (__int128 *)(v15 + 3);
            v36 = &v27[8 * v25 + 16];
            v37 = v33 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v38 = *v35;
              *((_OWORD *)v36 - 1) = *(v35 - 1);
              *(_OWORD *)v36 = v38;
              v35 += 2;
              v36 += 32;
              v37 -= 4;
            }
            while (v37);
            if (v33 != (v33 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_165:
              do
              {
LABEL_39:
                v39 = *(_QWORD *)v16;
                v16 += 8;
                *(_QWORD *)v32 = v39;
                v32 += 8;
              }
              while (v32 != v3);
            }
          }
          *(_QWORD *)a1 = v27;
          *(_QWORD *)(a1 + 8) = v28;
          *(_QWORD *)(a1 + 16) = v3;
          *(_QWORD *)(a1 + 24) = &v27[v26];
          if (v18)
          {
            operator delete(v18);
            v3 = *(char **)(a1 + 16);
          }
          goto LABEL_21;
        }
        v19 = (uint64_t)&v16[-*(_QWORD *)a1] >> 3;
        if (v19 >= -1)
          v20 = v19 + 1;
        else
          v20 = v19 + 2;
        v21 = v20 >> 1;
        v22 = &v16[-8 * (v20 >> 1)];
        v23 = v3 - v16;
        if (v3 != v16)
        {
          memmove(&v16[-8 * (v20 >> 1)], v16, v3 - v16);
          v3 = *(char **)(a1 + 8);
        }
        v14 = &v3[-8 * v21];
        v3 = &v22[v23];
        *(_QWORD *)(a1 + 8) = v14;
        *(_QWORD *)(a1 + 16) = &v22[v23];
      }
LABEL_21:
      *(_QWORD *)v3 = v17;
      v3 = (char *)(*(_QWORD *)(a1 + 16) + 8);
      *(_QWORD *)(a1 + 16) = v3;
      if (!--v8)
        return;
    }
  }
  v9 = v6 - v8;
  v10 = *(_QWORD *)(a1 + 24) - *(_QWORD *)a1;
  v11 = v4 >> 3;
  if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
  {
    if (v9)
    {
      while (*(_QWORD *)(a1 + 24) != *(_QWORD *)(a1 + 16))
      {
        v145 = operator new(0x1000uLL);
        std::__split_buffer<HGNode **>::push_back((char **)a1, &v145);
        --v6;
        if (!--v9)
          goto LABEL_134;
      }
      for (i = 0; i != v9; ++i)
      {
        v145 = operator new(0x1000uLL);
        std::__split_buffer<HGNode **>::push_front((void **)a1, &v145);
        if (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) == 8)
          v116 = 511;
        else
          v116 = 512;
        v117 = v116 + *(_QWORD *)(a1 + 32);
        *(_QWORD *)(a1 + 32) = v117;
      }
      v8 = v6;
      *(_QWORD *)(a1 + 32) = v117 - (v6 << 9);
      if (!v6)
        return;
    }
    else
    {
LABEL_134:
      *(_QWORD *)(a1 + 32) -= v8 << 9;
      if (!v8)
        return;
    }
    v118 = *(char **)(a1 + 16);
    while (1)
    {
      v120 = *(_QWORD **)(a1 + 8);
      v121 = (char *)(v120 + 1);
      v122 = *v120;
      *(_QWORD *)(a1 + 8) = v120 + 1;
      if (v118 == *(char **)(a1 + 24))
      {
        v123 = *(char **)a1;
        if ((unint64_t)v121 <= *(_QWORD *)a1)
        {
          v129 = (v118 - v123) >> 2;
          if (v118 == v123)
            v129 = 1;
          if (v129 >> 61)
            goto LABEL_159;
          v130 = v129 >> 2;
          v131 = 8 * v129;
          v132 = (char *)operator new(8 * v129);
          v133 = &v132[8 * v130];
          v134 = v118 - v121;
          v29 = v118 == v121;
          v118 = v133;
          if (!v29)
          {
            v118 = &v133[v134 & 0xFFFFFFFFFFFFFFF8];
            v135 = v134 - 8;
            if ((unint64_t)(v134 - 8) < 0x38)
            {
              v136 = &v132[8 * v130];
              goto LABEL_155;
            }
            v136 = &v132[8 * v130];
            if ((unint64_t)(v136 - v121) < 0x20)
              goto LABEL_166;
            v137 = (v135 >> 3) + 1;
            v138 = 8 * (v137 & 0x3FFFFFFFFFFFFFFCLL);
            v136 = &v133[v138];
            v121 += v138;
            v139 = (__int128 *)(v120 + 3);
            v140 = &v132[8 * v130 + 16];
            v141 = v137 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v142 = *v139;
              *((_OWORD *)v140 - 1) = *(v139 - 1);
              *(_OWORD *)v140 = v142;
              v139 += 2;
              v140 += 32;
              v141 -= 4;
            }
            while (v141);
            if (v137 != (v137 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_166:
              do
              {
LABEL_155:
                v143 = *(_QWORD *)v121;
                v121 += 8;
                *(_QWORD *)v136 = v143;
                v136 += 8;
              }
              while (v136 != v118);
            }
          }
          *(_QWORD *)a1 = v132;
          *(_QWORD *)(a1 + 8) = v133;
          *(_QWORD *)(a1 + 16) = v118;
          *(_QWORD *)(a1 + 24) = &v132[v131];
          if (v123)
          {
            operator delete(v123);
            v118 = *(char **)(a1 + 16);
          }
          goto LABEL_137;
        }
        v124 = (uint64_t)&v121[-*(_QWORD *)a1] >> 3;
        if (v124 >= -1)
          v125 = v124 + 1;
        else
          v125 = v124 + 2;
        v126 = v125 >> 1;
        v127 = &v121[-8 * (v125 >> 1)];
        v128 = v118 - v121;
        if (v118 != v121)
        {
          memmove(&v121[-8 * (v125 >> 1)], v121, v118 - v121);
          v118 = *(char **)(a1 + 8);
        }
        v119 = &v118[-8 * v126];
        v118 = &v127[v128];
        *(_QWORD *)(a1 + 8) = v119;
        *(_QWORD *)(a1 + 16) = &v127[v128];
      }
LABEL_137:
      *(_QWORD *)v118 = v122;
      v118 = (char *)(*(_QWORD *)(a1 + 16) + 8);
      *(_QWORD *)(a1 + 16) = v118;
      if (!--v8)
        return;
    }
  }
  if (v10 >> 2 <= v9 + v11)
    v12 = v9 + v11;
  else
    v12 = v10 >> 2;
  if (v12)
  {
    if (v12 >> 61)
LABEL_159:
      std::__throw_bad_array_new_length[abi:ne180100]();
    v13 = (char *)operator new(8 * v12);
  }
  else
  {
    v13 = 0;
  }
  v144 = v8 << 9;
  v40 = &v13[8 * (v11 - v8)];
  v41 = &v13[8 * v12];
  v42 = v40;
  v43 = v13;
  do
  {
    v44 = operator new(0x1000uLL);
    if (v42 != v41)
      goto LABEL_49;
    if (v40 > v43)
    {
      v45 = v43;
      v46 = (v40 - v43) >> 3;
      if (v46 >= -1)
        v47 = v46 + 1;
      else
        v47 = v46 + 2;
      v48 = v47 >> 1;
      v49 = &v40[-8 * (v47 >> 1)];
      v50 = v41;
      if (v41 != v40)
      {
        memmove(v49, v40, v41 - v40);
        v50 = v40;
      }
      v42 = &v49[v41 - v40];
      v40 = &v50[-8 * v48];
      v43 = v45;
      goto LABEL_49;
    }
    if (v41 == v43)
      v51 = 1;
    else
      v51 = (v41 - v43) >> 2;
    if (v51 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v52 = (char *)operator new(8 * v51);
    v53 = v43;
    v54 = v51 >> 2;
    v55 = &v52[8 * (v51 >> 2)];
    v42 = v55;
    v56 = v41 - v40;
    if (v41 != v40)
    {
      v42 = &v55[v56 & 0xFFFFFFFFFFFFFFF8];
      v57 = v56 - 8;
      if (v57 >= 0x38 && (v58 = 8 * v54, (unint64_t)(&v52[8 * v54] - v40) >= 0x20))
      {
        v62 = (v57 >> 3) + 1;
        v63 = 8 * (v62 & 0x3FFFFFFFFFFFFFFCLL);
        v59 = &v55[v63];
        v60 = &v40[v63];
        v64 = (__int128 *)(v40 + 16);
        v65 = &v52[v58 + 16];
        v66 = v62 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v67 = *v64;
          *((_OWORD *)v65 - 1) = *(v64 - 1);
          *(_OWORD *)v65 = v67;
          v64 += 2;
          v65 += 32;
          v66 -= 4;
        }
        while (v66);
        if (v62 == (v62 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_66;
      }
      else
      {
        v59 = &v52[8 * (v51 >> 2)];
        v60 = v40;
      }
      do
      {
        v61 = *(_QWORD *)v60;
        v60 += 8;
        *(_QWORD *)v59 = v61;
        v59 += 8;
      }
      while (v59 != v42);
    }
LABEL_66:
    v41 = &v52[8 * v51];
    if (v53)
      operator delete(v53);
    v40 = &v52[8 * (v51 >> 2)];
    v43 = v52;
LABEL_49:
    *(_QWORD *)v42 = v44;
    v42 += 8;
    --v9;
  }
  while (v9);
  v68 = *(_QWORD **)(a1 + 8);
  if (v8)
  {
    while (1)
    {
      if (v42 == v41)
      {
        if (v40 <= v43)
        {
          if (v41 == v43)
            v78 = 1;
          else
            v78 = (v41 - v43) >> 2;
          if (v78 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v79 = (char *)operator new(8 * v78);
          v80 = v79;
          v81 = v78 >> 2;
          v69 = &v79[8 * (v78 >> 2)];
          v42 = v69;
          v82 = v41 - v40;
          if (v41 != v40)
          {
            v42 = &v69[v82 & 0xFFFFFFFFFFFFFFF8];
            v83 = v82 - 8;
            if (v83 < 0x38 || (v84 = 8 * v81, (unint64_t)(&v79[8 * v81] - v40) < 0x20))
            {
              v85 = &v79[8 * (v78 >> 2)];
              v86 = v40;
              goto LABEL_96;
            }
            v88 = (v83 >> 3) + 1;
            v89 = 8 * (v88 & 0x3FFFFFFFFFFFFFFCLL);
            v85 = &v69[v89];
            v86 = &v40[v89];
            v90 = (__int128 *)(v40 + 16);
            v91 = &v79[v84 + 16];
            v92 = v88 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v93 = *v90;
              *((_OWORD *)v91 - 1) = *(v90 - 1);
              *(_OWORD *)v91 = v93;
              v90 += 2;
              v91 += 32;
              v92 -= 4;
            }
            while (v92);
            if (v88 != (v88 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_96:
                v87 = *(_QWORD *)v86;
                v86 += 8;
                *(_QWORD *)v85 = v87;
                v85 += 8;
              }
              while (v85 != v42);
            }
          }
          v41 = &v79[8 * v78];
          if (v43)
            operator delete(v43);
          v43 = v80;
          goto LABEL_79;
        }
        v72 = v43;
        v73 = (v40 - v43) >> 3;
        if (v73 >= -1)
          v74 = v73 + 1;
        else
          v74 = v73 + 2;
        v75 = v74 >> 1;
        v76 = &v40[-8 * (v74 >> 1)];
        v77 = v41;
        if (v41 != v40)
        {
          memmove(v76, v40, v41 - v40);
          v77 = v40;
        }
        v42 = &v76[v41 - v40];
        v69 = &v77[-8 * v75];
        v43 = v72;
      }
      else
      {
        v69 = v40;
      }
LABEL_79:
      *(_QWORD *)v42 = *v68;
      v42 += 8;
      v68 = (_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
      *(_QWORD *)(a1 + 8) = v68;
      v40 = v69;
      if (!--v8)
        goto LABEL_75;
    }
  }
  v69 = v40;
LABEL_75:
  v70 = *(_QWORD **)(a1 + 16);
  if (v70 != v68)
  {
    do
    {
      if (v69 == v43)
      {
        if (v42 >= v41)
        {
          if (v41 == v43)
            v100 = 1;
          else
            v100 = (v41 - v43) >> 2;
          if (v100 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v101 = (char *)operator new(8 * v100);
          v97 = v101;
          v102 = (v100 + 3) >> 2;
          v69 = &v101[8 * v102];
          v103 = v42 - v43;
          v29 = v42 == v43;
          v42 = v69;
          if (!v29)
          {
            v42 = &v69[v103 & 0xFFFFFFFFFFFFFFF8];
            v104 = v103 - 8;
            v105 = &v101[8 * v102];
            v106 = v43;
            if (v104 < 0x38)
              goto LABEL_167;
            v107 = 8 * v102;
            v105 = &v101[8 * v102];
            v106 = v43;
            if ((unint64_t)(v105 - v43) < 0x20)
              goto LABEL_167;
            v108 = (v104 >> 3) + 1;
            v109 = 8 * (v108 & 0x3FFFFFFFFFFFFFFCLL);
            v105 = &v69[v109];
            v106 = &v43[v109];
            v110 = (__int128 *)(v43 + 16);
            v111 = &v101[v107 + 16];
            v112 = v108 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v113 = *v110;
              *((_OWORD *)v111 - 1) = *(v110 - 1);
              *(_OWORD *)v111 = v113;
              v110 += 2;
              v111 += 32;
              v112 -= 4;
            }
            while (v112);
            if (v108 != (v108 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_167:
              do
              {
                v114 = *(_QWORD *)v106;
                v106 += 8;
                *(_QWORD *)v105 = v114;
                v105 += 8;
              }
              while (v105 != v42);
            }
          }
          v41 = &v101[8 * v100];
          if (v43)
            operator delete(v43);
        }
        else
        {
          v95 = (v41 - v42) >> 3;
          if (v95 >= -1)
            v96 = v95 + 1;
          else
            v96 = v95 + 2;
          v97 = v43;
          v98 = v96 >> 1;
          v69 = &v97[8 * (v96 >> 1)];
          v99 = v97;
          if (v42 != v97)
          {
            memmove(v69, v97, v42 - v97);
            v99 = v42;
          }
          v42 = &v99[8 * v98];
        }
        v43 = v97;
      }
      v94 = *--v70;
      *((_QWORD *)v69 - 1) = v94;
      v69 -= 8;
    }
    while (v70 != *(_QWORD **)(a1 + 8));
  }
  v71 = *(char **)a1;
  *(_QWORD *)a1 = v43;
  *(_QWORD *)(a1 + 8) = v69;
  *(_QWORD *)(a1 + 16) = v42;
  *(_QWORD *)(a1 + 24) = v41;
  *(_QWORD *)(a1 + 32) -= v144;
  if (v71)
    operator delete(v71);
}

void sub_1B2A6E0BC(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

void sub_1B2A6E108()
{
  __cxa_end_catch();
  JUMPOUT(0x1B2A6E110);
}

void std::vector<HGNodeChain>::__append(char **a1, unint64_t a2)
{
  char *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  size_t v12;
  char *v13;
  char *v14;
  size_t v15;
  char *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;

  v5 = a1[1];
  v4 = a1[2];
  if (0x6DB6DB6DB6DB6DB7 * ((v4 - v5) >> 3) >= a2)
  {
    if (a2)
    {
      v12 = 56 * ((56 * a2 - 56) / 0x38) + 56;
      bzero(a1[1], v12);
      v5 += v12;
    }
    a1[1] = v5;
  }
  else
  {
    v6 = *a1;
    v7 = 0x6DB6DB6DB6DB6DB7 * ((v5 - *a1) >> 3);
    v8 = v7 + a2;
    if (v7 + a2 > 0x492492492492492)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v9 = 0x6DB6DB6DB6DB6DB7 * ((v4 - v6) >> 3);
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0x249249249249249)
      v10 = 0x492492492492492;
    else
      v10 = v8;
    if (v10)
    {
      if (v10 > 0x492492492492492)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v11 = (char *)operator new(56 * v10);
    }
    else
    {
      v11 = 0;
    }
    v13 = &v11[56 * v7];
    v14 = &v11[56 * v10];
    v15 = 56 * ((56 * a2 - 56) / 0x38) + 56;
    bzero(v13, v15);
    v16 = &v13[v15];
    if (v5 != v6)
    {
      do
      {
        v17 = *(_OWORD *)(v5 - 56);
        v18 = *(_OWORD *)(v5 - 40);
        v19 = *(_OWORD *)(v5 - 24);
        *((_DWORD *)v13 - 2) = *((_DWORD *)v5 - 2);
        *(_OWORD *)(v13 - 24) = v19;
        *(_OWORD *)(v13 - 40) = v18;
        *(_OWORD *)(v13 - 56) = v17;
        v13 -= 56;
        v5 -= 56;
      }
      while (v5 != v6);
      v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v16;
    a1[2] = v14;
    if (v5)
      operator delete(v5);
  }
}

void HGComicColorStroke::HGComicColorStroke(HGComicColorStroke *this)
{
  uint64_t v1;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v1 = off_1E65254B8;
  *(_DWORD *)(v1 + 408) = 1065353216;
  *(_DWORD *)(v1 + 16) |= 0x600u;
}

void HGComicColorStroke::~HGComicColorStroke(HGNode *this)
{
  void *v1;

  HGNode::~HGNode(this);
  HGObject::operator delete(v1);
}

uint64_t HGComicColorStroke::SetParameter(HGComicColorStroke *this, int a2, float a3, float a4, float a5, float a6)
{
  if (a2)
    return 0xFFFFFFFFLL;
  if (*((float *)this + 102) == a3)
    return 0;
  *((float *)this + 102) = a3;
  return 1;
}

uint64_t HGComicColorStroke::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

uint64_t HGComicColorStroke::GetROI(HGComicColorStroke *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double v10;
  HGTransformUtils *v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE v17[144];
  HGRect v18;
  HGRect v19;
  HGRect v20;
  HGRect v21;
  HGRect v22;
  HGRect v23;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (a3 == 1)
  {
    v10 = *((float *)this + 102);
    HGTransform::HGTransform((HGTransform *)v17);
    HGTransform::Scale((HGTransform *)v17, v10, v10, 1.0);
    *(_QWORD *)&v18.var0 = 0;
    *(_QWORD *)&v18.var2 = 0;
    v12 = HGTransformUtils::MinW(v11);
    *(_QWORD *)&v23.var0 = v4;
    *(_QWORD *)&v18.var0 = HGTransformUtils::GetROI((HGTransformUtils *)v17, v5, v23, 0.5, v12);
    *(_QWORD *)&v18.var2 = v13;
    *(_QWORD *)&v21.var0 = 0xFFFFFFF8FFFFFFF8;
    *(_QWORD *)&v21.var2 = 0x800000008;
    HGRect::Grow(&v18, v21);
    v14 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    v16 = v15;
    *(_QWORD *)&v22.var0 = v14;
    *(_QWORD *)&v22.var2 = v16;
    HGRect::Grow(&v18, v22);
    HGTransform::~HGTransform((HGTransform *)v17);
    return *(_QWORD *)&v18.var0;
  }
  else if (a3)
  {
    return HGRectNull;
  }
  else
  {
    v18 = a4;
    *(_QWORD *)&v19.var0 = 0xFFFFFFF8FFFFFFF8;
    *(_QWORD *)&v19.var2 = 0x800000008;
    HGRect::Grow(&v18, v19);
    v6 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    v8 = v7;
    *(_QWORD *)&v20.var0 = v6;
    *(_QWORD *)&v20.var2 = v8;
    HGRect::Grow(&v18, v20);
    return *(_QWORD *)&v18.var0;
  }
}

void sub_1B2A6E4E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B2A6E4FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HGComicColorStroke::IntermediateFormat()
{
  return 24;
}

uint64_t HGComicColorStroke::RenderTile(HGComicColorStroke *this, int32x2_t *a2)
{
  int32x2_t *v2;
  uint64_t v4;
  int v5;
  float v6;
  int v9;
  int v10;
  float32x4_t v11;
  int8x16_t v12;
  float32x4_t v19;
  uint64_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int32x2_t v24;
  uint64_t v25;
  float32x4_t v26;
  int32x4_t v27;
  float32x2_t v28;
  float32x4_t *v29;
  float32x4_t v30;
  int8x16_t v31;
  int32x2_t v32;
  uint64_t v33;
  float32x4_t v34;
  int32x4_t v35;
  float32x4_t *v36;
  float32x4_t v37;
  uint64_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  int32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int32x4_t v46;
  float32x4_t v47;
  int8x16_t v48;
  int8x16_t v49;
  float32x4_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float32x4_t v53;
  uint64_t v54;
  int v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int32x2_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int32x4_t v65;
  float32x2_t v66;
  float32x4_t *v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  int32x4_t v72;
  float32x4_t *v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int32x4_t v77;
  float32x4_t *v78;
  float32x4_t v79;
  int8x16_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  int32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  int32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  int32x4_t v91;
  float32x4_t *v92;
  float32x4_t v93;
  int8x16_t v94;
  int v95;
  float32x4_t v96;
  int v97;
  int32x2_t *v98;
  uint64_t v99;
  int32x2_t v100;
  __int32 v101;
  float v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;

  v2 = a2;
  v102 = *((float *)this + 102);
  v4 = HGTile::Renderer((HGTile *)a2);
  v5 = (*(uint64_t (**)(HGComicColorStroke *, uint64_t))(*(_QWORD *)this + 312))(this, v4);
  v6 = v102;
  v95 = v2[1].i32[1] - HIDWORD(*(unint64_t *)v2);
  v99 = v2[1].i32[0] - v2->u32[0];
  if (v95 >= 1 && (int)(v2[1].i32[0] - *(_QWORD *)v2) >= 1)
  {
    v9 = v5;
    v10 = 0;
    *(float32x2_t *)v11.f32 = vadd_f32(vcvt_f32_s32(*v2), (float32x2_t)0x3F0000003F000000);
    v11.i64[1] = 0x3F80000000000000;
    v100 = v2[2];
    v12 = 0uLL;
    __asm { FMOV            V0.4S, #-1.0 }
    v103 = _Q0;
    __asm { FMOV            V0.4S, #1.0 }
    v106 = _Q0;
    v19 = v11;
    v98 = v2;
    v104 = v11;
    do
    {
      v97 = v10;
      v20 = 0;
      v96 = v19;
      v21 = v19;
      do
      {
        v24 = v2[12];
        v25 = v2[13].i32[0];
        v26 = vsubq_f32(vmulq_n_f32(v21, v6), v11);
        if (v9)
        {
          v27 = vaddq_s32(vcvtq_s32_f32(v26), vcltzq_f32(v26));
          v28 = (float32x2_t)vsubq_f32(v26, vcvtq_f32_s32(v27)).u64[0];
          v29 = (float32x4_t *)(*(_QWORD *)&v24 + 16 * (v27.i32[0] + v27.i32[1] * (int)v25));
          v30 = vaddq_f32(*v29, vmulq_n_f32(vsubq_f32(v29[1], *v29), v28.f32[0]));
          v31 = (int8x16_t)vaddq_f32(v30, vmulq_lane_f32(vsubq_f32(vaddq_f32(v29[v25], vmulq_n_f32(vsubq_f32(v29[(int)v25 + 1], v29[v25]), v28.f32[0])), v30), v28, 1));
          v32 = v2[10];
          v33 = v2[11].i32[0];
          v34 = vsubq_f32(v21, v11);
          v105 = v21;
          v35 = vaddq_s32(vcvtq_s32_f32(v34), vcltzq_f32(v34));
          v34.i64[0] = vsubq_f32(v34, vcvtq_f32_s32(v35)).u64[0];
          v36 = (float32x4_t *)(*(_QWORD *)&v32 + 16 * (v35.i32[0] + v35.i32[1] * (int)v33));
          v37 = vaddq_f32(*v36, vmulq_n_f32(vsubq_f32(v36[1], *v36), v34.f32[0]));
          v38 = v33 + 1;
          v39 = vsubq_f32(vaddq_f32(v36[v33], vmulq_n_f32(vsubq_f32(v36[v33 + 1], v36[v33]), v34.f32[0])), v37);
          v40 = vaddq_f32(v37, vmulq_lane_f32(v39, *(float32x2_t *)v34.f32, 1));
        }
        else
        {
          v41.i64[0] = 0x3F0000003F000000;
          v41.i64[1] = 0x3F0000003F000000;
          v42 = vaddq_f32(v26, v41);
          v43 = vcvtq_s32_f32(v42);
          v42.i64[0] = vaddq_s32(v43, vcgtq_f32(vcvtq_f32_s32(v43), v42)).u64[0];
          v31 = *(int8x16_t *)(*(_QWORD *)&v24 + 16 * (v42.i32[0] + v42.i32[1] * (int)v25));
          v32 = v2[10];
          v33 = v2[11].i32[0];
          v105 = v21;
          v44.i64[0] = 0x3F0000003F000000;
          v44.i64[1] = 0x3F0000003F000000;
          v45 = vaddq_f32(vsubq_f32(v21, v11), v44);
          v46 = vcvtq_s32_f32(v45);
          v39 = vcvtq_f32_s32(v46);
          v45.i64[0] = vaddq_s32(v46, vcgtq_f32(v39, v45)).u64[0];
          v40 = *(float32x4_t *)(*(_QWORD *)&v32 + 16 * (v45.i32[0] + v45.i32[1] * (int)v33));
          v38 = (int)v33 + 1;
        }
        v47 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.i8, 1);
        v39.i32[0] = 0;
        v48 = v31;
        v48.i32[1] = 0;
        v49 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v39, v47), (int8x16_t)vcgeq_f32(v47, v39))), 0), v48, v31);
        v50 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 2);
        v51 = v49;
        v51.i32[2] = 0;
        v49.i64[0] = vextq_s8(vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v39, v50), (int8x16_t)vcgeq_f32(v50, v39))), 0), v51, v49), v12, 4uLL).u64[0];
        v49.i64[1] = v12.i64[1];
        v52 = vminnmq_f32(vmaxnmq_f32(vaddq_f32(vaddq_f32((float32x4_t)v49, (float32x4_t)v49), v103), v103), v106);
        v53 = vnegq_f32(v52);
        v54 = (int)v25 + 1;
        v55 = -1;
        v101 = v40.i32[3];
        v56 = v40;
        v57 = (float32x4_t)xmmword_1B3051510;
        do
        {
          v107 = v57;
          v108 = v56;
          v109 = v53;
          v110 = v52;
          *(float *)v62.i32 = expf((float)v55 / 48.0);
          v12 = 0uLL;
          v63 = vaddq_f32(v105, (float32x4_t)v110.u64[0]);
          v64 = vsubq_f32(v63, v104);
          if (v9)
          {
            v65 = vaddq_s32(vcvtq_s32_f32(v64), vcltzq_f32(v64));
            v66 = (float32x2_t)vsubq_f32(v64, vcvtq_f32_s32(v65)).u64[0];
            v67 = (float32x4_t *)(*(_QWORD *)&v32 + 16 * (v65.i32[0] + v65.i32[1] * (int)v33));
            v68 = vaddq_f32(*v67, vmulq_n_f32(vsubq_f32(v67[1], *v67), v66.f32[0]));
            v69 = vaddq_f32(v68, vmulq_lane_f32(vsubq_f32(vaddq_f32(v67[v33], vmulq_n_f32(vsubq_f32(v67[v38], v67[v33]), v66.f32[0])), v68), v66, 1));
            v70 = vaddq_f32(v105, (float32x4_t)v109.u64[0]);
            v71 = vsubq_f32(v70, v104);
            v72 = vaddq_s32(vcvtq_s32_f32(v71), vcltzq_f32(v71));
            v71.i64[0] = vsubq_f32(v71, vcvtq_f32_s32(v72)).u64[0];
            v73 = (float32x4_t *)(*(_QWORD *)&v32 + 16 * (v72.i32[0] + v72.i32[1] * (int)v33));
            v74 = vaddq_f32(*v73, vmulq_n_f32(vsubq_f32(v73[1], *v73), v71.f32[0]));
            v75 = vaddq_f32(v69, vaddq_f32(v74, vmulq_lane_f32(vsubq_f32(vaddq_f32(v73[v33], vmulq_n_f32(vsubq_f32(v73[v38], v73[v33]), v71.f32[0])), v74), *(float32x2_t *)v71.f32, 1)));
            v6 = v102;
            v76 = vsubq_f32(vmulq_n_f32(v63, v102), v104);
            v77 = vaddq_s32(vcvtq_s32_f32(v76), vcltzq_f32(v76));
            v76.i64[0] = vsubq_f32(v76, vcvtq_f32_s32(v77)).u64[0];
            v78 = (float32x4_t *)(*(_QWORD *)&v24 + 16 * (v77.i32[0] + v77.i32[1] * (int)v25));
            v79 = vaddq_f32(*v78, vmulq_n_f32(vsubq_f32(v78[1], *v78), v76.f32[0]));
            v80 = (int8x16_t)vaddq_f32(v79, vmulq_lane_f32(vsubq_f32(vaddq_f32(v78[v25], vmulq_n_f32(vsubq_f32(v78[v54], v78[v25]), v76.f32[0])), v79), *(float32x2_t *)v76.f32, 1));
            v81 = vsubq_f32(vmulq_n_f32(v70, v102), v104);
            v91 = vaddq_s32(vcvtq_s32_f32(v81), vcltzq_f32(v81));
            v81.i64[0] = vsubq_f32(v81, vcvtq_f32_s32(v91)).u64[0];
            v92 = (float32x4_t *)(*(_QWORD *)&v24 + 16 * (v91.i32[0] + v91.i32[1] * (int)v25));
            v93 = vaddq_f32(*v92, vmulq_n_f32(vsubq_f32(v92[1], *v92), v81.f32[0]));
            v94 = (int8x16_t)vaddq_f32(v93, vmulq_lane_f32(vsubq_f32(vaddq_f32(v92[v25], vmulq_n_f32(vsubq_f32(v92[v54], v92[v25]), v81.f32[0])), v93), *(float32x2_t *)v81.f32, 1));
          }
          else
          {
            v82.i64[0] = 0x3F0000003F000000;
            v82.i64[1] = 0x3F0000003F000000;
            v83 = vaddq_f32(v64, v82);
            v84 = vcvtq_s32_f32(v83);
            v83.i64[0] = vaddq_s32(v84, vcgtq_f32(vcvtq_f32_s32(v84), v83)).u64[0];
            v85 = *(float32x4_t *)(*(_QWORD *)&v32 + 16 * (v83.i32[0] + v83.i32[1] * (int)v33));
            v86 = vaddq_f32(v105, (float32x4_t)v109.u64[0]);
            v87 = vaddq_f32(vsubq_f32(v86, v104), v82);
            v88 = vcvtq_s32_f32(v87);
            v87.i64[0] = vaddq_s32(v88, vcgtq_f32(vcvtq_f32_s32(v88), v87)).u64[0];
            v75 = vaddq_f32(v85, *(float32x4_t *)(*(_QWORD *)&v32 + 16 * (v87.i32[0] + v87.i32[1] * (int)v33)));
            v6 = v102;
            v89 = vaddq_f32(vsubq_f32(vmulq_n_f32(v63, v102), v104), v82);
            v90 = (float32x4_t)vcvtq_s32_f32(v89);
            v89.i64[0] = vaddq_s32((int32x4_t)v90, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v90), v89)).u64[0];
            v80 = *(int8x16_t *)(*(_QWORD *)&v24 + 16 * (v89.i32[0] + v89.i32[1] * (int)v25));
            v90.i64[0] = 0x3F0000003F000000;
            v90.i64[1] = 0x3F0000003F000000;
            v58 = vaddq_f32(vsubq_f32(vmulq_n_f32(v86, v102), v104), v90);
            v59 = vcvtq_s32_f32(v58);
            v58.i64[0] = vaddq_s32(v59, vcgtq_f32(vcvtq_f32_s32(v59), v58)).u64[0];
            v94 = *(int8x16_t *)(*(_QWORD *)&v24 + 16 * (v58.i32[0] + v58.i32[1] * (int)v25));
          }
          v57 = vaddq_f32(v107, (float32x4_t)vdupq_lane_s32(v62, 0));
          v56 = vaddq_f32(v108, vmulq_n_f32(v75, *(float *)v62.i32));
          v60 = (float32x4_t)vextq_s8(v80, (int8x16_t)0, 4uLL).u64[0];
          v52 = vaddq_f32(v110, vminnmq_f32(vmaxnmq_f32(vaddq_f32(vaddq_f32(v60, v60), v103), v103), v106));
          v61 = (float32x4_t)vextq_s8(v94, (int8x16_t)0, 4uLL).u64[0];
          v53 = vaddq_f32(v109, vminnmq_f32(vmaxnmq_f32(vaddq_f32(vaddq_f32(v61, v61), v103), v103), v106));
          --v55;
        }
        while (v55 != -8);
        v22.i64[0] = 0x3F0000003F000000;
        v22.i64[1] = 0x3F0000003F000000;
        v23 = vdivq_f32(vmulq_f32(v56, v22), v57);
        v23.i32[3] = v101;
        *(float32x4_t *)(*(_QWORD *)&v100 + 16 * v20) = vmaxnmq_f32(vminnmq_f32(v23, v106), (float32x4_t)0);
        v11 = v104;
        v21 = vaddq_f32(v105, (float32x4_t)xmmword_1B304F230);
        ++v20;
        v2 = v98;
      }
      while (v20 != v99);
      v19 = vaddq_f32(v96, (float32x4_t)xmmword_1B304F240);
      *(_QWORD *)&v100 += 16 * v98[3].i32[0];
      v10 = v97 + 1;
    }
    while (v97 + 1 != v95);
  }
  return 0;
}

const char *HGComicColorStroke::GetProgram(HGComicColorStroke *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) > 0x60B0F)
    return "//Metal1.0     \n"
           "//LEN=00000008b5\n"
           "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< half >      hg_Texture0 [[ texture(0) ]],\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]],\n"
           "                                  texture2d< half >      hg_Texture1 [[ texture(1) ]],\n"
           "                                  sampler                hg_Sampler1 [[ sampler(1) ]])\n"
           "{\n"
           "    // Get the 0'th normal (e0, for an exponent value of 0, so the coeff is 1.0)\n"
           "    float2 pointer = static_cast<float2>(hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).yz * 2.0f) - 1.0"
           "f;\n"
           "    float2 pointerRBack = -pointer;\n"
           "    \n"
           "    half4 acc = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
           "    half3 norma = {0.5h, 0.5h, 0.5h};\n"
           "\n"
           "    for (int i {1}; i < 8; ++i)\n"
           "    {\n"
           "        half coeff = exp(static_cast<half>(-i) / 48.0h);\n"
           "        norma += coeff;\n"
           "        \n"
           "        const float2 uPos0 = frag._texCoord0.xy + pointer;\n"
           "        const float2 uNeg0 = frag._texCoord0.xy + pointerRBack;\n"
           "        \n"
           "        const float2 uPos1 = frag._texCoord1.xy + pointer;\n"
           "        const float2 uNeg1 = frag._texCoord1.xy + pointerRBack;\n"
           "        \n"
           "        float2 acc_ptrTexCoord = uPos0;\n"
           "        float2 acc_ptrBackTexCoord = uNeg0;\n"
           "        \n"
           "        float2 grad_ptrTexCoord = uPos1;\n"
           "        float2 grad_ptrBackTexCoord = uNeg1;\n"
           "    \n"
           "        acc.rgb += coeff * (hg_Texture0.sample(hg_Sampler0, acc_ptrTexCoord).xyz +\n"
           "                            hg_Texture0.sample(hg_Sampler0, acc_ptrBackTexCoord).xyz);\n"
           "\n"
           "        pointer += static_cast<float2>(hg_Texture1.sample(hg_Sampler1, grad_ptrTexCoord).yz * 2.0f) - 1.0f;\n"
           "        pointerRBack -= static_cast<float2>(hg_Texture1.sample(hg_Sampler1, grad_ptrBackTexCoord).yz * 2.0f) "
           "- 1.0f;\n"
           "    }\n"
           "\n"
           "    FragmentOut out {float4(float3(acc.xyz * 0.5h / norma), acc.a)};\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    out.color0 = clamp(out.color0, 0.0f, 1.0f);\n"
           "    \n"
           "    return out;\n"
           "}\n"
           "//MD5=4e997c85:a0f6903a:77463274:2dba1821\n"
           "//SIG=00000000:00000000:00000000:00000003:000f:0000:0000:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
    return "//GLfs1.0      \n"
           "//LEN=000000079c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#define precision\n"
           "#define defaultp mediump\n"
           "#endif\n"
           "\n"
           " \n"
           "precision highp float;\n"
           "precision highp int;\n"
           "\n"
           "uniform defaultp sampler2DRect hg_Texture0;\n"
           "uniform defaultp sampler2DRect hg_Texture1;\n"
           "\n"
           "void main (void) \n"
           "{\n"
           "    float alpha = texture2DRect( hg_Texture0, gl_TexCoord[0].xy).a;\n"
           "    vec3 acc  =  texture2DRect( hg_Texture0, gl_TexCoord[0].xy).xyz; //L de LAB\n"
           "    vec3 norma  =  vec3(0.5,0.5,0.5) ;\n"
           "    \n"
           "    vec2 gradient = texture2DRect(hg_Texture1, gl_TexCoord[1].xy).yz; //DIRECCIONES\n"
           "    vec2 vdire = vec2( gradient.x*2.0-1.0 , gradient.y*2.0-1.0) ;\n"
           "    vec2 pointer = vec2( vdire.x  , vdire.y ) ;\n"
           "\n"
           "    vdire =   vec2( -(gradient.x*2.0-1.0) , -(gradient.y*2.0-1.0)) ;\n"
           "    vec2 pointerRBack =   vec2(  vdire.x  ,  vdire.y ) ;\n"
           "\n"
           "    for (float  i=1.0 ;i < 8.0 ;i++)    // direccion normal   1 - 7\n"
           "    {\n"
           "        float coeff =  exp(  - i / 48.0) ;\n"
           "        \n"
           "        vec2 uPos0 = gl_TexCoord[0].xy + pointer;\n"
           "        vec2 uNeg0 = gl_TexCoord[0].xy + pointerRBack;\n"
           "\n"
           "        vec2 uPos1 = gl_TexCoord[1].xy + pointer;\n"
           "        vec2 uNeg1 = gl_TexCoord[1].xy + pointerRBack;\n"
           "\n"
           "        acc  +=coeff * (texture2DRect(hg_Texture0, uPos0).xyz +\n"
           "                        texture2DRect(hg_Texture0, uNeg0).xyz);\n"
           "\n"
           "        norma += coeff;\n"
           "\n"
           "        gradient  = texture2DRect(hg_Texture1, uPos1).yz; //DIRECCIONES\n"
           "        vdire =   vec2( gradient.x*2.0-1.0 , gradient.y*2.0-1.0);\n"
           "        pointer +=  vdire  ;\n"
           "\n"
           "        gradient  = texture2DRect(hg_Texture1, uNeg1).yz; //DIRECCIONES\n"
           "        vdire =   vec2(-( gradient.x*2.0-1.0) , -(gradient.y*2.0-1.0));\n"
           "        pointerRBack +=  vdire  ;\n"
           "    }\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    gl_FragColor = clamp(vec4( acc*0.5/norma, alpha), 0.0, 1.0);\n"
           "}\n"
           "//MD5=3f48c7c9:9fb108b9:ab3c5d18:9729c820\n"
           "//SIG=00000000:00000000:00000000:00000000:0032:0000:0000:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  return 0;
}

uint64_t HGComicColorStroke::BindTexture(HGComicColorStroke *this, HGHandler *a2, uint64_t a3)
{
  if ((_DWORD)a3 == 1)
  {
    HGHandler::TexCoord(a2, 1, 0, 0, 0);
    (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, *((float *)this + 102), *((float *)this + 102), 1.0);
  }
  else if (!(_DWORD)a3)
  {
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, a3, 0);
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  (*(void (**)(HGHandler *, uint64_t, uint64_t))(*(_QWORD *)a2 + 48))(a2, 1, 1);
  return 0;
}

uint64_t HGMetalFunctionCache::HGMetalFunctionCache(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = a2;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_DWORD *)(a1 + 40) = 1065353216;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 48), 0);
  return a1;
}

void sub_1B2A6ED04(_Unwind_Exception *a1)
{
  void **v1;
  uint64_t v2;
  void **v4;

  v4 = *(void ***)(v2 + 24);
  if (v4)
    HGMetalFunctionCache::HGMetalFunctionCache(v4);
  HGMetalFunctionCache::HGMetalFunctionCache(v1);
  _Unwind_Resume(a1);
}

uint64_t *HGMetalFunctionCache::getFunction(uint64_t a1, const std::string *a2, uint64_t a3)
{
  pthread_mutex_t *v5;
  uint64_t **v6;
  uint64_t *v7;
  std::string __p;
  uint64_t v10;

  memset(&__p, 0, sizeof(__p));
  std::string::operator=(&__p, a2);
  v10 = a3;
  v5 = (pthread_mutex_t *)(a1 + 48);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 48));
  v6 = std::__hash_table<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::__unordered_map_hasher<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,HGMetalFunctionCache::InfoHash,std::equal_to<HGMetalFunctionCache::Info>,true>,std::__unordered_map_equal<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::equal_to<HGMetalFunctionCache::Info>,HGMetalFunctionCache::InfoHash,true>,std::allocator<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>>>::find<HGMetalFunctionCache::Info>((_QWORD *)(a1 + 8), (uint64_t)&__p);
  if (v6)
    v7 = v6[6];
  else
    v7 = 0;
  pthread_mutex_unlock(v5);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v7;
}

void sub_1B2A6EDB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *HGMetalFunctionCache::getFunctionWithSource(uint64_t a1, std::string *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t **v8;
  uint64_t *FunctionWithSource;
  std::string __p;
  uint64_t v12;
  std::string *p_p;

  memset(&__p, 0, sizeof(__p));
  std::string::operator=(&__p, a2);
  v12 = a3;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 48));
  v8 = std::__hash_table<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::__unordered_map_hasher<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,HGMetalFunctionCache::InfoHash,std::equal_to<HGMetalFunctionCache::Info>,true>,std::__unordered_map_equal<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::equal_to<HGMetalFunctionCache::Info>,HGMetalFunctionCache::InfoHash,true>,std::allocator<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>>>::find<HGMetalFunctionCache::Info>((_QWORD *)(a1 + 8), (uint64_t)&__p);
  if (v8)
  {
    FunctionWithSource = v8[6];
  }
  else
  {
    FunctionWithSource = (uint64_t *)HGMetalFunctionCache::_createFunctionWithSource((id *)a1, (uint64_t *)a2, a4);
    if (FunctionWithSource)
    {
      p_p = &__p;
      std::__hash_table<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::__unordered_map_hasher<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,HGMetalFunctionCache::InfoHash,std::equal_to<HGMetalFunctionCache::Info>,true>,std::__unordered_map_equal<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::equal_to<HGMetalFunctionCache::Info>,HGMetalFunctionCache::InfoHash,true>,std::allocator<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>>>::__emplace_unique_key_args<HGMetalFunctionCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalFunctionCache::Info const&>,std::tuple<>>(a1 + 8, (uint64_t)&__p, (uint64_t)&std::piecewise_construct, (__int128 **)&p_p)[6] = FunctionWithSource;
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 48));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return FunctionWithSource;
}

void sub_1B2A6EEB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalFunctionCache::_createFunctionWithSource(id *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v6;
  uint64_t v7;
  id v8;
  void *v9;
  uint64_t v10;
  const char *v11;
  char *v12;
  uint64_t *v13;
  uint64_t *v14;
  const char *v15;
  char *v16;
  uint64_t v17;
  unsigned __int8 v18;
  uint64_t *v19;
  id v21;
  _BYTE v22[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v22, "metal", 2, "HGMetalFunctionCache::_createFunctionWithSource()");
  if (*((char *)a3 + 23) >= 0)
    v6 = a3;
  else
    v6 = (uint64_t *)*a3;
  v7 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v6);
  v8 = objc_alloc_init(MEMORY[0x1E0CC6A68]);
  objc_msgSend(v8, "setLanguageVersion:", 131075);
  objc_msgSend(v8, "setFastMathEnabled:", 1);
  v21 = 0;
  v9 = (void *)objc_msgSend(*a1, "newLibraryWithSource:options:error:", v7, v8, &v21);

  if (v21
    && ((v10 = objc_msgSend((id)objc_msgSend(v21, "localizedDescription"), "UTF8String"), *((char *)a3 + 23) >= 0)
      ? (v13 = a3)
      : (v13 = (uint64_t *)*a3),
        HGLogger::warning((HGLogger *)"Failed to compile metal shader library!\n\n%s\n\n%s\n", v11, v12, v10, v13),
        objc_msgSend(v21, "code") != 4))
  {
    if (v9)

    v17 = 0;
  }
  else
  {
    if (*((char *)a2 + 23) >= 0)
      v14 = a2;
    else
      v14 = (uint64_t *)*a2;
    v17 = objc_msgSend(v9, "newFunctionWithName:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v14));
    if (!v17)
    {
      v18 = atomic_load(HGLogger::_enabled);
      if ((v18 & 1) != 0)
      {
        if (*((char *)a2 + 23) >= 0)
          v19 = a2;
        else
          v19 = (uint64_t *)*a2;
        HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"failed to retrieve %s from compiler shader!\n", v15, v16, v19);
      }
    }
    if (v9)

  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v22);
  return v17;
}

void sub_1B2A6F060(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A6F074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A6F088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A6F09C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t *HGMetalFunctionCache::getFunctionWithLibrary(uint64_t a1, std::string *a2, uint64_t a3)
{
  int v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t **v9;
  uint64_t *FunctionWithLibrary;
  std::string __p;
  unint64_t v13;
  std::string *p_p;

  memset(&__p, 0, sizeof(__p));
  std::string::operator=(&__p, a2);
  v6 = *(char *)(a3 + 23);
  if (v6 >= 0)
    v7 = (uint64_t *)a3;
  else
    v7 = *(uint64_t **)a3;
  if (v6 >= 0)
    v8 = *(unsigned __int8 *)(a3 + 23);
  else
    v8 = *(_QWORD *)(a3 + 8);
  v13 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&p_p, v7, v8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 48));
  v9 = std::__hash_table<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::__unordered_map_hasher<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,HGMetalFunctionCache::InfoHash,std::equal_to<HGMetalFunctionCache::Info>,true>,std::__unordered_map_equal<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::equal_to<HGMetalFunctionCache::Info>,HGMetalFunctionCache::InfoHash,true>,std::allocator<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>>>::find<HGMetalFunctionCache::Info>((_QWORD *)(a1 + 8), (uint64_t)&__p);
  if (v9)
  {
    FunctionWithLibrary = v9[6];
  }
  else
  {
    FunctionWithLibrary = (uint64_t *)HGMetalFunctionCache::_createFunctionWithLibrary((id *)a1, (uint64_t *)a2, (uint64_t *)a3);
    if (FunctionWithLibrary)
    {
      p_p = &__p;
      std::__hash_table<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::__unordered_map_hasher<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,HGMetalFunctionCache::InfoHash,std::equal_to<HGMetalFunctionCache::Info>,true>,std::__unordered_map_equal<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::equal_to<HGMetalFunctionCache::Info>,HGMetalFunctionCache::InfoHash,true>,std::allocator<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>>>::__emplace_unique_key_args<HGMetalFunctionCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalFunctionCache::Info const&>,std::tuple<>>(a1 + 8, (uint64_t)&__p, (uint64_t)&std::piecewise_construct, (__int128 **)&p_p)[6] = FunctionWithLibrary;
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 48));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return FunctionWithLibrary;
}

void sub_1B2A6F1A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void *HGMetalFunctionCache::_createFunctionWithLibrary(id *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v3;
  void *v6;
  const char *v7;
  char *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  char *v13;
  uint64_t *v14;
  const char *v15;
  char *v16;
  unsigned __int8 v17;
  uint64_t *v18;
  uint64_t *v19;
  id v21;

  v3 = a3;
  if (*((char *)a3 + 23) < 0)
  {
    if (!a3[1])
      goto LABEL_7;
    a3 = (uint64_t *)*a3;
LABEL_6:
    v6 = (void *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a3);
    goto LABEL_8;
  }
  if (*((_BYTE *)a3 + 23))
    goto LABEL_6;
LABEL_7:
  v6 = (void *)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB34D0], "mainBundle"), "pathForResource:ofType:", CFSTR("default"), CFSTR("metallib"));
  if (!v6)
  {
    HGLogger::warning((HGLogger *)"Failed to retrieve path for library default.metallib\n", v7, v8);
    return v6;
  }
LABEL_8:
  v21 = 0;
  v9 = (void *)objc_msgSend(*a1, "newLibraryWithURL:error:", objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:", v6), &v21);
  if (v21)
  {
    v10 = objc_msgSend(v6, "UTF8String");
    v11 = objc_msgSend((id)objc_msgSend(v21, "localizedDescription"), "UTF8String");
    HGLogger::warning((HGLogger *)"Failed to create new metal library from %s:\\n\n%s\n\n", v12, v13, v10, v11);
    if (objc_msgSend(v21, "code") != 4)
    {
      v6 = 0;
      if (!v9)
        return v6;
LABEL_25:

      return v6;
    }
  }
  if (*((char *)a2 + 23) >= 0)
    v14 = a2;
  else
    v14 = (uint64_t *)*a2;
  v6 = (void *)objc_msgSend(v9, "newFunctionWithName:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v14));
  if (!v6)
  {
    v17 = atomic_load(HGLogger::_enabled);
    if ((v17 & 1) != 0)
    {
      if (*((char *)a2 + 23) >= 0)
        v18 = a2;
      else
        v18 = (uint64_t *)*a2;
      if (*((char *)v3 + 23) >= 0)
        v19 = v3;
      else
        v19 = (uint64_t *)*v3;
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"failed to retrieve %s from metal library %s!\n", v15, v16, v18, v19);
    }
  }
  if (v9)
    goto LABEL_25;
  return v6;
}

uint64_t HGMetalRenderPipelineStateCache::Info::operator<(int *a1, int *a2)
{
  unint64_t v2;
  unint64_t v3;
  _BOOL8 v4;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  int v11;
  unint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *i;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  BOOL v19;
  unint64_t *v20;
  unint64_t *v21;
  unint64_t *v22;
  unint64_t *v23;
  unint64_t *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t *v29;
  unint64_t v30;
  unint64_t v31;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  BOOL v37;
  unint64_t *v38;
  unint64_t *v39;
  unint64_t *v40;
  unint64_t *v41;
  unint64_t *v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t *v47;
  unint64_t v48;
  unint64_t v49;
  unsigned int v51;
  unsigned int v52;

  v2 = *((_QWORD *)a1 + 49);
  v3 = *((_QWORD *)a2 + 49);
  if (v2 < v3)
    return 1;
  if (v3 < v2)
    return 0;
  v6 = *((_QWORD *)a1 + 50);
  v7 = *((_QWORD *)a2 + 50);
  if (v6 >= v7)
  {
    if (v7 >= v6)
    {
      v20 = (unint64_t *)*((_QWORD *)a2 + 51);
      v21 = (unint64_t *)*((_QWORD *)a2 + 52);
      v23 = (unint64_t *)*((_QWORD *)a1 + 51);
      v22 = (unint64_t *)*((_QWORD *)a1 + 52);
      if (v20 != v21)
      {
        v24 = v20 + 1;
        v25 = (unint64_t *)*((_QWORD *)a1 + 51);
        while (v25 != v22)
        {
          v26 = *v25;
          v27 = *(v24 - 1);
          if (*v25 < v27)
            break;
          ++v25;
          if (v27 < v26 || v24++ == v21)
            goto LABEL_36;
        }
        return 1;
      }
LABEL_36:
      if (v23 == v22)
      {
LABEL_45:
        v33 = a1[96];
        v34 = a2[96];
        if (v33 < v34)
          return 1;
        if (v34 >= v33)
        {
          v35 = *((unsigned __int8 *)a1 + 388);
          v36 = *((unsigned __int8 *)a2 + 388);
          v37 = v35 >= v36;
          v4 = v35 < v36;
          if (!v37)
            return v4;
        }
      }
      else
      {
        v29 = v23 + 1;
        while (v20 != v21)
        {
          v30 = *v20;
          v31 = *(v29 - 1);
          if (*v20 < v31)
            break;
          ++v20;
          if (v31 < v30 || v29++ == v22)
            goto LABEL_45;
        }
      }
    }
    v8 = *((_QWORD *)a2 + 50);
    v9 = *((_QWORD *)a1 + 50);
    if (v8 >= v9)
    {
      if (v9 >= v8)
      {
        v38 = (unint64_t *)*((_QWORD *)a1 + 51);
        v39 = (unint64_t *)*((_QWORD *)a1 + 52);
        v41 = (unint64_t *)*((_QWORD *)a2 + 51);
        v40 = (unint64_t *)*((_QWORD *)a2 + 52);
        if (v38 != v39)
        {
          v42 = v38 + 1;
          v43 = (unint64_t *)*((_QWORD *)a2 + 51);
          while (v43 != v40)
          {
            v44 = *v43;
            v45 = *(v42 - 1);
            if (*v43 < v45)
              break;
            ++v43;
            if (v45 < v44 || v42++ == v39)
              goto LABEL_59;
          }
          return 0;
        }
LABEL_59:
        if (v41 == v40)
        {
LABEL_68:
          v51 = a2[96];
          v52 = a1[96];
          if (v51 < v52 || v52 >= v51 && *((unsigned __int8 *)a2 + 388) < *((unsigned __int8 *)a1 + 388))
            return 0;
        }
        else
        {
          v47 = v41 + 1;
          while (v38 != v39)
          {
            v48 = *v38;
            v49 = *(v47 - 1);
            if (*v38 < v49)
              break;
            ++v38;
            if (v49 < v48 || v47++ == v40)
              goto LABEL_68;
          }
        }
      }
      v10 = *a1;
      v11 = *a2;
      if (*a1 < *a2)
        return 1;
      v12 = 0;
      v13 = (unsigned __int8 *)(a2 + 10);
      for (i = (unsigned __int8 *)(a1 + 10); ; i += 48)
      {
        if (v11 >= v10)
        {
          v15 = *i;
          v16 = *v13;
          if (v15 < v16)
            return 1;
          if (v16 > (v15 - 1))
          {
            if (HGBlendingInfo::operator<((uint64_t)(i - 32), (uint64_t)(v13 - 32)))
              return 1;
            v11 = *((_DWORD *)v13 - 10);
            v10 = *((_DWORD *)i - 10);
          }
        }
        if (v11 < v10)
          break;
        if (v10 < v11)
          goto LABEL_13;
        v17 = *v13;
        v18 = *i;
        if (v17 < v18)
          return 0;
        if (v18 <= (v17 - 1))
        {
LABEL_13:
          if (v12 > 6)
            return 0;
        }
        else
        {
          v19 = HGBlendingInfo::operator<((uint64_t)(v13 - 32), (uint64_t)(i - 32));
          v4 = 0;
          if (v19 || v12 > 6)
            return v4;
        }
        ++v12;
        v10 = *((_DWORD *)i + 2);
        v11 = *((_DWORD *)v13 + 2);
        v13 += 48;
        v4 = 1;
        if (v10 < v11)
          return v4;
      }
    }
    return 0;
  }
  return 1;
}

uint64_t HGMetalRenderPipelineStateCache::HGMetalRenderPipelineStateCache(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a1 + 16;
  *(_QWORD *)(a1 + 24) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 32), 0);
  return a1;
}

void sub_1B2A6F680(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD **v2;

  std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::destroy(v1, *v2);
  _Unwind_Resume(a1);
}

uint64_t HGMetalRenderPipelineStateCache::clear(HGMetalRenderPipelineStateCache *this)
{
  pthread_mutex_t *v2;
  uint64_t *v3;
  void *v5;
  HGMetalRenderPipelineStateCache *v6;
  void *v7;
  HGMetalRenderPipelineStateCache *v8;
  BOOL v9;
  uint64_t *v10;
  void *v11;

  v2 = (pthread_mutex_t *)((char *)this + 32);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  v3 = (uint64_t *)*((_QWORD *)this + 1);
  if (v3 != (uint64_t *)((char *)this + 16))
  {
    do
    {
      v5 = (void *)v3[58];
      if (v5)

      v6 = (HGMetalRenderPipelineStateCache *)v3[1];
      v7 = v3;
      if (v6)
      {
        do
        {
          v8 = v6;
          v6 = *(HGMetalRenderPipelineStateCache **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v8 = (HGMetalRenderPipelineStateCache *)*((_QWORD *)v7 + 2);
          v9 = *(_QWORD *)v8 == (_QWORD)v7;
          v7 = v8;
        }
        while (!v9);
      }
      if (*((uint64_t **)this + 1) == v3)
        *((_QWORD *)this + 1) = v8;
      v10 = (uint64_t *)*((_QWORD *)this + 2);
      --*((_QWORD *)this + 3);
      std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v10, v3);
      v11 = (void *)v3[55];
      if (v11)
      {
        v3[56] = (uint64_t)v11;
        operator delete(v11);
      }
      operator delete(v3);
      v3 = (uint64_t *)v8;
    }
    while (v8 != (HGMetalRenderPipelineStateCache *)((char *)this + 16));
  }
  return pthread_mutex_unlock(v2);
}

void *HGMetalRenderPipelineStateCache::getRenderPipelineState(uint64_t a1, int *a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t *v9;
  void *RenderPipelineState;
  void *v11;
  id v12;
  int *v14;

  v4 = (pthread_mutex_t *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  v5 = *(_QWORD *)(a1 + 16);
  v6 = a1 + 8;
  if (!v5)
    goto LABEL_8;
  v7 = a1 + 16;
  do
  {
    v8 = HGMetalRenderPipelineStateCache::Info::operator<((int *)(v5 + 32), a2);
    v9 = (uint64_t *)(v5 + 8);
    if (!v8)
    {
      v9 = (uint64_t *)v5;
      v7 = v5;
    }
    v5 = *v9;
  }
  while (*v9);
  if (v7 == a1 + 16 || HGMetalRenderPipelineStateCache::Info::operator<(a2, (int *)(v7 + 32)))
  {
LABEL_8:
    RenderPipelineState = HGMetalRenderPipelineStateCache::_createRenderPipelineState((id *)a1, (uint64_t)a2);
    v14 = a2;
    std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::__emplace_unique_key_args<HGMetalRenderPipelineStateCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalRenderPipelineStateCache::Info const&>,std::tuple<>>(v6, a2, (uint64_t)&std::piecewise_construct, (const void **)&v14)[58] = (uint64_t)RenderPipelineState;
  }
  v14 = a2;
  v11 = (void *)std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::__emplace_unique_key_args<HGMetalRenderPipelineStateCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalRenderPipelineStateCache::Info const&>,std::tuple<>>(v6, a2, (uint64_t)&std::piecewise_construct, (const void **)&v14)[58];
  pthread_mutex_unlock(v4);
  v12 = v11;
  return v11;
}

void *HGMetalRenderPipelineStateCache::_createRenderPipelineState(id *a1, uint64_t a2)
{
  void *v4;
  id v5;
  _QWORD *v6;
  _QWORD *i;
  void *v8;
  uint64_t v9;
  _DWORD *v10;
  _DWORD *v11;
  int v12;
  const char *v13;
  char *v14;
  unsigned __int8 v15;
  const BasePool *v16;
  uint64_t v17;
  void *v18;
  const char *v19;
  char *v20;
  unsigned __int8 v21;
  uint64_t v22;
  const char *v23;
  char *v24;
  id *v26;
  id v27[6];
  _BYTE v28[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v28, "mtl_utils", 2, "HGMetalRenderPipelineStateCache::_createRenderPipelineState()");
  v4 = (void *)objc_opt_new();
  objc_msgSend(v4, "setStencilAttachmentPixelFormat:", 0);
  objc_msgSend(v4, "setRasterSampleCount:", *(unsigned int *)(a2 + 384));
  objc_msgSend(v4, "setVertexFunction:", *(_QWORD *)(a2 + 392));
  objc_msgSend(v4, "setFragmentFunction:", *(_QWORD *)(a2 + 400));
  v5 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v6 = *(_QWORD **)(a2 + 408);
  for (i = *(_QWORD **)(a2 + 416); v6 != i; ++v6)
    objc_msgSend(v5, "addObject:", *v6);
  v26 = a1;
  if (objc_msgSend(v5, "count"))
  {
    v8 = (void *)objc_msgSend(MEMORY[0x1E0CC6B20], "linkedFunctions");
    objc_msgSend(v8, "setPrivateFunctions:", v5);
    objc_msgSend(v4, "setFragmentLinkedFunctions:", v8);
  }
  v9 = 0;
  v10 = (_DWORD *)a2;
  v11 = (_DWORD *)a2;
  do
  {
    v12 = *v11;
    v11 += 12;
    if (*((_BYTE *)v10 + 40))
    {
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setBlendingEnabled:", 1);
      v15 = atomic_load(HGLogger::_enabled);
      if ((v15 & 1) != 0)
        HGLogger::log((HGLogger *)"mtl_utils", (const char *)3, (HGLogger *)"[BLENDING ON] for unit: %d\n", v13, v14, v9);
      HGMetalBlendingInfo::HGMetalBlendingInfo((HGMetalBlendingInfo *)v27, (const HGBlendingInfo *)(v10 + 2));
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setAlphaBlendOperation:", HGPool::FixedTotalUsageServicingPolicy::maxObjectAgeNS((HGPool::FixedTotalUsageServicingPolicy *)v27, v16));
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setRgbBlendOperation:", HGParamField::fieldSize((HGParamField *)v27));
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setDestinationAlphaBlendFactor:", PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v27));
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setDestinationRGBBlendFactor:", OZFactoryBase::getFactoryForSerialization((uint64_t)v27));
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setSourceAlphaBlendFactor:", PCICCTransferFunctionLUT::getLUTEnd((PCICCTransferFunctionLUT *)v27));
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setSourceRGBBlendFactor:", PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)v27));
    }
    else
    {
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setBlendingEnabled:", 0);
    }
    ++v9;
    v10 = v11;
  }
  while (v9 != 8);
  if (*(_BYTE *)(a2 + 388))
    v17 = 252;
  else
    v17 = 0;
  objc_msgSend(v4, "setDepthAttachmentPixelFormat:", v17);
  v27[0] = 0;
  v18 = (void *)objc_msgSend(*v26, "newRenderPipelineStateWithDescriptor:error:", v4, v27);

  if (v27[0])
  {
    v21 = atomic_load(HGLogger::_enabled);
    if ((v21 & 1) != 0)
      HGLogger::log((HGLogger *)"mtl_utils", (const char *)1, (HGLogger *)"failed to create pipeline state! boo!\n", v19, v20);
    v22 = objc_msgSend((id)objc_msgSend(v27[0], "localizedDescription"), "UTF8String");
    HGLogger::warning((HGLogger *)"MTLPipelineState error: %s", v23, v24, v22);
    if (v18)
    {

      v18 = 0;
    }
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v28);
  return v18;
}

void sub_1B2A6FBAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A6FBC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A6FBD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A6FBE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A6FBFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A6FC10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A6FC24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGMetalUtils::metalFormat(int a1)
{
}

uint64_t HGMetalSamplerStateCache::HGMetalSamplerStateCache(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a1 + 16;
  *(_QWORD *)(a1 + 24) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 32), 0);
  return a1;
}

void sub_1B2A6FC94(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD **v2;

  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1, *v2);
  _Unwind_Resume(a1);
}

void *HGMetalSamplerStateCache::getSamplerState(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  unsigned int v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t SamplerState;
  void *v19;
  id v20;
  _OWORD *v22;

  v4 = (pthread_mutex_t *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  v5 = *(uint64_t **)(a1 + 16);
  v6 = (uint64_t **)(a1 + 8);
  if (!v5)
    goto LABEL_20;
  v8 = *(_QWORD *)a2;
  v7 = *(_QWORD *)(a2 + 8);
  v9 = *(_QWORD *)(a2 + 16);
  v10 = (uint64_t *)(a1 + 16);
  v11 = *(unsigned __int8 *)(a2 + 24);
  do
  {
    while (1)
    {
      v12 = v5[4];
      if (v12 >= v8)
      {
        if (v12 > v8)
          break;
        v13 = v5[5];
        if (v13 >= v7)
        {
          if (v13 > v7)
            break;
          v14 = v5[6];
          if (v14 >= v9 && (v14 > v9 || *((unsigned __int8 *)v5 + 56) >= v11))
            break;
        }
      }
      v5 = (uint64_t *)v5[1];
      if (!v5)
        goto LABEL_12;
    }
    v10 = v5;
    v5 = (uint64_t *)*v5;
  }
  while (v5);
LABEL_12:
  if (v10 == (uint64_t *)(a1 + 16)
    || (v15 = v10[4], v8 < v15)
    || v8 <= v15
    && ((v16 = v10[5], v7 < v16)
     || v7 <= v16 && ((v17 = v10[6], v9 < v17) || v9 <= v17 && v11 < *((unsigned __int8 *)v10 + 56))))
  {
LABEL_20:
    SamplerState = HGMetalSamplerStateCache::_createSamplerState((id *)a1, a2);
    v22 = (_OWORD *)a2;
    std::__tree<std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>,std::__map_value_compare<HGMetalSamplerStateCache::Info,std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>,std::less<HGMetalSamplerStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>>>::__emplace_unique_key_args<HGMetalSamplerStateCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalSamplerStateCache::Info const&>,std::tuple<>>(v6, (unint64_t *)a2, (uint64_t)&std::piecewise_construct, &v22)[8] = SamplerState;
  }
  v22 = (_OWORD *)a2;
  v19 = (void *)std::__tree<std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>,std::__map_value_compare<HGMetalSamplerStateCache::Info,std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>,std::less<HGMetalSamplerStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>>>::__emplace_unique_key_args<HGMetalSamplerStateCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalSamplerStateCache::Info const&>,std::tuple<>>(v6, (unint64_t *)a2, (uint64_t)&std::piecewise_construct, &v22)[8];
  pthread_mutex_unlock(v4);
  v20 = v19;
  return v19;
}

uint64_t HGMetalSamplerStateCache::_createSamplerState(id *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  _BYTE v7[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v7, "metal", 2, "HGMetalSamplerStateCache::_createSamplerState()");
  v4 = (void *)objc_opt_new();
  objc_msgSend(v4, "setMinFilter:", *(_QWORD *)a2);
  objc_msgSend(v4, "setMagFilter:", *(_QWORD *)(a2 + 8));
  objc_msgSend(v4, "setRAddressMode:", *(_QWORD *)(a2 + 16));
  objc_msgSend(v4, "setSAddressMode:", *(_QWORD *)(a2 + 16));
  objc_msgSend(v4, "setTAddressMode:", *(_QWORD *)(a2 + 16));
  objc_msgSend(v4, "setNormalizedCoordinates:", *(unsigned __int8 *)(a2 + 24));
  v5 = objc_msgSend(*a1, "newSamplerStateWithDescriptor:", v4);

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v7);
  return v5;
}

void sub_1B2A6FECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B2A6FEE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HGMetalDepthStencilStateCache::HGMetalDepthStencilStateCache(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a1 + 16;
  *(_QWORD *)(a1 + 24) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 32), 0);
  return a1;
}

void sub_1B2A6FF40(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD **v2;

  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1, *v2);
  _Unwind_Resume(a1);
}

uint64_t *HGMetalDepthStencilStateCache::getDepthStencilState(uint64_t a1, unsigned __int8 *a2)
{
  pthread_mutex_t *v4;
  uint64_t *v5;
  uint64_t **v6;
  unsigned int v7;
  unint64_t v8;
  uint64_t **v9;
  uint64_t **v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t DepthStencilState;
  unsigned __int8 *v14;
  uint64_t **v15;
  _QWORD *v16;
  unsigned int v17;
  unint64_t v18;
  unsigned int v19;
  unint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t **v24;
  unsigned int v25;
  unint64_t v26;
  unsigned int v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t *v33;

  v4 = (pthread_mutex_t *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  v6 = (uint64_t **)(a1 + 16);
  v5 = *(uint64_t **)(a1 + 16);
  if (!v5)
    goto LABEL_15;
  v7 = *a2;
  v8 = *((_QWORD *)a2 + 1);
  v9 = (uint64_t **)(a1 + 16);
  v10 = *(uint64_t ***)(a1 + 16);
  do
  {
    v11 = *((unsigned __int8 *)v10 + 32);
    if (v11 < v7)
    {
      ++v10;
    }
    else if (v11 <= v7)
    {
      if ((unint64_t)v10[5] < v8)
        ++v10;
      else
        v9 = v10;
    }
    else
    {
      v9 = v10;
    }
    v10 = (uint64_t **)*v10;
  }
  while (v10);
  if (v9 == v6 || (v12 = *((unsigned __int8 *)v9 + 32), v7 < v12) || v7 <= v12 && v8 < (unint64_t)v9[5])
  {
LABEL_15:
    DepthStencilState = HGMetalDepthStencilStateCache::_createDepthStencilState((id *)a1, a2);
    v14 = *(unsigned __int8 **)(a1 + 16);
    v15 = (uint64_t **)(a1 + 16);
    v16 = (_QWORD *)(a1 + 16);
    if (v14)
    {
      v17 = *a2;
      v18 = *((_QWORD *)a2 + 1);
      while (1)
      {
        v16 = v14;
        v19 = v14[32];
        if (v17 < v19)
          goto LABEL_17;
        if (v17 > v19)
        {
LABEL_22:
          v14 = (unsigned __int8 *)v16[1];
          if (!v14)
          {
            v15 = (uint64_t **)(v16 + 1);
            break;
          }
        }
        else
        {
          v20 = v16[5];
          if (v18 >= v20)
          {
            if (v20 >= v18)
              goto LABEL_27;
            goto LABEL_22;
          }
LABEL_17:
          v14 = (unsigned __int8 *)*v16;
          v15 = (uint64_t **)v16;
          if (!*v16)
            break;
        }
      }
    }
    v21 = v16;
    v16 = operator new(0x38uLL);
    *((_OWORD *)v16 + 2) = *(_OWORD *)a2;
    v16[6] = 0;
    *v16 = 0;
    v16[1] = 0;
    v16[2] = v21;
    *v15 = v16;
    v22 = **(_QWORD **)(a1 + 8);
    v23 = v16;
    if (v22)
    {
      *(_QWORD *)(a1 + 8) = v22;
      v23 = *v15;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 16), v23);
    ++*(_QWORD *)(a1 + 24);
LABEL_27:
    v16[6] = DepthStencilState;
    v5 = *v6;
  }
  v24 = (uint64_t **)(a1 + 16);
  if (v5)
  {
    v25 = *a2;
    v26 = *((_QWORD *)a2 + 1);
    while (1)
    {
      v24 = (uint64_t **)v5;
      v27 = *((unsigned __int8 *)v5 + 32);
      if (v25 < v27)
        goto LABEL_30;
      if (v25 > v27)
      {
LABEL_35:
        v5 = v24[1];
        if (!v5)
        {
          v6 = v24 + 1;
          break;
        }
      }
      else
      {
        v28 = v24[5];
        if (v26 >= (unint64_t)v28)
        {
          if ((unint64_t)v28 >= v26)
            goto LABEL_40;
          goto LABEL_35;
        }
LABEL_30:
        v5 = *v24;
        v6 = v24;
        if (!*v24)
          break;
      }
    }
  }
  v29 = (uint64_t *)v24;
  v24 = (uint64_t **)operator new(0x38uLL);
  *((_OWORD *)v24 + 2) = *(_OWORD *)a2;
  v24[6] = 0;
  *v24 = 0;
  v24[1] = 0;
  v24[2] = v29;
  *v6 = (uint64_t *)v24;
  v30 = **(_QWORD **)(a1 + 8);
  v31 = (uint64_t *)v24;
  if (v30)
  {
    *(_QWORD *)(a1 + 8) = v30;
    v31 = *v6;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 16), v31);
  ++*(_QWORD *)(a1 + 24);
LABEL_40:
  v32 = v24[6];
  pthread_mutex_unlock(v4);
  v33 = v32;
  return v32;
}

uint64_t HGMetalDepthStencilStateCache::_createDepthStencilState(id *a1, unsigned __int8 *a2)
{
  void *v4;
  uint64_t v5;
  _BYTE v7[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v7, "metal", 2, "HGMetalDepthStencilStateCache::_createDepthStencilState()");
  v4 = (void *)objc_opt_new();
  objc_msgSend(v4, "setDepthWriteEnabled:", *a2);
  objc_msgSend(v4, "setDepthCompareFunction:", *((_QWORD *)a2 + 1));
  v5 = objc_msgSend(*a1, "newDepthStencilStateWithDescriptor:", v4);

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v7);
  return v5;
}

void sub_1B2A70238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B2A7024C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HGMetalUtils::hgFormat(HGMetalUtils *this)
{
  char *v1;
  uint64_t result;

  v1 = (char *)this - 10;
  result = 0;
  switch((unint64_t)v1)
  {
    case 0uLL:
      result = 1;
      break;
    case 1uLL:
    case 2uLL:
    case 3uLL:
    case 4uLL:
    case 5uLL:
    case 6uLL:
    case 7uLL:
    case 8uLL:
    case 9uLL:
    case 0xBuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x13uLL:
    case 0x15uLL:
    case 0x16uLL:
    case 0x17uLL:
    case 0x18uLL:
    case 0x19uLL:
    case 0x1AuLL:
    case 0x1BuLL:
    case 0x1CuLL:
    case 0x1DuLL:
    case 0x1EuLL:
    case 0x1FuLL:
    case 0x20uLL:
    case 0x21uLL:
    case 0x22uLL:
    case 0x23uLL:
    case 0x24uLL:
    case 0x25uLL:
    case 0x26uLL:
    case 0x27uLL:
    case 0x28uLL:
    case 0x29uLL:
    case 0x2AuLL:
    case 0x2BuLL:
    case 0x2CuLL:
    case 0x2EuLL:
    case 0x2FuLL:
    case 0x30uLL:
    case 0x31uLL:
    case 0x33uLL:
    case 0x34uLL:
    case 0x35uLL:
    case 0x36uLL:
    case 0x38uLL:
    case 0x39uLL:
    case 0x3AuLL:
    case 0x3BuLL:
    case 0x3DuLL:
    case 0x3EuLL:
    case 0x3FuLL:
    case 0x40uLL:
    case 0x41uLL:
    case 0x42uLL:
    case 0x43uLL:
    case 0x44uLL:
    case 0x45uLL:
    case 0x47uLL:
    case 0x48uLL:
    case 0x49uLL:
    case 0x4AuLL:
    case 0x4BuLL:
    case 0x4CuLL:
    case 0x4DuLL:
    case 0x4EuLL:
    case 0x4FuLL:
    case 0x50uLL:
    case 0x51uLL:
    case 0x52uLL:
    case 0x53uLL:
    case 0x54uLL:
    case 0x55uLL:
    case 0x56uLL:
    case 0x57uLL:
    case 0x58uLL:
    case 0x59uLL:
    case 0x5AuLL:
    case 0x5BuLL:
    case 0x5CuLL:
    case 0x5DuLL:
    case 0x5EuLL:
    case 0x60uLL:
    case 0x61uLL:
    case 0x62uLL:
    case 0x63uLL:
    case 0x65uLL:
    case 0x66uLL:
    case 0x67uLL:
    case 0x68uLL:
    case 0x6AuLL:
    case 0x6BuLL:
    case 0x6CuLL:
    case 0x6DuLL:
    case 0x6EuLL:
    case 0x6FuLL:
    case 0x70uLL:
    case 0x71uLL:
    case 0x72uLL:
      return result;
    case 0xAuLL:
      result = 3;
      break;
    case 0xFuLL:
      result = 5;
      break;
    case 0x14uLL:
      result = 10;
      break;
    case 0x2DuLL:
      result = 7;
      break;
    case 0x32uLL:
      result = 11;
      break;
    case 0x37uLL:
      result = 12;
      break;
    case 0x3CuLL:
      result = 24;
      break;
    case 0x46uLL:
      result = 23;
      break;
    case 0x5FuLL:
      result = 13;
      break;
    case 0x64uLL:
      result = 25;
      break;
    case 0x69uLL:
      result = 27;
      break;
    case 0x73uLL:
      result = 28;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t HGMetalUtils::bytesPerPixel(HGMetalUtils *this)
{
  uint64_t result;

  result = 0;
  switch((unint64_t)this)
  {
    case 1uLL:
    case 0xAuLL:
      result = 1;
      break;
    case 2uLL:
    case 3uLL:
    case 4uLL:
    case 5uLL:
    case 6uLL:
    case 7uLL:
    case 8uLL:
    case 9uLL:
    case 0xBuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x13uLL:
    case 0x15uLL:
    case 0x16uLL:
    case 0x17uLL:
    case 0x18uLL:
    case 0x1AuLL:
    case 0x1BuLL:
    case 0x1CuLL:
    case 0x1DuLL:
    case 0x1FuLL:
    case 0x20uLL:
    case 0x21uLL:
    case 0x22uLL:
    case 0x23uLL:
    case 0x24uLL:
    case 0x25uLL:
    case 0x26uLL:
    case 0x27uLL:
    case 0x28uLL:
    case 0x29uLL:
    case 0x2AuLL:
    case 0x2BuLL:
    case 0x2CuLL:
    case 0x2DuLL:
    case 0x2EuLL:
    case 0x2FuLL:
    case 0x30uLL:
    case 0x31uLL:
    case 0x32uLL:
    case 0x33uLL:
    case 0x34uLL:
    case 0x35uLL:
    case 0x36uLL:
    case 0x38uLL:
    case 0x39uLL:
    case 0x3AuLL:
    case 0x3BuLL:
    case 0x3DuLL:
    case 0x3EuLL:
    case 0x3FuLL:
    case 0x40uLL:
    case 0x42uLL:
    case 0x43uLL:
    case 0x44uLL:
    case 0x45uLL:
    case 0x47uLL:
    case 0x48uLL:
    case 0x49uLL:
    case 0x4AuLL:
    case 0x4BuLL:
    case 0x4CuLL:
    case 0x4DuLL:
    case 0x4EuLL:
    case 0x4FuLL:
    case 0x51uLL:
    case 0x52uLL:
    case 0x53uLL:
    case 0x54uLL:
    case 0x55uLL:
    case 0x56uLL:
    case 0x57uLL:
    case 0x58uLL:
    case 0x59uLL:
    case 0x5BuLL:
    case 0x5CuLL:
    case 0x5DuLL:
    case 0x5EuLL:
    case 0x5FuLL:
    case 0x60uLL:
    case 0x61uLL:
    case 0x62uLL:
    case 0x63uLL:
    case 0x64uLL:
    case 0x65uLL:
    case 0x66uLL:
    case 0x67uLL:
    case 0x68uLL:
    case 0x6AuLL:
    case 0x6BuLL:
    case 0x6CuLL:
    case 0x6DuLL:
    case 0x6FuLL:
    case 0x70uLL:
    case 0x71uLL:
    case 0x72uLL:
    case 0x74uLL:
    case 0x75uLL:
    case 0x76uLL:
    case 0x77uLL:
    case 0x78uLL:
    case 0x79uLL:
    case 0x7AuLL:
    case 0x7BuLL:
    case 0x7CuLL:
      return result;
    case 0x14uLL:
    case 0x19uLL:
    case 0x1EuLL:
      result = 2;
      break;
    case 0x37uLL:
    case 0x3CuLL:
    case 0x41uLL:
    case 0x46uLL:
    case 0x50uLL:
    case 0x5AuLL:
      goto LABEL_2;
    case 0x69uLL:
    case 0x6EuLL:
    case 0x73uLL:
      result = 8;
      break;
    case 0x7DuLL:
      result = 16;
      break;
    default:
      if (this == (HGMetalUtils *)252)
LABEL_2:
        result = 4;
      break;
  }
  return result;
}

const char *HGMetalUtils::toString(HGMetalUtils *this)
{
  char *v1;
  const char *result;

  v1 = (char *)this - 1;
  result = "A8";
  switch((unint64_t)v1)
  {
    case 0uLL:
      return result;
    case 1uLL:
    case 2uLL:
    case 3uLL:
    case 4uLL:
    case 5uLL:
    case 6uLL:
    case 7uLL:
    case 8uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
    case 0x15uLL:
    case 0x16uLL:
    case 0x17uLL:
    case 0x19uLL:
    case 0x1AuLL:
    case 0x1BuLL:
    case 0x1CuLL:
    case 0x1EuLL:
    case 0x1FuLL:
    case 0x20uLL:
    case 0x21uLL:
    case 0x22uLL:
    case 0x23uLL:
    case 0x24uLL:
    case 0x25uLL:
    case 0x26uLL:
    case 0x27uLL:
    case 0x28uLL:
    case 0x29uLL:
    case 0x2AuLL:
    case 0x2BuLL:
    case 0x2CuLL:
    case 0x2DuLL:
    case 0x2EuLL:
    case 0x2FuLL:
    case 0x30uLL:
    case 0x31uLL:
    case 0x32uLL:
    case 0x33uLL:
    case 0x34uLL:
    case 0x35uLL:
    case 0x37uLL:
    case 0x38uLL:
    case 0x39uLL:
    case 0x3AuLL:
    case 0x3CuLL:
    case 0x3DuLL:
    case 0x3EuLL:
    case 0x3FuLL:
    case 0x41uLL:
    case 0x42uLL:
    case 0x43uLL:
    case 0x44uLL:
    case 0x46uLL:
    case 0x47uLL:
    case 0x48uLL:
    case 0x49uLL:
    case 0x4AuLL:
    case 0x4BuLL:
    case 0x4CuLL:
    case 0x4DuLL:
    case 0x4EuLL:
    case 0x50uLL:
    case 0x51uLL:
    case 0x52uLL:
    case 0x53uLL:
    case 0x54uLL:
    case 0x55uLL:
    case 0x56uLL:
    case 0x57uLL:
    case 0x58uLL:
    case 0x59uLL:
    case 0x5AuLL:
    case 0x5BuLL:
    case 0x5CuLL:
    case 0x5DuLL:
    case 0x5EuLL:
    case 0x5FuLL:
    case 0x60uLL:
    case 0x61uLL:
    case 0x62uLL:
    case 0x63uLL:
    case 0x64uLL:
    case 0x65uLL:
    case 0x66uLL:
    case 0x67uLL:
    case 0x69uLL:
    case 0x6AuLL:
    case 0x6BuLL:
    case 0x6CuLL:
    case 0x6EuLL:
    case 0x6FuLL:
    case 0x70uLL:
    case 0x71uLL:
    case 0x73uLL:
    case 0x74uLL:
    case 0x75uLL:
    case 0x76uLL:
    case 0x77uLL:
    case 0x78uLL:
    case 0x79uLL:
    case 0x7AuLL:
    case 0x7BuLL:
      goto LABEL_5;
    case 9uLL:
      result = "R8";
      break;
    case 0x13uLL:
      result = "R16";
      break;
    case 0x18uLL:
      result = "R16F";
      break;
    case 0x1DuLL:
      result = "RG8";
      break;
    case 0x36uLL:
      result = "R32F";
      break;
    case 0x3BuLL:
      result = "RG16";
      break;
    case 0x40uLL:
      result = "RG16F";
      break;
    case 0x45uLL:
      result = "RGBA8";
      break;
    case 0x4FuLL:
      result = "BGRA8";
      break;
    case 0x68uLL:
      result = "RG32F";
      break;
    case 0x6DuLL:
      result = "RGBA16";
      break;
    case 0x72uLL:
      result = "RGBA16F";
      break;
    case 0x7CuLL:
      result = "RGBA32F";
      break;
    default:
      if ("A8" == (char *)252)
        result = "D32F";
      else
LABEL_5:
        result = "(fmt)";
      break;
  }
  return result;
}

_QWORD *HGMetalCommandBufferRef::HGMetalCommandBufferRef(_QWORD *a1, void *a2)
{
  id v3;

  *a1 = a2;
  v3 = a2;
  return a1;
}

void HGMetalCommandBufferRef::~HGMetalCommandBufferRef(id *this)
{

  *this = 0;
}

void HGMetalCommandBufferRef::waitUntilScheduled(id *this)
{
  _BYTE v2[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v2, "gpu", 1, "HGMetalCommandBufferRef::waitUntilScheduled");
  kdebug_trace();
  objc_msgSend(*this, "waitUntilScheduled");
  kdebug_trace();
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v2);
}

void sub_1B2A70534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11, __int16 a12, char a13)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B2A70550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGMetalCommandBufferRef::waitUntilCompleted(id *this)
{
  _BYTE v2[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v2, "gpu", 1, "HGMetalCommandBufferRef::waitUntilCompleted");
  kdebug_trace();
  objc_msgSend(*this, "waitUntilCompleted");
  kdebug_trace();
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v2);
}

void sub_1B2A705F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11, __int16 a12, char a13)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B2A70614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

char *HGMetalUtils::stringForMetalHeader@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x58uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B35225A0;
  strcpy(result, "#include <metal_stdlib>    \n                           \nusing namespace metal;     \n\n");
  return result;
}

std::string *HGMetalUtils::stringForMetalVertexOutputStruct@<X0>(HGMetalUtils *this@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  int v4;
  unint64_t i;
  std::string *v7;
  __int128 v8;
  std::string *v9;
  std::string::size_type size;
  std::string *v11;
  __int128 v12;
  std::string *v13;
  __int128 v14;
  void **v15;
  std::string::size_type v16;
  std::string v18;
  std::string v19;
  std::string v20;
  void *__p[2];
  int64_t v22;
  std::string v23;

  v4 = (int)this;
  *(_BYTE *)(a3 + 23) = 0;
  *(_BYTE *)a3 = 0;
  std::string::append((std::string *)a3, "struct VertexInOut {\n");
  std::string::append((std::string *)a3, "    float4 _position  [[ position ]];\n");
  if (v4)
  {
    for (i = 0; v4 != i; ++i)
    {
      std::to_string(&v23, i);
      std::operator+<char>();
      v7 = std::string::append(&v18, " [[ user(texcoord");
      v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      v19.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v9 = &v23;
      else
        v9 = (std::string *)v23.__r_.__value_.__r.__words[0];
      if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v23.__r_.__value_.__r.__words[2]);
      else
        size = v23.__r_.__value_.__l.__size_;
      v11 = std::string::append(&v19, (const std::string::value_type *)v9, size);
      v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      v20.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      v13 = std::string::append(&v20, ") ]]; \n");
      v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
      v22 = v13->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v14;
      v13->__r_.__value_.__l.__size_ = 0;
      v13->__r_.__value_.__r.__words[2] = 0;
      v13->__r_.__value_.__r.__words[0] = 0;
      if (v22 >= 0)
        v15 = __p;
      else
        v15 = (void **)__p[0];
      if (v22 >= 0)
        v16 = HIBYTE(v22);
      else
        v16 = (std::string::size_type)__p[1];
      std::string::append((std::string *)a3, (const std::string::value_type *)v15, v16);
      if (SHIBYTE(v22) < 0)
      {
        operator delete(__p[0]);
        if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_18:
          if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_19;
          goto LABEL_24;
        }
      }
      else if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_18;
      }
      operator delete(v20.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_19:
        if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_20;
        goto LABEL_25;
      }
LABEL_24:
      operator delete(v19.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_20:
        if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_26;
        continue;
      }
LABEL_25:
      operator delete(v18.__r_.__value_.__l.__data_);
      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
LABEL_26:
        operator delete(v23.__r_.__value_.__l.__data_);
    }
  }
  if ((a2 & 1) != 0)
    std::string::append((std::string *)a3, "    float4 _color     [[ user(primary) ]];\n");
  return std::string::append((std::string *)a3, "};\n\n");
}

void sub_1B2A70890(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  uint64_t v35;

  if (*(char *)(v35 + 23) < 0)
  {
    operator delete(*(void **)v35);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

std::string *HGMetalUtils::stringForMetalVertexShader@<X0>(HGMetalUtils *this@<X0>, const char *a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  int v4;
  size_t v7;
  std::string::size_type v8;
  std::string *p_dst;
  uint64_t v10;
  uint64_t v11;
  std::string *v12;
  __int128 v13;
  std::string *v14;
  std::string::size_type size;
  uint64_t v16;
  unint64_t v17;
  std::string *v18;
  __int128 v19;
  std::string *v20;
  __int128 v21;
  unint64_t v22;
  std::string *v23;
  std::string::size_type v24;
  std::string *v25;
  __int128 v26;
  std::string *v27;
  __int128 v28;
  std::string *v29;
  std::string::size_type v30;
  unint64_t v31;
  std::string *v32;
  __int128 v33;
  std::string *v34;
  std::string::size_type v35;
  std::string *v36;
  __int128 v37;
  std::string *v38;
  __int128 v39;
  std::string *v40;
  std::string::size_type v41;
  std::string *v42;
  __int128 v43;
  std::string *v44;
  __int128 v45;
  std::string *v46;
  std::string::size_type v47;
  std::string v50;
  std::string v51;
  std::string v52;
  std::string __p;
  std::string v54;
  std::string __dst;
  std::string v56;

  v4 = (int)a2;
  *(_BYTE *)(a4 + 23) = 0;
  *(_BYTE *)a4 = 0;
  std::string::append((std::string *)a4, "[[ vertex ]]\n");
  std::string::append((std::string *)a4, "VertexInOut ");
  v7 = strlen((const char *)this);
  if (v7 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v8 = v7;
  if (v7 >= 0x17)
  {
    v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v10 = v7 | 7;
    v11 = v10 + 1;
    p_dst = (std::string *)operator new(v10 + 1);
    __dst.__r_.__value_.__l.__size_ = v8;
    __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_8;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v7;
  p_dst = &__dst;
  if (v7)
LABEL_8:
    memcpy(p_dst, this, v8);
  p_dst->__r_.__value_.__s.__data_[v8] = 0;
  v12 = std::string::append(&__dst, "(constant float4x4 *matrices [[ buffer(0) ]], \n");
  v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v56.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v14 = &v56;
  else
    v14 = (std::string *)v56.__r_.__value_.__r.__words[0];
  if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v56.__r_.__value_.__r.__words[2]);
  else
    size = v56.__r_.__value_.__l.__size_;
  std::string::append((std::string *)a4, (const std::string::value_type *)v14, size);
  if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v56.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_17;
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_17;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_17:
  std::string::append((std::string *)a4, "    const device float4 *positions [[ buffer(1) ]], \n");
  std::string::append((std::string *)a4, "    const device float4 *colors [[ buffer(2) ]], \n");
  v16 = v4;
  if (v4)
  {
    v17 = 0;
    while (1)
    {
      std::to_string(&v52, v17);
      v18 = std::string::insert(&v52, 0, "    const device float4 *texCoords");
      v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v19;
      v18->__r_.__value_.__l.__size_ = 0;
      v18->__r_.__value_.__r.__words[2] = 0;
      v18->__r_.__value_.__r.__words[0] = 0;
      v20 = std::string::append(&__p, " [[ buffer(");
      v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
      v54.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v21;
      v20->__r_.__value_.__l.__size_ = 0;
      v20->__r_.__value_.__r.__words[2] = 0;
      v20->__r_.__value_.__r.__words[0] = 0;
      v22 = v17 + 3;
      std::to_string(&v51, v22);
      if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v23 = &v51;
      else
        v23 = (std::string *)v51.__r_.__value_.__r.__words[0];
      if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v24 = HIBYTE(v51.__r_.__value_.__r.__words[2]);
      else
        v24 = v51.__r_.__value_.__l.__size_;
      v25 = std::string::append(&v54, (const std::string::value_type *)v23, v24);
      v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      __dst.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      v27 = std::string::append(&__dst, ") ]], \n");
      v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
      v56.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v28;
      v27->__r_.__value_.__l.__size_ = 0;
      v27->__r_.__value_.__r.__words[2] = 0;
      v27->__r_.__value_.__r.__words[0] = 0;
      if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v29 = &v56;
      else
        v29 = (std::string *)v56.__r_.__value_.__r.__words[0];
      if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v30 = HIBYTE(v56.__r_.__value_.__r.__words[2]);
      else
        v30 = v56.__r_.__value_.__l.__size_;
      std::string::append((std::string *)a4, (const std::string::value_type *)v29, v30);
      if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v56.__r_.__value_.__l.__data_);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_40;
LABEL_35:
        if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_36;
LABEL_41:
        operator delete(v51.__r_.__value_.__l.__data_);
        if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_42;
LABEL_37:
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_43;
LABEL_19:
        operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_44;
LABEL_20:
        v17 = v22 - 2;
        if (v17 == v4)
          break;
      }
      else
      {
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_35;
LABEL_40:
        operator delete(__dst.__r_.__value_.__l.__data_);
        if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_41;
LABEL_36:
        if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_37;
LABEL_42:
        operator delete(v54.__r_.__value_.__l.__data_);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_19;
LABEL_43:
        if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_20;
LABEL_44:
        operator delete(v52.__r_.__value_.__l.__data_);
        v17 = v22 - 2;
        if (v17 == v4)
          break;
      }
    }
  }
  std::string::append((std::string *)a4, "    uint vid [[ vertex_id ]])\n{\n");
  std::string::append((std::string *)a4, "    constant float4x4 *projectionMatrix = matrices;\n");
  if (v4)
    std::string::append((std::string *)a4, "    constant float4x4 *textureMatrices = matrices+1;\n");
  std::string::append((std::string *)a4, "    VertexInOut vertices;\n");
  std::string::append((std::string *)a4, "    vertices._position  = *projectionMatrix * positions[vid];\n");
  if (v4)
  {
    v31 = 0;
    while (1)
    {
      std::to_string(&v56, v31);
      std::operator+<char>();
      v32 = std::string::append(&v50, " = textureMatrices[");
      v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
      v51.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v33;
      v32->__r_.__value_.__l.__size_ = 0;
      v32->__r_.__value_.__r.__words[2] = 0;
      v32->__r_.__value_.__r.__words[0] = 0;
      if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v34 = &v56;
      else
        v34 = (std::string *)v56.__r_.__value_.__r.__words[0];
      if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v35 = HIBYTE(v56.__r_.__value_.__r.__words[2]);
      else
        v35 = v56.__r_.__value_.__l.__size_;
      v36 = std::string::append(&v51, (const std::string::value_type *)v34, v35);
      v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
      v52.__r_.__value_.__r.__words[2] = v36->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v37;
      v36->__r_.__value_.__l.__size_ = 0;
      v36->__r_.__value_.__r.__words[2] = 0;
      v36->__r_.__value_.__r.__words[0] = 0;
      v38 = std::string::append(&v52, "] * texCoords");
      v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v39;
      v38->__r_.__value_.__l.__size_ = 0;
      v38->__r_.__value_.__r.__words[2] = 0;
      v38->__r_.__value_.__r.__words[0] = 0;
      if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v40 = &v56;
      else
        v40 = (std::string *)v56.__r_.__value_.__r.__words[0];
      if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v41 = HIBYTE(v56.__r_.__value_.__r.__words[2]);
      else
        v41 = v56.__r_.__value_.__l.__size_;
      v42 = std::string::append(&__p, (const std::string::value_type *)v40, v41);
      v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
      v54.__r_.__value_.__r.__words[2] = v42->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v43;
      v42->__r_.__value_.__l.__size_ = 0;
      v42->__r_.__value_.__r.__words[2] = 0;
      v42->__r_.__value_.__r.__words[0] = 0;
      v44 = std::string::append(&v54, "[vid];\n");
      v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
      __dst.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v45;
      v44->__r_.__value_.__l.__size_ = 0;
      v44->__r_.__value_.__r.__words[2] = 0;
      v44->__r_.__value_.__r.__words[0] = 0;
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v46 = &__dst;
      else
        v46 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v47 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      else
        v47 = __dst.__r_.__value_.__l.__size_;
      std::string::append((std::string *)a4, (const std::string::value_type *)v46, v47);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__dst.__r_.__value_.__l.__data_);
        if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_77;
LABEL_71:
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_72;
LABEL_78:
        operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_79;
LABEL_73:
        if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_74;
LABEL_80:
        operator delete(v51.__r_.__value_.__l.__data_);
        if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_49;
LABEL_81:
        if ((SHIBYTE(v56.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_50;
LABEL_82:
        operator delete(v56.__r_.__value_.__l.__data_);
        if (v16 == ++v31)
          break;
      }
      else
      {
        if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_71;
LABEL_77:
        operator delete(v54.__r_.__value_.__l.__data_);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_78;
LABEL_72:
        if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_73;
LABEL_79:
        operator delete(v52.__r_.__value_.__l.__data_);
        if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_80;
LABEL_74:
        if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_81;
LABEL_49:
        operator delete(v50.__r_.__value_.__l.__data_);
        if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_82;
LABEL_50:
        if (v16 == ++v31)
          break;
      }
    }
  }
  if ((a3 & 1) != 0)
    std::string::append((std::string *)a4, "    vertices._color = colors[vid]; \n");
  std::string::append((std::string *)a4, "    return vertices;\n");
  return std::string::append((std::string *)a4, "}\n\n");
}

void sub_1B2A70F60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *__p,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  uint64_t v49;
  uint64_t v50;

  if (*(char *)(v50 - 105) < 0)
    operator delete(*(void **)(v50 - 128));
  if (a49 < 0)
    operator delete(__p);
  if (*(char *)(v49 + 23) < 0)
    operator delete(*(void **)v49);
  _Unwind_Resume(exception_object);
}

std::string *HGMetalUtils::stringForMetalFragmentOutputStruct@<X0>(HGMetalUtils *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int v4;
  int v6;
  BOOL v7;
  std::string *v8;
  __int128 v9;
  std::string *v10;
  std::string::size_type size;
  std::string *v12;
  __int128 v13;
  std::string *v14;
  __int128 v15;
  void **v16;
  std::string::size_type v17;
  std::string v19;
  std::string v20;
  std::string v21;
  void *__p[2];
  int64_t v23;
  std::string v24;

  v4 = this;
  *(_BYTE *)(a3 + 23) = 0;
  *(_BYTE *)a3 = 0;
  std::string::append((std::string *)a3, "struct FragmentOut {\n");
  if (v4)
  {
    v6 = 0;
    while (1)
    {
      if ((v4 & 1) == 0)
        goto LABEL_3;
      std::to_string(&v24, v6);
      std::operator+<char>();
      v8 = std::string::append(&v19, " [[ color(");
      v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v20.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v10 = &v24;
      else
        v10 = (std::string *)v24.__r_.__value_.__r.__words[0];
      if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v24.__r_.__value_.__r.__words[2]);
      else
        size = v24.__r_.__value_.__l.__size_;
      v12 = std::string::append(&v20, (const std::string::value_type *)v10, size);
      v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
      v21.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v13;
      v12->__r_.__value_.__l.__size_ = 0;
      v12->__r_.__value_.__r.__words[2] = 0;
      v12->__r_.__value_.__r.__words[0] = 0;
      v14 = std::string::append(&v21, ") ]];\n");
      v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      v23 = v14->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      if (v23 >= 0)
        v16 = __p;
      else
        v16 = (void **)__p[0];
      if (v23 >= 0)
        v17 = HIBYTE(v23);
      else
        v17 = (std::string::size_type)__p[1];
      std::string::append((std::string *)a3, (const std::string::value_type *)v16, v17);
      if (SHIBYTE(v23) < 0)
      {
        operator delete(__p[0]);
        if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_20:
          if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_21;
          goto LABEL_26;
        }
      }
      else if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_20;
      }
      operator delete(v21.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_21:
        if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_22;
        goto LABEL_27;
      }
LABEL_26:
      operator delete(v20.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_22:
        if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_28;
        goto LABEL_3;
      }
LABEL_27:
      operator delete(v19.__r_.__value_.__l.__data_);
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
LABEL_28:
        operator delete(v24.__r_.__value_.__l.__data_);
LABEL_3:
      ++v6;
      v7 = v4 > 1;
      v4 >>= 1;
      if (!v7)
        goto LABEL_30;
    }
  }
  std::string::append((std::string *)a3, "    float4 color0 [[ color(0) ]];\n");
LABEL_30:
  if (a2)
    std::string::append((std::string *)a3, "    float  depth  [[ depth(any) ]];\n");
  return std::string::append((std::string *)a3, "};\n\n");
}

void sub_1B2A713B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  uint64_t v35;

  if (*(char *)(v35 + 23) < 0)
  {
    operator delete(*(void **)v35);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *HGMetalUtils::blitBufferToTexture(void *a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  void *v7;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int TextureRect;
  uint64_t v27;
  uint64_t v28;
  unint64_t v30;
  int v31;
  _QWORD v32[5];
  _QWORD v33[3];
  _QWORD v34[3];
  uint64_t v35[2];
  int v36;

  v7 = 0;
  if (a2 && a3)
  {
    v36 = 4658;
    kdebug_trace();
    v15 = (void *)objc_msgSend(a1, "commandBuffer");
    objc_msgSend(v15, "setLabel:", CFSTR("HG BufferToTexture blit"));
    v16 = objc_msgSend(v15, "blitCommandEncoder");
    v7 = 0;
    v17 = *(_QWORD *)(a2 + 144);
    if (v17)
    {
      v31 = a6;
      v18 = a3[18];
      if (v18)
      {
        v19 = (void *)v16;
        v20 = HGRectIntersection(*(_QWORD *)(a2 + 20), *(_QWORD *)(a2 + 28), *(_QWORD *)((char *)a3 + 20), *(_QWORD *)((char *)a3 + 28));
        v35[0] = HGRectIntersection(v20, v21, a4, a5);
        v35[1] = v22;
        v30 = HGBitmap::byteOffset((HGBitmap *)a2, v35[0], SHIDWORD(v35[0]));
        v23 = HGFormatUtils::collapseRectForFormat(v35, *(_DWORD *)(a2 + 16));
        v25 = v24;
        TextureRect = HGMetalTexture::GetTextureRect((HGMetalTexture *)a3);
        v27 = HGMetalTexture::GetTextureRect((HGMetalTexture *)a3);
        v28 = *(_QWORD *)(a2 + 64);
        v34[0] = (v25 - v23);
        v34[1] = (HIDWORD(v25) - HIDWORD(v23));
        v34[2] = 1;
        v33[0] = (int)v23 - TextureRect;
        v33[1] = HIDWORD(v23) - HIDWORD(v27);
        v33[2] = 0;
        objc_msgSend(v19, "copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:", v17, v30, v28, 0, v34, v18, 0, 0, v33);
        objc_msgSend(v19, "endEncoding");
        if (a7 && (v31 & 1) == 0)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
          v32[0] = MEMORY[0x1E0C809B0];
          v32[1] = 3221225472;
          v32[2] = ___ZN12HGMetalUtils19blitBufferToTextureE21HGMTLCommandQueueTypeP13HGMetalBufferP14HGMetalTexture6HGRectbb_block_invoke;
          v32[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
          v32[4] = a2;
          objc_msgSend(v15, "addCompletedHandler:", v32);
        }
        objc_msgSend(v15, "commit");
        if (v31)
          objc_msgSend(v15, "waitUntilCompleted");
        else
          objc_msgSend(v15, "waitUntilScheduled");
        v7 = v15;
      }
    }
    kdebug_trace();
  }
  return v7;
}

void sub_1B2A716D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A716EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A71700(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A71714(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A71728(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A7173C(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A71754(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A71768(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A7177C(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

uint64_t ___ZN12HGMetalUtils19blitBufferToTextureE21HGMTLCommandQueueTypeP13HGMetalBufferP14HGMetalTexture6HGRectbb_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
}

void *HGMetalUtils::blitTextureToBuffer(void *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  void *v7;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v27;
  int v28;
  _QWORD v29[5];
  _QWORD v30[3];
  _QWORD v31[3];
  uint64_t v32[2];
  int v33;

  v7 = 0;
  if (a2 && a3)
  {
    v33 = 4660;
    kdebug_trace();
    v15 = (void *)objc_msgSend(a1, "commandBuffer");
    objc_msgSend(v15, "setLabel:", CFSTR("HG TextureToBuffer blit"));
    v16 = objc_msgSend(v15, "blitCommandEncoder");
    v7 = 0;
    v17 = a2[18];
    if (v17)
    {
      v28 = a6;
      v18 = *(_QWORD *)(a3 + 144);
      if (v18)
      {
        v19 = (void *)v16;
        v20 = HGRectIntersection(*(_QWORD *)((char *)a2 + 20), *(_QWORD *)((char *)a2 + 28), *(_QWORD *)(a3 + 20), *(_QWORD *)(a3 + 28));
        v32[0] = HGRectIntersection(v20, v21, a4, a5);
        v32[1] = v22;
        v27 = HGBitmap::byteOffset((HGBitmap *)a3, v32[0], SHIDWORD(v32[0]));
        v23 = HGFormatUtils::collapseRectForFormat(v32, *(_DWORD *)(a3 + 16));
        v25 = v24;
        v31[0] = (int)(v23 - HGMetalTexture::GetTextureRect((HGMetalTexture *)a2));
        v31[1] = (int)(HIDWORD(v23) - ((unint64_t)HGMetalTexture::GetTextureRect((HGMetalTexture *)a2) >> 32));
        v31[2] = 0;
        v30[0] = (v25 - v23);
        v30[1] = (HIDWORD(v25) - HIDWORD(v23));
        v30[2] = 1;
        objc_msgSend(v19, "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:", v17, 0, 0, v31, v30, v18, v27, *(_QWORD *)(a3 + 64), 0);
        objc_msgSend(v19, "endEncoding");
        if (a7 && (v28 & 1) == 0)
        {
          (*(void (**)(_QWORD *))(*a2 + 16))(a2);
          v29[0] = MEMORY[0x1E0C809B0];
          v29[1] = 3221225472;
          v29[2] = ___ZN12HGMetalUtils19blitTextureToBufferE21HGMTLCommandQueueTypeP14HGMetalTextureP13HGMetalBuffer6HGRectbb_block_invoke;
          v29[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
          v29[4] = a2;
          objc_msgSend(v15, "addCompletedHandler:", v29);
        }
        objc_msgSend(v15, "commit");
        if (v28)
          objc_msgSend(v15, "waitUntilCompleted");
        else
          objc_msgSend(v15, "waitUntilScheduled");
        v7 = v15;
      }
    }
    kdebug_trace();
  }
  return v7;
}

void sub_1B2A719D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A719EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A71A00(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A71A14(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A71A28(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A71A3C(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A71A54(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A71A68(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B2A71A7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

uint64_t ___ZN12HGMetalUtils19blitTextureToBufferE21HGMTLCommandQueueTypeP14HGMetalTextureP13HGMetalBuffer6HGRectbb_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
}

void *HGMetalUtils::tiledBlitBufferToTexture(void *a1, uint64_t a2, _QWORD *a3, unint64_t a4, unint64_t a5, int a6, int a7, unint64_t a8)
{
  int v10;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  int v17;
  void *v18;
  void *v19;
  void *__p;
  uint64_t *v22;
  uint64_t v23;

  v10 = HIDWORD(a5);
  __p = 0;
  v22 = 0;
  v23 = 0;
  v14 = (uint64_t *)__p;
  v15 = v22;
  if (__p == v22)
  {
    v19 = 0;
    if (!__p)
      return v19;
    goto LABEL_7;
  }
  do
  {
    v16 = v14[1];
    if (HIDWORD(v16) == v10)
      v17 = a6;
    else
      v17 = 0;
    v18 = HGMetalUtils::blitBufferToTexture(a1, a2, a3, *v14, v16, v17, a7);
    v14 += 2;
  }
  while (v14 != v15);
  v19 = v18;
  v14 = (uint64_t *)__p;
  if (__p)
  {
LABEL_7:
    v22 = v14;
    operator delete(v14);
  }
  return v19;
}

void sub_1B2A71B84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::buildTilesList(uint64_t *a1, unint64_t a2, unint64_t a3, int a4, unint64_t a5)
{
  unint64_t v5;
  unint64_t v6;
  int v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int v12;
  unint64_t v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  BOOL v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t *v24;
  unint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  uint64_t *v32;
  uint64_t v33;
  _QWORD *v34;
  unint64_t v35;
  unint64_t v36;
  int v37;
  unsigned int v38;
  unsigned int v39;

  v5 = a3;
  v6 = a2;
  v8 = 0;
  v9 = HIDWORD(a2);
  v11 = HIDWORD(a3);
  v12 = HIDWORD(a3) - HIDWORD(a2);
  switch(v10)
  {
    case 1:
    case 10:
      v8 = 1;
      break;
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 21:
    case 22:
    case 23:
    case 24:
    case 26:
    case 27:
    case 28:
    case 29:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 56:
    case 57:
    case 58:
    case 59:
    case 61:
    case 62:
    case 63:
    case 64:
    case 66:
    case 67:
    case 68:
    case 69:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 106:
    case 107:
    case 108:
    case 109:
    case 111:
    case 112:
    case 113:
    case 114:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
      break;
    case 20:
    case 25:
    case 30:
      v8 = 2;
      break;
    case 55:
    case 60:
    case 65:
    case 70:
    case 80:
    case 90:
      goto LABEL_2;
    case 105:
    case 110:
    case 115:
      v8 = 8;
      break;
    case 125:
      v8 = 16;
      break;
    default:
      if (v10 == 252)
LABEL_2:
        v8 = 4;
      break;
  }
  v13 = (((HIDWORD(a3) - HIDWORD(a2)) * (a3 - a2) * v8) >> 20) / a5;
  if (v12 >= (int)v13 + 1)
    v14 = v13 + 1;
  else
    v14 = HIDWORD(a3) - HIDWORD(a2);
  v39 = v14;
  if (v14)
  {
    v15 = 0;
    v37 = v12 / v14;
    v38 = v14 - 1;
    v35 = HIDWORD(a3);
    v36 = HIDWORD(a2);
    while (1)
    {
      while (1)
      {
        v16 = v9 + v15 * v37;
        v17 = v15++ == v38;
        v18 = v17 ? v11 : (int)v9 + v15 * v37;
        v19 = HGRectMake4i(v6, v16, v5, v18);
        v21 = v19;
        v22 = v20;
        v24 = (uint64_t *)a1[1];
        v23 = a1[2];
        if ((unint64_t)v24 >= v23)
          break;
        *v24 = v19;
        v24[1] = v20;
        a1[1] = (uint64_t)(v24 + 2);
        if (v15 == v39)
          return;
      }
      v9 = v6;
      v25 = v5;
      v26 = (uint64_t *)*a1;
      v27 = ((uint64_t)v24 - *a1) >> 4;
      v28 = v27 + 1;
      if ((unint64_t)(v27 + 1) >> 60)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v29 = v23 - (_QWORD)v26;
      if (v29 >> 3 > v28)
        v28 = v29 >> 3;
      v30 = (unint64_t)v29 >= 0x7FFFFFFFFFFFFFF0 ? 0xFFFFFFFFFFFFFFFLL : v28;
      if (v30)
        break;
      v31 = 0;
      v32 = (uint64_t *)(16 * v27);
      *v32 = v21;
      v32[1] = v20;
      v33 = 16 * v27;
      v5 = v25;
      if (v24 != v26)
        goto LABEL_30;
LABEL_32:
      v6 = v9;
      v34 = v32 + 2;
      *a1 = v33;
      a1[1] = (uint64_t)(v32 + 2);
      a1[2] = (uint64_t)&v31[16 * v30];
      LODWORD(v9) = v36;
      if (v24)
        operator delete(v24);
      LODWORD(v11) = v35;
      a1[1] = (uint64_t)v34;
      if (v15 == v39)
        return;
    }
    if (v30 >> 60)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v31 = (char *)operator new(16 * v30);
    v32 = (uint64_t *)&v31[16 * v27];
    *v32 = v21;
    v32[1] = v22;
    v33 = (uint64_t)v32;
    v5 = v25;
    if (v24 == v26)
      goto LABEL_32;
    do
    {
LABEL_30:
      *(_OWORD *)(v33 - 16) = *((_OWORD *)v24 - 1);
      v33 -= 16;
      v24 -= 2;
    }
    while (v24 != v26);
    v24 = (uint64_t *)*a1;
    goto LABEL_32;
  }
}

uint64_t **std::__hash_table<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::__unordered_map_hasher<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,HGMetalFunctionCache::InfoHash,std::equal_to<HGMetalFunctionCache::Info>,true>,std::__unordered_map_equal<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::equal_to<HGMetalFunctionCache::Info>,HGMetalFunctionCache::InfoHash,true>,std::allocator<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>>>::find<HGMetalFunctionCache::Info>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v2;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int8x8_t v7;
  uint64_t *v8;
  unint64_t v9;
  uint8x8_t v10;
  uint64_t v11;
  uint64_t ***v12;
  uint64_t **v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  unint64_t v19;
  uint64_t *v20;
  size_t v21;
  uint64_t *v23;
  int v24;
  unint64_t v25;
  uint64_t *v26;
  size_t v27;
  char v30;

  v2 = (_QWORD *)a2;
  v4 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v5 = v4;
  }
  v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v30, (uint64_t *)a2, v5);
  v7 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v7)
    return 0;
  v8 = (uint64_t *)v2[3];
  v9 = ((unint64_t)&v8[8 * v6 - 0xC3910C8D016B07DLL] + (v6 >> 2) - 3) ^ v6;
  v10 = (uint8x8_t)vcnt_s8(v7);
  v10.i16[0] = vaddlv_u8(v10);
  if (v10.u32[0] > 1uLL)
  {
    v11 = ((unint64_t)&v8[8 * v6 - 0xC3910C8D016B07DLL] + (v6 >> 2) - 3) ^ v6;
    if (v9 >= *(_QWORD *)&v7)
      v11 = v9 % *(_QWORD *)&v7;
  }
  else
  {
    v11 = (*(_QWORD *)&v7 - 1) & v9;
  }
  v12 = *(uint64_t ****)(*a1 + 8 * v11);
  if (!v12)
    return 0;
  v13 = *v12;
  if (*v12)
  {
    v14 = *((char *)v2 + 23);
    if (v14 >= 0)
      v15 = *((unsigned __int8 *)v2 + 23);
    else
      v15 = v2[1];
    if (v14 < 0)
      v2 = (_QWORD *)*v2;
    if (v10.u32[0] < 2uLL)
    {
      v16 = *(_QWORD *)&v7 - 1;
      while (1)
      {
        v23 = v13[1];
        if (v23 == (uint64_t *)v9)
        {
          if (v13[5] == v8)
          {
            v24 = *((char *)v13 + 39);
            v25 = v24 >= 0 ? *((unsigned __int8 *)v13 + 39) : (unint64_t)v13[3];
            v26 = v24 >= 0 ? (uint64_t *)(v13 + 2) : v13[2];
            v27 = v15 >= v25 ? v25 : v15;
            if (!memcmp(v26, v2, v27) && v15 == v25)
              return v13;
          }
        }
        else if (((unint64_t)v23 & v16) != v11)
        {
          return 0;
        }
        v13 = (uint64_t **)*v13;
        if (!v13)
          return v13;
      }
    }
    do
    {
      v17 = (unint64_t)v13[1];
      if (v17 == v9)
      {
        if (v13[5] == v8)
        {
          v18 = *((char *)v13 + 39);
          v19 = v18 >= 0 ? *((unsigned __int8 *)v13 + 39) : (unint64_t)v13[3];
          v20 = v18 >= 0 ? (uint64_t *)(v13 + 2) : v13[2];
          v21 = v15 >= v19 ? v19 : v15;
          if (!memcmp(v20, v2, v21) && v15 == v19)
            return v13;
        }
      }
      else
      {
        if (v17 >= *(_QWORD *)&v7)
          v17 %= *(_QWORD *)&v7;
        if (v17 != v11)
          return 0;
      }
      v13 = (uint64_t **)*v13;
    }
    while (v13);
  }
  return v13;
}

uint64_t **std::__hash_table<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::__unordered_map_hasher<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,HGMetalFunctionCache::InfoHash,std::equal_to<HGMetalFunctionCache::Info>,true>,std::__unordered_map_equal<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::equal_to<HGMetalFunctionCache::Info>,HGMetalFunctionCache::InfoHash,true>,std::allocator<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>>>::__emplace_unique_key_args<HGMetalFunctionCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalFunctionCache::Info const&>,std::tuple<>>(uint64_t a1, uint64_t a2, uint64_t a3, __int128 **a4)
{
  uint64_t v4;
  _QWORD *v6;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  uint8x8_t v14;
  uint64_t ***v15;
  uint64_t **v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  unint64_t v21;
  uint64_t *v22;
  size_t v23;
  uint64_t *v25;
  int v26;
  unint64_t v27;
  uint64_t *v28;
  size_t v29;
  _QWORD *v31;
  std::string *v32;
  __int128 *v33;
  __int128 v34;
  float v35;
  float v36;
  _QWORD *v37;
  _QWORD *v38;
  _BOOL8 v39;
  unint64_t v40;
  unint64_t v41;
  size_t prime;
  int8x8_t v43;
  unint64_t v44;
  uint8x8_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  _QWORD v50[2];
  char v51;

  v6 = (_QWORD *)a2;
  v8 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v9 = v8;
  }
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)v50, (uint64_t *)a2, v9);
  v11 = (uint64_t *)v6[3];
  v12 = ((unint64_t)&v11[8 * v10 - 0xC3910C8D016B07DLL] + (v10 >> 2) - 3) ^ v10;
  v13 = *(_QWORD *)(a1 + 8);
  if (v13)
  {
    v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
    v14.i16[0] = vaddlv_u8(v14);
    if (v14.u32[0] > 1uLL)
    {
      v4 = ((unint64_t)&v11[8 * v10 - 0xC3910C8D016B07DLL] + (v10 >> 2) - 3) ^ v10;
      if (v12 >= v13)
        v4 = v12 % v13;
    }
    else
    {
      v4 = (v13 - 1) & v12;
    }
    v15 = *(uint64_t ****)(*(_QWORD *)a1 + 8 * v4);
    if (v15)
    {
      v16 = *v15;
      if (*v15)
      {
        v17 = *((char *)v6 + 23);
        if (v17 >= 0)
          v18 = *((unsigned __int8 *)v6 + 23);
        else
          v18 = v6[1];
        if (v17 < 0)
          v6 = (_QWORD *)*v6;
        if (v14.u32[0] < 2uLL)
        {
          while (1)
          {
            v25 = v16[1];
            if (v25 == (uint64_t *)v12)
            {
              if (v16[5] == v11)
              {
                v26 = *((char *)v16 + 39);
                v27 = v26 >= 0 ? *((unsigned __int8 *)v16 + 39) : (unint64_t)v16[3];
                v28 = v26 >= 0 ? (uint64_t *)(v16 + 2) : v16[2];
                v29 = v18 >= v27 ? v27 : v18;
                if (!memcmp(v28, v6, v29) && v18 == v27)
                  return v16;
              }
            }
            else if (((unint64_t)v25 & (v13 - 1)) != v4)
            {
              goto LABEL_59;
            }
            v16 = (uint64_t **)*v16;
            if (!v16)
              goto LABEL_59;
          }
        }
        do
        {
          v19 = (unint64_t)v16[1];
          if (v19 == v12)
          {
            if (v16[5] == v11)
            {
              v20 = *((char *)v16 + 39);
              v21 = v20 >= 0 ? *((unsigned __int8 *)v16 + 39) : (unint64_t)v16[3];
              v22 = v20 >= 0 ? (uint64_t *)(v16 + 2) : v16[2];
              v23 = v18 >= v21 ? v21 : v18;
              if (!memcmp(v22, v6, v23) && v18 == v21)
                return v16;
            }
          }
          else
          {
            if (v19 >= v13)
              v19 %= v13;
            if (v19 != v4)
              break;
          }
          v16 = (uint64_t **)*v16;
        }
        while (v16);
      }
    }
  }
LABEL_59:
  v31 = operator new(0x38uLL);
  v50[0] = v31;
  v50[1] = a1 + 16;
  v51 = 0;
  *v31 = 0;
  v31[1] = v12;
  v32 = (std::string *)(v31 + 2);
  v33 = *a4;
  if (*((char *)*a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v32, *(const std::string::value_type **)v33, *((_QWORD *)v33 + 1));
  }
  else
  {
    v34 = *v33;
    v31[4] = *((_QWORD *)v33 + 2);
    *(_OWORD *)&v32->__r_.__value_.__l.__data_ = v34;
  }
  v31[5] = *((_QWORD *)v33 + 3);
  v31[6] = 0;
  v51 = 1;
  v35 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v36 = *(float *)(a1 + 32);
  if (!v13 || (float)(v36 * (float)v13) < v35)
  {
    v39 = 1;
    if (v13 >= 3)
      v39 = (v13 & (v13 - 1)) != 0;
    v40 = v39 | (2 * v13);
    v41 = vcvtps_u32_f32(v35 / v36);
    if (v40 <= v41)
      prime = v41;
    else
      prime = v40;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
    }
    v43 = *(int8x8_t *)(a1 + 8);
    if (prime > *(_QWORD *)&v43)
      goto LABEL_76;
    if (prime < *(_QWORD *)&v43)
    {
      v44 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(_QWORD *)&v43 < 3uLL || (v45 = (uint8x8_t)vcnt_s8(v43), v45.i16[0] = vaddlv_u8(v45), v45.u32[0] > 1uLL))
      {
        v44 = std::__next_prime(v44);
      }
      else
      {
        v46 = 1 << -(char)__clz(v44 - 1);
        if (v44 >= 2)
          v44 = v46;
      }
      if (prime <= v44)
        prime = v44;
      if (prime < *(_QWORD *)&v43)
LABEL_76:
        std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__do_rehash<true>(a1, prime);
    }
    v13 = *(_QWORD *)(a1 + 8);
    v47 = v13 - 1;
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v12 >= v13)
      {
        v4 = v12 % v13;
        v37 = *(_QWORD **)(*(_QWORD *)a1 + 8 * (v12 % v13));
        v38 = (_QWORD *)v50[0];
        if (v37)
          goto LABEL_65;
      }
      else
      {
        v4 = v12;
        v37 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
        v38 = (_QWORD *)v50[0];
        if (v37)
          goto LABEL_65;
      }
    }
    else
    {
      v4 = v47 & v12;
      v37 = *(_QWORD **)(*(_QWORD *)a1 + 8 * (v47 & v12));
      v38 = (_QWORD *)v50[0];
      if (v37)
        goto LABEL_65;
    }
LABEL_89:
    *v38 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v50[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v50[0])
    {
      v48 = *(_QWORD *)(*(_QWORD *)v50[0] + 8);
      if ((v13 & (v13 - 1)) != 0)
      {
        if (v48 >= v13)
          v48 %= v13;
      }
      else
      {
        v48 &= v13 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v48) = v50[0];
    }
    goto LABEL_100;
  }
  v37 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  v38 = (_QWORD *)v50[0];
  if (!v37)
    goto LABEL_89;
LABEL_65:
  *v38 = *v37;
  *v37 = v50[0];
LABEL_100:
  v16 = (uint64_t **)v50[0];
  ++*(_QWORD *)(a1 + 24);
  return v16;
}

void sub_1B2A72428(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A7243C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::destroy(uint64_t a1, _QWORD *a2)
{
  void *v4;

  if (a2)
  {
    std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::destroy(a1, a2[1]);
    v4 = (void *)a2[55];
    if (v4)
    {
      a2[56] = v4;
      operator delete(v4);
    }
    operator delete(a2);
  }
}

uint64_t *std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::__emplace_unique_key_args<HGMetalRenderPipelineStateCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalRenderPipelineStateCache::Info const&>,std::tuple<>>(uint64_t a1, int *a2, uint64_t a3, const void **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  uint64_t **v9;
  int *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *result;
  uint64_t *v14;

  v7 = (uint64_t **)(a1 + 8);
  v6 = *(uint64_t **)(a1 + 8);
  if (!v6)
  {
    v9 = (uint64_t **)(a1 + 8);
LABEL_9:
    std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<HGMetalRenderPipelineStateCache::Info const&>,std::tuple<>>(a1, a4, (uint64_t)&v14);
    v11 = v14;
    *v14 = 0;
    v11[1] = 0;
    v11[2] = (uint64_t)v9;
    *v7 = v11;
    v12 = **(_QWORD **)a1;
    if (v12)
    {
      *(_QWORD *)a1 = v12;
      v11 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 8), v11);
    ++*(_QWORD *)(a1 + 16);
    return v14;
  }
  while (1)
  {
    while (1)
    {
      v9 = (uint64_t **)v6;
      v10 = (int *)(v6 + 4);
      if (!HGMetalRenderPipelineStateCache::Info::operator<(a2, (int *)v6 + 8))
        break;
      v6 = *v9;
      v7 = v9;
      if (!*v9)
        goto LABEL_9;
    }
    if (!HGMetalRenderPipelineStateCache::Info::operator<(v10, a2))
      break;
    v7 = v9 + 1;
    v6 = v9[1];
    if (!v6)
      goto LABEL_9;
  }
  result = *v7;
  if (!*v7)
    goto LABEL_9;
  return result;
}

void *std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<HGMetalRenderPipelineStateCache::Info const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, const void **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  void *result;
  _BYTE *v9;
  _BYTE *v10;
  int64_t v11;
  char *v12;
  char *v13;

  v5 = a1 + 8;
  v6 = operator new(0x1D8uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = *a2;
  result = memcpy(v6 + 4, *a2, 0x198uLL);
  v6[56] = 0;
  v6[57] = 0;
  v6[55] = 0;
  v10 = (_BYTE *)v7[51];
  v9 = (_BYTE *)v7[52];
  v11 = v9 - v10;
  if (v9 != v10)
  {
    if (v11 < 0)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v12 = (char *)operator new(v9 - v10);
    v6[55] = v12;
    v6[56] = v12;
    v13 = &v12[8 * (v11 >> 3)];
    v6[57] = v13;
    result = memcpy(v12, v10, v11);
    v6[56] = v13;
  }
  v6[58] = 0;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1B2A72668(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void *v5;

  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v2 + 448) = v5;
    operator delete(v5);
  }
  std::unique_ptr<std::__tree_node<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,void *>>>>::~unique_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::unique_ptr<std::__tree_node<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t a1)
{
  _QWORD *v2;
  void *v3;

  v2 = *(_QWORD **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
    {
      v3 = (void *)v2[55];
      if (v3)
      {
        v2[56] = v3;
        operator delete(v3);
      }
    }
    operator delete(v2);
  }
  return a1;
}

uint64_t *std::__tree<std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>,std::__map_value_compare<HGMetalSamplerStateCache::Info,std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>,std::less<HGMetalSamplerStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>>>::__emplace_unique_key_args<HGMetalSamplerStateCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalSamplerStateCache::Info const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, _OWORD **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unsigned int v16;
  uint64_t *v18;
  _OWORD *v19;
  __int128 v20;
  uint64_t *v21;
  uint64_t *v22;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    v9 = a2[1];
    v10 = a2[2];
    v11 = *((unsigned __int8 *)a2 + 24);
    while (1)
    {
      v12 = v6;
      v13 = v6[4];
      if (v8 < v13)
        goto LABEL_3;
      if (v8 > v13)
        goto LABEL_6;
      v14 = v12[5];
      if (v9 < v14)
        goto LABEL_3;
      if (v9 > v14)
        goto LABEL_6;
      v15 = v12[6];
      if (v10 < v15)
        goto LABEL_3;
      if (v10 > v15)
        goto LABEL_6;
      v16 = *((unsigned __int8 *)v12 + 56);
      if (v11 < v16)
      {
LABEL_3:
        v6 = (uint64_t *)*v12;
        v7 = (uint64_t **)v12;
        if (!*v12)
          goto LABEL_16;
      }
      else
      {
        if (v16 >= v11)
          return v12;
LABEL_6:
        v6 = (uint64_t *)v12[1];
        if (!v6)
        {
          v7 = (uint64_t **)(v12 + 1);
          goto LABEL_16;
        }
      }
    }
  }
  v12 = (uint64_t *)(a1 + 1);
LABEL_16:
  v18 = v12;
  v19 = operator new(0x48uLL);
  v20 = (*a4)[1];
  v19[2] = **a4;
  v19[3] = v20;
  *((_QWORD *)v19 + 8) = 0;
  *(_QWORD *)v19 = 0;
  *((_QWORD *)v19 + 1) = 0;
  *((_QWORD *)v19 + 2) = v18;
  *v7 = (uint64_t *)v19;
  v21 = (uint64_t *)**a1;
  v22 = (uint64_t *)v19;
  if (v21)
  {
    *a1 = v21;
    v22 = *v7;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v22);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return (uint64_t *)v19;
}

void HGMetalFunctionCache::HGMetalFunctionCache(void **a1)
{
  void *v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
    operator delete(v2);
}

void HGMetalFunctionCache::HGMetalFunctionCache(void **__p)
{
  void **v2;

  do
  {
    v2 = (void **)*__p;
    if (*((char *)__p + 39) < 0)
      operator delete(__p[2]);
    operator delete(__p);
    __p = v2;
  }
  while (v2);
}

HGComic *HGComicDesignerInterfaceImplementation::GenerateGraph(HGComicDesignerInterfaceImplementation *this, HGNode *a2)
{
  HGComic *v4;
  HGComicLookupFilterLUTBitmapResourceImplementation *v5;
  void *v6;
  __n128 v7;
  float v8;
  __n128 v9;
  __n128 v10;
  int v11;
  float v12;
  uint64_t v13;
  HGComic *v14;
  HGComic *v15;

  v4 = (HGComic *)HGObject::operator new(0x1A0uLL);
  HGComic::HGComic(v4);
  (*(void (**)(HGComic *, _QWORD, HGNode *))(*(_QWORD *)v4 + 120))(v4, 0, a2);
  v5 = (HGComicLookupFilterLUTBitmapResourceImplementation *)*((_QWORD *)this + 5);
  if (v5 == (HGComicLookupFilterLUTBitmapResourceImplementation *)-1)
  {
    v6 = 0;
  }
  else
  {
    v6 = HGObject::operator new(0x1B0uLL);
    HGComicLookupFilterLUTBitmapResource::HGComicLookupFilterLUTBitmapResource((uint64_t)v6, v5);
  }
  (*(void (**)(HGComic *, uint64_t, void *))(*(_QWORD *)v4 + 120))(v4, 1, v6);
  if (v6)
    (*(void (**)(void *))(*(_QWORD *)v6 + 24))(v6);
  (*(void (**)(HGComic *, _QWORD, float, float, float, float))(*(_QWORD *)v4 + 96))(v4, 0, (float)*((unint64_t *)this + 7), 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, float, float, float))(*(_QWORD *)v4 + 96))(v4, 8, (float)*((uint64_t *)this + 6), 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, float, float, float))(*(_QWORD *)v4 + 96))(v4, 9, (float)*((int *)this + 16), 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, float, float, float))(*(_QWORD *)v4 + 96))(v4, 10, (float)*((int *)this + 20), (float)*((int *)this + 21), (float)*((int *)this + 22), (float)*((int *)this + 23));
  (*(void (**)(HGComic *, uint64_t, double, float, float, float))(*(_QWORD *)v4 + 96))(v4, 11, *((double *)this + 12), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 12))), 0.0, 0.0);
  v8 = 1.0;
  if (*((_BYTE *)this + 104))
    v7.n128_f32[0] = 1.0;
  else
    v7.n128_f32[0] = 0.0;
  (*(void (**)(HGComic *, uint64_t, __n128, float, float, float))(*(_QWORD *)v4 + 96))(v4, 12, v7, 0.0, 0.0, 0.0);
  if (*((_BYTE *)this + 105))
    v9.n128_f32[0] = 1.0;
  else
    v9.n128_f32[0] = 0.0;
  (*(void (**)(HGComic *, uint64_t, __n128, float, float, float))(*(_QWORD *)v4 + 96))(v4, 13, v9, 0.0, 0.0, 0.0);
  if (*((_BYTE *)this + 106))
    v10.n128_f32[0] = 1.0;
  else
    v10.n128_f32[0] = 0.0;
  (*(void (**)(HGComic *, uint64_t, __n128, float, float, float))(*(_QWORD *)v4 + 96))(v4, 14, v10, 0.0, 0.0, 0.0);
  v11 = *((_DWORD *)this + 16);
  if (v11 == 7)
  {
    (*(void (**)(HGComic *, uint64_t, float, float, float, float))(*(_QWORD *)v4 + 96))(v4, 3, 1.0, 0.0, 0.0, 0.0);
    v13 = 4;
    v8 = 0.0005;
  }
  else
  {
    if (v11 == 17)
    {
      v12 = (float)((float)((float)((float)*((uint64_t *)this + 3) * 0.01) / -3.0) + 1.0)
          + ((float)((float)*((uint64_t *)this + 9) * 0.01) + -0.5) * -0.5;
      (*(void (**)(HGComic *, uint64_t, float, float, float, float))(*(_QWORD *)v4 + 96))(v4, 3, fmaxf(fminf(v12, 1.0), 0.0), 0.0, 0.0, 0.0);
      (*(void (**)(HGComic *, uint64_t, float, float, float, float))(*(_QWORD *)v4 + 96))(v4, 4, 0.0, 0.0, 0.0, 0.0);
      goto LABEL_21;
    }
    v13 = 3;
  }
  (*(void (**)(HGComic *, uint64_t, float, float, float, float))(*(_QWORD *)v4 + 96))(v4, v13, v8, 0.0, 0.0, 0.0);
LABEL_21:
  (*(void (**)(HGComic *, uint64_t, float, float, float, float))(*(_QWORD *)v4 + 96))(v4, 3, (float)((float)((float)*((uint64_t *)this + 9) * -0.01) * 0.65) + 1.0, 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, float, float, float))(*(_QWORD *)v4 + 96))(v4, 1, 1.0/ (float)((float)((float)((float)*((uint64_t *)this + 2) * 0.01) + (float)((float)*((uint64_t *)this + 2) * 0.01)) + 1.0), 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, float, float, float))(*(_QWORD *)v4 + 96))(v4, 2, (float)((float)((float)((float)*((uint64_t *)this + 3) * -0.01) + 1.0) * 3.807) + 1.6, 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, float, float, float))(*(_QWORD *)v4 + 96))(v4, 5, (float)((float)((float)*((uint64_t *)this + 4) * 0.01) * 32.0) + 4.8, 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, float, float, float))(*(_QWORD *)v4 + 96))(v4, 6, (float)((float)((float)*((uint64_t *)this + 4) * 0.01) * 6.0) + 2.3406, 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, float, float, float))(*(_QWORD *)v4 + 96))(v4, 7, (float)((float)((float)*((uint64_t *)this + 4) * 0.01) * 12.0) + 4.0, 0.0, 0.0, 0.0);
  v14 = (HGComic *)*((_QWORD *)this + 14);
  v15 = v4;
  if (v14 != v4)
  {
    if (v14)
      (*(void (**)(HGComic *))(*(_QWORD *)v14 + 24))(v14);
    *((_QWORD *)this + 14) = v4;
    (*(void (**)(HGComic *))(*(_QWORD *)v4 + 16))(v4);
    v15 = (HGComic *)*((_QWORD *)this + 14);
  }
  (*(void (**)(HGComic *))(*(_QWORD *)v4 + 24))(v4);
  return v15;
}

void sub_1B2A72DA0(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;

  HGObject::operator delete(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void HGComicDesignerInterface::HGComicDesignerInterface(HGComicDesignerInterface *this)
{
  _QWORD *v2;
  char *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6525740;
  v3 = (char *)HGObject::operator new(0x78uLL);
  HGObject::HGObject((HGObject *)v3);
  *(_QWORD *)v3 = off_1E65259A8;
  *((_QWORD *)v3 + 3) = 0;
  *((_QWORD *)v3 + 4) = 0;
  *((_QWORD *)v3 + 2) = 0;
  *(_OWORD *)(v3 + 40) = xmmword_1B35225B0;
  *((_QWORD *)v3 + 7) = 720;
  *((_DWORD *)v3 + 16) = 0;
  *((_QWORD *)v3 + 9) = 0;
  *((_OWORD *)v3 + 5) = xmmword_1B35225C0;
  __asm { FMOV            V0.2S, #1.0 }
  *((_QWORD *)v3 + 12) = _D0;
  *((_WORD *)v3 + 52) = 256;
  v3[106] = 1;
  *((_QWORD *)v3 + 14) = 0;
  *((_QWORD *)this + 51) = v3;
}

void sub_1B2A72ECC(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A72EE8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGComicDesignerInterface::~HGComicDesignerInterface(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6525740;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6525740;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGComicDesignerInterface::SetParameter(HGComicDesignerInterface *this, int a2, double a3, float a4, float a5, float a6)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v30;

  switch(a2)
  {
    case 0:
      v7 = *((_QWORD *)this + 51);
      if ((float)*(uint64_t *)(v7 + 16) == *(float *)&a3)
        goto LABEL_41;
      *(_QWORD *)(v7 + 16) = (uint64_t)*(float *)&a3;
      result = 1;
      break;
    case 1:
      v9 = *((_QWORD *)this + 51);
      if ((float)*(uint64_t *)(v9 + 24) == *(float *)&a3)
        goto LABEL_41;
      *(_QWORD *)(v9 + 24) = (uint64_t)*(float *)&a3;
      result = 1;
      break;
    case 2:
      v10 = *((_QWORD *)this + 51);
      if ((float)*(uint64_t *)(v10 + 32) == *(float *)&a3)
        goto LABEL_41;
      *(_QWORD *)(v10 + 32) = (uint64_t)*(float *)&a3;
      result = 1;
      break;
    case 3:
      v11 = *((_QWORD *)this + 51);
      if ((float)*(uint64_t *)(v11 + 40) == *(float *)&a3)
        goto LABEL_41;
      *(_QWORD *)(v11 + 40) = (uint64_t)*(float *)&a3;
      result = 1;
      break;
    case 4:
      v12 = *((_QWORD *)this + 51);
      if ((float)*(uint64_t *)(v12 + 48) == *(float *)&a3)
        goto LABEL_41;
      *(_QWORD *)(v12 + 48) = (uint64_t)*(float *)&a3;
      result = 1;
      break;
    case 5:
      v13 = *((_QWORD *)this + 51);
      if ((float)*(unint64_t *)(v13 + 56) == *(float *)&a3)
        goto LABEL_41;
      *(_QWORD *)(v13 + 56) = (unint64_t)*(float *)&a3;
      result = 1;
      break;
    case 6:
      v14 = *((_QWORD *)this + 51);
      if (*(_DWORD *)(v14 + 64) == (int)*(float *)&a3)
        goto LABEL_41;
      *(_DWORD *)(v14 + 64) = (int)*(float *)&a3;
      result = 1;
      break;
    case 7:
      v15 = *((_QWORD *)this + 51);
      if ((float)*(uint64_t *)(v15 + 72) == *(float *)&a3)
        goto LABEL_41;
      *(_QWORD *)(v15 + 72) = (int)*(float *)&a3;
      result = 1;
      break;
    case 8:
      v21 = *((_QWORD *)this + 51);
      v23 = *(_DWORD *)(v21 + 80);
      v22 = *(_DWORD *)(v21 + 84);
      v24 = *(_QWORD *)(v21 + 88);
      v25 = HGRectMake4i((int)*(float *)&a3, (int)a4, (int)a5, (int)a6);
      if ((_DWORD)v25 == v23 && (_DWORD)v26 == (_DWORD)v24 && HIDWORD(v25) == v22 && HIDWORD(v26) == HIDWORD(v24))
        goto LABEL_41;
      v30 = *((_QWORD *)this + 51);
      *(_QWORD *)(v30 + 80) = v25;
      *(_QWORD *)(v30 + 88) = v26;
      result = 1;
      break;
    case 9:
      v16 = *((_QWORD *)this + 51);
      if (COERCE_FLOAT(*(_QWORD *)(v16 + 96)) == *(float *)&a3 && COERCE_FLOAT(HIDWORD(*(_QWORD *)(v16 + 96))) == a4)
        goto LABEL_41;
      *((float *)&a3 + 1) = a4;
      *(double *)(v16 + 96) = a3;
      result = 1;
      break;
    case 10:
      v18 = *((_QWORD *)this + 51);
      if ((*(float *)&a3 == 1.0) == (*(_BYTE *)(v18 + 104) != 0))
        goto LABEL_41;
      *(_BYTE *)(v18 + 104) = *(float *)&a3 == 1.0;
      result = 1;
      break;
    case 11:
      v19 = *((_QWORD *)this + 51);
      if ((*(float *)&a3 == 1.0) == (*(_BYTE *)(v19 + 105) != 0))
        goto LABEL_41;
      *(_BYTE *)(v19 + 105) = *(float *)&a3 == 1.0;
      result = 1;
      break;
    case 12:
      v20 = *((_QWORD *)this + 51);
      if ((*(float *)&a3 == 1.0) == (*(_BYTE *)(v20 + 106) != 0))
      {
LABEL_41:
        result = 0;
      }
      else
      {
        *(_BYTE *)(v20 + 106) = *(float *)&a3 == 1.0;
        result = 1;
      }
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

HGComic *HGComicDesignerInterface::GetOutput(HGComicDesignerInterface *this, HGRenderer *a2)
{
  HGNode *Input;

  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  return HGComicDesignerInterfaceImplementation::GenerateGraph(*((HGComicDesignerInterfaceImplementation **)this + 51), Input);
}

void HGComicDesignerInterfaceImplementation::~HGComicDesignerInterfaceImplementation(HGComicDesignerInterfaceImplementation *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65259A8;
  v2 = *((_QWORD *)this + 14);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGObject::~HGObject(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65259A8;
  v2 = *((_QWORD *)this + 14);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGObject::~HGObject(this);
  HGObject::operator delete(v3);
}

std::string *HGBufferDumper::_updateNodeFilename(HGBufferDumper *this, int a2, const char *a3, int a4, HGRect a5)
{
  uint64_t v5;
  uint64_t v6;
  std::string *v10;
  std::string::value_type *v11;
  std::string::value_type __s[32];
  char __str[8];
  uint64_t v15;

  v5 = *(_QWORD *)&a5.var2;
  v6 = *(_QWORD *)&a5.var0;
  v15 = *MEMORY[0x1E0C80C00];
  snprintf(__str, 8uLL, "%03d", a2);
  v10 = (std::string *)((char *)this + 48);
  MEMORY[0x1B5E28D80](v10, __str);
  std::string::append(v10, ".");
  std::string::append(v10, a3);
  if (a4 == -1)
  {
    v11 = "_out";
  }
  else
  {
    snprintf(__s, 8uLL, "_in%d", a4);
    v11 = __s;
  }
  std::string::append(v10, v11);
  std::string::append(v10, ".");
  snprintf(__s, 0x20uLL, "%dx%d+%d+%d", v5 - v6, HIDWORD(v5) - HIDWORD(v6), v6, HIDWORD(v6));
  return std::string::append(v10, __s);
}

void HGBufferDumper::HGBufferDumper(HGBufferDumper *this)
{
  *(_OWORD *)((char *)this + 60) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 19) = -1;
  *((_BYTE *)this + 80) = 0;
}

void HGBufferDumper::~HGBufferDumper(void **this)
{
  if (*((char *)this + 71) < 0)
  {
    operator delete(this[6]);
    if ((*((char *)this + 47) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 23) & 0x80000000) == 0)
        return;
LABEL_7:
      operator delete(*this);
      return;
    }
  }
  else if ((*((char *)this + 47) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[3]);
  if (*((char *)this + 23) < 0)
    goto LABEL_7;
}

uint64_t HGBufferDumper::setPath(HGBufferDumper *this, const char *a2)
{
  uint64_t result;

  result = MEMORY[0x1B5E28D80](this, a2);
  *((_DWORD *)this + 19) = -1;
  return result;
}

std::string *HGBufferDumper::enable(HGBufferDumper *this, int a2)
{
  std::string *result;
  tm *v5;
  std::string *v6;
  time_t tv_sec;
  char v8;
  timeval v9;
  char __str[16];
  std::string::value_type __s[32];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  result = (std::string *)HGLogger::setLevel((HGLogger *)"bufferdump", (const char *)1);
  if (*((unsigned __int8 *)this + 80) != a2)
  {
    *((_BYTE *)this + 80) = a2;
    *((_QWORD *)this + 9) = 0xFFFFFFFF00000000;
    gettimeofday(&v9, &v8);
    tv_sec = v9.tv_sec;
    v5 = localtime(&tv_sec);
    strftime(__s, 0x20uLL, "%Y%m%d.%H%M%S", v5);
    snprintf(__str, 0x10uLL, "%02d", v9.tv_usec / 10000);
    v6 = (std::string *)((char *)this + 24);
    MEMORY[0x1B5E28D80](v6, "bufferdump.");
    std::string::append(v6, __s);
    return std::string::append(v6, __str);
  }
  return result;
}

std::string *HGBufferDumper::reset(std::string *this)
{
  std::string *v1;
  tm *v2;
  time_t tv_sec;
  char v5;
  timeval v6;
  char __str[16];
  std::string::value_type __s[32];
  uint64_t v9;

  v1 = this;
  v9 = *MEMORY[0x1E0C80C00];
  this[3].__r_.__value_.__r.__words[0] = 0xFFFFFFFF00000000;
  gettimeofday(&v6, &v5);
  tv_sec = v6.tv_sec;
  v2 = localtime(&tv_sec);
  strftime(__s, 0x20uLL, "%Y%m%d.%H%M%S", v2);
  snprintf(__str, 0x10uLL, "%02d", v6.tv_usec / 10000);
  MEMORY[0x1B5E28D80](++v1, "bufferdump.");
  std::string::append(v1, __s);
  return std::string::append(v1, __str);
}

uint64_t HGBufferDumper::on(HGBufferDumper *this)
{
  return *((unsigned __int8 *)this + 80);
}

FILE *HGBufferDumper::write(HGBufferDumper *this, const char *a2, int a3, HGBitmap *a4)
{
  int v8;
  int v9;
  const char *v10;
  char *v11;
  int v12;
  unsigned __int8 v13;
  HGBufferDumper *v14;
  unsigned __int8 v15;
  int v16;
  int v17;
  size_t v18;
  unint64_t v19;
  std::string *p_dst;
  FILE *v21;
  uint64_t v22;
  uint64_t v23;
  HGBufferDumper *v24;
  int v25;
  const std::string::value_type *v26;
  std::string::size_type v27;
  std::string *v28;
  __int128 v29;
  std::string *v30;
  __int128 v31;
  const std::string::value_type *v32;
  char *v33;
  const std::string::value_type *v34;
  int v35;
  const std::string::value_type *v36;
  std::string::size_type v37;
  std::string *v38;
  __int128 v39;
  std::string *v40;
  const char *v41;
  char *v42;
  __int128 v43;
  unsigned __int8 v44;
  unsigned __int8 v45;
  __int128 *v46;
  HGIQA *v47;
  const char *v48;
  char *v49;
  unsigned __int8 v50;
  std::string __dst;
  std::string v53;
  std::string v54;
  std::string v55;
  __int128 v56;
  int64_t v57;

  v8 = *((_DWORD *)this + 19);
  if (v8 == -1)
  {
    if (*((char *)this + 23) < 0)
    {
      v12 = access(*(const char **)this, 0);
      *((_DWORD *)this + 19) = v12 != -1;
      if (v12 != -1)
        goto LABEL_15;
    }
    else
    {
      v9 = access((const char *)this, 0);
      *((_DWORD *)this + 19) = v9 != -1;
      if (v9 != -1)
        goto LABEL_15;
    }
    v13 = atomic_load(HGLogger::_enabled);
    if ((v13 & 1) != 0)
    {
      v14 = this;
      if (*((char *)this + 23) < 0)
        v14 = *(HGBufferDumper **)this;
      HGLogger::log((HGLogger *)"bufferdump", (const char *)1, (HGLogger *)"ERROR - invalid path for buffer dump files : %s\n", v10, v11, v14);
    }
    v15 = atomic_load(HGLogger::_enabled);
    if ((v15 & 1) != 0)
      HGLogger::log((HGLogger *)"bufferdump", (const char *)1, (HGLogger *)"  Use HG_ENV_BUFFER_DUMP_DIR or HGRenderer::SetBufferDumpDir() with a valid directory.\n", v10, v11);
    if (*((_DWORD *)this + 19) != 1)
      return 0;
  }
  else if (v8 != 1)
  {
    return 0;
  }
LABEL_15:
  if (!*((_BYTE *)this + 80))
    return 0;
  v16 = *((_DWORD *)this + 18) + 1;
  *((_DWORD *)this + 18) = v16;
  HGBufferDumper::_updateNodeFilename(this, v16, a2, a3, *(HGRect *)((char *)a4 + 20));
  v17 = *((char *)this + 23);
  if (v17 >= 0)
    v18 = *((unsigned __int8 *)this + 23);
  else
    v18 = *((_QWORD *)this + 1);
  v19 = v18 + 1;
  if (v18 + 1 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (v19 >= 0x17)
  {
    v22 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17)
      v22 = v19 | 7;
    v23 = v22 + 1;
    p_dst = (std::string *)operator new(v22 + 1);
    __dst.__r_.__value_.__l.__size_ = v18 + 1;
    __dst.__r_.__value_.__r.__words[2] = v23 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v18 + 1;
    if (!v18)
      goto LABEL_31;
  }
  if (v17 >= 0)
    v24 = this;
  else
    v24 = *(HGBufferDumper **)this;
  memmove(p_dst, v24, v18);
LABEL_31:
  *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v18) = 47;
  v25 = *((char *)this + 47);
  if (v25 >= 0)
    v26 = (char *)this + 24;
  else
    v26 = (const std::string::value_type *)*((_QWORD *)this + 3);
  if (v25 >= 0)
    v27 = *((unsigned __int8 *)this + 47);
  else
    v27 = *((_QWORD *)this + 4);
  v28 = std::string::append(&__dst, v26, v27);
  v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v29;
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  v30 = std::string::append(&v53, ".");
  v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
  v54.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v31;
  v30->__r_.__value_.__l.__size_ = 0;
  v30->__r_.__value_.__r.__words[2] = 0;
  v30->__r_.__value_.__r.__words[0] = 0;
  v34 = (const std::string::value_type *)*((_QWORD *)this + 6);
  v33 = (char *)this + 48;
  v32 = v34;
  v35 = v33[23];
  if (v35 >= 0)
    v36 = v33;
  else
    v36 = v32;
  if (v35 >= 0)
    v37 = v33[23];
  else
    v37 = *((_QWORD *)v33 + 1);
  v38 = std::string::append(&v54, v36, v37);
  v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
  v55.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v39;
  v38->__r_.__value_.__l.__size_ = 0;
  v38->__r_.__value_.__r.__words[2] = 0;
  v38->__r_.__value_.__r.__words[0] = 0;
  v40 = std::string::append(&v55, ".iqa");
  v43 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
  v57 = v40->__r_.__value_.__r.__words[2];
  v56 = v43;
  v40->__r_.__value_.__l.__size_ = 0;
  v40->__r_.__value_.__r.__words[2] = 0;
  v40->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v55.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_45:
      if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_46;
      goto LABEL_51;
    }
  }
  else if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_45;
  }
  operator delete(v54.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_46:
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_47;
    goto LABEL_52;
  }
LABEL_51:
  operator delete(v53.__r_.__value_.__l.__data_);
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_47:
    v44 = atomic_load(HGLogger::_enabled);
    if ((v44 & 1) == 0)
      goto LABEL_56;
LABEL_53:
    v46 = &v56;
    if (v57 < 0)
      v46 = (__int128 *)v56;
    HGLogger::log((HGLogger *)"bufferdump", (const char *)1, (HGLogger *)"dumping buffered bitmap to disk : %s\n", v41, v42, v46);
    goto LABEL_56;
  }
LABEL_52:
  operator delete(__dst.__r_.__value_.__l.__data_);
  v45 = atomic_load(HGLogger::_enabled);
  if ((v45 & 1) != 0)
    goto LABEL_53;
LABEL_56:
  if (v57 >= 0)
    v47 = (HGIQA *)&v56;
  else
    v47 = (HGIQA *)v56;
  v21 = HGIQA::WriteBitmap(v47, (const char *)a4, 0);
  if ((v21 & 1) == 0)
  {
    v50 = atomic_load(HGLogger::_enabled);
    if ((v50 & 1) != 0)
      HGLogger::log((HGLogger *)"bufferdump", (const char *)1, (HGLogger *)"ERROR writing buffer dump.\n", v48, v49);
  }
  if (SHIBYTE(v57) < 0)
    operator delete((void *)v56);
  return v21;
}

void sub_1B2A73B18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  uint64_t v35;

  if (*(char *)(v35 - 73) < 0)
    operator delete(*(void **)(v35 - 96));
  _Unwind_Resume(exception_object);
}

void HGPBOBitmap::HGPBOBitmap(HGPBOBitmap *this, HGPixelBufferObj *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t DataPtr;
  unsigned int v9;

  v4 = HGPixelBufferObj::rect(a2);
  v6 = v5;
  v7 = HGPixelBufferObj::format(a2);
  DataPtr = HGPixelBufferObj::GetDataPtr(a2);
  v9 = HGPixelBufferObj::rowBytes(a2);
  HGBitmap::HGBitmap((uint64_t)this, v4, v6, v7, DataPtr, v9);
  *(_QWORD *)this = off_1E65259F8;
  *((_QWORD *)this + 16) = a2;
  (*(void (**)(HGPixelBufferObj *))(*(_QWORD *)a2 + 16))(a2);
}

void sub_1B2A73C68(_Unwind_Exception *a1, void *a2)
{
  HGBitmap *v2;

  HGBitmap::~HGBitmap(v2, a2);
  _Unwind_Resume(a1);
}

void HGPBOBitmap::~HGPBOBitmap(HGPBOBitmap *this)
{
  void *v2;

  *(_QWORD *)this = off_1E65259F8;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 16) + 24))(*((_QWORD *)this + 16));
  HGBitmap::~HGBitmap((HGBitmap *)this, v2);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = off_1E65259F8;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 16) + 24))(*((_QWORD *)this + 16));
  HGBitmap::~HGBitmap((HGBitmap *)this, v2);
  HGObject::operator delete(v3);
}

void HGPBOBitmap::ReadTile(HGPBOBitmap *this, char *a2, HGRect a3, int a4)
{
  uint64_t v5;
  uint64_t v6;
  const char *v9;
  char *v10;
  HGRect v11;

  v5 = *(_QWORD *)&a3.var2;
  v6 = *(_QWORD *)&a3.var0;
  if (HGPixelBufferObj::GetDataPtr(*((HGPixelBufferObj **)this + 16)))
  {
    *(_QWORD *)&v11.var0 = v6;
    *(_QWORD *)&v11.var2 = v5;
    HGBitmap::ReadTile((HGBitmap *)this, a2, v11, a4);
  }
  else
  {
    HGLogger::warning((HGLogger *)"reading tile from unmapped PBO", v9, v10);
  }
}

const char *HGPBOBitmap::WriteTile(HGPBOBitmap *this, const char *a2, HGRect a3)
{
  return HGLogger::warning((HGLogger *)"writing tile into PBO bitmap -- undefined!!", a2, *(char **)&a3.var0, *(_QWORD *)&a3.var2);
}

HGObject *HGCVGLTextureFactory::HGCVGLTextureFactory(HGObject *a1, PC_Sp_counted_base **a2, float a3)
{
  _QWORD *v6;
  HGGLContext **v7;
  CVOpenGLESTextureCacheRef *v8;
  HGGLContext *v9;
  HGGLContext *v10;
  CFNumberRef v11;
  void *v12;
  const __CFDictionary *v13;
  EAGLContext *v14;
  uint64_t v15;
  const char *v16;
  char *v17;
  unsigned __int8 v18;
  float valuePtr;
  PCSharedCount v21;
  _BYTE v22[16];
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  HGObject::HGObject(a1);
  *v6 = off_1E6525A78;
  v6[2] = 0;
  v7 = (HGGLContext **)(v6 + 2);
  v6[3] = 0;
  v8 = (CVOpenGLESTextureCacheRef *)(v6 + 3);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v22, "hgcv", 1, "CVOpenGLESTextureCacheCreate");
  v21.var0 = *a2;
  HGGLContext::Create((uint64_t *)&v21, (HGObject **)keys);
  v9 = *v7;
  v10 = (HGGLContext *)keys[0];
  if (*v7 == keys[0])
  {
    if (v9)
      (*(void (**)(HGGLContext *))(*(_QWORD *)v9 + 24))(v9);
  }
  else
  {
    if (v9)
    {
      (*(void (**)(HGGLContext *))(*(_QWORD *)v9 + 24))(v9);
      v10 = (HGGLContext *)keys[0];
    }
    *v7 = v10;
    keys[0] = 0;
  }
  PCSharedCount::PCSharedCount(&v21);
  valuePtr = a3;
  v11 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  v12 = (void *)*MEMORY[0x1E0CA8F60];
  values = v11;
  keys[0] = v12;
  v13 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v14 = (EAGLContext *)HGGLContext::ptr(*v7);
  v15 = CVOpenGLESTextureCacheCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v13, v14, 0, v8);
  CFRelease(v11);
  CFRelease(v13);
  if ((_DWORD)v15)
  {
    v18 = atomic_load(HGLogger::_enabled);
    if ((v18 & 1) != 0)
      HGLogger::log((HGLogger *)"hgcv", (const char *)1, (HGLogger *)" **** CVOpenGLESTextureCacheCreate() error! booo! (%d)\n", v16, v17, v15);
    *v8 = 0;
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v22);
  return a1;
}

void sub_1B2A73F58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void HGCVGLTextureFactory::~HGCVGLTextureFactory(HGCVGLTextureFactory *this)
{
  const void *v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E6525A78;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  v3 = *((_QWORD *)this + 2);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGObject::~HGObject(this);
}

{
  const void *v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_1E6525A78;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  v3 = *((_QWORD *)this + 2);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGObject::~HGObject(this);
  HGObject::operator delete(v4);
}

void HGCVGLTextureFactory::_createTexture(uint64_t a1@<X0>, HGCVBitmap **a2@<X1>, HGBitmap **a3@<X8>)
{
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  GLint v11;
  GLenum format;
  GLenum v13;
  uint64_t v14;
  const char *v15;
  char *v16;
  unsigned __int8 v17;
  uint64_t Target;
  uint64_t Name;
  const char *v20;
  char *v21;
  unsigned int v22;
  unsigned __int8 v23;
  HGCVBitmap *v24;
  HGCVBufferPairStorage *v25;
  HGCVBitmap *v26;
  HGBitmap *v27;
  HGBitmap *v28;
  HGBitmap **v29;
  CVOpenGLESTextureRef image;
  PCSharedCount v31;
  _BYTE v32[16];

  *a3 = 0;
  if (HGGLContext::ptr(*(HGGLContext **)(a1 + 16)) && *(_QWORD *)(a1 + 24))
  {
    HGGLContext::context((uint64_t *)&v31, *(HGGLContext **)(a1 + 16));
    HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v32, &v31.var0);
    PCSharedCount::PCSharedCount(&v31);
    v6 = *((_QWORD *)*a2 + 16);
    v29 = a3;
    image = 0;
    kdebug_trace();
    HGGLContext::isES2(*(HGGLContext **)(a1 + 16));
    v8 = *((_DWORD *)*a2 + 7);
    v7 = *((_DWORD *)*a2 + 8);
    v9 = *((_DWORD *)*a2 + 5);
    v10 = *((_DWORD *)*a2 + 6);
    v11 = HGFormatUtils::toGLInternalFormat(*((_DWORD *)*a2 + 4));
    format = HGFormatUtils::toGLFormat(*((_DWORD *)*a2 + 4));
    v13 = HGFormatUtils::toGLType(*((_DWORD *)*a2 + 4));
    v14 = CVOpenGLESTextureCacheCreateTextureFromImage((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CVOpenGLESTextureCacheRef *)(a1 + 24), *(CVImageBufferRef *)(v6 + 24), 0, 0xDE1u, v11, v8 - v9, v7 - v10, format, v13, *((_QWORD *)*a2 + 17), &image);
    kdebug_trace();
    if ((_DWORD)v14)
    {
      v17 = atomic_load(HGLogger::_enabled);
      if ((v17 & 1) != 0)
        HGLogger::log((HGLogger *)"hgcv", (const char *)1, (HGLogger *)" **** CVOpenGLESTextureCacheCreateTextureFromImage() error! booo! (%d)\n", v15, v16, v14);
    }
    else
    {
      Target = CVOpenGLESTextureGetTarget(image);
      Name = CVOpenGLESTextureGetName(image);
      v22 = Name;
      v23 = atomic_load(HGLogger::_enabled);
      if ((v23 & 1) != 0)
        HGLogger::log((HGLogger *)"hgcv", (const char *)1, (HGLogger *)"created CVGLES texture (%d, %d) for pixelbuffer (%p)\n", v20, v21, Target, Name, *(_QWORD *)(v6 + 24));
      v24 = *a2;
      v25 = (HGCVBufferPairStorage *)HGObject::operator new(0x20uLL);
      HGCVBufferPairStorage::HGCVBufferPairStorage(v25, v24, image);
      v26 = *a2;
      v27 = (HGBitmap *)HGObject::operator new(0xC8uLL);
      HGGLTexture::HGGLTexture((uint64_t)v27, *(_QWORD *)((char *)v26 + 20), *(_QWORD *)((char *)v26 + 28), *((_DWORD *)v26 + 4), 0, Target, v22, 0);
      v28 = *v29;
      if (*v29 == v27)
      {
        if (v27)
          (*(void (**)(HGBitmap *))(*(_QWORD *)v27 + 24))(v27);
      }
      else
      {
        if (v28)
          (*(void (**)(HGBitmap *))(*(_QWORD *)v28 + 24))(v28);
        *v29 = v27;
      }
      *((_DWORD *)v27 + 3) |= 1u;
      HGBitmap::SetStorage(v27, v25);
      CFRelease(image);
      if (v25)
        (*(void (**)(HGCVBufferPairStorage *))(*(_QWORD *)v25 + 24))(v25);
    }
    HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v32);
  }
}

void sub_1B2A74330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, _QWORD *a12, uint64_t a13, PCSharedCount a14, char a15)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = v15;
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)&a15);
  if (*a12)
    (*(void (**)(_QWORD))(*(_QWORD *)*a12 + 24))(*a12);
  _Unwind_Resume(a1);
}

void HGCVGLTextureFactory::flush(CVOpenGLESTextureCacheRef *this)
{
  CVOpenGLESTextureCacheFlush(this[3], 0);
}

HGObject *HGGPUReadbackJob::HGGPUReadbackJob(HGObject *a1, uint64_t *a2, PC_Sp_counted_base **a3, uint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  HGObject *v16;
  HGObject *v17;
  PCSharedCount v19;
  HGObject *v20;

  HGObject::HGObject(a1);
  *v8 = off_1E6525AC8;
  v8[2] = 0;
  v8[3] = 0;
  v8[4] = 0;
  v10 = *a2;
  v9 = a2[1];
  if (v9)
  {
    v11 = (unint64_t *)(v9 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
    v13 = (std::__shared_weak_count *)*((_QWORD *)a1 + 3);
    *((_QWORD *)a1 + 2) = v10;
    *((_QWORD *)a1 + 3) = v9;
    if (v13)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        v15 = __ldaxr(p_shared_owners);
      while (__stlxr(v15 - 1, p_shared_owners));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }
  else
  {
    *((_QWORD *)a1 + 2) = v10;
    *((_QWORD *)a1 + 3) = 0;
  }
  v19.var0 = *a3;
  HGGLContext::Share((uint64_t *)&v19, &v20);
  v16 = (HGObject *)*((_QWORD *)a1 + 4);
  v17 = v20;
  if (v16 == v20)
  {
    if (v16)
      (*(void (**)(HGObject *))(*(_QWORD *)v16 + 24))(v16);
  }
  else
  {
    if (v16)
    {
      (*(void (**)(HGObject *))(*(_QWORD *)v16 + 24))(v16);
      v17 = v20;
    }
    *((_QWORD *)a1 + 4) = v17;
    v20 = 0;
  }
  PCSharedCount::PCSharedCount(&v19);
  *((_QWORD *)a1 + 5) = a4;
  (*(void (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  return a1;
}

void sub_1B2A7454C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  HGObject *v10;
  uint64_t v11;
  uint64_t v13;

  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  PCSharedCount::PCSharedCount((PCSharedCount *)&a9);
  v13 = *((_QWORD *)v10 + 4);
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v11);
  HGObject::~HGObject(v10);
  _Unwind_Resume(a1);
}

void HGGPUReadbackJob::~HGGPUReadbackJob(HGGPUReadbackJob *this)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  *(_QWORD *)this = off_1E6525AC8;
  v2 = *((_QWORD *)this + 5);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 4);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (!v4)
    goto LABEL_9;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    HGObject::~HGObject(this);
  }
  else
  {
LABEL_9:
    HGObject::~HGObject(this);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  void *v7;

  *(_QWORD *)this = off_1E6525AC8;
  v2 = *((_QWORD *)this + 5);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 4);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (!v4)
    goto LABEL_9;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    HGObject::~HGObject(this);
  }
  else
  {
LABEL_9:
    HGObject::~HGObject(this);
  }
  HGObject::operator delete(v7);
}

uint64_t HGGPUReadbackExecUnit::HGGPUReadbackExecUnit(uint64_t a1, uint64_t *a2, PC_Sp_counted_base **a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  HGObject *v14;
  HGObject *v15;
  const HGMetalDeviceInfo *DeviceInfo;
  HGMetalContext *v17;
  PCSharedCount v19;
  HGObject *v20;

  *(_QWORD *)a1 = &off_1E6525B00;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  v8 = *a2;
  v7 = a2[1];
  if (v7)
  {
    v9 = (unint64_t *)(v7 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    v11 = *(std::__shared_weak_count **)(a1 + 24);
    *(_QWORD *)(a1 + 16) = v8;
    *(_QWORD *)(a1 + 24) = v7;
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }
  else
  {
    *(_QWORD *)(a1 + 16) = v8;
    *(_QWORD *)(a1 + 24) = 0;
  }
  *(_DWORD *)(a1 + 12) = 0;
  v19.var0 = *a3;
  HGGLContext::Share((uint64_t *)&v19, &v20);
  v14 = *(HGObject **)(a1 + 48);
  v15 = v20;
  if (v14 == v20)
  {
    if (v14)
      (*(void (**)(HGObject *))(*(_QWORD *)v14 + 24))(v14);
  }
  else
  {
    if (v14)
    {
      (*(void (**)(HGObject *))(*(_QWORD *)v14 + 24))(v14);
      v15 = v20;
    }
    *(_QWORD *)(a1 + 48) = v15;
    v20 = 0;
  }
  PCSharedCount::PCSharedCount(&v19);
  *(_QWORD *)(a1 + 56) = a4;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  DeviceInfo = (const HGMetalDeviceInfo *)HGMetalDeviceInfo::getDeviceInfo(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 120));
  v17 = (HGMetalContext *)HGObject::operator new(0x68uLL);
  HGMetalContext::HGMetalContext(v17, DeviceInfo);
  *(_QWORD *)(a1 + 32) = v17;
  return a1;
}

void sub_1B2A7485C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;

  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  PCSharedCount::PCSharedCount((PCSharedCount *)&a9);
  v13 = *(_QWORD *)(v11 + 48);
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v10);
  _Unwind_Resume(a1);
}

void HGGPUReadbackExecUnit::~HGGPUReadbackExecUnit(HGGPUReadbackExecUnit *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  *(_QWORD *)this = &off_1E6525B00;
  v2 = *((_QWORD *)this + 8);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 4);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = *((_QWORD *)this + 5);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *((_QWORD *)this + 6);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

{
  HGGPUReadbackExecUnit::~HGGPUReadbackExecUnit(this);
  JUMPOUT(0x1B5E29170);
}

HGGPUReadbackExecUnit *StartGPUReadbackExecUnitFunc(HGGPUReadbackExecUnit *a1)
{
  HGGPUReadbackExecUnit::RunLoop(a1);
  return a1;
}

BOOL HGGPUReadbackExecUnit::RunLoop(HGGPUReadbackExecUnit *this)
{
  int VirtualScreen;
  _BOOL8 result;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  HGBitmap *v9;
  uint64_t v10;
  int v11;
  char *CVBitmapStorage;
  uint64_t v13;
  HGMetalTexture *MetalStorage;
  id *v15;
  HGBitmap *v16;
  id *MetalContext;
  HGTiming *v18;
  double v19;
  dispatch_group_t *v20;
  HGRenderJob *v21;
  int v22;
  int v23;
  uint64_t v24;
  HGGLContext *v25;
  int v26;
  dispatch_group_t *v27;
  char v28;
  HGGPUReadbackJob *v29;
  id v30;
  char __str[512];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  VirtualScreen = HGGLContext::getVirtualScreen(*((HGGLContext **)this + 6));
  snprintf(__str, 0x200uLL, "com.apple.helium.rq.rbu%d.vs%d", *((_DWORD *)this + 2), VirtualScreen);
  pthread_setname_np(__str);
  result = HGRenderQueue::IsShuttingDown(*((HGRenderQueue **)this + 7));
  if (!result)
  {
    while (1)
    {
      HGAutoReleasePoolScopeGuard::HGAutoReleasePoolScopeGuard((HGAutoReleasePoolScopeGuard *)&v30);
      v29 = 0;
      if (HGRenderQueue::GetGPUReadbackJob(*((HGRenderQueue **)this + 7), (HGGLContext **)this, &v29))
        break;
LABEL_64:
      HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard(&v30);
      result = HGRenderQueue::IsShuttingDown(*((HGRenderQueue **)this + 7));
      if (result)
        goto LABEL_65;
    }
    *((_DWORD *)this + 3) = 2;
    v4 = *((_QWORD *)v29 + 5);
    v5 = mach_absolute_time();
    v6 = *(_DWORD *)(*(_QWORD *)(v4 + 24) + 12);
    if ((v6 & 1) != 0)
    {
      v8 = 6;
      if (*(_DWORD *)(v4 + 56) != 5)
        goto LABEL_14;
    }
    else
    {
      if ((v6 & 0x10) != 0)
        v7 = 3;
      else
        v7 = 5;
      if ((v6 & 0x20) != 0)
        v8 = 5;
      else
        v8 = v7;
      if (*(_DWORD *)(v4 + 56) != 5)
        goto LABEL_14;
    }
    if (!*(_DWORD *)(v4 + 60))
    {
      *(_DWORD *)(v4 + 60) = v8;
      if ((*(_BYTE *)(*((_QWORD *)this + 7) + 70) & 2) == 0)
        goto LABEL_22;
      goto LABEL_15;
    }
LABEL_14:
    if ((*(_BYTE *)(*((_QWORD *)this + 7) + 70) & 2) == 0)
      goto LABEL_22;
LABEL_15:
    if (v8 == 3)
    {
      printf("Executing GPU-to-PBO Buffer Copy Job <%p>:    %llu   GL Texture\n");
    }
    else if (v8 == 5)
    {
      printf("Executing GPU-to-CPU Buffer Copy Job <%p>:    %llu   Metal Texture\n");
    }
    else
    {
      printf("Executing GPU-to-CPU Buffer Copy Job <%p>:    %llu   IOSurface\n");
    }
LABEL_22:
    kdebug_trace();
    v10 = *(_QWORD *)(v4 + 24);
    v11 = *(_DWORD *)(v10 + 12);
    if ((v11 & 1) != 0)
    {
      CVBitmapStorage = (char *)HGCVBitmap::getCVBitmapStorage((HGBitmap *)v10, v9);
      HGCVBitmap::lock((HGCVBitmap *)CVBitmapStorage, 0);
      HGCVBitmap::unlock((HGCVBitmap *)CVBitmapStorage, 0);
      (*(void (**)(char *))(*(_QWORD *)CVBitmapStorage + 16))(CVBitmapStorage);
      v13 = *(_QWORD *)(v4 + 24);
      if ((*(_BYTE *)(v13 + 12) & 0x10) != 0)
        HGRenderQueue::EnqueueDeleteHGGLTexture(*((HGRenderQueue **)this + 7), (HGGLTexture *)v13);
      else
        (*(void (**)(_QWORD))(*(_QWORD *)v13 + 24))(*(_QWORD *)(v4 + 24));
      if (*(_DWORD *)(v4 + 60) == 1)
      {
        v16 = (HGBitmap *)HGObject::operator new(0x80uLL);
        HGBitmap::HGBitmap(v16, *(_QWORD *)(CVBitmapStorage + 20), *(_QWORD *)(CVBitmapStorage + 28), *((unsigned int *)CVBitmapStorage + 4));
        HGCVBitmap::lock((HGCVBitmap *)CVBitmapStorage, 1uLL);
        HGRenderUtils::BufferCopier::BufferCopier((HGRenderUtils::BufferCopier *)&v27);
        HGRenderUtils::BufferCopier::execute(&v27, v16, (HGBitmap *)CVBitmapStorage);
        HGCVBitmap::unlock((HGCVBitmap *)CVBitmapStorage, 1uLL);
        (*(void (**)(char *))(*(_QWORD *)CVBitmapStorage + 24))(CVBitmapStorage);
        *(_QWORD *)(v4 + 24) = v16;
        HGRenderUtils::BufferCopier::~BufferCopier((HGRenderUtils::BufferCopier *)&v27);
LABEL_36:
        *(_DWORD *)(v4 + 64) = 1;
        goto LABEL_37;
      }
    }
    else
    {
      if ((v11 & 0x20) == 0)
      {
        if ((v11 & 0x10) != 0)
          HGGPUReadbackExecUnit::ExecutePBOReadback(this, v29);
LABEL_37:
        v18 = (HGTiming *)mach_absolute_time();
        v19 = HGTiming::GetMachTimeConversionFactor(v18) * (double)((unint64_t)v18 - v5);
        *(double *)(v4 + 104) = v19 + *(double *)(v4 + 104);
        *(double *)(v4 + 112) = v19;
        v20 = *(dispatch_group_t **)(*((_QWORD *)this + 7) + 584);
        v27 = v20;
        v28 = 0;
        HGSynchronizable::Lock((HGSynchronizable *)v20);
        std::list<HGGPUReadbackJob *>::remove((_QWORD *)(*((_QWORD *)this + 7) + 592), &v29);
        HGSynchronizable::Unlock((HGSynchronizable *)v20);
        kdebug_trace();
        if ((*(_BYTE *)(*((_QWORD *)this + 7) + 70) & 2) != 0)
        {
          if (v8 == 3)
          {
            printf("Completed GPU-to-PBO Buffer Copy Job <%p>: GLTexture     :  %llu  ");
          }
          else if (v8 == 5)
          {
            printf("Completed GPU-to-CPU Buffer Copy Job <%p>: MTLTexture    :  %llu  ");
          }
          else if (*(_DWORD *)(*(_QWORD *)(v4 + 192) + 100) == 1)
          {
            printf("Completed GPU-to-CPU Buffer Copy Job <%p>: GL-IOSurface  :  %llu  ");
          }
          else
          {
            printf("Completed GPU-to-CPU Buffer Copy Job <%p>: MTL-IOSurface :  %llu  ");
          }
          printf("%5.1f ms\n", *(double *)(v4 + 112) * 1000.0);
        }
        if (*(_DWORD *)(v4 + 56) != 5)
        {
          *(_DWORD *)(v4 + 56) = 9;
          HGRenderNode::CallNotifyFunc((const char *)v4);
          HGRenderNode::NotifyRenderJobFinished((HGRenderJob **)v4);
LABEL_63:
          (*(void (**)(HGGPUReadbackJob *))(*(_QWORD *)v29 + 24))(v29);
          *((_DWORD *)this + 3) = 1;
          goto LABEL_64;
        }
        v21 = (HGRenderJob *)HGObject::operator new(0x160uLL);
        HGRenderJob::HGRenderJob(v21);
        HGRenderJob::AddRenderNodeInternal(v21, (HGRenderNode *)v4);
        HGUserJob::SetPriority((uint64_t)v21, 2);
        HGUserJob::SetState((uint64_t)v21, 2);
        HGRenderJob::SetPriority((uint64_t)v21, 11);
        v22 = *(_DWORD *)(v4 + 60);
        switch(v22)
        {
          case 3:
            v23 = 1;
            break;
          case 5:
            v23 = 2;
            break;
          case 6:
            v23 = 0;
            break;
          default:
            goto LABEL_55;
        }
        HGRenderJob::SetGPUGraphicsAPI((uint64_t)v21, v23);
LABEL_55:
        v24 = *(_QWORD *)(v4 + 72);
        if (v24 && *(_DWORD *)(v24 + 8) == 1)
        {
          HGRenderJob::SetComputeDevice((uint64_t)v21, (uint64_t *)(v4 + 72));
        }
        else
        {
          v25 = *(HGGLContext **)(v4 + 88);
          if (v25)
          {
            v26 = HGGLContext::getVirtualScreen(v25);
            HGRenderJob::SetVirtualScreen(v21, v26);
          }
        }
        HGRenderNode::CallNotifyFunc((const char *)v4);
        if (HGRenderQueue::EnqueueRenderJob(*((HGRenderQueue **)this + 7), v21))
        {
          *(_DWORD *)(v4 + 56) = -997;
          HGRenderNode::CallNotifyFunc((const char *)v4);
          HGRenderNode::NotifyRenderJobFinished((HGRenderJob **)v4);
        }
        (*(void (**)(HGRenderJob *))(*(_QWORD *)v21 + 24))(v21);
        goto LABEL_63;
      }
      MetalStorage = (HGMetalTexture *)HGMetalTexture::getMetalStorage((HGBitmap *)v10, v9);
      CVBitmapStorage = (char *)HGObject::operator new(0x80uLL);
      HGBitmap::HGBitmap(CVBitmapStorage, *(_QWORD *)(*(_QWORD *)(v4 + 24) + 20), *(_QWORD *)(*(_QWORD *)(v4 + 24) + 28), *(unsigned int *)(*(_QWORD *)(v4 + 24) + 16));
      v15 = (id *)*((_QWORD *)this + 4);
      if (v15)
      {
        HGMetalTexture::CopyTexture(MetalStorage, v15, (HGBitmap *)CVBitmapStorage, *(HGRect *)(CVBitmapStorage + 20));
      }
      else
      {
        MetalContext = (id *)HGGPURenderer::GetMetalContext(*(HGGPURenderer **)(v4 + 184));
        HGMetalTexture::CopyTexture(MetalStorage, MetalContext, (HGBitmap *)CVBitmapStorage, *(HGRect *)(CVBitmapStorage + 20));
      }
      (*(void (**)(_QWORD))(**(_QWORD **)(v4 + 24) + 24))(*(_QWORD *)(v4 + 24));
    }
    *(_QWORD *)(v4 + 24) = CVBitmapStorage;
    goto LABEL_36;
  }
LABEL_65:
  *((_DWORD *)this + 3) = 3;
  return result;
}

void sub_1B2A74F78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A74F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A74FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14)
{
  void *v14;

  HGObject::operator delete(v14);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard(&a14);
  _Unwind_Resume(a1);
}

void sub_1B2A74FBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A74FD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14)
{
  void *v14;

  HGObject::operator delete(v14);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard(&a14);
  _Unwind_Resume(a1);
}

void sub_1B2A74FEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A75000(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A75014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14)
{
  void *v14;

  HGObject::operator delete(v14);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard(&a14);
  _Unwind_Resume(a1);
}

void sub_1B2A75030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A75044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A75058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  HGRenderUtils::BufferCopier::~BufferCopier((HGRenderUtils::BufferCopier *)va);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va1);
  _Unwind_Resume(a1);
}

void sub_1B2A75074(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, char a14)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void sub_1B2A750FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B2A75110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPUReadbackExecUnit::StartRunLoop(HGGPUReadbackExecUnit *this)
{
  pthread_t *v1;
  uint64_t v2;
  pthread_attr_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v1 = (pthread_t *)((char *)this + 80);
  if (*((_QWORD *)this + 10))
    return 0;
  pthread_attr_init(&v5);
  pthread_attr_setdetachstate(&v5, 2);
  v2 = pthread_create(v1, &v5, (void *(__cdecl *)(void *))StartGPUReadbackExecUnitFunc, this);
  pthread_attr_destroy(&v5);
  return v2;
}

HGSynchronizable *HGGPUReadbackExecUnit::ExecutePBOReadback(HGGPUReadbackExecUnit *this, HGGPUReadbackJob *a2)
{
  uint64_t v3;
  char *v4;
  uint64_t DataPtr;
  HGPixelBufferObj *v6;
  HGSynchronizable *result;

  v3 = *((_QWORD *)a2 + 5);
  HGGLTexture::ReadPixels((HGGLTexture *)v4, *((HGPixelBufferObj **)this + 8), *(HGRect *)(v4 + 20));
  DataPtr = HGPixelBufferObj::GetDataPtr(*((HGPixelBufferObj **)this + 8));
  ++*((_QWORD *)this + 11);
  if (DataPtr)
  {
    v6 = (HGPixelBufferObj *)*((_QWORD *)this + 8);
    if (*(_DWORD *)(v3 + 60) == 1)
    {
      *(_QWORD *)(v3 + 24) = HGPixelBufferObj::CreateBitmap(v6);
      *(_DWORD *)(v3 + 64) = 1;
      HGPixelBufferObj::ReleaseDataPtr(*((HGPixelBufferObj **)this + 8));
      HGRenderQueue::ReleasePBOToSharedPool(*((HGRenderQueue **)this + 7), *((HGPixelBufferObj **)this + 8));
    }
    else
    {
      *(_QWORD *)(v3 + 136) = v6;
      *(_DWORD *)(v3 + 64) = 2;
      *(_QWORD *)(v3 + 24) = 0;
    }
    result = (HGSynchronizable *)HGRenderQueue::EnqueueDeleteHGGLTexture(*((HGRenderQueue **)this + 7), (HGGLTexture *)v4);
    *((_QWORD *)this + 8) = 0;
  }
  else
  {
    *(_DWORD *)(v3 + 56) = -997;
    result = HGRenderQueue::ReleasePBOToSharedPool(*((HGRenderQueue **)this + 7), *((HGPixelBufferObj **)this + 8));
    *((_QWORD *)this + 8) = 0;
  }
  return result;
}

_QWORD *std::list<HGGPUReadbackJob *>::remove(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;

  v21 = &v21;
  v22 = &v21;
  v2 = (_QWORD *)result[1];
  if (v2 == result)
    return result;
  if (&v21 == result)
  {
    while (1)
    {
      v12 = (_QWORD *)v2[1];
      v13 = v2[2];
      if (v13 == *a2)
        break;
LABEL_19:
      v2 = v12;
      if (v12 == result)
        return result;
    }
    if (v12 == result)
    {
      v14 = 1;
    }
    else
    {
      if (v12[2] != v13)
      {
LABEL_25:
        v14 = 0;
        if (v2 == v12)
        {
LABEL_30:
          if (!v14)
            v12 = (_QWORD *)v12[1];
          goto LABEL_19;
        }
LABEL_29:
        v15 = *v12;
        v16 = *v2;
        *(_QWORD *)(v16 + 8) = *(_QWORD *)(*v12 + 8);
        **(_QWORD **)(v15 + 8) = v16;
        v17 = *result;
        *(_QWORD *)(v17 + 8) = v2;
        *v2 = v17;
        *result = v15;
        *(_QWORD *)(v15 + 8) = result;
        goto LABEL_30;
      }
      while (1)
      {
        v12 = (_QWORD *)v12[1];
        v14 = v12 == result;
        if (v12 == result)
          break;
        if (v12[2] != v13)
          goto LABEL_25;
      }
    }
    v12 = result;
    if (v2 == result)
      goto LABEL_30;
    goto LABEL_29;
  }
  v3 = 0;
  do
  {
    v4 = (_QWORD *)v2[1];
    v5 = v2[2];
    if (v5 == *a2)
    {
      while (v4 != result)
      {
        v6 = v4[2] == v5;
        if (v4[2] != v5)
        {
          if (v2 != v4)
            goto LABEL_11;
LABEL_17:
          if (v6)
            goto LABEL_4;
          goto LABEL_18;
        }
        v4 = (_QWORD *)v4[1];
      }
      v6 = 1;
      v4 = result;
      if (v2 == result)
        goto LABEL_17;
LABEL_11:
      v7 = (_QWORD *)*v4;
      v8 = 1;
      if ((_QWORD *)*v4 != v2)
      {
        v9 = v2;
        do
        {
          v9 = (_QWORD *)v9[1];
          ++v8;
        }
        while (v9 != v7);
      }
      result[2] -= v8;
      v3 += v8;
      v10 = *v2;
      *(_QWORD *)(v10 + 8) = v7[1];
      *(_QWORD *)v7[1] = v10;
      v11 = v21;
      v21[1] = v2;
      *v2 = v11;
      v21 = v7;
      v7[1] = &v21;
      if (!v6)
LABEL_18:
        v4 = (_QWORD *)v4[1];
    }
LABEL_4:
    v2 = v4;
  }
  while (v4 != result);
  if (v3)
  {
    v18 = v21;
    result = v22;
    v19 = *v22;
    *(_QWORD *)(v19 + 8) = v21[1];
    *(_QWORD *)v18[1] = v19;
    v23 = 0;
    if (result != &v21)
    {
      do
      {
        v20 = (_QWORD *)result[1];
        operator delete(result);
        result = v20;
      }
      while (v20 != &v21);
    }
  }
  return result;
}

float HGComicImplementation::GetSmallToLargeScale(HGComicImplementation *this, HGRect *a2)
{
  float v4;
  float v5;
  BOOL IsInfinite;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;

  v4 = 1.0;
  v5 = 1.0;
  if (!HGRect::IsInfinite(a2))
  {
    IsInfinite = HGRect::IsInfinite(a2);
    v7 = 1.0;
    if (!IsInfinite)
    {
      v8 = *((float *)this + 3);
      v9 = 1.0;
      if (v8 != 0.0)
      {
        v10 = fminf((float)(a2->var2 - a2->var0), (float)(a2->var3 - a2->var1));
        v11 = v10 * 0.76;
        v9 = v8 / v10;
        if (v11 <= v8)
          v9 = 0.76;
      }
      if (v9 <= 0.9)
        v7 = v9;
    }
    v12 = *((float *)this + 4);
    if (v12 == 0.0)
      v12 = 1.0;
    v13 = v7 * v12;
    if (v13 <= 0.9)
      v5 = v13;
    else
      v5 = 1.0;
  }
  if (!HGRect::IsInfinite(a2))
  {
    v14 = *((float *)this + 3);
    v15 = 1.0;
    if (v14 != 0.0)
    {
      v16 = fminf((float)(a2->var2 - a2->var0), (float)(a2->var3 - a2->var1));
      v17 = v16 * 0.76;
      v15 = v14 / v16;
      if (v17 <= v14)
        v15 = 0.76;
    }
    if (v15 <= 0.9)
      v4 = v15;
    else
      v4 = 1.0;
  }
  return (float)(1.0 / v5) * v4;
}

float HGComicImplementation::GetLargeToSmallScale(HGComicImplementation *this, HGRect *a2)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  BOOL IsInfinite;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;

  v4 = 1.0;
  v5 = 1.0;
  if (!HGRect::IsInfinite(a2))
  {
    v6 = *((float *)this + 3);
    v7 = 1.0;
    if (v6 != 0.0)
    {
      v8 = fminf((float)(a2->var2 - a2->var0), (float)(a2->var3 - a2->var1));
      v9 = v8 * 0.76;
      v7 = v6 / v8;
      if (v9 <= v6)
        v7 = 0.76;
    }
    if (v7 <= 0.9)
      v5 = v7;
    else
      v5 = 1.0;
  }
  if (!HGRect::IsInfinite(a2))
  {
    IsInfinite = HGRect::IsInfinite(a2);
    v11 = 1.0;
    if (!IsInfinite)
    {
      v12 = *((float *)this + 3);
      v13 = 1.0;
      if (v12 != 0.0)
      {
        v14 = fminf((float)(a2->var2 - a2->var0), (float)(a2->var3 - a2->var1));
        v15 = v14 * 0.76;
        v13 = v12 / v14;
        if (v15 <= v12)
          v13 = 0.76;
      }
      if (v13 <= 0.9)
        v11 = v13;
    }
    v16 = *((float *)this + 4);
    if (v16 == 0.0)
      v16 = 1.0;
    v17 = v11 * v16;
    if (v17 <= 0.9)
      v4 = v17;
    else
      v4 = 1.0;
  }
  return (float)(1.0 / v5) * v4;
}

uint64_t HGComicImplementation::GenerateSobelNode@<X0>(HGComicImplementation *this@<X0>, HGNode *a2@<X1>, float a3@<S0>, int a4@<W2>, HGTextureWrap **a5@<X8>)
{
  HGComicSobelOperator *v10;
  float v11;
  HGTextureWrap *v12;
  char *v13;
  uint64_t result;

  if (a2)
    (*(void (**)(HGNode *))(*(_QWORD *)a2 + 16))(a2);
  v10 = (HGComicSobelOperator *)HGObject::operator new(0x1A0uLL);
  HGComicSobelOperator::HGComicSobelOperator(v10);
  (*(void (**)(HGComicSobelOperator *, _QWORD, HGNode *))(*(_QWORD *)v10 + 120))(v10, 0, a2);
  v11 = 0.0;
  (*(void (**)(HGComicSobelOperator *, uint64_t, float, float, float, float))(*(_QWORD *)v10 + 96))(v10, 1, a3, 0.0, 0.0, 0.0);
  if (a4)
  {
    if (*((_BYTE *)this + 97))
      v11 = 1.0;
    else
      v11 = 0.0;
  }
  (*(void (**)(HGComicSobelOperator *, _QWORD, float, float, float, float))(*(_QWORD *)v10 + 96))(v10, 0, v11, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicSobelOperator *))(*(_QWORD *)v10 + 16))(v10);
  v12 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v12);
  (*(void (**)(HGTextureWrap *, _QWORD, HGComicSobelOperator *))(*(_QWORD *)v12 + 120))(v12, 0, v10);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v12, (const char *)1, v13);
  *a5 = v12;
  (*(void (**)(HGComicSobelOperator *))(*(_QWORD *)v10 + 24))(v10);
  result = (*(uint64_t (**)(HGComicSobelOperator *))(*(_QWORD *)v10 + 24))(v10);
  if (a2)
    return (*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 24))(a2);
  return result;
}

void sub_1B2A758AC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  HGObject::operator delete(v3);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t HGComicImplementation::GenerateGaussBlurXNode@<X0>(HGComicImplementation *this@<X0>, HGNode *a2@<X1>, float a3@<S0>, HGTextureWrap **a4@<X8>)
{
  HGComicGaussianBlurAndGradientGeneration *v8;
  __n128 v9;
  HGTextureWrap *v10;
  char *v11;
  uint64_t result;

  if (a2)
    (*(void (**)(HGNode *))(*(_QWORD *)a2 + 16))(a2);
  v8 = (HGComicGaussianBlurAndGradientGeneration *)HGObject::operator new(0x1B0uLL);
  HGComicGaussianBlurAndGradientGeneration::HGComicGaussianBlurAndGradientGeneration(v8);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, _QWORD, HGNode *))(*(_QWORD *)v8 + 120))(v8, 0, a2);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, _QWORD, float, float, float, float))(*(_QWORD *)v8 + 96))(v8, 0, a3 * COERCE_FLOAT(*((_QWORD *)this + 9)), 0.0, 0.0, 0.0);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, uint64_t, float, float, float, float))(*(_QWORD *)v8 + 96))(v8, 1, 1.0, 0.0, 0.0, 0.0);
  if (*((_BYTE *)this + 96))
    v9.n128_f32[0] = 1.0;
  else
    v9.n128_f32[0] = 0.0;
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, uint64_t, __n128, float, float, float))(*(_QWORD *)v8 + 96))(v8, 2, v9, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *))(*(_QWORD *)v8 + 16))(v8);
  v10 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v10);
  (*(void (**)(HGTextureWrap *, _QWORD, HGComicGaussianBlurAndGradientGeneration *))(*(_QWORD *)v10 + 120))(v10, 0, v8);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v10, (const char *)1, v11);
  *a4 = v10;
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *))(*(_QWORD *)v8 + 24))(v8);
  result = (*(uint64_t (**)(HGComicGaussianBlurAndGradientGeneration *))(*(_QWORD *)v8 + 24))(v8);
  if (a2)
    return (*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 24))(a2);
  return result;
}

void sub_1B2A75AC0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  HGObject::operator delete(v3);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t HGComicImplementation::GenerateGaussBlurYAndGradNode@<X0>(HGComicImplementation *this@<X0>, HGNode *a2@<X1>, float a3@<S0>, HGTextureWrap **a4@<X8>)
{
  HGComicGaussianBlurAndGradientGeneration *v8;
  __n128 v9;
  HGTextureWrap *v10;
  char *v11;
  uint64_t result;

  if (a2)
    (*(void (**)(HGNode *))(*(_QWORD *)a2 + 16))(a2);
  v8 = (HGComicGaussianBlurAndGradientGeneration *)HGObject::operator new(0x1B0uLL);
  HGComicGaussianBlurAndGradientGeneration::HGComicGaussianBlurAndGradientGeneration(v8);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, _QWORD, HGNode *))(*(_QWORD *)v8 + 120))(v8, 0, a2);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, _QWORD, float, float, float, float))(*(_QWORD *)v8 + 96))(v8, 0, *((float *)this + 19) * a3, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, uint64_t, float, float, float, float))(*(_QWORD *)v8 + 96))(v8, 1, 0.0, 1.0, 0.0, 0.0);
  if (*((_BYTE *)this + 96))
    v9.n128_f32[0] = 1.0;
  else
    v9.n128_f32[0] = 0.0;
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, uint64_t, __n128, float, float, float))(*(_QWORD *)v8 + 96))(v8, 2, v9, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *))(*(_QWORD *)v8 + 16))(v8);
  v10 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v10);
  (*(void (**)(HGTextureWrap *, _QWORD, HGComicGaussianBlurAndGradientGeneration *))(*(_QWORD *)v10 + 120))(v10, 0, v8);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v10, (const char *)1, v11);
  *a4 = v10;
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *))(*(_QWORD *)v8 + 24))(v8);
  result = (*(uint64_t (**)(HGComicGaussianBlurAndGradientGeneration *))(*(_QWORD *)v8 + 24))(v8);
  if (a2)
    return (*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 24))(a2);
  return result;
}

void sub_1B2A75CD8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  HGObject::operator delete(v3);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t HGComicImplementation::GenerateBilateralXNode@<X0>(HGComicImplementation *this@<X0>, HGNode *a2@<X1>, HGNode *a3@<X2>, float a4@<S0>, HGTextureWrap **a5@<X8>)
{
  HGComicBilateralFilter *v10;
  HGTextureWrap *v11;
  char *v12;
  uint64_t result;

  if (a2)
    (*(void (**)(HGNode *))(*(_QWORD *)a2 + 16))(a2);
  if (a3)
    (*(void (**)(HGNode *))(*(_QWORD *)a3 + 16))(a3);
  v10 = (HGComicBilateralFilter *)HGObject::operator new(0x1B0uLL);
  HGComicBilateralFilter::HGComicBilateralFilter(v10);
  (*(void (**)(HGComicBilateralFilter *, _QWORD, HGNode *))(*(_QWORD *)v10 + 120))(v10, 0, a2);
  (*(void (**)(HGComicBilateralFilter *, uint64_t, HGNode *))(*(_QWORD *)v10 + 120))(v10, 1, a3);
  (*(void (**)(HGComicBilateralFilter *, _QWORD, float, float, float, float))(*(_QWORD *)v10 + 96))(v10, 0, 6.51 * COERCE_FLOAT(*((_QWORD *)this + 9)), 0.10846, 0.0, 0.0);
  (*(void (**)(HGComicBilateralFilter *, uint64_t, float, float, float, float))(*(_QWORD *)v10 + 96))(v10, 1, 1.0, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicBilateralFilter *, uint64_t, float, float, float, float))(*(_QWORD *)v10 + 96))(v10, 2, a4, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicBilateralFilter *))(*(_QWORD *)v10 + 16))(v10);
  v11 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v11);
  (*(void (**)(HGTextureWrap *, _QWORD, HGComicBilateralFilter *))(*(_QWORD *)v11 + 120))(v11, 0, v10);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v11, (const char *)1, v12);
  *a5 = v11;
  (*(void (**)(HGComicBilateralFilter *))(*(_QWORD *)v10 + 24))(v10);
  result = (*(uint64_t (**)(HGComicBilateralFilter *))(*(_QWORD *)v10 + 24))(v10);
  if (a3)
    result = (*(uint64_t (**)(HGNode *))(*(_QWORD *)a3 + 24))(a3);
  if (a2)
    return (*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 24))(a2);
  return result;
}

void sub_1B2A75F3C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t HGComicImplementation::GenerateBilateralYNode@<X0>(HGComicImplementation *this@<X0>, HGNode *a2@<X1>, HGNode *a3@<X2>, HGTextureWrap **a4@<X8>)
{
  HGComicBilateralFilter *v8;
  HGTextureWrap *v9;
  char *v10;
  uint64_t result;

  if (a2)
    (*(void (**)(HGNode *))(*(_QWORD *)a2 + 16))(a2);
  if (a3)
    (*(void (**)(HGNode *))(*(_QWORD *)a3 + 16))(a3);
  v8 = (HGComicBilateralFilter *)HGObject::operator new(0x1B0uLL);
  HGComicBilateralFilter::HGComicBilateralFilter(v8);
  (*(void (**)(HGComicBilateralFilter *, _QWORD, HGNode *))(*(_QWORD *)v8 + 120))(v8, 0, a2);
  (*(void (**)(HGComicBilateralFilter *, uint64_t, HGNode *))(*(_QWORD *)v8 + 120))(v8, 1, a3);
  (*(void (**)(HGComicBilateralFilter *, _QWORD, float, float, float, float))(*(_QWORD *)v8 + 96))(v8, 0, *((float *)this + 19) * 6.51, 0.10846, 0.0, 0.0);
  (*(void (**)(HGComicBilateralFilter *, uint64_t, float, float, float, float))(*(_QWORD *)v8 + 96))(v8, 1, 0.0, 1.0, 0.0, 0.0);
  (*(void (**)(HGComicBilateralFilter *))(*(_QWORD *)v8 + 16))(v8);
  v9 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v9);
  (*(void (**)(HGTextureWrap *, _QWORD, HGComicBilateralFilter *))(*(_QWORD *)v9 + 120))(v9, 0, v8);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v9, (const char *)1, v10);
  *a4 = v9;
  (*(void (**)(HGComicBilateralFilter *))(*(_QWORD *)v8 + 24))(v8);
  result = (*(uint64_t (**)(HGComicBilateralFilter *))(*(_QWORD *)v8 + 24))(v8);
  if (a3)
    result = (*(uint64_t (**)(HGNode *))(*(_QWORD *)a3 + 24))(a3);
  if (a2)
    return (*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 24))(a2);
  return result;
}

void sub_1B2A76198(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t HGComicImplementation::GenerateQuantizeNode@<X0>(HGComicImplementation *this@<X0>, HGNode *a2@<X1>, float a3@<S0>, HGTextureWrap **a4@<X8>)
{
  HGComicQuantize *v8;
  HGTextureWrap *v9;
  char *v10;

  v8 = (HGComicQuantize *)HGObject::operator new(0x1A0uLL);
  HGComicQuantize::HGComicQuantize(v8);
  (*(void (**)(HGComicQuantize *, _QWORD, HGNode *))(*(_QWORD *)v8 + 120))(v8, 0, a2);
  (*(void (**)(HGComicQuantize *, _QWORD, float, float, float, float))(*(_QWORD *)v8 + 96))(v8, 0, (float)*((int *)this + 11), 0.0, 0.0, 0.0);
  (*(void (**)(HGComicQuantize *, uint64_t, float, float, float, float))(*(_QWORD *)v8 + 96))(v8, 1, a3, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicQuantize *))(*(_QWORD *)v8 + 16))(v8);
  v9 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v9);
  (*(void (**)(HGTextureWrap *, _QWORD, HGComicQuantize *))(*(_QWORD *)v9 + 120))(v9, 0, v8);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v9, (const char *)1, v10);
  *a4 = v9;
  (*(void (**)(HGComicQuantize *))(*(_QWORD *)v8 + 24))(v8);
  return (*(uint64_t (**)(HGComicQuantize *))(*(_QWORD *)v8 + 24))(v8);
}

void sub_1B2A76378(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;

  HGObject::operator delete(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t HGComicImplementation::GenerateColorStrokeNode@<X0>(HGNode *a1@<X1>, HGNode *a2@<X2>, float a3@<S0>, HGTextureWrap **a4@<X8>)
{
  HGComicColorStroke *v9;
  HGTextureWrap *v10;
  char *v11;
  uint64_t result;

  if (a1)
    (*(void (**)(HGNode *))(*(_QWORD *)a1 + 16))(a1);
  if (a2)
    (*(void (**)(HGNode *))(*(_QWORD *)a2 + 16))(a2);
  v9 = (HGComicColorStroke *)HGObject::operator new(0x1A0uLL);
  HGComicColorStroke::HGComicColorStroke(v9);
  (*(void (**)(HGComicColorStroke *, _QWORD, HGNode *))(*(_QWORD *)v9 + 120))(v9, 0, a1);
  (*(void (**)(HGComicColorStroke *, uint64_t, HGNode *))(*(_QWORD *)v9 + 120))(v9, 1, a2);
  (*(void (**)(HGComicColorStroke *, _QWORD, float, float, float, float))(*(_QWORD *)v9 + 96))(v9, 0, a3, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicColorStroke *))(*(_QWORD *)v9 + 16))(v9);
  v10 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v10);
  (*(void (**)(HGTextureWrap *, _QWORD, HGComicColorStroke *))(*(_QWORD *)v10 + 120))(v10, 0, v9);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v10, (const char *)1, v11);
  *a4 = v10;
  (*(void (**)(HGComicColorStroke *))(*(_QWORD *)v9 + 24))(v9);
  result = (*(uint64_t (**)(HGComicColorStroke *))(*(_QWORD *)v9 + 24))(v9);
  if (a2)
    result = (*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 24))(a2);
  if (a1)
    return (*(uint64_t (**)(HGNode *))(*(_QWORD *)a1 + 24))(a1);
  return result;
}

void sub_1B2A76558(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t HGComicImplementation::GenerateEdgesNode@<X0>(float32x2_t *this@<X0>, HGNode *a2@<X1>, HGNode *a3@<X2>, HGTextureWrap **a4@<X8>)
{
  HGComicEdges *v8;
  float v9;
  HGTextureWrap *v10;
  char *v11;
  uint64_t result;

  if (a2)
    (*(void (**)(HGNode *))(*(_QWORD *)a2 + 16))(a2);
  v8 = (HGComicEdges *)HGObject::operator new(0x1B0uLL);
  HGComicEdges::HGComicEdges(v8);
  (*(void (**)(HGComicEdges *, _QWORD, HGNode *))(*(_QWORD *)v8 + 120))(v8, 0, a2);
  (*(void (**)(HGComicEdges *, uint64_t, HGNode *))(*(_QWORD *)v8 + 120))(v8, 1, a3);
  v9 = vaddv_f32(this[9]);
  if (v9 > 1.0)
    v9 = 1.0;
  (*(void (**)(HGComicEdges *, _QWORD, float, float, float, float))(*(_QWORD *)v8 + 96))(v8, 0, this[2].f32[1] * v9, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicEdges *, uint64_t, float32_t, float, float, float))(*(_QWORD *)v8 + 96))(v8, 1, this[3].f32[0], 0.0, 0.0, 0.0);
  (*(void (**)(HGComicEdges *, uint64_t, float32_t, float, float, float))(*(_QWORD *)v8 + 96))(v8, 3, this[3].f32[1], 0.0, 0.0, 0.0);
  (*(void (**)(HGComicEdges *, uint64_t, float, float, float, float))(*(_QWORD *)v8 + 96))(v8, 2, 0.5, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicEdges *))(*(_QWORD *)v8 + 16))(v8);
  v10 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v10);
  (*(void (**)(HGTextureWrap *, _QWORD, HGComicEdges *))(*(_QWORD *)v10 + 120))(v10, 0, v8);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v10, (const char *)1, v11);
  *a4 = v10;
  (*(void (**)(HGComicEdges *))(*(_QWORD *)v8 + 24))(v8);
  result = (*(uint64_t (**)(HGComicEdges *))(*(_QWORD *)v8 + 24))(v8);
  if (a2)
    return (*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 24))(a2);
  return result;
}

void sub_1B2A767D4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  HGObject::operator delete(v3);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t HGComicImplementation::GenerateStrokeAndBlendNode@<X0>(float32x2_t *this@<X0>, HGNode *a2@<X1>, HGNode *a3@<X2>, HGNode *a4@<X3>, HGNode *a5@<X4>, float a6@<S0>, float a7@<S1>, int a8@<W5>, HGTextureWrap **a9@<X8>)
{
  HGComicStrokeAndBlend *v18;
  float v19;
  __n128 v20;
  __n128 v21;
  __n128 v22;
  __n128 v23;
  HGTextureWrap *v24;
  char *v25;
  uint64_t result;

  if (a2)
    (*(void (**)(HGNode *))(*(_QWORD *)a2 + 16))(a2);
  if (a3)
    (*(void (**)(HGNode *))(*(_QWORD *)a3 + 16))(a3);
  if (a4)
    (*(void (**)(HGNode *))(*(_QWORD *)a4 + 16))(a4);
  if (a5)
    (*(void (**)(HGNode *))(*(_QWORD *)a5 + 16))(a5);
  v18 = (HGComicStrokeAndBlend *)HGObject::operator new(0x1C0uLL);
  HGComicStrokeAndBlend::HGComicStrokeAndBlend(v18);
  (*(void (**)(HGComicStrokeAndBlend *, _QWORD, HGNode *))(*(_QWORD *)v18 + 120))(v18, 0, a3);
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, HGNode *))(*(_QWORD *)v18 + 120))(v18, 1, a2);
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, HGNode *))(*(_QWORD *)v18 + 120))(v18, 2, a4);
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, HGNode *))(*(_QWORD *)v18 + 120))(v18, 3, a5);
  v19 = vaddv_f32(this[9]);
  if (v19 > 1.0)
    v19 = 1.0;
  (*(void (**)(HGComicStrokeAndBlend *, _QWORD, float, float, float, float))(*(_QWORD *)v18 + 96))(v18, 0, this[4].f32[0] * v19, 0.0, 0.0, 0.0);
  if (a8)
    v20.n128_f32[0] = 1.0;
  else
    v20.n128_f32[0] = 0.0;
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, __n128, float, float, float))(*(_QWORD *)v18 + 96))(v18, 1, v20, 0.0, 0.0, 0.0);
  if (a4)
    v21.n128_f32[0] = 1.0;
  else
    v21.n128_f32[0] = 0.0;
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, __n128, float, float, float))(*(_QWORD *)v18 + 96))(v18, 2, v21, 0.0, 0.0, 0.0);
  if (a5)
    v22.n128_f32[0] = 1.0;
  else
    v22.n128_f32[0] = 0.0;
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, __n128, float, float, float))(*(_QWORD *)v18 + 96))(v18, 4, v22, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, float, float, float, float))(*(_QWORD *)v18 + 96))(v18, 5, a7, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, float, float, float, float))(*(_QWORD *)v18 + 96))(v18, 6, a6, 0.0, 0.0, 0.0);
  v23.n128_u32[0] = 1.0;
  if (!this[12].i8[2])
    v23.n128_f32[0] = 0.0;
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, __n128, float, float, float))(*(_QWORD *)v18 + 96))(v18, 3, v23, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicStrokeAndBlend *))(*(_QWORD *)v18 + 16))(v18);
  v24 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v24);
  (*(void (**)(HGTextureWrap *, _QWORD, HGComicStrokeAndBlend *))(*(_QWORD *)v24 + 120))(v24, 0, v18);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v24, (const char *)1, v25);
  *a9 = v24;
  (*(void (**)(HGComicStrokeAndBlend *))(*(_QWORD *)v18 + 24))(v18);
  result = (*(uint64_t (**)(HGComicStrokeAndBlend *))(*(_QWORD *)v18 + 24))(v18);
  if (a5)
    result = (*(uint64_t (**)(HGNode *))(*(_QWORD *)a5 + 24))(a5);
  if (a4)
    result = (*(uint64_t (**)(HGNode *))(*(_QWORD *)a4 + 24))(a4);
  if (a3)
    result = (*(uint64_t (**)(HGNode *))(*(_QWORD *)a3 + 24))(a3);
  if (a2)
    return (*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 24))(a2);
  return result;
}

void sub_1B2A76B90(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t HGComicImplementation::GenerateStrokeNode@<X0>(float32x2_t *this@<X0>, HGNode *a2@<X1>, HGNode *a3@<X2>, float a4@<S0>, HGTextureWrap **a5@<X8>)
{
  HGComicStroke *v10;
  float v11;
  __n128 v12;
  __n128 v13;
  HGTextureWrap *v14;
  char *v15;
  uint64_t result;

  if (a2)
    (*(void (**)(HGNode *))(*(_QWORD *)a2 + 16))(a2);
  if (a3)
    (*(void (**)(HGNode *))(*(_QWORD *)a3 + 16))(a3);
  v10 = (HGComicStroke *)HGObject::operator new(0x1B0uLL);
  HGComicStroke::HGComicStroke(v10);
  (*(void (**)(HGComicStroke *, _QWORD, HGNode *))(*(_QWORD *)v10 + 120))(v10, 0, a2);
  (*(void (**)(HGComicStroke *, uint64_t, HGNode *))(*(_QWORD *)v10 + 120))(v10, 1, a3);
  v11 = vaddv_f32(this[9]);
  if (v11 > 1.0)
    v11 = 1.0;
  (*(void (**)(HGComicStroke *, _QWORD, float, float, float, float))(*(_QWORD *)v10 + 96))(v10, 0, this[5].f32[0] * v11, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicStroke *, uint64_t, float, float, float, float))(*(_QWORD *)v10 + 96))(v10, 3, a4, 0.0, 0.0, 0.0);
  if (a3)
    v12.n128_f32[0] = 1.0;
  else
    v12.n128_f32[0] = 0.0;
  (*(void (**)(HGComicStroke *, uint64_t, __n128, float, float, float))(*(_QWORD *)v10 + 96))(v10, 2, v12, 0.0, 0.0, 0.0);
  v13.n128_u32[0] = 0;
  if (this[12].i8[2])
    v13.n128_f32[0] = 1.0;
  (*(void (**)(HGComicStroke *, uint64_t, __n128, float, float, float))(*(_QWORD *)v10 + 96))(v10, 1, v13, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicStroke *))(*(_QWORD *)v10 + 16))(v10);
  v14 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v14);
  (*(void (**)(HGTextureWrap *, _QWORD, HGComicStroke *))(*(_QWORD *)v14 + 120))(v14, 0, v10);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v14, (const char *)1, v15);
  *a5 = v14;
  (*(void (**)(HGComicStroke *))(*(_QWORD *)v10 + 24))(v10);
  result = (*(uint64_t (**)(HGComicStroke *))(*(_QWORD *)v10 + 24))(v10);
  if (a3)
    result = (*(uint64_t (**)(HGNode *))(*(_QWORD *)a3 + 24))(a3);
  if (a2)
    return (*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 24))(a2);
  return result;
}

void sub_1B2A76E98(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t HGComicImplementation::GenerateSobelGradients@<X0>(HGComicImplementation *this@<X0>, HGNode *a2@<X1>, float a3@<S0>, float a4@<S1>, int a5@<W2>, HGTextureWrap **a6@<X8>)
{
  HGNode *v9;
  HGNode *v10;
  uint64_t result;
  HGNode *v12;
  HGNode *v13;

  HGComicImplementation::GenerateSobelNode(this, a2, a4, a5, (HGTextureWrap **)&v12);
  v9 = v12;
  HGComicImplementation::GenerateGaussBlurXNode(this, v12, a3, (HGTextureWrap **)&v13);
  v10 = v13;
  result = HGComicImplementation::GenerateGaussBlurYAndGradNode(this, v13, a3, a6);
  if (v10)
    result = (*(uint64_t (**)(HGNode *))(*(_QWORD *)v10 + 24))(v10);
  if (v9)
    return (*(uint64_t (**)(HGNode *))(*(_QWORD *)v9 + 24))(v9);
  return result;
}

void sub_1B2A77004(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

HGXForm *HGComicImplementation::GenerateGraph(HGComicImplementation *this, HGRenderer *a2, HGNode *a3, HGNode *a4)
{
  HGNode *v8;
  HGCrop *v9;
  uint64_t v10;
  float v11;
  int v12;
  float v13;
  float v14;
  float v15;
  float v16;
  HGXForm *v18;
  uint64_t v19;
  HGTextureWrap *v20;
  char *v21;
  const char *v22;
  char *v23;
  HGTextureWrap *v24;
  HGXForm *v25;
  HGCrop *v26;
  HGXForm *v27;
  HGXForm *v28;
  HGRect v30;
  HGTextureWrap *v31[18];
  HGRect v32;

  if (a3)
  {
    (*(void (**)(HGNode *))(*(_QWORD *)a3 + 16))(a3);
    (*(void (**)(HGNode *))(*(_QWORD *)a3 + 16))(a3);
  }
  v8 = a3;
  if (!HGRect::IsInfinite((HGRect *)((char *)this + 52)))
  {
    v9 = (HGCrop *)HGObject::operator new(0x1A0uLL);
    HGCrop::HGCrop(v9);
    (*(void (**)(HGCrop *, _QWORD, HGNode *))(*(_QWORD *)v9 + 120))(v9, 0, a3);
    (*(void (**)(HGCrop *, _QWORD, float, float, float, float))(*(_QWORD *)v9 + 96))(v9, 0, (float)*((int *)this + 13), (float)*((int *)this + 14), (float)*((int *)this + 15), (float)*((int *)this + 16));
    v8 = a3;
    if (v9 != (HGCrop *)a3)
    {
      if (a3)
        (*(void (**)(HGNode *))(*(_QWORD *)a3 + 24))(a3);
      v8 = (HGNode *)v9;
      (*(void (**)(HGCrop *))(*(_QWORD *)v9 + 16))(v9);
    }
    (*(void (**)(HGCrop *))(*(_QWORD *)v9 + 24))(v9);
  }
  *(_QWORD *)&v32.var0 = HGRenderer::GetDOD(a2, v8);
  *(_QWORD *)&v32.var2 = v10;
  v11 = 1.0;
  if (HGRect::IsInfinite(&v32))
  {
    v12 = 0;
  }
  else
  {
    v13 = *((float *)this + 3);
    v12 = 0;
    if (v13 != 0.0)
    {
      v14 = v13 + v13;
      v15 = fminf((float)(v32.var2 - v32.var0), (float)(v32.var3 - v32.var1));
      if (v15 > v14)
      {
        v16 = v14 / v15;
        if ((float)(v14 / v15) <= 0.9 && v16 != 1.0)
        {
          HGTransform::HGTransform((HGTransform *)v31);
          HGTransform::Scale((HGTransform *)v31, v16, v16, 1.0);
          v18 = (HGXForm *)HGObject::operator new(0x210uLL);
          HGXForm::HGXForm(v18);
          (*(void (**)(HGXForm *, _QWORD, HGNode *))(*(_QWORD *)v18 + 120))(v18, 0, v8);
          (*(void (**)(HGXForm *, HGTextureWrap **))(*(_QWORD *)v18 + 576))(v18, v31);
          (*(void (**)(HGXForm *, uint64_t, float))(*(_QWORD *)v18 + 592))(v18, 6, 1.0);
          if (v8 != (HGNode *)v18)
          {
            if (v8)
              (*(void (**)(HGNode *))(*(_QWORD *)v8 + 24))(v8);
            v8 = (HGNode *)v18;
            (*(void (**)(HGXForm *))(*(_QWORD *)v18 + 16))(v18);
          }
          (*(void (**)(HGXForm *))(*(_QWORD *)v18 + 24))(v18);
          HGTransform::~HGTransform((HGTransform *)v31);
          v12 = 1;
          v11 = v16;
        }
      }
    }
  }
  *(_QWORD *)&v30.var0 = HGRenderer::GetDOD(a2, v8);
  *(_QWORD *)&v30.var2 = v19;
  v20 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v20);
  (*(void (**)(HGTextureWrap *, _QWORD, HGNode *))(*(_QWORD *)v20 + 120))(v20, 0, v8);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v20, (const char *)1, v21);
  switch(*((_DWORD *)this + 12))
  {
    case 0:
      HGComicImplementation::GenerateGraphStyleClassicParent((float32x2_t *)this, (HGNode *)v20, &v30, 0, 1, v31);
      goto LABEL_31;
    case 1:
    case 2:
      HGComicImplementation::GenerateGraphStylePosterParent((float32x2_t *)this, (HGNode *)v20, &v30, a4, 1, 0, v31);
      goto LABEL_31;
    case 5:
      HGComicImplementation::GenerateGraphStyleClassicParent((float32x2_t *)this, (HGNode *)v20, &v30, a4, 0, v31);
      goto LABEL_31;
    case 7:
      HGComicImplementation::GenerateGraphStylePosterParent((float32x2_t *)this, (HGNode *)v20, &v30, a4, 0, 0, v31);
      goto LABEL_31;
    case 0xA:
      HGComicImplementation::GenerateGraphStylePosterParent((float32x2_t *)this, (HGNode *)v20, &v30, 0, 0, 1, v31);
      goto LABEL_31;
    case 0x11:
    case 0x18:
      HGComicImplementation::GenerateGraphStyleInk((float32x2_t *)this, (HGNode *)v20, &v30, v31);
LABEL_31:
      v24 = v31[0];
      if ((v12 & 1) != 0)
        goto LABEL_32;
      if (v31[0])
      {
        v25 = (HGXForm *)v31[0];
        (*(void (**)(HGTextureWrap *))(*(_QWORD *)v31[0] + 16))(v31[0]);
      }
      else
      {
        v25 = 0;
      }
      break;
    default:
      HGLogger::error((HGLogger *)"Unsupported style detected in HGComic.  No HGComic graph generated.", v22, v23, *(_QWORD *)&v30.var0, *(_QWORD *)&v30.var2);
      v24 = 0;
      v25 = 0;
      if (!v12)
        break;
LABEL_32:
      HGTransform::HGTransform((HGTransform *)v31);
      HGTransform::Scale((HGTransform *)v31, (float)(1.0 / v11), (float)(1.0 / v11), 1.0);
      v25 = (HGXForm *)HGObject::operator new(0x210uLL);
      HGXForm::HGXForm(v25);
      (*(void (**)(HGXForm *, _QWORD, HGTextureWrap *))(*(_QWORD *)v25 + 120))(v25, 0, v24);
      (*(void (**)(HGXForm *, HGTextureWrap **))(*(_QWORD *)v25 + 576))(v25, v31);
      (*(void (**)(HGXForm *))(*(_QWORD *)v25 + 16))(v25);
      (*(void (**)(HGXForm *))(*(_QWORD *)v25 + 24))(v25);
      HGTransform::~HGTransform((HGTransform *)v31);
      break;
  }
  if (!HGRect::IsInfinite((HGRect *)((char *)this + 52)))
  {
    v26 = (HGCrop *)HGObject::operator new(0x1A0uLL);
    HGCrop::HGCrop(v26);
    (*(void (**)(HGCrop *, _QWORD, HGXForm *))(*(_QWORD *)v26 + 120))(v26, 0, v25);
    (*(void (**)(HGCrop *, _QWORD, float, float, float, float))(*(_QWORD *)v26 + 96))(v26, 0, (float)*((int *)this + 13), (float)*((int *)this + 14), (float)*((int *)this + 15), (float)*((int *)this + 16));
    if (v25 != (HGXForm *)v26)
    {
      if (v25)
        (*(void (**)(HGXForm *))(*(_QWORD *)v25 + 24))(v25);
      v25 = (HGXForm *)v26;
      (*(void (**)(HGCrop *))(*(_QWORD *)v26 + 16))(v26);
    }
    (*(void (**)(HGCrop *))(*(_QWORD *)v26 + 24))(v26);
  }
  v27 = (HGXForm *)*((_QWORD *)this + 13);
  if (v27 == v25)
  {
    v28 = v25;
    if (!v25)
      goto LABEL_49;
    goto LABEL_48;
  }
  if (v27)
    (*(void (**)(HGXForm *))(*(_QWORD *)v27 + 24))(v27);
  *((_QWORD *)this + 13) = v25;
  if (v25)
  {
    (*(void (**)(HGXForm *))(*(_QWORD *)v25 + 16))(v25);
    v28 = (HGXForm *)*((_QWORD *)this + 13);
LABEL_48:
    (*(void (**)(HGXForm *))(*(_QWORD *)v25 + 24))(v25);
LABEL_49:
    if (!v24)
      goto LABEL_51;
    goto LABEL_50;
  }
  v28 = 0;
  if (v24)
LABEL_50:
    (*(void (**)(HGTextureWrap *))(*(_QWORD *)v24 + 24))(v24);
LABEL_51:
  (*(void (**)(HGTextureWrap *))(*(_QWORD *)v20 + 24))(v20);
  if (v8)
    (*(void (**)(HGNode *))(*(_QWORD *)v8 + 24))(v8);
  if (a3)
    (*(void (**)(HGNode *))(*(_QWORD *)a3 + 24))(a3);
  return v28;
}

void sub_1B2A7761C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v11;
  uint64_t v12;
  void *v13;

  HGObject::operator delete(v13);
  HGTransform::~HGTransform((HGTransform *)&a11);
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
  _Unwind_Resume(a1);
}

HGNode *HGComicImplementation::GenerateGraphStyleClassicParent@<X0>(float32x2_t *this@<X0>, HGNode *a2@<X1>, HGRect *a3@<X2>, HGNode *a4@<X3>, int a5@<W4>, HGLegacyBlend **a6@<X8>)
{
  float v12;
  BOOL IsInfinite;
  float v14;
  BOOL v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  HGNode *v22;
  BOOL v23;
  float v24;
  BOOL v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  HGNode *v33;
  HGNode *v34;
  float SmallToLargeScale;
  HGNode *v36;
  float LargeToSmallScale;
  HGNode *v38;
  float v39;
  HGNode *v40;
  HGNode *v41;
  float v42;
  BOOL v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  HGNode *v49;
  HGNode *v50;
  HGLegacyBlend *v51;
  HGTextureWrap *v52;
  HGNode *result;
  HGTextureWrap *v54;
  HGNode *v55;
  HGTextureWrap *v56;
  HGNode *v57;
  HGNode *v58;
  HGNode *v59;
  HGNode *v60;
  HGNode *v61;
  HGNode *v62;

  v12 = this[4].f32[1];
  IsInfinite = HGRect::IsInfinite(a3);
  v14 = 1.0;
  if (!IsInfinite)
  {
    v15 = HGRect::IsInfinite(a3);
    v16 = 1.0;
    if (!v15)
    {
      v17 = this[1].f32[1];
      v18 = 1.0;
      if (v17 != 0.0)
      {
        v19 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
        v20 = v19 * 0.76;
        v18 = v17 / v19;
        if (v20 <= v17)
          v18 = 0.76;
      }
      if (v18 <= 0.9)
        v16 = v18;
    }
    v21 = this[2].f32[0];
    if (v21 == 0.0)
      v21 = 1.0;
    v14 = v16 * v21;
    if (v14 > 0.9)
      v14 = 1.0;
  }
  HGComicImplementation::GenerateSobelGradients((HGComicImplementation *)this, a2, v12, v14, 1, (HGTextureWrap **)&v61);
  v22 = v61;
  v54 = (HGTextureWrap *)v61;
  v23 = HGRect::IsInfinite(a3);
  v24 = 1.0;
  if (!v23)
  {
    v25 = HGRect::IsInfinite(a3);
    v24 = 1.0;
    v26 = 1.0;
    if (!v25)
    {
      v27 = this[1].f32[1];
      v28 = 1.0;
      if (v27 != 0.0)
      {
        v29 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
        v30 = v29 * 0.76;
        v28 = v27 / v29;
        if (v30 <= v27)
          v28 = 0.76;
      }
      if (v28 <= 0.9)
        v26 = v28;
    }
    v31 = this[2].f32[0];
    if (v31 == 0.0)
      v31 = 1.0;
    v32 = v26 * v31;
    if (v32 <= 0.9)
      v24 = v32;
  }
  HGComicImplementation::GenerateBilateralXNode((HGComicImplementation *)this, a2, v22, v24, (HGTextureWrap **)&v62);
  v33 = v62;
  HGComicImplementation::GenerateBilateralYNode((HGComicImplementation *)this, v62, v22, (HGTextureWrap **)&v60);
  if (v33)
    (*(void (**)(HGNode *))(*(_QWORD *)v33 + 24))(v33);
  v34 = v60;
  v55 = v60;
  SmallToLargeScale = HGComicImplementation::GetSmallToLargeScale((HGComicImplementation *)this, a3);
  HGComicImplementation::GenerateQuantizeNode((HGComicImplementation *)this, v34, SmallToLargeScale, (HGTextureWrap **)&v62);
  v36 = v62;
  LargeToSmallScale = HGComicImplementation::GetLargeToSmallScale((HGComicImplementation *)this, a3);
  HGComicImplementation::GenerateSobelGradients((HGComicImplementation *)this, v36, 2.1875, LargeToSmallScale, 0, (HGTextureWrap **)&v59);
  v38 = v59;
  v39 = HGComicImplementation::GetLargeToSmallScale((HGComicImplementation *)this, a3);
  HGComicImplementation::GenerateColorStrokeNode(v36, v38, v39, (HGTextureWrap **)&v58);
  v40 = a4;
  HGComicImplementation::GenerateEdgesNode(this, v55, v22, (HGTextureWrap **)&v57);
  if (this[12].i8[0])
    v41 = a2;
  else
    v41 = 0;
  v42 = HGComicImplementation::GetLargeToSmallScale((HGComicImplementation *)this, a3);
  v43 = HGRect::IsInfinite(a3);
  v44 = 1.0;
  if (!v43)
  {
    v45 = this[1].f32[1];
    v46 = 1.0;
    if (v45 != 0.0)
    {
      v47 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
      v48 = v47 * 0.76;
      v46 = v45 / v47;
      if (v48 <= v45)
        v46 = 0.76;
    }
    if (v46 <= 0.9)
      v44 = v46;
  }
  v49 = v57;
  v50 = v58;
  HGComicImplementation::GenerateStrokeAndBlendNode(this, v58, v57, v40, v41, 1.0 / v44, v42, 0, &v56);
  if (!a5)
  {
    *a6 = v56;
    if (!v49)
      goto LABEL_41;
    goto LABEL_40;
  }
  v51 = (HGLegacyBlend *)HGObject::operator new(0x1C0uLL);
  HGLegacyBlend::HGLegacyBlend(v51);
  *a6 = v51;
  (*(void (**)(HGLegacyBlend *, _QWORD, HGNode *))(*(_QWORD *)v51 + 120))(v51, 0, a2);
  v52 = v56;
  (*(void (**)(HGLegacyBlend *, uint64_t, HGTextureWrap *))(*(_QWORD *)v51 + 120))(v51, 1, v56);
  (*(void (**)(HGLegacyBlend *, _QWORD, float, float, float, float))(*(_QWORD *)v51 + 96))(v51, 0, 8.0, 0.0, 0.0, 0.0);
  (*(void (**)(HGLegacyBlend *, uint64_t, float, float, float, float))(*(_QWORD *)v51 + 96))(v51, 1, 0.5, 0.0, 0.0, 0.0);
  if (v52)
    (*(void (**)(HGTextureWrap *))(*(_QWORD *)v52 + 24))(v52);
  if (v49)
LABEL_40:
    (*(void (**)(HGNode *))(*(_QWORD *)v49 + 24))(v49);
LABEL_41:
  if (v50)
    (*(void (**)(HGNode *))(*(_QWORD *)v50 + 24))(v50);
  if (v38)
    (*(void (**)(HGNode *))(*(_QWORD *)v38 + 24))(v38);
  if (v36)
    (*(void (**)(HGNode *))(*(_QWORD *)v36 + 24))(v36);
  result = v55;
  if (v55)
    result = (HGNode *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)v55 + 24))(v55);
  if (v54)
    return (HGNode *)(*(uint64_t (**)(HGTextureWrap *))(*(_QWORD *)v54 + 24))(v54);
  return result;
}

void sub_1B2A77CB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14;
  uint64_t v15;
  void *v16;

  HGObject::operator delete(v16);
  if (a12)
    (*(void (**)(uint64_t))(*(_QWORD *)a12 + 24))(a12);
  if (a13)
    (*(void (**)(uint64_t))(*(_QWORD *)a13 + 24))(a13);
  if (a14)
    (*(void (**)(uint64_t))(*(_QWORD *)a14 + 24))(a14);
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 24))(v15);
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
  if (a11)
    (*(void (**)(uint64_t))(*(_QWORD *)a11 + 24))(a11);
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(a1);
}

HGTextureWrap *HGComicImplementation::GenerateGraphStylePosterParent@<X0>(float32x2_t *this@<X0>, HGNode *a2@<X1>, HGRect *a3@<X2>, HGNode *a4@<X3>, int a5@<W4>, int a6@<W5>, HGLegacyBlend **a7@<X8>)
{
  float v13;
  BOOL IsInfinite;
  float v15;
  BOOL v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  HGNode *v23;
  BOOL v24;
  float v25;
  BOOL v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  HGNode *v34;
  HGNode *v35;
  float SmallToLargeScale;
  HGNode *v37;
  HGNode *v38;
  float LargeToSmallScale;
  int v40;
  HGNode *v41;
  float v42;
  HGNode *v43;
  float v44;
  BOOL v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  HGNode *v51;
  HGNode *v52;
  HGTextureWrap *v53;
  HGLegacyBlend *v54;
  HGTextureWrap *result;
  HGTextureWrap *v56;
  HGNode *v58;
  HGTextureWrap *v59;
  HGNode *v60;
  HGNode *v61;
  HGNode *v62;
  HGNode *v63;
  HGNode *v64;
  HGNode *v65;

  v13 = this[4].f32[1];
  IsInfinite = HGRect::IsInfinite(a3);
  v15 = 1.0;
  if (!IsInfinite)
  {
    v16 = HGRect::IsInfinite(a3);
    v17 = 1.0;
    if (!v16)
    {
      v18 = this[1].f32[1];
      v19 = 1.0;
      if (v18 != 0.0)
      {
        v20 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
        v21 = v20 * 0.76;
        v19 = v18 / v20;
        if (v21 <= v18)
          v19 = 0.76;
      }
      if (v19 <= 0.9)
        v17 = v19;
    }
    v22 = this[2].f32[0];
    if (v22 == 0.0)
      v22 = 1.0;
    v15 = v17 * v22;
    if (v15 > 0.9)
      v15 = 1.0;
  }
  HGComicImplementation::GenerateSobelGradients((HGComicImplementation *)this, a2, v13, v15, 1, (HGTextureWrap **)&v64);
  v23 = v64;
  v24 = HGRect::IsInfinite(a3);
  v25 = 1.0;
  if (!v24)
  {
    v26 = HGRect::IsInfinite(a3);
    v25 = 1.0;
    v27 = 1.0;
    if (!v26)
    {
      v28 = this[1].f32[1];
      v29 = 1.0;
      if (v28 != 0.0)
      {
        v30 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
        v31 = v30 * 0.76;
        v29 = v28 / v30;
        if (v31 <= v28)
          v29 = 0.76;
      }
      if (v29 <= 0.9)
        v27 = v29;
    }
    v32 = this[2].f32[0];
    if (v32 == 0.0)
      v32 = 1.0;
    v33 = v27 * v32;
    if (v33 <= 0.9)
      v25 = v33;
  }
  HGComicImplementation::GenerateBilateralXNode((HGComicImplementation *)this, a2, v23, v25, (HGTextureWrap **)&v65);
  v34 = v65;
  HGComicImplementation::GenerateBilateralYNode((HGComicImplementation *)this, v65, v23, (HGTextureWrap **)&v63);
  if (v34)
    (*(void (**)(HGNode *))(*(_QWORD *)v34 + 24))(v34);
  v35 = v63;
  HGComicImplementation::GenerateEdgesNode(this, v63, v23, (HGTextureWrap **)&v65);
  v58 = a2;
  SmallToLargeScale = HGComicImplementation::GetSmallToLargeScale((HGComicImplementation *)this, a3);
  HGComicImplementation::GenerateQuantizeNode((HGComicImplementation *)this, v35, SmallToLargeScale, (HGTextureWrap **)&v62);
  v37 = a4;
  v38 = v62;
  LargeToSmallScale = HGComicImplementation::GetLargeToSmallScale((HGComicImplementation *)this, a3);
  HGComicImplementation::GenerateSobelGradients((HGComicImplementation *)this, v38, 2.1875, LargeToSmallScale, 0, (HGTextureWrap **)&v61);
  v40 = a6;
  v41 = v61;
  v56 = (HGTextureWrap *)v61;
  v42 = HGComicImplementation::GetLargeToSmallScale((HGComicImplementation *)this, a3);
  HGComicImplementation::GenerateColorStrokeNode(v38, v41, v42, (HGTextureWrap **)&v60);
  if (this[12].i8[0])
    v43 = v58;
  else
    v43 = 0;
  v44 = HGComicImplementation::GetLargeToSmallScale((HGComicImplementation *)this, a3);
  v45 = HGRect::IsInfinite(a3);
  v46 = 1.0;
  if (!v45)
  {
    v47 = this[1].f32[1];
    v48 = 1.0;
    if (v47 != 0.0)
    {
      v49 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
      v50 = v49 * 0.76;
      v48 = v47 / v49;
      if (v50 <= v47)
        v48 = 0.76;
    }
    if (v48 <= 0.9)
      v46 = v48;
  }
  v51 = v60;
  v52 = v65;
  HGComicImplementation::GenerateStrokeAndBlendNode(this, v60, v65, v37, v43, 1.0 / v46, v44, v40, &v59);
  v53 = v59;
  *a7 = v59;
  if (v53)
    (*(void (**)(HGTextureWrap *))(*(_QWORD *)v53 + 16))(v53);
  if (a5)
  {
    v54 = (HGLegacyBlend *)HGObject::operator new(0x1C0uLL);
    HGLegacyBlend::HGLegacyBlend(v54);
    (*(void (**)(HGLegacyBlend *, _QWORD, HGNode *))(*(_QWORD *)v54 + 120))(v54, 0, v58);
    (*(void (**)(HGLegacyBlend *, uint64_t, HGTextureWrap *))(*(_QWORD *)v54 + 120))(v54, 1, v53);
    (*(void (**)(HGLegacyBlend *, _QWORD, float, float, float, float))(*(_QWORD *)v54 + 96))(v54, 0, 8.0, 0.0, 0.0, 0.0);
    (*(void (**)(HGLegacyBlend *, uint64_t, float, float, float, float))(*(_QWORD *)v54 + 96))(v54, 1, 0.5, 0.0, 0.0, 0.0);
    if (v53 != v54)
    {
      if (v53)
        (*(void (**)(HGTextureWrap *))(*(_QWORD *)v53 + 24))(v53);
      *a7 = v54;
      (*(void (**)(HGLegacyBlend *))(*(_QWORD *)v54 + 16))(v54);
    }
    (*(void (**)(HGLegacyBlend *))(*(_QWORD *)v54 + 24))(v54);
  }
  if (v53)
    (*(void (**)(HGTextureWrap *))(*(_QWORD *)v53 + 24))(v53);
  if (v51)
    (*(void (**)(HGNode *))(*(_QWORD *)v51 + 24))(v51);
  result = v56;
  if (v56)
    result = (HGTextureWrap *)(*(uint64_t (**)(HGTextureWrap *))(*(_QWORD *)v56 + 24))(v56);
  if (v38)
    result = (HGTextureWrap *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)v38 + 24))(v38);
  if (v52)
    result = (HGTextureWrap *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)v52 + 24))(v52);
  if (v35)
    result = (HGTextureWrap *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)v35 + 24))(v35);
  if (v23)
    return (HGTextureWrap *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)v23 + 24))(v23);
  return result;
}

void sub_1B2A78304(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  uint64_t v18;
  void *v19;

  HGObject::operator delete(v19);
  if (v18)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
  }
  if (a13)
    (*(void (**)(uint64_t))(*(_QWORD *)a13 + 24))(a13);
  if (a9)
    (*(void (**)(uint64_t))(*(_QWORD *)a9 + 24))(a9);
  if (a15)
    (*(void (**)(uint64_t))(*(_QWORD *)a15 + 24))(a15);
  if (a18)
    (*(void (**)(uint64_t))(*(_QWORD *)a18 + 24))(a18);
  if (a16)
    (*(void (**)(uint64_t))(*(_QWORD *)a16 + 24))(a16);
  if (a17)
    (*(void (**)(uint64_t))(*(_QWORD *)a17 + 24))(a17);
  _Unwind_Resume(a1);
}

uint64_t HGComicImplementation::GenerateGraphStyleInk@<X0>(float32x2_t *this@<X0>, HGNode *a2@<X1>, HGRect *a3@<X2>, HGTextureWrap **a4@<X8>)
{
  float v9;
  BOOL IsInfinite;
  float v11;
  BOOL v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  HGNode *v19;
  BOOL v20;
  float v21;
  BOOL v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  HGNode *v30;
  HGNode *v31;
  int v32;
  HGNode *v33;
  BOOL v34;
  float v35;
  BOOL v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  HGNode *v44;
  uint64_t result;
  HGNode *v46;
  HGNode *v47;
  HGNode *v48;

  v9 = this[4].f32[1];
  IsInfinite = HGRect::IsInfinite(a3);
  v11 = 1.0;
  if (!IsInfinite)
  {
    v12 = HGRect::IsInfinite(a3);
    v13 = 1.0;
    if (!v12)
    {
      v14 = this[1].f32[1];
      v15 = 1.0;
      if (v14 != 0.0)
      {
        v16 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
        v17 = v16 * 0.76;
        v15 = v14 / v16;
        if (v17 <= v14)
          v15 = 0.76;
      }
      if (v15 <= 0.9)
        v13 = v15;
    }
    v18 = this[2].f32[0];
    if (v18 == 0.0)
      v18 = 1.0;
    v11 = v13 * v18;
    if (v11 > 0.9)
      v11 = 1.0;
  }
  HGComicImplementation::GenerateSobelGradients((HGComicImplementation *)this, a2, v9, v11, 1, (HGTextureWrap **)&v47);
  v19 = v47;
  v20 = HGRect::IsInfinite(a3);
  v21 = 1.0;
  if (!v20)
  {
    v22 = HGRect::IsInfinite(a3);
    v21 = 1.0;
    v23 = 1.0;
    if (!v22)
    {
      v24 = this[1].f32[1];
      v25 = 1.0;
      if (v24 != 0.0)
      {
        v26 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
        v27 = v26 * 0.76;
        v25 = v24 / v26;
        if (v27 <= v24)
          v25 = 0.76;
      }
      if (v25 <= 0.9)
        v23 = v25;
    }
    v28 = this[2].f32[0];
    if (v28 == 0.0)
      v28 = 1.0;
    v29 = v23 * v28;
    if (v29 <= 0.9)
      v21 = v29;
  }
  HGComicImplementation::GenerateBilateralXNode((HGComicImplementation *)this, a2, v19, v21, (HGTextureWrap **)&v48);
  v30 = v48;
  HGComicImplementation::GenerateBilateralYNode((HGComicImplementation *)this, v48, v19, (HGTextureWrap **)&v46);
  if (v30)
    (*(void (**)(HGNode *))(*(_QWORD *)v30 + 24))(v30);
  v31 = v46;
  HGComicImplementation::GenerateEdgesNode(this, v46, v19, (HGTextureWrap **)&v48);
  v32 = this[12].u8[0];
  v33 = v48;
  v34 = HGRect::IsInfinite(a3);
  v35 = 1.0;
  if (!v34)
  {
    v36 = HGRect::IsInfinite(a3);
    v35 = 1.0;
    v37 = 1.0;
    if (!v36)
    {
      v38 = this[1].f32[1];
      v39 = 1.0;
      if (v38 != 0.0)
      {
        v40 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
        v41 = v40 * 0.76;
        v39 = v38 / v40;
        if (v41 <= v38)
          v39 = 0.76;
      }
      if (v39 <= 0.9)
        v37 = v39;
    }
    v42 = this[2].f32[0];
    if (v42 == 0.0)
      v42 = 1.0;
    v43 = v37 * v42;
    if (v43 <= 0.9)
      v35 = v43;
  }
  if (v32)
    v44 = a2;
  else
    v44 = 0;
  result = HGComicImplementation::GenerateStrokeNode(this, v33, v44, 1.0 / v35, a4);
  if (v33)
    result = (*(uint64_t (**)(HGNode *))(*(_QWORD *)v33 + 24))(v33);
  if (v31)
    result = (*(uint64_t (**)(HGNode *))(*(_QWORD *)v31 + 24))(v31);
  if (v19)
    return (*(uint64_t (**)(HGNode *))(*(_QWORD *)v19 + 24))(v19);
  return result;
}

void sub_1B2A787B0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

void HGComic::HGComic(HGComic *this)
{
  _QWORD *v2;
  char *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6525B48;
  v3 = (char *)HGObject::operator new(0x70uLL);
  HGObject::HGObject((HGObject *)v3);
  *(_QWORD *)v3 = off_1E6525DB0;
  *(_OWORD *)(v3 + 12) = 0u;
  *(_OWORD *)(v3 + 28) = 0u;
  *(_OWORD *)(v3 + 44) = xmmword_1B35226C0;
  *(_QWORD *)(v3 + 60) = 0x8000000080000000;
  __asm { FMOV            V0.2S, #1.0 }
  *((_QWORD *)v3 + 9) = _D0;
  *((int32x2_t *)v3 + 10) = vdup_n_s32(0x3D4CCCCDu);
  *((_QWORD *)v3 + 11) = _D0;
  *((_WORD *)v3 + 48) = 256;
  v3[98] = 1;
  *((_QWORD *)v3 + 13) = 0;
  *((_QWORD *)this + 51) = v3;
}

void sub_1B2A788D8(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A788F4(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGComic::~HGComic(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6525B48;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6525B48;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGComic::SetParameter(HGComic *this, int a2, float a3, float32_t a4, float a5, float a6, uint64_t a7, const char *a8, char *a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v32;
  float32x2_t *v33;
  float32x2_t v35;
  unsigned __int8 v36;
  unsigned __int8 v37;
  unsigned __int8 v38;
  unsigned __int8 v39;
  uint64_t v40;
  uint64_t v41;
  float v42;
  float v43;
  float v44;
  __int32 v46;
  float32x2_t v47;
  float32x2_t v48;

  switch(a2)
  {
    case 0:
      v11 = *((_QWORD *)this + 51);
      if (*(float *)(v11 + 12) == a3)
        return 0;
      *(float *)(v11 + 12) = ceilf(a3);
      return 1;
    case 1:
      v14 = *((_QWORD *)this + 51);
      if (*(float *)(v14 + 16) == a3)
        return 0;
      *(float *)(v14 + 16) = a3;
      return 1;
    case 2:
      v15 = *((_QWORD *)this + 51);
      if (*(float *)(v15 + 20) == a3)
        return 0;
      *(float *)(v15 + 20) = a3;
      return 1;
    case 3:
      v16 = *((_QWORD *)this + 51);
      if (*(float *)(v16 + 24) == a3)
        return 0;
      *(float *)(v16 + 24) = a3;
      return 1;
    case 4:
      v17 = *((_QWORD *)this + 51);
      if (*(float *)(v17 + 28) == a3)
        return 0;
      *(float *)(v17 + 28) = a3;
      return 1;
    case 5:
      v18 = *((_QWORD *)this + 51);
      if (*(float *)(v18 + 32) == a3)
        return 0;
      *(float *)(v18 + 32) = a3;
      return 1;
    case 6:
      v19 = *((_QWORD *)this + 51);
      if (*(float *)(v19 + 36) == a3)
        return 0;
      *(float *)(v19 + 36) = a3;
      return 1;
    case 7:
      v20 = *((_QWORD *)this + 51);
      if (*(float *)(v20 + 40) == a3)
        return 0;
      *(float *)(v20 + 40) = a3;
      return 1;
    case 8:
      v21 = *((_QWORD *)this + 51);
      if ((float)*(int *)(v21 + 44) == a3)
        return 0;
      *(_DWORD *)(v21 + 44) = (int)a3;
      return 1;
    case 9:
      v22 = *((_QWORD *)this + 51);
      if (*(_DWORD *)(v22 + 48) == (int)a3)
        return 0;
      *(_DWORD *)(v22 + 48) = (int)a3;
      return 1;
    case 10:
      v23 = *((_QWORD *)this + 51);
      v25 = *(_DWORD *)(v23 + 52);
      v24 = *(_DWORD *)(v23 + 56);
      v26 = *(_QWORD *)(v23 + 60);
      v27 = HGRectMake4i((int)a3, (int)a4, (int)a5, (int)a6);
      if ((_DWORD)v27 == v25 && (_DWORD)v28 == (_DWORD)v26 && HIDWORD(v27) == v24 && HIDWORD(v28) == HIDWORD(v26))
        return 0;
      v32 = *((_QWORD *)this + 51);
      *(_QWORD *)(v32 + 52) = v27;
      *(_QWORD *)(v32 + 60) = v28;
      return 1;
    case 11:
      v33 = (float32x2_t *)*((_QWORD *)this + 51);
      if (COERCE_FLOAT(*(_QWORD *)&v33[9]) == a3 && COERCE_FLOAT(HIDWORD(*(_QWORD *)&v33[9])) == a4)
        return 0;
      v35.f32[0] = a3;
      if (COERCE_FLOAT(*(_QWORD *)&v33[10]) > a3)
      {
        v36 = atomic_load(HGLogger::_enabled);
        if ((v36 & 1) != 0)
        {
          v42 = a4;
          HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"proxy scale x value out of bounds :%f, clamped to minimum: %f\n", a8, a9, a3, COERCE_FLOAT(*(_QWORD *)&v33[10]));
          a4 = v42;
          v35.f32[0] = a3;
        }
      }
      if (v33[10].f32[1] > a4)
      {
        v37 = atomic_load(HGLogger::_enabled);
        if ((v37 & 1) != 0)
        {
          v43 = a4;
          v46 = v35.i32[0];
          HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"proxy scale y value out of bounds :%f, clamped to minimum: %f\n", a8, a9, a4, v33[10].f32[1]);
          a4 = v43;
          v35.i32[0] = v46;
        }
      }
      v35.f32[1] = a4;
      if (COERCE_FLOAT(*(_QWORD *)&v33[11]) < a3)
      {
        v38 = atomic_load(HGLogger::_enabled);
        if ((v38 & 1) != 0)
        {
          v44 = a4;
          v47 = v35;
          HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"proxy scale x value out of bounds :%f, clamped to maximum: %f\n", a8, a9, a3, COERCE_FLOAT(*(_QWORD *)&v33[11]));
          a4 = v44;
          v35 = v47;
        }
      }
      if (v33[11].f32[1] < a4)
      {
        v39 = atomic_load(HGLogger::_enabled);
        if ((v39 & 1) != 0)
        {
          v48 = v35;
          HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"proxy scale y value out of bounds :%f, clamped to maximum: %f\n", a8, a9, a4, v33[11].f32[1]);
          v35 = v48;
        }
      }
      v33[9] = vminnm_f32(vmaxnm_f32(v35, v33[10]), v33[11]);
      return 1;
    case 12:
      v40 = *((_QWORD *)this + 51);
      if ((a3 == 1.0) == (*(_BYTE *)(v40 + 96) != 0))
        return 0;
      *(_BYTE *)(v40 + 96) = a3 == 1.0;
      return 1;
    case 13:
      v41 = *((_QWORD *)this + 51);
      if ((a3 == 1.0) == (*(_BYTE *)(v41 + 97) != 0))
        return 0;
      *(_BYTE *)(v41 + 97) = a3 == 1.0;
      return 1;
    case 14:
      v12 = *((_QWORD *)this + 51);
      if ((a3 == 1.0) == (*(_BYTE *)(v12 + 98) != 0))
        return 0;
      *(_BYTE *)(v12 + 98) = a3 == 1.0;
      return 1;
    default:
      return 0xFFFFFFFFLL;
  }
}

HGXForm *HGComic::GetOutput(HGComic *this, HGRenderer *a2)
{
  HGNode *Input;
  HGNode *v5;
  const char *v6;
  char *v7;

  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  if (Input)
  {
    v5 = HGRenderer::GetInput(a2, (HGNode *)this, 1u);
    if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) != 0
      || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 43))
    {
      return HGComicImplementation::GenerateGraph(*((HGComicImplementation **)this + 51), a2, Input, v5);
    }
    HGLogger::warning((HGLogger *)"No GLES support in HGComic - use Metal on iOS", v6, v7);
  }
  return (HGXForm *)Input;
}

void HGComicImplementation::~HGComicImplementation(HGComicImplementation *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6525DB0;
  v2 = *((_QWORD *)this + 13);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGObject::~HGObject(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6525DB0;
  v2 = *((_QWORD *)this + 13);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGObject::~HGObject(this);
  HGObject::operator delete(v3);
}

void HG_RENDERER_ENV::HG_RENDERER_ENV(HG_RENDERER_ENV *this)
{
  char *v2;
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  const char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  const char *v13;
  char *v14;
  char *v15;
  char *v16;
  size_t v17;
  const char *v18;
  char *v19;
  size_t v20;
  void **p_dst;
  uint64_t v22;
  uint64_t v23;
  void **v24;
  void **v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  void **v29;
  char *v30;
  int v32;
  uint64_t v33;
  void **v34;
  char *v35;
  char *v37;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  char *v44;
  char *v45;
  char *v46;
  char *v47;
  char *v48;
  char *v49;
  char *v50;
  char *v51;
  size_t v52;
  size_t v53;
  void **v54;
  uint64_t v55;
  uint64_t v56;
  void **v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  void **v61;
  char *v62;
  int v64;
  uint64_t v65;
  void **v66;
  char *v67;
  uint64_t v70;
  void **v71;
  char *v72;
  void **v75;
  char *v76;
  const char *v79;
  char *v80;
  char *v81;
  _DWORD *v82;
  char *v83;
  char *v84;
  char *v85;
  char *v86;
  char *v87;
  char *v88;
  char *v89;
  char *v90;
  char *v91;
  char *v92;
  char *v93;
  char *v94;
  char *v95;
  char *v96;
  char *v97;
  char *v98;
  char *v99;
  char *v100;
  char *v101;
  const char *v102;
  char *v103;
  const char *v104;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  char *v110;
  const char *v111;
  char *v112;
  const char *v113;
  char *v114;
  const char *v115;
  unsigned __int8 v116;
  unsigned __int8 v117;
  unsigned __int8 v118;
  unsigned __int8 v119;
  unsigned __int8 v120;
  unsigned __int8 v121;
  unsigned __int8 v122;
  unsigned __int8 v123;
  unsigned __int8 v124;
  unsigned __int8 v125;
  unsigned __int8 v126;
  unsigned __int8 v127;
  unsigned __int8 v128;
  unsigned __int8 v129;
  unsigned __int8 v130;
  unsigned __int8 v131;
  unsigned __int8 v132;
  unsigned __int8 v133;
  unsigned __int8 v134;
  unsigned __int8 v135;
  unsigned __int8 v136;
  unsigned __int8 v137;
  unsigned __int8 v138;
  unsigned __int8 v139;
  unsigned __int8 v140;
  unsigned __int8 v141;
  unsigned __int8 v142;
  unsigned __int8 v143;
  unsigned __int8 v144;
  unsigned __int8 v145;
  unsigned __int8 v146;
  unsigned __int8 v147;
  unsigned __int8 v148;
  unsigned __int8 v149;
  unsigned __int8 v150;
  unsigned __int8 v151;
  unsigned __int8 v152;
  unsigned __int8 v153;
  unsigned __int8 v154;
  unsigned __int8 v155;
  unsigned __int8 v156;
  unsigned __int8 v157;
  unsigned __int8 v158;
  unsigned __int8 v159;
  unsigned __int8 v160;
  HG_RENDERER_ENV *v161;
  unsigned __int8 v162;
  _QWORD *v163;
  _QWORD *v164;
  void *__p[2];
  char v166;
  char v167;
  __int128 v168;
  unsigned __int16 v169;
  char v170;
  char v171;
  _BYTE v172[19];
  char v173;
  char v174;
  _BYTE v175[21];
  char v176;
  char v177;
  int __c[2];
  unsigned __int16 v179;
  char v180;
  char v181;
  void **__dst;
  size_t v183;
  int64_t v184;
  _BYTE v185[32];

  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  v164 = (_QWORD *)((char *)this + 24);
  *(_OWORD *)this = 0u;
  HGLogger::setLevel((HGLogger *)"envInit", 0);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v185, "envInit", 1, "HG_RENDERER_ENV::HG_RENDERER_ENV()");
  v2 = getenv("HG_ENABLE_LOGGER");
  if (v2)
    atomic_store(atoi(v2) != 0, HGLogger::_enabled);
  v3 = getenv("HG_ENV_NO_FLUSH_OPT");
  if (v3)
    HG_RENDERER_ENV::NO_FLUSH_OPT = atoi(v3);
  v4 = getenv("HG_ENV_LOW_MEMORY_USAGE");
  if (v4)
    HG_RENDERER_ENV::LOW_MEMORY_USAGE = atoi(v4);
  v5 = getenv("HG_ENV_TRACK_TEXTURE_USAGE");
  if (v5)
    HG_RENDERER_ENV::TRACK_TEXTURE_USAGE = atoi(v5);
  v6 = getenv("HG_ENV_VALIDATE_CURRENT_GL_CONTEXT");
  if (v6)
    HG_RENDERER_ENV::VALIDATE_CURRENT_GL_CONTEXT = atoi(v6);
  if (getenv("HG_ENV_USE_V210_BGRA_FORMAT"))
    HGLogger::warning((HGLogger *)"HG_ENV_USE_V210_BGRA_FORMAT is deprecated.", v7, v8);
  v9 = getenv("HG_ENV_SCISSORED_LARGE_TRI_TILES");
  if (v9)
    HG_RENDERER_ENV::SCISSORED_LARGE_TRI_TILES = atoi(v9);
  v10 = getenv("HG_ENV_SCISSORED_LARGE_TRI_TILES_WIDTH");
  if (v10)
    HG_RENDERER_ENV::SCISSORED_LARGE_TRI_TILES_WIDTH = atoi(v10);
  v11 = getenv("HG_ENV_FORCE_PAGE_SIZE");
  if (v11)
    HG_RENDERER_ENV::FORCE_PAGE_SIZE = atoi(v11);
  v12 = getenv("HG_ENV_FORCE_NO_PBO_READBACK");
  if (v12)
    HG_RENDERER_ENV::FORCE_NO_PBO_READBACK = atoi(v12);
  if (getenv("HG_ENV_FORCE_INTERLEAVED_RENDER_READBACK"))
    HGLogger::warning((HGLogger *)"HG_ENV_FORCE_INTERLEAVED_RENDER_READBACK is deprecated.", v13, v14);
  v15 = getenv("HG_ENV_FORCE_TEXTURE_STORAGE_HINT");
  if (v15)
  {
    v16 = v15;
    v17 = strlen(v15);
    if (v17 > 0x7FFFFFFFFFFFFFF7)
      std::string::__throw_length_error[abi:ne180100]();
    v20 = v17;
    if (v17 >= 0x17)
    {
      v22 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v17 | 7) != 0x17)
        v22 = v17 | 7;
      v23 = v22 + 1;
      p_dst = (void **)operator new(v22 + 1);
      v183 = v20;
      v184 = v23 | 0x8000000000000000;
      __dst = p_dst;
    }
    else
    {
      HIBYTE(v184) = v17;
      p_dst = (void **)&__dst;
      if (!v17)
      {
LABEL_32:
        *((_BYTE *)p_dst + v20) = 0;
        v181 = 7;
        strcpy((char *)__c, "PRIVATE");
        v177 = 6;
        strcpy(v175, "CACHED");
        v174 = 6;
        strcpy(v172, "SHARED");
        if (v184 >= 0)
          v24 = (void **)&__dst;
        else
          v24 = __dst;
        v25 = v24;
        if (v184 >= 0)
          v26 = HIBYTE(v184);
        else
          v26 = v183;
        v27 = (char *)v24 + v26;
        if (v26 > 6)
        {
          v28 = v26;
          v29 = v24;
          do
          {
            v30 = (char *)memchr(v29, SLOBYTE(__c[0]), v28 - 6);
            if (!v30)
              break;
            if (*(_DWORD *)v30 == __c[0] && *(_DWORD *)(v30 + 3) == *(int *)((char *)__c + 3))
            {
              if (v30 != v27 && v30 - (char *)v24 != -1)
              {
                v32 = 0;
                goto LABEL_72;
              }
              break;
            }
            v29 = (void **)(v30 + 1);
            v28 = v27 - (char *)v29;
          }
          while (v27 - (char *)v29 > 6);
        }
        if (v26 >= 6)
        {
          v33 = v26;
          v34 = v24;
          while (1)
          {
            v35 = (char *)memchr(v34, v175[0], v33 - 5);
            if (!v35)
              goto LABEL_62;
            if (*(_DWORD *)v35 == *(_DWORD *)v175 && *((unsigned __int16 *)v35 + 2) == *(unsigned __int16 *)&v175[4])
              break;
            v34 = (void **)(v35 + 1);
            v33 = v27 - (char *)v34;
            if (v27 - (char *)v34 < 6)
              goto LABEL_62;
          }
          if (v35 != v27 && v35 - (char *)v24 != -1)
          {
            v32 = 1;
LABEL_72:
            HG_RENDERER_ENV::FORCE_TEXTURE_STORAGE_HINT = v32;
            goto LABEL_74;
          }
LABEL_62:
          do
          {
            v37 = (char *)memchr(v25, v172[0], v26 - 5);
            if (!v37)
              break;
            if (*(_DWORD *)v37 == *(_DWORD *)v172 && *((unsigned __int16 *)v37 + 2) == *(unsigned __int16 *)&v172[4])
            {
              if (v37 != v27 && v37 - (char *)v24 != -1)
              {
                v32 = 2;
                goto LABEL_72;
              }
              break;
            }
            v25 = (void **)(v37 + 1);
            v26 = v27 - (v37 + 1);
          }
          while (v26 >= 6);
        }
        HGLogger::warning((HGLogger *)"invalid FORCE_TEXTURE_STORAGE_HINT value", v18, v19);
LABEL_74:
        if (SHIBYTE(v184) < 0)
          operator delete(__dst);
        goto LABEL_76;
      }
    }
    memmove(p_dst, v16, v20);
    goto LABEL_32;
  }
LABEL_76:
  v39 = getenv("HG_ENV_FORCE_FULLSIZE_TEXTURE_UPLOAD");
  if (v39)
    HG_RENDERER_ENV::FORCE_FULLSIZE_TEXTURE_UPLOAD = atoi(v39);
  v40 = getenv("HG_ENV_METAL_BLIT_MAX_TILE_SIZE_MB");
  if (v40)
    HG_RENDERER_ENV::METAL_BLIT_MAX_TILE_SIZE_MB = atoi(v40);
  v41 = getenv("HG_ENV_WAIT_FOR_QUEUED_TEXTURE_ONE_BY_ONE");
  if (v41)
    HG_RENDERER_ENV::WAIT_FOR_QUEUED_TEXTURE_ONE_BY_ONE = atoi(v41);
  v42 = getenv("HG_ENV_METAL_MAX_ENCODERS_PER_BUFFER");
  if (v42)
    HG_RENDERER_ENV::METAL_MAX_ENCODERS_PER_BUFFER = atoi(v42);
  v43 = getenv("HG_ENV_METAL_MAX_COMMAND_BUFFERS_COUNT");
  if (v43)
    HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_COUNT = atoi(v43);
  v44 = getenv("HG_ENV_METAL_MAX_COMMAND_BUFFERS_MEMORY");
  if (v44)
    HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_MEMORY = atoi(v44);
  v45 = getenv("HG_ENV_FORCE_CLUSTERED_TEXTURE_PADDING");
  if (v45)
    HG_RENDERER_ENV::FORCE_CLUSTERED_TEXTURE_PADDING = atoi(v45);
  v46 = getenv("HG_ENV_TEX_PADDING_REMEMBRANCE");
  if (v46)
    HG_RENDERER_ENV::TEX_PADDING_REMEMBRANCE = atoi(v46);
  v47 = getenv("HG_ENV_TEX_PADDING_CUSHIONING");
  if (v47)
    HG_RENDERER_ENV::TEX_PADDING_CUSHIONING = atoi(v47);
  v48 = getenv("HG_ENV_TEX_PADDING_CLUMPING");
  if (v48)
    HG_RENDERER_ENV::TEX_PADDING_CLUMPING = atoi(v48);
  v49 = getenv("HG_ENV_FORCE_LEGACY_TEXTURE_POOLING");
  if (v49)
    HG_RENDERER_ENV::FORCE_LEGACY_TEXTURE_POOLING = atoi(v49);
  v50 = getenv("HG_ENV_TEXTURE_POOL_STRATEGY");
  if (!v50)
    goto LABEL_176;
  v51 = v50;
  v52 = strlen(v50);
  if (v52 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v53 = v52;
  if (v52 >= 0x17)
  {
    v55 = (v52 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v52 | 7) != 0x17)
      v55 = v52 | 7;
    v56 = v55 + 1;
    v54 = (void **)operator new(v55 + 1);
    v183 = v53;
    v184 = v56 | 0x8000000000000000;
    __dst = v54;
    goto LABEL_106;
  }
  HIBYTE(v184) = v52;
  v54 = (void **)&__dst;
  if (v52)
LABEL_106:
    memmove(v54, v51, v53);
  *((_BYTE *)v54 + v53) = 0;
  v181 = 10;
  v179 = 22862;
  *(_QWORD *)__c = *(_QWORD *)"OLDEST_ANY";
  v177 = 21;
  qmemcpy(v175, "OLDEST_CLIENT_STORAGE", sizeof(v175));
  v174 = 19;
  qmemcpy(v172, "OLDEST_INTERMEDIATE", sizeof(v172));
  v171 = 18;
  v169 = 17735;
  v168 = *(_OWORD *)"ALL_CLIENT_STORAGE";
  v167 = 16;
  if (v184 >= 0)
    v57 = (void **)&__dst;
  else
    v57 = __dst;
  v180 = 0;
  v176 = 0;
  v173 = 0;
  v170 = 0;
  *(_OWORD *)__p = *(_OWORD *)"ALL_INTERMEDIATE";
  if (v184 >= 0)
    v58 = HIBYTE(v184);
  else
    v58 = v183;
  v166 = 0;
  if (v58 >= 10)
  {
    v59 = (char *)v57 + v58;
    v60 = v58;
    v61 = v57;
    do
    {
      v62 = (char *)memchr(v61, 79, v60 - 9);
      if (!v62)
        break;
      if (*(_QWORD *)v62 == *(_QWORD *)__c && *((unsigned __int16 *)v62 + 4) == (unint64_t)v179)
      {
        if (v62 != v59 && v62 - (char *)v57 != -1)
        {
          v64 = 0;
          goto LABEL_172;
        }
        break;
      }
      v61 = (void **)(v62 + 1);
      v60 = v59 - (char *)v61;
    }
    while (v59 - (char *)v61 >= 10);
    if (v58 >= 21)
    {
      v65 = v58;
      v66 = v57;
      do
      {
        v67 = (char *)memchr(v66, 79, v65 - 20);
        if (!v67)
          break;
        if (*(_QWORD *)v67 == *(_QWORD *)v175
          && *((_QWORD *)v67 + 1) == *(_QWORD *)&v175[8]
          && *(_QWORD *)(v67 + 13) == *(_QWORD *)&v175[13])
        {
          if (v67 != v59 && v67 - (char *)v57 != -1)
          {
            v64 = 1;
            goto LABEL_172;
          }
          break;
        }
        v66 = (void **)(v67 + 1);
        v65 = v59 - (char *)v66;
      }
      while (v59 - (char *)v66 >= 21);
    }
    if (v58 > 18)
    {
      v70 = v58;
      v71 = v57;
      do
      {
        v72 = (char *)memchr(v71, 79, v70 - 18);
        if (!v72)
          break;
        if (*(_QWORD *)v72 == *(_QWORD *)v172
          && *((_QWORD *)v72 + 1) == *(_QWORD *)&v172[8]
          && *(_QWORD *)(v72 + 11) == *(_QWORD *)&v172[11])
        {
          if (v72 != v59 && v72 - (char *)v57 != -1)
          {
            v64 = 2;
            goto LABEL_172;
          }
          break;
        }
        v71 = (void **)(v72 + 1);
        v70 = v59 - (char *)v71;
      }
      while (v59 - (char *)v71 > 18);
    }
    if (v58 >= 18)
    {
      v75 = v57;
      do
      {
        v76 = (char *)memchr(v75, 65, v58 - 17);
        if (!v76)
          break;
        if (*(_QWORD *)v76 == (_QWORD)v168
          && *((_QWORD *)v76 + 1) == *((_QWORD *)&v168 + 1)
          && *((unsigned __int16 *)v76 + 8) == (unint64_t)v169)
        {
          if (v76 != v59 && v76 - (char *)v57 != -1)
          {
            v64 = 3;
            goto LABEL_172;
          }
          break;
        }
        v75 = (void **)(v76 + 1);
        v58 = v59 - (char *)v75;
      }
      while (v59 - (char *)v75 >= 18);
    }
  }
  if (std::string::find[abi:ne180100]((uint64_t *)&__dst, (char *)__p, 0) == -1)
  {
    HGLogger::warning((HGLogger *)"invalid TEXTURE_POOL_STRATEGY value", v79, v80);
  }
  else
  {
    v64 = 4;
LABEL_172:
    HG_RENDERER_ENV::TEXTURE_POOL_STRATEGY = v64;
  }
  if (v167 < 0)
  {
    operator delete(__p[0]);
    if (SHIBYTE(v184) < 0)
      goto LABEL_327;
LABEL_176:
    v81 = getenv("HG_ENV_MAX_TEXTURE_AGE_MS");
    v82 = &unk_1EF06E000;
    if (!v81)
      goto LABEL_178;
    goto LABEL_177;
  }
  if ((SHIBYTE(v184) & 0x80000000) == 0)
    goto LABEL_176;
LABEL_327:
  operator delete(__dst);
  v81 = getenv("HG_ENV_MAX_TEXTURE_AGE_MS");
  v82 = (_DWORD *)&unk_1EF06E000;
  if (v81)
LABEL_177:
    v82[856] = atoi(v81);
LABEL_178:
  v83 = getenv("HG_ENV_MAX_TEXTURE_POOL_SIZE_PERCENT");
  if (v83)
    HG_RENDERER_ENV::MAX_TEXTURE_POOL_SIZE_PERCENT = atoi(v83);
  v84 = getenv("HG_ENV_MAX_TEXTURE_QUEUE_SIZE_PERCENT");
  if (v84)
    HG_RENDERER_ENV::MAX_TEXTURE_QUEUE_SIZE_PERCENT = atoi(v84);
  v85 = getenv("HG_ENV_MAX_TEXTURE_UNUSED_SIZE_PERCENT");
  if (v85)
    HG_RENDERER_ENV::MAX_TEXTURE_UNUSED_SIZE_PERCENT = atoi(v85);
  v86 = getenv("HG_ENV_MAX_TEXTURE_TOTAL_SIZE_PERCENT");
  if (v86)
    HG_RENDERER_ENV::MAX_TEXTURE_TOTAL_SIZE_PERCENT = atoi(v86);
  v87 = getenv("HG_ENV_IGNORE_LOADER_CHECK_FOR_CVCACHE");
  if (v87)
    HG_RENDERER_ENV::IGNORE_LOADER_CHECK_FOR_CVCACHE = atoi(v87);
  v88 = getenv("HG_ENV_METAL_UPLOAD_TEXTURE_CREATION_STRATEGY");
  if (v88)
    HG_RENDERER_ENV::METAL_UPLOAD_TEXTURE_CREATION_STRATEGY = atoi(v88);
  v89 = getenv("HG_ENV_CLIENT_STORAGE_RECYCLING_POLICY");
  if (v89)
    HG_RENDERER_ENV::CLIENT_STORAGE_RECYCLING_POLICY = atoi(v89);
  v90 = getenv("HG_ENV_FORCE_RECYCLE_SHARED_TEXTURES");
  if (v90)
    HG_RENDERER_ENV::FORCE_RECYCLE_SHARED_TEXTURES = atoi(v90);
  v91 = getenv("HG_ENV_LOAD_TEXTURE_TILE_ALIGNMENT");
  if (v91)
    HG_RENDERER_ENV::LOAD_TEXTURE_TILE_ALIGNMENT = atoi(v91);
  v92 = getenv("HG_ENV_FORCE_POST_RENDER_FINISH");
  if (v92)
    HG_RENDERER_ENV::FORCE_POST_RENDER_FINISH = atoi(v92);
  v93 = getenv("HG_ENV_FORCE_POST_READPIXELS_FINISH");
  if (v93)
    HG_RENDERER_ENV::FORCE_POST_READPIXELS_FINISH = atoi(v93);
  v94 = getenv("HG_ENV_FORCE_POST_READPIXELS_FENCE");
  if (v94)
    HG_RENDERER_ENV::FORCE_POST_READPIXELS_FENCE = atoi(v94);
  v95 = getenv("HG_ENV_FORCE_DEFAULT_METAL_DEVICE");
  if (v95)
    HG_RENDERER_ENV::FORCE_DEFAULT_METAL_DEVICE = atoi(v95);
  v96 = getenv("HG_ENV_FORCE_NATIVE_TEXTURE_OUTPUT");
  if (v96)
    HG_RENDERER_ENV::FORCE_NATIVE_TEXTURE_OUTPUT = atoi(v96);
  v97 = getenv("HG_ENV_LOG_LEVEL_INIT");
  if (v97)
    HG_RENDERER_ENV::LOG_LEVEL_INIT = atoi(v97);
  v98 = getenv("HG_ENV_LOG_LEVEL_TEXMANAGER");
  if (v98)
    HG_RENDERER_ENV::LOG_LEVEL_TEXMANAGER = atoi(v98);
  v99 = getenv("HG_ENV_LOG_LEVEL_GRAPH_DUMP");
  if (v99)
    HG_RENDERER_ENV::LOG_LEVEL_GRAPH_DUMP = atoi(v99);
  v100 = getenv("HG_ENV_LOG_LEVEL_GPU_TRACE");
  if (v100)
    HG_RENDERER_ENV::LOG_LEVEL_GPU_TRACE = atoi(v100);
  v101 = getenv("HG_ENV_LOG_LEVEL_GL_TRACE");
  if (v101)
  {
    v104 = v101;
    HGLogger::warning((HGLogger *)"HG_ENV_LOG_LEVEL_GL_TRACE is deprecated. Use HG_ENV_LOG_LEVEL_GPU_TRACE.", v102, v103);
    HG_RENDERER_ENV::LOG_LEVEL_GPU_TRACE = atoi(v104);
  }
  v105 = getenv("HG_ENV_FORCE_SINGLE_DOT_FILE");
  if (v105)
    HG_RENDERER_ENV::FORCE_SINGLE_DOT_FILE = atoi(v105);
  v106 = getenv("HG_ENV_DOT_GRAPH_OUTPUT_DIR");
  if (v106)
    MEMORY[0x1B5E28D80](this, v106);
  v107 = getenv("HG_ENV_BUFFER_DUMP_DIR");
  if (v107)
    MEMORY[0x1B5E28D80](v164, v107);
  v108 = getenv("HG_ENV_LOG_LEVEL_COLORCONFORM_DUMP");
  if (v108)
    HG_RENDERER_ENV::LOG_LEVEL_COLORCONFORM_DUMP = atoi(v108);
  v109 = getenv("HG_ENV_LOG_LEVEL_MTL_PERF_VALIDATION");
  if (v109)
    HG_RENDERER_ENV::LOG_LEVEL_MTL_PERF_VALIDATION = atoi(v109);
  v110 = getenv("SENSO_GENERAL_LOGLEVEL");
  if (v110)
  {
    v111 = (const char *)strtol(v110, 0, 0);
    v112 = getenv("SENSO_PERFORMANCE_LOGLEVEL");
    if (v112)
      goto LABEL_228;
LABEL_231:
    v115 = 0;
    v117 = atomic_load(HGLogger::_enabled);
    if ((v117 & 1) == 0)
      goto LABEL_233;
    goto LABEL_232;
  }
  v111 = 0;
  v112 = getenv("SENSO_PERFORMANCE_LOGLEVEL");
  if (!v112)
    goto LABEL_231;
LABEL_228:
  v115 = (const char *)strtol(v112, 0, 0);
  v116 = atomic_load(HGLogger::_enabled);
  if ((v116 & 1) != 0)
LABEL_232:
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  NO_FLUSH_OPT                  : %d\n", v113, v114, HG_RENDERER_ENV::NO_FLUSH_OPT);
LABEL_233:
  v118 = atomic_load(HGLogger::_enabled);
  if ((v118 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOW_MEMORY_USAGE              : %d\n", v113, v114, HG_RENDERER_ENV::LOW_MEMORY_USAGE);
  v119 = atomic_load(HGLogger::_enabled);
  if ((v119 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  TRACK_TEXTURE_USAGE           : %d\n", v113, v114, HG_RENDERER_ENV::TRACK_TEXTURE_USAGE);
  v120 = atomic_load(HGLogger::_enabled);
  if ((v120 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  VALIDATE_CURRENT_GL_CONTEXT   : %d\n", v113, v114, HG_RENDERER_ENV::VALIDATE_CURRENT_GL_CONTEXT);
  v121 = atomic_load(HGLogger::_enabled);
  if ((v121 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  SCISSORED_LARGE_TRI_TILES     : %d\n", v113, v114, HG_RENDERER_ENV::SCISSORED_LARGE_TRI_TILES);
  v122 = atomic_load(HGLogger::_enabled);
  if ((v122 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  SCISSORED_LARGE_TRI_TILES_WIDTH : %d\n", v113, v114, HG_RENDERER_ENV::SCISSORED_LARGE_TRI_TILES_WIDTH);
  v123 = atomic_load(HGLogger::_enabled);
  if ((v123 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_PAGE_SIZE               : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_PAGE_SIZE);
  v124 = atomic_load(HGLogger::_enabled);
  if ((v124 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_NO_PBO_READBACK         : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_NO_PBO_READBACK);
  v125 = atomic_load(HGLogger::_enabled);
  if ((v125 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_TEXTURE_STORAGE_HINT    : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_TEXTURE_STORAGE_HINT);
  v126 = atomic_load(HGLogger::_enabled);
  if ((v126 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_FULLSIZE_TEXTURE_UPLOAD : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_FULLSIZE_TEXTURE_UPLOAD);
  v127 = atomic_load(HGLogger::_enabled);
  if ((v127 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  METAL_BLIT_MAX_TILE_SIZE_MB   : %d\n", v113, v114, HG_RENDERER_ENV::METAL_BLIT_MAX_TILE_SIZE_MB);
  v128 = atomic_load(HGLogger::_enabled);
  if ((v128 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  WAIT_FOR_QUEUED_TEXTURE_ONE_BY_ONE : %d\n", v113, v114, HG_RENDERER_ENV::WAIT_FOR_QUEUED_TEXTURE_ONE_BY_ONE);
  v129 = atomic_load(HGLogger::_enabled);
  if ((v129 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  METAL_MAX_ENCODERS_PER_BUFFER : %d\n", v113, v114, HG_RENDERER_ENV::METAL_MAX_ENCODERS_PER_BUFFER);
  v130 = atomic_load(HGLogger::_enabled);
  if ((v130 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  METAL_MAX_COMMAND_BUFFERS_COUNT : %d\n", v113, v114, HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_COUNT);
  v131 = atomic_load(HGLogger::_enabled);
  if ((v131 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  METAL_MAX_COMMAND_BUFFERS_MEMORY : %d\n", v113, v114, HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_MEMORY);
  v132 = atomic_load(HGLogger::_enabled);
  if ((v132 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_CLUSTERED_TEXTURE_PADDING  : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_CLUSTERED_TEXTURE_PADDING);
  v133 = atomic_load(HGLogger::_enabled);
  if ((v133 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  TEX_PADDING_REMEMBRANCE       : %d\n", v113, v114, HG_RENDERER_ENV::TEX_PADDING_REMEMBRANCE);
  v134 = atomic_load(HGLogger::_enabled);
  if ((v134 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  TEX_PADDING_CUSHIONING        : %d\n", v113, v114, HG_RENDERER_ENV::TEX_PADDING_CUSHIONING);
  v135 = atomic_load(HGLogger::_enabled);
  if ((v135 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  TEX_PADDING_CLUMPING          : %d\n", v113, v114, HG_RENDERER_ENV::TEX_PADDING_CLUMPING);
  v136 = atomic_load(HGLogger::_enabled);
  if ((v136 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_LEGACY_TEXTURE_POOLING  : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_LEGACY_TEXTURE_POOLING);
  v137 = atomic_load(HGLogger::_enabled);
  if ((v137 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  TEXTURE_POOL_STRATEGY         : %d\n", v113, v114, HG_RENDERER_ENV::TEXTURE_POOL_STRATEGY);
  v138 = atomic_load(HGLogger::_enabled);
  if ((v138 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  MAX_TEXTURE_AGE_MS            : %d\n", v113, v114, HG_RENDERER_ENV::MAX_TEXTURE_AGE_MS);
  v139 = atomic_load(HGLogger::_enabled);
  if ((v139 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  MAX_TEXTURE_POOL_SIZE_PERCENT   : %d\n", v113, v114, HG_RENDERER_ENV::MAX_TEXTURE_POOL_SIZE_PERCENT);
  v140 = atomic_load(HGLogger::_enabled);
  if ((v140 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  MAX_TEXTURE_QUEUE_SIZE_PERCENT  : %d\n", v113, v114, HG_RENDERER_ENV::MAX_TEXTURE_QUEUE_SIZE_PERCENT);
  v141 = atomic_load(HGLogger::_enabled);
  if ((v141 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  MAX_TEXTURE_UNUSED_SIZE_PERCENT : %d\n", v113, v114, HG_RENDERER_ENV::MAX_TEXTURE_UNUSED_SIZE_PERCENT);
  v142 = atomic_load(HGLogger::_enabled);
  if ((v142 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  MAX_TEXTURE_TOTAL_SIZE_PERCENT  : %d\n", v113, v114, HG_RENDERER_ENV::MAX_TEXTURE_TOTAL_SIZE_PERCENT);
  v143 = atomic_load(HGLogger::_enabled);
  if ((v143 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  IGNORE_LOADER_CHECK_FOR_CVCACHE : %d\n", v113, v114, HG_RENDERER_ENV::IGNORE_LOADER_CHECK_FOR_CVCACHE);
  v144 = atomic_load(HGLogger::_enabled);
  if ((v144 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  METAL_UPLOAD_TEXTURE_CREATION_STRATEGY : %d\n", v113, v114, HG_RENDERER_ENV::METAL_UPLOAD_TEXTURE_CREATION_STRATEGY);
  v145 = atomic_load(HGLogger::_enabled);
  if ((v145 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  CLIENT_STORAGE_RECYCLING_POLICY : %d\n", v113, v114, HG_RENDERER_ENV::CLIENT_STORAGE_RECYCLING_POLICY);
  v146 = atomic_load(HGLogger::_enabled);
  if ((v146 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_RECYCLE_SHARED_TEXTURES : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_RECYCLE_SHARED_TEXTURES);
  v147 = atomic_load(HGLogger::_enabled);
  if ((v147 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOAD_TEXTURE_TILE_ALIGNMENT   : %d\n", v113, v114, HG_RENDERER_ENV::LOAD_TEXTURE_TILE_ALIGNMENT);
  v148 = atomic_load(HGLogger::_enabled);
  if ((v148 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_POST_RENDER_FINISH      : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_POST_RENDER_FINISH);
  v149 = atomic_load(HGLogger::_enabled);
  if ((v149 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_POST_READPIXELS_FINISH  : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_POST_READPIXELS_FINISH);
  v150 = atomic_load(HGLogger::_enabled);
  if ((v150 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_POST_READPIXELS_FENCE   : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_POST_READPIXELS_FENCE);
  v151 = atomic_load(HGLogger::_enabled);
  if ((v151 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_DEFAULT_METAL_DEVICE    : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_DEFAULT_METAL_DEVICE);
  v152 = atomic_load(HGLogger::_enabled);
  if ((v152 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_NATIVE_TEXTURE_OUTPUT   : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_NATIVE_TEXTURE_OUTPUT);
  v153 = atomic_load(HGLogger::_enabled);
  if ((v153 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOG_LEVEL_INIT                : %d\n", v113, v114, HG_RENDERER_ENV::LOG_LEVEL_INIT);
  v154 = atomic_load(HGLogger::_enabled);
  if ((v154 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOG_LEVEL_TEXMANAGER          : %d\n", v113, v114, HG_RENDERER_ENV::LOG_LEVEL_TEXMANAGER);
  v155 = atomic_load(HGLogger::_enabled);
  if ((v155 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOG_LEVEL_GRAPH_DUMP          : %d\n", v113, v114, HG_RENDERER_ENV::LOG_LEVEL_GRAPH_DUMP);
  v156 = atomic_load(HGLogger::_enabled);
  if ((v156 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOG_LEVEL_GPU_TRACE           : %d\n", v113, v114, HG_RENDERER_ENV::LOG_LEVEL_GPU_TRACE);
  v157 = atomic_load(HGLogger::_enabled);
  if ((v157 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOG_LEVEL_COLORCONFORM_DUMP   : %d\n", v113, v114, HG_RENDERER_ENV::LOG_LEVEL_COLORCONFORM_DUMP);
  v158 = atomic_load(HGLogger::_enabled);
  if ((v158 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOG_LEVEL_MTL_PERF_VALIDATION : %d\n", v113, v114, HG_RENDERER_ENV::LOG_LEVEL_MTL_PERF_VALIDATION);
  v159 = atomic_load(HGLogger::_enabled);
  if ((v159 & 1) != 0)
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_SINGLE_DOT_FILE         : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_SINGLE_DOT_FILE);
  v160 = atomic_load(HGLogger::_enabled);
  if ((v160 & 1) != 0)
  {
    v161 = this;
    if (*((char *)this + 23) < 0)
      v161 = *(HG_RENDERER_ENV **)this;
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  DOT_GRAPH_OUTPUT_DIR          : %s\n", v113, v114, v161);
  }
  v162 = atomic_load(HGLogger::_enabled);
  if ((v162 & 1) != 0)
  {
    v163 = v164;
    if (*((char *)this + 47) < 0)
      v163 = (_QWORD *)*v164;
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  BUFFER_DUMP_DIR               : %s\n", v113, v114, v163);
  }
  HGLogger::setLevel((HGLogger *)"init", (const char *)HG_RENDERER_ENV::LOG_LEVEL_INIT);
  HGLogger::setLevel((HGLogger *)"texManager", (const char *)HG_RENDERER_ENV::LOG_LEVEL_TEXMANAGER);
  HGLogger::setLevel((HGLogger *)"graph", (const char *)HG_RENDERER_ENV::LOG_LEVEL_GRAPH_DUMP);
  HGLogger::setLevel((HGLogger *)"gpu", (const char *)HG_RENDERER_ENV::LOG_LEVEL_GPU_TRACE);
  HGLogger::setLevel((HGLogger *)"colorConform", (const char *)HG_RENDERER_ENV::LOG_LEVEL_COLORCONFORM_DUMP);
  HGLogger::setLevel((HGLogger *)"mtl_perf_validation", (const char *)HG_RENDERER_ENV::LOG_LEVEL_MTL_PERF_VALIDATION);
  HGLogger::setLevel((HGLogger *)HGSensoLogging::sGeneral[0], v111);
  HGLogger::setLevel((HGLogger *)HGSensoLogging::sPerformance, v115);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v185);
}

void sub_1B2A7A314(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  uint64_t v16;
  uint64_t v17;

  if (a16 < 0)
    operator delete(__p);
  if (*(char *)(v17 - 113) < 0)
    operator delete(*(void **)(v17 - 136));
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v17 - 112));
  if (*(char *)(v16 + 47) < 0)
  {
    operator delete(*a10);
    if ((*(char *)(v16 + 23) & 0x80000000) == 0)
LABEL_7:
      _Unwind_Resume(a1);
  }
  else if ((*(char *)(v16 + 23) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }
  operator delete(*(void **)v16);
  _Unwind_Resume(a1);
}

uint64_t std::string::find[abi:ne180100](uint64_t *a1, char *a2, unint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  int v5;
  char *v6;
  int64_t v7;
  void *v9;
  char *v10;
  int64_t v11;
  char *v12;
  int v13;
  uint64_t v14;
  char *v15;

  v3 = (uint64_t)a1;
  if (*((char *)a1 + 23) < 0)
  {
    v3 = *a1;
    v4 = a1[1];
  }
  else
  {
    v4 = *((unsigned __int8 *)a1 + 23);
  }
  v5 = a2[23];
  if (v5 >= 0)
    v6 = a2;
  else
    v6 = *(char **)a2;
  if (v5 >= 0)
    v7 = a2[23];
  else
    v7 = *((_QWORD *)a2 + 1);
  if (v4 < a3)
    return -1;
  if (v7)
  {
    v9 = (void *)(v3 + a3);
    v10 = (char *)(v3 + v4);
    v11 = v4 - a3;
    if (v11 >= v7)
    {
      v13 = *v6;
      do
      {
        v14 = v11 - v7;
        if (v14 == -1)
          break;
        v15 = (char *)memchr(v9, v13, v14 + 1);
        if (!v15)
          break;
        v12 = v15;
        if (!memcmp(v15, v6, v7))
          goto LABEL_16;
        v9 = v12 + 1;
        v11 = v10 - (v12 + 1);
      }
      while (v11 >= v7);
    }
    v12 = v10;
LABEL_16:
    if (v12 == v10)
      return -1;
    else
      return (uint64_t)&v12[-v3];
  }
  return a3;
}

void HG_RENDERER_ENV::DOT_GRAPH_OUTPUT_DIR(std::string *a1@<X8>)
{
  unsigned __int8 v3;

  v3 = atomic_load((unsigned __int8 *)&byte_1ED4DAA10);
  if ((v3 & 1) == 0 && __cxa_guard_acquire((__guard *)&byte_1ED4DAA10))
  {
    HG_RENDERER_ENV::HG_RENDERER_ENV((HG_RENDERER_ENV *)&xmmword_1ED4DAA48);
    __cxa_atexit((void (*)(void *))HGProgramDescriptor::Dependency::~Dependency, &xmmword_1ED4DAA48, &dword_1B2737000);
    __cxa_guard_release((__guard *)&byte_1ED4DAA10);
  }
  if (byte_1ED4DAA5F < 0)
  {
    std::string::__init_copy_ctor_external(a1, (const std::string::value_type *)xmmword_1ED4DAA48, *((std::string::size_type *)&xmmword_1ED4DAA48 + 1));
  }
  else
  {
    *(_OWORD *)&a1->__r_.__value_.__l.__data_ = xmmword_1ED4DAA48;
    a1->__r_.__value_.__r.__words[2] = unk_1ED4DAA58;
  }
}

void sub_1B2A7A540(_Unwind_Exception *a1)
{
  __cxa_guard_abort((__guard *)&byte_1ED4DAA10);
  _Unwind_Resume(a1);
}

void HG_RENDERER_ENV::BUFFER_DUMP_DIR(std::string *a1@<X8>)
{
  unsigned __int8 v3;

  v3 = atomic_load((unsigned __int8 *)&byte_1ED4DAA10);
  if ((v3 & 1) == 0 && __cxa_guard_acquire((__guard *)&byte_1ED4DAA10))
  {
    HG_RENDERER_ENV::HG_RENDERER_ENV((HG_RENDERER_ENV *)&xmmword_1ED4DAA48);
    __cxa_atexit((void (*)(void *))HGProgramDescriptor::Dependency::~Dependency, &xmmword_1ED4DAA48, &dword_1B2737000);
    __cxa_guard_release((__guard *)&byte_1ED4DAA10);
  }
  if (byte_1ED4DAA77 < 0)
  {
    std::string::__init_copy_ctor_external(a1, (const std::string::value_type *)xmmword_1ED4DAA60, *((std::string::size_type *)&xmmword_1ED4DAA60 + 1));
  }
  else
  {
    *(_OWORD *)&a1->__r_.__value_.__l.__data_ = xmmword_1ED4DAA60;
    a1->__r_.__value_.__r.__words[2] = unk_1ED4DAA70;
  }
}

void sub_1B2A7A608(_Unwind_Exception *a1)
{
  __cxa_guard_abort((__guard *)&byte_1ED4DAA10);
  _Unwind_Resume(a1);
}

void HG_RENDERER_ENV::Init(HG_RENDERER_ENV *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&byte_1ED4DAA10);
  if ((v1 & 1) == 0)
  {
    if (__cxa_guard_acquire((__guard *)&byte_1ED4DAA10))
    {
      HG_RENDERER_ENV::HG_RENDERER_ENV((HG_RENDERER_ENV *)&xmmword_1ED4DAA48);
      __cxa_atexit((void (*)(void *))HGProgramDescriptor::Dependency::~Dependency, &xmmword_1ED4DAA48, &dword_1B2737000);
      __cxa_guard_release((__guard *)&byte_1ED4DAA10);
    }
  }
}

void sub_1B2A7A690(_Unwind_Exception *a1)
{
  __cxa_guard_abort((__guard *)&byte_1ED4DAA10);
  _Unwind_Resume(a1);
}

void HGRendererOutput::HGRendererOutput(HGRendererOutput *this, HGNode *a2, HGBitmap *a3)
{
  __int128 *v3;

  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = a3;
  v3 = (__int128 *)((char *)a3 + 20);
  if (!a3)
    v3 = &HGRectNull;
  *((_OWORD *)this + 1) = *v3;
  if (a3)
  {
    *((_QWORD *)this + 4) = *((unsigned int *)a3 + 4);
  }
  else
  {
    *((_DWORD *)this + 8) = 0;
    *((_DWORD *)this + 9) = 0;
  }
}

uint64_t HGRendererOutput::HGRendererOutput(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = a3;
  *(_QWORD *)(result + 24) = a4;
  *(_DWORD *)(result + 32) = a5;
  *(_DWORD *)(result + 36) = a6;
  return result;
}

void HGRenderer::HGRenderer(HGRenderer *this)
{
  uint64_t v2;
  _QWORD *v3;
  void **v4;
  unsigned __int8 v5;
  char *v6;
  _QWORD *v7;
  HGStats::GraphStats *v8;
  HGStats::RendererStats *v9;
  int v10;
  _QWORD *v11;
  _OWORD *CachedLimits;
  int v13;
  std::string::size_type size;
  std::string *p_p;
  std::string::size_type v16;
  std::string __p;

  HGObject::HGObject(this);
  *(_QWORD *)v2 = off_1E6525E00;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_DWORD *)(v2 + 72) = 0;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_DWORD *)(v2 + 96) = 0;
  *(_OWORD *)(v2 + 104) = 0u;
  *(_DWORD *)(v2 + 120) = 0;
  *(_OWORD *)(v2 + 128) = 0u;
  *(_DWORD *)(v2 + 144) = 0;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_DWORD *)(v2 + 168) = 0;
  *(_DWORD *)(v2 + 192) = 0;
  *(_OWORD *)(v2 + 176) = 0u;
  *(_OWORD *)(v2 + 200) = 0u;
  *(_DWORD *)(v2 + 216) = 0;
  *(_DWORD *)(v2 + 48) = 0;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 224) = 0u;
  v3 = (_QWORD *)(v2 + 552);
  *(_OWORD *)(v2 + 256) = 0u;
  *(_OWORD *)(v2 + 272) = 0u;
  *(_OWORD *)(v2 + 240) = 0u;
  *(_QWORD *)(v2 + 568) = 0;
  *(_OWORD *)(v2 + 552) = 0u;
  *(_OWORD *)(v2 + 576) = xmmword_1B35226D0;
  *(_OWORD *)(v2 + 592) = xmmword_1B35226E0;
  *(_OWORD *)(v2 + 608) = xmmword_1B35226F0;
  *(_OWORD *)(v2 + 624) = 0u;
  *(_OWORD *)(v2 + 640) = 0u;
  *(_QWORD *)(v2 + 656) = 0x4B000000000;
  *(_QWORD *)(v2 + 664) = 0x200000001;
  *(_OWORD *)(v2 + 672) = 0u;
  *(_OWORD *)(v2 + 688) = xmmword_1B3050E20;
  HGCache::HGCache((HGCache *)(v2 + 704));
  *((_WORD *)this + 404) = 256;
  *((_BYTE *)this + 810) = 0;
  *((_DWORD *)this + 208) = 1;
  HGDotGraph::HGDotGraph((HGRenderer *)((char *)this + 840));
  HGBufferDumper::HGBufferDumper((HGRenderer *)((char *)this + 928));
  *((_DWORD *)this + 254) = 0;
  v4 = (void **)((char *)this + 1024);
  *((_QWORD *)this + 128) = 0;
  *((_DWORD *)this + 262) = 0;
  *(_OWORD *)((char *)this + 1032) = 0u;
  *((_OWORD *)this + 66) = 0u;
  *((_DWORD *)this + 268) = 0;
  *((_QWORD *)this + 135) = 0;
  *((_QWORD *)this + 137) = 0;
  *((_QWORD *)this + 136) = 0;
  v5 = atomic_load((unsigned __int8 *)&byte_1ED4DAA10);
  if ((v5 & 1) == 0 && __cxa_guard_acquire((__guard *)&byte_1ED4DAA10))
  {
    HG_RENDERER_ENV::HG_RENDERER_ENV((HG_RENDERER_ENV *)&xmmword_1ED4DAA48);
    __cxa_atexit((void (*)(void *))HGProgramDescriptor::Dependency::~Dependency, &xmmword_1ED4DAA48, &dword_1B2737000);
    __cxa_guard_release((__guard *)&byte_1ED4DAA10);
  }
  *((_DWORD *)this + 149) = HGGetActiveCPU();
  *((_DWORD *)this + 268) = 0;
  v6 = getenv("ROI_DEBUG");
  if (v6)
    *((_DWORD *)this + 169) = atoi(v6);
  v7 = (_QWORD *)operator new();
  HGLUTCacheManager::HGLUTCacheManager(v7, (uint64_t)this);
  *v3 = v7;
  v8 = (HGStats::GraphStats *)operator new();
  HGStats::GraphStats::GraphStats(v8);
  *((_QWORD *)this + 70) = v8;
  v9 = (HGStats::RendererStats *)operator new();
  HGStats::RendererStats::RendererStats(v9);
  *((_QWORD *)this + 71) = v9;
  v10 = dword_1ED4DAA0C;
  if (!dword_1ED4DAA0C)
  {
    v10 = 0x1000000;
    dword_1ED4DAA0C = 0x1000000;
  }
  *((_DWORD *)this + 203) = v10;
  v11 = (_QWORD *)operator new();
  v11[2] = 0;
  v11[1] = 0;
  *v11 = v11 + 1;
  *((_QWORD *)this + 135) = v11;
  *((_QWORD *)this + 102) = HGRenderer::GetCachedLimits(this, *((_DWORD *)this + 203) | 0x60000u);
  CachedLimits = HGRenderer::GetCachedLimits(this, *((_DWORD *)this + 203) | 0x50000u);
  *((_QWORD *)this + 103) = CachedLimits;
  v13 = *((_DWORD *)this + 203);
  **((_DWORD **)this + 102) = v13;
  *(_DWORD *)CachedLimits = v13;
  *((_QWORD *)this + 35) = HGMalloc(128);
  pthread_rwlock_init((pthread_rwlock_t *)((char *)this + 288), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 488), 0);
  HG_RENDERER_ENV::DOT_GRAPH_OUTPUT_DIR(&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    size = __p.__r_.__value_.__l.__size_;
    operator delete(__p.__r_.__value_.__l.__data_);
    if (size)
      goto LABEL_8;
LABEL_12:
    MEMORY[0x1B5E28D80]((char *)this + 1024, "/var/tmp");
    goto LABEL_13;
  }
  if (!*((_BYTE *)&__p.__r_.__value_.__s + 23))
    goto LABEL_12;
LABEL_8:
  HG_RENDERER_ENV::DOT_GRAPH_OUTPUT_DIR(&__p);
  if (*((char *)this + 1047) < 0)
    operator delete(*v4);
  *(_OWORD *)v4 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
  *((_QWORD *)this + 130) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
LABEL_13:
  HG_RENDERER_ENV::BUFFER_DUMP_DIR(&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    v16 = __p.__r_.__value_.__l.__size_;
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v16)
      goto LABEL_15;
LABEL_21:
    HGBufferDumper::setPath((HGRenderer *)((char *)this + 928), "/var/tmp");
    goto LABEL_22;
  }
  if (!*((_BYTE *)&__p.__r_.__value_.__s + 23))
    goto LABEL_21;
LABEL_15:
  HG_RENDERER_ENV::BUFFER_DUMP_DIR(&__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  HGBufferDumper::setPath((HGRenderer *)((char *)this + 928), (const char *)p_p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_22:
  *((_DWORD *)this + 254) = ++HGRenderer::m_RendererCounter;
}

void sub_1B2A7AAB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;
  HGCache *v16;
  HGDotGraph *v17;
  void **v18;
  void **v19;
  void **v20;
  void *v22;
  void *v23;

  __cxa_guard_abort((__guard *)&byte_1ED4DAA10);
  if (*(char *)(v15 + 1047) < 0)
    operator delete(*v19);
  HGBufferDumper::~HGBufferDumper(v18);
  HGDotGraph::~HGDotGraph(v17);
  HGCache::~HGCache(v16);
  v22 = *(void **)(v15 + 248);
  if (v22)
  {
    *(_QWORD *)(v15 + 256) = v22;
    operator delete(v22);
    v23 = *v20;
    if (!*v20)
    {
LABEL_5:
      HGObject::~HGObject((HGObject *)v15);
      _Unwind_Resume(a1);
    }
  }
  else
  {
    v23 = *v20;
    if (!*v20)
      goto LABEL_5;
  }
  *(_QWORD *)(v15 + 232) = v23;
  operator delete(v23);
  HGObject::~HGObject((HGObject *)v15);
  _Unwind_Resume(a1);
}

_OWORD *HGRenderer::GetCachedLimits(HGRenderer *this, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  BOOL v10;
  uint64_t *v11;
  _OWORD *v12;
  uint64_t **v13;
  uint64_t *v14;
  uint64_t **v15;
  uint64_t **v16;
  unsigned int v17;
  _DWORD *v18;
  uint64_t *v19;
  uint64_t *v20;

  v4 = *((_QWORD *)this + 135);
  v7 = *(_QWORD *)(v4 + 8);
  v5 = v4 + 8;
  v6 = v7;
  if (v7)
  {
    v8 = v5;
    do
    {
      v9 = *(_DWORD *)(v6 + 32);
      v10 = v9 >= a2;
      if (v9 >= a2)
        v11 = (uint64_t *)v6;
      else
        v11 = (uint64_t *)(v6 + 8);
      if (v10)
        v8 = v6;
      v6 = *v11;
    }
    while (*v11);
    if (v8 != v5 && *(_DWORD *)(v8 + 32) <= a2)
      return *(_OWORD **)(v8 + 40);
  }
  v12 = (_OWORD *)operator new();
  *v12 = 0u;
  v12[1] = 0u;
  v12[2] = 0u;
  (*(void (**)(HGRenderer *, _OWORD *, uint64_t))(*(_QWORD *)this + 296))(this, v12, a2);
  v13 = (uint64_t **)*((_QWORD *)this + 135);
  v15 = v13 + 1;
  v14 = v13[1];
  if (v14)
  {
    while (1)
    {
      while (1)
      {
        v16 = (uint64_t **)v14;
        v17 = *((_DWORD *)v14 + 8);
        if (v17 <= a2)
          break;
        v14 = *v16;
        v15 = v16;
        if (!*v16)
          goto LABEL_19;
      }
      if (v17 >= a2)
        break;
      v14 = v16[1];
      if (!v14)
      {
        v15 = v16 + 1;
        goto LABEL_19;
      }
    }
  }
  else
  {
    v16 = v13 + 1;
LABEL_19:
    v18 = operator new(0x30uLL);
    v18[8] = a2;
    *((_QWORD *)v18 + 5) = v12;
    *(_QWORD *)v18 = 0;
    *((_QWORD *)v18 + 1) = 0;
    *((_QWORD *)v18 + 2) = v16;
    *v15 = (uint64_t *)v18;
    v19 = (uint64_t *)**v13;
    if (v19)
    {
      *v13 = v19;
      v20 = *v15;
    }
    else
    {
      v20 = (uint64_t *)v18;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v13[1], v20);
    v13[2] = (uint64_t *)((char *)v13[2] + 1);
  }
  return v12;
}

void HGRenderer::~HGRenderer(HGRenderer *this)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;
  HGStats::GraphStats *v8;
  HGStats::RendererStats *v9;
  HGLUTCacheManager *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  HGExecutionUnit *v16;
  void *v17;
  void *v18;

  *(_QWORD *)this = off_1E6525E00;
  v2 = *((_QWORD *)this + 135);
  v3 = *(_QWORD **)v2;
  if (*(_QWORD *)v2 == v2 + 8)
    goto LABEL_13;
  do
  {
    v4 = v3[5];
    if (v4)
      MEMORY[0x1B5E29170](v4, 0x1000C40EED21634);
    v3[5] = 0;
    v5 = (_QWORD *)v3[1];
    if (v5)
    {
      do
      {
        v6 = v5;
        v5 = (_QWORD *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        v6 = (_QWORD *)v3[2];
        v7 = *v6 == (_QWORD)v3;
        v3 = v6;
      }
      while (!v7);
    }
    v3 = v6;
  }
  while (v6 != (_QWORD *)(v2 + 8));
  v2 = *((_QWORD *)this + 135);
  if (v2)
  {
LABEL_13:
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v2, *(_QWORD **)(v2 + 8));
    MEMORY[0x1B5E29170](v2, 0x1020C4062D53EE8);
  }
  *((_OWORD *)this + 51) = 0u;
  v8 = (HGStats::GraphStats *)*((_QWORD *)this + 70);
  if (v8)
  {
    HGStats::GraphStats::~GraphStats(v8);
    MEMORY[0x1B5E29170]();
  }
  v9 = (HGStats::RendererStats *)*((_QWORD *)this + 71);
  if (v9)
  {
    HGStats::RendererStats::~RendererStats(v9);
    MEMORY[0x1B5E29170]();
  }
  v10 = (HGLUTCacheManager *)*((_QWORD *)this + 69);
  if (v10)
  {
    HGLUTCacheManager::~HGLUTCacheManager(v10);
    MEMORY[0x1B5E29170]();
  }
  (*(void (**)(HGRenderer *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_DWORD *)this + 30) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_DWORD *)this + 36) = 0;
  *((_DWORD *)this + 42) = 0;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_DWORD *)this + 54) = 0;
  v11 = *((_QWORD *)this + 29) - *((_QWORD *)this + 28);
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = 0;
  if ((int)(v11 >> 3) >= 1)
  {
    v12 = (v11 >> 3) + 1;
    do
    {
      v13 = *(_QWORD *)(*((_QWORD *)this + 28) + 8 * (v12 - 2));
      if (v13)
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
      --v12;
    }
    while (v12 > 1);
  }
  v14 = *((_QWORD *)this + 32) - *((_QWORD *)this + 31);
  if ((int)(v14 >> 3) >= 1)
  {
    v15 = (v14 >> 3) + 1;
    do
    {
      v16 = *(HGExecutionUnit **)(*((_QWORD *)this + 31) + 8 * (v15 - 2));
      if (v16)
      {
        HGExecutionUnit::~HGExecutionUnit(v16);
        MEMORY[0x1B5E29170]();
      }
      --v15;
    }
    while (v15 > 1);
  }
  HGFree(*((_QWORD *)this + 35));
  pthread_rwlock_destroy((pthread_rwlock_t *)((char *)this + 288));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 488));
  if (*((char *)this + 1047) < 0)
    operator delete(*((void **)this + 128));
  HGBufferDumper::~HGBufferDumper((void **)this + 116);
  HGDotGraph::~HGDotGraph((HGRenderer *)((char *)this + 840));
  HGCache::~HGCache((HGRenderer *)((char *)this + 704));
  v17 = (void *)*((_QWORD *)this + 31);
  if (v17)
  {
    *((_QWORD *)this + 32) = v17;
    operator delete(v17);
  }
  v18 = (void *)*((_QWORD *)this + 28);
  if (v18)
  {
    *((_QWORD *)this + 29) = v18;
    operator delete(v18);
  }
  HGObject::~HGObject(this);
}

{
  void *v1;

  HGRenderer::~HGRenderer(this);
  HGObject::operator delete(v1);
}

uint64_t HGRenderer::label(HGRenderer *this)
{
  _QWORD *v2;
  _QWORD *v3;
  const char *v4;
  uint64_t v5;
  _QWORD v7[2];
  _QWORD v8[11];
  char v9;
  uint64_t v10;

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v7);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"Renderer #", 10);
  v2 = (_QWORD *)std::ostream::operator<<();
  v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)": ", 2);
  if ((*(unsigned int (**)(HGRenderer *))(*(_QWORD *)this + 304))(this))
    v4 = "CPU";
  else
    v4 = "GPU";
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)v4, 3);
  std::stringbuf::str();
  v7[0] = *MEMORY[0x1E0DE4F50];
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)v7 + *(_QWORD *)(v7[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v8[0] = v5;
  v8[1] = MEMORY[0x1E0DE4FB8] + 16;
  if (v9 < 0)
    operator delete((void *)v8[9]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1B5E290BC](&v10);
}

void sub_1B2A7B0E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGRenderer::debugDescription(HGRenderer *this)
{
  return (*(uint64_t (**)(HGRenderer *))(*(_QWORD *)this + 40))(this);
}

uint64_t HGRenderer::IsCPU(HGRenderer *this)
{
  return 1;
}

uint64_t HGRenderer::RenderFullROI_Default(HGRenderer *this)
{
  return 1;
}

void *HGRenderer::CreateBuffer(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  void *v7;

  v7 = HGObject::operator new(0x80uLL);
  HGBuffer::HGBuffer((uint64_t)v7, a2, a3, a4);
  return v7;
}

void sub_1B2A7B164(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGRenderer::BindBuffer(HGBitmap **this, HGBitmap *a2)
{
  HGBitmap *v4;

  if (a2 && this[3] == a2)
    return 0;
  (*((void (**)(HGBitmap **, _QWORD, _QWORD, _QWORD, _QWORD))*this + 19))(this, 0, 0, 0, 0);
  (*((void (**)(HGBitmap **, uint64_t, _QWORD, _QWORD, _QWORD))*this + 19))(this, 1, 0, 0, 0);
  (*((void (**)(HGBitmap **, uint64_t, _QWORD, _QWORD, _QWORD))*this + 19))(this, 2, 0, 0, 0);
  (*((void (**)(HGBitmap **, uint64_t, _QWORD, _QWORD, _QWORD))*this + 19))(this, 3, 0, 0, 0);
  (*((void (**)(HGBitmap **, uint64_t, _QWORD, _QWORD, _QWORD))*this + 19))(this, 4, 0, 0, 0);
  (*((void (**)(HGBitmap **, uint64_t, _QWORD, _QWORD, _QWORD))*this + 19))(this, 5, 0, 0, 0);
  (*((void (**)(HGBitmap **, uint64_t, _QWORD, _QWORD, _QWORD))*this + 19))(this, 6, 0, 0, 0);
  (*((void (**)(HGBitmap **, uint64_t, _QWORD, _QWORD, _QWORD))*this + 19))(this, 7, 0, 0, 0);
  v4 = this[3];
  if (v4)
  {
    (*(void (**)(HGBitmap *))(*(_QWORD *)v4 + 24))(v4);
    this[3] = 0;
  }
  if (!a2)
    return 0;
  if (*((_QWORD *)a2 + 10))
  {
    this[3] = a2;
    (*(void (**)(HGBitmap *))(*(_QWORD *)a2 + 16))(a2);
    return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t HGRenderer::BindTexture(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t result;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;

  if (a2 > 7)
    return 0xFFFFFFFFLL;
  v10 = a1 + 24 * a2;
  v13 = *(_QWORD *)(v10 + 32);
  v11 = (_QWORD *)(v10 + 32);
  v12 = v13;
  v15 = v11 + 1;
  v14 = v11[1];
  if (v13 != a3)
  {
    *v11 = a3;
    if (a3)
      (*(void (**)(uint64_t))(*(_QWORD *)a3 + 16))(a3);
    if (v12)
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
  }
  if (v14 != a4)
  {
    *v15 = a4;
    if (a4)
      (*(void (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
    if (v14)
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
  }
  result = 0;
  *(_DWORD *)(a1 + 24 * a2 + 48) = a5;
  return result;
}

uint64_t HGRenderer::SetParameter(uint64_t this, int a2, char *a3)
{
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  signed int v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  BOOL v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  int v23;
  HGRenderer *v24;
  uint64_t v25;
  int v26;
  int v27;

  v3 = a3;
  v4 = this;
  switch(a2)
  {
    case 0:
      *(_DWORD *)(this + 584) = (_DWORD)a3;
      return this;
    case 1:
      if ((int)a3 <= 8)
        v5 = 8;
      else
        v5 = a3;
      if (v5 >= 0x100)
        v5 = 256;
      *(_DWORD *)(this + 588) = v5;
      return this;
    case 2:
      if ((int)a3 <= 8)
        v6 = 8;
      else
        v6 = a3;
      if (v6 >= 0x100)
        v6 = 256;
      *(_DWORD *)(this + 592) = v6;
      return this;
    case 4:
      *(_DWORD *)(this + 628) = (_DWORD)a3;
      return this;
    case 5:
      if ((int)a3 <= 1)
        v7 = 1;
      else
        v7 = (int)a3;
      *(_DWORD *)(this + 596) = v7;
      return this;
    case 6:
      v8 = a3 & ~((int)a3 >> 31);
      if (v8 >= 4)
        v8 = 4;
      *(_DWORD *)(this + 600) = v8;
      return this;
    case 7:
      *(_DWORD *)(this + 604) = (int)a3 > 0;
      return this;
    case 8:
      *(_DWORD *)(this + 608) = (int)a3 > 0;
      return this;
    case 9:
      *(_DWORD *)(this + 612) = (_DWORD)a3;
      return this;
    case 10:
      *(_DWORD *)(this + 616) = (_DWORD)a3;
      return this;
    case 11:
      *(_DWORD *)(this + 620) = (_DWORD)a3;
      return this;
    case 13:
      *(_DWORD *)(this + 636) = (_DWORD)a3;
      return this;
    case 14:
      if (*(_DWORD *)(this + 640))
      {
        if (!(_DWORD)a3)
        {
          *(_DWORD *)(this + 640) = 0;
          return pthread_rwlock_unlock((pthread_rwlock_t *)(this + 288));
        }
      }
      else if ((_DWORD)a3)
      {
        this = pthread_rwlock_wrlock((pthread_rwlock_t *)(this + 288));
        *(_DWORD *)(v4 + 640) = 1;
      }
      return this;
    case 15:
      *(_DWORD *)(this + 644) = (_DWORD)a3;
      return this;
    case 16:
      *(_DWORD *)(this + 648) = (_DWORD)a3;
      return this;
    case 17:
      *(_DWORD *)(this + 652) = (_DWORD)a3;
      return this;
    case 18:
      *(_DWORD *)(this + 660) = (_DWORD)a3;
      return this;
    case 19:
      if (((_DWORD)a3 - 1) <= 0x20)
        *(_DWORD *)(this + 576) = (_DWORD)a3;
      return this;
    case 20:
      if (((_DWORD)a3 - 1) <= 0x20)
        *(_DWORD *)(this + 580) = (_DWORD)a3;
      return this;
    case 22:
      *(_DWORD *)(this + 832) = (_DWORD)a3 != 0;
      return this;
    case 23:
      switch((_DWORD)a3)
      {
        case 2:
          *(_DWORD *)(this + 664) = 2;
          break;
        case 1:
          *(_DWORD *)(this + 664) = 1;
          break;
        case 0:
          *(_DWORD *)(this + 664) = 0;
          break;
      }
      return this;
    case 24:
      *(_DWORD *)(this + 668) = (_DWORD)a3;
      return this;
    case 28:
      *(_DWORD *)(this + 672) = (_DWORD)a3 != 0;
      return this;
    case 29:
      return HGLogger::setLevel((HGLogger *)"gpu", a3);
    case 30:
      *(_DWORD *)(this + 656) = (_DWORD)a3;
      return PCImage::setIsPremultiplied(this + 840, (_DWORD)a3 != 0);
    case 31:
      return (uint64_t)HGBufferDumper::enable((HGBufferDumper *)(this + 928), (_DWORD)a3 != 0);
    case 32:
      if ((int)a3 > 394255)
      {
        if ((_DWORD)a3 == 394272)
          goto LABEL_77;
        if ((_DWORD)a3 != 394256)
          goto LABEL_85;
LABEL_76:
        v22 = 394256;
        *(_QWORD *)(this + 816) = HGRenderer::GetCachedLimits((HGRenderer *)this, 394256);
        v23 = 328736;
        v24 = (HGRenderer *)v4;
        v25 = 328736;
LABEL_78:
        this = (uint64_t)HGRenderer::GetCachedLimits(v24, v25);
        *(_QWORD *)(v4 + 824) = this;
        **(_DWORD **)(v4 + 816) = v22;
        *(_DWORD *)this = v23;
        return this;
      }
      if ((_DWORD)a3 == 328736)
        goto LABEL_76;
      if ((_DWORD)a3 == 328752)
      {
LABEL_77:
        v22 = 394272;
        *(_QWORD *)(this + 816) = HGRenderer::GetCachedLimits((HGRenderer *)this, 394272);
        v23 = 328752;
        v24 = (HGRenderer *)v4;
        v25 = 328752;
        goto LABEL_78;
      }
LABEL_85:
      if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 304))(this) & 1) != 0)
      {
        v26 = v3 | 0x1000000;
        if (v3 >= 0x100000)
          v26 = v3;
        dword_1ED4DAA0C = v26;
        *(_DWORD *)(v4 + 812) = v26;
        *(_QWORD *)(v4 + 816) = HGRenderer::GetCachedLimits((HGRenderer *)v4, v26 | 0x60000u);
        this = (uint64_t)HGRenderer::GetCachedLimits((HGRenderer *)v4, *(_DWORD *)(v4 + 812) | 0x50000u);
        *(_QWORD *)(v4 + 824) = this;
        v27 = *(_DWORD *)(v4 + 812);
        **(_DWORD **)(v4 + 816) = v27;
        *(_DWORD *)this = v27;
      }
      else
      {
        *(_QWORD *)(v4 + 816) = HGRenderer::GetCachedLimits((HGRenderer *)v4, (unsigned __int16)v3 | 0x60000u);
        this = (uint64_t)HGRenderer::GetCachedLimits((HGRenderer *)v4, (unsigned __int16)v3 | 0x50000u);
        *(_QWORD *)(v4 + 824) = this;
        **(_DWORD **)(v4 + 816) = (unsigned __int16)v3 | 0x60000;
        *(_DWORD *)this = (unsigned __int16)v3 | 0x50000;
      }
      return this;
    case 33:
      v13 = (_DWORD)a3 != 0;
      *(_BYTE *)(this + 810) = (_DWORD)a3 != 0;
      v14 = *(_QWORD *)(this + 224);
      v15 = *(_QWORD *)(this + 232) - v14;
      if ((int)(v15 >> 3) >= 1)
      {
        v16 = (v15 >> 3);
        v17 = v16;
        if (v16 < 2)
          goto LABEL_70;
        v17 = (v15 >> 3) & 1;
        v18 = v16 - v17;
        v19 = v16 + 4294967294u;
        do
        {
          v20 = *(_QWORD *)(v14 + 8 * v19);
          *(_BYTE *)(*(_QWORD *)(v14 + 8 * (v19 + 1)) + 40) = v13;
          *(_BYTE *)(v20 + 40) = v13;
          v19 -= 2;
          v18 -= 2;
        }
        while (v18);
        if (v17)
        {
LABEL_70:
          v21 = v17 + 1;
          do
            *(_BYTE *)(*(_QWORD *)(v14 + 8 * (v21-- - 2)) + 40) = v13;
          while (v21 > 1);
        }
      }
      return this;
    case 34:
      switch((int)a3)
      {
        case 0:
        case 1:
        case 2:
        case 3:
          v9 = *(_DWORD *)(this + 1072);
          *(_DWORD *)(this + 1072) = 0;
          if (v9)
          {
            v10 = *(_QWORD *)(this + 248);
            v11 = *(_QWORD *)(this + 256) - v10;
            if ((int)(v11 >> 3) >= 1)
            {
              v12 = (v11 >> 3) + 1;
              do
                *(_DWORD *)(*(_QWORD *)(v10 + 8 * (v12-- - 2)) + 440) = 0;
              while (v12 > 1);
            }
          }
          break;
        default:
          return this;
      }
      return this;
    case 36:
      if ((_DWORD)a3 == -1)
      {
        this = (uint64_t)getenv("ROI_DEBUG");
        if (this)
        {
          this = atoi((const char *)this);
          *(_DWORD *)(v4 + 676) = this;
        }
      }
      else
      {
        *(_DWORD *)(this + 676) = (_DWORD)a3;
      }
      return this;
    case 40:
      *(_DWORD *)(this + 680) = (_DWORD)a3;
      return this;
    case 41:
      *(_DWORD *)(this + 684) = (_DWORD)a3;
      return this;
    case 42:
      *(_DWORD *)(this + 688) = (_DWORD)a3;
      return this;
    default:
      return this;
  }
}

uint64_t HGRenderer::GetParameter(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = 0;
  v3 = 0x2000;
  switch(a2)
  {
    case 0:
      return *(unsigned int *)(a1 + 584);
    case 1:
      return *(unsigned int *)(a1 + 588);
    case 2:
      return *(unsigned int *)(a1 + 592);
    case 3:
      return (*(_DWORD *)(a1 + 592) * *(_DWORD *)(a1 + 588));
    case 4:
      return *(unsigned int *)(a1 + 628);
    case 5:
      return *(unsigned int *)(a1 + 596);
    case 6:
      return *(unsigned int *)(a1 + 600);
    case 7:
      return *(unsigned int *)(a1 + 604);
    case 8:
      return *(unsigned int *)(a1 + 608);
    case 9:
      return *(unsigned int *)(a1 + 612);
    case 10:
      return *(unsigned int *)(a1 + 616);
    case 11:
      return *(unsigned int *)(a1 + 620);
    case 13:
      return *(unsigned int *)(a1 + 636);
    case 14:
      return *(unsigned int *)(a1 + 640);
    case 15:
      return *(unsigned int *)(a1 + 644);
    case 16:
      return *(unsigned int *)(a1 + 648);
    case 17:
      return *(unsigned int *)(a1 + 652);
    case 18:
      return *(unsigned int *)(a1 + 660);
    case 19:
      return *(unsigned int *)(a1 + 576);
    case 20:
      return *(unsigned int *)(a1 + 580);
    case 22:
      return *(unsigned int *)(a1 + 832);
    case 23:
      return *(unsigned int *)(a1 + 664);
    case 24:
      return *(unsigned int *)(a1 + 668);
    case 27:
      return v3;
    case 28:
      return *(unsigned int *)(a1 + 672);
    case 32:
      return **(unsigned int **)(a1 + 816);
    case 34:
      if (*(_DWORD *)(a1 + 1072))
        return 3;
      else
        return 0;
    case 36:
      return *(unsigned int *)(a1 + 676);
    case 40:
      return *(unsigned int *)(a1 + 680);
    case 41:
      return *(unsigned int *)(a1 + 684);
    case 42:
      return *(unsigned int *)(a1 + 688);
    case 46:
      return HGLimits::texturerect(*(HGLimits **)(a1 + 816));
    default:
      return v2;
  }
}

uint64_t HGRenderer::GetTarget(HGRenderer *this, int a2)
{
  switch(a2)
  {
    case 0:
      return dword_1ED4DAA0C;
    case 327680:
      return **((unsigned int **)this + 103);
    case 393216:
      return **((unsigned int **)this + 102);
  }
  return 0;
}

uint64_t HGRenderer::RenderCheckPoint(HGRenderer *this)
{
  if (*((_DWORD *)this + 160))
  {
    pthread_rwlock_rdlock((pthread_rwlock_t *)((char *)this + 288));
    pthread_rwlock_unlock((pthread_rwlock_t *)((char *)this + 288));
  }
  if (*((_DWORD *)this + 159))
    return 0xFFFFFFFFLL;
  else
    return 0;
}

void HGRenderer::RenderInput(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unint64_t a6, unint64_t a7, int a8)
{
  uint64_t v9;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  DBM_cpu *v18;
  uint64_t v20;
  int8x16_t *Stack;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const void *v27;
  DBM_cpu *v28;
  _BYTE v29[16];
  HGRect v30;
  HGRect v31;

  if (*(_DWORD *)(a3 + 88) <= a4 || (v9 = *(_QWORD *)(*(_QWORD *)(a3 + 80) + 8 * a4)) == 0)
  {
    *(_DWORD *)(a5 + 8) = 0;
    *(_QWORD *)a5 = 0;
    return;
  }
  if ((*(_BYTE *)(v9 + 12) & 6) != 0)
  {
    v14 = *(_QWORD **)(v9 + 48);
    if (v14)
    {
      *(_QWORD *)a5 = v14[10];
      *(_DWORD *)(a5 + 8) = v14[8] / v14[7];
    }
    v15 = *(int *)(a2 + 160);
    v16 = *(_QWORD *)(a1 + 224);
    if ((int)v15 < (int)((unint64_t)(*(_QWORD *)(a1 + 232) - v16) >> 3)
      && (v17 = *(const void **)(v16 + 8 * v15)) != 0)
    {
      if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 16) + 144) + 96))
        return;
    }
    else
    {
      v18 = 0;
      if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 16) + 144) + 96))
        return;
    }
    if (DepthBufferManager::hasDepthBuffer(v18))
    {
      *(_QWORD *)&v30.var0 = a6;
      *(_QWORD *)&v30.var2 = a7;
      DBM_cpu::setDepthBuffer(v18, *(HGBitmap **)(*(_QWORD *)(*(_QWORD *)(v9 + 16) + 144) + 96), v30);
    }
  }
  else if (!HGRectIsNull(a6, a7))
  {
    v20 = (int)((a7 - (a6 & 0xFFFFFFFF00000000)) >> 32) * (uint64_t)((int)a7 - (int)a6);
    Stack = (int8x16_t *)HGExecutionUnit::GetStack((uint64_t ****)a2, v20);
    v22 = *(_QWORD *)(v9 + 16);
    if (v22)
    {
      v23 = *(_QWORD *)(v22 + 144);
      v24 = *(_QWORD *)(v23 + 192);
      if (v24)
      {
        *(_DWORD *)(a2 + 36) = 0;
        *(_DWORD *)(a2 + 112) = *(_DWORD *)(a1 + 628);
        HGStats::ProfilerScopeGuard::ProfilerScopeGuard(v29, *(_QWORD *)(a2 + 424), 1, v20, *(_QWORD *)(v24 + 56) * v20);
        HGSampler::ReadTile((float32x4_t *)a2, *(_DWORD **)(v23 + 192), 0, Stack, a6, a7, 0);
        HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)v29);
        v25 = *(int *)(a2 + 160);
        v26 = *(_QWORD *)(a1 + 224);
        if ((int)v25 < (int)((unint64_t)(*(_QWORD *)(a1 + 232) - v26) >> 3)
          && (v27 = *(const void **)(v26 + 8 * v25)) != 0)
        {
        }
        else
        {
          v28 = 0;
        }
        if (*(_QWORD *)(v23 + 96) && DepthBufferManager::hasDepthBuffer(v28))
        {
          *(_QWORD *)&v31.var0 = a6;
          *(_QWORD *)&v31.var2 = a7;
          DBM_cpu::setDepthBuffer(v28, *(HGBitmap **)(v23 + 96), v31);
        }
      }
      else
      {
        HGRenderer::RenderTile(a1, (int *)a2, Stack->i8, a6, a7, v23, 0);
      }
    }
    *(_DWORD *)(a5 + 8) = a7 - a6;
    *(_QWORD *)a5 = Stack;
    if (!a8)
      HGExecutionUnit::CommitStack(a2, (uint64_t)Stack, v20);
  }
}

void sub_1B2A7BE94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HGRenderer::DepthManager(HGRenderer *this, int a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 28);
  if ((int)((unint64_t)(*((_QWORD *)this + 29) - v2) >> 3) <= a2)
    return 0;
  else
    return *(_QWORD *)(v2 + 8 * a2);
}

void HGRenderer::RenderTile(uint64_t a1, int *a2, char *a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  DBM_cpu *v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  char *v25;
  uint64_t v26;
  __int128 *v27;
  signed int v28;
  uint64_t v29;
  HGStats::ProfilerScopeGuard *v30;
  uint64_t v31;
  int v32;
  char *v33;
  int v34;
  uint64_t v35;
  char *v36;
  int v37;
  __int128 *v38;
  signed int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  HGExecutionUnit *v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  char *v56;
  int v57;
  char *v58;
  int v59;
  unsigned int v60;
  int v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  HGExecutionUnit *v66;
  _OWORD v67[2];
  uint64_t v68;
  __int128 v69;
  __int128 v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  int v85;
  uint64_t v86;
  int v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  HGExecutionUnit *v96;
  __int128 v97;
  __int128 v98;
  uint64_t v99;
  _OWORD v100[2];
  uint64_t v101;
  __int128 v102[2];
  uint64_t v103;
  HGRect v104;

  if (*(_DWORD *)(a1 + 640))
  {
    pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 288));
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 288));
  }
  if (*(_DWORD *)(a1 + 636))
    return;
  v14 = *(_QWORD *)(a6 + 192);
  if (!v14)
  {
    v63 = HIDWORD(a5);
    v64 = (a5 - a4);
    v65 = HIDWORD(a4);
    v66 = (HGExecutionUnit *)a2;
    v19 = HIDWORD(a5) - HIDWORD(a4);
    v20 = (HIDWORD(a5) - HIDWORD(a4)) * (unint64_t)v64;
    v21 = HGRectIntersection(a4, a5, *(_QWORD *)(a6 + 168), *(_QWORD *)(a6 + 176));
    v23 = v22;
    if (HGRectIsNull(v21, v22))
    {
      HGStats::ProfilerScopeGuard::ProfilerScopeGuard(&v69, *((_QWORD *)v66 + 53), 3, v20, 16 * v20);
      if ((_DWORD)a7)
      {
        v24 = HIDWORD(a5) - HIDWORD(a4);
        if (SHIDWORD(a5) > (int)v65)
        {
          do
          {
            bzero(a3, 16 * v64);
            a3 += 16 * (v64 + a7);
            --v24;
          }
          while (v24);
        }
      }
      else
      {
        bzero(a3, 16 * v20);
      }
      v30 = (HGStats::ProfilerScopeGuard *)&v69;
LABEL_34:
      HGStats::ProfilerScopeGuard::~ProfilerScopeGuard(v30);
      return;
    }
    if (HGRectIsEqual(v21, v23, a4, a5))
    {
      if ((*(_BYTE *)(a6 + 16) & 0x80) != 0
        || v20 < 2 * *(_DWORD *)(*((_QWORD *)v66 + 19) + 588) * *(_DWORD *)(*((_QWORD *)v66 + 19) + 592))
      {
        v99 = 0;
        v97 = 0u;
        v98 = 0u;
        HGExecutionUnit::GetStackState((uint64_t)v66, (uint64_t)&v97);
        v96 = v66;
        *(_QWORD *)&v69 = a4;
        *((_QWORD *)&v69 + 1) = a5;
        *(_QWORD *)&v70 = a3;
        DWORD2(v70) = v64 + a7;
        if (!*(_QWORD *)(a6 + 80) || (*(_BYTE *)(a6 + 16) & 0x10) != 0)
        {
          v72 = 0;
          v73 = 0;
          v74 = 0;
          v75 = 0;
          v88 = HGRectNull;
          v89 = HGRectNull;
          v76 = 0;
          v77 = 0;
          v78 = 0;
          v79 = 0;
          v90 = HGRectNull;
          v91 = HGRectNull;
          v80 = 0;
          v81 = 0;
          v82 = 0;
          v83 = 0;
          v92 = HGRectNull;
          v93 = HGRectNull;
          v84 = 0;
          v85 = 0;
          v86 = 0;
          v87 = 0;
          v94 = HGRectNull;
          v95 = HGRectNull;
        }
        else
        {
          v26 = 0;
          do
          {
            while (1)
            {
              v28 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a6 + 440))(a6, v26);
              v29 = *(_QWORD *)(*(_QWORD *)(a6 + 80) + 8 * v28);
              if (v29)
              {
                if (*(_QWORD *)(v29 + 16) && (*(_BYTE *)(v29 + 12) & 0x10) == 0)
                  break;
              }
              v27 = &v69 + v28;
              *((_QWORD *)v27 + 10) = 0;
              *((_DWORD *)v27 + 22) = 0;
              v27[13] = HGRectNull;
              v26 = (v26 + 1);
              if ((_DWORD)v26 == 8)
                goto LABEL_46;
            }
            if (HGRenderer::RenderInputTile(a1, (uint64_t)v66, (uint64_t)a3, a4, a5, a6, a7, (uint64_t)&v69, v28))a3 = 0;
            v26 = (v26 + 1);
          }
          while ((_DWORD)v26 != 8);
        }
LABEL_46:
        HGNode::RenderTileDispatch((HGNode *)a6, (HGTile *)&v69, v25);
        v67[0] = v97;
        v67[1] = v98;
        v68 = v99;
        v38 = v67;
      }
      else
      {
        v71 = 0;
        v69 = 0u;
        v70 = 0u;
        HGExecutionUnit::GetStackState((uint64_t)v66, (uint64_t)&v69);
        if (v19 >= (int)v64)
        {
          v50 = (HIDWORD(a5) + HIDWORD(a4)) >> 1;
          v51 = HGRectMake4i(a4, HIDWORD(a4), a5, v50);
          HGRenderer::RenderTile(a1, v66, a3, v51, v52, a6, a7);
          v53 = (v50 - HIDWORD(a4)) * ((_DWORD)v64 + (_DWORD)a7);
          HGExecutionUnit::CommitStack((uint64_t)v66, (uint64_t)a3, v53);
          v42 = HGRectMake4i(a4, v50, a5, HIDWORD(a5));
          v44 = v54;
          v46 = a1;
          v47 = v66;
          v48 = (uint64_t)&a3[16 * v53];
          v49 = a6;
          v45 = a7;
        }
        else
        {
          v39 = ((int)a5 + (int)a4) >> 1;
          HGExecutionUnit::CommitStack((uint64_t)v66, (uint64_t)a3, ((v64 + a7) * v19));
          v40 = HGRectMake4i(a4, HIDWORD(a4), v39, HIDWORD(a5));
          HGRenderer::RenderTile(a1, v66, a3, v40, v41, a6, (a5 + a7 - v39));
          v42 = HGRectMake4i(v39, HIDWORD(a4), a5, HIDWORD(a5));
          v44 = v43;
          v45 = (a7 - a4 + v39);
          v46 = a1;
          v47 = v66;
          v48 = (uint64_t)&a3[16 * v39 + -16 * (int)a4];
          v49 = a6;
        }
        HGRenderer::RenderTile(v46, v47, v48, v42, v44, v49, v45);
        v100[0] = v69;
        v100[1] = v70;
        v101 = v71;
        v38 = v100;
      }
      HGExecutionUnit::SetStackState((uint64_t)v66, v38);
      return;
    }
    v62 = HIDWORD(v21);
    v71 = 0;
    v69 = 0u;
    v70 = 0u;
    HGExecutionUnit::GetStackState((uint64_t)v66, (uint64_t)&v69);
    v60 = v64 + a7;
    v61 = a5 - v23;
    HGExecutionUnit::CommitStack((uint64_t)v66, (uint64_t)a3, v19 * ((int)v64 + (int)a7));
    v59 = (HIDWORD(v21) - HIDWORD(a4)) * (v64 + a7);
    HGRenderer::RenderTile(a1, v66, &a3[16 * v59 + 16 * ((int)v21 - (int)a4)], v21, v23, a6, (v21 - a4 + a7 + a5 - v23));
    v31 = (v19 * v64 + (HIDWORD(v23) - HIDWORD(v21)) * (v21 - v23));
    HGStats::ProfilerScopeGuard::ProfilerScopeGuard(&v97, *((_QWORD *)v66 + 53), 3, v31, 16 * v31);
    v32 = HIDWORD(v21) - HIDWORD(a4);
    if (HIDWORD(v21) != HIDWORD(a4))
    {
      if (!(_DWORD)a7)
      {
        bzero(a3, 16 * (v32 * v64));
        v34 = HIDWORD(a5);
        v35 = (int)v21 - (int)a4;
        if (HIDWORD(a5) == HIDWORD(v23))
          goto LABEL_55;
        v36 = &a3[16 * (HIDWORD(v23) - HIDWORD(a4)) * v60];
LABEL_54:
        bzero(v36, 16 * ((v34 - HIDWORD(v23)) * v64));
LABEL_55:
        if ((int)v35 >= 1)
        {
          v55 = HIDWORD(v23) - v62;
          if (SHIDWORD(v23) > (int)v62)
          {
            v56 = &a3[16 * v59];
            do
            {
              bzero(v56, 16 * v35);
              v56 += 16 * v60;
              --v55;
            }
            while (v55);
          }
        }
        if (v61 >= 1)
        {
          v57 = HIDWORD(v23) - v62;
          if (SHIDWORD(v23) > (int)v62)
          {
            v58 = &a3[16 * v59 + 16 * ((int)v23 - (int)a4)];
            do
            {
              bzero(v58, 16 * v61);
              v58 += 16 * v60;
              --v57;
            }
            while (v57);
          }
        }
        v102[0] = v69;
        v102[1] = v70;
        v103 = v71;
        HGExecutionUnit::SetStackState((uint64_t)v66, v102);
        v30 = (HGStats::ProfilerScopeGuard *)&v97;
        goto LABEL_34;
      }
      if (SHIDWORD(v21) > SHIDWORD(a4))
      {
        v33 = a3;
        do
        {
          bzero(v33, 16 * v64);
          v33 += 16 * (v64 + a7);
          --v32;
        }
        while (v32);
      }
    }
    v34 = v63;
    v35 = (int)v21 - (int)a4;
    if ((_DWORD)v63 == HIDWORD(v23))
      goto LABEL_55;
    v36 = &a3[16 * (HIDWORD(v23) - HIDWORD(a4)) * v60];
    if ((_DWORD)a7)
    {
      v37 = v63 - HIDWORD(v23);
      if ((int)v63 > SHIDWORD(v23))
      {
        do
        {
          bzero(v36, 16 * v64);
          v36 += 16 * (v64 + a7);
          --v37;
        }
        while (v37);
      }
      goto LABEL_55;
    }
    goto LABEL_54;
  }
  (*(void (**)(uint64_t, char *, unint64_t, unint64_t, uint64_t))(*(_QWORD *)v14 + 72))(v14, a3, a4, a5, a7);
  v15 = a2[40];
  v16 = *(_QWORD *)(a1 + 224);
  if ((int)v15 < (int)((unint64_t)(*(_QWORD *)(a1 + 232) - v16) >> 3)
    && (v17 = *(const void **)(v16 + 8 * v15)) != 0)
  {
    if (!*(_QWORD *)(a6 + 96))
      return;
  }
  else
  {
    v18 = 0;
    if (!*(_QWORD *)(a6 + 96))
      return;
  }
  if (DepthBufferManager::hasDepthBuffer(v18))
  {
    *(_QWORD *)&v104.var0 = a4;
    *(_QWORD *)&v104.var2 = a5;
    DBM_cpu::setDepthBuffer(v18, *(HGBitmap **)(a6 + 96), v104);
  }
}

void sub_1B2A7C654(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)(v1 - 224));
  _Unwind_Resume(a1);
}

uint64_t HGRenderer::RenderInputTile(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, unsigned int a7, uint64_t a8, signed int a9)
{
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  unint64_t v17;
  int v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  _BOOL4 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const void *v39;
  DBM_cpu *v40;
  uint64_t v42;
  _BOOL4 IsEqualSize;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t Stack;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  float32x4_t *v53;
  int8x16_t *v54;
  uint64_t v55;
  uint64_t v56;
  const void *v57;
  DepthBufferManager *v58;
  DepthBufferManager *v59;
  _BOOL4 hasDepthBuffer;
  uint64_t v61;
  int v62;
  int v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v68;
  uint64_t v69;
  int8x16_t *v71;
  uint64_t v72;
  _BYTE v73[16];
  HGRect v74;
  HGRect v75;

  v9 = a8 + 16 * a9;
  if (*(_DWORD *)(a6 + 88) <= a9)
  {
    v23 = 0;
    *(_QWORD *)(v9 + 80) = 0;
    *(_DWORD *)(v9 + 88) = 0;
    return v23;
  }
  v11 = *(_QWORD *)(*(_QWORD *)(a6 + 80) + 8 * a9);
  *(_QWORD *)(v9 + 80) = 0;
  v12 = v9 + 80;
  *(_DWORD *)(v12 + 8) = 0;
  if (!v11)
    return 0;
  v17 = HIDWORD(a4);
  v18 = *(_DWORD *)(v11 + 12);
  if ((v18 & 6) != 0)
  {
    v19 = *(_QWORD *)(v11 + 48);
    if (v19)
    {
      if ((v18 & 4) != 0)
      {
        v22 = 0;
        v21 = *(_QWORD *)(v19 + 56);
        v20 = *(_QWORD *)(v19 + 64);
      }
      else
      {
        v21 = *(_QWORD *)(v19 + 56);
        v20 = *(_QWORD *)(v19 + 64);
        v22 = v20 * (SHIDWORD(a4) - (uint64_t)*(int *)(v19 + 24)) + v21 * ((int)a4 - (uint64_t)*(int *)(v19 + 20));
      }
      *(_QWORD *)v12 = *(_QWORD *)(v19 + 80) + v22;
      *(_DWORD *)(v12 + 8) = v20 / v21;
      *(_OWORD *)(a8 + 16 * a9 + 208) = *(_OWORD *)(v19 + 20);
    }
    v37 = *(int *)(a2 + 160);
    v38 = *(_QWORD *)(a1 + 224);
    if ((int)v37 < (int)((unint64_t)(*(_QWORD *)(a1 + 232) - v38) >> 3)
      && (v39 = *(const void **)(v38 + 8 * v37)) != 0)
    {
      if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 16) + 144) + 96))
        return 0;
    }
    else
    {
      v40 = 0;
      if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 16) + 144) + 96))
        return 0;
    }
    if (DepthBufferManager::hasDepthBuffer(v40))
    {
      *(_QWORD *)&v74.var0 = a4;
      *(_QWORD *)&v74.var2 = a5;
      DBM_cpu::setDepthBuffer(v40, *(HGBitmap **)(*(_QWORD *)(*(_QWORD *)(v11 + 16) + 144) + 96), v74);
      return 0;
    }
    return 0;
  }
  v65 = v11;
  v68 = HIDWORD(a5);
  v25 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, unint64_t, unint64_t))(*(_QWORD *)a6 + 400))(a6, a1, a9, a4, a5);
  v66 = a1;
  v27 = v26;
  v72 = a2;
  v28 = *(uint64_t **)(a2 + 424);
  v63 = HIDWORD(v26) - HIDWORD(v25);
  v64 = v26 - v25;
  v29 = ((HIDWORD(v26) - HIDWORD(v25)) * (v26 - v25));
  v62 = v17;
  HGStats::UnitStats::in_n_out(v28, (HGNode *)a6, a9, v29, ((v68 - v17) * (a5 - a4)));
  v30 = a8 + 16 * a9;
  *(_QWORD *)(v30 + 208) = v25;
  *(_QWORD *)(v30 + 216) = v27;
  if (HGRectIsNull(v25, v27))
    return 0;
  v61 = a5;
  if (*(_DWORD *)(v66 + 624) == 2)
  {
    v31 = 0;
    v32 = a4;
    v34 = a3;
    v33 = v72;
    v35 = v27;
    v36 = v65;
  }
  else
  {
    v32 = a4;
    v34 = a3;
    v33 = v72;
    v36 = v65;
    v31 = (*(_BYTE *)(a6 + 16) & 1) == 0 && (*(_DWORD *)(v65 + 12) & 1) == 0;
    v35 = v27;
  }
  v42 = v63 * (uint64_t)v64;
  if (!v34)
  {
    v23 = 1;
LABEL_34:
    Stack = HGExecutionUnit::GetStack((uint64_t ****)v33, v42);
    v33 = v72;
    v44 = Stack;
    a7 = 0;
    goto LABEL_35;
  }
  if (!v31 || (IsEqualSize = HGRectIsEqualSize(v25, v35, v32, v61), v33 = v72, !IsEqualSize))
  {
    v45 = v32;
    v46 = v33;
    if (HGExecutionUnit::GetStack((uint64_t ****)v33, 0) == a3)
      HGExecutionUnit::SwapStack(v46);
    v23 = 0;
    v33 = v46;
    v32 = v45;
    v42 = v63 * (uint64_t)v64;
    v35 = v27;
    goto LABEL_34;
  }
  v23 = 1;
  v44 = a3;
LABEL_35:
  v48 = *(_QWORD *)(v36 + 16);
  v49 = HIDWORD(v25);
  if (v48)
  {
    v69 = v42;
    v50 = v32;
    v51 = *(_QWORD *)(v48 + 144);
    v52 = *(_QWORD *)(v51 + 192);
    if (v52)
    {
      *(_DWORD *)(v33 + 36) = 0;
      *(_DWORD *)(v33 + 112) = *(_DWORD *)(v66 + 628);
      v53 = (float32x4_t *)v33;
      v54 = (int8x16_t *)v44;
      HGStats::ProfilerScopeGuard::ProfilerScopeGuard(v73, *(_QWORD *)(v33 + 424), 1, v29, *(_QWORD *)(v52 + 56) * v29);
      v71 = v54;
      HGSampler::ReadTile(v53, *(_DWORD **)(v51 + 192), 0, v54, v25, v35, a7);
      HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)v73);
      v55 = v53[10].i32[0];
      v56 = *(_QWORD *)(v66 + 224);
      v33 = (uint64_t)v53;
      v49 = HIDWORD(v25);
      if ((int)v55 < (int)((unint64_t)(*(_QWORD *)(v66 + 232) - v56) >> 3))
      {
        v57 = *(const void **)(v56 + 8 * v55);
        v32 = v50;
        if (v57)
        {
          v33 = v72;
          v59 = v58;
        }
        else
        {
          v59 = 0;
        }
      }
      else
      {
        v59 = 0;
        v32 = v50;
      }
      v42 = v69;
      v44 = (uint64_t)v71;
      if (*(_QWORD *)(v51 + 96))
      {
        hasDepthBuffer = DepthBufferManager::hasDepthBuffer(v59);
        v44 = (uint64_t)v71;
        v33 = v72;
        if (hasDepthBuffer)
        {
          *(_QWORD *)&v75.var0 = v32;
          *(_QWORD *)&v75.var2 = v61;
          DBM_cpu::setDepthBuffer(v59, *(HGBitmap **)(v51 + 96), v75);
          v44 = (uint64_t)v71;
          v33 = v72;
        }
      }
    }
    else
    {
      v32 = v44;
      HGRenderer::RenderTile(v66, v72, v44, v25, v35, v51, a7);
      v44 = v32;
      v33 = v72;
      LODWORD(v32) = v50;
      v42 = v69;
    }
  }
  *(_DWORD *)(v12 + 8) = a7 + v64;
  *(_QWORD *)v12 = v44 + 16 * ((int)v32 - (int)v25 + (v62 - v49) * (uint64_t)v64);
  HGExecutionUnit::CommitStack(v33, v44, v42);
  return v23;
}

void sub_1B2A7CB3C(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)(v1 - 96));
  _Unwind_Resume(a1);
}

HGBuffer *HGRenderer::RenderTiles(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, HGBitmap *a6, int a7)
{
  uint64_t v10;
  uint64_t v11;
  HGBuffer *v14;
  uint64_t v16;
  _BOOL4 v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  const void *v22;
  uint64_t v23;
  uint64_t i;
  BOOL v25;
  char v26;
  uint64_t v27;
  const void *v28;
  void *v29;
  uint64_t v30;
  _QWORD v31[4];
  HGRect v32;

  v10 = a4;
  v11 = a3;
  if (!HGRectIsNull(a3, a4))
  {
    if (*(_DWORD *)(a1 + 640))
    {
      pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 288));
      pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 288));
    }
    if (!*(_DWORD *)(a1 + 636))
    {
      if (a7 && !*(_BYTE *)(a1 + 808))
      {
        v11 = HGRectIntersection(*(_QWORD *)(a2 + 152), *(_QWORD *)(a2 + 160), v11, v10);
        v10 = v16;
      }
      if (a6)
      {
        v14 = (HGBuffer *)HGObject::operator new(0x80uLL);
        *(_QWORD *)&v32.var0 = v11;
        *(_QWORD *)&v32.var2 = v10;
        HGBuffer::HGBuffer(v14, v32, a6);
        if (*(_BYTE *)(a2 + 105))
        {
LABEL_12:
          v17 = *(_BYTE *)(a1 + 810) != 0;
          goto LABEL_15;
        }
      }
      else
      {
        v14 = (HGBuffer *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 136))(a1, v11, v10, a5);
        if (*(_BYTE *)(a2 + 105))
          goto LABEL_12;
      }
      v17 = 0;
LABEL_15:
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 488));
      v31[0] = v11;
      v31[1] = v10;
      v31[2] = v14;
      v31[3] = a2;
      *(_QWORD *)(a1 + 272) = v31;
      LODWORD(v18) = *(_DWORD *)(a1 + 596);
      if (v17)
      {
        if ((int)v18 < 1)
        {
LABEL_38:
          *(_QWORD *)(a1 + 272) = 0;
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 488));
          return v14;
        }
        v19 = 0;
        do
        {
          v21 = *(_QWORD *)(a1 + 224);
          if (v19 < (int)((unint64_t)(*(_QWORD *)(a1 + 232) - v21) >> 3)
            && (v22 = *(const void **)(v21 + 8 * v19)) != 0)
          {
          }
          else
          {
            v20 = 0;
          }
          (*(void (**)(void *))(*(_QWORD *)v20 + 24))(v20);
          DBM_cpu::bufferHint((uint64_t)v20, *(_QWORD *)(a2 + 96));
          ++v19;
          v18 = *(int *)(a1 + 596);
        }
        while (v19 < v18);
      }
      if ((int)v18 >= 1)
      {
        v23 = 0;
        do
        {
          HGExecutionUnit::BgnExec(*(HGExecutionUnit **)(*(_QWORD *)(a1 + 248) + 8 * v23++));
          v18 = *(int *)(a1 + 596);
        }
        while (v23 < v18);
        if ((int)v18 >= 1)
        {
          for (i = 0; i < v18; ++i)
          {
            HGExecutionUnit::EndExec(*(pthread_cond_t **)(*(_QWORD *)(a1 + 248) + 8 * i));
            v18 = *(int *)(a1 + 596);
          }
        }
      }
      v25 = (int)v18 < 1;
      v26 = !v17;
      if (v25)
        v26 = 1;
      if ((v26 & 1) == 0)
      {
        v27 = 0;
        do
        {
          v30 = *(_QWORD *)(a1 + 224);
          if (v27 < (int)((unint64_t)(*(_QWORD *)(a1 + 232) - v30) >> 3))
            v28 = *(const void **)(v30 + 8 * v27);
          else
            v28 = 0;
          (*(void (**)(void *))(*(_QWORD *)v29 + 32))(v29);
          ++v27;
        }
        while (v27 < *(int *)(a1 + 596));
      }
      goto LABEL_38;
    }
  }
  return 0;
}

void sub_1B2A7CDEC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

_DWORD *HGRenderer::MarkBufferedOutput(_DWORD *this, HGNode *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;

  v3 = this[153];
  if (v3 == 2)
  {
    *((_BYTE *)a2 + 104) = 0;
    return this;
  }
  v4 = *((int *)a2 + 44) - (uint64_t)*((int *)a2 + 42);
  v5 = *((int *)a2 + 45) - (uint64_t)*((int *)a2 + 43);
  if (v3 == 1)
  {
    if ((*((_BYTE *)a2 + 16) & 0x84) == 0)
      goto LABEL_20;
LABEL_24:
    *((_BYTE *)a2 + 104) = 1;
    return this;
  }
  v6 = *((_DWORD *)a2 + 4);
  if ((v6 & 8) != 0)
    goto LABEL_17;
  if ((v6 & 2) != 0)
  {
    LOBYTE(v3) = 1;
    if ((*((_BYTE *)a2 + 16) & 0x84) == 0)
      goto LABEL_20;
    goto LABEL_24;
  }
  if (*((int *)a2 + 52) < 2)
  {
LABEL_17:
    LOBYTE(v3) = 0;
    if ((*((_BYTE *)a2 + 16) & 0x84) != 0)
      goto LABEL_24;
  }
  else
  {
    this = (_DWORD *)(*(uint64_t (**)(_DWORD *, uint64_t))(*(_QWORD *)this + 128))(this, 27);
    LOBYTE(v3) = v4 <= (int)this && v5 <= (int)this;
    if ((*((_BYTE *)a2 + 16) & 0x84) != 0)
      goto LABEL_24;
  }
LABEL_20:
  if (*((_DWORD *)a2 + 54) == -1)
    goto LABEL_24;
  if (v5 * v4 < 1)
    LOBYTE(v3) = 1;
  *((_BYTE *)a2 + 104) = v3;
  return this;
}

uint64_t HGRenderer::RenderBufferedInput(HGRenderer *this, HGNode *a2, int a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  HGBuffer *v13;
  HGRect v14;
  HGRect v15;

  v3 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * a3);
  if (!v3 || (*(_BYTE *)(v3 + 12) & 6) == 0 || HGRectIsNull(*(_QWORD *)(v3 + 32), *(_QWORD *)(v3 + 40)))
    return 0;
  v7 = *(_QWORD *)(v3 + 16);
  v9 = *(_QWORD *)(v3 + 32);
  v8 = *(_QWORD *)(v3 + 40);
  v10 = HGFormatUtils::buildFormat(*((_DWORD *)a2 + 8), 8);
  if (v7)
  {
    v11 = v10;
    v12 = *(_QWORD *)(*(_QWORD *)(v7 + 144) + 192);
    if (v12
      && *(_DWORD *)(v12 + 16) == (_DWORD)v10
      && (*(_QWORD *)&v14.var0 = v9, *(_QWORD *)&v14.var2 = v8, HGRect::ContainsRect((HGRect *)(v12 + 20), v14))
      && (*(_BYTE *)(v12 + 80) & 0xF) == 0)
    {
      v13 = (HGBuffer *)HGObject::operator new(0x80uLL);
      *(_QWORD *)&v15.var0 = v9;
      *(_QWORD *)&v15.var2 = v8;
      HGBuffer::HGBuffer(v13, v15, (HGBitmap *)v12);
    }
    else
    {
      (*(void (**)(_QWORD, HGRenderer *))(**(_QWORD **)(v7 + 144) + 416))(*(_QWORD *)(v7 + 144), this);
      v13 = (HGBuffer *)(*(uint64_t (**)(HGRenderer *, _QWORD, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, BOOL))(*(_QWORD *)this + 168))(this, *(_QWORD *)(v7 + 144), v9, v8, v11, 0, 0, (*(_DWORD *)(v3 + 12) & 0x2000) == 0);
    }
  }
  else
  {
    v13 = 0;
  }
  *(_QWORD *)(v3 + 48) = v13;
  return 1;
}

void sub_1B2A7D068(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

BOOL HGRenderer::RenderBufferedOutput(HGRenderer *this, HGNode *a2)
{
  int v2;
  int v5;
  int v7;
  uint64_t v8;
  HGFormatUtils *v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *((unsigned __int8 *)a2 + 104);
  if (!*((_BYTE *)a2 + 104))
    return v2 != 0;
  v5 = *((_DWORD *)a2 + 8);
  if ((*((_BYTE *)a2 + 16) & 0x84) != 0
    || (*((int *)a2 + 45) - (uint64_t)*((int *)a2 + 43)) * (*((int *)a2 + 44) - (uint64_t)*((int *)a2 + 42)) <= 0)
  {
    v7 = 8;
  }
  else
  {
    if (v5 == 4 && *((_DWORD *)a2 + 9) == 15)
    {
      v8 = (*(uint64_t (**)(HGNode *, _QWORD))(*(_QWORD *)a2 + 296))(a2, *((unsigned int *)this + 144));
      goto LABEL_13;
    }
    v9 = (HGFormatUtils *)HGFormatUtils::precision(*((_DWORD *)this + 144));
    v7 = HGFormatUtils::adjustPrecision(v9, *((_DWORD *)a2 + 9));
    v5 = *((_DWORD *)a2 + 8);
  }
  v8 = HGFormatUtils::buildFormat(v5, v7);
LABEL_13:
  v10 = v8;
  (*(void (**)(HGNode *, HGRenderer *))(*(_QWORD *)a2 + 416))(a2, this);
  (*(void (**)(HGNode *, HGRenderer *, uint64_t))(*(_QWORD *)a2 + 336))(a2, this, 1);
  v11 = *((_QWORD *)a2 + 24);
  if (v11)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 16))(v11);
    return v2 != 0;
  }
  *((_QWORD *)a2 + 24) = (*(uint64_t (**)(HGRenderer *, HGNode *, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD, BOOL))(*(_QWORD *)this + 168))(this, a2, *((_QWORD *)a2 + 21), *((_QWORD *)a2 + 22), v10, 0, 0, (*((_DWORD *)a2 + 4) & 0x2000) == 0);
  return v2 != 0;
}

uint64_t HGRenderer::GetOutputFormat(HGRenderer *this, HGNode *a2)
{
  HGFormatUtils *v4;
  int v5;

  if (*((_DWORD *)a2 + 8) == 4 && *((_DWORD *)a2 + 9) == 15)
    return (*(uint64_t (**)(HGNode *, _QWORD))(*(_QWORD *)a2 + 296))(a2, *((unsigned int *)this + 144));
  v4 = (HGFormatUtils *)HGFormatUtils::precision(*((_DWORD *)this + 144));
  v5 = HGFormatUtils::adjustPrecision(v4, *((_DWORD *)a2 + 9));
  return HGFormatUtils::buildFormat(*((_DWORD *)a2 + 8), v5);
}

uint64_t HGRenderer::ReleaseBufferedInput(HGRenderer *this, HGNode *a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v8;
  unsigned int v9;
  HGBufferDumper *v10;
  const char *v11;

  v3 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * a3);
  if (!v3)
    return 0;
  v4 = *(_QWORD *)(v3 + 48);
  if (!v4)
    return 0;
  v8 = *(_QWORD *)(*(_QWORD *)(v3 + 16) + 144);
  v9 = *(_DWORD *)(v4 + 16) - 24;
  if (v9 <= 4)
    HGDotGraph::filled((uint64_t)this + 840, *(_QWORD *)(*(_QWORD *)(v3 + 16) + 144), HGRenderer::DotLogNodeBufferFormat(HGNode *,HGBitmap *)::formatString[v9]);
  if ((*(_BYTE *)(v4 + 12) & 1) != 0)
    HGDotGraph::outline((uint64_t)this + 840, v8, "limegreen");
  HGRenderer::DotLogBufferOutput((uint64_t *)this, *(HGBitmap **)(*(_QWORD *)(v3 + 16) + 144), *(HGBitmap **)(v3 + 48));
  if ((*(_BYTE *)(*(_QWORD *)(v3 + 48) + 12) & 0x30) == 0)
  {
    v10 = (HGRenderer *)((char *)this + 928);
    if (HGBufferDumper::on(v10))
    {
      v11 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 48))(a2);
      HGBufferDumper::write(v10, v11, a3, *(HGBitmap **)(v3 + 48));
    }
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(v3 + 48) + 24))(*(_QWORD *)(v3 + 48));
  *(_QWORD *)(v3 + 48) = 0;
  return 1;
}

uint64_t HGRenderer::DotLogNodeBufferFormat(uint64_t this, HGNode *a2, HGBitmap *a3)
{
  uint64_t v5;
  unsigned int v6;

  v5 = this;
  v6 = *((_DWORD *)a3 + 4) - 24;
  if (v6 <= 4)
    this = HGDotGraph::filled(this + 840, (unint64_t)a2, HGRenderer::DotLogNodeBufferFormat(HGNode *,HGBitmap *)::formatString[v6]);
  if ((*((_BYTE *)a3 + 12) & 1) != 0)
    return HGDotGraph::outline(v5 + 840, (unint64_t)a2, "limegreen");
  return this;
}

uint64_t *HGRenderer::DotLogBufferOutput(uint64_t *this, HGBitmap *a2, HGBitmap *a3)
{
  uint64_t *v5;
  int v6;
  uint64_t *v7;
  uint64_t *CVBitmapStorage;
  const char *v9;
  int v10;
  int v11;
  const char *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  const char *v17;
  uint64_t *v18;
  char __str[64];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (*((int *)this + 164) < 3)
    return this;
  v5 = this;
  v6 = *((_DWORD *)a3 + 3);
  if ((v6 & 1) != 0)
  {
    CVBitmapStorage = (uint64_t *)HGCVBitmap::getCVBitmapStorage(a3, a2);
    goto LABEL_6;
  }
  v7 = (uint64_t *)a3;
  if ((v6 & 0x20) != 0)
  {
    CVBitmapStorage = (uint64_t *)HGMetalTexture::getMetalStorage(a3, a2);
LABEL_6:
    v7 = CVBitmapStorage;
  }
  v9 = "GL";
  v11 = *((_DWORD *)a3 + 3);
  v10 = *((_DWORD *)a3 + 4);
  if ((v11 & 0x10) == 0)
    v9 = "(bmp)";
  if ((v11 & 0x20) != 0)
    v9 = "MTL";
  if ((v11 & 0x30) == 0)
    v9 = "CPU";
  if ((v11 & 1) != 0)
    v12 = "IOS";
  else
    v12 = v9;
  v13 = *((_DWORD *)a3 + 8);
  v14 = *((_DWORD *)a3 + 6);
  v15 = *((_DWORD *)a3 + 7) - *((_DWORD *)a3 + 5);
  v16 = v13 - v14;
  v17 = (const char *)HGFormatUtils::toString(v10);
  snprintf(__str, 0x40uLL, "{ %s | %dx%d | %s }", v12, v15, v16, v17);
  v18 = v5 + 105;
  HGDotGraph::node(v18, (unint64_t)v7, (uint64_t)"bitmap", 0);
  HGDotGraph::filled((uint64_t)v18, (unint64_t)v7, "#e0e0e0");
  HGDotGraph::fontSize(v18, (unint64_t)v7, 9);
  HGDotGraph::link(v18, (unint64_t)a2, (unint64_t)v7, "", 1);
  HGDotGraph::linkStyle(v18, (uint64_t *)a2, v7, 1, 0);
  return HGDotGraph::record(v18, (unint64_t)v7, __str);
}

BOOL HGRenderer::ReleaseBufferedOutput(HGRenderer *this, HGNode *a2)
{
  uint64_t v2;
  unsigned int v5;
  uint64_t v6;
  HGBitmap *v7;
  HGCVBitmap *CVBitmapStorage;
  HGBitmap *v9;
  const char *v10;
  const char *v11;

  v2 = *((_QWORD *)a2 + 24);
  if (v2)
  {
    v5 = *(_DWORD *)(v2 + 16) - 24;
    if (v5 <= 4)
      HGDotGraph::filled((uint64_t)this + 840, (unint64_t)a2, HGRenderer::DotLogNodeBufferFormat(HGNode *,HGBitmap *)::formatString[v5]);
    if ((*(_BYTE *)(v2 + 12) & 1) != 0)
      HGDotGraph::outline((uint64_t)this + 840, (unint64_t)a2, "limegreen");
    HGRenderer::DotLogBufferOutput((uint64_t *)this, (HGBitmap *)a2, *((HGBitmap **)a2 + 24));
    if (HGBufferDumper::on((HGRenderer *)((char *)this + 928)))
    {
      v6 = (*(uint64_t (**)(HGRenderer *, _QWORD, _QWORD))(*(_QWORD *)this + 96))(this, *((_QWORD *)a2 + 24), *(unsigned int *)(*((_QWORD *)a2 + 24) + 16));
      CVBitmapStorage = (HGCVBitmap *)HGCVBitmap::getCVBitmapStorage((HGBitmap *)v6, v7);
      if (CVBitmapStorage)
      {
        v9 = (HGBitmap *)CVBitmapStorage;
        HGCVBitmap::lock(CVBitmapStorage, 1uLL);
        v10 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 48))(a2);
        HGBufferDumper::write((HGRenderer *)((char *)this + 928), v10, -1, v9);
        HGCVBitmap::unlock((HGCVBitmap *)v9, 1uLL);
      }
      else if (*(_QWORD *)(v6 + 80))
      {
        v11 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 48))(a2);
        HGBufferDumper::write((HGRenderer *)((char *)this + 928), v11, -1, (HGBitmap *)v6);
      }
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
    }
    (*(void (**)(HGNode *, HGRenderer *, _QWORD))(*(_QWORD *)a2 + 424))(a2, this, *((_QWORD *)a2 + 24));
    (*(void (**)(_QWORD))(**((_QWORD **)a2 + 24) + 24))(*((_QWORD *)a2 + 24));
    *((_QWORD *)a2 + 24) = 0;
  }
  return v2 != 0;
}

uint64_t HGRenderer::FinalizeInputsOfBufferedNodes(uint64_t this, HGNode *a2)
{
  int v2;
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  uint64_t v7;

  v2 = *((_DWORD *)a2 + 22);
  if (v2 >= 1)
  {
    v4 = this;
    for (i = 0; i < v2; ++i)
    {
      v6 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * i);
      if (v6)
      {
        v7 = *(_QWORD *)(v6 + 16);
        if (v7)
        {
          if (*((_QWORD *)a2 + 24) || *(_QWORD *)(v6 + 48))
          {
            this = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 248))(v4, *(_QWORD *)(v7 + 144));
            v2 = *((_DWORD *)a2 + 22);
          }
        }
      }
    }
  }
  return this;
}

uint64_t HGRenderer::RenderTilesBegin(uint64_t result, uint64_t a2)
{
  int v2;
  unsigned int *v4;
  int v5;
  int v6;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *(_DWORD *)(a2 + 212);
  *(_DWORD *)(a2 + 212) = v2 + 1;
  if (!v2)
  {
    v4 = (unsigned int *)result;
    ++*(_DWORD *)(result + 696);
    v5 = *(_DWORD *)(a2 + 16);
    if ((v5 & 0x20000) != 0)
      *(_DWORD *)(a2 + 16) = v5 | 0x82;
    v6 = *(_DWORD *)(a2 + 88);
    if (v6 >= 1)
    {
      for (i = 0; i < v6; ++i)
      {
        v8 = *(_QWORD *)(*(_QWORD *)(a2 + 80) + 8 * i);
        if (v8)
        {
          v9 = *(_QWORD *)(v8 + 16);
          if (v9)
          {
            if ((*(_BYTE *)(a2 + 18) & 2) != 0)
              *(_DWORD *)(v8 + 12) |= 2u;
            (*(void (**)(unsigned int *, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v4 + 240))(v4, *(_QWORD *)(v9 + 144), *(_QWORD *)(v8 + 32), *(_QWORD *)(v8 + 40), v4[144]);
            v6 = *(_DWORD *)(a2 + 88);
          }
        }
      }
    }
    (*(void (**)(unsigned int *, uint64_t, _QWORD))(*(_QWORD *)v4 + 320))(v4, a2, 0);
    if (HGRectIsNull(*(_QWORD *)(a2 + 168), *(_QWORD *)(a2 + 176)))
    {
      return (*(uint64_t (**)(unsigned int *, uint64_t))(*(_QWORD *)v4 + 232))(v4, a2);
    }
    else
    {
      if (*(int *)(a2 + 88) >= 1)
      {
        v10 = 0;
        do
        {
          (*(void (**)(unsigned int *, uint64_t, uint64_t))(*(_QWORD *)v4 + 200))(v4, a2, v10);
          v10 = (v10 + 1);
        }
        while ((int)v10 < *(_DWORD *)(a2 + 88));
      }
      (*(void (**)(unsigned int *, uint64_t))(*(_QWORD *)v4 + 192))(v4, a2);
      (*(void (**)(unsigned int *, uint64_t))(*(_QWORD *)v4 + 208))(v4, a2);
      result = (*(uint64_t (**)(unsigned int *, uint64_t))(*(_QWORD *)v4 + 232))(v4, a2);
      if (*(_DWORD *)(a2 + 40) != 1)
        return (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(*(_QWORD *)a2 + 336))(a2, v4, 1);
    }
  }
  return result;
}

uint64_t HGRenderer::GenProgram(HGRenderer *this, HGNode *a2)
{
  uint64_t result;
  uint64_t v4;
  const char *v5;
  char *v6;
  const char *v7;
  char *v8;

  result = HGNode::SupportsSWAIR(a2);
  if ((_DWORD)result)
  {
    v4 = (*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 224))(a2);
    *((_QWORD *)a2 + 9) = v4;
    if (v4)
    {
      return 0;
    }
    else
    {
      v5 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 48))(a2);
      v6 = strdup(v5);
      HGLogger::warning((HGLogger *)"Missing swair program for node: %s", v7, v8, v6);
      free(v6);
      return 1;
    }
  }
  return result;
}

uint64_t *HGRenderer::RenderTilesEnd(uint64_t *this, HGNode *a2)
{
  int v2;
  uint64_t **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *((_DWORD *)a2 + 52) - 1;
  *((_DWORD *)a2 + 52) = v2;
  if (!v2)
  {
    v4 = (uint64_t **)this;
    *((_DWORD *)a2 + 53) = 0;
    if (*((int *)a2 + 22) >= 1)
    {
      v5 = 0;
      do
      {
        v6 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * v5);
        if (v6)
        {
          if (*(_QWORD *)(v6 + 48))
          {
            ((void (*)(uint64_t **, HGNode *, uint64_t))(*v4)[27])(v4, a2, v5);
          }
          else if (!*((_QWORD *)a2 + 24))
          {
            v7 = *(_QWORD *)(v6 + 16);
            if (v7)
              ((void (*)(uint64_t **, _QWORD))(*v4)[31])(v4, *(_QWORD *)(v7 + 144));
          }
        }
        ++v5;
      }
      while (v5 < *((int *)a2 + 22));
    }
    this = (uint64_t *)((uint64_t (*)(uint64_t **, HGNode *))(*v4)[28])(v4, a2);
    if (*((_DWORD *)a2 + 10) != 2)
    {
      (*(void (**)(HGNode *, uint64_t **, uint64_t))(*(_QWORD *)a2 + 336))(a2, v4, 2);
      return HGStats::GraphStats::roiPixels(v4[70], a2, (uint64_t *)((*((_DWORD *)a2 + 45) - *((_DWORD *)a2 + 43))* (*((_DWORD *)a2 + 44) - *((_DWORD *)a2 + 42))));
    }
  }
  return this;
}

uint64_t HGRenderer::RenderNode(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;

  a1[2] = a2;
  (*(void (**)(_QWORD *))(*a1 + 184))(a1);
  (*(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*a1 + 240))(a1, a2, a3, a4, a5);
  v12 = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, BOOL))(*a1 + 168))(a1, a2, a3, a4, a5, a6, 1, (*(_DWORD *)(a2 + 16) & 0x2000) == 0);
  (*(void (**)(_QWORD *, uint64_t))(*a1 + 248))(a1, a2);
  return v12;
}

HGRenderer *HGRenderer::RenderNodeBgn(HGRenderer *this, HGNode *a2, int a3)
{
  HGRenderer *v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  v5 = this;
  while (1)
  {
    v6 = *((_DWORD *)a2 + 52);
    if (v6)
      break;
    *((_DWORD *)a2 + 54) = a3;
    *((_QWORD *)a2 + 26) = 1;
    v7 = *((unsigned int *)a2 + 22);
    if ((int)v7 >= 2)
    {
      v8 = v7 + 1;
      do
      {
        v9 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * (v8 - 2));
        if (v9)
        {
          v10 = *(_QWORD *)(v9 + 16);
          if (v10)
            this = (HGRenderer *)HGRenderer::RenderNodeBgn(v5, *(HGNode **)(v10 + 144), a3);
        }
        --v8;
      }
      while (v8 > 2);
    }
    v11 = (uint64_t *)*((_QWORD *)a2 + 10);
    if (v11)
    {
      v12 = *v11;
      if (v12)
      {
        v13 = *(_QWORD *)(v12 + 16);
        if (v13)
        {
          a2 = *(HGNode **)(v13 + 144);
          if (a2)
            continue;
        }
      }
    }
    return this;
  }
  if (*((_DWORD *)a2 + 54) != a3)
    *((_DWORD *)a2 + 54) = -1;
  *((_DWORD *)a2 + 52) = v6 + 1;
  return this;
}

HGRenderer *HGRenderer::RenderNodeEnd(HGRenderer *this, HGNode *a2)
{
  HGRenderer *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;

  v3 = this;
  do
  {
    if (!*((_DWORD *)a2 + 52))
      break;
    *((_QWORD *)a2 + 26) = 0;
    *((_DWORD *)a2 + 34) &= ~8u;
    v4 = *((unsigned int *)a2 + 22);
    if ((int)v4 >= 2)
    {
      v5 = v4 + 1;
      do
      {
        v6 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * (v5 - 2));
        if (v6)
        {
          v7 = *(_QWORD *)(v6 + 16);
          if (v7)
            this = (HGRenderer *)HGRenderer::RenderNodeEnd(v3, *(HGNode **)(v7 + 144));
        }
        --v5;
      }
      while (v5 > 2);
    }
    v8 = (uint64_t *)*((_QWORD *)a2 + 10);
    if (v8)
    {
      v9 = *v8;
      if (v9)
      {
        a2 = *(HGNode **)(v9 + 16);
        if (!a2)
          break;
      }
    }
    a2 = (HGNode *)*((_QWORD *)a2 + 18);
  }
  while (a2);
  return this;
}

uint64_t HGRenderer::SetROI(HGRenderer *this, HGNode *a2, HGRect a3, int a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v11;
  uint64_t DOD;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  char *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  char *v23;
  HGLogger *v24;
  int v25;
  void **v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  HGNode *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *__p[2];
  char v40;
  void *v41[2];
  char v42;
  void *v43;
  char v44;
  HGRect v45;

  v7 = *(_QWORD *)&a3.var2;
  v8 = *(_QWORD *)&a3.var0;
  v11 = 0;
  do
  {
    DOD = HGRenderer::GetDOD(this, a2);
    v14 = HGRectIntersection(v8, v7, DOD, v13);
    v18 = v14;
    v19 = v15;
    if (*((_DWORD *)a2 + 53))
    {
      *((_QWORD *)a2 + 21) = HGRectUnion(*((_QWORD *)a2 + 21), *((_QWORD *)a2 + 22), v14, v15);
      *((_QWORD *)a2 + 22) = v20;
      ++*((_DWORD *)a2 + 53);
      if (*((int *)this + 161) < 1)
        goto LABEL_15;
    }
    else
    {
      *((_QWORD *)a2 + 21) = v14;
      *((_QWORD *)a2 + 22) = v15;
      *((_DWORD *)a2 + 53) = 1;
      if (*((int *)this + 161) < 1)
        goto LABEL_15;
    }
    v21 = (*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 48))(a2);
    HGLogger::log((HGLogger *)"graph", (const char *)1, (HGLogger *)"%d: %p = %s: ROI [%d %d %d %d] DOD [%d %d %d %d]\n", v22, v23, a5, a2, v21, v18, HIDWORD(v18), v19, HIDWORD(v19), *((unsigned int *)a2 + 38), *((unsigned int *)a2 + 39), *((unsigned int *)a2 + 40), *((unsigned int *)a2 + 41));
    v25 = *((_DWORD *)this + 161);
    if (v25 < 2)
    {
LABEL_15:
      v27 = *((unsigned int *)a2 + 53);
      if ((_DWORD)v27 != *((_DWORD *)a2 + 52))
        return HGLogger::indent(v11);
      goto LABEL_16;
    }
    v44 = 0;
    LOBYTE(v43) = 0;
    HGLogger::getNewlinePreamble((uint64_t *)v41, v24);
    (*(void (**)(void **__return_ptr, HGNode *, _QWORD, void **, void **))(*(_QWORD *)a2 + 64))(__p, a2, (v25 - 1), &v43, v41);
    if (v40 < 0)
    {
      if (!__p[1])
        goto LABEL_29;
      v26 = (void **)__p[0];
    }
    else
    {
      if (!v40)
        goto LABEL_13;
      v26 = __p;
    }
    HGLogger::log((HGLogger *)"graph", (const char *)*((unsigned int *)this + 161), (HGLogger *)"%s\n", v16, v17, v26);
    if ((v40 & 0x80000000) == 0)
    {
LABEL_13:
      if ((v42 & 0x80000000) == 0)
        goto LABEL_14;
      goto LABEL_30;
    }
LABEL_29:
    operator delete(__p[0]);
    if ((v42 & 0x80000000) == 0)
    {
LABEL_14:
      if ((v44 & 0x80000000) == 0)
        goto LABEL_15;
      goto LABEL_31;
    }
LABEL_30:
    operator delete(v41[0]);
    if ((v44 & 0x80000000) == 0)
      goto LABEL_15;
LABEL_31:
    operator delete(v43);
    v27 = *((unsigned int *)a2 + 53);
    if ((_DWORD)v27 != *((_DWORD *)a2 + 52))
      return HGLogger::indent(v11);
LABEL_16:
    *((_DWORD *)a2 + 53) = 0;
    *((_DWORD *)a2 + 34) |= 8u;
    if ((int)v27 >= 2 && *((int *)this + 161) >= 1)
      HGLogger::log((HGLogger *)"graph", (const char *)1, (HGLogger *)" + Total ROI from %d branches [%d %d %d %d]\n", v16, v17, v27, *((unsigned int *)a2 + 42), *((unsigned int *)a2 + 43), *((unsigned int *)a2 + 44), *((unsigned int *)a2 + 45));
    HGLogger::indent(1);
    ++a4;
    v28 = *((unsigned int *)a2 + 22);
    if ((int)v28 > 1)
    {
      do
      {
        v35 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * --v28);
        if (v35 && *(_QWORD *)(v35 + 16))
        {
          *(_QWORD *)&v45.var0 = (*(uint64_t (**)(HGNode *, HGRenderer *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 400))(a2, this, v28, *((_QWORD *)a2 + 21), *((_QWORD *)a2 + 22));
          *(_QWORD *)&v45.var2 = v36;
          v37 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * v28);
          *(_QWORD *)(v37 + 32) = *(_QWORD *)&v45.var0;
          *(_QWORD *)(v37 + 40) = v36;
          HGRenderer::SetROI(this, *(HGNode **)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * v28) + 16) + 144), v45, a4, v28);
        }
      }
      while ((unint64_t)(v28 + 1) > 2);
    }
    v11 = (v11 - 1);
    v29 = (uint64_t *)*((_QWORD *)a2 + 10);
    if (!v29)
      break;
    v30 = *v29;
    if (!v30)
      break;
    v31 = *(_QWORD *)(v30 + 16);
    if (!v31)
      break;
    v32 = *(HGNode **)(v31 + 144);
    v8 = (*(uint64_t (**)(HGNode *, HGRenderer *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a2 + 400))(a2, this, 0, *((_QWORD *)a2 + 21), *((_QWORD *)a2 + 22));
    v7 = v33;
    a5 = 0;
    v34 = **((_QWORD **)a2 + 10);
    *(_QWORD *)(v34 + 32) = v8;
    *(_QWORD *)(v34 + 40) = v33;
    a2 = v32;
  }
  while (v32);
  return HGLogger::indent(v11);
}

void sub_1B2A7E04C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  uint64_t v32;

  if (a26 < 0)
  {
    operator delete(__p);
    if ((a32 & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v32 - 89) & 0x80000000) == 0)
        goto LABEL_4;
      goto LABEL_7;
    }
  }
  else if ((a32 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a27);
  if ((*(char *)(v32 - 89) & 0x80000000) == 0)
LABEL_4:
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(*(void **)(v32 - 112));
  _Unwind_Resume(exception_object);
}

uint64_t HGRenderer::GetDOD(HGRenderer *this, HGNode *a2)
{
  HGNode *Output;
  __int128 *v4;
  HGNode *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t DOD;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  Output = HGRenderer::GetOutput(this, a2);
  v4 = &HGRectNull;
  if (Output)
  {
    v5 = Output;
    if ((*((_BYTE *)Output + 136) & 4) == 0)
    {
      v6 = *((_DWORD *)Output + 22);
      if (v6 < 1)
        goto LABEL_13;
      v7 = 0;
      v8 = 0;
      do
      {
        v9 = *(_QWORD *)(*((_QWORD *)v5 + 10) + 8 * v7);
        if (v9)
        {
          v10 = *(_QWORD *)(v9 + 16);
          if (v10)
          {
            DOD = HGRenderer::GetDOD(this, *(HGNode **)(v10 + 144));
            v14 = (*(uint64_t (**)(HGNode *, HGRenderer *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5 + 392))(v5, this, v7, DOD, v12);
            v15 = v13;
            if (v8)
            {
              v14 = HGRectUnion(*((_QWORD *)v5 + 19), *((_QWORD *)v5 + 20), v14, v13);
              v15 = v16;
            }
            *((_QWORD *)v5 + 19) = v14;
            *((_QWORD *)v5 + 20) = v15;
            v8 = 1;
            v6 = *((_DWORD *)v5 + 22);
          }
        }
        ++v7;
      }
      while (v7 < v6);
      if (!v8)
      {
LABEL_13:
        *((_QWORD *)v5 + 19) = (*(uint64_t (**)(HGNode *, HGRenderer *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v5 + 392))(v5, this, 0, 0, 0);
        *((_QWORD *)v5 + 20) = v17;
      }
      *((_DWORD *)v5 + 34) |= 4u;
    }
    v4 = (__int128 *)((char *)v5 + 152);
  }
  return *(_QWORD *)v4;
}

uint64_t HGRenderer::SetTilesROI(HGRenderer *this, HGNode *a2, HGRect a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t DOD;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  HGRect v17;

  v3 = *(_QWORD *)&a3.var2;
  v4 = *(_QWORD *)&a3.var0;
  DOD = HGRenderer::GetDOD(this, a2);
  result = HGRectIntersection(v4, v3, DOD, v8);
  if (*((_DWORD *)a2 + 60))
  {
    result = HGRectUnion(*(_QWORD *)((char *)a2 + 220), *(_QWORD *)((char *)a2 + 228), result, v10);
    *(_QWORD *)((char *)a2 + 220) = result;
    *(_QWORD *)((char *)a2 + 228) = v11;
    v12 = *((_DWORD *)a2 + 59);
    v13 = *((_DWORD *)a2 + 60) + 1;
    *((_DWORD *)a2 + 60) = v13;
    if (v13 != v12)
      return result;
  }
  else
  {
    *(_QWORD *)((char *)a2 + 220) = result;
    *(_QWORD *)((char *)a2 + 228) = v10;
    *((_DWORD *)a2 + 60) = 1;
    if (*((_DWORD *)a2 + 59) != 1)
      return result;
  }
  *((_DWORD *)a2 + 60) = 0;
  v14 = *((unsigned int *)a2 + 22);
  if ((int)v14 >= 1)
  {
    do
    {
      v15 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * --v14);
      if (v15)
      {
        if (*(_QWORD *)(v15 + 16))
        {
          *(_QWORD *)&v17.var0 = (*(uint64_t (**)(HGNode *, HGRenderer *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 400))(a2, this, v14, *(_QWORD *)((char *)a2 + 220), *(_QWORD *)((char *)a2 + 228));
          *(_QWORD *)&v17.var2 = v16;
          result = HGRenderer::SetTilesROI(this, *(HGNode **)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * v14) + 16) + 144), v17);
        }
      }
    }
    while ((unint64_t)(v14 + 1) > 1);
  }
  return result;
}

void HGRenderer::DotNode(HGRenderer *this, HGNode *a2)
{
  const char *v4;
  size_t v5;
  std::string::size_type v6;
  std::string *p_dst;
  uint64_t v8;
  uint64_t v9;
  const std::string::value_type *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  std::ios_base *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  _QWORD *v20;
  const std::string::value_type *v21;
  std::string::size_type v22;
  int v23;
  std::string::size_type v24;
  unsigned __int8 v25;
  const std::string::value_type *v26;
  std::string::size_type v27;
  std::string *v28;
  int v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  int v35;
  const char *v36;
  char IsMergedWithInput;
  const char *v38;
  uint64_t v39;
  void *v40;
  uint64_t *v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *__p[2];
  void *v47[2];
  int v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  std::string::value_type *v52;
  std::string::size_type v53;
  unsigned __int8 v54;
  void *v55[2];
  unsigned __int8 v56;
  std::string __dst;

  v41 = (uint64_t *)((char *)this + 840);
  if (!HGDotGraph::on((HGRenderer *)((char *)this + 840)))
    return;
  v4 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 48))(a2);
  v5 = strlen(v4);
  if (v5 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v6 = v5;
  if (v5 >= 0x17)
  {
    v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v8 = v5 | 7;
    v9 = v8 + 1;
    p_dst = (std::string *)operator new(v8 + 1);
    __dst.__r_.__value_.__l.__size_ = v6;
    __dst.__r_.__value_.__r.__words[2] = v9 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_9;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v5;
  p_dst = &__dst;
  if (v5)
LABEL_9:
    memmove(p_dst, v4, v6);
  p_dst->__r_.__value_.__s.__data_[v6] = 0;
  if ((*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 56))(a2))
  {
    std::string::append(&__dst, "\\n");
    v10 = (const std::string::value_type *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)a2 + 56))(a2);
    std::string::append(&__dst, v10);
  }
  if (*((int *)this + 164) >= 2)
  {
    snprintf(HGRenderer::DotNode(HGNode *)::str, 0x100uLL, "DOD [%d %d %d %d]\\nROI [%d %d %d %d]", *((_DWORD *)a2 + 38), *((_DWORD *)a2 + 39), *((_DWORD *)a2 + 40), *((_DWORD *)a2 + 41), *((_DWORD *)a2 + 42), *((_DWORD *)a2 + 43), *((_DWORD *)a2 + 44), *((_DWORD *)a2 + 45));
    std::string::append(&__dst, "\\n");
    std::string::append(&__dst, HGRenderer::DotNode(HGNode *)::str);
  }
  if ((*(unsigned int (**)(HGRenderer *))(*(_QWORD *)this + 304))(this) && *((_DWORD *)this + 162))
  {
    if (*((int *)this + 164) < 2)
      goto LABEL_42;
    v11 = MEMORY[0x1E0DE4FE0];
    v12 = MEMORY[0x1E0DE4FE0] + 64;
    v13 = MEMORY[0x1E0DE4F60];
    v14 = *(void **)(MEMORY[0x1E0DE4F60] + 8);
    v15 = *(void **)(MEMORY[0x1E0DE4F60] + 16);
    v50 = MEMORY[0x1E0DE4FE0] + 64;
    v42 = v14;
    *(void **)((char *)&v42 + *((_QWORD *)v14 - 3)) = v15;
    v16 = (std::ios_base *)((char *)&v42 + *((_QWORD *)v42 - 3));
    std::ios_base::init(v16, &v43);
    v16[1].__vftable = 0;
    v16[1].__fmtflags_ = -1;
    v42 = (void *)(v11 + 24);
    v50 = v12;
    std::streambuf::basic_streambuf();
    v17 = MEMORY[0x1E0DE4FB8];
    v43 = MEMORY[0x1E0DE4FB8] + 16;
    *(_OWORD *)__p = 0u;
    *(_OWORD *)v47 = 0u;
    v48 = 16;
    v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v42, (uint64_t)"\\n", 2);
    v19 = *v18;
    *(_DWORD *)((char *)v18 + *(_QWORD *)(*v18 - 24) + 8) = *(_DWORD *)((_BYTE *)v18 + *(_QWORD *)(*v18 - 24) + 8) & 0xFFFFFEFB | 4;
    *(uint64_t *)((char *)v18 + *(_QWORD *)(v19 - 24) + 24) = 7;
    *(uint64_t *)((char *)v18 + *(_QWORD *)(v19 - 24) + 16) = 2;
    HGStats::GraphStats::getNodeTime(*((HGStats::GraphStats **)this + 70), a2);
    v20 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)" ms", 3);
    std::stringbuf::str();
    if ((v56 & 0x80u) == 0)
      v21 = (const std::string::value_type *)v55;
    else
      v21 = (const std::string::value_type *)v55[0];
    if ((v56 & 0x80u) == 0)
      v22 = v56;
    else
      v22 = (std::string::size_type)v55[1];
    std::string::append(&__dst, v21, v22);
    if ((char)v56 < 0)
      operator delete(v55[0]);
    v42 = *(void **)v13;
    *(void **)((char *)&v42 + *((_QWORD *)v42 - 3)) = *(void **)(v13 + 24);
    v43 = v17 + 16;
    if (SHIBYTE(v47[0]) < 0)
      operator delete(__p[0]);
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    MEMORY[0x1B5E290BC](&v50);
  }
  v23 = *((_DWORD *)this + 164);
  if (v23 >= 3)
  {
    HIBYTE(v44) = 0;
    LOBYTE(v42) = 0;
    v56 = 0;
    LOBYTE(v55[0]) = 0;
    (*(void (**)(std::string::value_type **__return_ptr, HGNode *, _QWORD, void **, void **))(*(_QWORD *)a2 + 64))(&v52, a2, (v23 - 2), &v42, v55);
    v24 = v54;
    v25 = v54;
    if ((v54 & 0x80u) != 0)
      v24 = v53;
    if (v24)
    {
      std::string::append(&__dst, "\\n");
      if ((v54 & 0x80u) == 0)
        v26 = (const std::string::value_type *)&v52;
      else
        v26 = v52;
      if ((v54 & 0x80u) == 0)
        v27 = v54;
      else
        v27 = v53;
      std::string::append(&__dst, v26, v27);
      v25 = v54;
    }
    if ((v25 & 0x80) != 0)
    {
      operator delete(v52);
      if (((char)v56 & 0x80000000) == 0)
      {
LABEL_41:
        if ((SHIBYTE(v44) & 0x80000000) == 0)
          goto LABEL_42;
LABEL_66:
        operator delete(v42);
        goto LABEL_42;
      }
    }
    else if (((char)v56 & 0x80000000) == 0)
    {
      goto LABEL_41;
    }
    operator delete(v55[0]);
    if ((SHIBYTE(v44) & 0x80000000) == 0)
      goto LABEL_42;
    goto LABEL_66;
  }
LABEL_42:
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v28 = &__dst;
  else
    v28 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  if (*((_BYTE *)a2 + 105))
    v29 = 2;
  else
    v29 = *((unsigned __int8 *)a2 + 106);
  HGDotGraph::node(v41, (unint64_t)a2, (uint64_t)v28, v29);
  v30 = *((unsigned int *)a2 + 22);
  if ((int)v30 >= 1)
  {
    v31 = (void *)*MEMORY[0x1E0DE4F50];
    v39 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
    v40 = *(void **)(MEMORY[0x1E0DE4F50] + 64);
    v32 = MEMORY[0x1E0DE4FB8] + 16;
    do
    {
      v33 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * --v30);
      if (v33 && *(_QWORD *)(v33 + 16))
      {
        std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v42);
        std::ostream::operator<<();
        v34 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * v30) + 16) + 144);
        std::stringbuf::str();
        v35 = (char)v56;
        v36 = (const char *)v55[0];
        IsMergedWithInput = HGNode::IsMergedWithInput(a2, v30);
        if (v35 >= 0)
          v38 = (const char *)v55;
        else
          v38 = v36;
        HGDotGraph::link(v41, v34, (unint64_t)a2, v38, IsMergedWithInput);
        if ((char)v56 < 0)
          operator delete(v55[0]);
        v42 = v31;
        *(void **)((char *)&v42 + *((_QWORD *)v31 - 3)) = v40;
        v44 = v39;
        v45 = v32;
        if (v49 < 0)
          operator delete(v47[0]);
        std::streambuf::~streambuf();
        std::iostream::~basic_iostream();
        MEMORY[0x1B5E290BC](&v51);
      }
    }
    while ((unint64_t)(v30 + 1) > 1);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
}

void sub_1B2A7E880(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;

  if (*(char *)(v27 - 113) < 0)
    operator delete(*(void **)(v27 - 136));
  std::ostringstream::~ostringstream((uint64_t)&__p);
  if (*(char *)(v27 - 89) < 0)
  {
    operator delete(*(void **)(v27 - 112));
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void HGRenderer::SetBufferDumpDir(uint64_t a1, const char *a2)
{
  std::string::size_type size;
  std::string v5;

  HG_RENDERER_ENV::BUFFER_DUMP_DIR(&v5);
  if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0)
  {
    size = v5.__r_.__value_.__l.__size_;
    operator delete(v5.__r_.__value_.__l.__data_);
    if (size)
      return;
  }
  else if (*((_BYTE *)&v5.__r_.__value_.__s + 23))
  {
    return;
  }
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  HGBufferDumper::setPath((HGBufferDumper *)(a1 + 928), a2);
}

void HGRenderer::SetDotGraphOutputDir(uint64_t a1, const void **a2)
{
  std::string::size_type size;
  std::string *v5;
  char v6;
  size_t v7;
  const void *v8;
  size_t v9;
  const void *v10;
  size_t v11;
  const char *v12;
  char *v13;
  std::string v15;

  HG_RENDERER_ENV::DOT_GRAPH_OUTPUT_DIR(&v15);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
  {
    size = v15.__r_.__value_.__l.__size_;
    operator delete(v15.__r_.__value_.__l.__data_);
    if (size)
      return;
  }
  else if (*((_BYTE *)&v15.__r_.__value_.__s + 23))
  {
    return;
  }
  v5 = (std::string *)(a1 + 1024);
  v6 = *((_BYTE *)a2 + 23);
  if (*(char *)(a1 + 1047) < 0)
  {
    v7 = *(_QWORD *)(a1 + 1032);
    v8 = *(const void **)(a1 + 1024);
  }
  else
  {
    v7 = *(unsigned __int8 *)(a1 + 1047);
    v8 = (const void *)(a1 + 1024);
  }
  if (v6 >= 0)
    v9 = *((unsigned __int8 *)a2 + 23);
  else
    v9 = (size_t)a2[1];
  if (v6 >= 0)
    v10 = a2;
  else
    v10 = *a2;
  if (v9 >= v7)
    v11 = v7;
  else
    v11 = v9;
  if (memcmp(v8, v10, v11) || v9 != v7)
    HGLogger::print((HGLogger *)"Helium Dot Graph Output Directory: %s", v12, v13, v10);
  std::string::operator=(v5, (const std::string *)a2);
}

uint64_t HGRenderer::DumpPreRenderDotTree(HGRenderer *this, HGNode *a2, const char *a3)
{
  int v6;
  char *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  size_t v11;
  _QWORD *v12;
  uint64_t v13;
  void *__p;
  char v16;
  _QWORD v17[2];
  _QWORD v18[11];
  char v19;
  uint64_t v20;

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v17);
  v6 = *((char *)this + 1047);
  if (v6 >= 0)
    v7 = (char *)this + 1024;
  else
    v7 = (char *)*((_QWORD *)this + 128);
  if (v6 >= 0)
    v8 = *((unsigned __int8 *)this + 1047);
  else
    v8 = *((_QWORD *)this + 129);
  v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)v7, v8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"/helium.", 8);
  if (!HG_RENDERER_ENV::FORCE_SINGLE_DOT_FILE)
  {
    v10 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)".", 1);
  }
  v11 = strlen(a3);
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)a3, v11);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)".dot", 4);
  std::stringbuf::str();
  HGNode::WriteDotGraph((uint64_t)a2, (uint64_t)&__p, 2);
  if (v16 < 0)
    operator delete(__p);
  v17[0] = *MEMORY[0x1E0DE4F50];
  v13 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)v17 + *(_QWORD *)(v17[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v18[0] = v13;
  v18[1] = MEMORY[0x1E0DE4FB8] + 16;
  if (v19 < 0)
    operator delete((void *)v18[9]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1B5E290BC](&v20);
}

void sub_1B2A7EC6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
    _Unwind_Resume(a1);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t *HGRenderer::DotLogInplaceRendering(HGRenderer *this, HGNode *a2)
{
  return HGDotGraph::dashed((uint64_t *)this + 105, (unint64_t)a2);
}

uint64_t *HGRenderer::DotLogHWBlending(HGRenderer *this, HGNode *a2, HGNode *a3, int a4)
{
  uint64_t *v5;
  uint64_t *v6;

  v5 = (uint64_t *)((char *)this + 840);
  v6 = (uint64_t *)((char *)this + 840);
  if (!a4)
    return HGDotGraph::linkStyle(v6, (uint64_t *)a2, (uint64_t *)a3, 0, 2);
  HGDotGraph::linkStyle(v6, (uint64_t *)a2, (uint64_t *)a3, 0, 3);
  return HGDotGraph::dashed(v5, (unint64_t)a2);
}

uint64_t HGRenderer::GetOwningRenderQueue(HGRenderer *this)
{
  return *((_QWORD *)this + 136);
}

uint64_t HGRenderer::SetOwningRenderQueue(uint64_t this, HGRenderQueue *a2)
{
  *(_QWORD *)(this + 1088) = a2;
  return this;
}

void HGRenderer::RenderBgn(HGRenderer *this, int a2)
{
  int v4;
  char *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  const char *p_p;
  uint64_t v10;
  HGExecutionUnit ***v11;
  uint64_t v12;
  uint64_t v13;
  HGExecutionUnit *v14;
  unint64_t v15;
  HGExecutionUnit **v16;
  HGExecutionUnit **v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  _BYTE *v23;
  HGExecutionUnit **v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  HGExecutionUnit **v28;
  _OWORD *v29;
  HGExecutionUnit **v30;
  uint64_t v31;
  __int128 v32;
  HGExecutionUnit *v33;
  uint64_t v34;
  HGExecutionUnit *v35;
  int v36;
  void *__p;
  char v38;
  _QWORD v39[2];
  _QWORD v40[11];
  char v41;
  uint64_t v42;

  kdebug_trace();
  if (HGDotGraph::on((HGRenderer *)((char *)this + 840)))
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v39);
    v4 = *((char *)this + 1047);
    if (v4 >= 0)
      v5 = (char *)this + 1024;
    else
      v5 = (char *)*((_QWORD *)this + 128);
    if (v4 >= 0)
      v6 = *((unsigned __int8 *)this + 1047);
    else
      v6 = *((_QWORD *)this + 129);
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)v5, v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)"/helium.", 8);
    if (!HG_RENDERER_ENV::FORCE_SINGLE_DOT_FILE)
    {
      v8 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)".", 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)"tree.dot", 8);
    std::stringbuf::str();
    if (v38 >= 0)
      p_p = (const char *)&__p;
    else
      p_p = (const char *)__p;
    HGDotGraph::begin((HGRenderer *)((char *)this + 840), p_p);
    if (v38 < 0)
      operator delete(__p);
    v39[0] = *MEMORY[0x1E0DE4F50];
    v10 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
    *(_QWORD *)((char *)v39 + *(_QWORD *)(v39[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
    v40[0] = v10;
    v40[1] = MEMORY[0x1E0DE4FB8] + 16;
    if (v41 < 0)
      operator delete((void *)v40[9]);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1B5E290BC](&v42);
  }
  v36 = a2;
  HGBufferDumper::reset((std::string *)((char *)this + 928));
  v11 = (HGExecutionUnit ***)((char *)this + 248);
  v12 = (*((_QWORD *)this + 32) - *((_QWORD *)this + 31)) >> 3;
  if (*((_DWORD *)this + 149) > (int)v12)
  {
    while (1)
    {
      v14 = (HGExecutionUnit *)operator new();
      HGExecutionUnit::HGExecutionUnit(v14, this, v12);
      *((_DWORD *)v14 + 110) = *((_DWORD *)this + 268);
      v16 = (HGExecutionUnit **)*((_QWORD *)this + 32);
      v15 = *((_QWORD *)this + 33);
      if ((unint64_t)v16 >= v15)
        break;
      *v16 = v14;
      v13 = (uint64_t)(v16 + 1);
LABEL_21:
      *((_QWORD *)this + 32) = v13;
      v12 = (unint64_t)(v13 - *((_QWORD *)this + 31)) >> 3;
      if (*((_DWORD *)this + 149) <= (int)v12)
        goto LABEL_43;
    }
    v17 = *v11;
    v18 = (char *)v16 - (char *)*v11;
    v19 = v18 >> 3;
    v20 = (v18 >> 3) + 1;
    if (v20 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v21 = v15 - (_QWORD)v17;
    if (v21 >> 2 > v20)
      v20 = v21 >> 2;
    if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8)
      v22 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v22 = v20;
    if (v22)
    {
      if (v22 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v23 = operator new(8 * v22);
      v24 = (HGExecutionUnit **)&v23[8 * v19];
      *v24 = v14;
      v13 = (uint64_t)(v24 + 1);
      if (v16 == v17)
        goto LABEL_41;
    }
    else
    {
      v23 = 0;
      v24 = (HGExecutionUnit **)(8 * v19);
      *(_QWORD *)(8 * v19) = v14;
      v13 = 8 * v19 + 8;
      if (v16 == v17)
      {
LABEL_41:
        *((_QWORD *)this + 31) = v24;
        *((_QWORD *)this + 32) = v13;
        *((_QWORD *)this + 33) = &v23[8 * v22];
        if (v16)
          operator delete(v16);
        goto LABEL_21;
      }
    }
    v25 = (char *)(v16 - 1) - (char *)v17;
    if (v25 < 0x58)
      goto LABEL_57;
    if ((unint64_t)((char *)v16 - &v23[v18]) < 0x20)
      goto LABEL_57;
    v26 = (v25 >> 3) + 1;
    v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
    v28 = &v16[v27 / 0xFFFFFFFFFFFFFFF8];
    v24 = (HGExecutionUnit **)((char *)v24 - v27);
    v29 = &v23[8 * v19 - 16];
    v30 = v16 - 2;
    v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v32 = *(_OWORD *)v30;
      *(v29 - 1) = *((_OWORD *)v30 - 1);
      *v29 = v32;
      v29 -= 2;
      v30 -= 4;
      v31 -= 4;
    }
    while (v31);
    v16 = v28;
    if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_57:
      do
      {
        v33 = *--v16;
        *--v24 = v33;
      }
      while (v16 != v17);
    }
    v16 = *v11;
    goto LABEL_41;
  }
LABEL_43:
  (*(void (**)(HGRenderer *))(*(_QWORD *)this + 288))(this);
  if (v36)
  {
    *((_DWORD *)this + 262) = 0;
    if (!*((_DWORD *)this + 158))
      *((_QWORD *)this + 132) = HGGetTBC();
    HGStats::GraphStats::clear(*((uint64_t ***)this + 70));
    HGStats::GraphStats::start(*((HGProfiler ****)this + 70));
    if (*((int *)this + 149) >= 1)
    {
      v34 = 0;
      do
      {
        while (1)
        {
          HGStats::UnitStats::clear(*(HGStats::UnitStats **)(*(_QWORD *)(*((_QWORD *)this + 31) + 8 * v34) + 424));
          HGStats::UnitStats::enable(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 31) + 8 * v34) + 424), *((_DWORD *)this + 162) != 0);
          HGStats::UnitStats::start(*(HGStats::UnitStatsImpl ***)(*(_QWORD *)(*((_QWORD *)this + 31) + 8 * v34) + 424), 0);
          v35 = *(HGExecutionUnit **)(*((_QWORD *)this + 31) + 8 * v34);
          if (*((int *)this + 158) < 1)
            break;
          HGExecutionUnit::PushStats(v35);
          if (++v34 >= *((int *)this + 149))
            goto LABEL_51;
        }
        HGExecutionUnit::ClearStats(v35);
        ++v34;
      }
      while (v34 < *((int *)this + 149));
    }
LABEL_51:
    *(_QWORD *)((char *)this + 692) = 0;
  }
  ++*((_DWORD *)this + 158);
}

void sub_1B2A7F14C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0)
  {
    operator delete(__p);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a16);
    _Unwind_Resume(a1);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void sub_1B2A7F198(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A0C408E851C7FLL);
  _Unwind_Resume(a1);
}

uint64_t HGRenderer::RenderEnd(HGRenderer *this, int a2)
{
  HGRenderer *v3;
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = this;
  v4 = atomic_load((unsigned __int8 *)&qword_1ED4DAA18);
  if ((v4 & 1) == 0)
  {
    this = (HGRenderer *)__cxa_guard_acquire(&qword_1ED4DAA18);
    if ((_DWORD)this)
    {
      LOBYTE(_MergedGlobals_11) = 0;
      __cxa_atexit((void (*)(void *))StaticInitTracker::~StaticInitTracker, &_MergedGlobals_11, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4DAA18);
    }
  }
  if ((_BYTE)_MergedGlobals_11)
  {
    puts("-------------------------------------------------------------------");
    puts("Helium ERROR : C++ teardown in progress!!");
    puts("               Accessing Helium during static objects destruction!!");
    this = (HGRenderer *)puts("-------------------------------------------------------------------");
  }
  HGMemory::renderEnd(this);
  --*((_DWORD *)v3 + 158);
  if (a2)
  {
    v5 = HGGetTBC();
    HGStats::GraphStats::stop(*((HGProfiler ****)v3 + 70));
    if (*((int *)v3 + 149) <= 0)
    {
      *((_QWORD *)v3 + 133) = v5;
    }
    else
    {
      v6 = 0;
      do
      {
        v8 = *((_QWORD *)v3 + 31);
        if (*((int *)v3 + 158) >= 1)
        {
          HGExecutionUnit::PopStats(*(HGExecutionUnit **)(v8 + 8 * v6));
          v8 = *((_QWORD *)v3 + 31);
        }
        HGStats::UnitStats::stop(*(_QWORD *)(*(_QWORD *)(v8 + 8 * v6) + 424), 0);
        if (!*((_DWORD *)v3 + 262))
          *((_DWORD *)v3 + 262) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v3 + 31) + 8 * v6) + 416) + 100);
        ++v6;
        v7 = *((int *)v3 + 149);
      }
      while (v6 < v7);
      *((_QWORD *)v3 + 133) = v5;
      if ((int)v7 >= 1)
      {
        v9 = 0;
        do
          HGStats::GraphStats::merge(*((HGStats::GraphStatsImpl ***)v3 + 70), *(const HGStats::UnitStatsImpl ***)(*(_QWORD *)(*((_QWORD *)v3 + 31) + 8 * v9++) + 424));
        while (v9 < *((int *)v3 + 149));
      }
    }
    HGStats::RendererStats::merge(*((HGStats::RendererStatsImpl ***)v3 + 71), *((HGProfiler ****)v3 + 70));
  }
  HGRenderer::StatsProbes((HGProfiler ****)v3);
  HGRenderer::DumpStats((unint64_t)v3);
  return kdebug_trace();
}

void StaticInitTracker::~StaticInitTracker(StaticInitTracker *this)
{
  *(_BYTE *)this = 1;
}

uint64_t HGRenderer::StatsProbes(HGProfiler ****this)
{
  uint64_t v2;
  double v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t result;

  if (((unsigned int (*)(HGProfiler ****))(*this)[38])(this))
    v2 = *((unsigned int *)this + 149);
  else
    v2 = 0;
  v3 = HGStats::GraphStats::time(this[70]);
  ((void (*)(HGProfiler ****, uint64_t, unint64_t))(*this)[38])(this, v2, (unint64_t)(v3 * 1000.0));
  if (((unsigned int (*)(HGProfiler ****))(*this)[38])(this))
    v4 = *((unsigned int *)this + 149);
  else
    v4 = 0;
  v5 = (unint64_t)(HGStats::RendererStats::time((HGStats::RendererStats *)this[71]) * 1000.0);
  v6 = HGStats::RendererStats::count((HGStats::RendererStats *)this[71]);
  result = ((uint64_t (*)(HGProfiler ****, uint64_t, unint64_t, uint64_t))(*this)[38])(this, v4, v5, v6);
  if ((_DWORD)result)
    return 0;
  return result;
}

unint64_t HGRenderer::DumpStats(unint64_t this)
{
  unsigned __int8 v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  std::ios_base *v10;
  uint64_t v11;
  uint64_t v12;
  const char *p_p;
  double v14;
  double v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unsigned __int8 v21;
  float v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  int v26;
  float v27;
  float v28;
  int v29;
  float v30;
  int v31;
  float v32;
  int v33;
  float v34;
  int v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  int v41;
  int v42;
  float v43;
  int v44;
  float v45;
  int v46;
  float v47;
  int v48;
  float v49;
  int v50;
  float v51;
  int v52;
  float v53;
  int v54;
  float v55;
  int v56;
  float v57;
  int v58;
  float v59;
  int v60;
  float v61;
  int v62;
  float v63;
  int v64;
  float v65;
  int v66;
  float v67;
  int v68;
  float v69;
  int v70;
  float v71;
  float v72;
  float v73;
  float v74;
  int v75;
  unsigned int v76;
  float v77;
  float v78;
  double v79;
  unint64_t v80;
  double v81;
  void *__p;
  char v83;
  uint64_t v84;
  uint64_t v85[8];
  void *v86[2];
  __int128 v87;
  int v88;
  uint64_t v89[19];

  v1 = atomic_load(HGLogger::_enabled);
  if ((v1 & 1) != 0)
  {
    v2 = this;
    v3 = *(_DWORD *)(this + 652);
    if (v3 >= 1)
    {
      if (v3 == 1)
        v4 = 256;
      else
        v4 = 65792;
      if (v3 >= 3 && (*(unsigned int (**)(unint64_t))(*(_QWORD *)this + 304))(this))
        v4 = 394752;
      v5 = MEMORY[0x1E0DE4FE0];
      v6 = MEMORY[0x1E0DE4FE0] + 64;
      v7 = (uint64_t *)MEMORY[0x1E0DE4F60];
      v8 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
      v9 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
      v89[0] = MEMORY[0x1E0DE4FE0] + 64;
      v84 = v8;
      *(uint64_t *)((char *)&v85[-1] + *(_QWORD *)(v8 - 24)) = v9;
      v10 = (std::ios_base *)((char *)&v85[-1] + *(_QWORD *)(v84 - 24));
      std::ios_base::init(v10, v85);
      v10[1].__vftable = 0;
      v10[1].__fmtflags_ = -1;
      v84 = v5 + 24;
      v89[0] = v6;
      std::streambuf::basic_streambuf();
      v11 = MEMORY[0x1E0DE4FB8];
      v85[0] = MEMORY[0x1E0DE4FB8] + 16;
      *(_OWORD *)v86 = 0u;
      v87 = 0u;
      v88 = 16;
      if (*(int *)(v2 + 596) >= 1)
      {
        v12 = 0;
        do
          HGStats::UnitStats::dump(*(uint64_t ***)(*(_QWORD *)(*(_QWORD *)(v2 + 248) + 8 * v12++) + 424), &v84, v4);
        while (v12 < *(int *)(v2 + 596));
      }
      HGStats::GraphStats::dump(*(uint64_t **)(v2 + 560), &v84, v4);
      HGStats::RendererStats::dump(*(_QWORD ***)(v2 + 568), &v84, v4);
      std::stringbuf::str();
      if (v83 >= 0)
        p_p = (const char *)&__p;
      else
        p_p = (const char *)__p;
      printf("%s", p_p);
      if (v83 < 0)
        operator delete(__p);
      v84 = *v7;
      *(uint64_t *)((char *)&v85[-1] + *(_QWORD *)(v84 - 24)) = v7[3];
      v85[0] = v11 + 16;
      if (SBYTE7(v87) < 0)
        operator delete(v86[0]);
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      this = MEMORY[0x1B5E290BC](v89);
      if (*(int *)(v2 + 652) >= 1)
      {
        v14 = (double)(unint64_t)(*(_QWORD *)(v2 + 1064) - *(_QWORD *)(v2 + 1056)) * 1000.0;
        this = HGGetTBCFrequency();
        v15 = v14 / (double)this;
        v16 = *(_DWORD *)(v2 + 652);
        if (v16 >= 3)
        {
          this = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 304))(v2);
          if ((this & 1) != 0)
          {
            v17 = *(_QWORD *)(v2 + 1064) - *(_QWORD *)(v2 + 1056);
            v18 = *(int *)(v2 + 596);
            if ((int)v18 <= 0)
            {
              v20 = 0;
            }
            else
            {
              v19 = 0;
              v20 = 0;
              do
              {
                v20 += HGExecutionUnit::StackSize(*(HGExecutionUnit **)(*(_QWORD *)(v2 + 248) + 8 * v19++));
                v18 = *(int *)(v2 + 596);
              }
              while (v19 < (uint64_t)v18);
            }
            v79 = (double)v17 * 1000.0;
            v80 = v20 / v18;
            v81 = v79 / (double)HGGetTBCFrequency();
            printf("\n- Helium Render Stats:");
            printf("\n  +   Wall Time (ms)        : %6.2f", v81);
            printf("\n  +   Mem Used              : %lu", v80);
            this = puts("\n");
            if (*(int *)(v2 + 652) <= 1)
              return this;
LABEL_30:
            v21 = atomic_load((unsigned __int8 *)&qword_1ED4DAA20);
            if ((v21 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DAA20))
            {
              StatsAccumulator::StatsAccumulator((StatsAccumulator *)&qword_1ED4DAA28);
              __cxa_atexit((void (*)(void *))StatsAccumulator::~StatsAccumulator, &qword_1ED4DAA28, &dword_1B2737000);
              __cxa_guard_release(&qword_1ED4DAA20);
            }
            v22 = v15;
            v23 = dword_1ED4DAA40++;
            v24 = dword_1ED4DAA40;
            v25 = qword_1ED4DAA28;
            *(float *)(qword_1ED4DAA28 + 4 * v23) = v22;
            v26 = ((unint64_t)(qword_1ED4DAA30 - v25) >> 2) - 1;
            if (v24 >= (qword_1ED4DAA30 - v25) >> 2)
            {
              dword_1ED4DAA40 = 0;
            }
            else if ((v23 & 0x80000000) == 0)
            {
LABEL_36:
              v27 = *(float *)(v25 + 4 * v23);
              v28 = 0.0;
              v29 = v23 - 1;
              if (v29 < 0)
                v29 = ((unint64_t)(qword_1ED4DAA30 - v25) >> 2) - 1;
              v30 = *(float *)(v25 + 4 * v29);
              v31 = v29 - 1;
              if (v31 < 0)
                v31 = ((unint64_t)(qword_1ED4DAA30 - v25) >> 2) - 1;
              v32 = *(float *)(v25 + 4 * v31);
              v33 = v31 - 1;
              if (v33 < 0)
                v33 = ((unint64_t)(qword_1ED4DAA30 - v25) >> 2) - 1;
              v34 = *(float *)(v25 + 4 * v33);
              v35 = v33 - 1;
              if (v35 >= 0)
                v26 = v35;
              v36 = *(float *)(v25 + 4 * v26);
              v37 = (float)((float)((float)((float)(v27 + 0.0) + v30) + v32) + v34) + v36;
              v38 = fmaxf(v27, 0.0);
              if (v38 < v30)
                v38 = v30;
              if (v38 < v32)
                v38 = v32;
              if (v38 < v34)
                v38 = v34;
              if (v38 < v36)
                v38 = *(float *)(v25 + 4 * v26);
              v39 = 10000000.0;
              v40 = fminf(v27, 10000000.0);
              if (v40 > v30)
                v40 = v30;
              if (v40 > v32)
                v40 = v32;
              if (v40 > v34)
                v40 = v34;
              if (v40 > v36)
                v40 = *(float *)(v25 + 4 * v26);
              printf("last %2d : %.2f ms (%.2f / %.2f)\n", 5, (float)(v37 / 5.0), v40, v38);
              v41 = dword_1ED4DAA40 - 1;
              v42 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
              if (dword_1ED4DAA40 - 1 < 0)
                v41 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
              v43 = *(float *)(qword_1ED4DAA28 + 4 * v41);
              v44 = v41 - 1;
              if (v44 < 0)
                v44 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
              v45 = *(float *)(qword_1ED4DAA28 + 4 * v44);
              v46 = v44 - 1;
              if (v46 < 0)
                v46 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
              v47 = *(float *)(qword_1ED4DAA28 + 4 * v46);
              v48 = v46 - 1;
              if (v48 < 0)
                v48 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
              v49 = *(float *)(qword_1ED4DAA28 + 4 * v48);
              v50 = v48 - 1;
              if (v50 < 0)
                v50 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
              v51 = *(float *)(qword_1ED4DAA28 + 4 * v50);
              v52 = v50 - 1;
              if (v52 < 0)
                v52 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
              v53 = *(float *)(qword_1ED4DAA28 + 4 * v52);
              v54 = v52 - 1;
              if (v54 < 0)
                v54 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
              v55 = *(float *)(qword_1ED4DAA28 + 4 * v54);
              v56 = v54 - 1;
              if (v56 < 0)
                v56 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
              v57 = *(float *)(qword_1ED4DAA28 + 4 * v56);
              v58 = v56 - 1;
              if (v58 < 0)
                v58 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
              v59 = *(float *)(qword_1ED4DAA28 + 4 * v58);
              v60 = v58 - 1;
              if (v60 < 0)
                v60 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
              v61 = *(float *)(qword_1ED4DAA28 + 4 * v60);
              v62 = v60 - 1;
              if (v62 < 0)
                v62 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
              v63 = *(float *)(qword_1ED4DAA28 + 4 * v62);
              v64 = v62 - 1;
              if (v64 < 0)
                v64 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
              v65 = *(float *)(qword_1ED4DAA28 + 4 * v64);
              v66 = v64 - 1;
              if (v66 < 0)
                v66 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
              v67 = *(float *)(qword_1ED4DAA28 + 4 * v66);
              v68 = v66 - 1;
              if (v68 < 0)
                v68 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
              v69 = *(float *)(qword_1ED4DAA28 + 4 * v68);
              v70 = v68 - 1;
              if (v70 >= 0)
                v42 = v70;
              v71 = *(float *)(qword_1ED4DAA28 + 4 * v42);
              v72 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v43 + 0.0) + v45) + v47) + v49)
                                                                                                  + v51)
                                                                                          + v53)
                                                                                  + v55)
                                                                          + v57)
                                                                  + v59)
                                                          + v61)
                                                  + v63)
                                          + v65)
                                  + v67)
                          + v69)
                  + v71;
              v73 = fmaxf(v43, 0.0);
              if (v73 < v45)
                v73 = v45;
              if (v73 < v47)
                v73 = v47;
              if (v73 < v49)
                v73 = v49;
              if (v73 < v51)
                v73 = v51;
              if (v73 < v53)
                v73 = v53;
              if (v73 < v55)
                v73 = v55;
              if (v73 < v57)
                v73 = v57;
              if (v73 < v59)
                v73 = v59;
              if (v73 < v61)
                v73 = v61;
              if (v73 < v63)
                v73 = v63;
              if (v73 < v65)
                v73 = v65;
              if (v73 < v67)
                v73 = v67;
              if (v73 < v69)
                v73 = v69;
              if (v73 < v71)
                v73 = *(float *)(qword_1ED4DAA28 + 4 * v42);
              v74 = fminf(v43, 10000000.0);
              if (v74 > v45)
                v74 = v45;
              if (v74 > v47)
                v74 = v47;
              if (v74 > v49)
                v74 = v49;
              if (v74 > v51)
                v74 = v51;
              if (v74 > v53)
                v74 = v53;
              if (v74 > v55)
                v74 = v55;
              if (v74 > v57)
                v74 = v57;
              if (v74 > v59)
                v74 = v59;
              if (v74 > v61)
                v74 = v61;
              if (v74 > v63)
                v74 = v63;
              if (v74 > v65)
                v74 = v65;
              if (v74 > v67)
                v74 = v67;
              if (v74 > v69)
                v74 = v69;
              if (v74 > v71)
                v74 = *(float *)(qword_1ED4DAA28 + 4 * v42);
              printf("last %2d : %.2f ms (%.2f / %.2f)\n", 15, (float)(v72 / 15.0), v74, v73);
              v75 = dword_1ED4DAA40;
              v76 = 51;
              v77 = 0.0;
              do
              {
                if (--v75 < 0)
                  v75 = ((unint64_t)(qword_1ED4DAA30 - qword_1ED4DAA28) >> 2) - 1;
                v78 = *(float *)(qword_1ED4DAA28 + 4 * v75);
                if (v39 > v78)
                  v39 = *(float *)(qword_1ED4DAA28 + 4 * v75);
                if (v77 < v78)
                  v77 = *(float *)(qword_1ED4DAA28 + 4 * v75);
                v28 = v28 + v78;
                --v76;
              }
              while (v76 > 1);
              return printf("last %2d : %.2f ms (%.2f / %.2f)\n", 50, (float)(v28 / 50.0), v39, v77);
            }
            v23 = ((unint64_t)(qword_1ED4DAA30 - v25) >> 2) - 1;
            goto LABEL_36;
          }
          v16 = *(_DWORD *)(v2 + 652);
        }
        if (v16 >= 1)
          this = printf("\nHelium Time (ms) : %6.2f\n", v15);
        if (*(int *)(v2 + 652) > 1)
          goto LABEL_30;
      }
    }
  }
  return this;
}

void sub_1B2A7FC74(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1ED4DAA20);
  _Unwind_Resume(a1);
}

void sub_1B2A7FC8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B2A7FCA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x1B5E290BC](v1);
  _Unwind_Resume(a1);
}

void HGRenderer::AdjustForBufferLocation(uint64_t a1, const char *a2, char *a3)
{
  char *v3;

  if (((_DWORD)a3 - 3) < 3)
  {
    v3 = "GPU buffer location destination provided for CPU renderer.";
LABEL_3:
    HGLogger::warning((HGLogger *)v3, a2, a3);
    return;
  }
  if ((_DWORD)a3 == 1)
  {
    v3 = "kRenderBufferIOSurface location for CPU renderer: not yet unimplemented, sorry.";
    goto LABEL_3;
  }
}

uint64_t HGRenderer::AdjustForBufferLocation(uint64_t a1, uint64_t a2)
{
  if (a2)
    (*(void (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  return a2;
}

uint64_t HGRenderer::PreRenderTraversal(HGRenderer *this, HGNode *a2)
{
  char v5;
  uint64_t (**v6)();
  int v7;

  v7 = 4098;
  kdebug_trace();
  if ((*((_BYTE *)a2 + 136) & 2) != 0)
  {
    v6 = off_1E6525FD0;
    HGTraversal::IterativeUniqueTraversal<(HGTraversal::NodeInput)1,(HGTraversal::IteratorOrder)0,(HGTraversal::TraversalOrder)0,(HGTraversal::InputOrder)0>::operator()((uint64_t)&v5, this, (uint64_t)a2, (uint64_t)&v6);
  }
  else
  {
    v6 = off_1E6525F98;
    HGTraversal::IterativeUniqueTraversal<(HGTraversal::NodeInput)0,(HGTraversal::IteratorOrder)0,(HGTraversal::TraversalOrder)0,(HGTraversal::InputOrder)0>::operator()((uint64_t)&v5, (uint64_t)this, (uint64_t)a2, (uint64_t)&v6);
  }
  return kdebug_trace();
}

void sub_1B2A7FE14(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 20));
  _Unwind_Resume(a1);
}

void sub_1B2A7FE28(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 20));
  _Unwind_Resume(a1);
}

uint64_t HGRenderer::Render(HGRenderer *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, char *a6)
{
  uint64_t v6;
  uint64_t v8;
  _QWORD v9[4];
  int v10;
  int v11;

  v9[0] = a5;
  v9[1] = 0;
  v9[2] = a2;
  v9[3] = a3;
  v10 = a4;
  v11 = 0;
  HGRenderer::RenderNode(a1, (const HGRendererOutput *)v9, a6, &v8);
  v6 = v8;
  if (v8)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  }
  return v6;
}

void sub_1B2A7FEAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void HGRenderer::RenderNode(HGRenderer *this@<X0>, const HGRendererOutput *a2@<X1>, char *a3@<X2>, _QWORD *a4@<X8>)
{
  _OWORD *v8;
  __int128 v9;
  const char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  void *__p;
  char *v19;
  _QWORD v20[3];

  v8 = operator new(0x28uLL);
  v20[1] = (char *)v8 + 40;
  v20[2] = (char *)v8 + 40;
  v9 = *((_OWORD *)a2 + 1);
  *v8 = *(_OWORD *)a2;
  v8[1] = v9;
  *((_QWORD *)v8 + 4) = *((_QWORD *)a2 + 4);
  v20[0] = v8;
  HGRenderer::RenderNodes(this, (const char *)v20, a3, v10, v11, &__p);
  v12 = (char *)__p;
  if (__p == v19)
  {
    *a4 = 0;
    if (!v12)
      goto LABEL_13;
  }
  else
  {
    v13 = *(_QWORD *)__p;
    *a4 = *(_QWORD *)__p;
    if (v13)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 16))(v13);
      v12 = (char *)__p;
      if (!__p)
        goto LABEL_13;
    }
  }
  v14 = v19;
  v15 = v12;
  if (v19 != v12)
  {
    do
    {
      v17 = *((_QWORD *)v14 - 1);
      v14 -= 8;
      v16 = v17;
      if (v17)
        (*(void (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
    }
    while (v14 != v12);
    v15 = __p;
  }
  v19 = v12;
  operator delete(v15);
LABEL_13:
  operator delete(v8);
}

void sub_1B2A7FFC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;

  std::vector<HGRef<HGBitmap>>::~vector[abi:ne180100](&a9);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B2A7FFE4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

const char *HGRenderer::RenderBitmap(HGRenderer *this, HGBitmap *a2, HGNode *a3)
{
  const char *result;
  uint64_t v4;
  _QWORD v5[2];
  __int128 v6;
  int v7;
  int v8;

  if ((*((_BYTE *)a2 + 12) & 0x30) != 0)
    return HGLogger::warning((HGLogger *)"  ERROR : bitmap is on GPU (with CPU renderer).", (const char *)a2, (char *)a3);
  v5[0] = a3;
  v5[1] = a2;
  v6 = *(_OWORD *)((char *)a2 + 20);
  v7 = *((_DWORD *)a2 + 4);
  v8 = 0;
  HGRenderer::RenderNode(this, (const HGRendererOutput *)v5, (char *)1, &v4);
  result = (const char *)v4;
  if (v4)
    return (const char *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  return result;
}

uint64_t HGRenderer::RenderBitmap(HGRenderer *this, HGBitmap *a2, HGNode *a3)
{
  HGLogger::warning((HGLogger *)"  WARNING : calling obsolete HGRenderer function:\n  void HGRenderer::RenderBitmap(HGBitmap *bmp, HGNode *node, BOOL fullROI)\n  instead, use:\n  void HGRenderer::RenderBitmap(HGBitmap *bmp, HGNode *node)\n  (fullROI is always 'on' when providing a destination bitmap)\n", (const char *)a2, (char *)a3);
  return (*(uint64_t (**)(HGRenderer *, HGBitmap *, HGNode *))(*(_QWORD *)this + 64))(this, a2, a3);
}

void HGRenderer::RenderNodes(HGRenderer *a1, int a2, uint64_t a3, const char *a4, char *a5, uint64_t a6, unsigned int a7)
{
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  __int128 v22;
  __int128 v23;
  char *v24;
  unint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  char *v28;
  char *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  const char *v37;
  char *v38;
  uint64_t v39;
  void *__p;
  char *v41;
  void *v42;
  char *v43;
  char *v44;

  v42 = 0;
  v43 = 0;
  v44 = 0;
  v7 = a2;
  if (a2 >= 1)
  {
    v8 = 0;
    v9 = 0;
    v38 = a5;
    v39 = a6;
    v37 = a4;
    do
    {
      while (1)
      {
        v10 = *(_QWORD *)&a4[8 * v9];
        v11 = &a5[16 * v9];
        v13 = *(_QWORD *)v11;
        v12 = *((_QWORD *)v11 + 1);
        v14 = *(_DWORD *)(a6 + 4 * v9);
        if (v8 >= v44)
          break;
        *(_QWORD *)v8 = v10;
        *((_QWORD *)v8 + 1) = 0;
        *((_QWORD *)v8 + 2) = v13;
        *((_QWORD *)v8 + 3) = v12;
        *((_DWORD *)v8 + 8) = v14;
        *((_DWORD *)v8 + 9) = 0;
        v43 = v8 + 40;
        ++v9;
        v8 += 40;
        if (v9 == v7)
          goto LABEL_21;
      }
      v15 = (char *)v42;
      v16 = 0xCCCCCCCCCCCCCCCDLL * ((v8 - (_BYTE *)v42) >> 3);
      v17 = v16 + 1;
      if (v16 + 1 > 0x666666666666666)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      if (0x999999999999999ALL * ((v44 - (_BYTE *)v42) >> 3) > v17)
        v17 = 0x999999999999999ALL * ((v44 - (_BYTE *)v42) >> 3);
      if (0xCCCCCCCCCCCCCCCDLL * ((v44 - (_BYTE *)v42) >> 3) >= 0x333333333333333)
        v18 = 0x666666666666666;
      else
        v18 = v17;
      if (v18)
      {
        if (v18 > 0x666666666666666)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v19 = (char *)operator new(40 * v18);
      }
      else
      {
        v19 = 0;
      }
      v20 = &v19[8 * ((v8 - (_BYTE *)v42) >> 3)];
      *(_QWORD *)v20 = v10;
      *((_QWORD *)v20 + 1) = 0;
      *((_QWORD *)v20 + 2) = v13;
      *((_QWORD *)v20 + 3) = v12;
      *((_DWORD *)v20 + 8) = v14;
      *((_DWORD *)v20 + 9) = 0;
      v21 = &v19[40 * v16];
      if (v8 != v15)
      {
        do
        {
          v22 = *(_OWORD *)(v8 - 40);
          v23 = *(_OWORD *)(v8 - 24);
          *((_QWORD *)v21 - 1) = *((_QWORD *)v8 - 1);
          *(_OWORD *)(v21 - 24) = v23;
          *(_OWORD *)(v21 - 40) = v22;
          v21 -= 40;
          v8 -= 40;
        }
        while (v8 != v15);
        v8 = v15;
      }
      v24 = v20 + 40;
      v42 = v21;
      v44 = &v19[40 * v18];
      if (v8)
        operator delete(v8);
      a5 = v38;
      a6 = v39;
      a4 = v37;
      v43 = v24;
      ++v9;
      v8 = v24;
    }
    while (v9 != v7);
  }
LABEL_21:
  HGRenderer::RenderNodes(a1, (const char *)&v42, (char *)a7, a4, a5, &__p);
  if (a2 >= 1)
  {
    v25 = 0;
    do
    {
      while (1)
      {
        v26 = __p;
        if (v25 < (v41 - (_BYTE *)__p) >> 3)
        {
          v27 = *((_QWORD *)__p + v25);
          if (v27)
            break;
        }
        *(_QWORD *)(a3 + 8 * v25++) = 0;
        if (v7 == v25)
          goto LABEL_27;
      }
      (*(void (**)(uint64_t))(*(_QWORD *)v27 + 16))(v27);
      *(_QWORD *)(a3 + 8 * v25) = v26[v25];
      ++v25;
    }
    while (v7 != v25);
  }
LABEL_27:
  v28 = (char *)__p;
  if (__p)
  {
    v29 = v41;
    v30 = __p;
    if (v41 != __p)
    {
      do
      {
        v32 = *((_QWORD *)v29 - 1);
        v29 -= 8;
        v31 = v32;
        if (v32)
          (*(void (**)(uint64_t))(*(_QWORD *)v31 + 24))(v31);
      }
      while (v29 != v28);
      v30 = __p;
    }
    v41 = v28;
    operator delete(v30);
  }
  if (v42)
    operator delete(v42);
}

void sub_1B2A80360(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGRenderer::RenderNodes(HGRenderer *a1@<X0>, const char *a2@<X1>, char *a3@<X2>, const char *a4@<X3>, char *a5@<X4>, void **a6@<X8>)
{
  void **v6;
  char v7;
  const char *v8;
  unsigned __int8 *v10;
  unsigned __int8 v11;
  HGNode **v12;
  HGNode **v13;
  HGNode **v14;
  HGNode **v15;
  HGNode **v16;
  HGNode **v17;
  int v18;
  HGNode *v19;
  unsigned int *v20;
  unsigned int *v21;
  uint64_t v22;
  HGNode **v23;
  HGNode **v24;
  const char *v25;
  HGNode *v26;
  HGNode *v27;
  HGNode *v28;
  HGNode *v29;
  unsigned __int8 v30;
  const char *v31;
  const char *v32;
  unsigned __int8 *v33;
  int v34;
  void **v35;
  const char *v36;
  const char *v37;
  char *v38;
  void **p_p;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t **v49;
  uint64_t *v50;
  uint64_t *v51;
  uint64_t **v52;
  uint64_t *v53;
  uint64_t *v54;
  HGNode **v55;
  HGNode **v56;
  HGNode *v57;
  unsigned int *v58;
  unsigned int *v59;
  uint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t *v63;
  _QWORD *v64;
  uint64_t **v65;
  uint64_t v66;
  uint64_t **v67;
  uint64_t ***v68;
  _QWORD *v69;
  uint64_t *v70;
  uint64_t *v71;
  void *v72;
  uint64_t v73;
  uint64_t v74;
  HGDotGraph *v75;
  HGNode **v76;
  HGNode **v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t **v80;
  uint64_t **v81;
  uint64_t *v82;
  unint64_t v83;
  uint64_t *v84;
  uint64_t *v85;
  uint64_t *v86;
  uint64_t **v87;
  uint64_t **v88;
  BOOL v89;
  uint64_t *v90;
  uint64_t *v91;
  uint64_t **v92;
  uint64_t **v93;
  unint64_t v94;
  uint64_t *v95;
  int v96;
  uint64_t i;
  uint64_t v98;
  uint64_t v99;
  uint64_t *v100;
  unint64_t v101;
  uint64_t **v102;
  uint64_t *v103;
  uint64_t **v104;
  unint64_t v105;
  uint64_t **v106;
  uint64_t **v107;
  uint64_t **v108;
  uint64_t *v109;
  unint64_t v110;
  uint64_t *v111;
  HGNode **v112;
  void **v113;
  uint64_t **v114;
  uint64_t *v115;
  uint64_t v116;
  void *__p;
  uint64_t *v118;
  unint64_t v119;
  _BYTE v120[16];
  HGRect v121;

  v6 = a6;
  *a6 = 0;
  a6[1] = 0;
  a6[2] = 0;
  if (*((_BYTE *)a1 + 809))
  {
    v7 = (char)a3;
    v8 = a2;
    v10 = HGLogger::_enabled;
    v11 = atomic_load(HGLogger::_enabled);
    if ((v11 & 1) != 0)
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"\n\n", a4, a5);
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v120, "gpu", 1, "----- HGRenderer::Render() -----");
    v12 = *(HGNode ***)v8;
    v13 = (HGNode **)*((_QWORD *)v8 + 1);
    if (*(HGNode ***)v8 != v13)
    {
      do
      {
        (*(void (**)(HGNode *, HGRenderer *, HGNode *, HGNode *, _QWORD))(*(_QWORD *)*v12 + 376))(*v12, a1, v12[2], v12[3], *((unsigned int *)v12 + 8));
        v12 += 5;
      }
      while (v12 != v13);
    }
    *((_BYTE *)a1 + 808) = v7;
    (*(void (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 256))(a1, 1);
    if (*((_DWORD *)a1 + 160))
    {
      pthread_rwlock_rdlock((pthread_rwlock_t *)((char *)a1 + 288));
      pthread_rwlock_unlock((pthread_rwlock_t *)((char *)a1 + 288));
    }
    if (!*((_DWORD *)a1 + 159))
    {
      v14 = *(HGNode ***)v8;
      v15 = (HGNode **)*((_QWORD *)v8 + 1);
      if (*(HGNode ***)v8 != v15)
      {
        do
        {
          HGRenderer::GetOutput(a1, *v14);
          v14 += 5;
        }
        while (v14 != v15);
      }
      v16 = *(HGNode ***)v8;
      v17 = (HGNode **)*((_QWORD *)v8 + 1);
      if (*(HGNode ***)v8 != v17)
      {
        v18 = 0;
        do
        {
          v19 = (HGNode *)*((_QWORD *)*v16 + 18);
          if (v19)
            HGRenderer::RenderNodeBgn(a1, v19, v18);
          ++v18;
          v16 += 5;
        }
        while (v16 != v17);
        v20 = *(unsigned int **)v8;
        v21 = (unsigned int *)*((_QWORD *)v8 + 1);
        if (*(unsigned int **)v8 != v21)
        {
          do
          {
            v22 = *(_QWORD *)(*(_QWORD *)v20 + 144);
            if (v22)
              (*(void (**)(HGRenderer *, uint64_t, _QWORD))(*(_QWORD *)a1 + 272))(a1, v22, v20[9]);
            v20 += 10;
          }
          while (v20 != v21);
          v24 = *(HGNode ***)v8;
          v23 = (HGNode **)*((_QWORD *)v8 + 1);
          if (*(HGNode ***)v8 != v23)
          {
            v25 = "HGRenderer::SetROI()";
            v112 = (HGNode **)*((_QWORD *)v8 + 1);
            v113 = v6;
            do
            {
              v26 = *v24;
              v27 = (HGNode *)*((_QWORD *)*v24 + 18);
              if (v27)
              {
                v28 = v24[2];
                v29 = v24[3];
                if (*((int *)a1 + 161) < 1)
                {
                  HGRenderer::SetROI(a1, v27, *((HGRect *)v24 + 1), 0, 0);
                }
                else
                {
                  v30 = atomic_load(v10);
                  if ((v30 & 1) != 0)
                  {
                    v31 = v25;
                    v32 = v8;
                    v33 = v10;
                    (*(void (**)(void **__return_ptr, HGRenderer *))(*(_QWORD *)a1 + 40))(&__p, a1);
                    v34 = SHIBYTE(v119);
                    v35 = (void **)__p;
                    v36 = HGFormat_repr(*((_DWORD *)a1 + 144));
                    p_p = &__p;
                    if (v34 < 0)
                      p_p = v35;
                    HGLogger::log((HGLogger *)"graph", (const char *)1, (HGLogger *)"%s.  Intermediate format: %s\n", v37, v38, p_p, v36);
                    v10 = v33;
                    v25 = v31;
                    if (SHIBYTE(v119) < 0)
                      operator delete(__p);
                    v8 = v32;
                    v23 = v112;
                    v6 = v113;
                  }
                  HGTraceGuard::HGTraceGuard((HGTraceGuard *)&__p, "graph", 1, v25);
                  *(_QWORD *)&v121.var0 = v28;
                  *(_QWORD *)&v121.var2 = v29;
                  HGRenderer::SetROI(a1, *((HGNode **)v26 + 18), v121, 0, 0);
                  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&__p);
                }
              }
              v24 += 5;
            }
            while (v24 != v23);
          }
        }
      }
      if (*((int *)a1 + 164) > 2)
        HGRenderer::DumpPreRenderDotTree(a1, **(HGNode ***)v8, "getoutput");
      __p = 0;
      v118 = 0;
      v119 = 0;
      v40 = *((_QWORD *)v8 + 1);
      if (*(_QWORD *)v8 != v40)
      {
        v41 = *(_QWORD *)v8 + 24;
        while (1)
        {
          v42 = v41 - 24;
          v43 = *(unsigned int *)(v41 + 8);
          v44 = *(_QWORD *)(*(_QWORD *)(v41 - 24) + 144);
          if (v44)
            break;
          v49 = (uint64_t **)HGObject::operator new(0x80uLL);
          HGBitmap::HGBitmap(v49, 0, 0, v43);
          v114 = v49;
          v50 = v118;
          if ((unint64_t)v118 < v119)
            goto LABEL_39;
          v51 = std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>(&__p, &v114);
          v52 = v114;
          v118 = v51;
          if (v114)
            goto LABEL_47;
LABEL_40:
          v41 += 40;
          if (v42 + 40 == v40)
            goto LABEL_60;
        }
        v45 = *(_QWORD *)(v41 - 16);
        v46 = (*(uint64_t (**)(HGRenderer *, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a1 + 160))(a1, v44, *(_QWORD *)(v41 - 8), *(_QWORD *)v41, *(unsigned int *)(v41 + 8), v45);
        v47 = v46;
        if (v45)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v45 + 16))(v45);
          v114 = (uint64_t **)v45;
          v48 = v118;
          if ((unint64_t)v118 >= v119)
          {
            v118 = std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>(&__p, &v114);
            if (v114)
              ((void (*)(uint64_t **))(*v114)[3])(v114);
          }
          else
          {
            *v118 = v45;
            v118 = v48 + 1;
          }
          if (!v47)
            goto LABEL_40;
          goto LABEL_54;
        }
        if (v46)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v46 + 16))(v46);
          v114 = (uint64_t **)v47;
          v53 = v118;
          if ((unint64_t)v118 >= v119)
          {
            v118 = std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>(&__p, &v114);
            if (v114)
              ((void (*)(uint64_t **))(*v114)[3])(v114);
          }
          else
          {
            *v118 = v47;
            v118 = v53 + 1;
          }
LABEL_54:
          (*(void (**)(uint64_t))(*(_QWORD *)v47 + 24))(v47);
          goto LABEL_40;
        }
        v49 = (uint64_t **)HGObject::operator new(0x80uLL);
        HGBitmap::HGBitmap(v49, 0, 0, v43);
        v114 = v49;
        v50 = v118;
        if ((unint64_t)v118 >= v119)
        {
          v54 = std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>(&__p, &v114);
          v52 = v114;
          v118 = v54;
          if (!v114)
            goto LABEL_40;
LABEL_47:
          ((void (*)(uint64_t **))(*v114)[3])(v52);
          goto LABEL_40;
        }
LABEL_39:
        *v50 = (uint64_t)v49;
        v118 = v50 + 1;
        goto LABEL_40;
      }
LABEL_60:
      v55 = *(HGNode ***)v8;
      v56 = (HGNode **)*((_QWORD *)v8 + 1);
      if (*(HGNode ***)v8 != v56)
      {
        do
        {
          v57 = (HGNode *)*((_QWORD *)*v55 + 18);
          if (v57)
            HGRenderer::RenderNodeEnd(a1, v57);
          v55 += 5;
        }
        while (v55 != v56);
        v58 = *(unsigned int **)v8;
        v59 = (unsigned int *)*((_QWORD *)v8 + 1);
        if (*(unsigned int **)v8 != v59)
        {
          v60 = 0;
          while (*(_QWORD *)(*(_QWORD *)v58 + 144))
          {
            v62 = (*(uint64_t (**)(HGRenderer *, _QWORD, _QWORD))(*(_QWORD *)a1 + 280))(a1, *(_QWORD *)((char *)__p + v60), v58[9]);
            v114 = (uint64_t **)v62;
            v63 = (uint64_t *)v6[1];
            if (v63 < v6[2])
            {
              *v63 = v62;
              v61 = v63 + 1;
LABEL_68:
              v6[1] = v61;
              goto LABEL_69;
            }
            v64 = std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>(v6, &v114);
            v65 = v114;
            v6[1] = v64;
            if (v65)
              goto LABEL_73;
LABEL_69:
            v60 += 8;
            v58 += 10;
            if (v58 == v59)
              goto LABEL_78;
          }
          v66 = v58[8];
          v67 = (uint64_t **)HGObject::operator new(0x80uLL);
          HGBitmap::HGBitmap(v67, 0, 0, v66);
          v114 = v67;
          v68 = (uint64_t ***)v6[1];
          if (v68 >= v6[2])
          {
            v69 = std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>(v6, &v114);
            v65 = v114;
            v6[1] = v69;
            if (!v65)
              goto LABEL_69;
LABEL_73:
            ((void (*)(uint64_t **))(*v65)[3])(v65);
            goto LABEL_69;
          }
          *v68 = v67;
          v61 = v68 + 1;
          goto LABEL_68;
        }
      }
LABEL_78:
      v70 = (uint64_t *)__p;
      if (__p)
      {
        v71 = v118;
        v72 = __p;
        if (v118 != __p)
        {
          do
          {
            v74 = *--v71;
            v73 = v74;
            if (v74)
              (*(void (**)(uint64_t))(*(_QWORD *)v73 + 24))(v73);
          }
          while (v71 != v70);
          v72 = __p;
        }
        v118 = v70;
        operator delete(v72);
      }
    }
    (*(void (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 264))(a1, 1);
    v75 = (HGRenderer *)((char *)a1 + 840);
    if (HGDotGraph::on((HGRenderer *)((char *)a1 + 840)))
    {
      if (*((_DWORD *)a1 + 160))
      {
        pthread_rwlock_rdlock((pthread_rwlock_t *)((char *)a1 + 288));
        pthread_rwlock_unlock((pthread_rwlock_t *)((char *)a1 + 288));
      }
      if (!*((_DWORD *)a1 + 159))
      {
        v118 = 0;
        v119 = 0;
        v116 = 0;
        __p = &v118;
        v114 = &v115;
        v115 = 0;
        v77 = *(HGNode ***)v8;
        v76 = (HGNode **)*((_QWORD *)v8 + 1);
        if (v77 != v76)
        {
          v78 = 0;
          do
          {
            v79 = *((_QWORD *)*v77 + 18);
            v80 = &v115;
            v81 = &v115;
            if (v115)
            {
              v82 = v115;
              while (1)
              {
                while (1)
                {
                  v81 = (uint64_t **)v82;
                  v83 = v82[4];
                  if (v79 >= v83)
                    break;
                  v82 = *v81;
                  v80 = v81;
                  if (!*v81)
                    goto LABEL_101;
                }
                if (v83 >= v79)
                  break;
                v82 = v81[1];
                if (!v82)
                {
                  v80 = v81 + 1;
                  goto LABEL_101;
                }
              }
            }
            else
            {
LABEL_101:
              v84 = (uint64_t *)operator new(0x28uLL);
              v84[4] = v79;
              *v84 = 0;
              v84[1] = 0;
              v84[2] = (uint64_t)v81;
              *v80 = v84;
              if (*v114)
              {
                v114 = (uint64_t **)*v114;
                v84 = *v80;
              }
              std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v115, v84);
              v78 = ++v116;
            }
            v77 += 5;
          }
          while (v77 != v76);
          if (v78)
          {
            do
            {
              v85 = (uint64_t *)v114;
              v86 = v114[1];
              v87 = v114;
              if (v86)
              {
                do
                {
                  v88 = (uint64_t **)v86;
                  v86 = (uint64_t *)*v86;
                }
                while (v86);
              }
              else
              {
                do
                {
                  v88 = (uint64_t **)v87[2];
                  v89 = *v88 == (uint64_t *)v87;
                  v87 = v88;
                }
                while (!v89);
              }
              v90 = v114[4];
              v114 = v88;
              v116 = v78 - 1;
              std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v115, v85);
              operator delete(v85);
              v91 = v118;
              v92 = &v118;
              v93 = &v118;
              if (v118)
              {
                while (1)
                {
                  while (1)
                  {
                    v93 = (uint64_t **)v91;
                    v94 = v91[4];
                    if ((unint64_t)v90 >= v94)
                      break;
                    v91 = *v93;
                    v92 = v93;
                    if (!*v93)
                      goto LABEL_119;
                  }
                  if (v94 >= (unint64_t)v90)
                    break;
                  v91 = v93[1];
                  if (!v91)
                  {
                    v92 = v93 + 1;
                    goto LABEL_119;
                  }
                }
              }
              else
              {
LABEL_119:
                v95 = (uint64_t *)operator new(0x28uLL);
                v95[4] = (uint64_t)v90;
                *v95 = 0;
                v95[1] = 0;
                v95[2] = (uint64_t)v93;
                *v92 = v95;
                if (*(_QWORD *)__p)
                {
                  __p = *(void **)__p;
                  v95 = *v92;
                }
                std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v118, v95);
                ++v119;
              }
              HGRenderer::DotNode(a1, (HGNode *)v90);
              v96 = *((_DWORD *)v90 + 22);
              if (v96 >= 1)
              {
                for (i = 0; i < v96; ++i)
                {
                  v98 = *(_QWORD *)(v90[10] + 8 * i);
                  if (v98)
                  {
                    v99 = *(_QWORD *)(v98 + 16);
                    if (v99)
                    {
                      v100 = v118;
                      v101 = *(_QWORD *)(v99 + 144);
                      if (!v118)
                        goto LABEL_137;
                      v102 = &v118;
                      do
                      {
                        v103 = v100;
                        v104 = v102;
                        v105 = v100[4];
                        v106 = (uint64_t **)(v100 + 1);
                        if (v105 >= v101)
                        {
                          v106 = (uint64_t **)v103;
                          v102 = (uint64_t **)v103;
                        }
                        v100 = *v106;
                      }
                      while (v100);
                      if (v102 == &v118)
                        goto LABEL_137;
                      if (v105 < v101)
                        v103 = (uint64_t *)v104;
                      if (v101 < v103[4])
                      {
LABEL_137:
                        v107 = &v115;
                        v108 = &v115;
                        if (v115)
                        {
                          v109 = v115;
                          while (1)
                          {
                            while (1)
                            {
                              v108 = (uint64_t **)v109;
                              v110 = v109[4];
                              if (v101 >= v110)
                                break;
                              v109 = *v108;
                              v107 = v108;
                              if (!*v108)
                                goto LABEL_144;
                            }
                            if (v110 >= v101)
                              break;
                            v109 = v108[1];
                            if (!v109)
                            {
                              v107 = v108 + 1;
                              goto LABEL_144;
                            }
                          }
                        }
                        else
                        {
LABEL_144:
                          v111 = (uint64_t *)operator new(0x28uLL);
                          v111[4] = v101;
                          *v111 = 0;
                          v111[1] = 0;
                          v111[2] = (uint64_t)v108;
                          *v107 = v111;
                          if (*v114)
                          {
                            v114 = (uint64_t **)*v114;
                            v111 = *v107;
                          }
                          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v115, v111);
                          ++v116;
                          v96 = *((_DWORD *)v90 + 22);
                        }
                      }
                    }
                  }
                }
              }
              v78 = v116;
            }
            while (v116);
          }
        }
        std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v114, v115);
        std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&__p, v118);
        v75 = (HGRenderer *)((char *)a1 + 840);
      }
    }
    HGDotGraph::end(v75);
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v120);
  }
  else
  {
    HGLogger::warning((HGLogger *)"Invalid Renderer", a2, a3);
  }
}

void sub_1B2A80D64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  void **v22;

  if (a13)
    (*(void (**)(uint64_t))(*(_QWORD *)a13 + 24))(a13);
  std::vector<HGRef<HGBitmap>>::~vector[abi:ne180100](&__p);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a22);
  std::vector<HGRef<HGBitmap>>::~vector[abi:ne180100](v22);
  _Unwind_Resume(a1);
}

void HGRenderer::RenderBitmaps(HGRenderer *this, int a2, HGBitmap **a3, HGNode **a4, char *a5)
{
  HGNode **v7;
  uint64_t v8;
  uint64_t v9;
  HGNode *v10;
  HGBitmap *v11;
  __int128 *v12;
  int v13;
  char *v14;
  HGNode **v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  __int128 v23;
  __int128 v24;
  char *v25;
  char *v26;
  char *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v32;
  void *__p;
  char *v34;
  __int128 v35;
  void *v36;
  char *v37;
  char *v38;

  v36 = 0;
  v37 = 0;
  v38 = 0;
  if (a2 >= 1)
  {
    v7 = 0;
    v8 = 0;
    v9 = a2;
    v32 = a2;
    while (1)
    {
      v10 = a4[v8];
      v11 = a3[v8];
      v12 = (__int128 *)((char *)v11 + 20);
      if (!v11)
        v12 = &HGRectNull;
      v35 = *v12;
      if (v11)
      {
        v13 = *((_DWORD *)v11 + 4);
        v14 = v38;
        if (v7 >= (HGNode **)v38)
          goto LABEL_10;
LABEL_3:
        *v7 = v10;
        v7[1] = (HGNode *)v11;
        *((_OWORD *)v7 + 1) = v35;
        *((_DWORD *)v7 + 8) = v13;
        *((_DWORD *)v7 + 9) = 0;
        v37 = (char *)(v7 + 5);
        ++v8;
        v7 += 5;
        if (v8 == v9)
          break;
      }
      else
      {
        v13 = 0;
        v14 = v38;
        if (v7 < (HGNode **)v38)
          goto LABEL_3;
LABEL_10:
        v15 = (HGNode **)v36;
        v16 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v7 - (_BYTE *)v36) >> 3);
        v17 = v16 + 1;
        if (v16 + 1 > 0x666666666666666)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v18 = 0xCCCCCCCCCCCCCCCDLL * ((v14 - (_BYTE *)v36) >> 3);
        if (2 * v18 > v17)
          v17 = 2 * v18;
        if (v18 >= 0x333333333333333)
          v19 = 0x666666666666666;
        else
          v19 = v17;
        if (v19)
        {
          if (v19 > 0x666666666666666)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v20 = (char *)operator new(40 * v19);
        }
        else
        {
          v20 = 0;
        }
        v21 = &v20[8 * (((char *)v7 - (_BYTE *)v36) >> 3)];
        *(_QWORD *)v21 = v10;
        *((_QWORD *)v21 + 1) = v11;
        *((_OWORD *)v21 + 1) = v35;
        *((_DWORD *)v21 + 8) = v13;
        *((_DWORD *)v21 + 9) = 0;
        v22 = &v20[40 * v16];
        if (v7 != v15)
        {
          do
          {
            v23 = *(_OWORD *)(v7 - 5);
            v24 = *(_OWORD *)(v7 - 3);
            *((_QWORD *)v22 - 1) = *(v7 - 1);
            *(_OWORD *)(v22 - 24) = v24;
            *(_OWORD *)(v22 - 40) = v23;
            v22 -= 40;
            v7 -= 5;
          }
          while (v7 != v15);
          v7 = v15;
        }
        v25 = v21 + 40;
        v36 = v22;
        v38 = &v20[40 * v19];
        if (v7)
          operator delete(v7);
        v9 = v32;
        v37 = v25;
        ++v8;
        v7 = (HGNode **)v25;
        if (v8 == v32)
          break;
      }
    }
  }
  HGRenderer::RenderNodes(this, (const char *)&v36, (char *)1, (const char *)a4, a5, &__p);
  v26 = (char *)__p;
  if (__p)
  {
    v27 = v34;
    v28 = __p;
    if (v34 != __p)
    {
      do
      {
        v30 = *((_QWORD *)v27 - 1);
        v27 -= 8;
        v29 = v30;
        if (v30)
          (*(void (**)(uint64_t))(*(_QWORD *)v29 + 24))(v29);
      }
      while (v27 != v26);
      v28 = __p;
    }
    v34 = v26;
    operator delete(v28);
  }
  if (v36)
    operator delete(v36);
}

void sub_1B2A81238(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t HGRenderer::GetBitmap(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v3;
  HGBitmap *v8;
  HGBitmapLoader *v9;

  if ((*(_BYTE *)(a2 + 12) & 0x30) != 0)
  {
    HGLogger::warning((HGLogger *)"  ERROR : bitmap is on GPU (with CPU renderer).", (const char *)a2, a3);
    return 0;
  }
  if (*(_DWORD *)(a2 + 16) != (_DWORD)a3)
  {
    v8 = (HGBitmap *)HGObject::operator new(0x80uLL);
    HGBitmap::HGBitmap(v8, *(HGRect *)(a2 + 20), (HGBitmap *)a2);
    v9 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
    HGBitmapLoader::HGBitmapLoader(v9, v8);
    v3 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, char *, HGBitmapLoader *, uint64_t))(*(_QWORD *)a1 + 56))(a1, *(_QWORD *)(a2 + 20), *(_QWORD *)(a2 + 28), a3, v9, 1);
    if (v9)
      (*(void (**)(HGBitmapLoader *))(*(_QWORD *)v9 + 24))(v9);
    if (v8)
      (*(void (**)(HGBitmap *))(*(_QWORD *)v8 + 24))(v8);
    return v3;
  }
  (*(void (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  return a2;
}

void sub_1B2A81374(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t HGRenderer::GetTexture(HGRenderer *this, HGBitmap *a2, char *a3)
{
  HGLogger::warning((HGLogger *)"  ERROR : can't call GetTexture with CPU renderer.", (const char *)a2, a3);
  return 0;
}

HGNode *HGRenderer::GetOutput(HGRenderer *this, HGNode *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t i;
  uint64_t v9;
  HGNode *v10;
  HGNode *GuardedOutput;
  HGNode *Output;

  if (!a2)
    return 0;
  if ((*((_BYTE *)a2 + 136) & 2) != 0)
    return (HGNode *)*((_QWORD *)a2 + 18);
  if (*((int *)a2 + 22) >= 1)
  {
    v4 = **((_QWORD **)a2 + 10);
    if (v4)
    {
      if (*(_QWORD *)(v4 + 16))
      {
        if ((*(unsigned int (**)(HGNode *))(*(_QWORD *)a2 + 360))(a2))
        {
          v5 = *(_QWORD *)(**((_QWORD **)a2 + 10) + 16);
          if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 360))(v5))
          {
            if (HGRenderer::IsMergeable(this, a2, 0, 0))
            {
              v6 = *(_QWORD *)(**((_QWORD **)a2 + 10) + 16);
              (*(void (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
              (*(void (**)(HGNode *, uint64_t))(*(_QWORD *)a2 + 368))(a2, v6);
              (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
            }
          }
        }
      }
    }
    v7 = *((_DWORD *)a2 + 22);
    if (v7 >= 1)
    {
      for (i = 0; i < v7; ++i)
      {
        v9 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * i);
        if (v9)
        {
          v10 = *(HGNode **)(v9 + 16);
          if (v10)
          {
            HGRenderer::GetOutput(this, v10);
            v7 = *((_DWORD *)a2 + 22);
          }
        }
      }
    }
  }
  GuardedOutput = HGNode::GetGuardedOutput(a2, this);
  Output = a2;
  if (GuardedOutput)
  {
    Output = a2;
    if (GuardedOutput != a2)
      Output = (HGNode *)HGRenderer::GetOutput(this, GuardedOutput);
  }
  *((_QWORD *)a2 + 18) = Output;
  *((_QWORD *)a2 + 23) = this;
  *((_DWORD *)a2 + 34) |= 2u;
  ++*((_DWORD *)this + 173);
  (*(void (**)(HGRenderer *, HGNode *))(*(_QWORD *)this + 176))(this, Output);
  return Output;
}

double HGRenderer::GetShaderCompileTime(HGRenderer *this)
{
  return 0.0;
}

unint64_t HGRenderer::GetStats(uint64_t a1, int a2)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t *v115;
  uint64_t v116;
  uint64_t v117;

  switch(a2)
  {
    case 0:
      v3 = *(int *)(a1 + 596);
      if ((int)v3 <= 0)
        return 0 / v3;
      v4 = 0;
      v5 = 0;
      do
      {
        v5 += HGExecutionUnit::StackSize(*(HGExecutionUnit **)(*(_QWORD *)(a1 + 248) + 8 * v4++));
        v6 = *(int *)(a1 + 596);
      }
      while (v4 < (uint64_t)v6);
      return v5 / v6;
    case 1:
      v8 = *(unsigned int *)(a1 + 596);
      if ((int)v8 < 1)
        return 0;
      v9 = *(_QWORD *)(a1 + 248);
      if ((_DWORD)v8 == 1)
      {
        v10 = 0;
        result = 0;
LABEL_48:
        v45 = (uint64_t *)(v9 + 8 * v10);
        v46 = v8 - v10;
        do
        {
          v47 = *v45++;
          result += **(_QWORD **)(v47 + 416);
          --v46;
        }
        while (v46);
        return result;
      }
      v41 = 0;
      v42 = 0;
      v10 = v8 & 0xFFFFFFFE;
      v43 = v9 + 8;
      v44 = v10;
      do
      {
        v41 += **(_QWORD **)(*(_QWORD *)(v43 - 8) + 416);
        v42 += **(_QWORD **)(*(_QWORD *)v43 + 416);
        v43 += 16;
        v44 -= 2;
      }
      while (v44);
      result = v42 + v41;
      if (v10 != v8)
        goto LABEL_48;
      return result;
    case 2:
      v11 = *(unsigned int *)(a1 + 596);
      if ((int)v11 < 1)
        return 0;
      v12 = *(_QWORD *)(a1 + 248);
      if ((_DWORD)v11 == 1)
      {
        v13 = 0;
        result = 0;
LABEL_54:
        v52 = (uint64_t *)(v12 + 8 * v13);
        v53 = v11 - v13;
        do
        {
          v54 = *v52++;
          result += *(_QWORD *)(*(_QWORD *)(v54 + 416) + 8);
          --v53;
        }
        while (v53);
        return result;
      }
      v48 = 0;
      v49 = 0;
      v13 = v11 & 0xFFFFFFFE;
      v50 = v12 + 8;
      v51 = v13;
      do
      {
        v48 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v50 - 8) + 416) + 8);
        v49 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v50 + 416) + 8);
        v50 += 16;
        v51 -= 2;
      }
      while (v51);
      result = v49 + v48;
      if (v13 != v11)
        goto LABEL_54;
      return result;
    case 3:
      v14 = *(unsigned int *)(a1 + 596);
      if ((int)v14 < 1)
        return 0;
      v15 = *(_QWORD *)(a1 + 248);
      if ((_DWORD)v14 == 1)
      {
        v16 = 0;
        result = 0;
LABEL_60:
        v59 = (uint64_t *)(v15 + 8 * v16);
        v60 = v14 - v16;
        do
        {
          v61 = *v59++;
          result += *(_QWORD *)(*(_QWORD *)(v61 + 416) + 16);
          --v60;
        }
        while (v60);
        return result;
      }
      v55 = 0;
      v56 = 0;
      v16 = v14 & 0xFFFFFFFE;
      v57 = v15 + 8;
      v58 = v16;
      do
      {
        v55 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v57 - 8) + 416) + 16);
        v56 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v57 + 416) + 16);
        v57 += 16;
        v58 -= 2;
      }
      while (v58);
      result = v56 + v55;
      if (v16 != v14)
        goto LABEL_60;
      return result;
    case 4:
      v17 = *(unsigned int *)(a1 + 596);
      if ((int)v17 < 1)
        return 0;
      v18 = *(_QWORD *)(a1 + 248);
      if ((_DWORD)v17 == 1)
      {
        v19 = 0;
        result = 0;
LABEL_66:
        v66 = (uint64_t *)(v18 + 8 * v19);
        v67 = v17 - v19;
        do
        {
          v68 = *v66++;
          result += *(_QWORD *)(*(_QWORD *)(v68 + 416) + 24);
          --v67;
        }
        while (v67);
        return result;
      }
      v62 = 0;
      v63 = 0;
      v19 = v17 & 0xFFFFFFFE;
      v64 = v18 + 8;
      v65 = v19;
      do
      {
        v62 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v64 - 8) + 416) + 24);
        v63 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v64 + 416) + 24);
        v64 += 16;
        v65 -= 2;
      }
      while (v65);
      result = v63 + v62;
      if (v19 != v17)
        goto LABEL_66;
      return result;
    case 5:
      v20 = *(unsigned int *)(a1 + 596);
      if ((int)v20 < 1)
        return 0;
      v21 = *(_QWORD *)(a1 + 248);
      if ((_DWORD)v20 == 1)
      {
        v22 = 0;
        result = 0;
LABEL_72:
        v73 = (uint64_t *)(v21 + 8 * v22);
        v74 = v20 - v22;
        do
        {
          v75 = *v73++;
          result += *(_QWORD *)(*(_QWORD *)(v75 + 416) + 32);
          --v74;
        }
        while (v74);
        return result;
      }
      v69 = 0;
      v70 = 0;
      v22 = v20 & 0xFFFFFFFE;
      v71 = v21 + 8;
      v72 = v22;
      do
      {
        v69 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v71 - 8) + 416) + 32);
        v70 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v71 + 416) + 32);
        v71 += 16;
        v72 -= 2;
      }
      while (v72);
      result = v70 + v69;
      if (v22 != v20)
        goto LABEL_72;
      return result;
    case 6:
      v23 = *(unsigned int *)(a1 + 596);
      if ((int)v23 < 1)
        return 0;
      v24 = *(_QWORD *)(a1 + 248);
      if ((_DWORD)v23 == 1)
      {
        v25 = 0;
        result = 0;
LABEL_78:
        v80 = (uint64_t *)(v24 + 8 * v25);
        v81 = v23 - v25;
        do
        {
          v82 = *v80++;
          result += *(_QWORD *)(*(_QWORD *)(v82 + 416) + 40);
          --v81;
        }
        while (v81);
        return result;
      }
      v76 = 0;
      v77 = 0;
      v25 = v23 & 0xFFFFFFFE;
      v78 = v24 + 8;
      v79 = v25;
      do
      {
        v76 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v78 - 8) + 416) + 40);
        v77 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v78 + 416) + 40);
        v78 += 16;
        v79 -= 2;
      }
      while (v79);
      result = v77 + v76;
      if (v25 != v23)
        goto LABEL_78;
      return result;
    case 7:
      v26 = *(unsigned int *)(a1 + 596);
      if ((int)v26 < 1)
        return 0;
      v27 = *(_QWORD *)(a1 + 248);
      if ((_DWORD)v26 == 1)
      {
        v28 = 0;
        result = 0;
LABEL_84:
        v87 = (uint64_t *)(v27 + 8 * v28);
        v88 = v26 - v28;
        do
        {
          v89 = *v87++;
          result += *(_QWORD *)(*(_QWORD *)(v89 + 416) + 48);
          --v88;
        }
        while (v88);
        return result;
      }
      v83 = 0;
      v84 = 0;
      v28 = v26 & 0xFFFFFFFE;
      v85 = v27 + 8;
      v86 = v28;
      do
      {
        v83 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v85 - 8) + 416) + 48);
        v84 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v85 + 416) + 48);
        v85 += 16;
        v86 -= 2;
      }
      while (v86);
      result = v84 + v83;
      if (v28 != v26)
        goto LABEL_84;
      return result;
    case 8:
      v29 = *(unsigned int *)(a1 + 596);
      if ((int)v29 < 1)
        return 0;
      v30 = *(_QWORD *)(a1 + 248);
      if ((_DWORD)v29 == 1)
      {
        v31 = 0;
        result = 0;
LABEL_90:
        v94 = (uint64_t *)(v30 + 8 * v31);
        v95 = v29 - v31;
        do
        {
          v96 = *v94++;
          result += *(_QWORD *)(*(_QWORD *)(v96 + 416) + 56);
          --v95;
        }
        while (v95);
        return result;
      }
      v90 = 0;
      v91 = 0;
      v31 = v29 & 0xFFFFFFFE;
      v92 = v30 + 8;
      v93 = v31;
      do
      {
        v90 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v92 - 8) + 416) + 56);
        v91 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v92 + 416) + 56);
        v92 += 16;
        v93 -= 2;
      }
      while (v93);
      result = v91 + v90;
      if (v31 != v29)
        goto LABEL_90;
      return result;
    case 9:
      v32 = *(unsigned int *)(a1 + 596);
      if ((int)v32 < 1)
        return 0;
      v33 = *(_QWORD *)(a1 + 248);
      if ((_DWORD)v32 == 1)
      {
        v34 = 0;
        result = 0;
LABEL_96:
        v101 = (uint64_t *)(v33 + 8 * v34);
        v102 = v32 - v34;
        do
        {
          v103 = *v101++;
          result += *(_QWORD *)(*(_QWORD *)(v103 + 416) + 72);
          --v102;
        }
        while (v102);
        return result;
      }
      v97 = 0;
      v98 = 0;
      v34 = v32 & 0xFFFFFFFE;
      v99 = v33 + 8;
      v100 = v34;
      do
      {
        v97 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v99 - 8) + 416) + 72);
        v98 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v99 + 416) + 72);
        v99 += 16;
        v100 -= 2;
      }
      while (v100);
      result = v98 + v97;
      if (v34 != v32)
        goto LABEL_96;
      return result;
    case 10:
      return *(int *)(a1 + 692);
    case 11:
      return *(int *)(a1 + 696);
    case 12:
      return *(_QWORD *)(a1 + 1064) - *(_QWORD *)(a1 + 1056);
    case 13:
      v35 = *(unsigned int *)(a1 + 596);
      if ((int)v35 < 1)
        return 0;
      v36 = *(_QWORD *)(a1 + 248);
      if ((_DWORD)v35 == 1)
      {
        v37 = 0;
        result = 0;
LABEL_102:
        v108 = (uint64_t *)(v36 + 8 * v37);
        v109 = v35 - v37;
        do
        {
          v110 = *v108++;
          result += *(_QWORD *)(*(_QWORD *)(v110 + 416) + 80);
          --v109;
        }
        while (v109);
        return result;
      }
      v104 = 0;
      v105 = 0;
      v37 = v35 & 0xFFFFFFFE;
      v106 = v36 + 8;
      v107 = v37;
      do
      {
        v104 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v106 - 8) + 416) + 80);
        v105 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v106 + 416) + 80);
        v106 += 16;
        v107 -= 2;
      }
      while (v107);
      result = v105 + v104;
      if (v37 != v35)
        goto LABEL_102;
      return result;
    case 14:
      v38 = *(unsigned int *)(a1 + 596);
      if ((int)v38 < 1)
        return 0;
      v39 = *(_QWORD *)(a1 + 248);
      if ((_DWORD)v38 == 1)
      {
        v40 = 0;
        result = 0;
LABEL_108:
        v115 = (uint64_t *)(v39 + 8 * v40);
        v116 = v38 - v40;
        do
        {
          v117 = *v115++;
          result += *(_QWORD *)(*(_QWORD *)(v117 + 416) + 88);
          --v116;
        }
        while (v116);
        return result;
      }
      v111 = 0;
      v112 = 0;
      v40 = v38 & 0xFFFFFFFE;
      v113 = v39 + 8;
      v114 = v40;
      do
      {
        v111 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v113 - 8) + 416) + 88);
        v112 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v113 + 416) + 88);
        v113 += 16;
        v114 -= 2;
      }
      while (v114);
      result = v112 + v111;
      if (v40 != v38)
        goto LABEL_108;
      return result;
    default:
      return 0;
  }
}

uint64_t HGRenderer::GetLimits(HGRenderer *this, int a2)
{
  if (a2 == 327680)
    return *((_QWORD *)this + 103);
  if (a2 == 393216)
    return *((_QWORD *)this + 102);
  return 0;
}

BOOL HGRenderer::IsMergeable(HGRenderer *this, HGNode *a2, unsigned int a3, int a4)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  _BOOL8 result;
  int v12;
  BOOL v13;
  char *v14;
  char *v15;
  unsigned int v16;
  char *v17;
  char *v18;

  if ((a3 & 0x80000000) != 0)
  {
    v8 = *((_DWORD *)a2 + 4);
    if ((v8 & 0x26) != 0)
      return 0;
  }
  else
  {
    if (*((_DWORD *)a2 + 22) > (signed int)a3)
    {
      v7 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * a3);
      if (v7)
      {
        v8 = *(_DWORD *)(v7 + 12);
        v9 = *(_QWORD *)(v7 + 16);
        if (v9)
        {
          v10 = *(_DWORD *)(v9 + 16);
          v8 |= v10 | *(_DWORD *)(HGRenderer::GetOutput(this, (HGNode *)v9) + 16);
        }
        if ((v8 & 0x26) == 0)
          goto LABEL_11;
        return 0;
      }
    }
    LOBYTE(v8) = 0;
  }
LABEL_11:
  v12 = *((_DWORD *)this + 208) | v8 & 0x40;
  result = v12 != 0;
  if (v12)
    v13 = a4 == 0;
  else
    v13 = 1;
  if (!v13)
  {
    if (*((_QWORD *)a2 + 16) < 2uLL)
      return 1;
    v14 = (char *)*((_QWORD *)a2 + 14);
    v15 = (char *)a2 + 120;
    if (v14 == v15)
    {
      return 1;
    }
    else
    {
      v16 = 0;
      do
      {
        if (HGRenderer::GetOutput(this, **((HGNode ***)v14 + 4)) == **((_QWORD **)v14 + 4))
          ++v16;
        v17 = (char *)*((_QWORD *)v14 + 1);
        if (v17)
        {
          do
          {
            v18 = v17;
            v17 = *(char **)v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            v18 = (char *)*((_QWORD *)v14 + 2);
            v13 = *(_QWORD *)v18 == (_QWORD)v14;
            v14 = v18;
          }
          while (!v13);
        }
        v14 = v18;
      }
      while (v18 != v15);
      return v16 < 2;
    }
  }
  return result;
}

uint64_t HGRenderer::GetROI(HGRenderer *this, HGNode *a2)
{
  HGNode *Output;
  __int128 *v3;

  Output = HGRenderer::GetOutput(this, a2);
  v3 = &HGRectNull;
  if (Output && (*((_BYTE *)Output + 136) & 8) != 0)
    v3 = (__int128 *)((char *)Output + 168);
  return *(_QWORD *)v3;
}

HGNode *HGRenderer::GetInput(HGRenderer *this, HGNode *a2, unsigned int a3)
{
  uint64_t v3;

  if (a2
    && (a3 & 0x80000000) == 0
    && *((_DWORD *)a2 + 22) > (signed int)a3
    && (v3 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8 * a3)) != 0)
  {
    return HGRenderer::GetOutput(this, *(HGNode **)(v3 + 16));
  }
  else
  {
    return 0;
  }
}

uint64_t HGRenderer::GetProgram(HGRenderer *this, HGNode *a2)
{
  return (*(uint64_t (**)(HGNode *, HGRenderer *))(*(_QWORD *)a2 + 184))(a2, this);
}

void HGRenderer::CreateDepthBufferManagers(HGRenderer *this)
{
  uint64_t **v1;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _BYTE *v13;
  uint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  _OWORD *v19;
  uint64_t *v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;

  v1 = (uint64_t **)((char *)this + 224);
  if (*((_DWORD *)this + 149) > (int)((*((_QWORD *)this + 29) - *((_QWORD *)this + 28)) >> 3))
  {
    while (1)
    {
      v4 = operator new();
      DBM_cpu::DBM_cpu(v4, (uint64_t)this);
      *(_BYTE *)(v4 + 40) = *((_BYTE *)this + 810);
      v6 = (uint64_t *)*((_QWORD *)this + 29);
      v5 = *((_QWORD *)this + 30);
      if ((unint64_t)v6 >= v5)
        break;
      *v6 = v4;
      v3 = (uint64_t)(v6 + 1);
LABEL_4:
      *((_QWORD *)this + 29) = v3;
      if (*((_DWORD *)this + 149) <= (int)((unint64_t)(v3 - *((_QWORD *)this + 28)) >> 3))
        return;
    }
    v7 = *v1;
    v8 = (char *)v6 - (char *)*v1;
    v9 = v8 >> 3;
    v10 = (v8 >> 3) + 1;
    if (v10 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v11 = v5 - (_QWORD)v7;
    if (v11 >> 2 > v10)
      v10 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      if (v12 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v13 = operator new(8 * v12);
      v14 = (uint64_t *)&v13[8 * v9];
      *v14 = v4;
      v3 = (uint64_t)(v14 + 1);
      if (v6 == v7)
        goto LABEL_24;
    }
    else
    {
      v13 = 0;
      v14 = (uint64_t *)(8 * v9);
      *(_QWORD *)(8 * v9) = v4;
      v3 = 8 * v9 + 8;
      if (v6 == v7)
      {
LABEL_24:
        *((_QWORD *)this + 28) = v14;
        *((_QWORD *)this + 29) = v3;
        *((_QWORD *)this + 30) = &v13[8 * v12];
        if (v6)
          operator delete(v6);
        goto LABEL_4;
      }
    }
    v15 = (char *)(v6 - 1) - (char *)v7;
    if (v15 < 0x58)
      goto LABEL_31;
    if ((unint64_t)((char *)v6 - &v13[v8]) < 0x20)
      goto LABEL_31;
    v16 = (v15 >> 3) + 1;
    v17 = 8 * (v16 & 0x3FFFFFFFFFFFFFFCLL);
    v18 = &v6[v17 / 0xFFFFFFFFFFFFFFF8];
    v14 = (uint64_t *)((char *)v14 - v17);
    v19 = &v13[8 * v9 - 16];
    v20 = v6 - 2;
    v21 = v16 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v22 = *(_OWORD *)v20;
      *(v19 - 1) = *((_OWORD *)v20 - 1);
      *v19 = v22;
      v19 -= 2;
      v20 -= 4;
      v21 -= 4;
    }
    while (v21);
    v6 = v18;
    if (v16 != (v16 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_31:
      do
      {
        v23 = *--v6;
        *--v14 = v23;
      }
      while (v6 != v7);
    }
    v6 = *v1;
    goto LABEL_24;
  }
}

void sub_1B2A82168(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C402DBA53A3);
  _Unwind_Resume(a1);
}

void StatsAccumulator::StatsAccumulator(StatsAccumulator *this)
{
  unint64_t v2;
  int v3;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_QWORD *)this + 2) = 0;
  HGLogger::setLevel((HGLogger *)"stats", (const char *)1);
  v2 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v2 > 0xC7)
  {
    if (v2 != 200)
      *((_QWORD *)this + 1) = *(_QWORD *)this + 200;
  }
  else
  {
    std::vector<float>::__append((char **)this, 50 - (v2 >> 2));
  }
  v3 = *((_DWORD *)this + 6);
  if (v3 >= 49)
    v3 = 49;
  *((_DWORD *)this + 6) = v3;
}

void sub_1B2A82210(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void StatsAccumulator::~StatsAccumulator(StatsAccumulator *this)
{
  void *v2;

  v2 = *(void **)this;
  if (v2)
  {
    *((_QWORD *)this + 1) = v2;
    operator delete(v2);
  }
}

uint64_t HGRenderer::UpdateLimits(HGRenderer *this, HGLimits *a2, int a3)
{
  int v3;
  char v4;
  char v5;

  *((_QWORD *)a2 + 4) = 0;
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_DWORD *)a2 + 5) = -1;
  *((_DWORD *)a2 + 11) = -1;
  v3 = 74448896;
  if ((a3 & 0x4700000) != 0 || (v3 = 75497472, (a3 & 0x4800000) != 0))
  {
    *(_DWORD *)a2 = v3;
    v4 = 16;
    *((_WORD *)a2 + 12) = 16;
    *((_BYTE *)a2 + 27) = 8;
  }
  else if ((a3 & 0x8100000) != 0)
  {
    v4 = 32;
    *((_WORD *)a2 + 12) = 32;
    *((_BYTE *)a2 + 26) = 0;
  }
  else
  {
    *(_DWORD *)a2 = 0x1000000;
    *((_WORD *)a2 + 12) = -1;
    v4 = -1;
    *((_BYTE *)a2 + 27) = -1;
  }
  *((_BYTE *)a2 + 28) = v4;
  *((_BYTE *)a2 + 29) = v4;
  *(_DWORD *)((char *)a2 + 34) = 0x80000;
  *((_BYTE *)a2 + 40) = 8 * ((a3 & 0xF0000) == 393216);
  *((_BYTE *)a2 + 41) = 0;
  if ((a3 & 0xF0000) == 0x60000)
    v5 = 1;
  else
    v5 = 8;
  *((_BYTE *)a2 + 42) = v5;
  *((_BYTE *)a2 + 43) = 0;
  return HGLimits::setnormalized((uint64_t)a2, 0);
}

uint64_t HGRenderer::PreRenderTraversal(HGNode *)::PreRenderUserGraphTraversalVisitor::visitNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 448))(a3);
}

uint64_t HGRenderer::PreRenderTraversal(HGNode *)::PreRenderRenderGraphTraversalVisitor::visitNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 448))(a3);
}

void HGSampler::HGSampler(HGSampler *this, HGExecutionUnit *a2)
{
  uint64_t v4;
  uint64_t v5;

  HGObject::HGObject(this);
  *(_QWORD *)v4 = off_1E6526008;
  *(_DWORD *)(v4 + 112) = 0;
  *(_QWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  *(_QWORD *)(v4 + 16) = a2;
  *(_OWORD *)(v4 + 48) = xmmword_1B304F240;
  *(_OWORD *)(v4 + 64) = xmmword_1B3522960;
  *(_OWORD *)(v4 + 80) = xmmword_1B3522970;
  *(_OWORD *)(v4 + 96) = xmmword_1B3522980;
  HgcSampler::Create((HgcSampler *)v4);
  *((_QWORD *)this + 15) = v5;
}

void sub_1B2A823AC(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGSampler::~HGSampler(HGSampler *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6526008;
  HgcSampler::Destroy(*((_QWORD *)this + 15));
  v2 = *((_QWORD *)this + 3);
  if (v2)
    HGFree(v2);
  HGObject::~HGObject(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6526008;
  HgcSampler::Destroy(*((_QWORD *)this + 15));
  v2 = *((_QWORD *)this + 3);
  if (v2)
    HGFree(v2);
  HGObject::~HGObject(this);
  HGObject::operator delete(v3);
}

void HGSampler::ReadTile(float32x4_t *a1, _DWORD *a2, uint64_t a3, int8x16_t *a4, unint64_t a5, unint64_t a6, uint64_t a7)
{
  if (a3)
    HGSampler::GetTile(a1, a2, a3, a4, a5, a6, a7);
  else
    (*(void (**)(_DWORD *, int8x16_t *, unint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 72))(a2, a4, a5, a6, a7);
}

void HGSampler::GetTile(float32x4_t *a1, _DWORD *a2, uint64_t a3, int8x16_t *a4, unint64_t a5, unint64_t a6, uint64_t a7)
{
  unint64_t v14;
  float32x4_t v15;
  int32x2_t v16;
  float32x4_t v17;
  uint64_t v19;
  float32x2_t *v20;
  float v21;
  float32x4_t v22;
  uint64_t v23;
  float32x2_t *v24;
  float v25;
  float32x4_t v26;
  float32x4_t v27;
  uint64_t v28;
  float32x2_t *v29;
  float v30;
  float32x4_t v31;
  __int32 v32;
  float32x4_t v33;
  unsigned int v34;
  uint64_t v35;
  float32x2_t *v36;
  float v37;
  float32x4_t v42;
  unint64_t v43;
  signed int v44;
  signed int v45;
  float32x4_t v46;
  unint64_t v47;
  float v48;
  float v49;
  float v50;
  float v51;
  int v52;
  BOOL v53;
  BOOL v54;
  signed int v56;
  signed int v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  unsigned int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t i64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  size_t v75;
  int8x16_t *v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  int32x2_t v80;
  int32x4_t v81;
  int32x2_t v82;
  __int32 v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t Stack;
  uint64_t v87;
  int32x2_t v88;
  int32x4_t v89;
  int32x4_t v90;
  int v91;
  int v92;
  uint64_t v93;
  unsigned int v94;
  uint64_t v95;
  uint64_t v96;
  unsigned int v97;
  int v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  int v104;
  float32x4_t *v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  int8x16_t v124;
  float32x4_t v125;
  float32x4_t v126;
  int8x16_t v127;
  int8x16_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  float32x4_t v135;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t *v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t *v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  uint64_t v164;
  float32x4_t v165;
  float32x4_t *v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x2_t v171;
  int32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  signed int v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  int32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  int32x4_t v184;
  float32x4_t v185;
  float32x4_t v186;
  float32x4_t v187;
  float32x4_t v188;
  float32x4_t v189;
  float32x4_t v190;
  float32x4_t v191;
  float32x4_t v192;
  float32x4_t v193;
  float32x4_t *v194;
  float32x4_t v195;
  float32x4_t v196;
  float32x4_t v197;
  float32x4_t *v198;
  float32x4_t v199;
  float32x4_t v200;
  float32x4_t v201;
  float32x4_t *v202;
  float32x4_t v203;
  float32x4_t v204;
  float32x4_t v205;
  float32x4_t v206;
  float32x4_t v207;
  float32x4_t v208;
  float32x4_t v209;
  float32x4_t v210;
  float32x4_t v211;
  float32x4_t v212;
  float32x4_t v213;
  float32x4_t *v214;
  float32x4_t v215;
  float32x4_t v216;
  float32x4_t *v217;
  float32x4_t v218;
  float32x4_t v219;
  float32x4_t v220;
  float32x4_t v221;
  float32x4_t v222;
  float32x4_t v223;
  float32x4_t v224;
  float32x4_t v225;
  float32x4_t v226;
  float32x4_t v227;
  float32x4_t *v228;
  float32x4_t v229;
  float32x4_t v230;
  float32x4_t v231;
  float32x4_t *v232;
  float32x4_t v233;
  float32x4_t v234;
  float32x4_t v235;
  float32x4_t v236;
  float32x4_t v237;
  float32x4_t v238;
  float32x4_t v239;
  float32x4_t v240;
  float32x4_t v241;
  float32x4_t v242;
  uint64_t v243;
  unsigned int v244;
  float32x4_t v245;
  float32x4_t *v246;
  float32x4_t v247;
  float32x4_t v248;
  float32x4_t *v249;
  float32x4_t v250;
  float32x4_t v251;
  int v252;
  float32x4_t v253;
  float32x4_t v254;
  float32x4_t v255;
  float32x4_t v256;
  float32x4_t v257;
  float32x4_t v258;
  int32x4_t v259;
  float32x4_t v260;
  float32x4_t v261;
  float32x4_t v262;
  float32x4_t v263;
  float32x4_t v264;
  float32x4_t v265;
  float32x4_t v266;
  float32x4_t v267;
  float32x4_t v268;
  float32x4_t v269;
  float32x4_t v270;
  float32x4_t v271;
  float32x4_t *v272;
  float32x4_t v273;
  float32x4_t v274;
  float32x4_t v275;
  float32x4_t *v276;
  float32x4_t v277;
  signed int v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  int v284;
  signed int v285;
  __int32 v286;
  signed int v287;
  unsigned int v288;
  float32x4_t v289;
  float32x4_t v290;
  float32x2_t v291;
  float32x4_t v292;
  int v293;
  uint64_t v294;
  int32x4_t v295;
  uint64_t v296;
  uint64_t v297;
  int32x2_t v298;
  uint64_t v299;
  int v300;
  int32x2_t v301;
  __int32 v302;
  __int32 v303;
  _DWORD *v304;
  float32x4_t v305;
  unsigned int v306;
  unint64_t v307;
  __int128 v308;
  __int128 v309;
  uint64_t v310;
  uint64_t v311;
  int v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  __int128 v316[2];
  uint64_t v317;
  __int128 v318[2];
  uint64_t v319;
  __int128 v320[2];
  uint64_t v321;
  int32x4_t v322;
  int32x4_t v323;
  int32x4_t v324;
  float32x4_t v325;

  v322.i64[0] = a5;
  v14 = HIDWORD(a6);
  v322.i64[1] = 0x100000000;
  v323.i64[0] = __PAIR64__(HIDWORD(a5), a6);
  v307 = HIDWORD(a5);
  v323.i64[1] = 0x100000000;
  v324.i64[0] = a6;
  v324.i64[1] = 0x100000000;
  v325.i64[0] = __PAIR64__(HIDWORD(a6), a5);
  v325.i64[1] = 0x100000000;
  v322 = (int32x4_t)vaddq_f32(vcvtq_f32_s32(v322), (float32x4_t)xmmword_1B3052100);
  v323 = (int32x4_t)vaddq_f32(vcvtq_f32_s32(v323), (float32x4_t)xmmword_1B30511F0);
  v324 = (int32x4_t)vaddq_f32(vcvtq_f32_s32(v324), (float32x4_t)xmmword_1B3522990);
  v325 = vaddq_f32(vcvtq_f32_s32((int32x4_t)v325), (float32x4_t)xmmword_1B35229A0);
  (*(void (**)(uint64_t, int32x4_t *, int32x4_t *, uint64_t))(*(_QWORD *)a3 + 208))(a3, &v322, &v322, 4);
  v15.i32[0] = v322.i32[3];
  v16.i32[0] = v323.i32[3];
  v17.i32[0] = v324.i32[3];
  _Q0.i32[0] = v325.i32[3];
  if (((*(float *)&v322.i32[3] < 0.00024414) | (8 * (v325.f32[3] < 0.00024414)) | (4
                                                                                  * (*(float *)&v324.i32[3] < 0.00024414)) | (2 * (*(float *)&v323.i32[3] < 0.00024414))) == 0xF)
  {
LABEL_54:
    v70 = (*(float *)&v322.i32[3] < 0.00024414) | (8 * (v325.f32[3] < 0.00024414)) | (4
                                                                                    * (*(float *)&v324.i32[3] < 0.00024414)) | (2 * (*(float *)&v323.i32[3] < 0.00024414));
    v71 = a7;
    if ((_DWORD)a7)
    {
      v72 = a5;
      v73 = a6;
      v74 = v14 - v307;
      if ((int)v14 > (int)v307)
      {
        v75 = 16 * ((int)a6 - v72);
        v76 = a4;
        do
        {
          bzero(v76, v75);
          v76 += v73 - v72 + v71;
          --v74;
        }
        while (v74);
      }
      if ((a1[7].i8[0] & 1) == 0)
        return;
    }
    else
    {
      v73 = a6;
      v72 = a5;
      bzero(a4, 16 * ((int)a6 - (int)a5) * ((int)v14 - (int)v307));
      if ((a1[7].i8[0] & 1) == 0)
        return;
    }
    _Q0.i32[0] = 0;
    v15.i32[0] = 15;
    v17.i32[0] = v70;
    a4[(((int)v14 - (int)v307) >> 1) * (v73 - v72 + v71) + ((v73 - v72) >> 1)] = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v17, (int32x4_t)_Q0), 0), (int8x16_t)xmmword_1B3051310, vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v17, (int32x4_t)v15), 0), (int8x16_t)xmmword_1B304FAB0, (int8x16_t)xmmword_1B3050190));
    return;
  }
  if (*(float *)&v322.i32[3] >= 0.00024414)
  {
    *(float32x2_t *)v22.f32 = vdiv_f32(*(float32x2_t *)v322.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v15.f32, 0));
    v22.f32[2] = *(float *)&v322.i32[2] / *(float *)&v322.i32[3];
    v22.i32[3] = v322.i32[3];
    if (*(float *)&v323.i32[3] < 0.00024414)
      goto LABEL_8;
LABEL_22:
    *(float32x2_t *)v26.f32 = vdiv_f32(*(float32x2_t *)v323.i8, (float32x2_t)vdup_lane_s32(v16, 0));
    v26.f32[2] = *(float *)&v323.i32[2] / *(float *)&v323.i32[3];
    v26.i32[3] = v323.i32[3];
    if (*(float *)&v324.i32[3] >= 0.00024414)
      goto LABEL_13;
    goto LABEL_23;
  }
  v19 = 2;
  if (v325.f32[3] >= 0.00024414)
    v19 = 3;
  if (*(float *)&v323.i32[3] >= 0.00024414)
    v19 = 1;
  v20 = (float32x2_t *)(&v322 + v19);
  v21 = (float)(0.00024414 - *(float *)&v322.i32[3]) / (float)(v20[1].f32[1] - *(float *)&v322.i32[3]);
  *(float32x2_t *)v22.f32 = vmul_f32(vadd_f32(*(float32x2_t *)v322.i8, vmul_n_f32(vsub_f32(*v20, *(float32x2_t *)v322.i8), v21)), (float32x2_t)vdup_n_s32(0x45800000u));
  v22.f32[2] = (float)(*(float *)&v322.i32[2] + (float)(v21 * (float)(v20[1].f32[0] - *(float *)&v322.i32[2]))) * 4096.0;
  v22.i32[3] = 964689920;
  if (*(float *)&v323.i32[3] >= 0.00024414)
    goto LABEL_22;
LABEL_8:
  v23 = 3;
  if (*(float *)&v322.i32[3] >= 0.00024414)
    v23 = 0;
  if (*(float *)&v324.i32[3] >= 0.00024414)
    v23 = 2;
  v24 = (float32x2_t *)(&v322 + v23);
  v25 = (float)(0.00024414 - *(float *)&v323.i32[3]) / (float)(v24[1].f32[1] - *(float *)&v323.i32[3]);
  *(float32x2_t *)v26.f32 = vmul_f32(vadd_f32(*(float32x2_t *)v323.i8, vmul_n_f32(vsub_f32(*v24, *(float32x2_t *)v323.i8), v25)), (float32x2_t)vdup_n_s32(0x45800000u));
  v26.f32[2] = (float)(*(float *)&v323.i32[2] + (float)(v25 * (float)(v24[1].f32[0] - *(float *)&v323.i32[2]))) * 4096.0;
  v26.i32[3] = 964689920;
  if (*(float *)&v324.i32[3] >= 0.00024414)
  {
LABEL_13:
    *(float32x2_t *)v27.f32 = vdiv_f32(*(float32x2_t *)v324.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v17.f32, 0));
    v27.f32[2] = *(float *)&v324.i32[2] / *(float *)&v324.i32[3];
    v27.i32[3] = v324.i32[3];
    if (v325.f32[3] < 0.00024414)
      goto LABEL_14;
    goto LABEL_26;
  }
LABEL_23:
  v35 = *(float *)&v323.i32[3] >= 0.00024414;
  if (v325.f32[3] >= 0.00024414)
    v35 = 3;
  v36 = (float32x2_t *)(&v322 + v35);
  v37 = (float)(0.00024414 - *(float *)&v324.i32[3]) / (float)(v36[1].f32[1] - *(float *)&v324.i32[3]);
  *(float32x2_t *)v27.f32 = vmul_f32(vadd_f32(*(float32x2_t *)v324.i8, vmul_n_f32(vsub_f32(*v36, *(float32x2_t *)v324.i8), v37)), (float32x2_t)vdup_n_s32(0x45800000u));
  v27.f32[2] = (float)(*(float *)&v324.i32[2] + (float)(v37 * (float)(v36[1].f32[0] - *(float *)&v324.i32[2]))) * 4096.0;
  v27.i32[3] = 964689920;
  if (v325.f32[3] < 0.00024414)
  {
LABEL_14:
    v28 = 2;
    if (*(float *)&v324.i32[3] < 0.00024414)
      v28 = 1;
    if (*(float *)&v322.i32[3] >= 0.00024414)
      v28 = 0;
    v29 = (float32x2_t *)(&v322 + v28);
    v30 = (float)(0.00024414 - v325.f32[3]) / (float)(v29[1].f32[1] - v325.f32[3]);
    *(float32x2_t *)v31.f32 = vmul_f32(vadd_f32(*(float32x2_t *)v325.f32, vmul_n_f32(vsub_f32(*v29, *(float32x2_t *)v325.f32), v30)), (float32x2_t)vdup_n_s32(0x45800000u));
    v31.f32[2] = (float)(v325.f32[2] + (float)(v30 * (float)(v29[1].f32[0] - v325.f32[2]))) * 4096.0;
    v31.i32[3] = 964689920;
    v32 = a1[2].i32[1];
    v33 = (float32x4_t)xmmword_1B3052100;
    if (v32)
      goto LABEL_19;
LABEL_27:
    v33 = 0uLL;
    __asm { FMOV            V0.4S, #1.0 }
    v34 = 1;
    goto LABEL_29;
  }
LABEL_26:
  *(float32x2_t *)v31.f32 = vdiv_f32(*(float32x2_t *)v325.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q0.f32, 0));
  v31.f32[2] = v325.f32[2] / v325.f32[3];
  v31.i32[3] = v325.i32[3];
  v32 = a1[2].i32[1];
  v33 = (float32x4_t)xmmword_1B3052100;
  if (!v32)
    goto LABEL_27;
LABEL_19:
  if (v32 == 1)
  {
    _Q0.i64[0] = 0x4000000040000000;
    _Q0.i64[1] = 0x4000000040000000;
    v34 = 2;
  }
  else
  {
    v33 = (float32x4_t)xmmword_1B35229B0;
    __asm { FMOV            V0.4S, #4.0 }
    v34 = 4;
  }
LABEL_29:
  v305 = v33;
  v42 = vsubq_f32(vminq_f32(v22, vminq_f32(v26, vminq_f32(v27, v31))), v33);
  v17 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
  v15 = vaddq_f32(v17, vcvtq_f32_s32(vcgtq_f32(v17, v42)));
  v43 = vcvtq_s32_f32(v15).u64[0];
  v44 = v43;
  if ((int)v43 >= a2[7])
    goto LABEL_54;
  v45 = HIDWORD(v43);
  if (SHIDWORD(v43) >= a2[8])
    goto LABEL_54;
  v46 = vsubq_f32(vmaxq_f32(v22, vmaxq_f32(v26, vmaxq_f32(v27, v31))), v305);
  v17 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
  v15 = vsubq_f32(v17, vcvtq_f32_s32(vcgtq_f32(v46, v17)));
  _Q0 = vaddq_f32(_Q0, v15);
  v47 = vcvtq_s32_f32(_Q0).u64[0];
  if ((int)v47 <= a2[5] || SHIDWORD(v47) <= a2[6])
    goto LABEL_54;
  v304 = a2;
  v48 = v22.f32[3] / v31.f32[3];
  if (v31.f32[3] > v22.f32[3])
    v48 = v31.f32[3] / v22.f32[3];
  v49 = v26.f32[3] / v27.f32[3];
  if (v27.f32[3] > v26.f32[3])
    v49 = v27.f32[3] / v26.f32[3];
  v50 = v26.f32[3] / v22.f32[3];
  if (v26.f32[3] <= v22.f32[3])
    v50 = v22.f32[3] / v26.f32[3];
  v51 = v27.f32[3] / v31.f32[3];
  if (v27.f32[3] <= v31.f32[3])
    v51 = v31.f32[3] / v27.f32[3];
  if ((int)v14 - (int)v307 >= 2)
  {
    v52 = a6 - a5;
    if ((int)a6 - (int)a5 >= 2)
    {
      v53 = v48 <= 1.0625 && v49 <= 1.0625;
      v54 = v53 && v50 <= 1.0625;
      if (!v54 || v51 > 1.0625)
      {
        v56 = a5;
        v284 = a7;
        v57 = ((int)a6 + (int)a5) >> 1;
        v310 = 0;
        v308 = 0u;
        v309 = 0u;
        HGExecutionUnit::GetStackState(a1[1].i64[0], (uint64_t)&v308);
        v58 = HGRectMake4i(v56, v307, v57, ((int)v14 + (int)v307) >> 1);
        v306 = a6 - v57 + a7;
        HGSampler::GetTile(a1, v304, a3, a4, v58, v59, v306);
        v300 = v52 + a7;
        v60 = ((((int)v14 + (int)v307) >> 1) - v307) * (v52 + a7);
        HGExecutionUnit::CommitStack(a1[1].i64[0], (uint64_t)a4, v60);
        v61 = ((int)v14 + (int)v307) >> 1;
        v62 = HGRectMake4i(v57, v307, a6, v61);
        HGSampler::GetTile(a1, v304, a3, &a4[v57 - v56], v62, v63, (v57 - v56 + v284));
        i64 = (uint64_t)a4[v60].i64;
        v65 = HGRectMake4i(v56, v61, v57, v14);
        HGSampler::GetTile(a1, v304, a3, i64, v65, v66, v306);
        HGExecutionUnit::CommitStack(a1[1].i64[0], i64, (int)((v14 - v61) * v300));
        v67 = HGRectMake4i(v57, v61, a6, v14);
        HGSampler::GetTile(a1, v304, a3, i64 + 16 * (v57 - v56), v67, v68, (v57 - v56 + v284));
        v69 = a1[1].i64[0];
        v320[0] = v308;
        v320[1] = v309;
        v321 = v310;
        HGExecutionUnit::SetStackState(v69, v320);
        return;
      }
    }
  }
  v293 = v14 - v307;
  v322.i64[0] = v22.i64[0];
  v291 = *(float32x2_t *)v26.f32;
  v292 = v22;
  v322.i64[1] = v22.u32[2] | 0x3F80000000000000;
  v323.i64[0] = v26.i64[0];
  v323.i64[1] = v26.u32[2] | 0x3F80000000000000;
  v324.i64[0] = v27.i64[0];
  v289 = v31;
  v290 = v27;
  v324.i64[1] = v27.u32[2] | 0x3F80000000000000;
  v325.i64[0] = v31.i64[0];
  v325.i64[1] = v31.u32[2] | 0x3F80000000000000;
  v296 = *(_QWORD *)(v304 + 5);
  v294 = *(_QWORD *)(v304 + 7);
  v77 = v34;
  v298 = (int32x2_t)v43;
  v301 = (int32x2_t)v47;
  v78 = HGRectMake4i(-v34, -v34, v34, v34);
  v79 = HGRectGrow(v296, v294, v78);
  if (v44 <= (int)v79)
    v44 = v79;
  v288 = v77;
  v82 = vadd_s32(v298, vdup_n_s32(v77));
  if (v45 <= SHIDWORD(v79))
    v45 = HIDWORD(v79);
  *(int32x2_t *)v81.i8 = vmax_s32(vmin_s32(v301, v80), v82);
  v83 = v81.i32[0];
  v295 = v81;
  v302 = v81.i32[1];
  v297 = HGRectMake4i(v44, v45, v81.u32[0], v81.u32[1]);
  v299 = v84;
  v287 = v44;
  v285 = v45;
  v303 = v302 - v45;
  v286 = v83 - v44;
  v85 = v303 * (uint64_t)(v83 - v44);
  if (v85 < (int)(2
                 * (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1[1].i64[0] + 152) + 128))(*(_QWORD *)(a1[1].i64[0] + 152), 3)))goto LABEL_68;
  v92 = a6 - a5;
  if (v293 >= (int)a6 - (int)a5 && v293 >= 2)
  {
    v93 = a7;
    v94 = ((int)v14 + (int)v307) >> 1;
    v310 = 0;
    v308 = 0u;
    v309 = 0u;
    HGExecutionUnit::GetStackState(a1[1].i64[0], (uint64_t)&v308);
    v95 = HGRectMake4i(a5, v307, a6, v94);
    HGSampler::GetTile(a1, v304, a3, a4, v95, v96, a7);
    v97 = v14;
    v98 = (v94 - v307) * (v92 + v93);
    HGExecutionUnit::CommitStack(a1[1].i64[0], (uint64_t)a4, v98);
    v99 = HGRectMake4i(a5, v94, a6, v97);
    HGSampler::GetTile(a1, v304, a3, &a4[v98], v99, v100, v93);
    v101 = a1[1].i64[0];
    v318[0] = v308;
    v318[1] = v309;
    v319 = v310;
    HGExecutionUnit::SetStackState(v101, v318);
    return;
  }
  if (v92 < 2)
  {
LABEL_68:
    Stack = HGExecutionUnit::GetStack((uint64_t ****)a1[1].i64[0], 0);
    if ((int8x16_t *)Stack == a4)
      HGExecutionUnit::SwapStack(a1[1].i64[0]);
    v87 = HGExecutionUnit::GetStack((uint64_t ****)a1[1].i64[0], v85);
    (*(void (**)(_DWORD *, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v304 + 72))(v304, v87, v297, v299, 0);
    a1[8].i64[0] = (uint64_t)HgcSampler::Init(a1[7].i64[1], a3, a1[2].i32[1]);
    if ((int8x16_t *)Stack == a4)
      HGExecutionUnit::SwapStack(a1[1].i64[0]);
    v91 = a1[2].i32[1];
    if (v91 <= 1)
    {
      *(_QWORD *)&v308 = a5;
      *((_QWORD *)&v308 + 1) = a6;
      *(_QWORD *)&v309 = a4;
      DWORD2(v309) = a7 - a5 + a6;
      v312 = v299 - v297;
      v311 = v87 - 16 * ((int)v297 - (int)a5 + (HIDWORD(v297) - (int)v307) * ((int)v299 - (int)v297));
      v313 = v297;
      v314 = v299;
      v315 = a1[1].i64[0];
      ((void (*)(__int128 *, uint64_t, _QWORD))a1[8].i64[0])(&v308, a1[7].i64[1], 0);
      return;
    }
    v102 = a6 - a5;
    v103 = a6 - a5 - 1;
    if ((int)a6 - (int)a5 <= 1)
      v103 = 1;
    v104 = v293 - 1;
    if (v293 < 2)
      v104 = 1;
    if (v91 == 2 && (int)v14 > (int)v307)
    {
      v105 = (float32x4_t *)a4;
      v90.i32[0] = 0;
      v89.i64[0] = __PAIR64__(v285, v287);
      v106 = v292;
      v106.i32[3] = 1.0;
      v108 = v289;
      v107 = v290;
      v107.i32[3] = 1.0;
      v108.i32[3] = 1.0;
      v109 = vcvtq_f32_s32(v89);
      *(float *)v88.i32 = (float)v103;
      v110 = (float32x4_t)vdupq_lane_s32(v88, 0);
      *(float *)v88.i32 = (float)v104;
      v111 = (float32x4_t)vdupq_lane_s32(v88, 0);
      v112 = (float)(unint64_t)v286;
      *(float *)v89.i32 = (float)(v286 - (unint64_t)v288);
      v113 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v89.i8, 0);
      v114.i64[0] = 0x80000000800000;
      v114.i64[1] = 0x80000000800000;
      v115 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
      v116 = vminq_f32(vmaxq_f32(v110, v114), v115);
      v117 = vminq_f32(vmaxq_f32(vrecpeq_f32(v116), v114), v115);
      v118 = vminq_f32(vmaxq_f32(vmulq_f32(v117, vrecpsq_f32(v116, v117)), v114), v115);
      v119 = vmulq_f32(v118, vrecpsq_f32(v116, v118));
      v120 = vminq_f32(vmaxq_f32(v111, v114), v115);
      v121 = vminq_f32(vmaxq_f32(vrecpeq_f32(v120), v114), v115);
      v122 = vmulq_f32(v121, vrecpsq_f32(v120, v121));
      v121.f32[0] = (float)(v303 - (unint64_t)v288);
      v123 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v121.f32, 0);
      v124 = (int8x16_t)vminq_f32(vmaxq_f32(v122, v114), v115);
      v125 = vmulq_f32((float32x4_t)v124, vrecpsq_f32(v120, (float32x4_t)v124));
      *(float32x2_t *)v124.i8 = vmul_f32(vsub_f32(v291, *(float32x2_t *)v292.f32), *(float32x2_t *)v119.f32);
      v124.u64[1] = (unint64_t)vmul_f32(vsub_f32(*(float32x2_t *)v289.f32, *(float32x2_t *)v292.f32), *(float32x2_t *)v125.f32);
      v126 = vsubq_f32(vmulq_f32(v119, vsubq_f32(v107, v108)), (float32x4_t)v124);
      v127 = (int8x16_t)vmulq_f32(v125, v126);
      v126.i32[0] = a1[7].i32[0] & 1;
      v128 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v126, v90), 0);
      v129 = (float32x4_t)vandq_s8(v127, v128);
      v130 = (float32x4_t)vandq_s8(v124, v128);
      v135.i64[0] = 0x3F0000003F000000;
      v135.i64[1] = 0x3F0000003F000000;
      v131 = (float32x4_t)vbslq_s8(v128, (int8x16_t)vdupq_lane_s64(vsubq_f32(vsubq_f32(v106, v305), v109).i64[0], 0), (int8x16_t)vdupq_lane_s64(vmulq_f32(vsubq_f32(vcvtq_f32_s32(v295), v109), v135).i64[0], 0));
      v132 = 16 * v286;
      v133 = 32 * v286;
      v134 = 48 * v286;
      v135.i8[3] = 0;
      v135.i8[7] = 0;
      v135.i8[11] = 0;
      v135.i8[15] = 0;
      __asm
      {
        FMOV            V7.4S, #1.0
        FMOV            V17.4S, #4.0
      }
      v138 = 0uLL;
      do
      {
        v171 = (float32x2_t)vaddq_f32(v130, vmulq_f32(v129, v138)).u64[0];
        v172 = (int32x4_t)vaddq_f32(v131, vmulq_f32(v130, v138));
        v173 = (float32x4_t)vdupq_laneq_s32(v172, 2);
        v174 = (float32x4_t)vdupq_laneq_s32(v172, 3);
        if (v102 < 4)
        {
          v176 = a6 - a5;
          v175 = (float32x4_t)xmmword_1B304FD40;
          v252 = v14;
          if (!v102)
            goto LABEL_86;
        }
        else
        {
          v175 = (float32x4_t)xmmword_1B304FD40;
          v176 = a6 - a5;
          do
          {
            v177 = vmaxq_f32(vminq_f32(vaddq_f32(v173, vmulq_n_f32(v175, v171.f32[0])), v113), v135);
            v178 = vmaxq_f32(vminq_f32(vaddq_f32(v174, vmulq_lane_f32(v175, v171, 1)), v123), v135);
            v179 = vcvtq_f32_s32(vcvtq_s32_f32(v177));
            v180 = vcvtq_f32_s32(vcvtq_s32_f32(v178));
            v181 = vcvtq_s32_f32(vaddq_f32(vmulq_n_f32(v180, v112), v179));
            v182 = vsubq_f32(v177, v179);
            v183 = vsubq_f32(v178, v180);
            v184 = vshlq_n_s32(v181, 4uLL);
            v185 = a1[5];
            v186 = a1[6];
            v187 = vaddq_f32(v185, vmulq_n_f32(v186, v182.f32[0]));
            v188 = vaddq_f32(v185, vmulq_n_f32(v186, v183.f32[0]));
            v189 = vmulq_n_f32(v187, v182.f32[0]);
            v191 = a1[3];
            v190 = a1[4];
            v192 = vaddq_f32(v191, vmulq_n_f32(vaddq_f32(v190, v189), v182.f32[0]));
            v193 = vaddq_f32(v191, vmulq_n_f32(vaddq_f32(v190, vmulq_n_f32(v188, v183.f32[0])), v183.f32[0]));
            v194 = (float32x4_t *)(v87 + v184.i32[0]);
            v195 = vmulq_n_f32(v192, v193.f32[0]);
            v196 = vaddq_f32(vmulq_laneq_f32(v194[2], v195, 2), vaddq_f32(vmulq_lane_f32(v194[1], *(float32x2_t *)v195.f32, 1), vmulq_n_f32(*v194, v195.f32[0])));
            v197 = vmulq_laneq_f32(v194[3], v195, 3);
            v198 = (float32x4_t *)(v87 + v132 + v184.i32[0]);
            v199 = vaddq_f32(v197, v196);
            v200 = vmulq_lane_f32(v192, *(float32x2_t *)v193.f32, 1);
            v201 = vmulq_laneq_f32(v192, v193, 2);
            v202 = (float32x4_t *)(v87 + v134 + v184.i32[0]);
            v203 = vmulq_laneq_f32(v192, v193, 3);
            *v105 = vaddq_f32(vmulq_laneq_f32(v202[3], v203, 3), vaddq_f32(vmulq_laneq_f32(v202[2], v203, 2), vaddq_f32(vmulq_lane_f32(v202[1], *(float32x2_t *)v203.f32, 1), vaddq_f32(vmulq_n_f32(*v202, v203.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v133 + v184.i32[0] + 48), v201, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v133 + v184.i32[0] + 32), v201, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)(v87 + v133 + v184.i32[0] + 16), *(float32x2_t *)v201.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)(v87 + v133 + v184.i32[0]), v201.f32[0]), vaddq_f32(
                                      vmulq_laneq_f32(v198[3], v200, 3),
                                      vaddq_f32(vmulq_laneq_f32(v198[2], v200, 2), vaddq_f32(vmulq_lane_f32(v198[1], *(float32x2_t *)v200.f32, 1), vaddq_f32(vmulq_n_f32(*v198, v200.f32[0]), v199))))))))))));
            v204 = a1[5];
            v205 = a1[6];
            v206 = vaddq_f32(v204, vmulq_lane_f32(v205, *(float32x2_t *)v182.f32, 1));
            v207 = vaddq_f32(v204, vmulq_lane_f32(v205, *(float32x2_t *)v183.f32, 1));
            v209 = a1[3];
            v208 = a1[4];
            v210 = vaddq_f32(v208, vmulq_lane_f32(v207, *(float32x2_t *)v183.f32, 1));
            v211 = vaddq_f32(v209, vmulq_lane_f32(vaddq_f32(v208, vmulq_lane_f32(v206, *(float32x2_t *)v182.f32, 1)), *(float32x2_t *)v182.f32, 1));
            v212 = vaddq_f32(v209, vmulq_lane_f32(v210, *(float32x2_t *)v183.f32, 1));
            v213 = vmulq_n_f32(v211, v212.f32[0]);
            v214 = (float32x4_t *)(v87 + v132 + v184.i32[1]);
            v215 = vmulq_lane_f32(v211, *(float32x2_t *)v212.f32, 1);
            v216 = vmulq_laneq_f32(v211, v212, 2);
            v217 = (float32x4_t *)(v87 + v134 + v184.i32[1]);
            v218 = vmulq_laneq_f32(v211, v212, 3);
            v105[1] = vaddq_f32(vmulq_laneq_f32(v217[3], v218, 3), vaddq_f32(vmulq_laneq_f32(v217[2], v218, 2), vaddq_f32(vmulq_lane_f32(v217[1], *(float32x2_t *)v218.f32, 1), vaddq_f32(vmulq_n_f32(*v217, v218.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v133 + v184.i32[1] + 48), v216, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v133 + v184.i32[1] + 32), v216, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)(v87 + v133 + v184.i32[1] + 16), *(float32x2_t *)v216.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)(v87 + v133 + v184.i32[1]), v216.f32[0]), vaddq_f32(
                                        vmulq_laneq_f32(v214[3], v215, 3),
                                        vaddq_f32(vmulq_laneq_f32(v214[2], v215, 2), vaddq_f32(vmulq_lane_f32(v214[1], *(float32x2_t *)v215.f32, 1), vaddq_f32(vmulq_n_f32(*v214, v215.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v184.i32[1] + 48), v213, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v184.i32[1] + 32), v213, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)(v87 + v184.i32[1] + 16), *(float32x2_t *)v213.f32, 1), vmulq_n_f32(*(float32x4_t *)(v87 + v184.i32[1]), v213.f32[0]))))))))))))))));
            v219 = a1[5];
            v220 = a1[6];
            v221 = vaddq_f32(v219, vmulq_laneq_f32(v220, v182, 2));
            v222 = vaddq_f32(v219, vmulq_laneq_f32(v220, v183, 2));
            v224 = a1[3];
            v223 = a1[4];
            v225 = vaddq_f32(v223, vmulq_laneq_f32(v222, v183, 2));
            v226 = vaddq_f32(v224, vmulq_laneq_f32(vaddq_f32(v223, vmulq_laneq_f32(v221, v182, 2)), v182, 2));
            v227 = vaddq_f32(v224, vmulq_laneq_f32(v225, v183, 2));
            v228 = (float32x4_t *)(v87 + v184.i32[2]);
            v229 = vmulq_n_f32(v226, v227.f32[0]);
            v230 = vmulq_lane_f32(v226, *(float32x2_t *)v227.f32, 1);
            v231 = vmulq_laneq_f32(v226, v227, 2);
            v232 = (float32x4_t *)(v87 + v134 + v184.i32[2]);
            v233 = vmulq_laneq_f32(v226, v227, 3);
            v105[2] = vaddq_f32(vmulq_laneq_f32(v232[3], v233, 3), vaddq_f32(vmulq_laneq_f32(v232[2], v233, 2), vaddq_f32(vmulq_lane_f32(v232[1], *(float32x2_t *)v233.f32, 1), vaddq_f32(vmulq_n_f32(*v232, v233.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v133 + v184.i32[2] + 48), v231, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v133 + v184.i32[2] + 32), v231, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)(v87 + v133 + v184.i32[2] + 16), *(float32x2_t *)v231.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)(v87 + v133 + v184.i32[2]), v231.f32[0]), vaddq_f32(
                                        vmulq_laneq_f32(*(float32x4_t *)(v87 + v132 + v184.i32[2] + 48), v230, 3),
                                        vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v132 + v184.i32[2] + 32), v230, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)(v87 + v132 + v184.i32[2] + 16), *(float32x2_t *)v230.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)(v87 + v132 + v184.i32[2]), v230.f32[0]), vaddq_f32(vmulq_laneq_f32(v228[3], v229, 3), vaddq_f32(vmulq_laneq_f32(v228[2], v229, 2), vaddq_f32(vmulq_lane_f32(v228[1], *(float32x2_t *)v229.f32, 1), vmulq_n_f32(*v228, v229.f32[0]))))))))))))))));
            v234 = a1[5];
            v235 = a1[6];
            v236 = vaddq_f32(v234, vmulq_laneq_f32(v235, v182, 3));
            v237 = vaddq_f32(v234, vmulq_laneq_f32(v235, v183, 3));
            v238 = vmulq_laneq_f32(v236, v182, 3);
            v240 = a1[3];
            v239 = a1[4];
            v241 = vaddq_f32(v240, vmulq_laneq_f32(vaddq_f32(v239, v238), v182, 3));
            v242 = vaddq_f32(v240, vmulq_laneq_f32(vaddq_f32(v239, vmulq_laneq_f32(v237, v183, 3)), v183, 3));
            v243 = v184.i32[3];
            v244 = v176;
            v245 = vmulq_n_f32(v241, v242.f32[0]);
            v246 = (float32x4_t *)(v87 + v132 + v184.i32[3]);
            v247 = vmulq_lane_f32(v241, *(float32x2_t *)v242.f32, 1);
            v248 = vaddq_f32(vmulq_laneq_f32(v246[3], v247, 3), vaddq_f32(vmulq_laneq_f32(v246[2], v247, 2), vaddq_f32(vmulq_lane_f32(v246[1], *(float32x2_t *)v247.f32, 1), vaddq_f32(vmulq_n_f32(*v246, v247.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v184.i32[3] + 48), v245, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v184.i32[3] + 32), v245, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)(v87 + v184.i32[3] + 16), *(float32x2_t *)v245.f32, 1), vmulq_n_f32(*(float32x4_t *)(v87 + v184.i32[3]), v245.f32[0]))))))));
            v249 = (float32x4_t *)(v87 + v133 + v243);
            v250 = vmulq_laneq_f32(v241, v242, 2);
            v251 = vmulq_laneq_f32(v241, v242, 3);
            v175 = vaddq_f32(v175, _Q17);
            v105[3] = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v134 + v243 + 48), v251, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v134 + v243 + 32), v251, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)(v87 + v134 + v243 + 16), *(float32x2_t *)v251.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)(v87 + v134 + v243), v251.f32[0]), vaddq_f32(vmulq_laneq_f32(v249[3], v250, 3), vaddq_f32(vmulq_laneq_f32(v249[2], v250, 2), vaddq_f32(vmulq_lane_f32(v249[1], *(float32x2_t *)v250.f32, 1), vaddq_f32(vmulq_n_f32(*v249, v250.f32[0]), v248))))))));
            v105 += 4;
            v176 = v244 - 4;
          }
          while (v244 > 7);
          v252 = v14;
          if (v244 == 4)
            goto LABEL_86;
        }
        v253 = vaddq_f32(v173, vmulq_n_f32(v175, v171.f32[0]));
        v254 = vaddq_f32(v174, vmulq_lane_f32(v175, v171, 1));
        v255 = vmaxq_f32(vminq_f32(v253, v113), v135);
        v256 = vmaxq_f32(vminq_f32(v254, v123), v135);
        v257 = vcvtq_f32_s32(vcvtq_s32_f32(v255));
        v258 = vcvtq_f32_s32(vcvtq_s32_f32(v256));
        v259 = vshlq_n_s32(vcvtq_s32_f32(vaddq_f32(vmulq_n_f32(v258, v112), v257)), 4uLL);
        v260 = vsubq_f32(v255, v257);
        v261 = vsubq_f32(v256, v258);
        if (v176 != 2)
        {
          if (v176 != 3)
            goto LABEL_85;
          v262 = a1[5];
          v263 = a1[6];
          v264 = vaddq_f32(v262, vmulq_laneq_f32(v263, v260, 2));
          v265 = vaddq_f32(v262, vmulq_laneq_f32(v263, v261, 2));
          v266 = vmulq_laneq_f32(v264, v260, 2);
          v268 = a1[3];
          v267 = a1[4];
          v269 = vaddq_f32(v268, vmulq_laneq_f32(vaddq_f32(v267, v266), v260, 2));
          v270 = vaddq_f32(v268, vmulq_laneq_f32(vaddq_f32(v267, vmulq_laneq_f32(v265, v261, 2)), v261, 2));
          v271 = vmulq_n_f32(v269, v270.f32[0]);
          v272 = (float32x4_t *)(v87 + v132 + v259.i32[2]);
          v273 = vmulq_lane_f32(v269, *(float32x2_t *)v270.f32, 1);
          v274 = vaddq_f32(vmulq_laneq_f32(v272[3], v273, 3), vaddq_f32(vmulq_laneq_f32(v272[2], v273, 2), vaddq_f32(vmulq_lane_f32(v272[1], *(float32x2_t *)v273.f32, 1), vaddq_f32(vmulq_n_f32(*v272, v273.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v259.i32[2] + 48), v271, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v259.i32[2] + 32), v271, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)(v87 + v259.i32[2] + 16), *(float32x2_t *)v271.f32, 1), vmulq_n_f32(*(float32x4_t *)(v87 + v259.i32[2]), v271.f32[0]))))))));
          v275 = vmulq_laneq_f32(v269, v270, 2);
          v276 = (float32x4_t *)(v87 + v134 + v259.i32[2]);
          v277 = vmulq_laneq_f32(v269, v270, 3);
          v105[2] = vaddq_f32(vmulq_laneq_f32(v276[3], v277, 3), vaddq_f32(vmulq_laneq_f32(v276[2], v277, 2), vaddq_f32(vmulq_lane_f32(v276[1], *(float32x2_t *)v277.f32, 1), vaddq_f32(vmulq_n_f32(*v276, v277.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v133 + v259.i32[2] + 48), v275, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v133 + v259.i32[2] + 32), v275, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)(v87 + v133 + v259.i32[2] + 16), *(float32x2_t *)v275.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)(v87 + v133 + v259.i32[2]), v275.f32[0]), v274))))))));
        }
        v139 = a1[5];
        v140 = a1[6];
        v141 = vaddq_f32(v139, vmulq_lane_f32(v140, *(float32x2_t *)v260.f32, 1));
        v142 = vaddq_f32(v139, vmulq_lane_f32(v140, *(float32x2_t *)v261.f32, 1));
        v143 = vmulq_lane_f32(v141, *(float32x2_t *)v260.f32, 1);
        v145 = a1[3];
        v144 = a1[4];
        v146 = vaddq_f32(v145, vmulq_lane_f32(vaddq_f32(v144, v143), *(float32x2_t *)v260.f32, 1));
        v147 = vaddq_f32(v145, vmulq_lane_f32(vaddq_f32(v144, vmulq_lane_f32(v142, *(float32x2_t *)v261.f32, 1)), *(float32x2_t *)v261.f32, 1));
        v148 = vmulq_n_f32(v146, v147.f32[0]);
        v149 = (float32x4_t *)(v87 + v132 + v259.i32[1]);
        v150 = vmulq_lane_f32(v146, *(float32x2_t *)v147.f32, 1);
        v151 = vaddq_f32(vmulq_laneq_f32(v149[3], v150, 3), vaddq_f32(vmulq_laneq_f32(v149[2], v150, 2), vaddq_f32(vmulq_lane_f32(v149[1], *(float32x2_t *)v150.f32, 1), vaddq_f32(vmulq_n_f32(*v149, v150.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v259.i32[1] + 48), v148, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v259.i32[1] + 32), v148, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)(v87 + v259.i32[1] + 16), *(float32x2_t *)v148.f32, 1), vmulq_n_f32(*(float32x4_t *)(v87 + v259.i32[1]), v148.f32[0]))))))));
        v152 = vmulq_laneq_f32(v146, v147, 2);
        v153 = (float32x4_t *)(v87 + v134 + v259.i32[1]);
        v154 = vmulq_laneq_f32(v146, v147, 3);
        v105[1] = vaddq_f32(vmulq_laneq_f32(v153[3], v154, 3), vaddq_f32(vmulq_laneq_f32(v153[2], v154, 2), vaddq_f32(vmulq_lane_f32(v153[1], *(float32x2_t *)v154.f32, 1), vaddq_f32(vmulq_n_f32(*v153, v154.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v133 + v259.i32[1] + 48), v152, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v133 + v259.i32[1] + 32), v152, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)(v87 + v133 + v259.i32[1] + 16), *(float32x2_t *)v152.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)(v87 + v133 + v259.i32[1]), v152.f32[0]), v151))))))));
LABEL_85:
        v155 = a1[5];
        v156 = a1[6];
        v157 = vaddq_f32(v155, vmulq_n_f32(v156, v260.f32[0]));
        v158 = vaddq_f32(v155, vmulq_n_f32(v156, v261.f32[0]));
        v159 = vmulq_n_f32(v157, v260.f32[0]);
        v161 = a1[3];
        v160 = a1[4];
        v162 = vaddq_f32(v161, vmulq_n_f32(vaddq_f32(v160, v159), v260.f32[0]));
        v163 = vaddq_f32(v161, vmulq_n_f32(vaddq_f32(v160, vmulq_n_f32(v158, v261.f32[0])), v261.f32[0]));
        v164 = v259.i32[0];
        v165 = vmulq_n_f32(v162, v163.f32[0]);
        v166 = (float32x4_t *)(v87 + v132 + v259.i32[0]);
        v167 = vmulq_lane_f32(v162, *(float32x2_t *)v163.f32, 1);
        v168 = vaddq_f32(vmulq_laneq_f32(v166[3], v167, 3), vaddq_f32(vmulq_laneq_f32(v166[2], v167, 2), vaddq_f32(vmulq_lane_f32(v166[1], *(float32x2_t *)v167.f32, 1), vaddq_f32(vmulq_n_f32(*v166, v167.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v259.i32[0] + 48), v165, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v259.i32[0] + 32), v165, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)(v87 + v259.i32[0] + 16), *(float32x2_t *)v165.f32, 1), vmulq_n_f32(*(float32x4_t *)(v87 + v259.i32[0]), v165.f32[0]))))))));
        v169 = vmulq_laneq_f32(v162, v163, 2);
        v170 = vmulq_laneq_f32(v162, v163, 3);
        *v105 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v134 + v164 + 48), v170, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v134 + v164 + 32), v170, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)(v87 + v134 + v164 + 16), *(float32x2_t *)v170.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)(v87 + v134 + v164), v170.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v133 + v164 + 48), v169, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v87 + v133 + v164 + 32), v169, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)(v87 + v133 + v164 + 16), *(float32x2_t *)v169.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)(v87 + v133 + v164), v169.f32[0]), v168))))))));
        v105 += v176;
LABEL_86:
        v138 = vaddq_f32(v138, _Q7);
        v105 += (int)a7;
        LODWORD(v307) = v307 + 1;
      }
      while ((_DWORD)v307 != v252);
    }
  }
  else
  {
    v278 = ((int)a6 + (int)a5) >> 1;
    v310 = 0;
    v308 = 0u;
    v309 = 0u;
    HGExecutionUnit::GetStackState(a1[1].i64[0], (uint64_t)&v308);
    v279 = HGRectMake4i(a5, v307, v278, v14);
    HGSampler::GetTile(a1, v304, a3, a4, v279, v280, (a6 + a7 - v278));
    HGExecutionUnit::CommitStack(a1[1].i64[0], (uint64_t)a4, (v92 + (int)a7) * v293);
    v281 = HGRectMake4i(v278, v307, a6, v14);
    HGSampler::GetTile(a1, v304, a3, &a4[v278 - (int)a5], v281, v282, (a7 - a5 + v278));
    v283 = a1[1].i64[0];
    v316[0] = v308;
    v316[1] = v309;
    v317 = v310;
    HGExecutionUnit::SetStackState(v283, v316);
  }
}

uint64_t HGSampler::ReadTile(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
}

uint64_t HGSampler::ReadTileIndirect(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, unint64_t a5, unint64_t a6)
{
  float32x4_t *v6;
  unint64_t v8;
  unint64_t v9;
  int32x4_t v10;
  float32x4_t v11;
  int32x2_t v12;
  int32x4_t v13;
  int32x4_t v14;
  float32x4_t *v15;
  int32x4_t v16;
  int32x4_t v17;
  unint64_t v18;
  int32x4_t v19;
  int v20;
  float32x4_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  __int32 v26;
  __int32 v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  unint64_t v34;
  uint64_t result;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;

  v6 = a4;
  v8 = HIDWORD(a5);
  v9 = HIDWORD(a6);
  v10 = (int32x4_t)a5;
  v10.i32[1] = HIDWORD(a5);
  v11 = vcvtq_f32_s32(vcvtq_s32_f32(*a4));
  v12 = (int32x2_t)vaddq_s32(vcvtq_s32_f32(vaddq_f32(v11, vcvtq_f32_s32(vcgtq_f32(v11, *a4)))), v10).u64[0];
  v13 = vdupq_lane_s32(v12, 0);
  v14 = vdupq_lane_s32(v12, 1);
  if (SHIDWORD(a5) >= SHIDWORD(a6) || (_DWORD)a6 == (_DWORD)a5)
  {
    v17.i32[0] = v14.i32[0];
    v16.i32[0] = v13.i32[0];
  }
  else
  {
    v15 = a4;
    v16 = v13;
    v17 = v14;
    v18 = HIDWORD(a5);
    do
    {
      v19 = (int32x4_t)a5;
      v19.i32[1] = v18;
      v20 = a5 - a6;
      do
      {
        v21 = vcvtq_f32_s32(vcvtq_s32_f32(*v15));
        v22 = vaddq_s32(vcvtq_s32_f32(vaddq_f32(v21, vcvtq_f32_s32(vcgtq_f32(v21, *v15)))), v19);
        v23 = vdupq_lane_s32(*(int32x2_t *)v22.i8, 0);
        v13 = vminq_s32(v13, v23);
        v16 = vmaxq_s32(v16, v23);
        v24 = vdupq_lane_s32(*(int32x2_t *)v22.i8, 1);
        v14 = vminq_s32(v14, v24);
        v17 = vmaxq_s32(v17, v24);
        v19 = vaddq_s32(v19, (int32x4_t)xmmword_1B3056A60);
        *v15++ = (float32x4_t)v22;
      }
      while (!__CFADD__(v20++, 1));
      LODWORD(v18) = v18 + 1;
    }
    while ((_DWORD)v18 != HIDWORD(a6));
  }
  v40 = a5;
  v41 = a6;
  v26 = v13.i32[0];
  v27 = v14.i32[0];
  v28 = (v16.i32[0] + 1);
  v29 = (v17.i32[0] + 1);
  v30 = v13.u32[0] | ((unint64_t)v14.u32[0] << 32);
  v31 = v28 | (v29 << 32);
  v32 = v28 - v13.i32[0];
  v33 = (v28 - v13.i32[0]) * (v29 - v14.i32[0]);
  v34 = *(_QWORD *)(a1 + 24);
  if (v33 > *(_DWORD *)(a1 + 32))
  {
    v38 = a2;
    v39 = a3;
    if (v34)
      HGFree(v34);
    v34 = HGMalloc(16 * v33);
    *(_QWORD *)(a1 + 24) = v34;
    *(_DWORD *)(a1 + 32) = v33;
    a2 = v38;
    a3 = v39;
  }
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t, unint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, a2, a3, v34, v30, v31, 0);
  if (v41 > v40 && (int)v8 < (int)v9)
  {
    v36 = *(_QWORD *)(a1 + 24);
    do
    {
      v37 = v41 - v40;
      do
      {
        *v6 = *(float32x4_t *)(v36 + 16 * (v6->i32[0] - v26 + (v6->i32[1] - v27) * v32));
        ++v6;
        --v37;
      }
      while (v37);
      LODWORD(v8) = v8 + 1;
    }
    while ((_DWORD)v8 != (_DWORD)v9);
  }
  return result;
}

HGNode *HGRenderCinema::HGRenderCinema(HGNode *a1, int a2)
{
  const char *v4;
  char *v5;
  uint64_t v6;
  HGCinematic **v7;
  HGCinematic *v8;
  HGCinematic *v9;
  HGCinematic *v10;
  HGCinematic *v11;

  HGNode::HGNode(a1);
  *(_QWORD *)v6 = off_1E6526070;
  v7 = (HGCinematic **)(v6 + 408);
  *(_QWORD *)(v6 + 408) = 0;
  *(_QWORD *)(v6 + 416) = 0;
  *(_DWORD *)(v6 + 424) = a2;
  *(_BYTE *)(v6 + 428) = 0;
  *(_DWORD *)(v6 + 432) = 100;
  switch(a2)
  {
    case 0:
      v8 = (HGCinematic *)HGObject::operator new(0x1E0uLL);
      HGCinematic::HGCinematic(v8);
      v9 = *v7;
      if (*v7 != v8)
      {
        if (!v9)
          goto LABEL_32;
        goto LABEL_31;
      }
      if (!v8)
        return a1;
      goto LABEL_19;
    case 1:
      v8 = (HGCinematic *)HGObject::operator new(0x1A0uLL);
      HgcCinematicDepthFX_Fog::HgcCinematicDepthFX_Fog(v8);
      v9 = *v7;
      if (*v7 != v8)
      {
        if (!v9)
          goto LABEL_32;
        goto LABEL_31;
      }
      if (!v8)
        return a1;
      goto LABEL_19;
    case 2:
      v8 = (HGCinematic *)HGObject::operator new(0x1A0uLL);
      HgcCinematicDepthFX_ColorPop::HgcCinematicDepthFX_ColorPop(v8);
      v9 = *v7;
      if (*v7 != v8)
      {
        if (!v9)
          goto LABEL_32;
        goto LABEL_31;
      }
      if (!v8)
        return a1;
      goto LABEL_19;
    case 3:
      v8 = (HGCinematic *)HGObject::operator new(0x1A0uLL);
      HgcCinematicDepthFX_FadeOut::HgcCinematicDepthFX_FadeOut(v8);
      v9 = *v7;
      if (*v7 != v8)
      {
        if (!v9)
          goto LABEL_32;
        goto LABEL_31;
      }
      if (!v8)
        return a1;
      goto LABEL_19;
    case 4:
      v10 = (HGCinematic *)HGObject::operator new(0x1E0uLL);
      HGCinematic::HGCinematic(v10);
      HGCinematic::setRenderDisparity((uint64_t)v10);
      v11 = *v7;
      if (*v7 == v10)
      {
        if (v10)
          (*(void (**)(HGCinematic *))(*(_QWORD *)v10 + 24))(v10);
      }
      else
      {
        if (v11)
          (*(void (**)(HGCinematic *))(*(_QWORD *)v11 + 24))(v11);
        *v7 = v10;
      }
      goto LABEL_29;
    default:
LABEL_29:
      HGLogger::error((HGLogger *)"HGRenderCinema : Render FX Type not specified in initialization of node.", v4, v5);
      v8 = (HGCinematic *)HGObject::operator new(0x1E0uLL);
      HGCinematic::HGCinematic(v8);
      v9 = *v7;
      if (*v7 == v8)
      {
        if (v8)
LABEL_19:
          (*(void (**)(HGCinematic *))(*(_QWORD *)v8 + 24))(v8);
        return a1;
      }
      else
      {
        if (v9)
LABEL_31:
          (*(void (**)(HGCinematic *))(*(_QWORD *)v9 + 24))(v9);
LABEL_32:
        *v7 = v8;
        return a1;
      }
  }
}

void sub_1B2A83ED4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v5;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v5 = *(_QWORD *)(v1 + 416);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  if (*v3)
    (*(void (**)(_QWORD))(*(_QWORD *)*v3 + 24))(*v3);
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

uint64_t HGRenderCinema::SetFXParameter(uint64_t result, const char *a2, char *a3, __n128 a4)
{
  float v4;
  const void *v5;
  void *v6;
  const void *v7;
  void *v8;
  char *v9;

  v4 = a4.n128_f32[0];
  switch((int)a2)
  {
    case 0:
      v5 = *(const void **)(result + 408);
      if (!v5
      {
        v9 = "HGRenderCinema : Aperture not set.";
        goto LABEL_14;
      }
      result = HGCinematic::setAperture((uint64_t)v6, v4);
      break;
    case 1:
      v7 = *(const void **)(result + 408);
      if (v7
      {
        result = HGCinematic::setFocusDistance((uint64_t)v8, v4);
      }
      else
      {
        v9 = "HGRenderCinema : Focus distance not set.";
LABEL_14:
        result = (uint64_t)HGLogger::warning((HGLogger *)v9, a2, a3);
      }
      break;
    case 2:
      if ((*(_DWORD *)(result + 424) | 2) == 3)
        goto LABEL_10;
      break;
    case 3:
      if (*(_DWORD *)(result + 424) == 2)
LABEL_10:
        result = (*(uint64_t (**)(_QWORD, _QWORD, __n128, float, float, float))(**(_QWORD **)(result + 408)
                                                                                        + 96))(*(_QWORD *)(result + 408), 0, a4, 0.0, 0.0, 0.0);
      break;
    default:
      result = (uint64_t)HGLogger::error((HGLogger *)"HGRenderCinema : Valid FX Parameter type not provided while setting parameter value.", a2, a3);
      break;
  }
  return result;
}

const char *HGRenderCinema::SetRenderQuality(HGRenderCinema *this, const char *a2, char *a3)
{
  const void *v3;
  int v4;
  void *v5;

  v3 = (const void *)*((_QWORD *)this + 51);
  if (v3
    && (v4 = (int)a2,
  {
    return (const char *)HGCinematic::SetRenderQuality((uint64_t)v5, v4);
  }
  else
  {
    return HGLogger::warning((HGLogger *)"HGRenderCinema : Render quality not set.", a2, a3);
  }
}

void HGRenderCinema::SetTransferFunction(uint64_t a1, uint64_t a2, char *a3)
{
  const void *v3;
  std::string *v5;
  std::string *v6;
  std::string __p;

  v3 = *(const void **)(a1 + 408);
  if (v3
  {
    v6 = v5;
    if (*(char *)(a2 + 23) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
    else
      __p = *(std::string *)a2;
    std::string::operator=(v6 + 18, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    HGLogger::warning((HGLogger *)"HGRenderCinema : Transfer function not set.", (const char *)a2, a3);
  }
}

void sub_1B2A84258(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

const char *HGRenderCinema::SetDisplayMode(HGRenderCinema *this, const char *a2, char *a3)
{
  const void *v3;
  int v4;
  void *v5;

  v3 = (const void *)*((_QWORD *)this + 51);
  if (v3
    && (v4 = (int)a2,
  {
    return (const char *)HGCinematic::setDisplayMode((uint64_t)v5, v4);
  }
  else
  {
    return HGLogger::warning((HGLogger *)"HGRenderCinema : Display mode not set.", a2, a3);
  }
}

uint64_t HGRenderCinema::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t v4;
  HGNode *Input;
  uint64_t v6;
  HGNode *v7;
  HGCinematic *v9;
  HGNode *v10;
  HGNode *v11;

  v4 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v4 + 120))(v4, 0, Input);
  if ((*((_DWORD *)this + 106) | 4) == 4)
  {
    v6 = *((_QWORD *)this + 51);
    v7 = HGRenderer::GetInput(a2, this, 1u);
    (*(void (**)(uint64_t, uint64_t, HGNode *))(*(_QWORD *)v6 + 120))(v6, 1, v7);
  }
  else
  {
    v9 = (HGCinematic *)HGObject::operator new(0x1E0uLL);
    HGCinematic::HGCinematic(v9);
    v10 = HGRenderer::GetInput(a2, this, 0);
    (*(void (**)(HGCinematic *, _QWORD, HGNode *))(*(_QWORD *)v9 + 120))(v9, 0, v10);
    v11 = HGRenderer::GetInput(a2, this, 1u);
    (*(void (**)(HGCinematic *, uint64_t, HGNode *))(*(_QWORD *)v9 + 120))(v9, 1, v11);
    HGCinematic::setRenderDisparity((uint64_t)v9);
    (*(void (**)(_QWORD, uint64_t, HGCinematic *))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 1, v9);
  }
  return *((_QWORD *)this + 51);
}

void sub_1B2A843F4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGRenderCinema::SetSingleChannelDepthConversion(uint64_t this)
{
  *(_BYTE *)(this + 428) = 1;
  return this;
}

PTGlobalRenderingMetadata *HGRenderCinema::SetGlobalRenderingMetadata(HGRenderCinema *this, PTGlobalRenderingMetadata *a2, char *a3)
{
  const void *v3;
  PTGlobalRenderingMetadata *v5;

  v3 = (const void *)*((_QWORD *)this + 51);
  if (v3
  {
    return HGCinematic::SetGlobalRenderingMetadata(v5, a2);
  }
  else
  {
    return (PTGlobalRenderingMetadata *)HGLogger::warning((HGLogger *)"HGRenderCinema : GlobalRenderingMetadata not set", (const char *)a2, a3);
  }
}

const char *HGRenderCinema::SetTimedRenderingMetadata(uint64_t a1, void *a2, char *a3)
{
  const void *v3;
  _QWORD *v5;

  v3 = *(const void **)(a1 + 408);
  if (v3
  {
    return (const char *)HGCinematic::SetTimedRenderingMetadata(v5, a2);
  }
  else
  {
    return HGLogger::warning((HGLogger *)"HGRenderCinema : TimedRenderingMetadata not set", (const char *)a2, a3);
  }
}

void HGRenderCinema::~HGRenderCinema(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E6526070;
  v2 = *((_QWORD *)this + 52);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 51);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_1E6526070;
  v2 = *((_QWORD *)this + 52);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 51);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
  HGObject::operator delete(v4);
}

HGPool **HGMetalTexturePool::HGMetalTexturePool(HGPool **a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  HGPool::BasePool *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;

  v4 = (std::__shared_weak_count *)operator new(0x28uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_1E65262D8;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E6526328;
  v6 = v4 + 1;
  v4[1].__shared_owners_ = a2;
  v7 = operator new();
  v8 = v7;
  do
    v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  HGPool::BasePool::BasePool(v7);
  *(_QWORD *)v8 = &off_1E6526380;
  *(_QWORD *)(v8 + 16) = v6;
  *(_QWORD *)(v8 + 24) = v4;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  *(_QWORD *)(v8 + 32) = 0;
  *(_QWORD *)(v8 + 40) = 0;
  *(_QWORD *)(v8 + 48) = v6;
  *(_QWORD *)(v8 + 56) = v4;
  do
    v12 = __ldxr(p_shared_owners);
  while (__stxr(v12 + 1, p_shared_owners));
  *(_OWORD *)(v8 + 112) = 0u;
  *(_OWORD *)(v8 + 128) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_QWORD *)(v8 + 152) = v6;
  *(_QWORD *)(v8 + 160) = v4;
  do
    v13 = __ldxr(p_shared_owners);
  while (__stxr(v13 + 1, p_shared_owners));
  *(_OWORD *)(v8 + 232) = 0u;
  *(_OWORD *)(v8 + 216) = 0u;
  *(_OWORD *)(v8 + 200) = 0u;
  *(_OWORD *)(v8 + 184) = 0u;
  *(_OWORD *)(v8 + 168) = 0u;
  *(_OWORD *)(v8 + 264) = 0u;
  *(_OWORD *)(v8 + 280) = 0u;
  *(_OWORD *)(v8 + 296) = 0u;
  *(_BYTE *)(v8 + 343) = 14;
  *(_QWORD *)(v8 + 312) = 0;
  strcpy((char *)(v8 + 320), "(unnamed) pool");
  *(_BYTE *)(v8 + 367) = 6;
  strcpy((char *)(v8 + 344), "hgpool");
  *(_DWORD *)(v8 + 368) = 0;
  *(_WORD *)(v8 + 372) = 257;
  *(_BYTE *)(v8 + 374) = 1;
  *(_WORD *)(v8 + 8) = 34;
  v14 = *(unsigned __int16 *)(v8 + 10) | 0x220000;
  *(_QWORD *)(v8 + 144) = v14;
  *(_QWORD *)(v8 + 248) = v14;
  *(_QWORD *)(v8 + 256) = 850045863;
  *a1 = (HGPool *)v8;
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  HGPool::registerPool(*a1, v10);
  if (v4)
  {
    v16 = (unint64_t *)&v4->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

void sub_1B2A847A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v11;

  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  MEMORY[0x1B5E29170](v11, 0x10B3C40C3EE8A59);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1B2A847DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGMetalTexturePool::newTexture(uint64_t *a1, __int128 *a2, char a3)
{
  return HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::newObjectWithRecovery(*a1, a2, a3 ^ 1u);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::newObjectWithRecovery(uint64_t a1, __int128 *a2, char a3)
{
  uint64_t result;
  const char *v7;
  char *v8;
  unsigned __int8 v9;
  HGLogger *v10;

  result = HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::newObject(a1, a2, a3);
  if (!result)
  {
    while (1)
    {
      std::mutex::lock((std::mutex *)(a1 + 256));
      if (!*(_QWORD *)(a1 + 224))
        break;
      HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_pop_front((int64x2_t *)(a1 + 152));
      std::mutex::unlock((std::mutex *)(a1 + 256));
      result = HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::newObject(a1, a2, a3);
      if (result)
        return result;
    }
    std::mutex::unlock((std::mutex *)(a1 + 256));
    v9 = atomic_load(HGLogger::_enabled);
    if ((v9 & 1) != 0)
    {
      v10 = (HGLogger *)(a1 + 344);
      if (*(char *)(a1 + 367) < 0)
        v10 = *(HGLogger **)v10;
      HGLogger::log(v10, (const char *)1, (HGLogger *)"HGPool::newObjectWithRecovery() - Failed to recycle or allocate object! Oops.", v7, v8);
    }
    return 0;
  }
  return result;
}

void HGMetalTexturePool::releaseTexture(uint64_t *a1, uint64_t a2)
{
  HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::releaseObject(*a1, a2);
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::releaseObject(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  unint64_t *v12;
  unint64_t v13;
  __int128 v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  const char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  unint64_t *v30;
  unint64_t v31;
  __int128 v32;
  unsigned int v33;
  unint64_t *v34;
  unint64_t v35;
  char *v36;
  std::mutex *v37;
  _OWORD v38[5];
  char v39;
  __int128 v40;
  __int128 v41;
  HGMetalUtils *v42[2];
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  uint64_t v46[3];

  v46[0] = a2;
  v37 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,true>::retrieveObject((int64x2_t *)(a1 + 48), v46, (uint64_t)&v40);
  if ((_QWORD)v40)
  {
    LOBYTE(v45) = 0;
    *(std::chrono::steady_clock::time_point *)&v44 = std::chrono::steady_clock::now();
    HGMetalUtils::bytesPerPixel(v42[0]);
    kdebug_trace();
    v3 = *(_QWORD *)(a1 + 200);
    v4 = *(_QWORD *)(a1 + 192);
    v5 = 46 * ((v3 - v4) >> 3) - 1;
    if (v3 == v4)
      v5 = 0;
    v6 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
    if (v5 == v6)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::__add_back_capacity(a1 + 184);
      v4 = *(_QWORD *)(a1 + 192);
      v6 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
    }
    v7 = *(_QWORD *)(v4 + 8 * (v6 / 0x2E)) + 88 * (v6 % 0x2E);
    v8 = v41;
    *(_OWORD *)v7 = v40;
    *(_OWORD *)(v7 + 16) = v8;
    v9 = *(_OWORD *)v42;
    v10 = v43;
    v11 = v44;
    *(_QWORD *)(v7 + 80) = v45;
    *(_OWORD *)(v7 + 48) = v10;
    *(_OWORD *)(v7 + 64) = v11;
    *(_OWORD *)(v7 + 32) = v9;
    ++*(_QWORD *)(a1 + 224);
    v12 = (unint64_t *)(a1 + 232);
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 + 1, v12));
    v14 = v41;
    v15 = *((_QWORD *)&v14 + 1) * v14 * HGMetalUtils::bytesPerPixel(v42[0]);
    v16 = (unint64_t *)(a1 + 240);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 + v15, v16));
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::service((int64x2_t *)(a1 + 152), a1);
  }
  else
  {
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), v46, (uint64_t)v38);
    v43 = v38[3];
    v44 = v38[4];
    LOBYTE(v45) = v39;
    v40 = v38[0];
    v41 = v38[1];
    *(_OWORD *)v42 = v38[2];
    v20 = *(_QWORD *)&v38[0];
    if (*(_QWORD *)&v38[0])
    {
      v21 = *(_QWORD *)(a1 + 200);
      v22 = *(_QWORD *)(a1 + 192);
      v23 = 46 * ((v21 - v22) >> 3) - 1;
      if (v21 == v22)
        v23 = 0;
      v24 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
      if (v23 == v24)
      {
        std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::__add_back_capacity(a1 + 184);
        v22 = *(_QWORD *)(a1 + 192);
        v24 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
      }
      v25 = *(_QWORD *)(v22 + 8 * (v24 / 0x2E)) + 88 * (v24 % 0x2E);
      v26 = v41;
      *(_OWORD *)v25 = v40;
      *(_OWORD *)(v25 + 16) = v26;
      v27 = *(_OWORD *)v42;
      v28 = v43;
      v29 = v44;
      *(_QWORD *)(v25 + 80) = v45;
      *(_OWORD *)(v25 + 48) = v28;
      *(_OWORD *)(v25 + 64) = v29;
      *(_OWORD *)(v25 + 32) = v27;
      ++*(_QWORD *)(a1 + 224);
      v30 = (unint64_t *)(a1 + 232);
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 + 1, v30));
      v32 = v41;
      v33 = HGMetalUtils::bytesPerPixel(v42[0]);
      v34 = (unint64_t *)(a1 + 240);
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 + *((_QWORD *)&v32 + 1) * v32 * v33, v34));
      v36 = "HGPool::releaseObject() - Attempting to double-release a free object: <%p>";
      v20 = v40;
    }
    else
    {
      v36 = "HGPool::releaseObject() - Attempting to release an unmanaged object: <%p>";
    }
    HGLogger::warning((HGLogger *)v36, v18, v19, v20);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  kdebug_trace();
  std::mutex::unlock(v37);
}

void sub_1B2A84C78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11)
{
  std::mutex::unlock(a11);
  _Unwind_Resume(a1);
}

void sub_1B2A84C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11)
{
  std::mutex::unlock(a11);
  _Unwind_Resume(a1);
}

void HGMetalTexturePool::clear(HGMetalTexturePool *this)
{
  HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::clear((uint64_t)this->var0);
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::clear(uint64_t a1)
{
  std::mutex *v2;
  uint64_t v3;

  v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (*(_QWORD *)(a1 + 224))
  {
    v3 = 0;
    do
    {
      HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_pop_front((int64x2_t *)(a1 + 152));
      --v3;
    }
    while (*(_QWORD *)(a1 + 224));
    if (v3)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
      kdebug_trace();
    }
  }
  std::mutex::unlock(v2);
}

void sub_1B2A84D7C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A84D90(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

HGPool **HGMetalTextureWrapperInfinipool::HGMetalTextureWrapperInfinipool(HGPool **a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  HGMetalDeviceInfo *DeviceInfo;
  int v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  HGPool::BasePool *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v32;

  v4 = (std::__shared_weak_count *)operator new(0x28uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6526598;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E65265E8;
  v6 = v4 + 1;
  v4[1].__shared_owners_ = a2;
  v32 = v4;
  v7 = operator new();
  v8 = v7;
  do
    v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  HGPool::BasePool::BasePool(v7);
  *(_QWORD *)v8 = &off_1E6526640;
  *(_QWORD *)(v8 + 16) = v6;
  *(_QWORD *)(v8 + 24) = v4;
  do
    v10 = __ldxr(p_shared_owners);
  while (__stxr(v10 + 1, p_shared_owners));
  *(_QWORD *)(v8 + 32) = 0;
  *(_QWORD *)(v8 + 40) = 0;
  *(_QWORD *)(v8 + 48) = v6;
  *(_QWORD *)(v8 + 56) = v4;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  *(_OWORD *)(v8 + 112) = 0u;
  *(_OWORD *)(v8 + 128) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_QWORD *)(v8 + 152) = v6;
  *(_QWORD *)(v8 + 160) = v4;
  do
    v12 = __ldxr(p_shared_owners);
  while (__stxr(v12 + 1, p_shared_owners));
  *(_OWORD *)(v8 + 232) = 0u;
  *(_OWORD *)(v8 + 216) = 0u;
  *(_OWORD *)(v8 + 200) = 0u;
  *(_OWORD *)(v8 + 184) = 0u;
  *(_OWORD *)(v8 + 168) = 0u;
  *(_OWORD *)(v8 + 264) = 0u;
  *(_OWORD *)(v8 + 280) = 0u;
  *(_OWORD *)(v8 + 296) = 0u;
  *(_BYTE *)(v8 + 343) = 14;
  *(_QWORD *)(v8 + 312) = 0;
  strcpy((char *)(v8 + 320), "(unnamed) pool");
  *(_BYTE *)(v8 + 367) = 6;
  strcpy((char *)(v8 + 344), "hgpool");
  *(_DWORD *)(v8 + 368) = 0;
  *(_WORD *)(v8 + 372) = 257;
  *(_BYTE *)(v8 + 374) = 1;
  *(_WORD *)(v8 + 8) = 50;
  v13 = *(unsigned __int16 *)(v8 + 10) | 0x320000;
  *(_QWORD *)(v8 + 144) = v13;
  *(_QWORD *)(v8 + 248) = v13;
  *(_QWORD *)(v8 + 256) = 850045863;
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  *a1 = (HGPool *)v8;
  DeviceInfo = (HGMetalDeviceInfo *)HGMetalDeviceInfo::getDeviceInfo(a2);
  if (DeviceInfo)
  {
    if (HGMetalDeviceInfo::isIntel(DeviceInfo))
      v16 = 2;
    else
      v16 = 1;
  }
  else
  {
    v16 = 1;
  }
  *(_DWORD *)(v8 + 368) = v16;
  v17 = (std::__shared_weak_count *)operator new(0x20uLL);
  v17->__shared_owners_ = 0;
  v18 = (unint64_t *)&v17->__shared_owners_;
  v17->__shared_weak_owners_ = 0;
  v17->__vftable = (std::__shared_weak_count_vtbl *)&off_1E65266C8;
  v17[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E6526718;
  do
    v19 = __ldxr(v18);
  while (__stxr(v19 + 1, v18));
  std::mutex::lock((std::mutex *)(v8 + 256));
  do
    v20 = __ldxr(v18);
  while (__stxr(v20 + 1, v18));
  v21 = *(std::__shared_weak_count **)(v8 + 176);
  *(_QWORD *)(v8 + 168) = v17 + 1;
  *(_QWORD *)(v8 + 176) = v17;
  if (v21)
  {
    v22 = (unint64_t *)&v21->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  std::mutex::unlock((std::mutex *)(v8 + 256));
  if (v17)
  {
    v25 = (unint64_t *)&v17->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  HGPool::registerPool(*a1, v24);
  if (v17)
  {
    v27 = (unint64_t *)&v17->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  if (v32)
  {
    v29 = (unint64_t *)&v32->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  return a1;
}

void sub_1B2A85108(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B2A8511C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1B2A85148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B2A8515C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B2A85170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  MEMORY[0x1B5E29170](v3, 0x10B3C40C3EE8A59);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1B2A851A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::newObject(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  const char *v8;
  char *v9;
  int v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _OWORD *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  unsigned __int8 v31;
  HGLogger *v32;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  unint64_t v45;

  if ((a3 & 1) != 0 || (v4 = *(_QWORD *)(a1 + 32)) == 0)
  {
    v5 = *(_OWORD *)(a2 + 32);
    v6 = *(_OWORD *)(a2 + 48);
    v7 = *(_OWORD *)a2;
    v42 = *(_OWORD *)(a2 + 16);
    v43 = v5;
    v44 = v6;
    v45 = *(_QWORD *)(a2 + 64);
    v41 = v7;
  }
  else
  {
    (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)v4 + 16))(&v41);
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), &v41, (uint64_t)&v34);
  std::mutex::unlock((std::mutex *)(a1 + 256));
  if ((_QWORD)v34)
  {
    BYTE8(v40) = 1;
    *((std::chrono::steady_clock::time_point *)&v39 + 1) = std::chrono::steady_clock::now();
    *(_QWORD *)&v40 = v40 + 1;
    HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::reused(&v34);
    kdebug_trace();
    v10 = *(_DWORD *)(a1 + 368);
    if (v10 == 1)
    {
      kdebug_trace();
      v14 = v34;
      v15 = (*(uint64_t (**)(_QWORD, __int128 *))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), &v41);
      HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::deleted(&v34);
      *(_QWORD *)&v34 = v15;
      v37 = v43;
      v38 = v44;
      *(_QWORD *)&v39 = v45;
      v35 = v41;
      v36 = v42;
      HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::allocated(&v34);
      kdebug_trace();
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16), v14);
      kdebug_trace();
    }
    else if (v10 == 2)
    {
      kdebug_trace();
      v11 = v34;
      v12 = (*(uint64_t (**)(_QWORD, __int128 *))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), &v41);
      HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::deleted(&v34);
      *(_QWORD *)&v34 = v12;
      *((_QWORD *)&v34 + 1) = v11;
      v37 = v43;
      v38 = v44;
      *(_QWORD *)&v39 = v45;
      v35 = v41;
      v36 = v42;
      HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::allocated(&v34);
      kdebug_trace();
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16), *((_QWORD *)&v11 + 1));
      kdebug_trace();
    }
  }
  else
  {
    kdebug_trace();
    v13 = (*(uint64_t (**)(_QWORD, __int128 *))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), &v41);
    v37 = v43;
    v38 = v44;
    v35 = v41;
    v36 = v42;
    *(_QWORD *)&v40 = 0;
    v39 = v45;
    v34 = (unint64_t)v13;
    BYTE8(v40) = 1;
    *((std::chrono::steady_clock::time_point *)&v39 + 1) = std::chrono::steady_clock::now();
    *(_QWORD *)&v40 = v40 + 1;
    HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::allocated(&v34);
    kdebug_trace();
    kdebug_trace();
  }
  if ((_QWORD)v34)
  {
    std::mutex::lock((std::mutex *)(a1 + 256));
    v16 = *(_QWORD *)(a1 + 96);
    v17 = *(_QWORD *)(a1 + 88);
    v18 = 36 * ((v16 - v17) >> 3) - 1;
    if (v16 == v17)
      v18 = 0;
    v19 = *(_QWORD *)(a1 + 120) + *(_QWORD *)(a1 + 112);
    if (v18 == v19)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::__add_back_capacity(a1 + 80);
      v17 = *(_QWORD *)(a1 + 88);
      v19 = *(_QWORD *)(a1 + 120) + *(_QWORD *)(a1 + 112);
    }
    v20 = (_OWORD *)(*(_QWORD *)(v17 + 8 * (v19 / 0x24)) + 112 * (v19 % 0x24));
    v21 = v34;
    v22 = v36;
    v20[1] = v35;
    v20[2] = v22;
    *v20 = v21;
    v23 = v37;
    v24 = v38;
    v25 = v40;
    v20[5] = v39;
    v20[6] = v25;
    v20[3] = v23;
    v20[4] = v24;
    ++*(_QWORD *)(a1 + 120);
    v26 = (unint64_t *)(a1 + 128);
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 + 1, v26));
    v28 = *((_QWORD *)&v35 + 1);
    v29 = (unint64_t *)(a1 + 136);
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 + v28, v29));
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    kdebug_trace();
    std::mutex::unlock((std::mutex *)(a1 + 256));
  }
  else
  {
    v31 = atomic_load(HGLogger::_enabled);
    if ((v31 & 1) != 0)
    {
      v32 = (HGLogger *)(a1 + 344);
      if (*(char *)(a1 + 367) < 0)
        v32 = *(HGLogger **)v32;
      HGLogger::log(v32, (const char *)1, (HGLogger *)"HGPool::newObject() - Failed to recycle or allocate object! Oops.", v8, v9);
    }
  }
  return v34;
}

void sub_1B2A8570C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  _Unwind_Resume(a1);
}

void sub_1B2A85720(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  _Unwind_Resume(a1);
}

void sub_1B2A85734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  _Unwind_Resume(a1);
}

void sub_1B2A85748(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  _Unwind_Resume(a1);
}

void sub_1B2A8575C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::releaseObject(uint64_t a1, uint64_t a2)
{
  std::mutex *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _OWORD *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  const char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  _OWORD *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  char *v37;
  _OWORD v38[5];
  _OWORD v39[2];
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  _BYTE v45[32];
  uint64_t v46;

  v46 = a2;
  v3 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,true>::retrieveObject((int64x2_t *)(a1 + 48), &v46, (uint64_t)&v40);
  if ((_QWORD)v40)
  {
    v45[24] = 0;
    *(std::chrono::steady_clock::time_point *)&v45[8] = std::chrono::steady_clock::now();
    HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::recycled(&v40);
    kdebug_trace();
    v4 = *(_QWORD *)(a1 + 200);
    v5 = *(_QWORD *)(a1 + 192);
    v6 = 36 * ((v4 - v5) >> 3) - 1;
    if (v4 == v5)
      v6 = 0;
    v7 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
    if (v6 == v7)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::__add_back_capacity(a1 + 184);
      v5 = *(_QWORD *)(a1 + 192);
      v7 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
    }
    v8 = (_OWORD *)(*(_QWORD *)(v5 + 8 * (v7 / 0x24)) + 112 * (v7 % 0x24));
    v9 = v40;
    v10 = v42;
    v8[1] = v41;
    v8[2] = v10;
    *v8 = v9;
    v11 = v43;
    v12 = v44;
    v13 = *(_OWORD *)&v45[16];
    v8[5] = *(_OWORD *)v45;
    v8[6] = v13;
    v8[3] = v11;
    v8[4] = v12;
    ++*(_QWORD *)(a1 + 224);
    v14 = (unint64_t *)(a1 + 232);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 + 1, v14));
    v16 = *((_QWORD *)&v41 + 1);
    v17 = (unint64_t *)(a1 + 240);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 + v16, v17));
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::service((int64x2_t *)(a1 + 152), a1);
  }
  else
  {
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), &v46, (uint64_t)v38);
    v44 = v38[4];
    *(_OWORD *)v45 = v39[0];
    *(_OWORD *)&v45[9] = *(_OWORD *)((char *)v39 + 9);
    v40 = v38[0];
    v41 = v38[1];
    v42 = v38[2];
    v43 = v38[3];
    v21 = *(_QWORD *)&v38[0];
    if (*(_QWORD *)&v38[0])
    {
      v22 = *(_QWORD *)(a1 + 200);
      v23 = *(_QWORD *)(a1 + 192);
      v24 = 36 * ((v22 - v23) >> 3) - 1;
      if (v22 == v23)
        v24 = 0;
      v25 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
      if (v24 == v25)
      {
        std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::__add_back_capacity(a1 + 184);
        v23 = *(_QWORD *)(a1 + 192);
        v25 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
      }
      v26 = (_OWORD *)(*(_QWORD *)(v23 + 8 * (v25 / 0x24)) + 112 * (v25 % 0x24));
      v27 = v40;
      v28 = v42;
      v26[1] = v41;
      v26[2] = v28;
      *v26 = v27;
      v29 = v43;
      v30 = v44;
      v31 = *(_OWORD *)&v45[16];
      v26[5] = *(_OWORD *)v45;
      v26[6] = v31;
      v26[3] = v29;
      v26[4] = v30;
      ++*(_QWORD *)(a1 + 224);
      v32 = (unint64_t *)(a1 + 232);
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 + 1, v32));
      v34 = *((_QWORD *)&v41 + 1);
      v35 = (unint64_t *)(a1 + 240);
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 + v34, v35));
      v37 = "HGPool::releaseObject() - Attempting to double-release a free object: <%p>";
      v21 = v40;
    }
    else
    {
      v37 = "HGPool::releaseObject() - Attempting to release an unmanaged object: <%p>";
    }
    HGLogger::warning((HGLogger *)v37, v19, v20, v21);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  kdebug_trace();
  std::mutex::unlock(v3);
}

void sub_1B2A85A90(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A85AA4(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGMetalTextureWrapperInfinipool::clear(HGMetalTextureWrapperInfinipool *this)
{
  HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::clear(*(_QWORD *)this);
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::clear(uint64_t a1)
{
  std::mutex *v2;
  uint64_t v3;

  v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (*(_QWORD *)(a1 + 224))
  {
    v3 = 0;
    do
    {
      HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::_pop_front((int64x2_t *)(a1 + 152));
      --v3;
    }
    while (*(_QWORD *)(a1 + 224));
    if (v3)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
      kdebug_trace();
    }
  }
  std::mutex::unlock(v2);
}

void sub_1B2A85B94(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A85BA8(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<`anonymous namespace'::TextureAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E65262D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<`anonymous namespace'::TextureAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E65262D8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

uint64_t std::__shared_ptr_emplace<`anonymous namespace'::TextureAllocator>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void `anonymous namespace'::TextureAllocator::~TextureAllocator(_anonymous_namespace_::TextureAllocator *this)
{
  JUMPOUT(0x1B5E29170);
}

uint64_t `anonymous namespace'::TextureAllocator::allocate(uint64_t a1, uint64_t a2)
{
  void *v4;

  v4 = (void *)objc_msgSend(MEMORY[0x1E0CC6BB0], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", *(_QWORD *)(a2 + 16), *(_QWORD *)a2, *(_QWORD *)(a2 + 8), 0);
  objc_msgSend(v4, "setUsage:", *(unsigned int *)(a2 + 24));
  objc_msgSend(v4, "setStorageMode:", *(_QWORD *)(a2 + 32));
  objc_msgSend(v4, "setTextureType:", *(unsigned int *)(a2 + 40));
  objc_msgSend(v4, "setSampleCount:", *(unsigned int *)(a2 + 44));
  return objc_msgSend(*(id *)(a1 + 8), "newTextureWithDescriptor:", v4);
}

void `anonymous namespace'::TextureAllocator::release(uint64_t a1, void *a2)
{

}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::~Pool(a1, a2);
  JUMPOUT(0x1B5E29170);
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::usedObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 128));
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::usedTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 136));
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::freeObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 232));
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::freeTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 240));
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::service(uint64_t a1)
{
  std::mutex *v2;

  v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::service((int64x2_t *)(a1 + 152), a1))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    kdebug_trace();
  }
  std::mutex::unlock(v2);
}

void sub_1B2A85DFC(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::trace(std::mutex *a1)
{
  std::mutex *v2;
  std::mutex *sig;

  v2 = a1 + 4;
  std::mutex::lock(a1 + 4);
  sig = a1 + 5;
  if (a1[5].__m_.__opaque[15] < 0)
    sig = (std::mutex *)sig->__m_.__sig;
  (*(void (**)(std::mutex *, std::mutex *))(a1->__m_.__sig + 24))(a1, sig);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 16))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 40))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 32))(a1);
  std::mutex::unlock(v2);
}

void sub_1B2A86050(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A86064(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A86078(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A8608C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::log(uint64_t a1, const char *a2)
{
  HGLogger *v3;
  const char *v4;
  char *v5;
  unsigned __int8 v6;
  _QWORD *v7;
  const char *v8;
  char *v9;
  unsigned __int8 v10;
  const char *v11;
  char *v12;
  unsigned __int8 v13;

  v3 = (HGLogger *)(a1 + 344);
  if (*(char *)(a1 + 367) < 0)
  {
    v3 = *(HGLogger **)v3;
    if ((int)HGLogger::getLevel(v3, a2) < 2)
      return;
  }
  else if ((int)HGLogger::getLevel((HGLogger *)(a1 + 344), a2) < 2)
  {
    return;
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  v6 = atomic_load(HGLogger::_enabled);
  if ((v6 & 1) != 0)
  {
    v7 = (_QWORD *)(a1 + 320);
    if (*(char *)(a1 + 343) < 0)
      v7 = (_QWORD *)*v7;
    HGLogger::log(v3, (const char *)2, (HGLogger *)"pool '%s' (%p)\n", v4, v5, v7, a1);
  }
  HGLogger::indent(1);
  v10 = atomic_load(HGLogger::_enabled);
  if ((v10 & 1) != 0)
    HGLogger::log(v3, (const char *)2, (HGLogger *)"live objects:\n", v8, v9);
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,true>::log((_QWORD *)(a1 + 48), v3);
  v13 = atomic_load(HGLogger::_enabled);
  if ((v13 & 1) != 0)
    HGLogger::log(v3, (const char *)2, (HGLogger *)"free objects:\n", v11, v12);
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::log((_QWORD *)(a1 + 152), v3);
  HGLogger::indent(0xFFFFFFFFLL);
  std::mutex::unlock((std::mutex *)(a1 + 256));
}

void sub_1B2A861B8(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::canService(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 372);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::canTrace(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 373);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::canLog(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 374);
}

int64x2_t *HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::~List(int64x2_t *a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;

  while (a1[4].i64[1])
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_pop_front(a1);
  std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::~deque[abi:ne180100]((uint64_t)a1[2].i64);
  v2 = (std::__shared_weak_count *)a1[1].i64[1];
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = (std::__shared_weak_count *)a1->i64[1];
  if (!v5)
    return a1;
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (v7)
    return a1;
  ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
  std::__shared_weak_count::__release_weak(v5);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_pop_front(int64x2_t *a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  HGMetalUtils *v7;
  unint64_t *v8;
  unint64_t v9;
  unsigned int v10;
  unint64_t *v11;
  unint64_t v12;
  void **v13;
  int64x2_t v14;

  v2 = (uint64_t *)(*(_QWORD *)(a1[2].i64[1] + 8 * (a1[4].i64[0] / 0x2EuLL)) + 88 * (a1[4].i64[0] % 0x2EuLL));
  v4 = *v2;
  v3 = v2[1];
  v5 = v2[2];
  v6 = v2[3];
  v7 = (HGMetalUtils *)v2[4];
  v8 = (unint64_t *)&a1[5];
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 - 1, v8));
  v10 = HGMetalUtils::bytesPerPixel(v7);
  v11 = &a1[5].u64[1];
  do
    v12 = __ldaxr(v11);
  while (__stlxr(v12 - v6 * v5 * v10, v11));
  v13 = (void **)a1[2].i64[1];
  v14 = vaddq_s64(a1[4], (int64x2_t)xmmword_1B304F0B0);
  a1[4] = v14;
  if (v14.i64[0] >= 0x5CuLL)
  {
    operator delete(*v13);
    a1[2].i64[1] += 8;
    a1[4].i64[0] -= 46;
  }
  HGMetalUtils::bytesPerPixel(v7);
  kdebug_trace();
  kdebug_trace();
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1->i64[0] + 24))(a1->i64[0], v4);
  if (v3)
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1->i64[0] + 24))(a1->i64[0], v3);
  return kdebug_trace();
}

void sub_1B2A86470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::~deque[abi:ne180100](uint64_t a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  *(_QWORD *)(a1 + 40) = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = *(void ***)(a1 + 16);
      v2 = (void **)(*(_QWORD *)(a1 + 8) + 8);
      *(_QWORD *)(a1 + 8) = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 23;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    v6 = 46;
LABEL_7:
    *(_QWORD *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    v9 = *(_QWORD *)(a1 + 8);
    v8 = *(_QWORD *)(a1 + 16);
    if (v8 != v9)
      *(_QWORD *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;

  *(_QWORD *)a1 = &off_1E6526380;
  HGPool::unregisterPool((HGPool *)a1, a2);
  if (*(char *)(a1 + 367) < 0)
  {
    operator delete(*(void **)(a1 + 344));
    if ((*(char *)(a1 + 343) & 0x80000000) == 0)
      goto LABEL_3;
LABEL_24:
    operator delete(*(void **)(a1 + 320));
    goto LABEL_3;
  }
  if (*(char *)(a1 + 343) < 0)
    goto LABEL_24;
LABEL_3:
  std::mutex::~mutex((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::~List((int64x2_t *)(a1 + 152));
  std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::~deque[abi:ne180100](a1 + 80);
  v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  v6 = *(std::__shared_weak_count **)(a1 + 56);
  if (v6)
  {
    v7 = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v9 = *(std::__shared_weak_count **)(a1 + 40);
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v12)
    return a1;
  v13 = (unint64_t *)&v12->__shared_owners_;
  do
    v14 = __ldaxr(v13);
  while (__stlxr(v14 - 1, v13));
  if (v14)
    return a1;
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::service(int64x2_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;

  if (!a1[1].i64[0] || !a1[4].i64[1])
    return 0;
  v4 = 0;
  do
  {
    v5 = atomic_load((unint64_t *)&a1[5]);
    if (v5 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1[1].i64[0] + 16))(a1[1].i64[0], a2))
    {
      v6 = atomic_load(&a1[5].u64[1]);
      if (v6 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1[1].i64[0] + 24))(a1[1].i64[0], a2))
      {
        v7 = a1[4].u64[0];
        v8 = *(_QWORD *)(a1[2].i64[1] + 8 * (v7 / 0x2E));
        v9 = std::chrono::steady_clock::now().__d_.__rep_ - *(_QWORD *)(v8 + 88 * (v7 % 0x2E) + 64);
        if (v9 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1[1].i64[0] + 32))(a1[1].i64[0], a2))
          break;
      }
    }
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_pop_front(a1);
    ++v4;
  }
  while (a1[4].i64[1]);
  return v4;
}

void HGPool::EntryTrace<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::trace(uint64_t a1)
{
  void *__p;
  char v3;

  HGPool::DescriptorString<HGMetalTexturePool::Descriptor>::str(a1 + 16);
  HGMetalUtils::bytesPerPixel(*(HGMetalUtils **)(a1 + 32));
  if (*(_BYTE *)(a1 + 80))
  {
    if ((v3 & 0x80000000) == 0)
      return;
LABEL_5:
    operator delete(__p);
    return;
  }
  std::chrono::steady_clock::now();
  if (v3 < 0)
    goto LABEL_5;
}

void sub_1B2A868A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t HGPool::DescriptorString<HGMetalTexturePool::Descriptor>::str(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  const char *v5;
  size_t v6;
  uint64_t v7;
  _QWORD v9[13];
  char v10;
  uint64_t v11;

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v9);
  v2 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)" x ", 3);
  v3 = (_QWORD *)std::ostream::operator<<();
  v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)", ", 2);
  v5 = HGMetalUtils::toString(*(HGMetalUtils **)(a1 + 16));
  v6 = strlen(v5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)v5, v6);
  std::stringbuf::str();
  v9[0] = *MEMORY[0x1E0DE4F50];
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)v9 + *(_QWORD *)(v9[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v9[2] = v7;
  v9[3] = MEMORY[0x1E0DE4FB8] + 16;
  if (v10 < 0)
    operator delete((void *)v9[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1B5E290BC](&v11);
}

void sub_1B2A869C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,true>::log(_QWORD *a1, HGLogger *a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  unint64_t v13;
  HGLoggerUtils *v14;
  const char *v15;
  char *v16;
  unsigned __int8 v17;
  void **v18;
  unint64_t v19;
  void *__p[2];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  if (a1[9])
  {
    HGLogger::indent(1);
    v4 = a1[5];
    if (a1[6] != v4)
    {
      v5 = a1[8];
      v6 = (_QWORD *)(v4 + 8 * (v5 / 0x2E));
      v7 = *v6 + 88 * (v5 % 0x2E);
      v8 = *(_QWORD *)(v4 + 8 * ((a1[9] + v5) / 0x2E)) + 88 * ((a1[9] + v5) % 0x2E);
      while (v7 != v8)
      {
        v9 = *(_OWORD *)(v7 + 16);
        *(_OWORD *)__p = *(_OWORD *)v7;
        v21 = v9;
        v10 = *(_OWORD *)(v7 + 32);
        v11 = *(_OWORD *)(v7 + 48);
        v12 = *(_OWORD *)(v7 + 64);
        v25 = *(_QWORD *)(v7 + 80);
        v23 = v11;
        v24 = v12;
        v22 = v10;
        HGPool::EntryLog<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 88;
        if (v7 - *v6 == 4048)
        {
          v13 = v6[1];
          ++v6;
          v7 = v13;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    v14 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v14);
    v17 = atomic_load(HGLogger::_enabled);
    if ((v17 & 1) != 0)
    {
      if ((SBYTE7(v21) & 0x80u) == 0)
        v18 = __p;
      else
        v18 = (void **)__p[0];
      v19 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v15, v16, v18, v19);
    }
    if (SBYTE7(v21) < 0)
      operator delete(__p[0]);
  }
}

void sub_1B2A86B54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::log(_QWORD *a1, HGLogger *a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  unint64_t v13;
  HGLoggerUtils *v14;
  const char *v15;
  char *v16;
  unsigned __int8 v17;
  void **v18;
  unint64_t v19;
  void *__p[2];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  if (a1[9])
  {
    HGLogger::indent(1);
    v4 = a1[5];
    if (a1[6] != v4)
    {
      v5 = a1[8];
      v6 = (_QWORD *)(v4 + 8 * (v5 / 0x2E));
      v7 = *v6 + 88 * (v5 % 0x2E);
      v8 = *(_QWORD *)(v4 + 8 * ((a1[9] + v5) / 0x2E)) + 88 * ((a1[9] + v5) % 0x2E);
      while (v7 != v8)
      {
        v9 = *(_OWORD *)(v7 + 16);
        *(_OWORD *)__p = *(_OWORD *)v7;
        v21 = v9;
        v10 = *(_OWORD *)(v7 + 32);
        v11 = *(_OWORD *)(v7 + 48);
        v12 = *(_OWORD *)(v7 + 64);
        v25 = *(_QWORD *)(v7 + 80);
        v23 = v11;
        v24 = v12;
        v22 = v10;
        HGPool::EntryLog<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 88;
        if (v7 - *v6 == 4048)
        {
          v13 = v6[1];
          ++v6;
          v7 = v13;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    v14 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v14);
    v17 = atomic_load(HGLogger::_enabled);
    if ((v17 & 1) != 0)
    {
      if ((SBYTE7(v21) & 0x80u) == 0)
        v18 = __p;
      else
        v18 = (void **)__p[0];
      v19 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v15, v16, v18, v19);
    }
    if (SBYTE7(v21) < 0)
      operator delete(__p[0]);
  }
}

void sub_1B2A86CF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGPool::EntryLog<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::log(uint64_t *a1, HGLogger *a2, const char *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  const char *v10;
  char *v11;
  unsigned __int8 v12;
  void **v13;
  void **v14;
  std::chrono::steady_clock::time_point v15;
  const char *v16;
  char *v17;
  unsigned __int8 v18;
  void **v19;
  void *p_p;
  void **v21;
  void *__p;
  char v23;
  void *v24[2];
  char v25;
  void *v26[2];
  char v27;

  v6 = *a1;
  v7 = (uint64_t)(a1 + 2);
  v8 = a1[3] * a1[2];
  v9 = HGMetalUtils::bytesPerPixel((HGMetalUtils *)a1[4]);
  HGLoggerUtils::bytesPrettyString((HGLoggerUtils *)(v8 * v9));
  HGPool::DescriptorString<HGMetalTexturePool::Descriptor>::str(v7);
  if (*((_BYTE *)a1 + 80))
  {
    v12 = atomic_load(HGLogger::_enabled);
    if ((v12 & 1) != 0)
    {
      v13 = v26;
      if (v27 < 0)
        v13 = (void **)v26[0];
      v14 = v24;
      if (v25 < 0)
        v14 = (void **)v24[0];
      HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu   %s\n", v10, v11, v6, v13, a1[9], v14);
    }
    goto LABEL_17;
  }
  v15.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  HGLoggerUtils::timePrettyString((HGLoggerUtils *)(v15.__d_.__rep_ - a1[8]));
  v18 = atomic_load(HGLogger::_enabled);
  if ((v18 & 1) != 0)
  {
    v19 = v26;
    if (v27 < 0)
      v19 = (void **)v26[0];
    p_p = &__p;
    if (v23 < 0)
      p_p = __p;
    v21 = v24;
    if (v25 < 0)
      v21 = (void **)v24[0];
    HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu  %10s   %s\n", v16, v17, v6, v19, a1[9], p_p, v21);
  }
  if ((v23 & 0x80000000) == 0)
  {
LABEL_17:
    if ((v25 & 0x80000000) == 0)
      goto LABEL_18;
    goto LABEL_21;
  }
  operator delete(__p);
  if ((v25 & 0x80000000) == 0)
  {
LABEL_18:
    if ((v27 & 0x80000000) == 0)
      return;
LABEL_22:
    operator delete(v26[0]);
    return;
  }
LABEL_21:
  operator delete(v24[0]);
  if (v27 < 0)
    goto LABEL_22;
}

void sub_1B2A86EBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  uint64_t v25;

  if (a19 < 0)
  {
    operator delete(__p);
    if ((a25 & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v25 - 49) & 0x80000000) == 0)
        goto LABEL_4;
      goto LABEL_7;
    }
  }
  else if ((a25 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a20);
  if ((*(char *)(v25 - 49) & 0x80000000) == 0)
LABEL_4:
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(*(void **)(v25 - 72));
  _Unwind_Resume(exception_object);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::newObject(uint64_t a1, __int128 *a2, char a3)
{
  uint64_t v4;
  __int128 v5;
  const char *v6;
  char *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  unsigned __int128 v20;
  unint64_t *v21;
  unint64_t v22;
  __int128 v23;
  unsigned int v24;
  unint64_t *v25;
  unint64_t v26;
  unsigned __int8 v27;
  HGLogger *v28;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  HGMetalUtils *v35[2];
  __int128 v36;
  unsigned __int128 v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;

  if ((a3 & 1) != 0 || (v4 = *(_QWORD *)(a1 + 32)) == 0)
  {
    v5 = a2[1];
    v39 = *a2;
    v40 = v5;
    v41 = a2[2];
  }
  else
  {
    (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)v4 + 16))(&v39);
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), &v39, (uint64_t)&v33);
  std::mutex::unlock((std::mutex *)(a1 + 256));
  if ((_QWORD)v33)
  {
    LOBYTE(v38) = 1;
    v37 = __PAIR128__(*((unint64_t *)&v37 + 1), std::chrono::steady_clock::now().__d_.__rep_)
        + __PAIR128__(1, 0);
    HGMetalUtils::bytesPerPixel(v35[0]);
    kdebug_trace();
    v8 = *(_DWORD *)(a1 + 368);
    if (v8 == 1)
    {
      kdebug_trace();
      v31 = v33;
      v11 = (*(uint64_t (**)(_QWORD, __int128 *))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), &v39);
      HGMetalUtils::bytesPerPixel(v35[0]);
      *(_QWORD *)&v33 = v11;
      *(_OWORD *)v35 = v40;
      v36 = v41;
      v34 = v39;
      HGMetalUtils::bytesPerPixel((HGMetalUtils *)v40);
      kdebug_trace();
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16), v31);
      kdebug_trace();
    }
    else if (v8 == 2)
    {
      kdebug_trace();
      v30 = *((_QWORD *)&v33 + 1);
      v32 = v33;
      v9 = (*(uint64_t (**)(_QWORD, __int128 *))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), &v39);
      HGMetalUtils::bytesPerPixel(v35[0]);
      *(_QWORD *)&v33 = v9;
      *((_QWORD *)&v33 + 1) = v32;
      *(_OWORD *)v35 = v40;
      v36 = v41;
      v34 = v39;
      HGMetalUtils::bytesPerPixel((HGMetalUtils *)v40);
      kdebug_trace();
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16), v30);
      kdebug_trace();
    }
  }
  else
  {
    kdebug_trace();
    v10 = (*(uint64_t (**)(_QWORD, __int128 *))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), &v39);
    v34 = v39;
    *(_OWORD *)v35 = v40;
    v36 = v41;
    v37 = 0uLL;
    v33 = (unint64_t)v10;
    LOBYTE(v38) = 1;
    v37 = __PAIR128__(1, std::chrono::steady_clock::now().__d_.__rep_) + 0;
    HGMetalUtils::bytesPerPixel(v35[0]);
    kdebug_trace();
    kdebug_trace();
  }
  if ((_QWORD)v33)
  {
    std::mutex::lock((std::mutex *)(a1 + 256));
    v12 = *(_QWORD *)(a1 + 96);
    v13 = *(_QWORD *)(a1 + 88);
    v14 = 46 * ((v12 - v13) >> 3) - 1;
    if (v12 == v13)
      v14 = 0;
    v15 = *(_QWORD *)(a1 + 120) + *(_QWORD *)(a1 + 112);
    if (v14 == v15)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::__add_back_capacity(a1 + 80);
      v13 = *(_QWORD *)(a1 + 88);
      v15 = *(_QWORD *)(a1 + 120) + *(_QWORD *)(a1 + 112);
    }
    v16 = *(_QWORD *)(v13 + 8 * (v15 / 0x2E)) + 88 * (v15 % 0x2E);
    v17 = v34;
    *(_OWORD *)v16 = v33;
    *(_OWORD *)(v16 + 16) = v17;
    v18 = *(_OWORD *)v35;
    v19 = v36;
    v20 = v37;
    *(_QWORD *)(v16 + 80) = v38;
    *(_OWORD *)(v16 + 48) = v19;
    *(_OWORD *)(v16 + 64) = v20;
    *(_OWORD *)(v16 + 32) = v18;
    ++*(_QWORD *)(a1 + 120);
    v21 = (unint64_t *)(a1 + 128);
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 + 1, v21));
    v23 = v34;
    v24 = HGMetalUtils::bytesPerPixel(v35[0]);
    v25 = (unint64_t *)(a1 + 136);
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 + *((_QWORD *)&v23 + 1) * v23 * v24, v25));
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    kdebug_trace();
    std::mutex::unlock((std::mutex *)(a1 + 256));
  }
  else
  {
    v27 = atomic_load(HGLogger::_enabled);
    if ((v27 & 1) != 0)
    {
      v28 = (HGLogger *)(a1 + 344);
      if (*(char *)(a1 + 367) < 0)
        v28 = *(HGLogger **)v28;
      HGLogger::log(v28, (const char *)1, (HGLogger *)"HGPool::newObject() - Failed to recycle or allocate object! Oops.", v6, v7);
    }
  }
  return v33;
}

void sub_1B2A875C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, char a14)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a14);
  _Unwind_Resume(a1);
}

void sub_1B2A875DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, char a14)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a14);
  _Unwind_Resume(a1);
}

void sub_1B2A875F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, char a14)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a14);
  _Unwind_Resume(a1);
}

void sub_1B2A87604(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, char a14)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a14);
  _Unwind_Resume(a1);
}

void sub_1B2A87618(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

_QWORD *HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::retrieveObject@<X0>(int64x2_t *a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v6;
  char *v7;
  __int128 v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *result;
  uint64_t v14;
  _BYTE v15[24];
  _BYTE *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _QWORD v20[3];
  _QWORD *v21;
  _BYTE v22[24];
  _BYTE *v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v23 = 0;
  v6 = a2[1];
  v24 = *a2;
  v25 = v6;
  v26 = a2[2];
  v16 = 0;
  v17 = v24;
  v18 = v6;
  v19 = v26;
  v21 = 0;
  v7 = (char *)operator new(0x58uLL);
  *(_QWORD *)v7 = &off_1E6526408;
  *((_QWORD *)v7 + 4) = 0;
  v8 = a2[1];
  *(_OWORD *)(v7 + 40) = *a2;
  *(_OWORD *)(v7 + 56) = v8;
  *(_OWORD *)(v7 + 72) = a2[2];
  v21 = v7;
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_retrieve(a1, v20, a3);
  v9 = v21;
  if (v21 == v20)
  {
    v10 = 4;
    v9 = v20;
  }
  else
  {
    if (!v21)
      goto LABEL_6;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_6:
  v11 = v16;
  if (v16 == v15)
  {
    v12 = 4;
    v11 = v15;
  }
  else
  {
    if (!v16)
      goto LABEL_11;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_11:
  result = v23;
  if (v23 == v22)
  {
    v14 = 4;
    result = v22;
  }
  else
  {
    if (!v23)
      return result;
    v14 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v14))();
}

void sub_1B2A87788(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,char *a23,char a24,uint64_t a25,uint64_t a26,char *a27)
{
  char *v27;
  char *v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;

  v29 = a23;
  if (a23 == v27)
  {
    v30 = 4;
    v29 = &a20;
  }
  else
  {
    if (!a23)
      goto LABEL_6;
    v30 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v29 + 8 * v30))();
LABEL_6:
  v31 = a13;
  if (a13 == &a10)
  {
    v32 = 4;
    v31 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_11;
    v32 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v31 + 8 * v32))();
LABEL_11:
  v33 = a27;
  if (a27 == &a24)
  {
    v34 = 4;
    v33 = &a24;
  }
  else
  {
    if (!a27)
      goto LABEL_16;
    v34 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v33 + 8 * v34))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

void **HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_retrieve@<X0>(int64x2_t *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void **result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  __int128 v25;
  __int128 v26;
  unint64_t *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  _BYTE v34[24];
  void **v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)(a3 + 28) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_BYTE *)(a3 + 80) = 1;
  v5 = a1[4].u64[0];
  v6 = v5 + a1[4].i64[1];
  v7 = v6 / 0x2E;
  v8 = a1[2].i64[1];
  if (a1[3].i64[0] != v8)
  {
    v9 = *(_QWORD *)(v8 + 8 * v7) + 88 * (v6 % 0x2E);
    v10 = *(_QWORD *)(v8 + 8 * (v5 / 0x2E)) + 88 * (v5 % 0x2E);
    v11 = (_QWORD *)a2[3];
    if (v11)
      goto LABEL_3;
LABEL_6:
    v35 = 0;
    goto LABEL_8;
  }
  v9 = 0;
  v10 = 0;
  v11 = (_QWORD *)a2[3];
  if (!v11)
    goto LABEL_6;
LABEL_3:
  if (v11 == a2)
  {
    v35 = (void **)v34;
    (*(void (**)(_QWORD *, _BYTE *))(*a2 + 24))(a2, v34);
  }
  else
  {
    v35 = (void **)(*(uint64_t (**)(_QWORD *))(*v11 + 16))(v11);
  }
LABEL_8:
  v12 = (uint64_t *)(v8 + 8 * v7);
  if (v9 != v10)
  {
    v13 = *v12;
    while (1)
    {
      v14 = v9;
      if (v9 == v13)
        v14 = *(v12 - 1) + 4048;
      if (!v35)
        std::__throw_bad_function_call[abi:ne180100]();
      if (((*((uint64_t (**)(void **, uint64_t))*v35 + 6))(v35, v14 - 88) & 1) != 0)
        break;
      v13 = *v12;
      if (v9 == *v12)
      {
        v15 = *--v12;
        v13 = v15;
        v9 = v15 + 4048;
      }
      v9 -= 88;
      if (v9 == v10)
      {
        v9 = v10;
        break;
      }
    }
  }
  result = v35;
  if (v35 == (void **)v34)
  {
    v17 = 4;
    result = (void **)v34;
  }
  else
  {
    if (!v35)
      goto LABEL_23;
    v17 = 5;
  }
  result = (void **)(*((uint64_t (**)(void))*result + v17))();
LABEL_23:
  v18 = a1[2].i64[1];
  if (a1[3].i64[0] == v18)
  {
    if (!v9)
      return result;
  }
  else if (v9 == *(_QWORD *)(v18 + 8 * (a1[4].i64[0] / 0x2EuLL)) + 88 * (a1[4].i64[0] % 0x2EuLL))
  {
    return result;
  }
  v19 = v9 - *v12;
  v20 = 0x2E8BA2E8BA2E8BA3 * (v19 >> 3);
  if (v19 < 89)
  {
    v24 = 46 - v20;
    v22 = &v12[-(v24 / 0x2E)];
    v23 = *v22 + 88 * (46 * (v24 / 0x2E) - v24) + 3960;
  }
  else
  {
    v21 = v20 - 1;
    v22 = &v12[v21 / 0x2E];
    v23 = *v22 + 88 * (v21 % 0x2E);
  }
  v25 = *(_OWORD *)(v23 + 48);
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v23 + 32);
  *(_OWORD *)(a3 + 48) = v25;
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(v23 + 64);
  *(_BYTE *)(a3 + 80) = *(_BYTE *)(v23 + 80);
  v26 = *(_OWORD *)(v23 + 16);
  v27 = (unint64_t *)&a1[5];
  *(_OWORD *)a3 = *(_OWORD *)v23;
  *(_OWORD *)(a3 + 16) = v26;
  do
    v28 = __ldaxr(v27);
  while (__stlxr(v28 - 1, v27));
  v29 = *(_QWORD *)(a3 + 16);
  v30 = *(_QWORD *)(a3 + 24);
  v31 = v30 * v29 * HGMetalUtils::bytesPerPixel(*(HGMetalUtils **)(a3 + 32));
  v32 = &a1[5].u64[1];
  do
    v33 = __ldaxr(v32);
  while (__stlxr(v33 - v31, v32));
  return std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::erase(a1 + 2, v22, (char *)v23);
}

void sub_1B2A87B7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10)
  {
    (*(void (**)(void))(a10 + 32))();
    _Unwind_Resume(exception_object);
  }
  if (!a13)
    _Unwind_Resume(exception_object);
  (*(void (**)(void))(*a13 + 40))();
  _Unwind_Resume(exception_object);
}

void **std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::erase(int64x2_t *a1, _QWORD *a2, char *a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void **v9;
  char *v10;
  uint64_t v11;
  _BYTE *v12;
  unint64_t v13;
  const void **v14;
  const void **v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  const void **v20;
  _BYTE *v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  const void **v26;
  char *v27;
  unint64_t v28;
  int64x2_t v29;
  unint64_t v30;
  void **v31;
  void **result;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  const void **v38;
  _BYTE *v39;
  void **v40;
  uint64_t v41;
  uint64_t v42;
  const void **v43[4];

  v6 = a1[2].u64[0];
  v7 = a1->i64[1];
  v8 = a1[1].i64[0];
  v9 = (const void **)(v7 + 8 * (v6 / 0x2E));
  if (v8 != v7)
  {
    v10 = (char *)*v9 + 88 * (v6 % 0x2E);
    if (a3 != v10)
      goto LABEL_3;
LABEL_9:
    v13 = 0;
    v12 = *v9;
    goto LABEL_10;
  }
  v10 = 0;
  if (!a3)
    goto LABEL_9;
LABEL_3:
  v11 = 46 * ((const void **)a2 - v9) + 0x2E8BA2E8BA2E8BA3 * ((uint64_t)&a3[-*a2] >> 3);
  v12 = *v9;
  v13 = v11 - 0x2E8BA2E8BA2E8BA3 * ((v10 - (_BYTE *)*v9) >> 3);
  if (!v13)
  {
LABEL_10:
    v22 = 1;
    v14 = (const void **)(v7 + 8 * (v6 / 0x2E));
    v15 = (const void **)v10;
    goto LABEL_13;
  }
  if (v11 < 1)
  {
    v14 = &v9[-((45 - v11) / 0x2EuLL)];
    v12 = *v14;
    v15 = (const void **)((char *)*v14 + 88 * (46 * ((45 - v11) / 0x2EuLL) - (45 - v11)) + 3960);
    v16 = a1[2].i64[1];
    if (v13 > (unint64_t)(v16 - 1) >> 1)
      goto LABEL_6;
  }
  else
  {
    v14 = &v9[v11 / 0x2EuLL];
    v12 = *v14;
    v15 = (const void **)((char *)*v14 + 88 * (v11 % 0x2EuLL));
    v16 = a1[2].i64[1];
    if (v13 > (unint64_t)(v16 - 1) >> 1)
    {
LABEL_6:
      v17 = (char *)v15 - v12;
      v18 = 0x2E8BA2E8BA2E8BA3 * (((char *)v15 - v12) >> 3);
      if (v17 < -87)
      {
        v35 = 44 - v18;
        v20 = &v14[-(v35 / 0x2E)];
        v21 = (char *)*v20 + 88 * (46 * (v35 / 0x2E) - v35) + 3960;
      }
      else
      {
        v19 = v18 + 1;
        v20 = &v14[v19 / 0x2E];
        v21 = (char *)*v20 + 88 * (v19 % 0x2E);
      }
      v36 = v16 + v6;
      v37 = (v16 + v6) / 0x2E;
      v38 = (const void **)(v7 + 8 * v37);
      if (v8 == v7)
        v39 = 0;
      else
        v39 = (char *)*v38 + 88 * (v36 - 46 * v37);
      v43[0] = v14;
      v43[1] = v15;
      std::__for_each_segment[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,HGMetalTexturePool::Descriptor*,HGMetalTexturePool::Descriptor&,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,long,46l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*>>(v20, v21, v38, v39, (uint64_t)v43);
      v31 = (void **)a1->i64[1];
      v40 = (void **)a1[1].i64[0];
      v41 = 46 * (v40 - v31) - 1;
      v30 = a1[2].u64[0];
      v42 = a1[2].i64[1];
      a1[2].i64[1] = v42 - 1;
      if (v40 == v31)
        v41 = 0;
      if (v41 - (v42 + v30) + 1 >= 0x5C)
      {
        operator delete(*(v40 - 1));
        v22 = 0;
        v31 = (void **)a1->i64[1];
        a1[1].i64[0] -= 8;
        v30 = a1[2].u64[0];
      }
      else
      {
        v22 = 0;
      }
      goto LABEL_18;
    }
  }
  v22 = 0;
LABEL_13:
  v23 = (char *)v15 - v12;
  v24 = 0x2E8BA2E8BA2E8BA3 * (((char *)v15 - v12) >> 3);
  if (v23 < -87)
  {
    v28 = 44 - v24;
    v26 = &v14[-(v28 / 0x2E)];
    v27 = (char *)*v26 + 88 * (46 * (v28 / 0x2E) - v28) + 3960;
  }
  else
  {
    v25 = v24 + 1;
    v26 = &v14[v25 / 0x2E];
    v27 = (char *)*v26 + 88 * (v25 % 0x2E);
  }
  std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,HGMetalTexturePool::Descriptor*,HGMetalTexturePool::Descriptor&,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,long,46l>,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,0>(v9, v10, v14, (char *)v15, v26, v27, v43);
  v29 = vaddq_s64(a1[2], (int64x2_t)xmmword_1B304F0B0);
  a1[2] = v29;
  v30 = v29.i64[0];
  v31 = (void **)a1->i64[1];
  if (v29.i64[0] >= 0x5CuLL)
  {
    operator delete(*v31);
    v31 = (void **)(a1->i64[1] + 8);
    a1->i64[1] = (uint64_t)v31;
    v30 = a1[2].i64[0] - 46;
    a1[2].i64[0] = v30;
  }
LABEL_18:
  result = &v31[v30 / 0x2E];
  if ((void **)a1[1].i64[0] == v31)
  {
    v33 = 0;
    if ((v22 & 1) != 0)
      return result;
  }
  else
  {
    v33 = (unint64_t)*result + 88 * (v30 % 0x2E);
    if ((v22 & 1) != 0)
      return result;
  }
  v34 = v13 + 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v33 - (_QWORD)*result) >> 3);
  if (v34 < 1)
    result -= (45 - v34) / 0x2EuLL;
  else
    result += v34 / 0x2EuLL;
  return result;
}

void *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,HGMetalTexturePool::Descriptor*,HGMetalTexturePool::Descriptor&,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,long,46l>,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,0>@<X0>(const void **a1@<X1>, char *a2@<X2>, const void **a3@<X3>, char *a4@<X4>, const void **a5@<X5>, char *a6@<X6>, const void ***a7@<X8>)
{
  const void **v8;
  const void **v9;
  const void **v10;
  const void ***v12;
  _BYTE *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  void *result;
  uint64_t v19;
  char *v20;
  const void **v21;
  char *v22;
  _BYTE *v23;
  char *v24;
  uint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;

  v8 = a5;
  v9 = (const void **)a4;
  v10 = a3;
  v12 = a7;
  if (a1 == a3)
  {
    if (a2 != a4)
    {
      v34 = (uint64_t)*a5;
      v35 = a4;
      while (1)
      {
        v36 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)&a6[-v34] >> 3);
        if (0x2E8BA2E8BA2E8BA3 * ((v35 - a2) >> 3) < v36)
          v36 = 0x2E8BA2E8BA2E8BA3 * ((v35 - a2) >> 3);
        v35 -= 88 * v36;
        a6 -= 88 * v36;
        if (v36)
          result = memmove(a6, v35, 88 * v36 - 7);
        if (v35 == a2)
          break;
        v37 = (uint64_t)*--v8;
        v34 = v37;
        a6 = (char *)(v37 + 4048);
      }
      if ((char *)*v8 + 4048 == a6)
      {
        v38 = (char *)v8[1];
        ++v8;
        a6 = v38;
      }
      v10 = a3;
    }
  }
  else
  {
    v14 = *a3;
    if (*a3 != a4)
    {
      v15 = (uint64_t)*a5;
      v16 = a4;
      while (1)
      {
        v17 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)&a6[-v15] >> 3);
        if (0x2E8BA2E8BA2E8BA3 * ((v16 - v14) >> 3) < v17)
          v17 = 0x2E8BA2E8BA2E8BA3 * ((v16 - v14) >> 3);
        v16 -= 88 * v17;
        a6 -= 88 * v17;
        if (v17)
          result = memmove(a6, v16, 88 * v17 - 7);
        if (v16 == v14)
          break;
        v19 = (uint64_t)*--v8;
        v15 = v19;
        a6 = (char *)(v19 + 4048);
      }
      if ((char *)*v8 + 4048 == a6)
      {
        v20 = (char *)v8[1];
        ++v8;
        a6 = v20;
      }
      v10 = a3;
    }
    v21 = v10 - 1;
    if (v10 - 1 != a1)
    {
      v22 = (char *)*v8;
      do
      {
        while (1)
        {
          v23 = *v21;
          v24 = (char *)*v21 + 4048;
          while (1)
          {
            v25 = 0x2E8BA2E8BA2E8BA3 * ((a6 - v22) >> 3);
            if (0x2E8BA2E8BA2E8BA3 * ((v24 - v23) >> 3) < v25)
              v25 = 0x2E8BA2E8BA2E8BA3 * ((v24 - v23) >> 3);
            v24 -= 88 * v25;
            a6 -= 88 * v25;
            if (v25)
              result = memmove(a6, v24, 88 * v25 - 7);
            if (v24 == v23)
              break;
            v26 = (char *)*--v8;
            v22 = v26;
            a6 = v26 + 4048;
          }
          v22 = (char *)*v8;
          if ((char *)*v8 + 4048 == a6)
            break;
          if (--v21 == a1)
            goto LABEL_25;
        }
        v27 = (char *)v8[1];
        ++v8;
        v22 = v27;
        a6 = v27;
        --v21;
      }
      while (v21 != a1);
LABEL_25:
      v10 = a3;
    }
    v28 = (char *)*a1 + 4048;
    v9 = (const void **)a4;
    if (v28 != a2)
    {
      v29 = (uint64_t)*v8;
      while (1)
      {
        v30 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)&a6[-v29] >> 3);
        if (0x2E8BA2E8BA2E8BA3 * ((v28 - a2) >> 3) < v30)
          v30 = 0x2E8BA2E8BA2E8BA3 * ((v28 - a2) >> 3);
        v28 -= 88 * v30;
        a6 -= 88 * v30;
        if (v30)
          result = memmove(a6, v28, 88 * v30 - 7);
        if (v28 == a2)
          break;
        v31 = (uint64_t)*--v8;
        v29 = v31;
        a6 = (char *)(v31 + 4048);
      }
      if ((char *)*v8 + 4048 == a6)
      {
        v32 = (char *)v8[1];
        ++v8;
        a6 = v32;
      }
    }
    v12 = a7;
  }
  *v12 = v10;
  v12[1] = v9;
  v12[2] = v8;
  v12[3] = (const void **)a6;
  return result;
}

const void **std::__for_each_segment[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,HGMetalTexturePool::Descriptor*,HGMetalTexturePool::Descriptor&,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,long,46l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*>>(const void **result, _BYTE *__src, const void **a3, _BYTE *a4, uint64_t a5)
{
  _BYTE *v6;
  char *v7;
  void **v8;
  const void **v9;
  _BYTE *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  _BYTE *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  void **v30;
  char *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  _QWORD *v38;

  v6 = __src;
  v8 = *(void ***)a5;
  v7 = *(char **)(a5 + 8);
  if (result == a3)
  {
    if (__src == a4)
      goto LABEL_48;
    v32 = (char *)*v8++;
    v31 = v32;
    while (1)
    {
      v33 = 0x2E8BA2E8BA2E8BA3 * ((v31 - v7 + 4048) >> 3);
      if (0x2E8BA2E8BA2E8BA3 * ((a4 - v6) >> 3) >= v33)
        v34 = v33;
      else
        v34 = 0x2E8BA2E8BA2E8BA3 * ((a4 - v6) >> 3);
      if (v34)
        result = (const void **)memmove(v7, v6, 88 * v34 - 7);
      v6 += 88 * v34;
      if (v6 == a4)
        break;
      v35 = (char *)*v8++;
      v31 = v35;
      v7 = v35;
    }
    v7 += 88 * v34;
    v30 = v8 - 1;
    if ((char *)*(v8 - 1) + 4048 != v7)
      goto LABEL_36;
    goto LABEL_47;
  }
  v9 = result;
  v10 = (char *)*result + 4048;
  if (v10 != __src)
  {
    v12 = (char *)*v8++;
    v11 = v12;
    while (1)
    {
      v13 = 0x2E8BA2E8BA2E8BA3 * ((v11 - v7 + 4048) >> 3);
      if (0x2E8BA2E8BA2E8BA3 * ((v10 - v6) >> 3) >= v13)
        v14 = v13;
      else
        v14 = 0x2E8BA2E8BA2E8BA3 * ((v10 - v6) >> 3);
      if (v14)
        result = (const void **)memmove(v7, v6, 88 * v14 - 7);
      v6 += 88 * v14;
      if (v6 == v10)
        break;
      v15 = (char *)*v8++;
      v11 = v15;
      v7 = v15;
    }
    v7 += 88 * v14;
    if ((char *)*(v8 - 1) + 4048 == v7)
    {
      v7 = (char *)*v8;
      *(_QWORD *)a5 = v8;
      *(_QWORD *)(a5 + 8) = v7;
      v16 = v9 + 1;
      if (v9 + 1 != a3)
        goto LABEL_16;
      goto LABEL_26;
    }
    --v8;
  }
  *(_QWORD *)a5 = v8;
  *(_QWORD *)(a5 + 8) = v7;
  v16 = v9 + 1;
  if (v9 + 1 != a3)
  {
    do
    {
LABEL_16:
      while (1)
      {
        v17 = 0;
        v38 = v16;
        v18 = *v16;
        v20 = (char *)*v8++;
        v19 = v20;
        while (1)
        {
          v21 = 0x2E8BA2E8BA2E8BA3 * ((v19 - v7 + 4048) >> 3);
          if (0x2E8BA2E8BA2E8BA3 * ((4048 - 88 * v17) >> 3) >= v21)
            v22 = v21;
          else
            v22 = 0x2E8BA2E8BA2E8BA3 * ((4048 - 88 * v17) >> 3);
          if (v22)
            result = (const void **)memmove(v7, (const void *)(v18 + 88 * v17), 88 * v22 - 7);
          v17 += v22;
          if (v17 == 46)
            break;
          v23 = (char *)*v8++;
          v19 = v23;
          v7 = v23;
        }
        v7 += 88 * v22;
        if ((char *)*(v8 - 1) + 4048 != v7)
          break;
        v7 = (char *)*v8;
        *(_QWORD *)a5 = v8;
        *(_QWORD *)(a5 + 8) = v7;
        v16 = v38 + 1;
        if (v38 + 1 == a3)
          goto LABEL_26;
      }
      *(_QWORD *)a5 = --v8;
      *(_QWORD *)(a5 + 8) = v7;
      v16 = v38 + 1;
    }
    while (v38 + 1 != a3);
  }
LABEL_26:
  v24 = *a3;
  if (*a3 != a4)
  {
    v26 = (char *)*v8++;
    v25 = v26;
    while (1)
    {
      v27 = 0x2E8BA2E8BA2E8BA3 * ((v25 - v7 + 4048) >> 3);
      v28 = 0x2E8BA2E8BA2E8BA3 * ((a4 - v24) >> 3) >= v27 ? v27 : 0x2E8BA2E8BA2E8BA3 * ((a4 - v24) >> 3);
      if (v28)
        result = (const void **)memmove(v7, v24, 88 * v28 - 7);
      v24 += 88 * v28;
      if (v24 == a4)
        break;
      v29 = (char *)*v8++;
      v25 = v29;
      v7 = v29;
    }
    v7 += 88 * v28;
    v30 = v8 - 1;
    if ((char *)*(v8 - 1) + 4048 != v7)
    {
LABEL_36:
      v8 = v30;
      goto LABEL_48;
    }
LABEL_47:
    v7 = (char *)*v8;
  }
LABEL_48:
  *(_QWORD *)a5 = v8;
  *(_QWORD *)(a5 + 8) = v7;
  return result;
}

_QWORD *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E6526408;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::~__func(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E6526408;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1B5E29170);
}

char *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::__clone(uint64_t a1)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = (char *)operator new(0x58uLL);
  *(_QWORD *)v2 = &off_1E6526408;
  v3 = v2 + 8;
  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    if (v4 == a1 + 8)
    {
      *((_QWORD *)v2 + 4) = v3;
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
      goto LABEL_6;
    }
    v4 = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v4 + 16))(v4, v3);
  }
  *((_QWORD *)v2 + 4) = v4;
LABEL_6:
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(v2 + 72) = *(_OWORD *)(a1 + 72);
  return v2;
}

void sub_1B2A88874(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  __n128 result;
  __int128 v7;

  *(_QWORD *)a2 = &off_1E6526408;
  v4 = a2 + 8;
  v5 = *(_QWORD *)(a1 + 32);
  if (v5)
  {
    if (v5 == a1 + 8)
    {
      *(_QWORD *)(a2 + 32) = v4;
      (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
    }
    else
    {
      *(_QWORD *)(a2 + 32) = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 16))(v5, v4);
    }
  }
  else
  {
    *(_QWORD *)(a2 + 32) = 0;
  }
  result = *(__n128 *)(a1 + 40);
  v7 = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 72) = *(_OWORD *)(a1 + 72);
  *(_OWORD *)(a2 + 56) = v7;
  *(__n128 *)(a2 + 40) = result;
  return result;
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::destroy(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = a1 + 8;
  result = *(_QWORD *)(a1 + 32);
  if (result == v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 32))(v1);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  return result;
}

void std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::destroy_deallocate(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

BOOL std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a1 + 40) == *(_QWORD *)(a2 + 16)
      && *(_QWORD *)(a1 + 48) == *(_QWORD *)(a2 + 24)
      && *(_QWORD *)(a1 + 56) == *(_QWORD *)(a2 + 32)
      && *(_DWORD *)(a1 + 64) == *(_DWORD *)(a2 + 40)
      && *(_QWORD *)(a1 + 72) == *(_QWORD *)(a2 + 48)
      && *(_DWORD *)(a1 + 80) == *(_DWORD *)(a2 + 56)
      && *(_DWORD *)(a1 + 84) == *(_DWORD *)(a2 + 60);
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "N6HGPool16MatchDescriptionIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE")
    return a1 + 8;
  if (((v3 & (unint64_t)"N6HGPool16MatchDescriptionIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool16MatchDescriptionIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool16MatchDescriptionIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::target_type()
{
}

void std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  void *v26;
  char *v27;
  char *v28;
  char *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  BOOL v37;
  int64_t v38;
  unint64_t v39;
  char *v40;
  _QWORD *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int64_t v45;
  unint64_t v46;
  char *v47;
  unint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  size_t v58;
  unint64_t v59;
  char *v60;
  unint64_t v61;
  int64_t v62;
  unint64_t v63;
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  __int128 *v69;
  char *v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  __int128 *v77;
  _OWORD *v78;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  __int128 *v85;
  _OWORD *v86;
  uint64_t v87;
  __int128 v88;
  uint64_t v89;
  void *v90;
  void *v91;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = v2 >= 0x2E;
  v4 = v2 - 46;
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v4;
    v6 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_78:
      *(_QWORD *)v5 = v8;
      *(_QWORD *)(a1 + 16) += 8;
      return;
    }
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v31 = (v5 - v9) >> 2;
      if (v5 == v9)
        v31 = 1;
      if (!(v31 >> 61))
      {
        v32 = v31 >> 2;
        v33 = 8 * v31;
        v34 = (char *)operator new(8 * v31);
        v35 = &v34[8 * v32];
        v36 = &v34[v33];
        v38 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            v74 = &v34[8 * v32];
            v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              v75 = (v39 >> 3) + 1;
              v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              v40 = &v35[v76];
              v7 += v76;
              v77 = (__int128 *)(v6 + 3);
              v78 = v74 + 16;
              v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v40 = &v34[8 * v32];
          }
          do
          {
            v81 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_76;
      }
LABEL_87:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    v11 = v10 >> 3;
    if (v11 >= -1)
      v12 = v11 + 1;
    else
      v12 = v11 + 2;
    v13 = v12 >> 1;
    v14 = -v13;
    v15 = &v7[-8 * v13];
    v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      v7 = *(char **)(a1 + 8);
    }
    v5 = &v15[v16];
    *(_QWORD *)(a1 + 8) = &v7[8 * v14];
    *(_QWORD *)(a1 + 16) = &v15[v16];
    goto LABEL_78;
  }
  v18 = *(_QWORD *)(a1 + 16);
  v17 = *(_QWORD *)(a1 + 24);
  v19 = *(_QWORD *)(a1 + 8);
  v20 = v18 - v19;
  v21 = (v18 - v19) >> 3;
  v22 = v17 - *(_QWORD *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      v91 = operator new(0xFD0uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    v91 = operator new(0xFD0uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    v41 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v41 + 1);
    v8 = *v41;
    *(_QWORD *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24))
      goto LABEL_78;
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v42 = (v5 - v9) >> 2;
      if (v5 == v9)
        v42 = 1;
      if (!(v42 >> 61))
      {
        v43 = v42 >> 2;
        v44 = 8 * v42;
        v34 = (char *)operator new(8 * v42);
        v35 = &v34[8 * v43];
        v36 = &v34[v44];
        v45 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            v82 = &v34[8 * v43];
            v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              v83 = (v46 >> 3) + 1;
              v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              v47 = &v35[v84];
              v7 += v84;
              v85 = (__int128 *)(v41 + 3);
              v86 = v82 + 16;
              v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v47 = &v34[8 * v43];
          }
          do
          {
            v89 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_76:
        *(_QWORD *)a1 = v34;
        *(_QWORD *)(a1 + 8) = v35;
        *(_QWORD *)(a1 + 16) = v5;
        *(_QWORD *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          v5 = *(char **)(a1 + 16);
        }
        goto LABEL_78;
      }
      goto LABEL_87;
    }
    goto LABEL_5;
  }
  v23 = v22 >> 2;
  if (v17 == *(_QWORD *)a1)
    v24 = 1;
  else
    v24 = v23;
  if (v24 >> 61)
    goto LABEL_87;
  v25 = (char *)operator new(8 * v24);
  v26 = operator new(0xFD0uLL);
  v27 = &v25[8 * v21];
  v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19)
        v48 = 1;
      else
        v48 = v20 >> 2;
      if (v48 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v49 = (char *)operator new(8 * v48);
      v27 = &v49[8 * (v48 >> 2)];
      v28 = &v49[8 * v48];
      operator delete(v25);
      v50 = *(_QWORD *)(a1 + 8);
      v18 = *(_QWORD *)(a1 + 16);
      v25 = v49;
      *(_QWORD *)v27 = v90;
      v29 = v27 + 8;
      if (v18 == v50)
        goto LABEL_45;
    }
    else
    {
      v30 = v21 + 2;
      if (v21 >= -1)
        v30 = v21 + 1;
      v27 -= 8 * (v30 >> 1);
      *(_QWORD *)v27 = v26;
      v29 = v27 + 8;
      if (v18 == v19)
        goto LABEL_45;
    }
    do
    {
LABEL_50:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27)
            v59 = 1;
          else
            v59 = (v28 - v27) >> 2;
          if (v59 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v60 = (char *)operator new(8 * v59);
          v25 = v60;
          v61 = (v59 + 3) >> 2;
          v53 = &v60[8 * v61];
          v62 = v29 - v27;
          v37 = v29 == v27;
          v29 = v53;
          if (!v37)
          {
            v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            v63 = v62 - 8;
            v64 = &v60[8 * v61];
            v65 = v27;
            if (v63 < 0x38)
              goto LABEL_91;
            v66 = 8 * v61;
            v64 = &v60[8 * v61];
            v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20)
              goto LABEL_91;
            v67 = (v63 >> 3) + 1;
            v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            v64 = &v53[v68];
            v65 = &v27[v68];
            v69 = (__int128 *)(v27 + 16);
            v70 = &v60[v66 + 16];
            v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_91:
              do
              {
                v73 = *(_QWORD *)v65;
                v65 += 8;
                *(_QWORD *)v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          v55 = (v28 - v29) >> 3;
          if (v55 >= -1)
            v56 = v55 + 1;
          else
            v56 = v55 + 2;
          v57 = &v29[8 * (v56 >> 1)];
          v53 = &v57[-(v29 - v27)];
          v58 = v29 - v27;
          v37 = v29 == v27;
          v29 = v57;
          if (!v37)
            memmove(v53, v27, v58);
          v25 = v27;
        }
      }
      else
      {
        v53 = v27;
      }
      v54 = *(_QWORD *)(v18 - 8);
      v18 -= 8;
      *((_QWORD *)v53 - 1) = v54;
      v51 = v53 - 8;
      v27 = v51;
    }
    while (v18 != *(_QWORD *)(a1 + 8));
    goto LABEL_46;
  }
  *(_QWORD *)v27 = v26;
  v29 = v27 + 8;
  if (v18 != v19)
    goto LABEL_50;
LABEL_45:
  v51 = v27;
LABEL_46:
  v52 = *(char **)a1;
  *(_QWORD *)a1 = v25;
  *(_QWORD *)(a1 + 8) = v51;
  *(_QWORD *)(a1 + 16) = v29;
  *(_QWORD *)(a1 + 24) = v28;
  if (v52)
    operator delete(v52);
}

void sub_1B2A88FEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  void *v9;

  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B2A89008(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A8901C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A89034(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,true>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *result;
  uint64_t v12;
  _BYTE v13[24];
  _BYTE *v14;
  uint64_t v15;
  _QWORD v16[3];
  _QWORD *v17;
  _BYTE v18[24];
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  v19 = 0;
  v20 = v5;
  v14 = 0;
  v15 = v5;
  v6 = operator new(0x30uLL);
  *v6 = &off_1E6526510;
  v6[4] = 0;
  v6[5] = v5;
  v17 = v6;
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,true>::_retrieve(a1, v16, a3);
  v7 = v17;
  if (v17 == v16)
  {
    v8 = 4;
    v7 = v16;
  }
  else
  {
    if (!v17)
      goto LABEL_6;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  v9 = v14;
  if (v14 == v13)
  {
    v10 = 4;
    v9 = v13;
  }
  else
  {
    if (!v14)
      goto LABEL_11;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_11:
  result = v19;
  if (v19 == v18)
  {
    v12 = 4;
    result = v18;
  }
  else
  {
    if (!v19)
      return result;
    v12 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
}

void sub_1B2A89174(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char *a18, char a19, uint64_t a20,uint64_t a21,char *a22)
{
  char *v22;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;

  v24 = a18;
  if (a18 == v22)
  {
    v25 = 4;
    v24 = &a15;
  }
  else
  {
    if (!a18)
      goto LABEL_6;
    v25 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_6:
  v26 = a13;
  if (a13 == &a10)
  {
    v27 = 4;
    v26 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_11;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_11:
  v28 = a22;
  if (a22 == &a19)
  {
    v29 = 4;
    v28 = &a19;
  }
  else
  {
    if (!a22)
      goto LABEL_16;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

_QWORD *HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *result;
  uint64_t v12;
  _BYTE v13[24];
  _BYTE *v14;
  uint64_t v15;
  _QWORD v16[3];
  _QWORD *v17;
  _BYTE v18[24];
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  v19 = 0;
  v20 = v5;
  v14 = 0;
  v15 = v5;
  v6 = operator new(0x30uLL);
  *v6 = &off_1E6526510;
  v6[4] = 0;
  v6[5] = v5;
  v17 = v6;
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_retrieve(a1, v16, a3);
  v7 = v17;
  if (v17 == v16)
  {
    v8 = 4;
    v7 = v16;
  }
  else
  {
    if (!v17)
      goto LABEL_6;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  v9 = v14;
  if (v14 == v13)
  {
    v10 = 4;
    v9 = v13;
  }
  else
  {
    if (!v14)
      goto LABEL_11;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_11:
  result = v19;
  if (v19 == v18)
  {
    v12 = 4;
    result = v18;
  }
  else
  {
    if (!v19)
      return result;
    v12 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
}

void sub_1B2A8933C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char *a18, char a19, uint64_t a20,uint64_t a21,char *a22)
{
  char *v22;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;

  v24 = a18;
  if (a18 == v22)
  {
    v25 = 4;
    v24 = &a15;
  }
  else
  {
    if (!a18)
      goto LABEL_6;
    v25 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_6:
  v26 = a13;
  if (a13 == &a10)
  {
    v27 = 4;
    v26 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_11;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_11:
  v28 = a22;
  if (a22 == &a19)
  {
    v29 = 4;
    v28 = &a19;
  }
  else
  {
    if (!a22)
      goto LABEL_16;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

void **HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,true>::_retrieve@<X0>(int64x2_t *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void **result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  __int128 v25;
  __int128 v26;
  unint64_t *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  _BYTE v34[24];
  void **v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)(a3 + 28) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_BYTE *)(a3 + 80) = 1;
  v5 = a1[4].u64[0];
  v6 = v5 + a1[4].i64[1];
  v7 = v6 / 0x2E;
  v8 = a1[2].i64[1];
  if (a1[3].i64[0] != v8)
  {
    v9 = *(_QWORD *)(v8 + 8 * v7) + 88 * (v6 % 0x2E);
    v10 = *(_QWORD *)(v8 + 8 * (v5 / 0x2E)) + 88 * (v5 % 0x2E);
    v11 = (_QWORD *)a2[3];
    if (v11)
      goto LABEL_3;
LABEL_6:
    v35 = 0;
    goto LABEL_8;
  }
  v9 = 0;
  v10 = 0;
  v11 = (_QWORD *)a2[3];
  if (!v11)
    goto LABEL_6;
LABEL_3:
  if (v11 == a2)
  {
    v35 = (void **)v34;
    (*(void (**)(_QWORD *, _BYTE *))(*a2 + 24))(a2, v34);
  }
  else
  {
    v35 = (void **)(*(uint64_t (**)(_QWORD *))(*v11 + 16))(v11);
  }
LABEL_8:
  v12 = (uint64_t *)(v8 + 8 * v7);
  if (v9 != v10)
  {
    v13 = *v12;
    while (1)
    {
      v14 = v9;
      if (v9 == v13)
        v14 = *(v12 - 1) + 4048;
      if (!v35)
        std::__throw_bad_function_call[abi:ne180100]();
      if (((*((uint64_t (**)(void **, uint64_t))*v35 + 6))(v35, v14 - 88) & 1) != 0)
        break;
      v13 = *v12;
      if (v9 == *v12)
      {
        v15 = *--v12;
        v13 = v15;
        v9 = v15 + 4048;
      }
      v9 -= 88;
      if (v9 == v10)
      {
        v9 = v10;
        break;
      }
    }
  }
  result = v35;
  if (v35 == (void **)v34)
  {
    v17 = 4;
    result = (void **)v34;
  }
  else
  {
    if (!v35)
      goto LABEL_23;
    v17 = 5;
  }
  result = (void **)(*((uint64_t (**)(void))*result + v17))();
LABEL_23:
  v18 = a1[2].i64[1];
  if (a1[3].i64[0] == v18)
  {
    if (!v9)
      return result;
  }
  else if (v9 == *(_QWORD *)(v18 + 8 * (a1[4].i64[0] / 0x2EuLL)) + 88 * (a1[4].i64[0] % 0x2EuLL))
  {
    return result;
  }
  v19 = v9 - *v12;
  v20 = 0x2E8BA2E8BA2E8BA3 * (v19 >> 3);
  if (v19 < 89)
  {
    v24 = 46 - v20;
    v22 = &v12[-(v24 / 0x2E)];
    v23 = *v22 + 88 * (46 * (v24 / 0x2E) - v24) + 3960;
  }
  else
  {
    v21 = v20 - 1;
    v22 = &v12[v21 / 0x2E];
    v23 = *v22 + 88 * (v21 % 0x2E);
  }
  v25 = *(_OWORD *)(v23 + 48);
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v23 + 32);
  *(_OWORD *)(a3 + 48) = v25;
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(v23 + 64);
  *(_BYTE *)(a3 + 80) = *(_BYTE *)(v23 + 80);
  v26 = *(_OWORD *)(v23 + 16);
  v27 = (unint64_t *)&a1[5];
  *(_OWORD *)a3 = *(_OWORD *)v23;
  *(_OWORD *)(a3 + 16) = v26;
  do
    v28 = __ldaxr(v27);
  while (__stlxr(v28 - 1, v27));
  v29 = *(_QWORD *)(a3 + 16);
  v30 = *(_QWORD *)(a3 + 24);
  v31 = v30 * v29 * HGMetalUtils::bytesPerPixel(*(HGMetalUtils **)(a3 + 32));
  v32 = &a1[5].u64[1];
  do
    v33 = __ldaxr(v32);
  while (__stlxr(v33 - v31, v32));
  return std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::erase(a1 + 2, v22, (char *)v23);
}

void sub_1B2A89730(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10)
  {
    (*(void (**)(void))(a10 + 32))();
    _Unwind_Resume(exception_object);
  }
  if (!a13)
    _Unwind_Resume(exception_object);
  (*(void (**)(void))(*a13 + 40))();
  _Unwind_Resume(exception_object);
}

_QWORD *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E6526510;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::~__func(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E6526510;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1B5E29170);
}

_QWORD *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = operator new(0x30uLL);
  *v2 = &off_1E6526510;
  v3 = v2 + 1;
  v4 = *(_QWORD *)(a1 + 32);
  if (!v4)
    goto LABEL_4;
  if (v4 != a1 + 8)
  {
    v4 = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 16))(v4, v3);
LABEL_4:
    v5 = *(_QWORD *)(a1 + 40);
    v2[4] = v4;
    v2[5] = v5;
    return v2;
  }
  v2[4] = v3;
  (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v2[5] = *(_QWORD *)(a1 + 40);
  return v2;
}

void sub_1B2A898DC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t result;

  *a2 = &off_1E6526510;
  v4 = a2 + 1;
  result = *(_QWORD *)(a1 + 32);
  if (result)
  {
    if (result == a1 + 8)
    {
      a2[4] = v4;
      result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
    }
    else
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)result + 16))(result, v4);
      a2[4] = result;
    }
    a2[5] = *(_QWORD *)(a1 + 40);
  }
  else
  {
    a2[4] = 0;
    a2[5] = *(_QWORD *)(a1 + 40);
  }
  return result;
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::destroy(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = a1 + 8;
  result = *(_QWORD *)(a1 + 32);
  if (result == v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 32))(v1);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  return result;
}

void std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::destroy_deallocate(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

BOOL std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::operator()(uint64_t a1, _QWORD *a2)
{
  return *a2 == *(_QWORD *)(a1 + 40);
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "N6HGPool11MatchObjectIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE")
    return a1 + 8;
  if (((v3 & (unint64_t)"N6HGPool11MatchObjectIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool11MatchObjectIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool11MatchObjectIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::target_type()
{
}

void std::__shared_ptr_emplace<`anonymous namespace'::TextureWrapperAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6526598;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<`anonymous namespace'::TextureWrapperAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6526598;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

uint64_t std::__shared_ptr_emplace<`anonymous namespace'::TextureWrapperAllocator>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void `anonymous namespace'::TextureWrapperAllocator::~TextureWrapperAllocator(_anonymous_namespace_::TextureWrapperAllocator *this)
{
  JUMPOUT(0x1B5E29170);
}

uint64_t `anonymous namespace'::TextureWrapperAllocator::allocate()
{
  return 0;
}

void `anonymous namespace'::TextureWrapperAllocator::release(uint64_t a1, void *a2)
{

}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::~Pool(a1, a2);
  JUMPOUT(0x1B5E29170);
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::usedObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 128));
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::usedTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 136));
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::freeObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 232));
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::freeTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 240));
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::service(uint64_t a1)
{
  std::mutex *v2;

  v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::service((int64x2_t *)(a1 + 152), a1))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    kdebug_trace();
  }
  std::mutex::unlock(v2);
}

void sub_1B2A89C4C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::trace(std::mutex *a1)
{
  std::mutex *v2;
  std::mutex *sig;

  v2 = a1 + 4;
  std::mutex::lock(a1 + 4);
  sig = a1 + 5;
  if (a1[5].__m_.__opaque[15] < 0)
    sig = (std::mutex *)sig->__m_.__sig;
  (*(void (**)(std::mutex *, std::mutex *))(a1->__m_.__sig + 24))(a1, sig);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 16))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 40))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 32))(a1);
  std::mutex::unlock(v2);
}

void sub_1B2A89E90(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A89EA4(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A89EB8(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A89ECC(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::log(uint64_t a1, const char *a2)
{
  HGLogger *v3;
  const char *v4;
  char *v5;
  unsigned __int8 v6;
  _QWORD *v7;
  const char *v8;
  char *v9;
  unsigned __int8 v10;
  const char *v11;
  char *v12;
  unsigned __int8 v13;

  v3 = (HGLogger *)(a1 + 344);
  if (*(char *)(a1 + 367) < 0)
  {
    v3 = *(HGLogger **)v3;
    if ((int)HGLogger::getLevel(v3, a2) < 2)
      return;
  }
  else if ((int)HGLogger::getLevel((HGLogger *)(a1 + 344), a2) < 2)
  {
    return;
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  v6 = atomic_load(HGLogger::_enabled);
  if ((v6 & 1) != 0)
  {
    v7 = (_QWORD *)(a1 + 320);
    if (*(char *)(a1 + 343) < 0)
      v7 = (_QWORD *)*v7;
    HGLogger::log(v3, (const char *)2, (HGLogger *)"pool '%s' (%p)\n", v4, v5, v7, a1);
  }
  HGLogger::indent(1);
  v10 = atomic_load(HGLogger::_enabled);
  if ((v10 & 1) != 0)
    HGLogger::log(v3, (const char *)2, (HGLogger *)"live objects:\n", v8, v9);
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,true>::log((_QWORD *)(a1 + 48), v3);
  v13 = atomic_load(HGLogger::_enabled);
  if ((v13 & 1) != 0)
    HGLogger::log(v3, (const char *)2, (HGLogger *)"free objects:\n", v11, v12);
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::log((_QWORD *)(a1 + 152), v3);
  HGLogger::indent(0xFFFFFFFFLL);
  std::mutex::unlock((std::mutex *)(a1 + 256));
}

void sub_1B2A89FF8(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::canService(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 372);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::canTrace(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 373);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::canLog(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 374);
}

int64x2_t *HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::~List(int64x2_t *a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;

  while (a1[4].i64[1])
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::_pop_front(a1);
  std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::~deque[abi:ne180100]((uint64_t)a1[2].i64);
  v2 = (std::__shared_weak_count *)a1[1].i64[1];
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = (std::__shared_weak_count *)a1->i64[1];
  if (!v5)
    return a1;
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (v7)
    return a1;
  ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
  std::__shared_weak_count::__release_weak(v5);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::_pop_front(int64x2_t *a1)
{
  __int128 *v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  void **v12;
  int64x2_t v13;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;

  v2 = (__int128 *)(*(_QWORD *)(a1[2].i64[1] + 8 * (a1[4].i64[0] / 0x24uLL)) + 112 * (a1[4].i64[0] % 0x24uLL));
  v4 = v2[1];
  v3 = v2[2];
  v15 = *v2;
  v16 = v4;
  v17 = v3;
  v5 = v2[6];
  v7 = v2[3];
  v6 = v2[4];
  v20 = v2[5];
  v21 = v5;
  v18 = v7;
  v19 = v6;
  v8 = (unint64_t *)&a1[5];
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 - 1, v8));
  v10 = &a1[5].u64[1];
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - *((_QWORD *)&v16 + 1), v10));
  v12 = (void **)a1[2].i64[1];
  v13 = vaddq_s64(a1[4], (int64x2_t)xmmword_1B304F0B0);
  a1[4] = v13;
  if (v13.i64[0] >= 0x48uLL)
  {
    operator delete(*v12);
    a1[2].i64[1] += 8;
    a1[4].i64[0] -= 36;
  }
  HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::deleted(&v15);
  kdebug_trace();
  kdebug_trace();
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a1->i64[0] + 24))(a1->i64[0], v15);
  if (*((_QWORD *)&v15 + 1))
    (*(void (**)(uint64_t))(*(_QWORD *)a1->i64[0] + 24))(a1->i64[0]);
  return kdebug_trace();
}

void sub_1B2A8A280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  _Unwind_Resume(a1);
}

void HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::deleted(_QWORD *a1)
{
  const char *v2;
  char *v3;
  unsigned __int8 v4;
  void *p_p;
  void *__p;
  char v7;

  HGPool::DescriptorString<HGMetalTextureWrapperInfinipool::Descriptor>::str((uint64_t)(a1 + 2));
  v4 = atomic_load(HGLogger::_enabled);
  if ((v4 & 1) != 0)
  {
    if (v7 >= 0)
      p_p = &__p;
    else
      p_p = __p;
    HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry deleted : %p (%s)\n", v2, v3, *a1, p_p);
  }
  if (v7 < 0)
    operator delete(__p);
}

void sub_1B2A8A334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t HGPool::DescriptorString<HGMetalTextureWrapperInfinipool::Descriptor>::str(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  const char *v5;
  size_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[13];
  char v11;
  uint64_t v12;

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v10);
  v2 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)" x ", 3);
  v3 = (_QWORD *)std::ostream::operator<<();
  v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)", ", 2);
  v5 = HGMetalUtils::toString(*(HGMetalUtils **)(a1 + 48));
  v6 = strlen(v5);
  v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)v5, v6);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)", ptr=", 6);
  std::ostream::operator<<();
  std::stringbuf::str();
  v10[0] = *MEMORY[0x1E0DE4F50];
  v8 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)v10 + *(_QWORD *)(v10[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v10[2] = v8;
  v10[3] = MEMORY[0x1E0DE4FB8] + 16;
  if (v11 < 0)
    operator delete((void *)v10[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1B5E290BC](&v12);
}

void sub_1B2A8A474(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::~deque[abi:ne180100](uint64_t a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  *(_QWORD *)(a1 + 40) = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = *(void ***)(a1 + 16);
      v2 = (void **)(*(_QWORD *)(a1 + 8) + 8);
      *(_QWORD *)(a1 + 8) = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 18;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    v6 = 36;
LABEL_7:
    *(_QWORD *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    v9 = *(_QWORD *)(a1 + 8);
    v8 = *(_QWORD *)(a1 + 16);
    if (v8 != v9)
      *(_QWORD *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;

  *(_QWORD *)a1 = &off_1E6526640;
  HGPool::unregisterPool((HGPool *)a1, a2);
  if (*(char *)(a1 + 367) < 0)
  {
    operator delete(*(void **)(a1 + 344));
    if ((*(char *)(a1 + 343) & 0x80000000) == 0)
      goto LABEL_3;
LABEL_24:
    operator delete(*(void **)(a1 + 320));
    goto LABEL_3;
  }
  if (*(char *)(a1 + 343) < 0)
    goto LABEL_24;
LABEL_3:
  std::mutex::~mutex((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::~List((int64x2_t *)(a1 + 152));
  std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::~deque[abi:ne180100](a1 + 80);
  v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  v6 = *(std::__shared_weak_count **)(a1 + 56);
  if (v6)
  {
    v7 = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v9 = *(std::__shared_weak_count **)(a1 + 40);
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v12)
    return a1;
  v13 = (unint64_t *)&v12->__shared_owners_;
  do
    v14 = __ldaxr(v13);
  while (__stlxr(v14 - 1, v13));
  if (v14)
    return a1;
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::service(int64x2_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;

  if (!a1[1].i64[0] || !a1[4].i64[1])
    return 0;
  v4 = 0;
  do
  {
    v5 = atomic_load((unint64_t *)&a1[5]);
    if (v5 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1[1].i64[0] + 16))(a1[1].i64[0], a2))
    {
      v6 = atomic_load(&a1[5].u64[1]);
      if (v6 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1[1].i64[0] + 24))(a1[1].i64[0], a2))
      {
        v7 = a1[4].u64[0];
        v8 = *(_QWORD *)(a1[2].i64[1] + 8 * (v7 / 0x24));
        v9 = std::chrono::steady_clock::now().__d_.__rep_ - *(_QWORD *)(v8 + 112 * (v7 % 0x24) + 88);
        if (v9 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1[1].i64[0] + 32))(a1[1].i64[0], a2))
          break;
      }
    }
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::_pop_front(a1);
    ++v4;
  }
  while (a1[4].i64[1]);
  return v4;
}

void HGPool::EntryTrace<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::trace(uint64_t a1)
{
  void *__p;
  char v3;

  HGPool::DescriptorString<HGMetalTextureWrapperInfinipool::Descriptor>::str(a1 + 16);
  if (*(_BYTE *)(a1 + 104))
  {
    if ((v3 & 0x80000000) == 0)
      return;
LABEL_5:
    operator delete(__p);
    return;
  }
  std::chrono::steady_clock::now();
  if (v3 < 0)
    goto LABEL_5;
}

void sub_1B2A8A88C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,true>::log(_QWORD *a1, HGLogger *a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  __int128 *v7;
  unint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 *v14;
  HGLoggerUtils *v15;
  const char *v16;
  char *v17;
  unsigned __int8 v18;
  void **v19;
  unint64_t v20;
  void *__p[2];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;

  if (a1[9])
  {
    HGLogger::indent(1);
    v4 = a1[5];
    if (a1[6] != v4)
    {
      v5 = a1[8];
      v6 = (_QWORD *)(v4 + 8 * (v5 / 0x24));
      v7 = (__int128 *)(*v6 + 112 * (v5 % 0x24));
      v8 = *(_QWORD *)(v4 + 8 * ((a1[9] + v5) / 0x24)) + 112 * ((a1[9] + v5) % 0x24);
      while (v7 != (__int128 *)v8)
      {
        v9 = *v7;
        v10 = v7[2];
        v22 = v7[1];
        v23 = v10;
        *(_OWORD *)__p = v9;
        v11 = v7[3];
        v12 = v7[4];
        v13 = v7[6];
        v26 = v7[5];
        v27 = v13;
        v24 = v11;
        v25 = v12;
        HGPool::EntryLog<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 7;
        if ((__int128 *)((char *)v7 - *v6) == (__int128 *)4032)
        {
          v14 = (__int128 *)v6[1];
          ++v6;
          v7 = v14;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    v15 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v15);
    v18 = atomic_load(HGLogger::_enabled);
    if ((v18 & 1) != 0)
    {
      if ((SBYTE7(v22) & 0x80u) == 0)
        v19 = __p;
      else
        v19 = (void **)__p[0];
      v20 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v16, v17, v19, v20);
    }
    if (SBYTE7(v22) < 0)
      operator delete(__p[0]);
  }
}

void sub_1B2A8AA20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::log(_QWORD *a1, HGLogger *a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  __int128 *v7;
  unint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 *v14;
  HGLoggerUtils *v15;
  const char *v16;
  char *v17;
  unsigned __int8 v18;
  void **v19;
  unint64_t v20;
  void *__p[2];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;

  if (a1[9])
  {
    HGLogger::indent(1);
    v4 = a1[5];
    if (a1[6] != v4)
    {
      v5 = a1[8];
      v6 = (_QWORD *)(v4 + 8 * (v5 / 0x24));
      v7 = (__int128 *)(*v6 + 112 * (v5 % 0x24));
      v8 = *(_QWORD *)(v4 + 8 * ((a1[9] + v5) / 0x24)) + 112 * ((a1[9] + v5) % 0x24);
      while (v7 != (__int128 *)v8)
      {
        v9 = *v7;
        v10 = v7[2];
        v22 = v7[1];
        v23 = v10;
        *(_OWORD *)__p = v9;
        v11 = v7[3];
        v12 = v7[4];
        v13 = v7[6];
        v26 = v7[5];
        v27 = v13;
        v24 = v11;
        v25 = v12;
        HGPool::EntryLog<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 7;
        if ((__int128 *)((char *)v7 - *v6) == (__int128 *)4032)
        {
          v14 = (__int128 *)v6[1];
          ++v6;
          v7 = v14;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    v15 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v15);
    v18 = atomic_load(HGLogger::_enabled);
    if ((v18 & 1) != 0)
    {
      if ((SBYTE7(v22) & 0x80u) == 0)
        v19 = __p;
      else
        v19 = (void **)__p[0];
      v20 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v16, v17, v19, v20);
    }
    if (SBYTE7(v22) < 0)
      operator delete(__p[0]);
  }
}

void sub_1B2A8ABB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGPool::EntryLog<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::log(uint64_t *a1, HGLogger *a2, const char *a3)
{
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  unsigned __int8 v10;
  void **v11;
  void **v12;
  std::chrono::steady_clock::time_point v13;
  const char *v14;
  char *v15;
  unsigned __int8 v16;
  void **v17;
  void *p_p;
  void **v19;
  void *__p;
  char v21;
  void *v22[2];
  char v23;
  void *v24[2];
  char v25;

  v6 = *a1;
  v7 = (uint64_t)(a1 + 2);
  HGLoggerUtils::bytesPrettyString((HGLoggerUtils *)a1[3]);
  HGPool::DescriptorString<HGMetalTextureWrapperInfinipool::Descriptor>::str(v7);
  if (*((_BYTE *)a1 + 104))
  {
    v10 = atomic_load(HGLogger::_enabled);
    if ((v10 & 1) != 0)
    {
      v11 = v24;
      if (v25 < 0)
        v11 = (void **)v24[0];
      v12 = v22;
      if (v23 < 0)
        v12 = (void **)v22[0];
      HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu   %s\n", v8, v9, v6, v11, a1[12], v12);
    }
    goto LABEL_17;
  }
  v13.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  HGLoggerUtils::timePrettyString((HGLoggerUtils *)(v13.__d_.__rep_ - a1[11]));
  v16 = atomic_load(HGLogger::_enabled);
  if ((v16 & 1) != 0)
  {
    v17 = v24;
    if (v25 < 0)
      v17 = (void **)v24[0];
    p_p = &__p;
    if (v21 < 0)
      p_p = __p;
    v19 = v22;
    if (v23 < 0)
      v19 = (void **)v22[0];
    HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu  %10s   %s\n", v14, v15, v6, v17, a1[12], p_p, v19);
  }
  if ((v21 & 0x80000000) == 0)
  {
LABEL_17:
    if ((v23 & 0x80000000) == 0)
      goto LABEL_18;
    goto LABEL_21;
  }
  operator delete(__p);
  if ((v23 & 0x80000000) == 0)
  {
LABEL_18:
    if ((v25 & 0x80000000) == 0)
      return;
LABEL_22:
    operator delete(v24[0]);
    return;
  }
LABEL_21:
  operator delete(v22[0]);
  if (v25 < 0)
    goto LABEL_22;
}

void sub_1B2A8AD6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  uint64_t v25;

  if (a19 < 0)
  {
    operator delete(__p);
    if ((a25 & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v25 - 49) & 0x80000000) == 0)
        goto LABEL_4;
      goto LABEL_7;
    }
  }
  else if ((a25 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a20);
  if ((*(char *)(v25 - 49) & 0x80000000) == 0)
LABEL_4:
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(*(void **)(v25 - 72));
  _Unwind_Resume(exception_object);
}

_QWORD *HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::retrieveObject@<X0>(int64x2_t *a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v6;
  uint64_t v7;
  __int128 v8;
  char *v9;
  __int128 v10;
  __int128 v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *result;
  uint64_t v17;
  _BYTE v18[24];
  _BYTE *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  _QWORD v25[3];
  _QWORD *v26;
  _BYTE v27[24];
  _BYTE *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v6 = a2[3];
  v31 = a2[2];
  v32 = v6;
  v7 = *((_QWORD *)a2 + 8);
  v28 = 0;
  v33 = v7;
  v8 = a2[1];
  v29 = *a2;
  v30 = v8;
  v19 = 0;
  v22 = v31;
  v23 = v6;
  v24 = v7;
  v21 = v8;
  v20 = v29;
  v26 = 0;
  v9 = (char *)operator new(0x70uLL);
  *(_QWORD *)v9 = &off_1E6526768;
  *((_QWORD *)v9 + 4) = 0;
  v10 = *a2;
  *(_OWORD *)(v9 + 56) = a2[1];
  v11 = a2[3];
  *(_OWORD *)(v9 + 72) = a2[2];
  *(_OWORD *)(v9 + 88) = v11;
  *((_QWORD *)v9 + 13) = *((_QWORD *)a2 + 8);
  *(_OWORD *)(v9 + 40) = v10;
  v26 = v9;
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::_retrieve(a1, v25, a3);
  v12 = v26;
  if (v26 == v25)
  {
    v13 = 4;
    v12 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_6;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_6:
  v14 = v19;
  if (v19 == v18)
  {
    v15 = 4;
    v14 = v18;
  }
  else
  {
    if (!v19)
      goto LABEL_11;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_11:
  result = v28;
  if (v28 == v27)
  {
    v17 = 4;
    result = v27;
  }
  else
  {
    if (!v28)
      return result;
    v17 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v17))();
}

void sub_1B2A8AFD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char *a26,char a27,uint64_t a28,uint64_t a29,char *a30)
{
  char *v30;
  char *v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;

  v32 = a26;
  if (a26 == v30)
  {
    v33 = 4;
    v32 = &a23;
  }
  else
  {
    if (!a26)
      goto LABEL_6;
    v33 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v32 + 8 * v33))();
LABEL_6:
  v34 = a13;
  if (a13 == &a10)
  {
    v35 = 4;
    v34 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_11;
    v35 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v34 + 8 * v35))();
LABEL_11:
  v36 = a30;
  if (a30 == &a27)
  {
    v37 = 4;
    v36 = &a27;
  }
  else
  {
    if (!a30)
      goto LABEL_16;
    v37 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v36 + 8 * v37))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

void **HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::_retrieve@<X0>(int64x2_t *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void **result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  _BYTE v33[24];
  void **v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a3 + 96) = 0;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_BYTE *)(a3 + 104) = 1;
  v5 = a1[4].u64[0];
  v6 = v5 + a1[4].i64[1];
  v7 = v6 / 0x24;
  v8 = a1[2].i64[1];
  if (a1[3].i64[0] != v8)
  {
    v9 = *(_QWORD *)(v8 + 8 * v7) + 112 * (v6 % 0x24);
    v10 = *(_QWORD *)(v8 + 8 * (v5 / 0x24)) + 112 * (v5 % 0x24);
    v11 = (_QWORD *)a2[3];
    if (v11)
      goto LABEL_3;
LABEL_6:
    v34 = 0;
    goto LABEL_8;
  }
  v9 = 0;
  v10 = 0;
  v11 = (_QWORD *)a2[3];
  if (!v11)
    goto LABEL_6;
LABEL_3:
  if (v11 == a2)
  {
    v34 = (void **)v33;
    (*(void (**)(_QWORD *, _BYTE *))(*a2 + 24))(a2, v33);
  }
  else
  {
    v34 = (void **)(*(uint64_t (**)(_QWORD *))(*v11 + 16))(v11);
  }
LABEL_8:
  v12 = (uint64_t *)(v8 + 8 * v7);
  if (v9 != v10)
  {
    v13 = *v12;
    while (1)
    {
      v14 = v9;
      if (v9 == v13)
        v14 = *(v12 - 1) + 4032;
      if (!v34)
        std::__throw_bad_function_call[abi:ne180100]();
      if (((*((uint64_t (**)(void **, uint64_t))*v34 + 6))(v34, v14 - 112) & 1) != 0)
        break;
      v13 = *v12;
      if (v9 == *v12)
      {
        v15 = *--v12;
        v13 = v15;
        v9 = v15 + 4032;
      }
      v9 -= 112;
      if (v9 == v10)
      {
        v9 = v10;
        break;
      }
    }
  }
  result = v34;
  if (v34 == (void **)v33)
  {
    v17 = 4;
    result = (void **)v33;
  }
  else
  {
    if (!v34)
      goto LABEL_23;
    v17 = 5;
  }
  result = (void **)(*((uint64_t (**)(void))*result + v17))();
LABEL_23:
  v18 = a1[2].i64[1];
  if (a1[3].i64[0] == v18)
  {
    if (!v9)
      return result;
  }
  else if (v9 == *(_QWORD *)(v18 + 8 * (a1[4].i64[0] / 0x24uLL)) + 112 * (a1[4].i64[0] % 0x24uLL))
  {
    return result;
  }
  v19 = v9 - *v12;
  v20 = 0x6DB6DB6DB6DB6DB7 * (v19 >> 4);
  if (v19 < 113)
  {
    v24 = 36 - v20;
    v22 = &v12[-(v24 / 0x24)];
    v23 = *v22 + 112 * (36 * (v24 / 0x24) - v24) + 3920;
  }
  else
  {
    v21 = v20 - 1;
    v22 = &v12[v21 / 0x24];
    v23 = *v22 + 112 * (v21 % 0x24);
  }
  v25 = *(_OWORD *)(v23 + 80);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(v23 + 64);
  *(_OWORD *)(a3 + 80) = v25;
  *(_OWORD *)(a3 + 89) = *(_OWORD *)(v23 + 89);
  v26 = *(_OWORD *)(v23 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v23;
  *(_OWORD *)(a3 + 16) = v26;
  v27 = *(_OWORD *)(v23 + 48);
  v28 = (unint64_t *)&a1[5];
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v23 + 32);
  *(_OWORD *)(a3 + 48) = v27;
  do
    v29 = __ldaxr(v28);
  while (__stlxr(v29 - 1, v28));
  v30 = *(_QWORD *)(a3 + 24);
  v31 = &a1[5].u64[1];
  do
    v32 = __ldaxr(v31);
  while (__stlxr(v32 - v30, v31));
  return std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::erase(a1 + 2, v22, (char *)v23);
}

void sub_1B2A8B38C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10)
  {
    (*(void (**)(void))(a10 + 32))();
    _Unwind_Resume(exception_object);
  }
  if (!a13)
    _Unwind_Resume(exception_object);
  (*(void (**)(void))(*a13 + 40))();
  _Unwind_Resume(exception_object);
}

