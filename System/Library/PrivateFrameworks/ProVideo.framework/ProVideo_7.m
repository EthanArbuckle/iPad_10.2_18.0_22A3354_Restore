void sub_1B2AF3C34(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2AF3C4C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGSynchronizable *HGRenderQueue::ReleasePBOToSharedPool(HGRenderQueue *this, HGPixelBufferObj *a2)
{
  int VirtualScreen;
  uint64_t v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t **v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  float v14;
  HGSynchronizable *v15;
  PCSharedCount v17;
  HGGLContext *v18;
  HGSynchronizable *v19;
  char v20;

  v19 = (HGSynchronizable *)*((_QWORD *)this + 80);
  v20 = 0;
  HGSynchronizable::Lock(v19);
  (*(void (**)(HGPixelBufferObj *))(*(_QWORD *)a2 + 24))(a2);
  if ((*((_BYTE *)this + 69) & 0x10) == 0)
    goto LABEL_14;
  v17.var0 = *(PC_Sp_counted_base **)(*((_QWORD *)a2 + 2) + 8);
  HGGLContext::Share((uint64_t *)&v17, (HGObject **)&v18);
  PCSharedCount::PCSharedCount(&v17);
  VirtualScreen = HGGLContext::getVirtualScreen(v18);
  v5 = mach_absolute_time();
  v6 = (uint64_t *)*((_QWORD *)this + 78);
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v6;
        v9 = v6[4];
        if (v9 <= (unint64_t)a2)
          break;
        v6 = *v8;
        v7 = v8;
        if (!*v8)
          goto LABEL_9;
      }
      if (v9 >= (unint64_t)a2)
        break;
      v6 = v8[1];
      if (!v6)
      {
        v7 = v8 + 1;
        goto LABEL_9;
      }
    }
    v13 = (uint64_t)v8[5];
    if (qword_1ED4DAB18 == -1)
      goto LABEL_12;
  }
  else
  {
    v7 = (uint64_t **)((char *)this + 624);
    v8 = (uint64_t **)((char *)this + 624);
LABEL_9:
    v10 = (uint64_t *)operator new(0x30uLL);
    v10[4] = (uint64_t)a2;
    v10[5] = 0;
    *v10 = 0;
    v10[1] = 0;
    v10[2] = (uint64_t)v8;
    *v7 = v10;
    v11 = **((_QWORD **)this + 77);
    v12 = v10;
    if (v11)
    {
      *((_QWORD *)this + 77) = v11;
      v12 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 78), v12);
    ++*((_QWORD *)this + 79);
    v13 = v10[5];
    if (qword_1ED4DAB18 == -1)
      goto LABEL_12;
  }
  dispatch_once(&qword_1ED4DAB18, &__block_literal_global_86);
LABEL_12:
  v14 = *(double *)&qword_1ED4DAB10 * (double)(v5 - v13);
  printf("ReleasePBOToSharedPool:<%p>: Checkin to pool vs: %d time: %5.1f (ms)\n", a2, VirtualScreen, (float)(v14 * 1000.0));
  if (v18)
    (*(void (**)(HGGLContext *))(*(_QWORD *)v18 + 24))(v18);
LABEL_14:
  HGSynchronizable::Unlock(v19);
  v15 = (HGSynchronizable *)*((_QWORD *)this + 63);
  v19 = v15;
  v20 = 0;
  HGSynchronizable::Lock(v15);
  HGSynchronizable::NotifyAll(v15);
  return HGSynchronizable::Unlock(v15);
}

void sub_1B2AF3E48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, PCSharedCount a13, uint64_t a14, HGSynchronizable *a15)
{
  if (a14)
    (*(void (**)(uint64_t))(*(_QWORD *)a14 + 24))(a14);
  HGSynchronizer::~HGSynchronizer(&a15);
  _Unwind_Resume(a1);
}

uint64_t **std::map<HGPixelBufferObj *,unsigned long long>::operator[](uint64_t **a1, uint64_t **a2)
{
  uint64_t *v3;
  uint64_t **v4;
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;

  v4 = a1 + 1;
  v3 = a1[1];
  v5 = *a2;
  if (v3)
  {
    while (1)
    {
      while (1)
      {
        v6 = (uint64_t **)v3;
        v7 = v3[4];
        if ((unint64_t)v5 >= v7)
          break;
        v3 = *v6;
        v4 = v6;
        if (!*v6)
          goto LABEL_8;
      }
      if (v7 >= (unint64_t)v5)
        break;
      v3 = v6[1];
      if (!v3)
      {
        v4 = v6 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    v6 = a1 + 1;
LABEL_8:
    v8 = (uint64_t *)v6;
    v6 = (uint64_t **)operator new(0x30uLL);
    v6[4] = v5;
    v6[5] = 0;
    *v6 = 0;
    v6[1] = 0;
    v6[2] = v8;
    *v4 = (uint64_t *)v6;
    v9 = (uint64_t *)**a1;
    v10 = (uint64_t *)v6;
    if (v9)
    {
      *a1 = v9;
      v10 = *v4;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v6 + 5;
}

uint64_t HGRenderQueue::DeleteHGGLTexture(HGRenderQueue *this, HGGLTexture *a2)
{
  if (*((_QWORD *)a2 + 16))
    return HGRenderQueue::EnqueueDeleteHGGLTexture(this, a2);
  (*(void (**)(HGGLTexture *))(*(_QWORD *)a2 + 24))(a2);
  return 0;
}

uint64_t HGRenderQueue::EnqueueDeleteHGGLTexture(HGRenderQueue *this, HGGLTexture *a2)
{
  uint64_t i;
  HGRenderNode *v5;
  HGRenderJob *v6;
  uint64_t v7;

  for (i = *((_QWORD *)this + 13); (HGRenderQueue *)i != (HGRenderQueue *)((char *)this + 96); i = *(_QWORD *)(i + 8))
  {
    if (*(_QWORD *)(*(_QWORD *)(i + 16) + 56) == *((_QWORD *)a2 + 16))
      break;
  }
  v5 = (HGRenderNode *)HGObject::operator new(0xD0uLL);
  HGRenderNode::HGRenderNode(v5);
  HGRenderNode::SetBitmap(v5, (HGBitmap *)a2);
  HGRenderNode::SetRenderer((uint64_t)v5, *((HGRenderer **)a2 + 16));
  (*(void (**)(HGGLTexture *))(*(_QWORD *)a2 + 24))(a2);
  v6 = (HGRenderJob *)HGObject::operator new(0x160uLL);
  HGRenderJob::HGRenderJob(v6);
  HGUserJob::SetPriority((uint64_t)v6, 6);
  HGRenderJob::AddRenderNodeInternal(v6, v5);
  HGRenderJob::SetRenderer(v6, *((HGRenderer **)a2 + 16));
  HGRenderJob::SetPriority((uint64_t)v6, 12);
  v7 = HGRenderQueue::EnqueueRenderJob(this, v6);
  if ((_DWORD)v7)
  {
    (*(void (**)(HGGLTexture *))(*(_QWORD *)a2 + 16))(a2);
    HGRenderNode::SetBitmap(v5, 0);
  }
  (*(void (**)(HGRenderJob *))(*(_QWORD *)v6 + 24))(v6);
  (*(void (**)(HGRenderNode *))(*(_QWORD *)v5 + 24))(v5);
  return v7;
}

void sub_1B2AF40C4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2AF40DC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::FindIdleRenderExecUnitForJobWithPreferredVirtualScreen(HGRenderQueue *this, HGRenderJob *a2)
{
  HGRenderJob *v2;
  HGGPUComputeDevice *v4;
  int GLVirtualScreen;
  char *v6;
  uint64_t v7;
  const struct __class_type_info *v8;
  const struct __class_type_info *v9;
  uint64_t v10;
  const void *v11;
  PVRenderJob *v12;
  uint64_t FrameStats;
  HGGPUComputeDevice *v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  int v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t **v21;
  uint64_t *v22;
  uint64_t **v23;
  int v24;
  HGRenderJob *v25;
  const struct __class_type_info *v26;
  const struct __class_type_info *v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t *v30;
  HGRenderQueue *v32;
  uint64_t **v33;

  v2 = a2;
  v4 = (HGGPUComputeDevice *)*((_QWORD *)a2 + 10);
  if (v4)
  {
    GLVirtualScreen = HGGPUComputeDevice::GetGLVirtualScreen(v4);
    v6 = (char *)this + 96;
    v7 = *((_QWORD *)this + 13);
    if ((HGRenderQueue *)v7 == (HGRenderQueue *)((char *)this + 96))
      return 0;
    goto LABEL_5;
  }
  GLVirtualScreen = *((_DWORD *)a2 + 48);
  v6 = (char *)this + 96;
  v7 = *((_QWORD *)this + 13);
  if ((HGRenderQueue *)v7 != (HGRenderQueue *)((char *)this + 96))
  {
LABEL_5:
    v32 = this;
    v33 = (uint64_t **)((char *)this + 208);
    while (1)
    {
      v10 = *(_QWORD *)(v7 + 16);
      if (!HGRenderExecUnit::IsGPU((HGRenderExecUnit *)v10)
        || (*(_DWORD *)(v10 + 24) - 1) > 1
        || !HGRenderExecUnit::CanPerformJobType(v10, *((_DWORD *)v2 + 3)))
      {
        goto LABEL_6;
      }
      v11 = *(const void **)(v10 + 48);
      if (!v11)
        break;
      v12 = (PVRenderJob *)__dynamic_cast(v11, v8, v9, 0);
      if (v12)
      {
        FrameStats = PVRenderJob::GetFrameStats(v12);
        v14 = *(HGGPUComputeDevice **)FrameStats;
        v15 = *(std::__shared_weak_count **)(FrameStats + 8);
        if (v15)
        {
          p_shared_owners = (unint64_t *)&v15->__shared_owners_;
          do
            v17 = __ldxr(p_shared_owners);
          while (__stxr(v17 + 1, p_shared_owners));
        }
        v18 = HGGPUComputeDevice::GetGLVirtualScreen(v14);
        if (v15)
        {
          v19 = (unint64_t *)&v15->__shared_owners_;
          do
            v20 = __ldaxr(v19);
          while (__stlxr(v20 - 1, v19));
          if (!v20)
          {
            ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
            std::__shared_weak_count::__release_weak(v15);
            if (v18 != GLVirtualScreen)
              goto LABEL_6;
            goto LABEL_23;
          }
        }
        goto LABEL_22;
      }
      if (GLVirtualScreen != -1)
        goto LABEL_6;
LABEL_23:
      v21 = v33;
      while (1)
      {
        v22 = *v21;
        v23 = v21;
        if (!*v21)
          break;
        while (1)
        {
          v21 = (uint64_t **)v22;
          v24 = *((_DWORD *)v22 + 7);
          if (GLVirtualScreen < v24)
            break;
          if (v24 >= GLVirtualScreen)
            goto LABEL_32;
          v22 = v21[1];
          if (!v22)
          {
            v23 = v21 + 1;
            goto LABEL_29;
          }
        }
      }
LABEL_29:
      v25 = v2;
      v26 = v9;
      v27 = v8;
      v28 = (uint64_t *)v21;
      v21 = (uint64_t **)operator new(0x28uLL);
      *((_DWORD *)v21 + 7) = GLVirtualScreen;
      *((_BYTE *)v21 + 32) = 0;
      *v21 = 0;
      v21[1] = 0;
      v21[2] = v28;
      *v23 = (uint64_t *)v21;
      v29 = **((_QWORD **)v32 + 25);
      v30 = (uint64_t *)v21;
      if (v29)
      {
        *((_QWORD *)v32 + 25) = v29;
        v30 = *v23;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v32 + 26), v30);
      ++*((_QWORD *)v32 + 27);
      v8 = v27;
      v9 = v26;
      v2 = v25;
LABEL_32:
      if (!*((_BYTE *)v21 + 32) && !HGRenderExecUnit::NumEnqueuedRenderJobs((HGRenderExecUnit *)v10))
        return 1;
LABEL_6:
      v7 = *(_QWORD *)(v7 + 8);
      if ((char *)v7 == v6)
        return 0;
    }
    v18 = -1;
LABEL_22:
    if (v18 != GLVirtualScreen)
      goto LABEL_6;
    goto LABEL_23;
  }
  return 0;
}

void sub_1B2AF4338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::NotifyIdleRenderUnits(HGRenderQueue *this)
{
  unsigned int *v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  float v6;
  HGSynchronizable *v7;
  HGSynchronizable *v8;
  uint64_t result;

  v2 = (unsigned int *)((char *)this + 80);
  do
    __ldaxr(v2);
  while (__stlxr(0, v2));
  v3 = atomic_load((unint64_t *)this + 24);
  if (v3 && (*((_BYTE *)this + 68) & 2) != 0)
  {
    v4 = mach_absolute_time();
    v5 = atomic_load((unint64_t *)this + 24);
    if (qword_1ED4DAB18 != -1)
      dispatch_once(&qword_1ED4DAB18, &__block_literal_global_86);
    v6 = *(double *)&qword_1ED4DAB10 * (double)(v4 - v5) * 1000.0;
    printf("HGRenderQueue::NotifyIdleRenderUnits: Elapsed time: %7.1f (ms)\n", v6);
  }
  v7 = (HGSynchronizable *)*((_QWORD *)this + 16);
  HGSynchronizable::Lock(v7);
  HGSynchronizable::NotifyAll(v7);
  HGSynchronizable::Unlock(v7);
  v8 = (HGSynchronizable *)*((_QWORD *)this + 15);
  HGSynchronizable::Lock(v8);
  HGSynchronizable::NotifyAll(v8);
  HGSynchronizable::Unlock(v8);
  result = mach_absolute_time();
  atomic_store(result, (unint64_t *)this + 24);
  return result;
}

void sub_1B2AF4468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF4480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

BOOL HGRenderQueue::GetThrottleFlagOnVirtualScreen(HGRenderQueue *this, int a2)
{
  uint64_t *v4;
  uint64_t **v5;
  uint64_t **v6;
  int v7;
  uint64_t v8;
  uint64_t *v9;
  _DWORD *v10;
  int v11;
  HGSynchronizable *v13;

  v13 = (HGSynchronizable *)*((_QWORD *)this + 43);
  HGSynchronizable::Lock(v13);
  v5 = (uint64_t **)((char *)this + 208);
  v4 = (uint64_t *)*((_QWORD *)this + 26);
  if (v4)
  {
    do
    {
      while (1)
      {
        v6 = (uint64_t **)v4;
        v7 = *((_DWORD *)v4 + 7);
        if (v7 <= a2)
          break;
        v4 = *v6;
        v5 = v6;
        if (!*v6)
          goto LABEL_9;
      }
      if (v7 >= a2)
      {
        v10 = v6;
        goto LABEL_12;
      }
      v4 = v6[1];
    }
    while (v4);
    v5 = v6 + 1;
  }
  else
  {
    v6 = (uint64_t **)((char *)this + 208);
  }
LABEL_9:
  v10 = operator new(0x28uLL);
  v10[7] = a2;
  *((_BYTE *)v10 + 32) = 0;
  *(_QWORD *)v10 = 0;
  *((_QWORD *)v10 + 1) = 0;
  *((_QWORD *)v10 + 2) = v6;
  *v5 = (uint64_t *)v10;
  v8 = **((_QWORD **)this + 25);
  v9 = (uint64_t *)v10;
  if (v8)
  {
    *((_QWORD *)this + 25) = v8;
    v9 = *v5;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 26), v9);
  ++*((_QWORD *)this + 27);
LABEL_12:
  v11 = *((unsigned __int8 *)v10 + 32);
  HGSynchronizable::Unlock(v13);
  return v11 != 0;
}

void sub_1B2AF4584(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
  HGSynchronizer::~HGSynchronizer(&a9);
  _Unwind_Resume(a1);
}

HGSynchronizable *HGRenderQueue::SetThrottleFlagOnVirtualScreen(HGRenderQueue *this, int a2, char a3)
{
  char *v6;
  uint64_t **v7;
  uint64_t **v8;
  int v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t *v12;
  HGSynchronizable *v14;

  v14 = (HGSynchronizable *)*((_QWORD *)this + 43);
  HGSynchronizable::Lock(v14);
  v7 = (uint64_t **)((char *)this + 208);
  v6 = (char *)*((_QWORD *)this + 26);
  if (!v6)
  {
    v8 = (uint64_t **)((char *)this + 208);
LABEL_8:
    v10 = operator new(0x28uLL);
    v10[7] = a2;
    *((_BYTE *)v10 + 32) = 0;
    *(_QWORD *)v10 = 0;
    *((_QWORD *)v10 + 1) = 0;
    *((_QWORD *)v10 + 2) = v8;
    *v7 = (uint64_t *)v10;
    v11 = **((_QWORD **)this + 25);
    v12 = (uint64_t *)v10;
    if (v11)
    {
      *((_QWORD *)this + 25) = v11;
      v12 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 26), v12);
    ++*((_QWORD *)this + 27);
    *((_BYTE *)v10 + 32) = a3;
    if ((a3 & 1) != 0)
      return HGSynchronizable::Unlock(v14);
LABEL_13:
    HGSynchronizable::NotifyAll(*((HGSynchronizable **)this + 16));
    return HGSynchronizable::Unlock(v14);
  }
  while (1)
  {
    while (1)
    {
      v8 = (uint64_t **)v6;
      v9 = *((_DWORD *)v6 + 7);
      if (v9 <= a2)
        break;
      v6 = (char *)*v8;
      v7 = v8;
      if (!*v8)
        goto LABEL_8;
    }
    if (v9 >= a2)
      break;
    v6 = (char *)v8[1];
    if (!v6)
    {
      v7 = v8 + 1;
      goto LABEL_8;
    }
  }
  *((_BYTE *)v8 + 32) = a3;
  if ((a3 & 1) == 0)
    goto LABEL_13;
  return HGSynchronizable::Unlock(v14);
}

void sub_1B2AF46A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
  HGSynchronizer::~HGSynchronizer(&a9);
  _Unwind_Resume(a1);
}

BOOL HGRenderQueue::GetLockFlagOnVirtualScreen(HGRenderQueue *this, int a2)
{
  uint64_t *v4;
  uint64_t **v5;
  uint64_t **v6;
  int v7;
  uint64_t v8;
  uint64_t *v9;
  _DWORD *v10;
  int v11;
  HGSynchronizable *v13;

  v13 = (HGSynchronizable *)*((_QWORD *)this + 43);
  HGSynchronizable::Lock(v13);
  v5 = (uint64_t **)((char *)this + 232);
  v4 = (uint64_t *)*((_QWORD *)this + 29);
  if (v4)
  {
    do
    {
      while (1)
      {
        v6 = (uint64_t **)v4;
        v7 = *((_DWORD *)v4 + 7);
        if (v7 <= a2)
          break;
        v4 = *v6;
        v5 = v6;
        if (!*v6)
          goto LABEL_9;
      }
      if (v7 >= a2)
      {
        v10 = v6;
        goto LABEL_12;
      }
      v4 = v6[1];
    }
    while (v4);
    v5 = v6 + 1;
  }
  else
  {
    v6 = (uint64_t **)((char *)this + 232);
  }
LABEL_9:
  v10 = operator new(0x28uLL);
  v10[7] = a2;
  *((_BYTE *)v10 + 32) = 0;
  *(_QWORD *)v10 = 0;
  *((_QWORD *)v10 + 1) = 0;
  *((_QWORD *)v10 + 2) = v6;
  *v5 = (uint64_t *)v10;
  v8 = **((_QWORD **)this + 28);
  v9 = (uint64_t *)v10;
  if (v8)
  {
    *((_QWORD *)this + 28) = v8;
    v9 = *v5;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 29), v9);
  ++*((_QWORD *)this + 30);
LABEL_12:
  v11 = *((unsigned __int8 *)v10 + 32);
  HGSynchronizable::Unlock(v13);
  return v11 != 0;
}

void sub_1B2AF47A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
  HGSynchronizer::~HGSynchronizer(&a9);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::GetRenderJob(HGRenderQueue *this, HGRenderExecUnit *a2, HGRenderJob **a3)
{
  uint64_t v6;
  HGSynchronizable *v7;
  unsigned int *v8;
  uint64_t RenderJobFromQueue;
  const char *LUTEnd;
  HGSynchronizable *v11;
  unint64_t v12;
  _BOOL4 v13;
  unsigned int v14;
  NSObject *global_queue;
  dispatch_time_t v16;
  HGSynchronizable *v17;
  int v18;
  HGSynchronizable *v19;
  uint64_t v20;
  uint64_t v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  double v25;
  const char *v26;
  float v27;
  float v28;
  _QWORD block[5];
  HGSynchronizable *v31;
  char v32;

  v6 = 120;
  if (!*((_DWORD *)a2 + 10))
    v6 = 128;
  v7 = *(HGSynchronizable **)((char *)this + v6);
  v31 = v7;
  v32 = 0;
  HGSynchronizable::Lock(v7);
  v8 = (unsigned int *)((char *)this + 80);
  while (1)
  {
    RenderJobFromQueue = HGRenderQueue::GetRenderJobFromQueue(this, a2, a3);
    if ((RenderJobFromQueue & 1) != 0)
      break;
    if (*((_DWORD *)a2 + 6) != 4)
    {
      *((_DWORD *)a2 + 6) = 1;
      *((_QWORD *)a2 + 12) = mach_absolute_time();
      if ((*((_BYTE *)this + 68) & 1) != 0)
      {
        LUTEnd = (const char *)PCICCTransferFunctionLUT::getLUTEnd(a2);
        printf("%s : going idle\n", LUTEnd);
      }
      v11 = (HGSynchronizable *)*((_QWORD *)this + 43);
      HGSynchronizable::Lock(v11);
      v12 = *((_QWORD *)this + 4) + 1;
      *((_QWORD *)this + 4) = v12;
      v13 = *((_QWORD *)this + 42)
         && v12 >= 2
         && *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 38)
                                              + ((*((_QWORD *)this + 41) >> 6) & 0x3FFFFFFFFFFFFF8))
                                  + 8 * (*((_QWORD *)this + 41) & 0x1FFLL))
                      + 104) >= *((_DWORD *)this + 14);
      HGSynchronizable::Unlock(v11);
      if (v13)
      {
        do
          v14 = __ldaxr(v8);
        while (__stlxr(v14 | 1, v8));
        if (!v14)
        {
          global_queue = dispatch_get_global_queue(0, 0);
          dispatch_group_enter(*((dispatch_group_t *)this + 93));
          v16 = dispatch_time(0, 2000000);
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 0x40000000;
          block[2] = ___ZN13HGRenderQueue12GetRenderJobEP16HGRenderExecUnitPP11HGRenderJob_block_invoke;
          block[3] = &__block_descriptor_tmp_38;
          block[4] = this;
          dispatch_after(v16, global_queue, block);
        }
      }
    }
    v7 = v31;
    HGSynchronizable::Wait(v31);
    v17 = (HGSynchronizable *)*((_QWORD *)this + 43);
    HGSynchronizable::Lock(v17);
    v18 = *((_DWORD *)this + 4);
    HGSynchronizable::Unlock(v17);
    if (v18 == 3)
      goto LABEL_26;
    if (*((_DWORD *)a2 + 6) != 4)
    {
      v19 = (HGSynchronizable *)*((_QWORD *)this + 43);
      HGSynchronizable::Lock(v19);
      --*((_QWORD *)this + 4);
      HGSynchronizable::Unlock(v19);
      *((_DWORD *)a2 + 6) = 2;
      *((_QWORD *)a2 + 13) = mach_absolute_time();
      if ((*((_BYTE *)this + 68) & 2) != 0
        && HGRenderExecUnit::IsGPU(a2)
        && (*(_DWORD *)(*((_QWORD *)a2 + 6) + 40) | 2) == 2)
      {
        v20 = mach_absolute_time();
        v21 = *((_QWORD *)this + 11);
        if (qword_1ED4DAB18 != -1)
          dispatch_once(&qword_1ED4DAB18, &__block_literal_global_86);
        v22 = *(double *)&qword_1ED4DAB10;
        v23 = *((_QWORD *)a2 + 12);
        v24 = *((_QWORD *)a2 + 13);
        v25 = *(double *)&qword_1ED4DAB10;
        v26 = (const char *)PCICCTransferFunctionLUT::getLUTEnd(a2);
        v27 = v25 * (double)(unint64_t)(v24 - v23) * 1000.0;
        v28 = v22 * (double)(v20 - v21) * 1000.0;
        printf("%s : woke up : %5.2f (ms) :  queue time : %6.1f (ms) : ", v26, v27, v28);
        HGRenderQueue::DumpRenderJobQueues(this);
      }
    }
  }
  *((_DWORD *)a2 + 6) = 3;
LABEL_26:
  if (!v32)
    HGSynchronizable::Unlock(v7);
  return RenderJobFromQueue;
}

void sub_1B2AF4AD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF4AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF4B00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF4B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::GetRenderJobFromQueue(HGRenderQueue *this, HGRenderExecUnit *a2, HGRenderJob **a3)
{
  _DWORD *v6;
  uint64_t v7;
  PVRenderJob *v9;
  uint64_t *FrameStats;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  HGRenderJob **v15;
  uint64_t v16;
  unint64_t v17;
  HGRenderJob *v18;
  HGRenderJob *v19;
  const char *TypeLabel;
  int v21;
  _BOOL4 v22;
  _BOOL4 v23;
  int IsRequestedVirtualScreen;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  _BOOL4 IsGPU;
  _BOOL4 v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  _BOOL4 v34;
  HGRenderJob *v35;
  uint64_t v36;
  HGObject *v37;
  uint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  HGRenderJob *v41;
  HGObject *v42;
  uint64_t v43;
  uint64_t v44;
  HGObject *v45;
  uint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  BOOL v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  HGObject *v53;
  uint64_t v54;
  unint64_t *v55;
  unint64_t v56;
  int v57;
  unsigned int v58;
  HGObject *v59;
  HGRenderExecUnit *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  const char *LUTEnd;
  const char *UserName;
  HGRenderJob **v68;
  _QWORD *v69;
  uint64_t v70;
  HGRenderJob *v71;
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  const char *v75;
  const char *v76;
  HGRenderJob *v77;
  const char *v78;
  uint64_t v79;
  unint64_t v80;
  _QWORD *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  HGRenderJob *v86;
  int v87;
  uint64_t v88;
  std::__shared_weak_count *v89;
  unint64_t *p_shared_owners;
  unint64_t v91;
  HGRenderJob *v92;
  HGRenderJob **v93;
  const char *v94;
  int GLVirtualScreen;
  uint64_t *v96;
  HGObject *v97;
  uint64_t v98;
  PCSharedCount v99;
  HGGPUComputeDevice *v100;
  std::__shared_weak_count *v101;
  HGSynchronizable *v102;
  char v103;
  HGObject *v104;
  uint64_t v105;

  v102 = (HGSynchronizable *)*((_QWORD *)this + 43);
  v103 = 0;
  HGSynchronizable::Lock(v102);
  *a3 = 0;
  if (!*((_QWORD *)this + 42)
    || *((_DWORD *)a2 + 6) == 4
    || (v6 = (_DWORD *)*((_QWORD *)a2 + 6), v6[8] == 3)
    || (*((_DWORD *)this + 4) & 0xFFFFFFFE) == 2
    || *((_DWORD *)this + 3) == 1 && !*((_QWORD *)this + 6))
  {
    v7 = 0;
    goto LABEL_6;
  }
  v100 = 0;
  v101 = 0;
  if (*((_DWORD *)a2 + 10)
  {
    GLVirtualScreen = -1;
  }
  else
  {
    FrameStats = (uint64_t *)PVRenderJob::GetFrameStats(v9);
    std::shared_ptr<HGComputeDevice const>::operator=[abi:ne180100]<HGGPUComputeDevice const,void>(&v100, FrameStats);
    GLVirtualScreen = HGGPUComputeDevice::GetGLVirtualScreen(v100);
    v6 = (_DWORD *)*((_QWORD *)a2 + 6);
  }
  v11 = HGPixelBufferObj::format((HGPixelBufferObj *)v6);
  v12 = *((_QWORD *)this + 38);
  v13 = *((_QWORD *)this + 39);
  v14 = v12 + 8 * (*((_QWORD *)this + 41) >> 9);
  if (v13 == v12)
    v15 = 0;
  else
    v15 = (HGRenderJob **)(*(_QWORD *)v14 + 8 * (*((_QWORD *)this + 41) & 0x1FFLL));
  v94 = 0;
  v16 = 0;
  v96 = (uint64_t *)((char *)this + 136);
  while (1)
  {
    if (v13 == v12)
    {
      if (!v15)
        goto LABEL_185;
    }
    else
    {
      v17 = *((_QWORD *)this + 42) + *((_QWORD *)this + 41);
      if (v15 == (HGRenderJob **)(*(_QWORD *)(v12 + ((v17 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v17 & 0x1FF)))
        goto LABEL_185;
    }
    if ((*((_DWORD *)this + 17) & 0x80000000) != 0)
    {
      v19 = *v15;
      TypeLabel = HGRenderJob::GetTypeLabel(*v15);
      printf("GetRenderJobFromQueue: Job<%p> type %s priority [%d] :  min exec priority [%d]\n", v19, TypeLabel, *((_DWORD *)*v15 + 26), *((_DWORD *)this + 14));
      v18 = *v15;
      if (*((_DWORD *)*v15 + 27) != 6)
        goto LABEL_28;
    }
    else
    {
      v18 = *v15;
      if (*((_DWORD *)*v15 + 27) != 6)
        goto LABEL_28;
    }
    if (*((_DWORD *)v18 + 3) != 4)
      goto LABEL_123;
LABEL_28:
    if ((_DWORD)v11 == 1 && (*((_DWORD *)v18 + 3) - 2) >= 5)
      break;
    if (*((_DWORD *)v18 + 26) < *((_DWORD *)this + 14))
    {
      if ((*((_BYTE *)this + 68) & 0x40) == 0)
        goto LABEL_162;
      printf("GetRenderJobFromQueue: Job<%p> not executed: priority [%d] is lower than min priority [%d]\n");
      goto LABEL_171;
    }
    v21 = *((_DWORD *)v18 + 3);
    switch(v21)
    {
      case 1:
        if (!*((_DWORD *)v18 + 4))
        {
          v27 = v16;
          v28 = "Synchronous Render Job: ANY resource requested.";
          goto LABEL_103;
        }
        if (HGRenderJob::UsesOnlyCPUResource(v18) && HGRenderExecUnit::IsCPU(a2))
        {
          v18 = *v15;
          *a3 = *v15;
          v32 = "Synchronous Render Job: CPU resource requested.";
        }
        else
        {
          if (!HGRenderJob::UsesOnlyGPUResource(*v15) || !HGRenderExecUnit::IsGPU(a2))
            goto LABEL_123;
          v35 = *v15;
          if (!*((_DWORD *)*v15 + 47))
          {
            *a3 = v35;
            v94 = "Synchronous Render Job: GPU resource requested.";
            goto LABEL_186;
          }
          if (!HGRenderJob::IsRequestedVirtualScreen(v35, GLVirtualScreen))
            goto LABEL_123;
          v18 = *v15;
          *a3 = *v15;
          v32 = "Synchronous Render Job: GPU Renderer/VScreen specified.";
        }
        break;
      case 3:
        IsGPU = HGRenderExecUnit::IsGPU(a2);
        if ((_DWORD)v11)
          v30 = IsGPU;
        else
          v30 = 0;
        if (!v30)
          goto LABEL_51;
        v18 = *v15;
        v31 = *((_QWORD *)*v15 + 3);
        if (!v31 || v31 != *(_QWORD *)(*((_QWORD *)a2 + 6) + 16))
          goto LABEL_51;
        v27 = v16;
        v28 = "XGMI Buffer Copy Job: Destination compute device match";
        goto LABEL_103;
      case 2:
        v22 = HGRenderExecUnit::IsGPU(a2);
        if ((_DWORD)v11)
          v23 = v22;
        else
          v23 = 0;
        if (!v23)
          goto LABEL_51;
        IsRequestedVirtualScreen = HGRenderJob::IsRequestedVirtualScreen(*v15, GLVirtualScreen);
        v18 = *v15;
        v25 = *((_QWORD *)*v15 + 22);
        if (v25)
          LODWORD(v25) = v25 == *((_QWORD *)a2 + 7);
        v26 = *((_QWORD *)v18 + 3);
        if (v26)
          LOBYTE(v26) = v26 == *(_QWORD *)(*((_QWORD *)a2 + 6) + 16);
        if (((IsRequestedVirtualScreen | v25) & 1) == 0 && (v26 & 1) == 0)
        {
LABEL_51:
          v94 = 0;
          goto LABEL_140;
        }
        v27 = v16;
        v28 = "CPU Buffer Copy To GPU Job: Virtual Screen, Renderer, or Compute Device Match";
        goto LABEL_103;
      default:
        v33 = *((_QWORD *)v18 + 22);
        if (v33)
        {
          if (v33 != *((_QWORD *)a2 + 7))
          {
            if (v21
              || ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v33 + 304))(v33) & 1) != 0
              || !HGRenderExecUnit::IsGPU(a2))
            {
LABEL_123:
              v94 = 0;
            }
            else
            {
              HGGPURenderer::GetContext(*((_QWORD *)*v15 + 22), 24, (uint64_t *)&v99);
              HGGLContext::Share((uint64_t *)&v99, &v104);
              PCSharedCount::PCSharedCount(&v99);
              v34 = HGGLContext::getVirtualScreen((HGGLContext *)v104) == GLVirtualScreen;
              if (v104)
                (*(void (**)(HGObject *))(*(_QWORD *)v104 + 24))(v104);
              v94 = 0;
              v16 = v34 | v16;
            }
LABEL_124:
            v18 = *a3;
            if (!*a3)
              goto LABEL_140;
            goto LABEL_125;
          }
          v49 = v21 == 4;
          v27 = (v21 == 4) & v16;
          if (!v49)
          {
            v94 = "Renderer Specified";
            if (((v16 ^ 1) & 1) != 0)
              goto LABEL_104;
            v94 = 0;
            v16 = 1;
            goto LABEL_124;
          }
          v28 = "Renderer Specified";
LABEL_103:
          v94 = v28;
LABEL_104:
          *a3 = v18;
          v16 = v27;
          goto LABEL_125;
        }
        if (HGRenderJob::SpecifiesComputeDevices(v18))
        {
          v36 = *((_QWORD *)a2 + 6);
          v37 = *(HGObject **)(v36 + 16);
          v38 = *(_QWORD *)(v36 + 24);
          v104 = v37;
          v105 = v38;
          if (v38)
          {
            v39 = (unint64_t *)(v38 + 8);
            do
              v40 = __ldxr(v39);
            while (__stxr(v40 + 1, v39));
          }
          v41 = *v15;
          if (*((HGObject **)*v15 + 3) == v37)
          {
            *a3 = v41;
            v50 = "Compute Device Specified";
            goto LABEL_119;
          }
          v42 = (HGObject *)*((_QWORD *)v41 + 10);
          if (v42)
          {
            if (v42 == v37)
            {
              *a3 = v41;
              v50 = "Preferred GPU Compute Device Specified";
              goto LABEL_119;
            }
            if ((HGRenderQueue::FindIdleRenderExecUnitForJobWithPreferredVirtualScreen(this, v41) & 1) == 0)
            {
              v43 = *((_QWORD *)*v15 + 5);
              v44 = *((_QWORD *)*v15 + 6);
              if (v43 == v44)
              {
                *a3 = *v15;
                v50 = "Preferred Compute Device Not Available. Using Alternate Compute Device.";
              }
              else
              {
                while (1)
                {
                  v45 = *(HGObject **)v43;
                  v46 = *(_QWORD *)(v43 + 8);
                  v97 = *(HGObject **)v43;
                  v98 = v46;
                  if (v46)
                  {
                    v47 = (unint64_t *)(v46 + 8);
                    do
                      v48 = __ldxr(v47);
                    while (__stxr(v48 + 1, v47));
                  }
                  if (v45 == v104)
                    break;
                  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v97);
                  v43 += 16;
                  if (v43 == v44)
                    goto LABEL_111;
                }
                *a3 = *v15;
                std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v97);
                v50 = "Preferred Compute Device Not Available. Using Alternate Compute Device From List.";
              }
              goto LABEL_119;
            }
LABEL_111:
            v94 = 0;
          }
          else
          {
            v51 = *((_QWORD *)v41 + 5);
            v52 = *((_QWORD *)v41 + 6);
            if (v51 == v52)
              goto LABEL_111;
            while (1)
            {
              v53 = *(HGObject **)v51;
              v54 = *(_QWORD *)(v51 + 8);
              v97 = *(HGObject **)v51;
              v98 = v54;
              if (v54)
              {
                v55 = (unint64_t *)(v54 + 8);
                do
                  v56 = __ldxr(v55);
                while (__stxr(v56 + 1, v55));
              }
              if (v53 == v104)
                break;
              std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v97);
              v51 += 16;
              if (v51 == v52)
                goto LABEL_111;
            }
            *a3 = *v15;
            std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v97);
            v50 = "Compute Device Selected from Compute Device List";
LABEL_119:
            v94 = v50;
          }
          std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v104);
          goto LABEL_124;
        }
        v18 = *v15;
        if (!*((_DWORD *)*v15 + 4))
        {
          v27 = v16;
          v28 = "Any Resource";
          goto LABEL_103;
        }
        if (HGRenderJob::UsesOnlyCPUResource(*v15) && HGRenderExecUnit::IsCPU(a2))
        {
          v18 = *v15;
          *a3 = *v15;
          v32 = "CPU Resource";
        }
        else
        {
          if (!HGRenderJob::UsesOnlyGPUResource(*v15) || !HGRenderExecUnit::IsGPU(a2))
            goto LABEL_123;
          v18 = *v15;
          if (*((_DWORD *)*v15 + 47))
          {
            if (!HGRenderJob::IsRequestedVirtualScreen(*v15, GLVirtualScreen))
              goto LABEL_123;
            v18 = *v15;
            *a3 = *v15;
            v32 = "GPU Resource, VScreen requested and was available";
          }
          else
          {
            v57 = *((_DWORD *)v18 + 48);
            if (v57 < 0)
            {
              v27 = v16;
              v28 = "GPU Resource, Any screen";
              goto LABEL_103;
            }
            if (v57 == GLVirtualScreen)
            {
              v27 = v16;
              v28 = "GPU Resource, Preferred VScreen requested and was available";
              goto LABEL_103;
            }
            if ((HGRenderQueue::FindIdleRenderExecUnitForJobWithPreferredVirtualScreen(this, *v15) & 1) != 0)
              goto LABEL_123;
            v18 = *v15;
            *a3 = *v15;
            v32 = "GPU Resource, Preferred VScreen requested but was not available";
          }
        }
        break;
    }
    v94 = v32;
    if (!v18)
      goto LABEL_140;
LABEL_125:
    v58 = *((_DWORD *)v18 + 3);
    if (v58 != 2)
    {
      if (v58 >= 2)
      {
        if (v58 != 7)
          goto LABEL_185;
        if (*((_BYTE *)this + 75))
        {
          if (HGRenderQueue::GetNumActiveGPUCustomRenderJobs(this, GLVirtualScreen))
          {
            if ((*((_BYTE *)this + 68) & 0x10) != 0)
            {
              PCICCTransferFunctionLUT::getLUTEnd(a2);
              HGRenderJob::GetUserName(*a3);
              printf("%s : NOT DEQUEUED : kTypeCustom : (%s) :  Reason: Serialize custom jobs. '%s'\n");
            }
            goto LABEL_216;
          }
          v18 = *a3;
        }
        if (!*((_QWORD *)v18 + 22))
          *((_QWORD *)v18 + 22) = *((_QWORD *)a2 + 7);
        v96 = (uint64_t *)((char *)this + 160);
      }
      else
      {
        if (!*((_DWORD *)a2 + 10))
        {
          if (HGRenderQueue::GetThrottleFlagOnVirtualScreen(this, GLVirtualScreen))
          {
            if ((*((_BYTE *)this + 69) & 1) != 0)
            {
              PCICCTransferFunctionLUT::getLUTEnd(a2);
              HGRenderJob::GetUserName(*a3);
              printf("%s :NOT DEQUEUED: kTypeRender : (%s) :  Reason: Throttle for PBO downloads. '%s'\n");
            }
          }
          else
          {
            if (!HGRenderQueue::GetLockFlagOnVirtualScreen(this, GLVirtualScreen))
            {
              if (*((_BYTE *)this + 72))
              {
                if (*((_BYTE *)this + 74))
                  v85 = *((_DWORD *)*a3 + 26);
                else
                  v85 = 0;
                if (HGRenderQueue::GetNumActiveGPURenderJobs((uint64_t)this, GLVirtualScreen, v85))
                {
                  if ((*((_BYTE *)this + 68) & 0x10) != 0)
                  {
                    PCICCTransferFunctionLUT::getLUTEnd(a2);
                    HGRenderJob::GetUserName(*a3);
                    printf("%s : NOT DEQUEUED : kTypeRender : (%s) :  Reason: Serialize renders. '%s'\n");
                  }
                  goto LABEL_216;
                }
                v92 = *a3;
                *((_DWORD *)v92 + 46) = GLVirtualScreen;
                if (!*((_QWORD *)v92 + 22))
                {
                  *((_QWORD *)v92 + 22) = *((_QWORD *)a2 + 7);
                  goto LABEL_184;
                }
                HGRenderExecUnit::RemoveEnqueuedRenderJob(a2, v92);
                if ((*((_BYTE *)this + 69) & 4) == 0)
                  goto LABEL_184;
              }
              else
              {
                v86 = *a3;
                *((_DWORD *)v86 + 46) = GLVirtualScreen;
                if (!*((_QWORD *)v86 + 22))
                {
                  *((_QWORD *)v86 + 22) = *((_QWORD *)a2 + 7);
                  goto LABEL_184;
                }
                HGRenderExecUnit::RemoveEnqueuedRenderJob(a2, v86);
                if ((*((_BYTE *)this + 69) & 4) == 0)
                  goto LABEL_184;
              }
              v87 = *((_DWORD *)a2 + 2);
              v88 = HGRenderExecUnit::NumEnqueuedRenderJobs(a2);
              printf("RenderUnit<%d> Execute: Count: %lu\n", v87, v88);
              goto LABEL_184;
            }
            if ((*((_BYTE *)this + 68) & 0x10) != 0)
            {
              PCICCTransferFunctionLUT::getLUTEnd(a2);
              HGRenderJob::GetUserName(*a3);
              printf("%s :NOT DEQUEUED: kTypeRender : (%s) :  Reason: Virtual Screen Locked by Client. '%s'\n");
            }
          }
LABEL_216:
          v7 = 0;
          *a3 = 0;
          goto LABEL_217;
        }
        if (HGRenderQueue::GetLockFlagOnVirtualScreen(this, -1))
        {
          if ((*((_BYTE *)this + 68) & 0x10) != 0)
          {
            PCICCTransferFunctionLUT::getLUTEnd(a2);
            HGRenderJob::GetUserName(*a3);
            printf("%s :NOT DEQUEUED: kTypeRender : (%s) :  Reason: CPU Locked by Client. '%s'\n");
          }
          goto LABEL_216;
        }
        if (*((_BYTE *)this + 73) && HGRenderQueue::GetNumActiveCPURenderJobs(this))
        {
          if ((*((_BYTE *)this + 68) & 0x10) != 0)
          {
            PCICCTransferFunctionLUT::getLUTEnd(a2);
            HGRenderJob::GetUserName(*a3);
            printf("%s :NOT DEQUEUED: kTypeRender : (%s) :  Reason: Serializing CPU renders. '%s'\n");
          }
          goto LABEL_216;
        }
        if (!*((_QWORD *)*a3 + 22))
          *((_QWORD *)*a3 + 22) = *((_QWORD *)a2 + 7);
      }
LABEL_184:
      std::list<HGRenderJob *>::push_back(v96, (uint64_t *)a3);
      goto LABEL_185;
    }
    if (!*((_BYTE *)this + 77))
    {
      *((_DWORD *)v18 + 46) = GLVirtualScreen;
      if (!*((_QWORD *)v18 + 22))
      {
        *((_QWORD *)v18 + 22) = *((_QWORD *)a2 + 7);
        v18 = *a3;
      }
      v70 = *((_QWORD *)v18 + 8);
      v69 = (_QWORD *)((char *)v18 + 64);
      if (!v70)
      {
        std::shared_ptr<HGComputeDevice const>::operator=[abi:ne180100]<HGGPUComputeDevice const,void>(v69, (uint64_t *)(*((_QWORD *)a2 + 6) + 16));
        goto LABEL_185;
      }
      goto LABEL_186;
    }
    v59 = (HGObject *)*((_QWORD *)this + 43);
    v104 = v59;
    LOBYTE(v105) = 0;
    HGSynchronizable::Lock((HGSynchronizable *)v59);
    v93 = v15;
    v60 = a2;
    v61 = v11;
    v62 = v14;
    v63 = (uint64_t *)*((_QWORD *)this + 18);
    if (v63 == v96)
    {
      v64 = 0;
    }
    else
    {
      v64 = 0;
      do
      {
        v65 = v63[2];
        if (((*(uint64_t (**)(_QWORD))(**(_QWORD **)(v65 + 176) + 304))(*(_QWORD *)(v65 + 176)) & 1) == 0
          && (*(_DWORD *)(v65 + 104) & 0x80000000) == 0
          && *(_DWORD *)(v65 + 184) == GLVirtualScreen)
        {
          ++v64;
        }
        v63 = (uint64_t *)v63[1];
      }
      while (v63 != v96);
    }
    HGSynchronizable::Unlock((HGSynchronizable *)v59);
    v14 = v62;
    if (!v64)
    {
      v71 = *a3;
      *((_DWORD *)v71 + 46) = GLVirtualScreen;
      a2 = v60;
      if (!*((_QWORD *)v71 + 22))
      {
        *((_QWORD *)v71 + 22) = *((_QWORD *)v60 + 7);
        v71 = *a3;
      }
      v73 = *((_QWORD *)v71 + 8);
      v72 = (_QWORD *)((char *)v71 + 64);
      v15 = v93;
      if (!v73)
        std::shared_ptr<HGComputeDevice const>::operator=[abi:ne180100]<HGGPUComputeDevice const,void>(v72, (uint64_t *)(*((_QWORD *)a2 + 6) + 16));
      goto LABEL_184;
    }
    v11 = v61;
    a2 = v60;
    v15 = v93;
    if ((*((_BYTE *)this + 68) & 0x10) != 0)
    {
      LUTEnd = (const char *)PCICCTransferFunctionLUT::getLUTEnd(a2);
      UserName = HGRenderJob::GetUserName(*a3);
      printf("%s :NOT DEQUEUED: kTypeCopyCPUBitmapToGPUTexture : (%s) :  Reason: Serialize renders/uploads. '%s'\n", LUTEnd, v94, UserName);
    }
    *a3 = 0;
LABEL_140:
    if ((HGRenderJob **)((char *)++v15 - *(_QWORD *)v14) == (HGRenderJob **)4096)
    {
      v68 = *(HGRenderJob ***)(v14 + 8);
      v14 += 8;
      v15 = v68;
    }
    v12 = *((_QWORD *)this + 38);
    v13 = *((_QWORD *)this + 39);
  }
  if ((*((_BYTE *)this + 69) & 0x40) == 0)
  {
LABEL_162:
    v94 = 0;
    goto LABEL_185;
  }
  printf("GetRenderJobFromQueue: Job<%p> not executed: Work unit only performs CPU to GPU buffer copy/delete jobs \n");
LABEL_171:
  v94 = 0;
LABEL_185:
  if (*a3)
  {
LABEL_186:
    std::deque<Pipeline *>::erase((int64x2_t *)((char *)this + 296), (char *)v14, (char *)v15);
    v74 = *((_QWORD *)*a3 + 22);
    if (v74)
      (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v74 + 120))(v74, 13, 0);
    if ((*((_BYTE *)this + 71) & 0x40) != 0)
    {
      v75 = (const char *)PCICCTransferFunctionLUT::getLUTEnd(a2);
      v76 = HGRenderJob::GetTypeLabel(*a3);
      v77 = *a3;
      v78 = HGRenderJob::GetUserName(*a3);
      printf("%s : DequeueJob: %s : %s (job %p) '%s'\n", v75, v76, v94, v77, v78);
    }
    if (*((_DWORD *)this + 3) == 1)
      --*((_QWORD *)this + 6);
    if ((*((_BYTE *)this + 69) & 8) == 0 || *((_DWORD *)*a3 + 3))
    {
LABEL_194:
      v7 = 1;
      goto LABEL_217;
    }
    v7 = 1;
    if (!*((_BYTE *)this + 352))
    {
      *((_BYTE *)this + 352) = 1;
      v79 = *((_QWORD *)this + 38);
      if (*((_QWORD *)this + 39) != v79)
      {
        v80 = *((_QWORD *)this + 41);
        v81 = (_QWORD *)(v79 + 8 * (v80 >> 9));
        v82 = *v81 + 8 * (v80 & 0x1FF);
        v83 = *(_QWORD *)(v79 + (((*((_QWORD *)this + 42) + v80) >> 6) & 0x3FFFFFFFFFFFFF8))
            + 8 * ((*((_QWORD *)this + 42) + v80) & 0x1FF);
        while (v82 != v83)
        {
          if (!*(_DWORD *)(*(_QWORD *)v82 + 12))
          {
            *((_BYTE *)this + 352) = 0;
            goto LABEL_194;
          }
          v82 += 8;
          if (v82 - *v81 == 4096)
          {
            v84 = v81[1];
            ++v81;
            v82 = v84;
          }
        }
      }
      *((_QWORD *)this + 45) = mach_absolute_time();
      goto LABEL_194;
    }
  }
  else
  {
    v7 = 0;
  }
LABEL_217:
  v89 = v101;
  if (v101)
  {
    p_shared_owners = (unint64_t *)&v101->__shared_owners_;
    do
      v91 = __ldaxr(p_shared_owners);
    while (__stlxr(v91 - 1, p_shared_owners));
    if (!v91)
    {
      ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
      std::__shared_weak_count::__release_weak(v89);
    }
  }
  if (!v103)
LABEL_6:
    HGSynchronizable::Unlock(v102);
  return v7;
}

void sub_1B2AF5848(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,PCSharedCount a21,char a22,uint64_t a23,HGSynchronizable *a24)
{
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a22);
  HGSynchronizer::~HGSynchronizer(&a24);
  _Unwind_Resume(a1);
}

void sub_1B2AF58F8()
{
  uint64_t v0;

  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)(v0 - 104));
  JUMPOUT(0x1B2AF5904);
}

void ___ZN13HGRenderQueue12GetRenderJobEP16HGRenderExecUnitPP11HGRenderJob_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  HGRenderQueue::NotifyIdleRenderUnits((HGRenderQueue *)v1);
  dispatch_group_leave(*(dispatch_group_t *)(v1 + 744));
}

_QWORD *std::list<HGRenderJob *>::push_back(uint64_t *a1, uint64_t *a2)
{
  _QWORD *result;
  uint64_t v5;
  uint64_t v6;

  result = operator new(0x18uLL);
  v5 = *a2;
  result[1] = a1;
  result[2] = v5;
  v6 = *a1;
  *result = *a1;
  *(_QWORD *)(v6 + 8) = result;
  *a1 = (uint64_t)result;
  ++a1[2];
  return result;
}

uint64_t HGRenderQueue::AddUserJobQueue(HGRenderQueue *this)
{
  HGSynchronizable *v2;
  HGUserExecUnit *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v2 = (HGSynchronizable *)*((_QWORD *)this + 43);
  HGSynchronizable::Lock(v2);
  v3 = (HGUserExecUnit *)operator new();
  HGUserExecUnit::HGUserExecUnit(v3, this);
  *((_DWORD *)v3 + 2) = 0;
  v4 = operator new(0x18uLL);
  v4[1] = (char *)this + 368;
  v4[2] = v3;
  v5 = *((_QWORD *)this + 46);
  *v4 = v5;
  *(_QWORD *)(v5 + 8) = v4;
  *((_QWORD *)this + 46) = v4;
  ++*((_QWORD *)this + 48);
  *((_BYTE *)this + 43) = 1;
  v6 = *((unsigned int *)v3 + 6);
  HGSynchronizable::Unlock(v2);
  return v6;
}

void sub_1B2AF5A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
  uint64_t v9;

  MEMORY[0x1B5E29170](v9, 0x10A1C4022CE9198);
  HGSynchronizer::~HGSynchronizer(&a9);
  _Unwind_Resume(a1);
}

void sub_1B2AF5A6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
  HGSynchronizer::~HGSynchronizer(&a9);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::EnqueueUserJob(HGRenderQueue *this, HGUserJob *a2)
{
  HGSynchronizable *v4;
  _BOOL4 v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  HGSynchronizable *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  HGSynchronizable *v19;
  HGUserJob *v20;

  v20 = a2;
  v4 = (HGSynchronizable *)*((_QWORD *)this + 43);
  HGSynchronizable::Lock(v4);
  if (*((_DWORD *)this + 4) == 3)
  {
    v5 = 0;
    v6 = 4294966305;
  }
  else if (*((_BYTE *)this + 43))
  {
    v7 = *((_DWORD *)a2 + 5);
    if (v7)
    {
      v8 = *((_QWORD *)this + 47);
      if ((HGRenderQueue *)v8 == (HGRenderQueue *)((char *)this + 368))
      {
LABEL_8:
        v5 = 0;
      }
      else
      {
        while (1)
        {
          v9 = *(_DWORD *)(*(_QWORD *)(v8 + 16) + 24);
          v5 = v9 == v7;
          if (v9 == v7)
            break;
          v8 = *(_QWORD *)(v8 + 8);
          if ((HGRenderQueue *)v8 == (HGRenderQueue *)((char *)this + 368))
            goto LABEL_8;
        }
      }
      v6 = 4294966302;
    }
    else
    {
      v6 = 4294966302;
      v5 = 1;
    }
  }
  else
  {
    v5 = 0;
    v6 = 4294966301;
  }
  HGSynchronizable::Unlock(v4);
  if (v5)
  {
    (*(void (**)(HGUserJob *))(*(_QWORD *)a2 + 16))(a2);
    HGUserJob::SetState((uint64_t)a2, 2);
    *((_QWORD *)a2 + 7) = this;
    HGUserJob::CallNotifyFunc(a2);
    v10 = (HGSynchronizable *)*((_QWORD *)this + 59);
    HGSynchronizable::Lock(v10);
    v11 = *((_QWORD *)this + 57);
    v12 = *((_QWORD *)this + 54);
    v13 = v12 + 8 * (v11 >> 9);
    if (*((_QWORD *)this + 55) == v12)
    {
      v14 = 0;
      v15 = (_QWORD *)((char *)this + 464);
    }
    else
    {
      v14 = *(_QWORD *)v13 + 8 * (*((_QWORD *)this + 57) & 0x1FFLL);
      v15 = (_QWORD *)((char *)this + 464);
      v16 = *(_QWORD *)(v12 + (((*((_QWORD *)this + 58) + v11) >> 6) & 0x3FFFFFFFFFFFFF8))
          + 8 * ((*((_QWORD *)this + 58) + v11) & 0x1FF);
      if (v14 != v16)
      {
        while (*((_DWORD *)a2 + 3) <= *(_DWORD *)(*(_QWORD *)v14 + 12))
        {
          v14 += 8;
          if (v14 - *(_QWORD *)v13 == 4096)
          {
            v17 = *(_QWORD *)(v13 + 8);
            v13 += 8;
            v14 = v17;
          }
          if (v14 == v16)
          {
            v14 = v16;
            break;
          }
        }
      }
    }
    std::deque<HGUserJob *>::insert((_QWORD *)this + 53, (char *)v13, v14, (char *)&v20);
    if (*((_DWORD *)this + 17))
      printf("EnqueueUserJob: User Queue Size: %lu\n", *v15);
    HGSynchronizable::Unlock(v10);
    v19 = (HGSynchronizable *)*((_QWORD *)this + 49);
    HGSynchronizable::Lock(v19);
    HGSynchronizable::NotifyAll(v19);
    HGSynchronizable::Unlock(v19);
    return 0;
  }
  return v6;
}

void sub_1B2AF5C80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF5C98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

_QWORD *std::deque<HGUserJob *>::insert(_QWORD *a1, char *a2, uint64_t a3, char *a4)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  _QWORD *result;
  unint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  unint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  char *v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  char *v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  char *v63;

  v6 = a1[4];
  v7 = a1[1];
  v8 = a1[2];
  v9 = (char *)(v7 + 8 * (v6 >> 9));
  if (v8 == v7)
  {
    v10 = 0;
    if (a3)
    {
LABEL_3:
      v11 = ((a3 - *(_QWORD *)a2) >> 3) + ((a2 - v9) << 6) - ((v10 - *(_QWORD *)v9) >> 3);
      v12 = a1[5];
      v13 = v12 - v11;
      if (v11 < v12 - v11)
        goto LABEL_4;
LABEL_14:
      if (v8 == v7)
        v22 = 0;
      else
        v22 = ((v8 - v7) << 6) - 1;
      if (v22 == v12 + v6)
      {
        std::deque<HGUserJob *>::__add_back_capacity((uint64_t)a1);
        v12 = a1[5];
        v13 = v12 - v11;
      }
      if (v12 == v11)
      {
        *(_QWORD *)(*(_QWORD *)(a1[1] + (((a1[4] + v11) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((a1[4] + v11) & 0x1FF)) = *(_QWORD *)a4;
        a1[5] = v11 + 1;
        v23 = a1[4];
        v24 = a1[1];
        result = (_QWORD *)(v24 + 8 * (v23 >> 9));
        if (a1[2] != v24)
          goto LABEL_55;
        goto LABEL_47;
      }
      v63 = a4;
      v26 = a1[4] + v12;
      v27 = a1[1];
      v28 = (char *)(v27 + 8 * (v26 >> 9));
      v29 = *(_QWORD *)v28 + 8 * (v26 & 0x1FF);
      if (a1[2] == v27)
        v30 = 0;
      else
        v30 = (char *)v29;
      v31 = (uint64_t)&v30[-*(_QWORD *)v28];
      v32 = v31 >> 3;
      if (v31 < 9)
      {
        v51 = 512 - v32;
        v34 = &v28[-8 * (v51 >> 9)];
        v35 = (char *)(*(_QWORD *)v34 + 8 * (~(_WORD)v51 & 0x1FF));
        if (v35 != a4)
          goto LABEL_44;
      }
      else
      {
        v33 = v32 - 1;
        v34 = &v28[8 * (v33 >> 9)];
        v35 = (char *)(*(_QWORD *)v34 + 8 * (v33 & 0x1FF));
        if (v35 != a4)
          goto LABEL_44;
      }
      v63 = v30;
      a4 = v30;
LABEL_44:
      *(_QWORD *)v30 = *(_QWORD *)v35;
      a1[5] = v12 + 1;
      if (v13 >= 2)
      {
        v55 = ((uint64_t)&v30[-*(_QWORD *)v28] >> 3) - v13;
        if (v55 < 1)
        {
          v61 = 511 - v55;
          v56 = &v28[-8 * (v61 >> 9)];
          v57 = (char *)(*(_QWORD *)v56 + 8 * (~(_WORD)v61 & 0x1FF));
        }
        else
        {
          v56 = &v28[8 * ((unint64_t)v55 >> 9)];
          v57 = (char *)(*(_QWORD *)v56 + 8 * (v55 & 0x1FF));
        }
        v28 = std::deque<HGRenderJob *>::__move_backward_and_check((uint64_t)a1, v56, v57, v34, v35, v28, v30, (unint64_t *)&v63);
        v30 = v62;
        v52 = *(_QWORD *)v63;
        if (v62 != *(char **)v28)
        {
LABEL_46:
          *((_QWORD *)v30 - 1) = v52;
          v23 = a1[4];
          v53 = a1[1];
          result = (_QWORD *)(v53 + 8 * (v23 >> 9));
          if (a1[2] != v53)
            goto LABEL_55;
          goto LABEL_47;
        }
      }
      else
      {
        v52 = *(_QWORD *)a4;
        if (v30 != *(char **)v28)
          goto LABEL_46;
      }
      v30 = (char *)(*((_QWORD *)v28 - 1) + 4096);
      goto LABEL_46;
    }
  }
  else
  {
    v10 = *(_QWORD *)v9 + 8 * (a1[4] & 0x1FFLL);
    if (a3 != v10)
      goto LABEL_3;
  }
  v11 = 0;
  v12 = a1[5];
  v13 = v12;
  if (!v12)
    goto LABEL_14;
LABEL_4:
  if (v6)
  {
    if (v11)
      goto LABEL_6;
  }
  else
  {
    std::deque<HGUserJob *>::__add_front_capacity((uint64_t)a1);
    if (v11)
    {
LABEL_6:
      v63 = a4;
      v14 = a1[4];
      v15 = a1[1];
      v16 = (char *)(v15 + 8 * (v14 >> 9));
      v17 = *(_QWORD *)v16;
      if (a1[2] == v15)
        v18 = 0;
      else
        v18 = (char *)(*(_QWORD *)v16 + 8 * (a1[4] & 0x1FFLL));
      v19 = (uint64_t)&v18[-v17];
      v20 = (uint64_t)&v18[-v17] >> 3;
      if (v19 < 9)
      {
        v21 = (char *)(*(_QWORD *)&v16[-8 * ((unint64_t)(512 - v20) >> 9)] + 8 * (~(512 - (_WORD)v20) & 0x1FF));
        if (v18 != a4)
          goto LABEL_38;
      }
      else
      {
        v21 = (char *)(*(_QWORD *)&v16[((unint64_t)(v20 - 1) >> 6) & 0x3FFFFFFFFFFFFF8]
                     + 8 * ((v20 - 1) & 0x1FF));
        if (v18 != a4)
          goto LABEL_38;
      }
      v63 = v21;
      a4 = v21;
LABEL_38:
      *(_QWORD *)v21 = *(_QWORD *)v18;
      v42 = a1[5] + 1;
      a1[4] = v14 - 1;
      a1[5] = v42;
      if (v11 < 2)
        goto LABEL_54;
      v43 = (uint64_t)&v18[-*(_QWORD *)v16];
      v44 = v43 >> 3;
      if (v43 < -7)
      {
        v45 = &v16[-8 * ((unint64_t)(510 - v44) >> 9)];
        v46 = (char *)(*(_QWORD *)v45 + 8 * (~(510 - (_WORD)v44) & 0x1FF));
        v47 = v44 + v11;
        if (v47 < 1)
          goto LABEL_41;
      }
      else
      {
        v45 = &v16[8 * ((unint64_t)(v44 + 1) >> 9)];
        v46 = (char *)(*(_QWORD *)v45 + 8 * ((v44 + 1) & 0x1FF));
        v47 = v44 + v11;
        if (v47 < 1)
        {
LABEL_41:
          v48 = 511 - v47;
          v49 = &v16[-8 * (v48 >> 9)];
          v50 = (char *)(*(_QWORD *)v49 + 8 * (~(_WORD)v48 & 0x1FF));
LABEL_53:
          std::deque<HGRenderJob *>::__move_and_check((int)a1, v45, v46, v49, v50, v16, v18, (unint64_t *)&v63);
          v18 = v58;
          a4 = v63;
LABEL_54:
          *(_QWORD *)v18 = *(_QWORD *)a4;
          v23 = a1[4];
          v59 = a1[1];
          result = (_QWORD *)(v59 + 8 * (v23 >> 9));
          if (a1[2] != v59)
            goto LABEL_55;
          goto LABEL_47;
        }
      }
      v49 = &v16[8 * ((unint64_t)v47 >> 9)];
      v50 = (char *)(*(_QWORD *)v49 + 8 * (v47 & 0x1FF));
      goto LABEL_53;
    }
  }
  v36 = a1[4];
  v37 = a1[1];
  v38 = (_QWORD *)(v37 + 8 * (v36 >> 9));
  if (a1[2] == v37)
    v39 = 0;
  else
    v39 = *v38 + 8 * (a1[4] & 0x1FFLL);
  if (v39 == *v38)
    v39 = *(v38 - 1) + 4096;
  *(_QWORD *)(v39 - 8) = *(_QWORD *)a4;
  v40 = a1[5] + 1;
  a1[4] = v36 - 1;
  a1[5] = v40;
  v23 = a1[4];
  v41 = a1[1];
  result = (_QWORD *)(v41 + 8 * (v23 >> 9));
  if (a1[2] != v41)
  {
LABEL_55:
    v54 = *result + 8 * (v23 & 0x1FF);
    if (!v11)
      return result;
    goto LABEL_56;
  }
LABEL_47:
  v54 = 0;
  if (!v11)
    return result;
LABEL_56:
  v60 = v11 + ((v54 - *result) >> 3);
  if (v60 < 1)
    result -= (unint64_t)(511 - v60) >> 9;
  else
    result += (unint64_t)v60 >> 9;
  return result;
}

uint64_t HGRenderQueue::CancelUserJobs(HGRenderQueue *this, int a2)
{
  HGSynchronizable *v4;
  uint64_t v5;
  char *v6;
  uint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  HGUserJob *v10;
  char *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  char *v16;
  char *v17;
  char *v18;
  HGSynchronizable *v19;
  char *v20;
  uint64_t v21;
  HGSynchronizable *v22;
  uint64_t v23;
  void **v24;
  void **v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  void *v29;
  timespec __rmtp;
  timespec __rqtp;
  void *__p[2];
  __int128 v34;
  __int128 v35;

  v34 = 0u;
  v35 = 0u;
  *(_OWORD *)__p = 0u;
  v4 = (HGSynchronizable *)*((_QWORD *)this + 59);
  __rqtp.tv_sec = (__darwin_time_t)v4;
  LOBYTE(__rqtp.tv_nsec) = 0;
  HGSynchronizable::Lock(v4);
  v5 = *((_QWORD *)this + 54);
  v6 = (char *)(v5 + 8 * (*((_QWORD *)this + 57) >> 9));
  if (*((_QWORD *)this + 55) == v5)
  {
    v7 = 0;
    v8 = 0;
    goto LABEL_6;
  }
  v7 = (uint64_t *)(*(_QWORD *)v6 + 8 * (*((_QWORD *)this + 57) & 0x1FFLL));
  v8 = 0;
  while (1)
  {
    v9 = *((_QWORD *)this + 58) + *((_QWORD *)this + 57);
    if (v7 == (uint64_t *)(*(_QWORD *)(v5 + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v9 & 0x1FF)))
      break;
    while (1)
    {
      v10 = (HGUserJob *)*v7;
      HGUserJob::SetState(*v7, 4);
      HGUserJob::CallNotifyFunc(v10);
      v11 = (char *)__p[1];
      if ((void *)v34 == __p[1])
        v12 = 0;
      else
        v12 = (((_QWORD)v34 - (unint64_t)__p[1]) << 6) - 1;
      v13 = *((_QWORD *)&v35 + 1);
      v14 = *((_QWORD *)&v35 + 1) + v35;
      if (v12 == *((_QWORD *)&v35 + 1) + (_QWORD)v35)
      {
        std::deque<HGUserJob *>::__add_back_capacity((uint64_t)__p);
        v13 = *((_QWORD *)&v35 + 1);
        v11 = (char *)__p[1];
        v14 = v35 + *((_QWORD *)&v35 + 1);
      }
      *(_QWORD *)(*(_QWORD *)&v11[(v14 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v14 & 0x1FF)) = v10;
      *((_QWORD *)&v35 + 1) = v13 + 1;
      v6 = (char *)std::deque<Pipeline *>::erase((int64x2_t *)((char *)this + 424), v6, (char *)v7);
      v7 = v15;
      ++v8;
      v5 = *((_QWORD *)this + 54);
      if (*((_QWORD *)this + 55) != v5)
        break;
LABEL_6:
      if (!v7)
        goto LABEL_14;
    }
  }
LABEL_14:
  HGSynchronizable::Unlock(v4);
  if (*((_QWORD *)&v35 + 1))
  {
    v16 = (char *)__p[1] + 8 * ((unint64_t)v35 >> 9);
    if ((void *)v34 == __p[1])
      v17 = 0;
    else
      v17 = (char *)(*(_QWORD *)v16 + 8 * (v35 & 0x1FF));
    while (1)
    {
      if ((void *)v34 == __p[1])
      {
        if (!v17)
          break;
      }
      else if ((char *)(*(_QWORD *)((char *)__p[1]
                                   + (((*((_QWORD *)&v35 + 1) + (_QWORD)v35) >> 6) & 0x3FFFFFFFFFFFFF8))
                       + 8 * ((*((_QWORD *)&v35 + 1) + v35) & 0x1FF)) == v17)
      {
        break;
      }
      (*(void (**)(_QWORD))(**(_QWORD **)v17 + 24))(*(_QWORD *)v17);
      v16 = (char *)std::deque<Pipeline *>::erase((int64x2_t *)__p, v16, v17);
      v17 = v18;
    }
  }
  v19 = (HGSynchronizable *)*((_QWORD *)this + 59);
  __rqtp.tv_sec = (__darwin_time_t)v19;
  LOBYTE(__rqtp.tv_nsec) = 0;
  HGSynchronizable::Lock(v19);
  v20 = (char *)this + 400;
  v21 = *((_QWORD *)this + 51);
  if ((HGRenderQueue *)v21 != (HGRenderQueue *)((char *)this + 400))
  {
    do
    {
      HGUserJob::SetState(*(_QWORD *)(v21 + 16), 4);
      ++v8;
      v21 = *(_QWORD *)(v21 + 8);
    }
    while ((char *)v21 != v20);
  }
  HGSynchronizable::Unlock(v19);
  if (a2)
  {
    while (1)
    {
      v22 = (HGSynchronizable *)*((_QWORD *)this + 59);
      HGSynchronizable::Lock(v22);
      v23 = *((_QWORD *)this + 51);
      if ((char *)v23 == v20)
        break;
      while (*(_DWORD *)(*(_QWORD *)(v23 + 16) + 16) != 4)
      {
        v23 = *(_QWORD *)(v23 + 8);
        if ((char *)v23 == v20)
          goto LABEL_31;
      }
      HGSynchronizable::Unlock(v22);
      __rqtp = (timespec)xmmword_1B3524AA0;
      nanosleep(&__rqtp, &__rmtp);
    }
LABEL_31:
    HGSynchronizable::Unlock(v22);
  }
  v24 = (void **)__p[1];
  v25 = (void **)v34;
  *((_QWORD *)&v35 + 1) = 0;
  v26 = v34 - (unint64_t)__p[1];
  if ((unint64_t)v34 - (unint64_t)__p[1] >= 0x11)
  {
    do
    {
      operator delete(*v24);
      v25 = (void **)v34;
      v24 = (void **)((char *)__p[1] + 8);
      __p[1] = v24;
      v26 = v34 - (_QWORD)v24;
    }
    while ((_QWORD)v34 - (_QWORD)v24 > 0x10uLL);
  }
  v27 = v26 >> 3;
  if (v27 == 1)
  {
    v28 = 256;
    goto LABEL_38;
  }
  if (v27 == 2)
  {
    v28 = 512;
LABEL_38:
    *(_QWORD *)&v35 = v28;
  }
  if (v24 != v25)
  {
    do
    {
      v29 = *v24++;
      operator delete(v29);
    }
    while (v24 != v25);
    if ((void *)v34 != __p[1])
      *(_QWORD *)&v34 = v34 + (((unint64_t)__p[1] - v34 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (__p[0])
    operator delete(__p[0]);
  return v8;
}

void sub_1B2AF6534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  std::deque<HGNode *>::~deque[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  HGSynchronizable *v6;
  va_list va;
  uint64_t v8;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, HGSynchronizable *);
  v8 = va_arg(va1, _QWORD);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  std::deque<HGNode *>::~deque[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::GetUserJob(HGRenderQueue *this, HGUserExecUnit *a2, HGUserJob **a3)
{
  HGSynchronizable *v6;
  HGSynchronizable *v7;
  int v8;
  uint64_t v9;

  v6 = (HGSynchronizable *)*((_QWORD *)this + 49);
  HGSynchronizable::Lock(v6);
  while ((HGRenderQueue::GetUserJobFromQueue(this, a2, a3) & 1) == 0)
  {
    *((_DWORD *)a2 + 2) = 1;
    HGSynchronizable::Wait(v6);
    v7 = (HGSynchronizable *)*((_QWORD *)this + 43);
    HGSynchronizable::Lock(v7);
    v8 = *((_DWORD *)this + 4);
    HGSynchronizable::Unlock(v7);
    if (v8 == 3)
    {
      v9 = 0;
      goto LABEL_6;
    }
  }
  v9 = 1;
LABEL_6:
  HGSynchronizable::Unlock(v6);
  return v9;
}

void sub_1B2AF6648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
  HGSynchronizer::~HGSynchronizer(&a9);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::GetUserJobFromQueue(HGRenderQueue *this, HGUserExecUnit *a2, HGUserJob **a3)
{
  HGSynchronizable *v6;
  HGSynchronizable *v7;
  int v8;
  uint64_t v9;
  HGGLBlendingInfo *v10;
  int AlphaOperation;
  uint64_t v12;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  HGSynchronizable *v27;

  v6 = (HGSynchronizable *)*((_QWORD *)this + 59);
  HGSynchronizable::Lock(v6);
  *a3 = 0;
  if (*((_DWORD *)this + 17))
    printf("GetUserJobFromQueue: User Queue Size: %lu\n", *((_QWORD *)this + 58));
  if (!*((_QWORD *)this + 58))
    goto LABEL_13;
  v7 = (HGSynchronizable *)*((_QWORD *)this + 43);
  HGSynchronizable::Lock(v7);
  v8 = *((_DWORD *)this + 4);
  HGSynchronizable::Unlock(v7);
  if (v8 == 2)
    goto LABEL_13;
  if (!*((_QWORD *)this + 58))
  {
LABEL_10:
    if (*((_DWORD *)this + 17))
      puts("GetUserJobFromQueue: Incompatible user exec unit.");
    v27 = (HGSynchronizable *)*((_QWORD *)this + 49);
    HGSynchronizable::Lock(v27);
    HGSynchronizable::NotifyAll(v27);
    HGSynchronizable::Unlock(v27);
LABEL_13:
    v12 = 0;
    goto LABEL_14;
  }
  v9 = 0;
  while (1)
  {
    v10 = *(HGGLBlendingInfo **)(*(_QWORD *)(*((_QWORD *)this + 54)
                                           + (((unint64_t)(v9 + *((_QWORD *)this + 57)) >> 6) & 0x3FFFFFFFFFFFFF8))
                               + 8 * ((v9 + *((_QWORD *)this + 57)) & 0x1FF));
    AlphaOperation = HGGLBlendingInfo::GetAlphaOperation(v10);
    if (!AlphaOperation)
    {
      *a3 = v10;
      v14 = *((_QWORD *)this + 54);
      v15 = (char *)(v14 + 8 * (*((_QWORD *)this + 57) >> 9));
      if (*((_QWORD *)this + 55) == v14)
      {
        v16 = 0;
        if (!v9)
          goto LABEL_32;
      }
      else
      {
        v16 = (char *)(*(_QWORD *)v15 + 8 * (*((_QWORD *)this + 57) & 0x1FFLL));
        if (!v9)
          goto LABEL_32;
      }
      v18 = (uint64_t)&v16[-*(_QWORD *)v15] >> 3;
      v19 = v18 + v9;
      if (v18 + v9 < 1)
      {
        v22 = 511 - v9 - v18;
        LOWORD(v19) = ~(_WORD)v22;
        v15 -= 8 * (v22 >> 9);
      }
      else
      {
        v15 += 8 * (v19 >> 9);
      }
      v16 = (char *)(*(_QWORD *)v15 + 8 * (v19 & 0x1FF));
      goto LABEL_32;
    }
    if (AlphaOperation == *((_DWORD *)a2 + 6))
      break;
    if ((unint64_t)++v9 >= *((_QWORD *)this + 58))
      goto LABEL_10;
  }
  *a3 = v10;
  v17 = *((_QWORD *)this + 54);
  v15 = (char *)(v17 + 8 * (*((_QWORD *)this + 57) >> 9));
  if (*((_QWORD *)this + 55) == v17)
  {
    v16 = 0;
    if (!v9)
      goto LABEL_32;
  }
  else
  {
    v16 = (char *)(*(_QWORD *)v15 + 8 * (*((_QWORD *)this + 57) & 0x1FFLL));
    if (!v9)
      goto LABEL_32;
  }
  v20 = (uint64_t)&v16[-*(_QWORD *)v15] >> 3;
  v21 = v20 + v9;
  if (v20 + v9 < 1)
  {
    v23 = 511 - v9 - v20;
    LOWORD(v21) = ~(_WORD)v23;
    v15 -= 8 * (v23 >> 9);
  }
  else
  {
    v15 += 8 * (v21 >> 9);
  }
  v16 = (char *)(*(_QWORD *)v15 + 8 * (v21 & 0x1FF));
LABEL_32:
  std::deque<Pipeline *>::erase((int64x2_t *)((char *)this + 424), v15, v16);
  v24 = operator new(0x18uLL);
  v25 = (uint64_t)*a3;
  v24[1] = (char *)this + 400;
  v24[2] = v25;
  v26 = *((_QWORD *)this + 50);
  *v24 = v26;
  *(_QWORD *)(v26 + 8) = v24;
  *((_QWORD *)this + 50) = v24;
  ++*((_QWORD *)this + 52);
  v12 = 1;
LABEL_14:
  HGSynchronizable::Unlock(v6);
  return v12;
}

void sub_1B2AF68F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6930(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  HGSynchronizable *v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, HGSynchronizable *);
  v6 = va_arg(va1, _QWORD);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va1);
  _Unwind_Resume(a1);
}

void sub_1B2AF694C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF697C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

HGSynchronizable *HGRenderQueue::EnqueueGPUReadbackJob(HGRenderQueue *this, HGGLContext **a2)
{
  HGSynchronizable *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  unint64_t v11;
  int VirtualScreen;
  unint64_t v13;
  unint64_t v14;
  char v15;
  HGSynchronizable *v17;

  v4 = (HGSynchronizable *)*((_QWORD *)this + 73);
  HGSynchronizable::Lock(v4);
  v5 = *((_QWORD *)this + 69);
  v6 = *((_QWORD *)this + 68);
  if (v5 == v6)
    v7 = 0;
  else
    v7 = ((v5 - v6) << 6) - 1;
  v8 = *((_QWORD *)this + 72);
  v9 = v8 + *((_QWORD *)this + 71);
  if (v7 == v9)
  {
    std::deque<HGGPUReadbackJob *>::__add_back_capacity((uint64_t)this + 536);
    v8 = *((_QWORD *)this + 72);
    v6 = *((_QWORD *)this + 68);
    v9 = *((_QWORD *)this + 71) + v8;
  }
  *(_QWORD *)(*(_QWORD *)(v6 + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v9 & 0x1FF)) = a2;
  *((_QWORD *)this + 72) = v8 + 1;
  (*((void (**)(HGGLContext **))*a2 + 2))(a2);
  v10 = *((_DWORD *)this + 17);
  if ((v10 & 0x1000) != 0)
  {
    v11 = *((_QWORD *)this + 72);
LABEL_11:
    printf("EnqueueGPUReadbackJob: GPU Readback Queue Size: %lu\n", v11);
    goto LABEL_12;
  }
  if ((v10 & 0x2000) != 0)
  {
    v11 = *((_QWORD *)this + 72);
    if (v11 >= 2)
      goto LABEL_11;
  }
LABEL_12:
  VirtualScreen = HGGLContext::getVirtualScreen(a2[4]);
  if (*((_QWORD *)this + 72))
  {
    v13 = 0;
    v14 = 0;
    do
    {
      if (HGGLContext::getVirtualScreen(*(HGGLContext **)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 68)
                                                                                               + (((v14
                                                                                                  + *((_QWORD *)this + 71)) >> 6) & 0x3FFFFFFFFFFFFF8))
                                                                                   + 8
                                                                                   * ((v14 + *((_QWORD *)this + 71)) & 0x1FF))
                                                                       + 32)) == VirtualScreen)
        ++v13;
      ++v14;
    }
    while (v14 < *((_QWORD *)this + 72));
    v15 = v13 > *((_QWORD *)this + 66);
  }
  else
  {
    v15 = 0;
  }
  HGRenderQueue::SetThrottleFlagOnVirtualScreen(this, VirtualScreen, v15);
  HGSynchronizable::Unlock(v4);
  v17 = (HGSynchronizable *)*((_QWORD *)this + 63);
  HGSynchronizable::Lock(v17);
  HGSynchronizable::NotifyAll(v17);
  return HGSynchronizable::Unlock(v17);
}

void sub_1B2AF6B30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6B48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6B5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6B70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6B84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::GetGPUReadbackJob(HGRenderQueue *this, HGGLContext **a2, HGGPUReadbackJob **a3)
{
  HGSynchronizable *v6;
  HGSynchronizable *v7;
  int v8;
  uint64_t v9;

  v6 = (HGSynchronizable *)*((_QWORD *)this + 63);
  HGSynchronizable::Lock(v6);
  while ((HGRenderQueue::GetGPUReadbackJobFromQueue(this, a2, a3) & 1) == 0)
  {
    HGSynchronizable::Wait(v6);
    v7 = (HGSynchronizable *)*((_QWORD *)this + 43);
    HGSynchronizable::Lock(v7);
    v8 = *((_DWORD *)this + 4);
    HGSynchronizable::Unlock(v7);
    if (v8 == 3)
    {
      v9 = 0;
      goto LABEL_6;
    }
  }
  v9 = 1;
LABEL_6:
  HGSynchronizable::Unlock(v6);
  return v9;
}

void sub_1B2AF6C44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
  HGSynchronizer::~HGSynchronizer(&a9);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::GetGPUReadbackJobFromQueue(HGRenderQueue *this, HGGLContext **a2, HGGPUReadbackJob **a3)
{
  int VirtualScreen;
  HGSynchronizable *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  HGSynchronizable *v11;
  HGSynchronizable *v12;
  int v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  char *v21;
  uint64_t v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;

  *a3 = 0;
  if (!*((_BYTE *)this + 76))
    goto LABEL_11;
  VirtualScreen = HGGLContext::getVirtualScreen(a2[6]);
  v7 = (HGSynchronizable *)*((_QWORD *)this + 73);
  HGSynchronizable::Lock(v7);
  v8 = *((_QWORD *)this + 75);
  if ((HGRenderQueue *)v8 == (HGRenderQueue *)((char *)this + 592))
  {
    v9 = 0;
  }
  else
  {
    v9 = 0;
    do
    {
      if (HGGLContext::getVirtualScreen(*(HGGLContext **)(*(_QWORD *)(v8 + 16) + 32)) == VirtualScreen)
        ++v9;
      v8 = *(_QWORD *)(v8 + 8);
    }
    while ((HGRenderQueue *)v8 != (HGRenderQueue *)((char *)this + 592));
  }
  HGSynchronizable::Unlock(v7);
  if (!v9)
  {
LABEL_11:
    v11 = (HGSynchronizable *)*((_QWORD *)this + 73);
    HGSynchronizable::Lock(v11);
    if (*((_QWORD *)this + 72))
    {
      v12 = (HGSynchronizable *)*((_QWORD *)this + 43);
      HGSynchronizable::Lock(v12);
      v13 = *((_DWORD *)this + 4);
      HGSynchronizable::Unlock(v12);
      if (v13 != 2)
      {
        v14 = *((_QWORD *)this + 72);
        if (v14)
        {
          v15 = 0;
          v16 = *((_QWORD *)this + 71);
          while (1)
          {
            v17 = *((_QWORD *)this + 68);
            v18 = *(_QWORD *)(*(_QWORD *)(v17 + (((v16 + v15) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v16 + v15) & 0x1FF));
            if (*(HGGLContext **)(v18 + 16) == a2[2])
              break;
            if (++v15 >= v14)
              goto LABEL_23;
          }
          if ((*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v18 + 40) + 24) + 12) & 0x10) == 0)
            goto LABEL_21;
          if (HGRenderQueue::GetPBOFromSharedPool(this, (HGGPUReadbackExecUnit *)a2, *(HGGLContext ***)(*(_QWORD *)(v17 + (((v16 + v15) >> 6) & 0x3FFFFFFFFFFFFF8))+ 8 * ((v16 + v15) & 0x1FF))))
          {
            v16 = *((_QWORD *)this + 71);
LABEL_21:
            *a3 = (HGGPUReadbackJob *)v18;
            v19 = *((_QWORD *)this + 68);
            v20 = (char *)(v19 + 8 * (v16 >> 9));
            if (*((_QWORD *)this + 69) == v19)
              v21 = 0;
            else
              v21 = (char *)(*(_QWORD *)v20 + 8 * (v16 & 0x1FF));
            if (v15)
            {
              v23 = ((uint64_t)&v21[-*(_QWORD *)v20] >> 3) + v15;
              if (v23 < 1)
              {
                v24 = 511 - v23;
                v20 -= 8 * (v24 >> 9);
                v21 = (char *)(*(_QWORD *)v20 + 8 * (~(_WORD)v24 & 0x1FF));
              }
              else
              {
                v20 += 8 * ((unint64_t)v23 >> 9);
                v21 = (char *)(*(_QWORD *)v20 + 8 * (v23 & 0x1FF));
              }
            }
            std::deque<Pipeline *>::erase((int64x2_t *)((char *)this + 536), v20, v21);
            if ((*((_BYTE *)this + 69) & 0x10) != 0)
              printf("GetGPUReadbackJobFromQueue<%p>: GPU Readback Queue Size: %lu\n", a2, *((_QWORD *)this + 72));
            v25 = HGGLContext::getVirtualScreen(*(HGGLContext **)(v18 + 32));
            if (HGRenderQueue::GetThrottleFlagOnVirtualScreen(this, v25))
            {
              if (!*((_QWORD *)this + 72))
                goto LABEL_40;
              v26 = 0;
              v27 = 0;
              do
              {
                if (HGGLContext::getVirtualScreen(*(HGGLContext **)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 68) + (((v27 + *((_QWORD *)this + 71)) >> 6) & 0x3FFFFFFFFFFFFF8))
                                                                                             + 8
                                                                                             * ((v27
                                                                                               + *((_QWORD *)this + 71)) & 0x1FF))
                                                                                 + 32)) == v25)
                  ++v26;
                ++v27;
              }
              while (v27 < *((_QWORD *)this + 72));
              if (v26 <= *((_QWORD *)this + 66))
LABEL_40:
                HGRenderQueue::SetThrottleFlagOnVirtualScreen(this, v25, 0);
            }
            v28 = operator new(0x18uLL);
            v29 = (uint64_t)*a3;
            v28[1] = (char *)this + 592;
            v28[2] = v29;
            v30 = *((_QWORD *)this + 74);
            *v28 = v30;
            *(_QWORD *)(v30 + 8) = v28;
            *((_QWORD *)this + 74) = v28;
            ++*((_QWORD *)this + 76);
            v10 = 1;
            goto LABEL_24;
          }
        }
      }
    }
LABEL_23:
    v10 = 0;
LABEL_24:
    HGSynchronizable::Unlock(v11);
    return v10;
  }
  return 0;
}

void sub_1B2AF6F44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6F58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6F6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6F80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6F94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6FAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6FC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B2AF6FDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::GetPBOFromSharedPool(HGRenderQueue *this, HGGPUReadbackExecUnit *a2, HGGLContext **a3)
{
  int VirtualScreen;
  _QWORD *v7;
  uint64_t v8;
  int v10;
  int v11;
  int v12;
  int v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  _BOOL4 v18;
  int v19;
  int v20;
  uint64_t v21;
  const void *v22;
  int v23;
  unsigned int v24;
  void *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t **v31;
  uint64_t **v32;
  unint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t *v36;
  PCSharedCount v37;
  PCSharedCount v38;
  PCSharedCount v39;
  PCSharedCount v40;
  HGGLContext *v41;
  HGSynchronizable *v42;
  char v43;

  VirtualScreen = HGGLContext::getVirtualScreen(*((HGGLContext **)a2 + 6));
  if (VirtualScreen != HGGLContext::getVirtualScreen(a3[4]))
    return 0;
  v7 = (_QWORD *)((char *)a2 + 64);
  if (*((_QWORD *)a2 + 8))
    return 1;
  v42 = (HGSynchronizable *)*((_QWORD *)this + 80);
  v43 = 0;
  HGSynchronizable::Lock(v42);
  if ((*((_BYTE *)this + 69) & 0x10) != 0)
  {
    if (*((_QWORD *)this + 86))
    {
      v10 = 0;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      v14 = 0;
      do
      {
        v15 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 82)
                                    + (((v14 + *((_QWORD *)this + 85)) >> 6) & 0x3FFFFFFFFFFFFF8))
                        + 8 * ((v14 + *((_QWORD *)this + 85)) & 0x1FF));
        v40.var0 = *(PC_Sp_counted_base **)(*(_QWORD *)(v15 + 16) + 8);
        HGGLContext::Share((uint64_t *)&v40, (HGObject **)&v41);
        PCSharedCount::PCSharedCount(&v40);
        v16 = HGGLContext::getVirtualScreen(v41);
        v17 = atomic_load((unsigned int *)(v15 + 8));
        v18 = v17 == 1;
        v19 = v10 + v18;
        v20 = v11 + v18;
        if (v16)
          ++v12;
        else
          ++v13;
        if (v16)
          v10 = v19;
        else
          v11 = v20;
        if (v41)
          (*(void (**)(HGGLContext *))(*(_QWORD *)v41 + 24))(v41);
        ++v14;
      }
      while (v14 < *((_QWORD *)this + 86));
    }
    else
    {
      v13 = 0;
      v12 = 0;
      v11 = 0;
      v10 = 0;
    }
    printf("GetPBOFromSharedPool<%p>: Getting PBO for virtual screen %d.\n", a2, VirtualScreen);
    printf("GetPBOFromSharedPool<%p>: Num available PBOs : vs0: %d/%d  vs1: %d/%d\n", a2, v11, v13, v10, v12);
  }
  if (*((_QWORD *)this + 86))
  {
    v21 = 0;
    while (1)
    {
      v22 = *(const void **)(*(_QWORD *)(*((_QWORD *)this + 82)
                                       + (((unint64_t)(v21 + *((_QWORD *)this + 85)) >> 6) & 0x3FFFFFFFFFFFFF8))
                           + 8 * ((v21 + *((_QWORD *)this + 85)) & 0x1FF));
      v39.var0 = *(PC_Sp_counted_base **)(*((_QWORD *)v22 + 2) + 8);
      HGGLContext::Share((uint64_t *)&v39, (HGObject **)&v41);
      PCSharedCount::PCSharedCount(&v39);
      v23 = HGGLContext::getVirtualScreen(v41);
      v24 = atomic_load((unsigned int *)v22 + 2);
      if (v24 == 1 && v23 == VirtualScreen)
        break;
      if (v41)
        (*(void (**)(HGGLContext *))(*(_QWORD *)v41 + 24))(v41);
      if ((unint64_t)++v21 >= *((_QWORD *)this + 86))
        goto LABEL_29;
    }
    *v7 = v22;
    (*(void (**)(const void *))(*(_QWORD *)v22 + 16))(v22);
    v28 = mach_absolute_time();
    v29 = v28;
    v30 = (uint64_t *)*((_QWORD *)this + 78);
    if (v30)
    {
      while (1)
      {
        while (1)
        {
          v32 = (uint64_t **)v30;
          v33 = v30[4];
          if ((unint64_t)v22 >= v33)
            break;
          v30 = *v32;
          v31 = v32;
          if (!*v32)
            goto LABEL_48;
        }
        if (v33 >= (unint64_t)v22)
          break;
        v30 = v32[1];
        if (!v30)
        {
          v31 = v32 + 1;
          goto LABEL_48;
        }
      }
      v32[5] = (uint64_t *)v28;
      if ((*((_BYTE *)this + 69) & 0x10) == 0)
        goto LABEL_52;
    }
    else
    {
      v31 = (uint64_t **)((char *)this + 624);
      v32 = (uint64_t **)((char *)this + 624);
LABEL_48:
      v34 = (uint64_t *)operator new(0x30uLL);
      v34[4] = (uint64_t)v22;
      v34[5] = 0;
      *v34 = 0;
      v34[1] = 0;
      v34[2] = (uint64_t)v32;
      *v31 = v34;
      v35 = **((_QWORD **)this + 77);
      v36 = v34;
      if (v35)
      {
        *((_QWORD *)this + 77) = v35;
        v36 = *v31;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 78), v36);
      ++*((_QWORD *)this + 79);
      v34[5] = v29;
      if ((*((_BYTE *)this + 69) & 0x10) == 0)
        goto LABEL_52;
    }
    printf("GetPBOFromSharedPool<%p>: Checkout from pool :  vs: %d\n", v22, VirtualScreen);
LABEL_52:
    if (v41)
      (*(void (**)(HGGLContext *))(*(_QWORD *)v41 + 24))(v41);
LABEL_54:
    v8 = 1;
    if (v43)
      return v8;
LABEL_55:
    HGSynchronizable::Unlock(v42);
    return v8;
  }
LABEL_29:
  if (!*v7 && *((_QWORD *)a2 + 9) < *((_QWORD *)this + 65))
  {
    HGGLContext::context((uint64_t *)&v38, *((HGGLContext **)a2 + 6));
    HGGLContext::Create((uint64_t *)&v38, (HGObject **)&v41);
    PCSharedCount::PCSharedCount(&v38);
    if (v41)
    {
      HGGLContext::setVirtualScreen(v41);
      v26 = HGObject::operator new(0x40uLL);
      HGGLContext::context((uint64_t *)&v37, v41);
      HGPixelBufferObj::HGPixelBufferObj(v26, &v37);
      *v7 = v26;
      PCSharedCount::PCSharedCount(&v37);
      v27 = (uint64_t *)mach_absolute_time();
      *std::map<HGPixelBufferObj *,unsigned long long>::operator[]((uint64_t **)this + 77, (uint64_t **)a2 + 8) = v27;
      if (*v7)
      {
        std::deque<HGPixelBufferObj *>::push_back((_QWORD *)this + 81, (_QWORD *)a2 + 8);
        (*(void (**)(_QWORD))(*(_QWORD *)*v7 + 16))(*v7);
        std::deque<HGRef<HGGLContext>>::push_back((_QWORD *)this + 87, (uint64_t *)&v41);
        ++*((_QWORD *)a2 + 9);
        if ((*((_BYTE *)this + 69) & 0x10) != 0)
          printf("GetPBOFromSharedPool<%p>: Creating PBO at virtual screen %d.\n", a2, VirtualScreen);
        if (v41)
          (*(void (**)(HGGLContext *))(*(_QWORD *)v41 + 24))(v41);
        goto LABEL_54;
      }
      if (v41)
        (*(void (**)(HGGLContext *))(*(_QWORD *)v41 + 24))(v41);
    }
    v8 = 0;
    if (v43)
      return v8;
    goto LABEL_55;
  }
  if ((*((_BYTE *)this + 69) & 0x30) != 0)
    printf("GetPBOFromSharedPool<%p>: Warning: Max num PBOs in use (%lu in use: pboUnit for vs-%d).\n", a2, *((_QWORD *)a2 + 9), VirtualScreen);
  v8 = 0;
  *v7 = 0;
  if (!v43)
    goto LABEL_55;
  return v8;
}

void sub_1B2AF7478(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, PCSharedCount a14, char a15, PCSharedCount a16, char a17, uint64_t a18, HGSynchronizable *a19)
{
  void *v19;

  PCSharedCount::PCSharedCount(&a14);
  HGObject::operator delete(v19);
  if (a18)
    (*(void (**)(uint64_t))(*(_QWORD *)a18 + 24))(a18);
  HGSynchronizer::~HGSynchronizer(&a19);
  _Unwind_Resume(a1);
}

void std::deque<HGPixelBufferObj *>::push_back(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v4 = a1[2];
  v5 = a1[1];
  if (v4 == v5)
    v6 = 0;
  else
    v6 = ((v4 - v5) << 6) - 1;
  v7 = a1[5];
  v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<HGPixelBufferObj *>::__add_back_capacity((uint64_t)a1);
    v5 = a1[1];
    v7 = a1[5];
    v8 = a1[4] + v7;
  }
  *(_QWORD *)(*(_QWORD *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

uint64_t std::deque<HGRef<HGGLContext>>::push_back(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t result;

  v4 = a1[2];
  v5 = a1[1];
  if (v4 == v5)
    v6 = 0;
  else
    v6 = ((v4 - v5) << 6) - 1;
  v7 = a1[5];
  v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<HGRef<HGGLContext>>::__add_back_capacity((uint64_t)a1);
    v5 = a1[1];
    v7 = a1[5];
    v8 = v7 + a1[4];
  }
  result = *a2;
  *(_QWORD *)(*(_QWORD *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
    v7 = a1[5];
  }
  a1[5] = v7 + 1;
  return result;
}

double HGTiming::GetMachTimeConversionFactor(HGTiming *this)
{
  if (qword_1ED4DAB18 != -1)
    dispatch_once(&qword_1ED4DAB18, &__block_literal_global_86);
  return *(double *)&qword_1ED4DAB10;
}

double ___ZN8HGTiming27GetMachTimeConversionFactorEv_block_invoke()
{
  double result;
  unint64_t v1;
  mach_timebase_info info;

  if (!mach_timebase_info(&info))
  {
    LODWORD(result) = info.numer;
    LODWORD(v1) = info.denom;
    result = (double)*(unint64_t *)&result * 0.000000001 / (double)v1;
    qword_1ED4DAB10 = *(_QWORD *)&result;
  }
  return result;
}

uint64_t std::deque<HGRef<HGGLContext>>::~deque[abi:ne180100](uint64_t a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  void **v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;

  v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    v3 = *(void ***)(a1 + 8);
    *(_QWORD *)(a1 + 40) = 0;
    v10 = 0;
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 32);
    v5 = &v2[v4 >> 9];
    v6 = (char *)*v5;
    v7 = (char *)*v5 + 8 * (v4 & 0x1FF);
    v8 = *(uint64_t *)((char *)v2 + (((*(_QWORD *)(a1 + 40) + v4) >> 6) & 0x3FFFFFFFFFFFFF8))
       + 8 * ((*(_QWORD *)(a1 + 40) + v4) & 0x1FF);
    if (v7 != (char *)v8)
    {
      do
      {
        if (*(_QWORD *)v7)
        {
          (*(void (**)(_QWORD))(**(_QWORD **)v7 + 24))(*(_QWORD *)v7);
          v6 = (char *)*v5;
        }
        v7 += 8;
        if (v7 - v6 == 4096)
        {
          v9 = (char *)v5[1];
          ++v5;
          v6 = v9;
          v7 = v9;
        }
      }
      while (v7 != (char *)v8);
      v2 = *(void ***)(a1 + 8);
      v3 = *(void ***)(a1 + 16);
    }
    *(_QWORD *)(a1 + 40) = 0;
    v10 = (char *)v3 - (char *)v2;
    if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
    {
      do
      {
        operator delete(*v2);
        v3 = *(void ***)(a1 + 16);
        v2 = (void **)(*(_QWORD *)(a1 + 8) + 8);
        *(_QWORD *)(a1 + 8) = v2;
        v10 = (char *)v3 - (char *)v2;
      }
      while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
    }
  }
  v11 = v10 >> 3;
  if (v11 == 1)
  {
    v12 = 256;
    goto LABEL_17;
  }
  if (v11 == 2)
  {
    v12 = 512;
LABEL_17:
    *(_QWORD *)(a1 + 32) = v12;
  }
  if (v2 != v3)
  {
    do
    {
      v13 = *v2++;
      operator delete(v13);
    }
    while (v2 != v3);
    v15 = *(_QWORD *)(a1 + 8);
    v14 = *(_QWORD *)(a1 + 16);
    if (v14 != v15)
      *(_QWORD *)(a1 + 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::deque<HGRenderJob *>::__add_front_capacity(uint64_t a1)
{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  void *v12;
  void *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  void *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  unint64_t v34;
  int64_t v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int128 *v43;
  char *v44;
  uint64_t v45;
  __int128 v46;
  void *v47;

  v3 = *(char **)(a1 + 8);
  v2 = *(char **)(a1 + 16);
  if (v2 == v3)
    v4 = 0;
  else
    v4 = ((v2 - v3) << 6) - 1;
  v5 = *(_QWORD *)(a1 + 32);
  if ((unint64_t)(v4 - (*(_QWORD *)(a1 + 40) + v5)) >= 0x200)
  {
    *(_QWORD *)(a1 + 32) = v5 + 512;
    v47 = (void *)*((_QWORD *)v2 - 1);
    *(_QWORD *)(a1 + 16) = v2 - 8;
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
    return;
  }
  v6 = *(char **)(a1 + 24);
  v7 = *(char **)a1;
  v8 = (uint64_t)&v6[-*(_QWORD *)a1];
  if (v2 - v3 < (unint64_t)v8)
  {
    if (v3 == v7)
    {
      v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v47);
      v17 = *(_QWORD *)(a1 + 16);
      v47 = *(void **)(v17 - 8);
      *(_QWORD *)(a1 + 16) = v17 - 8;
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) == 8)
        goto LABEL_9;
    }
    else
    {
      v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) == 8)
      {
LABEL_9:
        v9 = 256;
LABEL_19:
        *(_QWORD *)(a1 + 32) = v9;
        return;
      }
    }
    v9 = *(_QWORD *)(a1 + 32) + 512;
    goto LABEL_19;
  }
  if (v6 == v7)
    v10 = 1;
  else
    v10 = v8 >> 2;
  if (v10 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v11 = (char *)operator new(8 * v10);
  v12 = operator new(0x1000uLL);
  v13 = v12;
  if (v10)
  {
    v14 = &v11[8 * v10];
    *(_QWORD *)v11 = v12;
    v15 = v11 + 8;
    v16 = v11;
    if (v3 != v2)
      goto LABEL_27;
    goto LABEL_21;
  }
  v18 = (char *)operator new(8uLL);
  v14 = v18 + 8;
  operator delete(v11);
  v3 = *(char **)(a1 + 8);
  v19 = *(char **)(a1 + 16);
  v11 = v18;
  *(_QWORD *)v18 = v13;
  v15 = v18 + 8;
  v16 = v18;
  if (v3 != v19)
  {
    while (1)
    {
LABEL_27:
      if (v15 == v14)
      {
        if (v11 <= v16)
        {
          if (v15 == v16)
            v31 = 1;
          else
            v31 = (v15 - v16) >> 2;
          if (v31 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v32 = (char *)operator new(8 * v31);
          v33 = v32;
          v34 = v31 >> 2;
          v20 = &v32[8 * (v31 >> 2)];
          v23 = v20;
          v35 = v15 - v11;
          if (v15 != v11)
          {
            v23 = &v20[v35 & 0xFFFFFFFFFFFFFFF8];
            v36 = v35 - 8;
            if (v36 < 0x38 || (v37 = 8 * v34, (unint64_t)(&v32[8 * v34] - v11) < 0x20))
            {
              v38 = &v32[8 * (v31 >> 2)];
              v39 = v11;
              goto LABEL_43;
            }
            v41 = (v36 >> 3) + 1;
            v42 = 8 * (v41 & 0x3FFFFFFFFFFFFFFCLL);
            v38 = &v20[v42];
            v39 = &v11[v42];
            v43 = (__int128 *)(v11 + 16);
            v44 = &v32[v37 + 16];
            v45 = v41 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v46 = *v43;
              *((_OWORD *)v44 - 1) = *(v43 - 1);
              *(_OWORD *)v44 = v46;
              v43 += 2;
              v44 += 32;
              v45 -= 4;
            }
            while (v45);
            if (v41 != (v41 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_43:
                v40 = *(_QWORD *)v39;
                v39 += 8;
                *(_QWORD *)v38 = v40;
                v38 += 8;
              }
              while (v38 != v23);
            }
          }
          v15 = &v32[8 * v31];
          if (v16)
            operator delete(v16);
          v16 = v33;
          goto LABEL_26;
        }
        v25 = (v11 - v16) >> 3;
        if (v25 >= -1)
          v26 = v25 + 1;
        else
          v26 = v25 + 2;
        v27 = v26 >> 1;
        v28 = &v11[-8 * (v26 >> 1)];
        v29 = v15;
        if (v15 != v11)
        {
          memmove(v28, v11, v15 - v11);
          v29 = v11;
        }
        v30 = -v27;
        v23 = &v28[v15 - v11];
        v20 = &v29[8 * v30];
      }
      else
      {
        v20 = v11;
        v23 = v15;
        v15 = v14;
      }
LABEL_26:
      v14 = v15;
      v24 = *(_QWORD *)v3;
      v3 += 8;
      *(_QWORD *)v23 = v24;
      v21 = v23 + 8;
      v15 = v21;
      v11 = v20;
      if (v3 == *(char **)(a1 + 16))
        goto LABEL_22;
    }
  }
LABEL_21:
  v20 = v11;
  v21 = v15;
LABEL_22:
  v22 = *(void **)a1;
  *(_QWORD *)a1 = v16;
  *(_QWORD *)(a1 + 8) = v20;
  *(_QWORD *)(a1 + 16) = v21;
  *(_QWORD *)(a1 + 24) = v14;
  if (v21 - v20 == 8)
  {
    *(_QWORD *)(a1 + 32) = 256;
    if (v22)
LABEL_24:
      operator delete(v22);
  }
  else
  {
    *(_QWORD *)(a1 + 32) += 512;
    if (v22)
      goto LABEL_24;
  }
}

void sub_1B2AF7C04(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v1);
  operator delete(v2);
  _Unwind_Resume(a1);
}

char *std::deque<HGRenderJob *>::__move_and_check(int a1, char *a2, char *__src, char *a4, char *a5, char *a6, char *__dst, unint64_t *a8)
{
  char *v10;
  char *v11;
  uint64_t v12;
  unint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;

  if (a5 != __src)
  {
    v10 = __src;
    v11 = a2;
    v12 = ((uint64_t)&a5[-*(_QWORD *)a4] >> 3) + ((a4 - a2) << 6) - ((uint64_t)&__src[-*(_QWORD *)a2] >> 3);
    if (v12 >= 1)
    {
      while (1)
      {
        v16 = *(_QWORD *)v11;
        v17 = *(_QWORD *)v11 + 4096;
        v18 = (v17 - (uint64_t)v10) >> 3;
        if (v18 >= v12)
          v19 = v12;
        else
          v19 = (v17 - (uint64_t)v10) >> 3;
        if (v18 <= v12)
          v20 = *(_QWORD *)v11 + 4096;
        else
          v20 = (unint64_t)&v10[8 * v12];
        v21 = *a8;
        if ((unint64_t)v10 <= *a8 && v21 < v20)
        {
          if (v10 != __dst)
          {
            v23 = ((uint64_t)&__dst[-*(_QWORD *)a6] >> 3) - (((uint64_t)&v10[-v16] >> 3) + ((v11 - a6) << 6));
            if (v23)
            {
              v24 = v23 + ((uint64_t)(v21 - v16) >> 3);
              if (v24 < 1)
                v21 = *(_QWORD *)&v11[-8 * ((unint64_t)(511 - v24) >> 9)] + 8 * (~(511 - (_WORD)v24) & 0x1FF);
              else
                v21 = *(_QWORD *)&v11[((unint64_t)v24 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v24 & 0x1FF);
            }
          }
          *a8 = v21;
        }
        if (v10 == (char *)v20)
          goto LABEL_33;
        v26 = *(char **)a6;
        a6 += 8;
        v25 = v26;
        v27 = v10;
        while (1)
        {
          v28 = (v25 - __dst + 4096) >> 3;
          v29 = (uint64_t)(v20 - (_QWORD)v27) >> 3 >= v28 ? v28 : (uint64_t)(v20 - (_QWORD)v27) >> 3;
          if (v29)
            memmove(__dst, v27, 8 * v29);
          v27 += 8 * v29;
          if (v27 == (char *)v20)
            break;
          v30 = *(char **)a6;
          a6 += 8;
          v25 = v30;
          __dst = v30;
        }
        __dst += 8 * v29;
        if ((char *)(*((_QWORD *)a6 - 1) + 4096) != __dst)
          break;
        __dst = *(char **)a6;
        if (v19)
        {
LABEL_34:
          v31 = v19 + ((uint64_t)&v10[-*(_QWORD *)v11] >> 3);
          if (v31 < 1)
          {
            v14 = 511 - v31;
            v11 -= 8 * (v14 >> 9);
            v10 = (char *)(*(_QWORD *)v11 + 8 * (~(_WORD)v14 & 0x1FF));
          }
          else
          {
            v11 += 8 * ((unint64_t)v31 >> 9);
            v10 = (char *)(*(_QWORD *)v11 + 8 * (v31 & 0x1FF));
          }
        }
LABEL_5:
        v15 = v12 <= v19;
        v12 -= v19;
        if (v15)
          return a6;
      }
      a6 -= 8;
LABEL_33:
      if (v19)
        goto LABEL_34;
      goto LABEL_5;
    }
  }
  return a6;
}

void std::deque<HGRenderJob *>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  void *v26;
  char *v27;
  char *v28;
  char *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  BOOL v37;
  int64_t v38;
  unint64_t v39;
  char *v40;
  _QWORD *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int64_t v45;
  unint64_t v46;
  char *v47;
  unint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  size_t v58;
  unint64_t v59;
  char *v60;
  unint64_t v61;
  int64_t v62;
  unint64_t v63;
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  __int128 *v69;
  char *v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  __int128 *v77;
  _OWORD *v78;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  __int128 *v85;
  _OWORD *v86;
  uint64_t v87;
  __int128 v88;
  uint64_t v89;
  void *v90;
  void *v91;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = v2 >= 0x200;
  v4 = v2 - 512;
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v4;
    v6 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_78:
      *(_QWORD *)v5 = v8;
      *(_QWORD *)(a1 + 16) += 8;
      return;
    }
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v31 = (v5 - v9) >> 2;
      if (v5 == v9)
        v31 = 1;
      if (!(v31 >> 61))
      {
        v32 = v31 >> 2;
        v33 = 8 * v31;
        v34 = (char *)operator new(8 * v31);
        v35 = &v34[8 * v32];
        v36 = &v34[v33];
        v38 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            v74 = &v34[8 * v32];
            v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              v75 = (v39 >> 3) + 1;
              v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              v40 = &v35[v76];
              v7 += v76;
              v77 = (__int128 *)(v6 + 3);
              v78 = v74 + 16;
              v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v40 = &v34[8 * v32];
          }
          do
          {
            v81 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_76;
      }
LABEL_87:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    v11 = v10 >> 3;
    if (v11 >= -1)
      v12 = v11 + 1;
    else
      v12 = v11 + 2;
    v13 = v12 >> 1;
    v14 = -v13;
    v15 = &v7[-8 * v13];
    v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      v7 = *(char **)(a1 + 8);
    }
    v5 = &v15[v16];
    *(_QWORD *)(a1 + 8) = &v7[8 * v14];
    *(_QWORD *)(a1 + 16) = &v15[v16];
    goto LABEL_78;
  }
  v18 = *(_QWORD *)(a1 + 16);
  v17 = *(_QWORD *)(a1 + 24);
  v19 = *(_QWORD *)(a1 + 8);
  v20 = v18 - v19;
  v21 = (v18 - v19) >> 3;
  v22 = v17 - *(_QWORD *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    v41 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v41 + 1);
    v8 = *v41;
    *(_QWORD *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24))
      goto LABEL_78;
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v42 = (v5 - v9) >> 2;
      if (v5 == v9)
        v42 = 1;
      if (!(v42 >> 61))
      {
        v43 = v42 >> 2;
        v44 = 8 * v42;
        v34 = (char *)operator new(8 * v42);
        v35 = &v34[8 * v43];
        v36 = &v34[v44];
        v45 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            v82 = &v34[8 * v43];
            v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              v83 = (v46 >> 3) + 1;
              v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              v47 = &v35[v84];
              v7 += v84;
              v85 = (__int128 *)(v41 + 3);
              v86 = v82 + 16;
              v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v47 = &v34[8 * v43];
          }
          do
          {
            v89 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_76:
        *(_QWORD *)a1 = v34;
        *(_QWORD *)(a1 + 8) = v35;
        *(_QWORD *)(a1 + 16) = v5;
        *(_QWORD *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          v5 = *(char **)(a1 + 16);
        }
        goto LABEL_78;
      }
      goto LABEL_87;
    }
    goto LABEL_5;
  }
  v23 = v22 >> 2;
  if (v17 == *(_QWORD *)a1)
    v24 = 1;
  else
    v24 = v23;
  if (v24 >> 61)
    goto LABEL_87;
  v25 = (char *)operator new(8 * v24);
  v26 = operator new(0x1000uLL);
  v27 = &v25[8 * v21];
  v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19)
        v48 = 1;
      else
        v48 = v20 >> 2;
      if (v48 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v49 = (char *)operator new(8 * v48);
      v27 = &v49[8 * (v48 >> 2)];
      v28 = &v49[8 * v48];
      operator delete(v25);
      v50 = *(_QWORD *)(a1 + 8);
      v18 = *(_QWORD *)(a1 + 16);
      v25 = v49;
      *(_QWORD *)v27 = v90;
      v29 = v27 + 8;
      if (v18 == v50)
        goto LABEL_45;
    }
    else
    {
      v30 = v21 + 2;
      if (v21 >= -1)
        v30 = v21 + 1;
      v27 -= 8 * (v30 >> 1);
      *(_QWORD *)v27 = v26;
      v29 = v27 + 8;
      if (v18 == v19)
        goto LABEL_45;
    }
    do
    {
LABEL_50:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27)
            v59 = 1;
          else
            v59 = (v28 - v27) >> 2;
          if (v59 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v60 = (char *)operator new(8 * v59);
          v25 = v60;
          v61 = (v59 + 3) >> 2;
          v53 = &v60[8 * v61];
          v62 = v29 - v27;
          v37 = v29 == v27;
          v29 = v53;
          if (!v37)
          {
            v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            v63 = v62 - 8;
            v64 = &v60[8 * v61];
            v65 = v27;
            if (v63 < 0x38)
              goto LABEL_91;
            v66 = 8 * v61;
            v64 = &v60[8 * v61];
            v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20)
              goto LABEL_91;
            v67 = (v63 >> 3) + 1;
            v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            v64 = &v53[v68];
            v65 = &v27[v68];
            v69 = (__int128 *)(v27 + 16);
            v70 = &v60[v66 + 16];
            v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_91:
              do
              {
                v73 = *(_QWORD *)v65;
                v65 += 8;
                *(_QWORD *)v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          v55 = (v28 - v29) >> 3;
          if (v55 >= -1)
            v56 = v55 + 1;
          else
            v56 = v55 + 2;
          v57 = &v29[8 * (v56 >> 1)];
          v53 = &v57[-(v29 - v27)];
          v58 = v29 - v27;
          v37 = v29 == v27;
          v29 = v57;
          if (!v37)
            memmove(v53, v27, v58);
          v25 = v27;
        }
      }
      else
      {
        v53 = v27;
      }
      v54 = *(_QWORD *)(v18 - 8);
      v18 -= 8;
      *((_QWORD *)v53 - 1) = v54;
      v51 = v53 - 8;
      v27 = v51;
    }
    while (v18 != *(_QWORD *)(a1 + 8));
    goto LABEL_46;
  }
  *(_QWORD *)v27 = v26;
  v29 = v27 + 8;
  if (v18 != v19)
    goto LABEL_50;
LABEL_45:
  v51 = v27;
LABEL_46:
  v52 = *(char **)a1;
  *(_QWORD *)a1 = v25;
  *(_QWORD *)(a1 + 8) = v51;
  *(_QWORD *)(a1 + 16) = v29;
  *(_QWORD *)(a1 + 24) = v28;
  if (v52)
    operator delete(v52);
}

void sub_1B2AF83A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  void *v9;

  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B2AF83C0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2AF83D4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2AF83EC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

char *std::deque<HGRenderJob *>::__move_backward_and_check(uint64_t a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7, unint64_t *a8)
{
  char *v10;
  char *v11;
  uint64_t v12;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  unint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;

  if (a5 != a3)
  {
    v10 = a5;
    v11 = a4;
    v12 = ((uint64_t)&a5[-*(_QWORD *)a4] >> 3) + ((a4 - a2) << 6) - ((uint64_t)&a3[-*(_QWORD *)a2] >> 3);
    if (v12 >= 1)
    {
      while (1)
      {
        v14 = *(char **)v11;
        if (v10 == *(char **)v11)
        {
          v15 = (char *)*((_QWORD *)v11 - 1);
          v11 -= 8;
          v14 = v15;
          v10 = v15 + 4096;
        }
        v16 = v10 - 8;
        v17 = (v10 - v14) >> 3;
        v18 = v17 >= v12 ? v12 : (v10 - v14) >> 3;
        v19 = v17 <= v12 ? v14 : &v10[-8 * v12];
        v20 = *a8;
        v21 = *a8 >= (unint64_t)v10 || (unint64_t)v19 > v20;
        if (!v21)
          break;
        if (v19 == v10)
          goto LABEL_34;
LABEL_25:
        v24 = *(_QWORD *)a6;
        while (1)
        {
          v25 = (uint64_t)&a7[-v24] >> 3;
          if ((v10 - v19) >> 3 < v25)
            v25 = (v10 - v19) >> 3;
          v10 -= 8 * v25;
          a7 -= 8 * v25;
          if (v25)
            memmove(a7, v10, 8 * v25);
          if (v10 == v19)
            break;
          v26 = *((_QWORD *)a6 - 1);
          a6 -= 8;
          v24 = v26;
          a7 = (char *)(v26 + 4096);
        }
        if ((char *)(*(_QWORD *)a6 + 4096) == a7)
        {
          v29 = (char *)*((_QWORD *)a6 + 1);
          a6 += 8;
          a7 = v29;
          v27 = v18 - 1;
          if (v18 != 1)
          {
LABEL_35:
            v28 = ((uint64_t)&v16[-*(_QWORD *)v11] >> 3) - v27;
            if (v28 < 1)
            {
              v30 = 511 - v28;
              v11 -= 8 * (v30 >> 9);
              v10 = (char *)(*(_QWORD *)v11 + 8 * (~(_WORD)v30 & 0x1FF));
            }
            else
            {
              v11 += 8 * ((unint64_t)v28 >> 9);
              v10 = (char *)(*(_QWORD *)v11 + 8 * (v28 & 0x1FF));
            }
            goto LABEL_5;
          }
        }
        else
        {
LABEL_34:
          v27 = v18 - 1;
          if (v18 != 1)
            goto LABEL_35;
        }
        v10 = v16;
LABEL_5:
        v21 = v12 <= v18;
        v12 -= v18;
        if (v21)
          return a6;
      }
      if (v16 == a7)
      {
        v23 = ((uint64_t)(v20 - (_QWORD)v14) >> 3) - 1;
        if (v23 >= 1)
          goto LABEL_21;
      }
      else
      {
        v22 = ~((v16 - v14) >> 3) + ((a6 - v11) << 6) + ((uint64_t)&a7[-*(_QWORD *)a6] >> 3);
        if (!v22)
        {
LABEL_24:
          *a8 = v20;
          goto LABEL_25;
        }
        v23 = v22 + ((uint64_t)(v20 - (_QWORD)v14) >> 3);
        if (v23 >= 1)
        {
LABEL_21:
          v20 = *(_QWORD *)&v11[((unint64_t)v23 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v23 & 0x1FF);
          goto LABEL_24;
        }
      }
      v20 = *(_QWORD *)&v11[-8 * ((unint64_t)(511 - v23) >> 9)] + 8 * (~(511 - (_WORD)v23) & 0x1FF);
      goto LABEL_24;
    }
  }
  return a6;
}

void std::deque<HGUserJob *>::__add_front_capacity(uint64_t a1)
{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  void *v12;
  void *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  void *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  unint64_t v34;
  int64_t v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int128 *v43;
  char *v44;
  uint64_t v45;
  __int128 v46;
  void *v47;

  v3 = *(char **)(a1 + 8);
  v2 = *(char **)(a1 + 16);
  if (v2 == v3)
    v4 = 0;
  else
    v4 = ((v2 - v3) << 6) - 1;
  v5 = *(_QWORD *)(a1 + 32);
  if ((unint64_t)(v4 - (*(_QWORD *)(a1 + 40) + v5)) >= 0x200)
  {
    *(_QWORD *)(a1 + 32) = v5 + 512;
    v47 = (void *)*((_QWORD *)v2 - 1);
    *(_QWORD *)(a1 + 16) = v2 - 8;
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
    return;
  }
  v6 = *(char **)(a1 + 24);
  v7 = *(char **)a1;
  v8 = (uint64_t)&v6[-*(_QWORD *)a1];
  if (v2 - v3 < (unint64_t)v8)
  {
    if (v3 == v7)
    {
      v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v47);
      v17 = *(_QWORD *)(a1 + 16);
      v47 = *(void **)(v17 - 8);
      *(_QWORD *)(a1 + 16) = v17 - 8;
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) == 8)
        goto LABEL_9;
    }
    else
    {
      v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) == 8)
      {
LABEL_9:
        v9 = 256;
LABEL_19:
        *(_QWORD *)(a1 + 32) = v9;
        return;
      }
    }
    v9 = *(_QWORD *)(a1 + 32) + 512;
    goto LABEL_19;
  }
  if (v6 == v7)
    v10 = 1;
  else
    v10 = v8 >> 2;
  if (v10 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v11 = (char *)operator new(8 * v10);
  v12 = operator new(0x1000uLL);
  v13 = v12;
  if (v10)
  {
    v14 = &v11[8 * v10];
    *(_QWORD *)v11 = v12;
    v15 = v11 + 8;
    v16 = v11;
    if (v3 != v2)
      goto LABEL_27;
    goto LABEL_21;
  }
  v18 = (char *)operator new(8uLL);
  v14 = v18 + 8;
  operator delete(v11);
  v3 = *(char **)(a1 + 8);
  v19 = *(char **)(a1 + 16);
  v11 = v18;
  *(_QWORD *)v18 = v13;
  v15 = v18 + 8;
  v16 = v18;
  if (v3 != v19)
  {
    while (1)
    {
LABEL_27:
      if (v15 == v14)
      {
        if (v11 <= v16)
        {
          if (v15 == v16)
            v31 = 1;
          else
            v31 = (v15 - v16) >> 2;
          if (v31 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v32 = (char *)operator new(8 * v31);
          v33 = v32;
          v34 = v31 >> 2;
          v20 = &v32[8 * (v31 >> 2)];
          v23 = v20;
          v35 = v15 - v11;
          if (v15 != v11)
          {
            v23 = &v20[v35 & 0xFFFFFFFFFFFFFFF8];
            v36 = v35 - 8;
            if (v36 < 0x38 || (v37 = 8 * v34, (unint64_t)(&v32[8 * v34] - v11) < 0x20))
            {
              v38 = &v32[8 * (v31 >> 2)];
              v39 = v11;
              goto LABEL_43;
            }
            v41 = (v36 >> 3) + 1;
            v42 = 8 * (v41 & 0x3FFFFFFFFFFFFFFCLL);
            v38 = &v20[v42];
            v39 = &v11[v42];
            v43 = (__int128 *)(v11 + 16);
            v44 = &v32[v37 + 16];
            v45 = v41 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v46 = *v43;
              *((_OWORD *)v44 - 1) = *(v43 - 1);
              *(_OWORD *)v44 = v46;
              v43 += 2;
              v44 += 32;
              v45 -= 4;
            }
            while (v45);
            if (v41 != (v41 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_43:
                v40 = *(_QWORD *)v39;
                v39 += 8;
                *(_QWORD *)v38 = v40;
                v38 += 8;
              }
              while (v38 != v23);
            }
          }
          v15 = &v32[8 * v31];
          if (v16)
            operator delete(v16);
          v16 = v33;
          goto LABEL_26;
        }
        v25 = (v11 - v16) >> 3;
        if (v25 >= -1)
          v26 = v25 + 1;
        else
          v26 = v25 + 2;
        v27 = v26 >> 1;
        v28 = &v11[-8 * (v26 >> 1)];
        v29 = v15;
        if (v15 != v11)
        {
          memmove(v28, v11, v15 - v11);
          v29 = v11;
        }
        v30 = -v27;
        v23 = &v28[v15 - v11];
        v20 = &v29[8 * v30];
      }
      else
      {
        v20 = v11;
        v23 = v15;
        v15 = v14;
      }
LABEL_26:
      v14 = v15;
      v24 = *(_QWORD *)v3;
      v3 += 8;
      *(_QWORD *)v23 = v24;
      v21 = v23 + 8;
      v15 = v21;
      v11 = v20;
      if (v3 == *(char **)(a1 + 16))
        goto LABEL_22;
    }
  }
LABEL_21:
  v20 = v11;
  v21 = v15;
LABEL_22:
  v22 = *(void **)a1;
  *(_QWORD *)a1 = v16;
  *(_QWORD *)(a1 + 8) = v20;
  *(_QWORD *)(a1 + 16) = v21;
  *(_QWORD *)(a1 + 24) = v14;
  if (v21 - v20 == 8)
  {
    *(_QWORD *)(a1 + 32) = 256;
    if (v22)
LABEL_24:
      operator delete(v22);
  }
  else
  {
    *(_QWORD *)(a1 + 32) += 512;
    if (v22)
      goto LABEL_24;
  }
}

void sub_1B2AF89A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v1);
  operator delete(v2);
  _Unwind_Resume(a1);
}

void std::deque<HGUserJob *>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  void *v26;
  char *v27;
  char *v28;
  char *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  BOOL v37;
  int64_t v38;
  unint64_t v39;
  char *v40;
  _QWORD *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int64_t v45;
  unint64_t v46;
  char *v47;
  unint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  size_t v58;
  unint64_t v59;
  char *v60;
  unint64_t v61;
  int64_t v62;
  unint64_t v63;
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  __int128 *v69;
  char *v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  __int128 *v77;
  _OWORD *v78;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  __int128 *v85;
  _OWORD *v86;
  uint64_t v87;
  __int128 v88;
  uint64_t v89;
  void *v90;
  void *v91;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = v2 >= 0x200;
  v4 = v2 - 512;
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v4;
    v6 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_78:
      *(_QWORD *)v5 = v8;
      *(_QWORD *)(a1 + 16) += 8;
      return;
    }
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v31 = (v5 - v9) >> 2;
      if (v5 == v9)
        v31 = 1;
      if (!(v31 >> 61))
      {
        v32 = v31 >> 2;
        v33 = 8 * v31;
        v34 = (char *)operator new(8 * v31);
        v35 = &v34[8 * v32];
        v36 = &v34[v33];
        v38 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            v74 = &v34[8 * v32];
            v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              v75 = (v39 >> 3) + 1;
              v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              v40 = &v35[v76];
              v7 += v76;
              v77 = (__int128 *)(v6 + 3);
              v78 = v74 + 16;
              v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v40 = &v34[8 * v32];
          }
          do
          {
            v81 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_76;
      }
LABEL_87:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    v11 = v10 >> 3;
    if (v11 >= -1)
      v12 = v11 + 1;
    else
      v12 = v11 + 2;
    v13 = v12 >> 1;
    v14 = -v13;
    v15 = &v7[-8 * v13];
    v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      v7 = *(char **)(a1 + 8);
    }
    v5 = &v15[v16];
    *(_QWORD *)(a1 + 8) = &v7[8 * v14];
    *(_QWORD *)(a1 + 16) = &v15[v16];
    goto LABEL_78;
  }
  v18 = *(_QWORD *)(a1 + 16);
  v17 = *(_QWORD *)(a1 + 24);
  v19 = *(_QWORD *)(a1 + 8);
  v20 = v18 - v19;
  v21 = (v18 - v19) >> 3;
  v22 = v17 - *(_QWORD *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    v41 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v41 + 1);
    v8 = *v41;
    *(_QWORD *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24))
      goto LABEL_78;
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v42 = (v5 - v9) >> 2;
      if (v5 == v9)
        v42 = 1;
      if (!(v42 >> 61))
      {
        v43 = v42 >> 2;
        v44 = 8 * v42;
        v34 = (char *)operator new(8 * v42);
        v35 = &v34[8 * v43];
        v36 = &v34[v44];
        v45 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            v82 = &v34[8 * v43];
            v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              v83 = (v46 >> 3) + 1;
              v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              v47 = &v35[v84];
              v7 += v84;
              v85 = (__int128 *)(v41 + 3);
              v86 = v82 + 16;
              v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v47 = &v34[8 * v43];
          }
          do
          {
            v89 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_76:
        *(_QWORD *)a1 = v34;
        *(_QWORD *)(a1 + 8) = v35;
        *(_QWORD *)(a1 + 16) = v5;
        *(_QWORD *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          v5 = *(char **)(a1 + 16);
        }
        goto LABEL_78;
      }
      goto LABEL_87;
    }
    goto LABEL_5;
  }
  v23 = v22 >> 2;
  if (v17 == *(_QWORD *)a1)
    v24 = 1;
  else
    v24 = v23;
  if (v24 >> 61)
    goto LABEL_87;
  v25 = (char *)operator new(8 * v24);
  v26 = operator new(0x1000uLL);
  v27 = &v25[8 * v21];
  v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19)
        v48 = 1;
      else
        v48 = v20 >> 2;
      if (v48 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v49 = (char *)operator new(8 * v48);
      v27 = &v49[8 * (v48 >> 2)];
      v28 = &v49[8 * v48];
      operator delete(v25);
      v50 = *(_QWORD *)(a1 + 8);
      v18 = *(_QWORD *)(a1 + 16);
      v25 = v49;
      *(_QWORD *)v27 = v90;
      v29 = v27 + 8;
      if (v18 == v50)
        goto LABEL_45;
    }
    else
    {
      v30 = v21 + 2;
      if (v21 >= -1)
        v30 = v21 + 1;
      v27 -= 8 * (v30 >> 1);
      *(_QWORD *)v27 = v26;
      v29 = v27 + 8;
      if (v18 == v19)
        goto LABEL_45;
    }
    do
    {
LABEL_50:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27)
            v59 = 1;
          else
            v59 = (v28 - v27) >> 2;
          if (v59 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v60 = (char *)operator new(8 * v59);
          v25 = v60;
          v61 = (v59 + 3) >> 2;
          v53 = &v60[8 * v61];
          v62 = v29 - v27;
          v37 = v29 == v27;
          v29 = v53;
          if (!v37)
          {
            v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            v63 = v62 - 8;
            v64 = &v60[8 * v61];
            v65 = v27;
            if (v63 < 0x38)
              goto LABEL_91;
            v66 = 8 * v61;
            v64 = &v60[8 * v61];
            v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20)
              goto LABEL_91;
            v67 = (v63 >> 3) + 1;
            v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            v64 = &v53[v68];
            v65 = &v27[v68];
            v69 = (__int128 *)(v27 + 16);
            v70 = &v60[v66 + 16];
            v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_91:
              do
              {
                v73 = *(_QWORD *)v65;
                v65 += 8;
                *(_QWORD *)v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          v55 = (v28 - v29) >> 3;
          if (v55 >= -1)
            v56 = v55 + 1;
          else
            v56 = v55 + 2;
          v57 = &v29[8 * (v56 >> 1)];
          v53 = &v57[-(v29 - v27)];
          v58 = v29 - v27;
          v37 = v29 == v27;
          v29 = v57;
          if (!v37)
            memmove(v53, v27, v58);
          v25 = v27;
        }
      }
      else
      {
        v53 = v27;
      }
      v54 = *(_QWORD *)(v18 - 8);
      v18 -= 8;
      *((_QWORD *)v53 - 1) = v54;
      v51 = v53 - 8;
      v27 = v51;
    }
    while (v18 != *(_QWORD *)(a1 + 8));
    goto LABEL_46;
  }
  *(_QWORD *)v27 = v26;
  v29 = v27 + 8;
  if (v18 != v19)
    goto LABEL_50;
LABEL_45:
  v51 = v27;
LABEL_46:
  v52 = *(char **)a1;
  *(_QWORD *)a1 = v25;
  *(_QWORD *)(a1 + 8) = v51;
  *(_QWORD *)(a1 + 16) = v29;
  *(_QWORD *)(a1 + 24) = v28;
  if (v52)
    operator delete(v52);
}

void sub_1B2AF8F3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  void *v9;

  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B2AF8F58(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2AF8F6C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2AF8F84(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::deque<HGGPUReadbackJob *>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  void *v26;
  char *v27;
  char *v28;
  char *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  BOOL v37;
  int64_t v38;
  unint64_t v39;
  char *v40;
  _QWORD *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int64_t v45;
  unint64_t v46;
  char *v47;
  unint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  size_t v58;
  unint64_t v59;
  char *v60;
  unint64_t v61;
  int64_t v62;
  unint64_t v63;
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  __int128 *v69;
  char *v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  __int128 *v77;
  _OWORD *v78;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  __int128 *v85;
  _OWORD *v86;
  uint64_t v87;
  __int128 v88;
  uint64_t v89;
  void *v90;
  void *v91;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = v2 >= 0x200;
  v4 = v2 - 512;
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v4;
    v6 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_78:
      *(_QWORD *)v5 = v8;
      *(_QWORD *)(a1 + 16) += 8;
      return;
    }
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v31 = (v5 - v9) >> 2;
      if (v5 == v9)
        v31 = 1;
      if (!(v31 >> 61))
      {
        v32 = v31 >> 2;
        v33 = 8 * v31;
        v34 = (char *)operator new(8 * v31);
        v35 = &v34[8 * v32];
        v36 = &v34[v33];
        v38 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            v74 = &v34[8 * v32];
            v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              v75 = (v39 >> 3) + 1;
              v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              v40 = &v35[v76];
              v7 += v76;
              v77 = (__int128 *)(v6 + 3);
              v78 = v74 + 16;
              v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v40 = &v34[8 * v32];
          }
          do
          {
            v81 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_76;
      }
LABEL_87:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    v11 = v10 >> 3;
    if (v11 >= -1)
      v12 = v11 + 1;
    else
      v12 = v11 + 2;
    v13 = v12 >> 1;
    v14 = -v13;
    v15 = &v7[-8 * v13];
    v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      v7 = *(char **)(a1 + 8);
    }
    v5 = &v15[v16];
    *(_QWORD *)(a1 + 8) = &v7[8 * v14];
    *(_QWORD *)(a1 + 16) = &v15[v16];
    goto LABEL_78;
  }
  v18 = *(_QWORD *)(a1 + 16);
  v17 = *(_QWORD *)(a1 + 24);
  v19 = *(_QWORD *)(a1 + 8);
  v20 = v18 - v19;
  v21 = (v18 - v19) >> 3;
  v22 = v17 - *(_QWORD *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    v41 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v41 + 1);
    v8 = *v41;
    *(_QWORD *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24))
      goto LABEL_78;
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v42 = (v5 - v9) >> 2;
      if (v5 == v9)
        v42 = 1;
      if (!(v42 >> 61))
      {
        v43 = v42 >> 2;
        v44 = 8 * v42;
        v34 = (char *)operator new(8 * v42);
        v35 = &v34[8 * v43];
        v36 = &v34[v44];
        v45 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            v82 = &v34[8 * v43];
            v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              v83 = (v46 >> 3) + 1;
              v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              v47 = &v35[v84];
              v7 += v84;
              v85 = (__int128 *)(v41 + 3);
              v86 = v82 + 16;
              v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v47 = &v34[8 * v43];
          }
          do
          {
            v89 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_76:
        *(_QWORD *)a1 = v34;
        *(_QWORD *)(a1 + 8) = v35;
        *(_QWORD *)(a1 + 16) = v5;
        *(_QWORD *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          v5 = *(char **)(a1 + 16);
        }
        goto LABEL_78;
      }
      goto LABEL_87;
    }
    goto LABEL_5;
  }
  v23 = v22 >> 2;
  if (v17 == *(_QWORD *)a1)
    v24 = 1;
  else
    v24 = v23;
  if (v24 >> 61)
    goto LABEL_87;
  v25 = (char *)operator new(8 * v24);
  v26 = operator new(0x1000uLL);
  v27 = &v25[8 * v21];
  v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19)
        v48 = 1;
      else
        v48 = v20 >> 2;
      if (v48 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v49 = (char *)operator new(8 * v48);
      v27 = &v49[8 * (v48 >> 2)];
      v28 = &v49[8 * v48];
      operator delete(v25);
      v50 = *(_QWORD *)(a1 + 8);
      v18 = *(_QWORD *)(a1 + 16);
      v25 = v49;
      *(_QWORD *)v27 = v90;
      v29 = v27 + 8;
      if (v18 == v50)
        goto LABEL_45;
    }
    else
    {
      v30 = v21 + 2;
      if (v21 >= -1)
        v30 = v21 + 1;
      v27 -= 8 * (v30 >> 1);
      *(_QWORD *)v27 = v26;
      v29 = v27 + 8;
      if (v18 == v19)
        goto LABEL_45;
    }
    do
    {
LABEL_50:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27)
            v59 = 1;
          else
            v59 = (v28 - v27) >> 2;
          if (v59 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v60 = (char *)operator new(8 * v59);
          v25 = v60;
          v61 = (v59 + 3) >> 2;
          v53 = &v60[8 * v61];
          v62 = v29 - v27;
          v37 = v29 == v27;
          v29 = v53;
          if (!v37)
          {
            v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            v63 = v62 - 8;
            v64 = &v60[8 * v61];
            v65 = v27;
            if (v63 < 0x38)
              goto LABEL_91;
            v66 = 8 * v61;
            v64 = &v60[8 * v61];
            v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20)
              goto LABEL_91;
            v67 = (v63 >> 3) + 1;
            v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            v64 = &v53[v68];
            v65 = &v27[v68];
            v69 = (__int128 *)(v27 + 16);
            v70 = &v60[v66 + 16];
            v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_91:
              do
              {
                v73 = *(_QWORD *)v65;
                v65 += 8;
                *(_QWORD *)v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          v55 = (v28 - v29) >> 3;
          if (v55 >= -1)
            v56 = v55 + 1;
          else
            v56 = v55 + 2;
          v57 = &v29[8 * (v56 >> 1)];
          v53 = &v57[-(v29 - v27)];
          v58 = v29 - v27;
          v37 = v29 == v27;
          v29 = v57;
          if (!v37)
            memmove(v53, v27, v58);
          v25 = v27;
        }
      }
      else
      {
        v53 = v27;
      }
      v54 = *(_QWORD *)(v18 - 8);
      v18 -= 8;
      *((_QWORD *)v53 - 1) = v54;
      v51 = v53 - 8;
      v27 = v51;
    }
    while (v18 != *(_QWORD *)(a1 + 8));
    goto LABEL_46;
  }
  *(_QWORD *)v27 = v26;
  v29 = v27 + 8;
  if (v18 != v19)
    goto LABEL_50;
LABEL_45:
  v51 = v27;
LABEL_46:
  v52 = *(char **)a1;
  *(_QWORD *)a1 = v25;
  *(_QWORD *)(a1 + 8) = v51;
  *(_QWORD *)(a1 + 16) = v29;
  *(_QWORD *)(a1 + 24) = v28;
  if (v52)
    operator delete(v52);
}

void sub_1B2AF94F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  void *v9;

  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B2AF9514(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2AF9528(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2AF9540(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::deque<HGPixelBufferObj *>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  void *v26;
  char *v27;
  char *v28;
  char *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  BOOL v37;
  int64_t v38;
  unint64_t v39;
  char *v40;
  _QWORD *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int64_t v45;
  unint64_t v46;
  char *v47;
  unint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  size_t v58;
  unint64_t v59;
  char *v60;
  unint64_t v61;
  int64_t v62;
  unint64_t v63;
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  __int128 *v69;
  char *v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  __int128 *v77;
  _OWORD *v78;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  __int128 *v85;
  _OWORD *v86;
  uint64_t v87;
  __int128 v88;
  uint64_t v89;
  void *v90;
  void *v91;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = v2 >= 0x200;
  v4 = v2 - 512;
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v4;
    v6 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_78:
      *(_QWORD *)v5 = v8;
      *(_QWORD *)(a1 + 16) += 8;
      return;
    }
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v31 = (v5 - v9) >> 2;
      if (v5 == v9)
        v31 = 1;
      if (!(v31 >> 61))
      {
        v32 = v31 >> 2;
        v33 = 8 * v31;
        v34 = (char *)operator new(8 * v31);
        v35 = &v34[8 * v32];
        v36 = &v34[v33];
        v38 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            v74 = &v34[8 * v32];
            v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              v75 = (v39 >> 3) + 1;
              v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              v40 = &v35[v76];
              v7 += v76;
              v77 = (__int128 *)(v6 + 3);
              v78 = v74 + 16;
              v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v40 = &v34[8 * v32];
          }
          do
          {
            v81 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_76;
      }
LABEL_87:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    v11 = v10 >> 3;
    if (v11 >= -1)
      v12 = v11 + 1;
    else
      v12 = v11 + 2;
    v13 = v12 >> 1;
    v14 = -v13;
    v15 = &v7[-8 * v13];
    v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      v7 = *(char **)(a1 + 8);
    }
    v5 = &v15[v16];
    *(_QWORD *)(a1 + 8) = &v7[8 * v14];
    *(_QWORD *)(a1 + 16) = &v15[v16];
    goto LABEL_78;
  }
  v18 = *(_QWORD *)(a1 + 16);
  v17 = *(_QWORD *)(a1 + 24);
  v19 = *(_QWORD *)(a1 + 8);
  v20 = v18 - v19;
  v21 = (v18 - v19) >> 3;
  v22 = v17 - *(_QWORD *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    v41 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v41 + 1);
    v8 = *v41;
    *(_QWORD *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24))
      goto LABEL_78;
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v42 = (v5 - v9) >> 2;
      if (v5 == v9)
        v42 = 1;
      if (!(v42 >> 61))
      {
        v43 = v42 >> 2;
        v44 = 8 * v42;
        v34 = (char *)operator new(8 * v42);
        v35 = &v34[8 * v43];
        v36 = &v34[v44];
        v45 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            v82 = &v34[8 * v43];
            v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              v83 = (v46 >> 3) + 1;
              v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              v47 = &v35[v84];
              v7 += v84;
              v85 = (__int128 *)(v41 + 3);
              v86 = v82 + 16;
              v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v47 = &v34[8 * v43];
          }
          do
          {
            v89 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_76:
        *(_QWORD *)a1 = v34;
        *(_QWORD *)(a1 + 8) = v35;
        *(_QWORD *)(a1 + 16) = v5;
        *(_QWORD *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          v5 = *(char **)(a1 + 16);
        }
        goto LABEL_78;
      }
      goto LABEL_87;
    }
    goto LABEL_5;
  }
  v23 = v22 >> 2;
  if (v17 == *(_QWORD *)a1)
    v24 = 1;
  else
    v24 = v23;
  if (v24 >> 61)
    goto LABEL_87;
  v25 = (char *)operator new(8 * v24);
  v26 = operator new(0x1000uLL);
  v27 = &v25[8 * v21];
  v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19)
        v48 = 1;
      else
        v48 = v20 >> 2;
      if (v48 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v49 = (char *)operator new(8 * v48);
      v27 = &v49[8 * (v48 >> 2)];
      v28 = &v49[8 * v48];
      operator delete(v25);
      v50 = *(_QWORD *)(a1 + 8);
      v18 = *(_QWORD *)(a1 + 16);
      v25 = v49;
      *(_QWORD *)v27 = v90;
      v29 = v27 + 8;
      if (v18 == v50)
        goto LABEL_45;
    }
    else
    {
      v30 = v21 + 2;
      if (v21 >= -1)
        v30 = v21 + 1;
      v27 -= 8 * (v30 >> 1);
      *(_QWORD *)v27 = v26;
      v29 = v27 + 8;
      if (v18 == v19)
        goto LABEL_45;
    }
    do
    {
LABEL_50:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27)
            v59 = 1;
          else
            v59 = (v28 - v27) >> 2;
          if (v59 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v60 = (char *)operator new(8 * v59);
          v25 = v60;
          v61 = (v59 + 3) >> 2;
          v53 = &v60[8 * v61];
          v62 = v29 - v27;
          v37 = v29 == v27;
          v29 = v53;
          if (!v37)
          {
            v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            v63 = v62 - 8;
            v64 = &v60[8 * v61];
            v65 = v27;
            if (v63 < 0x38)
              goto LABEL_91;
            v66 = 8 * v61;
            v64 = &v60[8 * v61];
            v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20)
              goto LABEL_91;
            v67 = (v63 >> 3) + 1;
            v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            v64 = &v53[v68];
            v65 = &v27[v68];
            v69 = (__int128 *)(v27 + 16);
            v70 = &v60[v66 + 16];
            v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_91:
              do
              {
                v73 = *(_QWORD *)v65;
                v65 += 8;
                *(_QWORD *)v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          v55 = (v28 - v29) >> 3;
          if (v55 >= -1)
            v56 = v55 + 1;
          else
            v56 = v55 + 2;
          v57 = &v29[8 * (v56 >> 1)];
          v53 = &v57[-(v29 - v27)];
          v58 = v29 - v27;
          v37 = v29 == v27;
          v29 = v57;
          if (!v37)
            memmove(v53, v27, v58);
          v25 = v27;
        }
      }
      else
      {
        v53 = v27;
      }
      v54 = *(_QWORD *)(v18 - 8);
      v18 -= 8;
      *((_QWORD *)v53 - 1) = v54;
      v51 = v53 - 8;
      v27 = v51;
    }
    while (v18 != *(_QWORD *)(a1 + 8));
    goto LABEL_46;
  }
  *(_QWORD *)v27 = v26;
  v29 = v27 + 8;
  if (v18 != v19)
    goto LABEL_50;
LABEL_45:
  v51 = v27;
LABEL_46:
  v52 = *(char **)a1;
  *(_QWORD *)a1 = v25;
  *(_QWORD *)(a1 + 8) = v51;
  *(_QWORD *)(a1 + 16) = v29;
  *(_QWORD *)(a1 + 24) = v28;
  if (v52)
    operator delete(v52);
}

void sub_1B2AF9AB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  void *v9;

  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B2AF9AD0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2AF9AE4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2AF9AFC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::deque<HGRef<HGGLContext>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  void *v26;
  char *v27;
  char *v28;
  char *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  BOOL v37;
  int64_t v38;
  unint64_t v39;
  char *v40;
  _QWORD *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int64_t v45;
  unint64_t v46;
  char *v47;
  unint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  size_t v58;
  unint64_t v59;
  char *v60;
  unint64_t v61;
  int64_t v62;
  unint64_t v63;
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  __int128 *v69;
  char *v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  __int128 *v77;
  _OWORD *v78;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  __int128 *v85;
  _OWORD *v86;
  uint64_t v87;
  __int128 v88;
  uint64_t v89;
  void *v90;
  void *v91;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = v2 >= 0x200;
  v4 = v2 - 512;
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v4;
    v6 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_78:
      *(_QWORD *)v5 = v8;
      *(_QWORD *)(a1 + 16) += 8;
      return;
    }
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v31 = (v5 - v9) >> 2;
      if (v5 == v9)
        v31 = 1;
      if (!(v31 >> 61))
      {
        v32 = v31 >> 2;
        v33 = 8 * v31;
        v34 = (char *)operator new(8 * v31);
        v35 = &v34[8 * v32];
        v36 = &v34[v33];
        v38 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            v74 = &v34[8 * v32];
            v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              v75 = (v39 >> 3) + 1;
              v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              v40 = &v35[v76];
              v7 += v76;
              v77 = (__int128 *)(v6 + 3);
              v78 = v74 + 16;
              v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v40 = &v34[8 * v32];
          }
          do
          {
            v81 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_76;
      }
LABEL_87:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    v11 = v10 >> 3;
    if (v11 >= -1)
      v12 = v11 + 1;
    else
      v12 = v11 + 2;
    v13 = v12 >> 1;
    v14 = -v13;
    v15 = &v7[-8 * v13];
    v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      v7 = *(char **)(a1 + 8);
    }
    v5 = &v15[v16];
    *(_QWORD *)(a1 + 8) = &v7[8 * v14];
    *(_QWORD *)(a1 + 16) = &v15[v16];
    goto LABEL_78;
  }
  v18 = *(_QWORD *)(a1 + 16);
  v17 = *(_QWORD *)(a1 + 24);
  v19 = *(_QWORD *)(a1 + 8);
  v20 = v18 - v19;
  v21 = (v18 - v19) >> 3;
  v22 = v17 - *(_QWORD *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    v41 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v41 + 1);
    v8 = *v41;
    *(_QWORD *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24))
      goto LABEL_78;
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v42 = (v5 - v9) >> 2;
      if (v5 == v9)
        v42 = 1;
      if (!(v42 >> 61))
      {
        v43 = v42 >> 2;
        v44 = 8 * v42;
        v34 = (char *)operator new(8 * v42);
        v35 = &v34[8 * v43];
        v36 = &v34[v44];
        v45 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            v82 = &v34[8 * v43];
            v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              v83 = (v46 >> 3) + 1;
              v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              v47 = &v35[v84];
              v7 += v84;
              v85 = (__int128 *)(v41 + 3);
              v86 = v82 + 16;
              v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v47 = &v34[8 * v43];
          }
          do
          {
            v89 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_76:
        *(_QWORD *)a1 = v34;
        *(_QWORD *)(a1 + 8) = v35;
        *(_QWORD *)(a1 + 16) = v5;
        *(_QWORD *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          v5 = *(char **)(a1 + 16);
        }
        goto LABEL_78;
      }
      goto LABEL_87;
    }
    goto LABEL_5;
  }
  v23 = v22 >> 2;
  if (v17 == *(_QWORD *)a1)
    v24 = 1;
  else
    v24 = v23;
  if (v24 >> 61)
    goto LABEL_87;
  v25 = (char *)operator new(8 * v24);
  v26 = operator new(0x1000uLL);
  v27 = &v25[8 * v21];
  v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19)
        v48 = 1;
      else
        v48 = v20 >> 2;
      if (v48 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v49 = (char *)operator new(8 * v48);
      v27 = &v49[8 * (v48 >> 2)];
      v28 = &v49[8 * v48];
      operator delete(v25);
      v50 = *(_QWORD *)(a1 + 8);
      v18 = *(_QWORD *)(a1 + 16);
      v25 = v49;
      *(_QWORD *)v27 = v90;
      v29 = v27 + 8;
      if (v18 == v50)
        goto LABEL_45;
    }
    else
    {
      v30 = v21 + 2;
      if (v21 >= -1)
        v30 = v21 + 1;
      v27 -= 8 * (v30 >> 1);
      *(_QWORD *)v27 = v26;
      v29 = v27 + 8;
      if (v18 == v19)
        goto LABEL_45;
    }
    do
    {
LABEL_50:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27)
            v59 = 1;
          else
            v59 = (v28 - v27) >> 2;
          if (v59 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v60 = (char *)operator new(8 * v59);
          v25 = v60;
          v61 = (v59 + 3) >> 2;
          v53 = &v60[8 * v61];
          v62 = v29 - v27;
          v37 = v29 == v27;
          v29 = v53;
          if (!v37)
          {
            v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            v63 = v62 - 8;
            v64 = &v60[8 * v61];
            v65 = v27;
            if (v63 < 0x38)
              goto LABEL_91;
            v66 = 8 * v61;
            v64 = &v60[8 * v61];
            v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20)
              goto LABEL_91;
            v67 = (v63 >> 3) + 1;
            v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            v64 = &v53[v68];
            v65 = &v27[v68];
            v69 = (__int128 *)(v27 + 16);
            v70 = &v60[v66 + 16];
            v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_91:
              do
              {
                v73 = *(_QWORD *)v65;
                v65 += 8;
                *(_QWORD *)v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          v55 = (v28 - v29) >> 3;
          if (v55 >= -1)
            v56 = v55 + 1;
          else
            v56 = v55 + 2;
          v57 = &v29[8 * (v56 >> 1)];
          v53 = &v57[-(v29 - v27)];
          v58 = v29 - v27;
          v37 = v29 == v27;
          v29 = v57;
          if (!v37)
            memmove(v53, v27, v58);
          v25 = v27;
        }
      }
      else
      {
        v53 = v27;
      }
      v54 = *(_QWORD *)(v18 - 8);
      v18 -= 8;
      *((_QWORD *)v53 - 1) = v54;
      v51 = v53 - 8;
      v27 = v51;
    }
    while (v18 != *(_QWORD *)(a1 + 8));
    goto LABEL_46;
  }
  *(_QWORD *)v27 = v26;
  v29 = v27 + 8;
  if (v18 != v19)
    goto LABEL_50;
LABEL_45:
  v51 = v27;
LABEL_46:
  v52 = *(char **)a1;
  *(_QWORD *)a1 = v25;
  *(_QWORD *)(a1 + 8) = v51;
  *(_QWORD *)(a1 + 16) = v29;
  *(_QWORD *)(a1 + 24) = v28;
  if (v52)
    operator delete(v52);
}

void sub_1B2AFA070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  void *v9;

  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B2AFA08C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2AFA0A0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2AFA0B8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

const char *HGNode::RenderPageDeluxeMetalTextures(uint64_t a1, HGGPURenderer **a2)
{
  uint64_t MetalContext;
  int v5;
  const char *v6;
  char *v7;
  const char *result;
  void *v9;

  MetalContext = HGGPURenderer::GetMetalContext(*a2);
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 520))(a1);
  switch(v5)
  {
    case 2:
      v9 = (void *)objc_msgSend(*(id *)(MetalContext + 32), "commandBuffer");
      (*(void (**)(uint64_t, HGGPURenderer **, void *))(*(_QWORD *)a1 + 552))(a1, a2, v9);
      objc_msgSend(v9, "commit");
      HGGPURenderer::SetLastMetalCmdBuffer((uint64_t)*a2, v9);
      result = (const char *)(*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)*a2 + 128))(*a2, 41);
      if ((_DWORD)result)
        return (const char *)objc_msgSend(v9, "waitUntilCompleted");
      break;
    case 3:
      return (const char *)(*(uint64_t (**)(uint64_t, HGGPURenderer **, _QWORD))(*(_QWORD *)a1 + 560))(a1, a2, *(_QWORD *)(MetalContext + 32));
    case 4:
      return (const char *)(*(uint64_t (**)(uint64_t, HGGPURenderer **))(*(_QWORD *)a1 + 568))(a1, a2);
    default:
      return HGLogger::warning((HGLogger *)"HGNode::RenderPageDeluxeMetalTextures() could not find a valid rendering path.", v6, v7);
  }
  return result;
}

void HGComicStroke::HGComicStroke(HGComicStroke *this)
{
  uint64_t v1;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v1 = off_1E6530A68;
  *(_OWORD *)(v1 + 408) = xmmword_1B304EFF0;
  *(_DWORD *)(v1 + 16) |= 0x620u;
}

void HGComicStroke::~HGComicStroke(HGNode *this)
{
  void *v1;

  HGNode::~HGNode(this);
  HGObject::operator delete(v1);
}

uint64_t HGComicStroke::SetParameter(HGComicStroke *this, int a2, float a3, float a4, float a5, float a6)
{
  uint64_t result;

  switch(a2)
  {
    case 0:
      if (*((float *)this + 102) == a3)
        goto LABEL_11;
      *((float *)this + 102) = a3;
      result = 1;
      break;
    case 1:
      if (*((float *)this + 103) == a3)
        goto LABEL_11;
      *((float *)this + 103) = a3;
      result = 1;
      break;
    case 2:
      if (*((float *)this + 104) == a3)
        goto LABEL_11;
      *((float *)this + 104) = a3;
      result = 1;
      break;
    case 3:
      if (*((float *)this + 105) == a3)
      {
LABEL_11:
        result = 0;
      }
      else
      {
        *((float *)this + 105) = a3;
        result = 1;
      }
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HGComicStroke::IntermediateFormat()
{
  return 24;
}

uint64_t HGComicStroke::GetDOD(HGComicStroke *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t DOD;
  double v6;
  const HGTransform *v7;
  uint64_t v8;
  HGTransformUtils *v9;
  float v10;
  _BYTE v12[144];
  HGRect v13;
  HGRect v14;

  v13 = a4;
  if (a3)
    return 0;
  if (HGRect::IsInfinite(&v13))
    return *(_QWORD *)&v13.var0;
  v6 = *((float *)this + 105);
  HGTransform::HGTransform((HGTransform *)v12);
  HGTransform::Scale((HGTransform *)v12, v6, v6, 1.0);
  v7 = *(const HGTransform **)&v13.var0;
  v8 = *(_QWORD *)&v13.var2;
  v10 = HGTransformUtils::MinW(v9);
  *(_QWORD *)&v14.var0 = v8;
  DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v12, v7, v14, 0.5, v10);
  HGTransform::~HGTransform((HGTransform *)v12);
  return DOD;
}

void sub_1B2AFA394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B2AFA3A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HGComicStroke::GetROI(HGComicStroke *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  unint64_t v5;
  double v7;
  HGTransformUtils *v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE v18[144];
  HGRect v19;
  HGRect v20;
  HGRect v21;
  HGRect v22;
  HGRect v23;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (a3 == 1)
  {
    v19 = a4;
    v14 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    v16 = v15;
    *(_QWORD *)&v22.var0 = v14;
    *(_QWORD *)&v22.var2 = v16;
    HGRect::Grow(&v19, v22);
  }
  else if (a3)
  {
    v19 = (HGRect)HGRectNull;
  }
  else
  {
    v7 = 1.0 / *((float *)this + 105);
    HGTransform::HGTransform((HGTransform *)v18);
    HGTransform::Scale((HGTransform *)v18, v7, v7, 1.0);
    *(_QWORD *)&v19.var0 = 0;
    *(_QWORD *)&v19.var2 = 0;
    v9 = HGTransformUtils::MinW(v8);
    *(_QWORD *)&v23.var0 = v4;
    *(_QWORD *)&v19.var0 = HGTransformUtils::GetROI((HGTransformUtils *)v18, v5, v23, 0.5, v9);
    *(_QWORD *)&v19.var2 = *(_QWORD *)&v20.var0;
    LODWORD(v10) = vcvtps_s32_f32(*((float *)this + 102) + *((float *)this + 102));
    *(_QWORD *)&v20.var2 = v10 | (v10 << 32);
    v20.var0 = -(int)v10;
    v20.var1 = -(int)v10;
    HGRect::Grow(&v19, v20);
    v11 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    v13 = v12;
    *(_QWORD *)&v21.var0 = v11;
    *(_QWORD *)&v21.var2 = v13;
    HGRect::Grow(&v19, v21);
    HGTransform::~HGTransform((HGTransform *)v18);
  }
  return *(_QWORD *)&v19.var0;
}

void sub_1B2AFA4F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B2AFA504(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B2AFA518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HGComicStroke::RenderTile(HGComicStroke *this, HGTile *a2)
{
  float v4;
  uint64_t v5;
  int v6;
  int8x16_t v7;
  int32x2_t v8;
  int v9;
  int v10;
  float32x4_t v11;
  float v12;
  float v13;
  uint64_t v14;
  int v15;
  int8x16_t v16;
  float v23;
  float32x4_t v24;
  uint64_t v25;
  float32x4_t v26;
  uint64_t v27;
  uint64_t v28;
  float32x4_t v29;
  int32x4_t v30;
  float32x2_t v31;
  float32x4_t *v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t v41;
  float32x4_t v42;
  uint64_t v43;
  uint64_t v44;
  float32x4_t v45;
  int32x4_t v46;
  float32x2_t v47;
  float32x4_t *v48;
  float32x4_t v49;
  float v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  uint64_t v54;
  int v55;
  float v56;
  float32x4_t v57;
  int32x4_t v58;
  float32x4_t *v59;
  float32x4_t v60;
  int8x16_t v61;
  float32x4_t v62;
  int32x4_t v63;
  float32x4_t *v64;
  float32x4_t v65;
  int8x16_t v66;
  unint64_t v67;
  unint64_t v68;
  float32x4_t v69;
  int32x4_t v70;
  int v71;
  float v72;
  float32x4_t v73;
  float32x4_t v74;
  int32x4_t v75;
  int8x16_t v76;
  float32x4_t v77;
  int32x4_t v78;
  int8x16_t v79;
  unint64_t v80;
  unint64_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  int v86;
  float32x4_t v87;
  int v88;
  int v89;
  uint64_t v90;
  __int128 v91;
  float v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  int8x16_t v101;
  int8x16_t v102;

  v4 = *((float *)this + 105);
  v5 = HGTile::Renderer(a2);
  v6 = (*(uint64_t (**)(HGComicStroke *, uint64_t))(*(_QWORD *)this + 312))(this, v5);
  v8 = *(int32x2_t *)a2;
  v86 = *((_DWORD *)a2 + 3) - HIDWORD(*(_QWORD *)a2);
  if (v86 >= 1)
  {
    v90 = (*((_DWORD *)a2 + 2) - v8.i32[0]);
    if ((int)v90 >= 1)
    {
      v9 = v6;
      v10 = 0;
      *(float32x2_t *)v11.f32 = vadd_f32(vcvt_f32_s32(v8), (float32x2_t)0x3F0000003F000000);
      v11.i64[1] = 0x3F80000000000000;
      v12 = *((float *)this + 102);
      v13 = 1.0 / (float)(v12 * (float)(v12 * 3.0));
      v14 = *((_QWORD *)a2 + 2);
      v89 = (int)(float)(v12 + v12);
      v15 = -v89;
      v7.i32[0] = 0;
      v16 = 0uLL;
      __asm
      {
        FMOV            V7.4S, #-1.0
        FMOV            V16.4S, #1.0
      }
      v23 = 1.0 / v4;
      v24 = v11;
      v94 = _Q7;
      v95 = v11;
      v92 = 1.0 / v4;
      v93 = _Q16;
      do
      {
        v88 = v10;
        v25 = 0;
        v87 = v24;
        v26 = v24;
        do
        {
          v27 = *((_QWORD *)a2 + 10);
          v28 = *((int *)a2 + 22);
          v29 = vsubq_f32(vmulq_n_f32(v26, v23), v11);
          if (v9)
          {
            v30 = vaddq_s32(vcvtq_s32_f32(v29), vcltzq_f32(v29));
            v31 = (float32x2_t)vsubq_f32(v29, vcvtq_f32_s32(v30)).u64[0];
            v32 = (float32x4_t *)(v27 + 16 * (v30.i32[0] + v30.i32[1] * (int)v28));
            v33 = vaddq_f32(*v32, vmulq_n_f32(vsubq_f32(v32[1], *v32), v31.f32[0]));
            v34 = (int8x16_t)vaddq_f32(v33, vmulq_lane_f32(vsubq_f32(vaddq_f32(v32[v28], vmulq_n_f32(vsubq_f32(v32[(int)v28 + 1], v32[v28]), v31.f32[0])), v33), v31, 1));
          }
          else
          {
            v35.i64[0] = 0x3F0000003F000000;
            v35.i64[1] = 0x3F0000003F000000;
            v36 = vaddq_f32(v29, v35);
            v37 = vcvtq_s32_f32(v36);
            v36.i64[0] = vaddq_s32(v37, vcgtq_f32(vcvtq_f32_s32(v37), v36)).u64[0];
            v34 = *(int8x16_t *)(v27 + 16 * (v36.i32[0] + v36.i32[1] * (int)v28));
          }
          v38 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.i8, 1);
          v39 = v34;
          v39.i32[1] = 0;
          v40 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32((float32x4_t)v7, v38), (int8x16_t)vcgeq_f32(v38, (float32x4_t)v7))), 0), v39, v34);
          v42 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2);
          v41 = v40;
          v41.i32[2] = 0;
          v7 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32((float32x4_t)v7, v42), (int8x16_t)vcgeq_f32(v42, (float32x4_t)v7))), 0), v41, v40);
          v42.i32[3] = v7.i32[3];
          if (*((float *)this + 104) != 0.0)
          {
            v43 = *((_QWORD *)a2 + 12);
            v44 = *((int *)a2 + 26);
            v45 = vsubq_f32(v26, v11);
            if (!v9)
            {
              v69.i64[0] = 0x3F0000003F000000;
              v69.i64[1] = 0x3F0000003F000000;
              v40 = (int8x16_t)vaddq_f32(v45, v69);
              v70 = vcvtq_s32_f32((float32x4_t)v40);
              v40.i64[0] = vaddq_s32(v70, vcgtq_f32(vcvtq_f32_s32(v70), (float32x4_t)v40)).u64[0];
              v50 = 0.5;
              v91 = *(_OWORD *)(v43 + 16 * (v40.i32[0] + v40.i32[1] * (int)v44));
              if (v89 <= 1)
                goto LABEL_22;
              goto LABEL_14;
            }
            v46 = vaddq_s32(vcvtq_s32_f32(v45), vcltzq_f32(v45));
            v47 = (float32x2_t)vsubq_f32(v45, vcvtq_f32_s32(v46)).u64[0];
            v48 = (float32x4_t *)(v43 + 16 * (v46.i32[0] + v46.i32[1] * (int)v44));
            v49 = vaddq_f32(*v48, vmulq_n_f32(vsubq_f32(v48[1], *v48), v47.f32[0]));
            v40 = (int8x16_t)vmulq_lane_f32(vsubq_f32(vaddq_f32(v48[v44], vmulq_n_f32(vsubq_f32(v48[(int)v44 + 1], v48[v44]), v47.f32[0])), v49), v47, 1);
            v42 = vaddq_f32(v49, (float32x4_t)v40);
          }
          v50 = 0.5;
          HIDWORD(v91) = v42.i32[3];
          if (v89 <= 1)
            goto LABEL_22;
LABEL_14:
          v51.i64[0] = vextq_s8(v7, v16, 4uLL).u64[0];
          v51.i64[1] = v16.i64[1];
          v52 = vmaxnmq_f32(vminnmq_f32(vaddq_f32(vaddq_f32(v51, v51), _Q7), _Q16), _Q7);
          v53 = vnegq_f32(v52);
          v96 = v26;
          if (v9)
          {
            v54 = (int)v28 + 1;
            v55 = -1;
            do
            {
              v97 = v53;
              v99 = v52;
              v101 = v7;
              v56 = expf(v13 * (float)v55);
              v26 = v96;
              v23 = v92;
              _Q16 = v93;
              _Q7 = v94;
              v11 = v95;
              v50 = v50 + v56;
              v57 = vsubq_f32(vmulq_n_f32(vaddq_f32(v96, v99), v92), v95);
              v58 = vaddq_s32(vcvtq_s32_f32(v57), vcltzq_f32(v57));
              v57.i64[0] = vsubq_f32(v57, vcvtq_f32_s32(v58)).u64[0];
              v59 = (float32x4_t *)(v27 + 16 * (v58.i32[0] + v58.i32[1] * (int)v28));
              v60 = vaddq_f32(*v59, vmulq_n_f32(vsubq_f32(v59[1], *v59), v57.f32[0]));
              v61 = (int8x16_t)vaddq_f32(v60, vmulq_lane_f32(vsubq_f32(vaddq_f32(v59[v28], vmulq_n_f32(vsubq_f32(v59[v54], v59[v28]), v57.f32[0])), v60), *(float32x2_t *)v57.f32, 1));
              v62 = vsubq_f32(vmulq_n_f32(vaddq_f32(v96, v97), v92), v95);
              v63 = vaddq_s32(vcvtq_s32_f32(v62), vcltzq_f32(v62));
              v62.i64[0] = vsubq_f32(v62, vcvtq_f32_s32(v63)).u64[0];
              v64 = (float32x4_t *)(v27 + 16 * (v63.i32[0] + v63.i32[1] * (int)v28));
              v65 = vaddq_f32(*v64, vmulq_n_f32(vsubq_f32(v64[1], *v64), v62.f32[0]));
              v16 = 0uLL;
              v7 = v101;
              v66 = (int8x16_t)vaddq_f32(v65, vmulq_lane_f32(vsubq_f32(vaddq_f32(v64[v28], vmulq_n_f32(vsubq_f32(v64[v54], v64[v28]), v62.f32[0])), v65), *(float32x2_t *)v62.f32, 1));
              *(float *)v7.i32 = *(float *)v101.i32
                               + (float)(v56 * vaddq_f32((float32x4_t)v61, (float32x4_t)v66).f32[0]);
              v67 = vextq_s8(v61, (int8x16_t)0, 4uLL).u64[0];
              v52 = vaddq_f32(v99, vmaxnmq_f32(vminnmq_f32(vaddq_f32(vaddq_f32((float32x4_t)v67, (float32x4_t)v67), v94), v93), v94));
              v68 = vextq_s8(v66, (int8x16_t)0, 4uLL).u64[0];
              v40 = (int8x16_t)vmaxnmq_f32(vminnmq_f32(vaddq_f32(vaddq_f32((float32x4_t)v68, (float32x4_t)v68), v94), v93), v94);
              v53 = vaddq_f32(v97, (float32x4_t)v40);
              --v55;
            }
            while (v15 != v55);
          }
          else
          {
            v71 = -1;
            do
            {
              v98 = v53;
              v100 = v52;
              v102 = v7;
              v72 = expf(v13 * (float)v71);
              v26 = v96;
              v23 = v92;
              _Q16 = v93;
              _Q7 = v94;
              v11 = v95;
              v16 = 0uLL;
              v73.i64[0] = 0x3F0000003F000000;
              v73.i64[1] = 0x3F0000003F000000;
              v74 = vaddq_f32(vsubq_f32(vmulq_n_f32(vaddq_f32(v96, v100), v92), v95), v73);
              v75 = vcvtq_s32_f32(v74);
              v74.i64[0] = vaddq_s32(v75, vcgtq_f32(vcvtq_f32_s32(v75), v74)).u64[0];
              v76 = *(int8x16_t *)(v27 + 16 * (v74.i32[0] + v74.i32[1] * (int)v28));
              v50 = v50 + v72;
              v77 = vaddq_f32(vsubq_f32(vmulq_n_f32(vaddq_f32(v96, v98), v92), v95), v73);
              v78 = vcvtq_s32_f32(v77);
              v7 = v102;
              v77.i64[0] = vaddq_s32(v78, vcgtq_f32(vcvtq_f32_s32(v78), v77)).u64[0];
              v79 = *(int8x16_t *)(v27 + 16 * (v77.i32[0] + v77.i32[1] * (int)v28));
              *(float *)v7.i32 = *(float *)v102.i32
                               + (float)(v72 * vaddq_f32((float32x4_t)v76, (float32x4_t)v79).f32[0]);
              v80 = vextq_s8(v76, (int8x16_t)0, 4uLL).u64[0];
              v52 = vaddq_f32(v100, vmaxnmq_f32(vminnmq_f32(vaddq_f32(vaddq_f32((float32x4_t)v80, (float32x4_t)v80), v94), v93), v94));
              v81 = vextq_s8(v79, (int8x16_t)0, 4uLL).u64[0];
              v40 = (int8x16_t)vmaxnmq_f32(vminnmq_f32(vaddq_f32(vaddq_f32((float32x4_t)v81, (float32x4_t)v81), v94), v93), v94);
              v53 = vaddq_f32(v98, (float32x4_t)v40);
              --v71;
            }
            while (v15 != v71);
          }
LABEL_22:
          *(float *)v40.i32 = (float)((float)(*(float *)v7.i32 * 0.5) / v50) / 0.8;
          v7.i32[0] = 0;
          *(float *)v40.i32 = fminf(fmaxf(*(float *)v40.i32, 0.0), 1.0);
          *(float *)v40.i32 = (float)(*(float *)v40.i32 * *(float *)v40.i32)
                            * (float)(3.0 - (float)(*(float *)v40.i32 + *(float *)v40.i32));
          v82 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.i8, 0);
          v82.i32[3] = HIDWORD(v91);
          v83 = vmaxnmq_f32(vminnmq_f32(v82, _Q16), (float32x4_t)v16);
          if (*((float *)this + 103) == 1.0)
          {
            v84 = vmulq_laneq_f32(v83, v83, 3);
            v84.i32[3] = v83.i32[3];
            v83 = v84;
          }
          *(float32x4_t *)(v14 + 16 * v25) = v83;
          v26 = vaddq_f32(v26, (float32x4_t)xmmword_1B304F230);
          ++v25;
        }
        while (v25 != v90);
        v24 = vaddq_f32(v87, (float32x4_t)xmmword_1B304F240);
        v14 += 16 * *((int *)a2 + 6);
        v10 = v88 + 1;
      }
      while (v88 + 1 != v86);
    }
  }
  return 0;
}

HGComicStroke *HGComicStroke::GetOutput(HGComicStroke *this, HGRenderer *a2, char *a3)
{
  char *v4;
  float v5;
  char *v6;
  float v7;
  uint64_t v9;

  HGNode::SetParameter((HGNode *)this, 0, *((float *)this + 102), 0.0, 0.0, 0.0, a3);
  if (*((float *)this + 103) == 1.0)
    v5 = 1.0;
  else
    v5 = 0.0;
  HGNode::SetParameter((HGNode *)this, 1, v5, 0.0, 0.0, 0.0, v4);
  if (*((float *)this + 104) == 1.0)
    v7 = 1.0;
  else
    v7 = 0.0;
  HGNode::SetParameter((HGNode *)this, 2, v7, 0.0, 0.0, 0.0, v6);
  if (*((float *)this + 104) == 0.0)
  {
    v9 = (*(uint64_t (**)(HGComicStroke *, _QWORD))(*(_QWORD *)this + 128))(this, 0);
    (*(void (**)(HGComicStroke *, uint64_t, uint64_t))(*(_QWORD *)this + 120))(this, 1, v9);
  }
  return this;
}

const char *HGComicStroke::GetProgram(HGComicStroke *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) > 0x60B0F)
    return "//Metal1.0     \n"
           "//LEN=0000000a29\n"
           "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< half >      hg_Texture0 [[ texture(0) ]],   // color\n"
           "                                  texture2d< half >      hg_Texture1 [[ texture(1) ]],   // alpha replace\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]],\n"
           "                                  sampler                hg_Sampler1 [[ sampler(1) ]])\n"
           "{\n"
           "    const half sigma {static_cast<half>(hg_Params[0].x)};\n"
           "    const BOOL AlphaPremultiplyOutput {static_cast<BOOL>(hg_Params[1].x)};\n"
           "    const BOOL alphaReplaceEnabled {static_cast<BOOL>(hg_Params[2].x)};\n"
           "    \n"
           "    const half4 texel = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
           "    const float alpha = alphaReplaceEnabled ? hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).a\n"
           "                                            : texel.a;\n"
           "    \n"
           "    // Get the 0'th normal (e0, for an exponent value of 0, so the coeff is 1.0)\n"
           "    float2 pointer = float2(texel.yz) * 2.0f - 1.0f;\n"
           "    float2 pointerRBack = -pointer;\n"
           "    \n"
           "    half acc = texel.x;\n"
           "    half norma = {0.5h};\n"
           "\n"
           "    half sigma3 = 1.0h / (3.0h * sigma * sigma);\n"
           "    half limit = 2.0h * sigma;\n"
           "    for (half i = 1.0h; i < limit; i++)\n"
           "    {\n"
           "        half coeff = exp(-i * sigma3);\n"
           "        norma += coeff;\n"
           "        \n"
           "        const float2 uPos = frag._texCoord0.xy + pointer;\n"
           "        const float2 uNeg = frag._texCoord0.xy + pointerRBack;\n"
           "        \n"
           "        const float2 acc_ptrTexCoord = uPos;\n"
           "        const float2 acc_ptrBackTexCoord = uNeg;\n"
           "        \n"
           "        const float2 grad_ptrTexCoord = uPos;\n"
           "        const float2 grad_ptrBackTexCoord = uNeg;\n"
           "\n"
           "    \n"
           "        acc += coeff * (hg_Texture0.sample(hg_Sampler0, acc_ptrTexCoord).x +\n"
           "                        hg_Texture0.sample(hg_Sampler0, acc_ptrBackTexCoord).x);\n"
           "\n"
           "        pointer += float2(hg_Texture0.sample(hg_Sampler0, grad_ptrTexCoord).yz * 2.0f) - 1.0f;\n"
           "        pointerRBack -= float2(hg_Texture0.sample(hg_Sampler0, grad_ptrBackTexCoord).yz * 2.0f) - 1.0f;\n"
           "    }\n"
           "\n"
           "    half result {smoothstep(0.0h, 0.8h, acc * 0.5h / norma)};\n"
           " \n"
           "    if (AlphaPremultiplyOutput)\n"
           "        result *= alpha;\n"
           " \n"
           "    FragmentOut out {float4(result, result, result, alpha)};\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    out.color0 = clamp(out.color0, 0.0f, 1.0f);\n"
           "\n"
           "    return out;\n"
           "}\n"
           "//MD5=cf23531d:c7d2f03d:785bd60d:1958694a\n"
           "//SIG=00000000:00000000:00000000:00000003:0010:0003:0000:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
    return "//GLfs1.0      \n"
           "//LEN=0000000944\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#define precision\n"
           "#define defaultp mediump\n"
           "#endif\n"
           " \n"
           "precision highp float;\n"
           "precision highp int;\n"
           "\n"
           "uniform defaultp sampler2DRect hg_Texture0;
           "uniform defaultp sampler2DRect hg_Texture1;
           "\n"
           "uniform highp vec4 hg_ProgramLocal0;    // {.x == sigma}\n"
           "uniform highp vec4 hg_ProgramLocal1;    // {.x == alpha premultiply output toggle}\n"
           "uniform highp vec4 hg_ProgramLocal2;    // {.x == alpha replace toggle}\n"
           "\n"
           "void main() \n"
           "{\n"
           "    float sigma = hg_ProgramLocal0.x;\n"
           "    float alphaPremultiplyOutput = hg_ProgramLocal1.x;\n"
           "    float alphaReplaceEnabled = hg_ProgramLocal2.x;\n"
           " \n"
           "    vec4 texel = texture2DRect(hg_Texture0, gl_TexCoord[0].xy);\n"
           "    float alpha = (alphaReplaceEnabled != 0.0)  ? texture2DRect(hg_Texture1, gl_TexCoord[1].xy).a\n"
           "                                                : texel.a;\n"
           "    \n"
           "\n"
           "    float acc = texel.x;\n"
           "    float norma = 0.5;\n"
           "    \n"
           "    vec2 gradient = texel.yz;\n"
           "    vec2 vdire = vec2(gradient.x * 2.0 - 1.0, gradient.y * 2.0 - 1.0);\n"
           "    vec2 pointer = vec2(vdire.x, vdire.y);\n"
           "\n"
           "    vdire = vec2(-(gradient.x * 2.0 - 1.0), -(gradient.y * 2.0 - 1.0));\n"
           "    vec2 pointerRBack = vec2(vdire.x, vdire.y);\n"
           "\n"
           "    float sigma3 = 1.0 / (3.0 * sigma * sigma);\n"
           "    float limit = 2.0 * sigma;\n"
           "    for (float i = 1.0; i < limit; i++)\n"
           "    {\n"
           "        float coeff = exp(-i * sigma3);\n"
           "        \n"
           "        vec2 uPos = gl_TexCoord[0].xy + pointer;\n"
           "        vec2 uNeg = gl_TexCoord[0].xy + pointerRBack;\n"
           "\n"
           "        acc +=coeff * (texture2DRect(hg_Texture0, uPos).x +\n"
           "                       texture2DRect(hg_Texture0, uNeg).x);\n"
           "\n"
           "        norma += coeff;\n"
           "\n"
           "        gradient = texture2DRect(hg_Texture0, uPos).yz;\n"
           "        vdire = vec2(gradient.x * 2.0 - 1.0, gradient.y * 2.0 - 1.0);\n"
           "        pointer += vdire;\n"
           "\n"
           "        gradient = texture2DRect(hg_Texture0, uNeg).yz;\n"
           "        vdire = vec2(-(gradient.x * 2.0 - 1.0),-(gradient.y * 2.0 - 1.0));\n"
           "        pointerRBack += vdire;\n"
           "    }\n"
           "\n"
           "    float result = smoothstep(0.0, 0.8, acc * 0.5 / norma);\n"
           " \n"
           "    if (alphaPremultiplyOutput == 1.0)\n"
           "        result *= alpha;\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    gl_FragColor = clamp(vec4(result, result, result, alpha), 0.0, 1.0);\n"
           "}\n"
           "//MD5=3f28c492:3ede71fa:6537a9ca:f282928b\n"
           "//SIG=00000000:00000000:00000000:00000000:0038:0003:0000:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  return 0;
}

uint64_t HGComicStroke::BindTexture(HGComicStroke *this, HGHandler *a2, uint64_t a3)
{
  float v5;

  if ((_DWORD)a3)
  {
    HGHandler::TexCoord(a2, a3, 0, 0, 0);
  }
  else
  {
    v5 = 1.0 / *((float *)this + 105);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, v5, v5, 1.0);
  }
  (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, a3, 0);
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  (*(void (**)(HGHandler *, uint64_t, uint64_t))(*(_QWORD *)a2 + 48))(a2, 1, 1);
  return 0;
}

uint64_t HGCSolidColor::GetDOD(HGCSolidColor *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = (__int128 *)((char *)this + 416);
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

void HGSolidColor::HGSolidColor(HGSolidColor *this)
{
  _QWORD *v2;
  HgcSolidColor *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6530CD0;
  v3 = (HgcSolidColor *)HGObject::operator new(0x1B0uLL);
  HgcSolidColor::HgcSolidColor(v3);
  *(_QWORD *)v3 = off_1E6530F20;
  *((_QWORD *)v3 + 52) = 0x8000000080000000;
  *((_QWORD *)v3 + 53) = 0x7FFFFFFF7FFFFFFFLL;
  *((_QWORD *)this + 51) = v3;
}

void sub_1B2AFADF8(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2AFAE14(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGSolidColor::HGSolidColor(HGSolidColor *this, HGRect a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  HgcSolidColor *v6;

  v2 = *(_QWORD *)&a2.var2;
  v3 = *(_QWORD *)&a2.var0;
  HGNode::HGNode((HGNode *)this);
  *v5 = off_1E6530CD0;
  v6 = (HgcSolidColor *)HGObject::operator new(0x1B0uLL);
  HgcSolidColor::HgcSolidColor(v6);
  *(_QWORD *)v6 = off_1E6530F20;
  *((_QWORD *)v6 + 52) = v3;
  *((_QWORD *)v6 + 53) = v2;
  *((_QWORD *)this + 51) = v6;
}

void sub_1B2AFAE8C(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2AFAEA8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGSolidColor::~HGSolidColor(HGSolidColor *this)
{
  *(_QWORD *)this = off_1E6530CD0;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 51) + 24))(*((_QWORD *)this + 51));
  HGNode::~HGNode((HGNode *)this);
}

{
  void *v2;

  *(_QWORD *)this = off_1E6530CD0;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 51) + 24))(*((_QWORD *)this + 51));
  HGNode::~HGNode((HGNode *)this);
  HGObject::operator delete(v2);
}

uint64_t HGSolidColor::SetParameter(HGSolidColor *this, float a2, float a3, float a4, float a5)
{
  return (*(uint64_t (**)(_QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), a2, a3, a4, a5);
}

uint64_t HGSolidColor::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  return *((_QWORD *)this + 51);
}

void HGCSolidColor::~HGCSolidColor(HGNode *this)
{
  void *v1;

  HgcSolidColor::~HgcSolidColor(this);
  HGObject::operator delete(v1);
}

void HGCVBufferPairStorage::HGCVBufferPairStorage(HGCVBufferPairStorage *this, HGCVBitmap *a2, __CVBuffer *a3)
{
  _QWORD *v6;

  HGObject::HGObject(this);
  *v6 = off_1E65311A0;
  v6[2] = a2;
  v6[3] = a3;
  (*(void (**)(HGCVBitmap *))(*(_QWORD *)a2 + 16))(a2);
  CFRetain(*((CFTypeRef *)this + 3));
}

void sub_1B2AFB010(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGCVBufferPairStorage::~HGCVBufferPairStorage(CFTypeRef *this)
{
  *this = off_1E65311A0;
  CFRelease(this[3]);
  (*(void (**)(CFTypeRef))(*(_QWORD *)this[2] + 24))(this[2]);
  HGObject::~HGObject((HGObject *)this);
}

{
  void *v2;

  *this = off_1E65311A0;
  CFRelease(this[3]);
  (*(void (**)(CFTypeRef))(*(_QWORD *)this[2] + 24))(this[2]);
  HGObject::~HGObject((HGObject *)this);
  HGObject::operator delete(v2);
}

uint64_t HGApplyNDLUTInfo::HGApplyNDLUTInfo(uint64_t result, uint64_t a2, unint64_t a3, int a4, float a5, float a6)
{
  uint64_t v6;

  *(_QWORD *)result = off_1E65311F0;
  *(_QWORD *)(result + 8) = a2;
  *(_QWORD *)(result + 16) = a3;
  *(float *)(result + 24) = a5;
  *(float *)(result + 28) = a6;
  *(_DWORD *)(result + 32) = a4;
  if (a3 <= 3)
  {
    if (a3 == 3)
      return result;
    v6 = 1;
  }
  else
  {
    v6 = 3;
  }
  *(_QWORD *)(result + 16) = v6;
  return result;
}

float HGApplyNDLUTInfo::getRangeOffset(HGApplyNDLUTInfo *this)
{
  return *((float *)this + 7);
}

uint64_t HGApplyNDLUTInfo::getLUTStorageFormat(HGApplyNDLUTInfo *this)
{
  return *((unsigned int *)this + 8);
}

void *HGApplyNDLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *result;

  if (!lpsrc)
    return 0;
  if (result)
  {
    if (*(_QWORD *)(a1 + 8) == *((_QWORD *)result + 1)
      && *(_QWORD *)(a1 + 16) == *((_QWORD *)result + 2)
      && vabds_f32(*(float *)(a1 + 24), *((float *)result + 6)) < 0.0001
      && vabds_f32(*(float *)(a1 + 28), *((float *)result + 7)) < 0.0001)
    {
      return (void *)(*(_DWORD *)(a1 + 32) == *((_DWORD *)result + 8));
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HGApplyNDLUTInfo::colorAtIndex(HGApplyNDLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  *a5 = 0.0;
  *a6 = 0.0;
  *a7 = 0.0;
  *a8 = 0.0;
}

_QWORD *HGApplyNDLUTEntry::HGApplyNDLUTEntry(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  void *v3;
  _QWORD *v5;
  HGBitmap **v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  HGMemory::StorageObject *v17;
  uint64_t v18;
  HGBitmap *v19;
  HGBitmap *v20;

  v3 = (void *)a2;
  v5 = HGLUTCache::LUTEntry::LUTEntry(a1, a2, a3);
  *v5 = &off_1E6531240;
  v5[3] = 0;
  v6 = (HGBitmap **)(v5 + 3);
  v5[4] = 0;
  if (v3)
  v7 = *((_DWORD *)v3 + 2);
  if (*((_QWORD *)v3 + 2) == 1)
  {
    v9 = HGRectMake4i(0, 0, v7 + 1, 1u);
    v10 = v8;
    if ((v8 - v9) < 0x801uLL)
      goto LABEL_8;
    v11 = HGRectMake4i(0, 0, 0x800u, ((v8 - v9) >> 11) + 1);
  }
  else
  {
    v11 = HGRectMake4i(0, 0, v7 * v7 + 1, v7 + 1);
  }
  v9 = v11;
  v10 = v12;
LABEL_8:
  v13 = *((_DWORD *)v3 + 8);
  if (v13 == 1)
    v14 = 27;
  else
    v14 = 28;
  if (v13)
    v15 = v14;
  else
    v15 = 25;
  v16 = HGFormatUtils::bytesPerPixel(v15);
  v17 = (HGMemory::StorageObject *)HGObject::operator new(0x20uLL);
  HGMemory::StorageObject::StorageObject(v17, ((HIDWORD(v10) - HIDWORD(v9)) * (v10 - v9) * v16));
  v18 = *((_QWORD *)v17 + 2);
  v19 = (HGBitmap *)HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap((uint64_t)v19, v9, v10, v15, v18);
  v20 = *v6;
  if (*v6 == v19)
  {
    if (v19)
    {
      (*(void (**)(HGBitmap *))(*(_QWORD *)v19 + 24))(v19);
      v19 = *v6;
    }
  }
  else
  {
    if (v20)
      (*(void (**)(HGBitmap *))(*(_QWORD *)v20 + 24))(v20);
    *v6 = v19;
  }
  HGBitmap::SetStorage(v19, v17);
  HGApplyNDLUTEntry::CopyData((uint64_t)a1, (const HGApplyNDLUTInfo *)v3);
  (*(void (**)(HGMemory::StorageObject *))(*(_QWORD *)v17 + 24))(v17);
  return a1;
}

void sub_1B2AFB3B0(_Unwind_Exception *a1)
{
  HGLUTCache::LUTEntry *v1;
  _QWORD *v2;
  uint64_t v4;

  v4 = *((_QWORD *)v1 + 4);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  if (*v2)
    (*(void (**)(_QWORD))(*(_QWORD *)*v2 + 24))(*v2);
  HGLUTCache::LUTEntry::~LUTEntry(v1);
  _Unwind_Resume(a1);
}

uint64_t HGApplyNDLUTEntry::CopyData(uint64_t this, const HGApplyNDLUTInfo *a2)
{
  uint64_t v3;
  uint64_t v4;
  float v5;
  float v6;
  uint64_t v7;
  int v8;
  int16x4_t *v9;
  float v10;
  float32x4_t v11;
  float32x4_t v12;
  uint32x4_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t k;
  float32x4_t v20;
  float32x4_t v21;
  uint32x4_t v22;
  float v23;
  int16x4_t *v24;
  __int32 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _WORD *v29;
  uint64_t i;
  float v31;
  float v32;
  float v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  float *v37;
  uint64_t j;
  float32x4_t v39;
  float32x4_t v40;
  uint32x4_t v41;
  float v42;
  uint64_t v43;
  uint64_t v44;
  int8x16_t v45;
  int8x16_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float v53;
  float v54;
  unsigned int v55[4];

  v4 = *((_QWORD *)a2 + 1);
  v3 = *((_QWORD *)a2 + 2);
  v5 = *((float *)a2 + 7);
  v6 = *((float *)a2 + 6) / (float)(unint64_t)(v4 - 1);
  *(_QWORD *)v55 = 0;
  v54 = 0.0;
  v53 = 0.0;
  v7 = *(_QWORD *)(this + 24);
  v8 = *(_DWORD *)(v7 + 16);
  if (v3 == 1)
  {
    v9 = *(int16x4_t **)(v7 + 80);
    if (v8 == 27)
    {
      if (v4)
      {
        v10 = 0.0;
        v49 = (float32x4_t)vdupq_n_s32(0x47800000u);
        v51 = (float32x4_t)vdupq_n_s32(0xC7800000);
        v45 = (int8x16_t)vdupq_n_s32(0xF800000u);
        v47 = (float32x4_t)vdupq_n_s32(0x7800000u);
        do
        {
          this = (*(uint64_t (**)(const HGApplyNDLUTInfo *, unsigned int *, unsigned int *, float *, float *, float, float, float))(*(_QWORD *)a2 + 32))(a2, &v55[1], v55, &v54, &v53, v5 + (float)(v6 * v10), 0.0, 0.0);
          v11.i64[0] = __PAIR64__(v55[0], v55[1]);
          v11.i64[1] = __PAIR64__(LODWORD(v53), LODWORD(v54));
          v12 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v51, v11), (int8x16_t)v51, (int8x16_t)v11);
          v13 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v12, v49), v45, (int8x16_t)vmulq_f32(v12, v47));
          *v9++ = vmovn_s32((int32x4_t)vorrq_s8(vandq_s8((int8x16_t)vshlq_u32(v13, (uint32x4_t)xmmword_1B3523D30), (int8x16_t)xmmword_1B3523D40), vandq_s8((int8x16_t)vshlq_u32(v13, (uint32x4_t)xmmword_1B3523D50), (int8x16_t)xmmword_1B3523D60)));
          v10 = v10 + 1.0;
          --v4;
        }
        while (v4);
      }
      else
      {
        v11 = 0uLL;
      }
      v39 = (float32x4_t)vdupq_n_s32(0xC7800000);
      v40 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v39, v11), (int8x16_t)v39, (int8x16_t)v11);
      v41 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v40, (float32x4_t)vdupq_n_s32(0x47800000u)), (int8x16_t)vdupq_n_s32(0xF800000u), (int8x16_t)vmulq_f32(v40, (float32x4_t)vdupq_n_s32(0x7800000u)));
      *v9 = vmovn_s32((int32x4_t)vorrq_s8(vandq_s8((int8x16_t)vshlq_u32(v41, (uint32x4_t)xmmword_1B3523D30), (int8x16_t)xmmword_1B3523D40), vandq_s8((int8x16_t)vshlq_u32(v41, (uint32x4_t)xmmword_1B3523D50), (int8x16_t)xmmword_1B3523D60)));
    }
    else
    {
      if (v4)
      {
        v23 = 0.0;
        do
        {
          this = (*(uint64_t (**)(const HGApplyNDLUTInfo *, unsigned int *, unsigned int *, float *, float *, float, float, float))(*(_QWORD *)a2 + 32))(a2, &v55[1], v55, &v54, &v53, v5 + (float)(v6 * v23), 0.0, 0.0);
          v9->i32[0] = v55[1];
          v9->i32[1] = v55[0];
          *(float *)v9[1].i32 = v54;
          v24 = v9 + 2;
          *(float *)&v9[1].i32[1] = v53;
          v23 = v23 + 1.0;
          v9 += 2;
          --v4;
        }
        while (v4);
        v25 = v55[1];
        v9 = v24;
      }
      else
      {
        v25 = 0;
      }
      v9->i32[0] = v25;
      v42 = v54;
      v9->i32[1] = v55[0];
      *(float *)v9[1].i32 = v42;
      *(float *)&v9[1].i32[1] = v53;
    }
  }
  else
  {
    v14 = this;
    if (v8 == 25)
    {
      if (v4)
      {
        v26 = 0;
        v27 = *(_QWORD *)(v7 + 80);
        do
        {
          v28 = 0;
          v29 = (_WORD *)(v27 + *(_QWORD *)(*(_QWORD *)(v14 + 24) + 64) * v26);
          do
          {
            for (i = 0; i != v4; ++i)
            {
              this = (*(uint64_t (**)(const HGApplyNDLUTInfo *, unsigned int *, unsigned int *, float *, float *, float, float, float))(*(_QWORD *)a2 + 32))(a2, &v55[1], v55, &v54, &v53, v5 + (float)(v6 * (float)(int)i), v5 + (float)(v6 * (float)(int)v28), v5 + (float)(v6 * (float)(int)v26));
              v31 = fmaxf(fminf(*(float *)v55, 1.0), 0.0) * 65535.0;
              *(float *)v55 = v31;
              *(float *)&v55[1] = fmaxf(fminf(*(float *)&v55[1], 1.0), 0.0) * 65535.0;
              v32 = fmaxf(fminf(v54, 1.0), 0.0) * 65535.0;
              v54 = v32;
              v33 = fmaxf(fminf(v53, 1.0), 0.0);
              v53 = v33 * 65535.0;
              *v29 = (int)*(float *)&v55[1];
              v29[1] = (int)v31;
              v29[2] = (int)v32;
              v29[3] = (int)(float)(v33 * 65535.0);
              v29 += 4;
            }
            ++v28;
          }
          while (v28 != v4);
          ++v26;
        }
        while (v26 != v4);
      }
    }
    else if (v8 == 28)
    {
      if (v4)
      {
        v34 = 0;
        v35 = *(_QWORD *)(v7 + 80);
        do
        {
          v36 = 0;
          v37 = (float *)(v35 + *(_QWORD *)(*(_QWORD *)(v14 + 24) + 64) * v34);
          do
          {
            for (j = 0; j != v4; ++j)
            {
              this = (*(uint64_t (**)(const HGApplyNDLUTInfo *, unsigned int *, unsigned int *, float *, float *, float, float, float))(*(_QWORD *)a2 + 32))(a2, &v55[1], v55, &v54, &v53, v5 + (float)(v6 * (float)(int)j), v5 + (float)(v6 * (float)(int)v36), v5 + (float)(v6 * (float)(int)v34));
              *v37 = (float)(*(float *)&v55[1] - v5) / v6;
              v37[1] = (float)(*(float *)v55 - v5) / v6;
              v37[2] = (float)(v54 - v5) / v6;
              v37[3] = (float)(v53 - v5) / v6;
              v37 += 4;
            }
            ++v36;
          }
          while (v36 != v4);
          ++v34;
        }
        while (v34 != v4);
      }
    }
    else if (v8 == 27 && v4)
    {
      v15 = 0;
      v43 = *(_QWORD *)(v7 + 80);
      v44 = this;
      v50 = (float32x4_t)vdupq_n_s32(0x47800000u);
      v52 = (float32x4_t)vdupq_n_s32(0xC7800000);
      v46 = (int8x16_t)vdupq_n_s32(0xF800000u);
      v48 = (float32x4_t)vdupq_n_s32(0x7800000u);
      do
      {
        v16 = 0;
        v17 = v43 + *(_QWORD *)(*(_QWORD *)(v14 + 24) + 64) * v15;
        do
        {
          v18 = 0;
          for (k = 0; k != v4; ++k)
          {
            this = (*(uint64_t (**)(const HGApplyNDLUTInfo *, unsigned int *, unsigned int *, float *, float *, float, float, float))(*(_QWORD *)a2 + 32))(a2, &v55[1], v55, &v54, &v53, v5 + (float)(v6 * (float)(int)k), v5 + (float)(v6 * (float)(int)v16), v5 + (float)(v6 * (float)(int)v15));
            v20.i64[0] = __PAIR64__(v55[0], v55[1]);
            v20.i64[1] = __PAIR64__(LODWORD(v53), LODWORD(v54));
            v21 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v52, v20), (int8x16_t)v52, (int8x16_t)v20);
            v22 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v21, v50), v46, (int8x16_t)vmulq_f32(v21, v48));
            *(int16x4_t *)(v17 + 8 * k) = vmovn_s32((int32x4_t)vorrq_s8(vandq_s8((int8x16_t)vshlq_u32(v22, (uint32x4_t)xmmword_1B3523D30), (int8x16_t)xmmword_1B3523D40), vandq_s8((int8x16_t)vshlq_u32(v22, (uint32x4_t)xmmword_1B3523D50), (int8x16_t)xmmword_1B3523D60)));
            v18 -= 8;
          }
          ++v16;
          v17 -= v18;
        }
        while (v16 != v4);
        ++v15;
        v14 = v44;
      }
      while (v15 != v4);
    }
  }
  return this;
}

void HGApplyNDLUTEntry::~HGApplyNDLUTEntry(HGApplyNDLUTEntry *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E6531240;
  v2 = *((_QWORD *)this + 4);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 3);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGLUTCache::LUTEntry::~LUTEntry(this);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E6531240;
  v2 = *((_QWORD *)this + 4);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 3);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGLUTCache::LUTEntry::~LUTEntry(this);
  JUMPOUT(0x1B5E29170);
}

uint64_t HGApplyNDLUTEntry::GetBitmap(HGApplyNDLUTEntry *this)
{
  uint64_t v2;
  uint64_t v3;
  HGGPURenderer *v4;
  HGMetalTexture *v5;
  char *v6;
  uint64_t MetalContext;
  HGMetalTexture *v8;
  HGMetalTexture *v10;

  v2 = *((_QWORD *)this + 2);
  if (!v2
    || ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 304))(v2) & 1) != 0
    || ((v3 = *((_QWORD *)this + 2)) == 0
      ? (v4 = 0)
  {
    v5 = (HGMetalTexture *)*((_QWORD *)this + 3);
    v6 = (char *)this + 24;
    if (!v5)
      return *(_QWORD *)v6;
    goto LABEL_14;
  }
  v6 = (char *)this + 32;
  v5 = (HGMetalTexture *)*((_QWORD *)this + 4);
  if (v5)
    goto LABEL_14;
  MetalContext = HGGPURenderer::GetMetalContext(v4);
  HGMetalTexture::createWithCopy(*(void **)(*(_QWORD *)(MetalContext + 16) + 16), 0, *((_QWORD *)this + 3), *(_QWORD *)(*((_QWORD *)this + 3) + 20), *(_QWORD *)(*((_QWORD *)this + 3) + 28), 0, 0, &v10);
  v8 = (HGMetalTexture *)*((_QWORD *)this + 4);
  v5 = v10;
  if (v8 == v10)
  {
    if (!v8)
      return *(_QWORD *)v6;
    (*(void (**)(_QWORD))(*(_QWORD *)v8 + 24))(*((_QWORD *)this + 4));
    v5 = *(HGMetalTexture **)v6;
    if (!*(_QWORD *)v6)
      return *(_QWORD *)v6;
LABEL_14:
    (*(void (**)(HGMetalTexture *))(*(_QWORD *)v5 + 16))(v5);
    return *(_QWORD *)v6;
  }
  if (v8)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)v8 + 24))(*((_QWORD *)this + 4));
    v5 = v10;
  }
  *(_QWORD *)v6 = v5;
  if (v5)
    goto LABEL_14;
  return *(_QWORD *)v6;
}

void sub_1B2AFBC84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(exception_object);
}

void HGInvertAlpha::HGInvertAlpha(HGInvertAlpha *this)
{
  _QWORD *v2;
  HgcInvertAlpha *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6531280;
  v3 = (HgcInvertAlpha *)HGObject::operator new(0x1A0uLL);
  HgcInvertAlpha::HgcInvertAlpha(v3);
  *((_QWORD *)this + 51) = v3;
}

void sub_1B2AFBCF4(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2AFBD10(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGInvertAlpha::~HGInvertAlpha(HGInvertAlpha *this)
{
  *(_QWORD *)this = off_1E6531280;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 51) + 24))(*((_QWORD *)this + 51));
  HGNode::~HGNode((HGNode *)this);
}

{
  void *v2;

  *(_QWORD *)this = off_1E6531280;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 51) + 24))(*((_QWORD *)this + 51));
  HGNode::~HGNode((HGNode *)this);
  HGObject::operator delete(v2);
}

uint64_t HGInvertAlpha::GetOutput(HGInvertAlpha *this, HGRenderer *a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *((_QWORD *)this + 51);
  v4 = (*(uint64_t (**)(HGInvertAlpha *, _QWORD))(*(_QWORD *)this + 128))(this, 0);
  (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v3 + 120))(v3, 0, v4);
  return *((_QWORD *)this + 51);
}

const char *HGFractured::GetProgram(HGNode *this, HGRenderer *a2)
{
  int v4;
  HGNode *Input;
  uint64_t v6;
  int v8;
  int v9;
  const char *v10;
  BOOL v11;
  const char *v12;
  const char *v13;
  int v14;

  v4 = *((unsigned __int8 *)this + 432);
  Input = HGRenderer::GetInput(a2, this, 1u);
  v6 = *((_QWORD *)this + 53);
  if (v4)
  {
    if (Input)
    {
      if (*(_DWORD *)(v6 + 140))
      {
        if (*(_BYTE *)(v6 + 144) || *(float *)(v6 + 136) != 0.0)
        {
          if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
            return "//GLfs1.0      \n"
                   "//LEN=000000054d\n"
                   "#extension GL_ARB_texture_rectangle : enable\n"
                   "uniform sampler2DRect hg_Texture0;\n"
                   "uniform sampler2DRect hg_Texture1;\n"
                   "uniform vec4 hg_ProgramLocal0;\n"
                   "uniform vec4 hg_ProgramLocal1;\n"
                   "uniform vec4 hg_ProgramLocal2;\n"
                   "uniform vec4 hg_ProgramLocal3;\n"
                   "uniform vec4 hg_ProgramLocal4;\n"
                   "uniform vec4 hg_ProgramLocal5;\n"
                   "uniform vec4 hg_ProgramLocal6;\n"
                   "void main()\n"
                   "{\n"
                   "    vec3 N = gl_TexCoord[2].xyz*sign(gl_TexCoord[2].z);\n"
                   "    vec4 color;\n"
                   "    if (gl_TexCoord[2].w >= 0.) { color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy); color.xyz = m"
                   "ix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w); color.w *= hg_ProgramLocal0.y; } else { color "
                   "= texture2DRect(hg_Texture1, gl_TexCoord[1].xy); color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, -1."
                   " - gl_TexCoord[2].w); color.w *= hg_ProgramLocal0.w; }\n"
                   "    if (color.w == 0.) discard;\n"
                   "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
                   "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
                   "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLoc"
                   "al5.w);\n"
                   "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), "
                   "0., 1.));\n"
                   "    gl_FragColor = color;\n"
                   "}\n"
                   "//MD5=048203a4:140c5dea:13afe2b7:7d78bf90\n"
                   "//SIG=01000000:00000000:00000000:00000000:0008:0007:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
          else
            return "//GLfs2.0      \n"
                   "//LEN=0000000621\n"
                   "#ifndef GL_ES\n"
                   "#define lowp\n"
                   "#define mediump\n"
                   "#define highp\n"
                   "#endif\n"
                   "#define defaultp mediump\n"
                   "uniform defaultp sampler2D hg_Texture0;\n"
                   "uniform defaultp sampler2D hg_Texture1;\n"
                   "varying highp vec4 hg_TexCoord0;\n"
                   "varying highp vec4 hg_TexCoord1;\n"
                   "varying highp vec4 hg_TexCoord2;\n"
                   "uniform defaultp vec4 hg_ProgramLocal0;\n"
                   "uniform defaultp vec4 hg_ProgramLocal1;\n"
                   "uniform defaultp vec4 hg_ProgramLocal2;\n"
                   "uniform defaultp vec4 hg_ProgramLocal3;\n"
                   "uniform defaultp vec4 hg_ProgramLocal4;\n"
                   "uniform defaultp vec4 hg_ProgramLocal5;\n"
                   "uniform defaultp vec4 hg_ProgramLocal6;\n"
                   "void main()\n"
                   "{\n"
                   "    defaultp vec3 N = hg_TexCoord2.xyz*sign(hg_TexCoord2.z);\n"
                   "    defaultp vec4 color;\n"
                   "    if (hg_TexCoord2.w >= 0.) { color = texture2D(hg_Texture0, hg_TexCoord0.xy); color.xyz = mix(color"
                   ".xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w); color.w *= hg_ProgramLocal0.y; } else { color = texture2"
                   "D(hg_Texture1, hg_TexCoord1.xy); color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, -1. - hg_TexCoord2."
                   "w); color.w *= hg_ProgramLocal0.w; }\n"
                   "    if (color.w == 0.) discard;\n"
                   "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
                   "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
                   "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLoc"
                   "al5.w);\n"
                   "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), "
                   "0., 1.));\n"
                   "    gl_FragColor = color;\n"
                   "}\n"
                   "//MD5=6d683b18:e19499dd:89a80eed:33f6c6d3\n"
                   "//SIG=01000000:00000000:00000000:00000000:0008:0007:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
        }
        else if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
        {
          return "//GLfs1.0      \n"
                 "//LEN=000000053e\n"
                 "uniform sampler2DRect hg_Texture0;\n"
                 "uniform sampler2DRect hg_Texture1;\n"
                 "uniform vec4 hg_ProgramLocal0;\n"
                 "uniform vec4 hg_ProgramLocal1;\n"
                 "uniform vec4 hg_ProgramLocal2;\n"
                 "uniform vec4 hg_ProgramLocal3;\n"
                 "uniform vec4 hg_ProgramLocal4;\n"
                 "uniform vec4 hg_ProgramLocal5;\n"
                 "uniform vec4 hg_ProgramLocal6;\n"
                 "void main()\n"
                 "{\n"
                 "    vec3 N = gl_TexCoord[2].xyz*sign(gl_TexCoord[2].z);\n"
                 "    vec4 color;\n"
                 "    if (gl_TexCoord[2].w >= 0.) { color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy); color.xyz = mix"
                 "(color.xyz, hg_ProgramLocal1.xyz, 1. - float(gl_TexCoord[2].z >= 0.)); color.w *= hg_ProgramLocal0.y; }"
                 " else { color = texture2DRect(hg_Texture1, gl_TexCoord[1].xy); color.xyz = mix(color.xyz, hg_ProgramLoc"
                 "al1.xyz, 1. - float(gl_TexCoord[2].z >= 0.)); color.w *= hg_ProgramLocal0.w; }\n"
                 "    if (color.w == 0.) discard;\n"
                 "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
                 "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
                 "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal"
                 "5.w);\n"
                 "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0."
                 ", 1.));\n"
                 "    gl_FragColor = color;\n"
                 "}\n"
                 "//MD5=96f478a4:68ca6376:eca3120a:0382949c\n"
                 "//SIG=01000000:00000000:00000000:00000000:000b:0007:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
        }
        else
        {
          return "//GLfs2.0      \n"
                 "//LEN=0000000640\n"
                 "#ifndef GL_ES\n"
                 "#define lowp\n"
                 "#define mediump\n"
                 "#define highp\n"
                 "#endif\n"
                 "#define defaultp mediump\n"
                 "uniform defaultp sampler2D hg_Texture0;\n"
                 "uniform defaultp sampler2D hg_Texture1;\n"
                 "varying highp vec4 hg_TexCoord0;\n"
                 "varying highp vec4 hg_TexCoord1;\n"
                 "varying highp vec4 hg_TexCoord2;\n"
                 "uniform defaultp vec4 hg_ProgramLocal0;\n"
                 "uniform defaultp vec4 hg_ProgramLocal1;\n"
                 "uniform defaultp vec4 hg_ProgramLocal2;\n"
                 "uniform defaultp vec4 hg_ProgramLocal3;\n"
                 "uniform defaultp vec4 hg_ProgramLocal4;\n"
                 "uniform defaultp vec4 hg_ProgramLocal5;\n"
                 "uniform defaultp vec4 hg_ProgramLocal6;\n"
                 "void main()\n"
                 "{\n"
                 "\n"
                 "    defaultp vec3 N = hg_TexCoord2.xyz*sign(hg_TexCoord2.z);\n"
                 "    defaultp vec4 color;\n"
                 "    if (hg_TexCoord2.w >= 0.) { color = texture2D(hg_Texture0, hg_TexCoord0.xy); color.xyz = mix(color.x"
                 "yz, hg_ProgramLocal1.xyz, 1. - float(hg_TexCoord2.z >= 0.)); color.w *= hg_ProgramLocal0.y; } else { co"
                 "lor = texture2D(hg_Texture1, hg_TexCoord1.xy); color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, 1. - fl"
                 "oat(hg_TexCoord2.z >= 0.)); color.w *= hg_ProgramLocal0.w; }\n"
                 "    if (color.w == 0.) discard;\n"
                 "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
                 "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
                 "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal"
                 "5.w);\n"
                 "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0."
                 ", 1.));\n"
                 "    gl_FragColor = color;\n"
                 "}\n"
                 "//MD5=6512e0e9:9aceb198:492c6c92:460f64b9\n"
                 "//SIG=01000000:00000000:00000000:00000000:000b:0007:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
        }
      }
      else if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
      {
        return "//GLfs1.0      \n"
               "//LEN=00000004b6\n"
               "uniform sampler2DRect hg_Texture0;\n"
               "uniform sampler2DRect hg_Texture1;\n"
               "uniform vec4 hg_ProgramLocal0;\n"
               "uniform vec4 hg_ProgramLocal1;\n"
               "uniform vec4 hg_ProgramLocal2;\n"
               "uniform vec4 hg_ProgramLocal3;\n"
               "uniform vec4 hg_ProgramLocal4;\n"
               "uniform vec4 hg_ProgramLocal5;\n"
               "uniform vec4 hg_ProgramLocal6;\n"
               "void main()\n"
               "{\n"
               "    vec3 N = gl_TexCoord[2].xyz*sign(gl_TexCoord[2].z);\n"
               "    vec4 color;\n"
               "    if (gl_TexCoord[2].z > 0.) color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy); else color = texture"
               "2DRect(hg_Texture1, gl_TexCoord[1].xy);\n"
               "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w);\n"
               "    color.w *= hg_ProgramLocal0.y;\n"
               "    if (color.w == 0.) discard;\n"
               "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
               "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
               "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal5."
               "w);\n"
               "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0., "
               "1.));\n"
               "    gl_FragColor = color;\n"
               "}\n"
               "//MD5=1ffc5b22:dfce327a:09069485:c32701b3\n"
               "//SIG=01000000:00000000:00000000:00000000:0007:0007:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
      }
      else
      {
        return "//GLfs2.0      \n"
               "//LEN=00000005ba\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#endif\n"
               "#define defaultp mediump\n"
               "uniform defaultp sampler2D hg_Texture0;\n"
               "uniform defaultp sampler2D hg_Texture1;\n"
               "varying highp vec4 hg_TexCoord0;\n"
               "varying highp vec4 hg_TexCoord1;\n"
               "varying highp vec4 hg_TexCoord2;\n"
               "uniform defaultp vec4 hg_ProgramLocal0;\n"
               "uniform defaultp vec4 hg_ProgramLocal1;\n"
               "uniform defaultp vec4 hg_ProgramLocal2;\n"
               "uniform defaultp vec4 hg_ProgramLocal3;\n"
               "uniform defaultp vec4 hg_ProgramLocal4;\n"
               "uniform defaultp vec4 hg_ProgramLocal5;\n"
               "uniform defaultp vec4 hg_ProgramLocal6;\n"
               "void main()\n"
               "{\n"
               "    defaultp vec3 N = hg_TexCoord2.xyz*sign(hg_TexCoord2.z);\n"
               "    defaultp vec4 color;\n"
               "    if (hg_TexCoord2.z >= 0.) color = texture2D(hg_Texture0, hg_TexCoord0.xy); else color = texture2D(hg_T"
               "exture1, hg_TexCoord1.xy);\n"
               "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w);\n"
               "    color.w *= hg_ProgramLocal0.y;\n"
               "    if (color.w == 0.) discard;\n"
               "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
               "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
               "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal5."
               "w);\n"
               "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0., "
               "1.));\n"
               "    gl_FragColor = color;\n"
               "}\n"
               "//MD5=730c0ffa:a53248be:33a85183:f0cac4ce\n"
               "//SIG=01000000:00000000:00000000:00000000:0007:0007:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
      }
    }
    v8 = *(unsigned __int8 *)(v6 + 144);
    v9 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46);
    v10 = "//GLfs1.0      \n"
          "//LEN=000000046a\n"
          "#extension GL_ARB_texture_rectangle : enable\n"
          "uniform sampler2DRect hg_Texture0;\n"
          "uniform vec4 hg_ProgramLocal0;\n"
          "uniform vec4 hg_ProgramLocal1;\n"
          "uniform vec4 hg_ProgramLocal2;\n"
          "uniform vec4 hg_ProgramLocal3;\n"
          "uniform vec4 hg_ProgramLocal4;\n"
          "uniform vec4 hg_ProgramLocal5;\n"
          "uniform vec4 hg_ProgramLocal6;\n"
          "void main()\n"
          "{\n"
          "    vec3 N = gl_TexCoord[2].xyz*sign(gl_TexCoord[2].z);\n"
          "    vec4 color;\n"
          "    color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy);\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w);\n"
          "    color.w *= hg_ProgramLocal0.y;\n"
          "    if (color.w == 0.) discard;\n"
          "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
          "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
          "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal5.w);\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0., 1.));"
          "\n"
          "    gl_FragColor = color;\n"
          "}\n"
          "//MD5=50bcc0cd:7bd315ab:4e84c0b7:5357fb32\n"
          "//SIG=01000000:00000000:00000000:00000000:0006:0007:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
    v11 = v9 == 0;
    v12 = "//GLfs1.0      \n"
          "//LEN=00000004aa\n"
          "#extension GL_ARB_texture_rectangle : enable\n"
          "uniform sampler2DRect hg_Texture0;\n"
          "uniform vec4 hg_ProgramLocal0;\n"
          "uniform vec4 hg_ProgramLocal1;\n"
          "uniform vec4 hg_ProgramLocal2;\n"
          "uniform vec4 hg_ProgramLocal3;\n"
          "uniform vec4 hg_ProgramLocal4;\n"
          "uniform vec4 hg_ProgramLocal5;\n"
          "uniform vec4 hg_ProgramLocal6;\n"
          "void main()\n"
          "{\n"
          "    vec3 N = gl_TexCoord[2].xyz*sign(gl_TexCoord[2].z);\n"
          "    vec4 color;\n"
          "    color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy);\n"
          "    if (gl_TexCoord[2].z < 0.) color.xyz = hg_ProgramLocal1.xyz;\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w);\n"
          "    color.w *= hg_ProgramLocal0.y;\n"
          "    if (color.w == 0.) discard;\n"
          "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
          "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
          "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal5.w);\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0., 1.));"
          "\n"
          "    gl_FragColor = color;\n"
          "}\n"
          "//MD5=84c0772d:b3f43045:cf620bf2:2131a68a\n"
          "//SIG=01000000:00000000:00000000:00000000:0007:0007:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
    if (!v9)
      v10 = "//GLfs2.0      \n"
            "//LEN=0000000522\n"
            "#ifndef GL_ES\n"
            "#define lowp\n"
            "#define mediump\n"
            "#define highp\n"
            "#endif\n"
            "#define defaultp mediump\n"
            "uniform defaultp sampler2D hg_Texture0;\n"
            "varying highp vec4 hg_TexCoord0;\n"
            "varying highp vec4 hg_TexCoord2;\n"
            "uniform defaultp vec4 hg_ProgramLocal0;\n"
            "uniform defaultp vec4 hg_ProgramLocal1;\n"
            "uniform defaultp vec4 hg_ProgramLocal2;\n"
            "uniform defaultp vec4 hg_ProgramLocal3;\n"
            "uniform defaultp vec4 hg_ProgramLocal4;\n"
            "uniform defaultp vec4 hg_ProgramLocal5;\n"
            "uniform defaultp vec4 hg_ProgramLocal6;\n"
            "void main()\n"
            "{\n"
            "    defaultp vec3 N = hg_TexCoord2.xyz*sign(hg_TexCoord2.z);\n"
            "    defaultp vec4 color;\n"
            "    color = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
            "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w);\n"
            "    color.w *= hg_ProgramLocal0.y;\n"
            "    if (color.w == 0.) discard;\n"
            "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
            "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
            "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal5.w);"
            "\n"
            "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0., 1.)"
            ");\n"
            "    gl_FragColor = color;\n"
            "}\n"
            "//MD5=3d5aef97:d57d9f0c:eb222e68:4e70c3a7\n"
            "//SIG=01000000:00000000:00000000:00000000:0006:0007:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
    v13 = "//GLfs2.0      \n"
          "//LEN=0000000560\n"
          "#ifndef GL_ES\n"
          "#define lowp\n"
          "#define mediump\n"
          "#define highp\n"
          "#endif\n"
          "#define defaultp mediump\n"
          "uniform defaultp sampler2D hg_Texture0;\n"
          "varying highp vec4 hg_TexCoord0;\n"
          "varying highp vec4 hg_TexCoord2;\n"
          "uniform defaultp vec4 hg_ProgramLocal0;\n"
          "uniform defaultp vec4 hg_ProgramLocal1;\n"
          "uniform defaultp vec4 hg_ProgramLocal2;\n"
          "uniform defaultp vec4 hg_ProgramLocal3;\n"
          "uniform defaultp vec4 hg_ProgramLocal4;\n"
          "uniform defaultp vec4 hg_ProgramLocal5;\n"
          "uniform defaultp vec4 hg_ProgramLocal6;\n"
          "void main()\n"
          "{\n"
          "    defaultp vec3 N = hg_TexCoord2.xyz*sign(hg_TexCoord2.z);\n"
          "    defaultp vec4 color;\n"
          "    color = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
          "    if (hg_TexCoord2.z < 0.) color.xyz = hg_ProgramLocal1.xyz;\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w);\n"
          "    color.w *= hg_ProgramLocal0.y;\n"
          "    if (color.w == 0.) discard;\n"
          "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
          "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
          "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal5.w);\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0., 1.));"
          "\n"
          "    gl_FragColor = color;\n"
          "}\n"
          "//MD5=db130e93:74ff1d49:d5dadf6b:55aa0d76\n"
          "//SIG=01000000:00000000:00000000:00000000:0007:0007:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
  }
  else
  {
    if (Input)
    {
      if (*(_DWORD *)(v6 + 140))
      {
        if (*(_BYTE *)(v6 + 144) || *(float *)(v6 + 136) != 0.0)
        {
          if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
            return "//GLfs1.0      \n"
                   "//LEN=0000000319\n"
                   "#extension GL_ARB_texture_rectangle : enable\n"
                   "uniform sampler2DRect hg_Texture0;\n"
                   "uniform sampler2DRect hg_Texture1;\n"
                   "uniform vec4 hg_ProgramLocal0;\n"
                   "uniform vec4 hg_ProgramLocal1;\n"
                   "void main()\n"
                   "{\n"
                   "    vec4 color;\n"
                   "    if (gl_TexCoord[2].w >= 0.) { color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy); color.xyz = m"
                   "ix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w); color.w *= hg_ProgramLocal0.y; } else { color "
                   "= texture2DRect(hg_Texture1, gl_TexCoord[1].xy); color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, -1."
                   " - gl_TexCoord[2].w); color.w *= hg_ProgramLocal0.w; }\n"
                   "    if (color.w == 0.) discard;\n"
                   "\t gl_FragColor = color;\n"
                   "}\n"
                   "//MD5=f673426c:e4b2910d:9e07361f:3e827073\n"
                   "//SIG=01000000:00000000:00000000:00000000:0003:0002:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
          else
            return "//GLfs2.0      \n"
                   "//LEN=00000003bc\n"
                   "#ifndef GL_ES\n"
                   "#define lowp\n"
                   "#define mediump\n"
                   "#define highp\n"
                   "#endif\n"
                   "#define defaultp mediump\n"
                   "uniform defaultp sampler2D hg_Texture0;\n"
                   "uniform defaultp sampler2D hg_Texture1;\n"
                   "varying highp vec4 hg_TexCoord0;\n"
                   "varying highp vec4 hg_TexCoord1;\n"
                   "varying highp vec4 hg_TexCoord2;\n"
                   "uniform defaultp vec4 hg_ProgramLocal0;\n"
                   "uniform defaultp vec4 hg_ProgramLocal1;\n"
                   "void main()\n"
                   "{\n"
                   "\n"
                   "    defaultp vec4 color;\n"
                   "    if (hg_TexCoord2.w >= 0.) { color = texture2D(hg_Texture0, hg_TexCoord0.xy); color.xyz = mix(color"
                   ".xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w); color.w *= hg_ProgramLocal0.y; } else { color = texture2"
                   "D(hg_Texture1, hg_TexCoord1.xy); color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, -1. - hg_TexCoord2."
                   "w); color.w *= hg_ProgramLocal0.w; }\n"
                   "    if (color.w == 0.) discard;\n"
                   "\t gl_FragColor = color;\n"
                   "}\n"
                   "//MD5=d7802c70:56f4148a:7de1731f:a6628685\n"
                   "//SIG=01000000:00000000:00000000:00000000:0003:0002:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
        }
        else if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
        {
          return "//GLfs1.0      \n"
                 "//LEN=000000030a\n"
                 "uniform sampler2DRect hg_Texture0;\n"
                 "uniform sampler2DRect hg_Texture1;\n"
                 "uniform vec4 hg_ProgramLocal0;\n"
                 "uniform vec4 hg_ProgramLocal1;\n"
                 "void main()\n"
                 "{\n"
                 "    vec4 color;\n"
                 "    if (gl_TexCoord[2].w >= 0.) { color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy); color.xyz = mix"
                 "(color.xyz, hg_ProgramLocal1.xyz, 1. - float(gl_TexCoord[2].z >= 0.)); color.w *= hg_ProgramLocal0.y; }"
                 " else { color = texture2DRect(hg_Texture1, gl_TexCoord[1].xy); color.xyz = mix(color.xyz, hg_ProgramLoc"
                 "al1.xyz, 1. - float(gl_TexCoord[2].z >= 0.)); color.w *= hg_ProgramLocal0.w; }\n"
                 "    if (color.w == 0.) discard;\n"
                 "\t gl_FragColor = color;\n"
                 "}\n"
                 "//MD5=153a8d02:f92fde9d:5699771f:c33d93d6\n"
                 "//SIG=01000000:00000000:00000000:00000000:0006:0002:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
        }
        else
        {
          return "//GLfs2.0      \n"
                 "//LEN=00000003da\n"
                 "#ifndef GL_ES\n"
                 "#define lowp\n"
                 "#define mediump\n"
                 "#define highp\n"
                 "#endif\n"
                 "#define defaultp mediump\n"
                 "uniform defaultp sampler2D hg_Texture0;\n"
                 "uniform defaultp sampler2D hg_Texture1;\n"
                 "varying highp vec4 hg_TexCoord0;\n"
                 "varying highp vec4 hg_TexCoord1;\n"
                 "varying highp vec4 hg_TexCoord2;\n"
                 "uniform defaultp vec4 hg_ProgramLocal0;\n"
                 "uniform defaultp vec4 hg_ProgramLocal1;\n"
                 "void main()\n"
                 "{\n"
                 "\n"
                 "    defaultp vec4 color;\n"
                 "    if (hg_TexCoord2.w >= 0.) { color = texture2D(hg_Texture0, hg_TexCoord0.xy); color.xyz = mix(color.x"
                 "yz, hg_ProgramLocal1.xyz, 1. - float(hg_TexCoord2.z >= 0.)); color.w *= hg_ProgramLocal0.y; } else { co"
                 "lor = texture2D(hg_Texture1, hg_TexCoord1.xy); color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, 1. - fl"
                 "oat(hg_TexCoord2.z >= 0.)); color.w *= hg_ProgramLocal0.w; }\n"
                 "    if (color.w == 0.) discard;\n"
                 "\t gl_FragColor = color;\n"
                 "}\n"
                 "//MD5=b073f2bb:326233fb:1e6214d5:44610998\n"
                 "//SIG=01000000:00000000:00000000:00000000:0006:0002:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
        }
      }
      else if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
      {
        return "//GLfs1.0      \n"
               "//LEN=00000002b0\n"
               "#extension GL_ARB_texture_rectangle : enable\n"
               "uniform sampler2DRect hg_Texture0;\n"
               "uniform sampler2DRect hg_Texture1;\n"
               "uniform vec4 hg_ProgramLocal0;\n"
               "uniform vec4 hg_ProgramLocal1;\n"
               "void main()\n"
               "{\n"
               "    vec4 color;\n"
               "    if (gl_TexCoord[2].z >= 0.) color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy); else color = textur"
               "e2DRect(hg_Texture1, gl_TexCoord[1].xy);\n"
               "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w);\n"
               "    color.w *= hg_ProgramLocal0.y;\n"
               "    if (color.w == 0.) discard;\n"
               "\t gl_FragColor = color;\n"
               "}\n"
               "//MD5=8e12dae5:052ec9c0:5f3a6a16:1b06dafe\n"
               "//SIG=01000000:00000000:00000000:00000000:0002:0002:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
      }
      else
      {
        return "//GLfs2.0      \n"
               "//LEN=0000000355\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#endif\n"
               "#define defaultp mediump\n"
               "uniform defaultp sampler2D hg_Texture0;\n"
               "uniform defaultp sampler2D hg_Texture1;\n"
               "varying highp vec4 hg_TexCoord0;\n"
               "varying highp vec4 hg_TexCoord1;\n"
               "varying highp vec4 hg_TexCoord2;\n"
               "uniform defaultp vec4 hg_ProgramLocal0;\n"
               "uniform defaultp vec4 hg_ProgramLocal1;\n"
               "void main()\n"
               "{\n"
               "\n"
               "    defaultp vec4 color;\n"
               "    if (hg_TexCoord2.z >= 0.) color = texture2D(hg_Texture0, hg_TexCoord0.xy); else color = texture2D(hg_T"
               "exture1, hg_TexCoord1.xy);\n"
               "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w);\n"
               "    color.w *= hg_ProgramLocal0.y;\n"
               "    if (color.w == 0.) discard;\n"
               "\t gl_FragColor = color;\n"
               "}\n"
               "//MD5=fb2a20d4:43fc0741:04bdeaa2:d1f82ff2\n"
               "//SIG=01000000:00000000:00000000:00000000:0002:0002:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
      }
    }
    v8 = *(unsigned __int8 *)(v6 + 144);
    v14 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46);
    v10 = "//GLfs1.0      \n"
          "//LEN=0000000236\n"
          "#extension GL_ARB_texture_rectangle : enable\n"
          "uniform sampler2DRect hg_Texture0;\n"
          "uniform vec4 hg_ProgramLocal0;\n"
          "uniform vec4 hg_ProgramLocal1;\n"
          "void main()\n"
          "{\n"
          "    vec4 color;\n"
          "    color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy);\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w);\n"
          "    color.w *= hg_ProgramLocal0.y;\n"
          "    if (color.w == 0.) discard;\n"
          "\t gl_FragColor = color;\n"
          "}\n"
          "//MD5=d2fdd930:3bbc72e9:2dad14b9:097199ac\n"
          "//SIG=01000000:00000000:00000000:00000000:0001:0002:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
    v11 = v14 == 0;
    v12 = "//GLfs1.0      \n"
          "//LEN=0000000276\n"
          "#extension GL_ARB_texture_rectangle : enable\n"
          "uniform sampler2DRect hg_Texture0;\n"
          "uniform vec4 hg_ProgramLocal0;\n"
          "uniform vec4 hg_ProgramLocal1;\n"
          "void main()\n"
          "{\n"
          "    vec4 color;\n"
          "    color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy);\n"
          "    if (gl_TexCoord[2].z < 0.) color.xyz = hg_ProgramLocal1.xyz;\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w);\n"
          "    color.w *= hg_ProgramLocal0.y;\n"
          "    if (color.w == 0.) discard;\n"
          "\t gl_FragColor = color;\n"
          "}\n"
          "//MD5=10e54296:9caf9cc8:d7817b0a:892592fe\n"
          "//SIG=01000000:00000000:00000000:00000000:0002:0002:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
    if (!v14)
      v10 = "//GLfs2.0      \n"
            "//LEN=00000002bd\n"
            "#ifndef GL_ES\n"
            "#define lowp\n"
            "#define mediump\n"
            "#define highp\n"
            "#endif\n"
            "#define defaultp mediump\n"
            "uniform defaultp sampler2D hg_Texture0;\n"
            "varying highp vec4 hg_TexCoord0;\n"
            "varying highp vec4 hg_TexCoord2;\n"
            "uniform defaultp vec4 hg_ProgramLocal0;\n"
            "uniform defaultp vec4 hg_ProgramLocal1;\n"
            "void main()\n"
            "{\n"
            "\n"
            "    defaultp vec4 color;\n"
            "    color = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
            "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w);\n"
            "    color.w *= hg_ProgramLocal0.y;\n"
            "    if (color.w == 0.) discard;\n"
            "\t gl_FragColor = color;\n"
            "}\n"
            "//MD5=fdbbe725:fdd32d95:d5c4f9b0:c807ee7e\n"
            "//SIG=01000000:00000000:00000000:00000000:0001:0002:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
    v13 = "//GLfs2.0      \n"
          "//LEN=00000002fb\n"
          "#ifndef GL_ES\n"
          "#define lowp\n"
          "#define mediump\n"
          "#define highp\n"
          "#endif\n"
          "#define defaultp mediump\n"
          "uniform defaultp sampler2D hg_Texture0;\n"
          "varying highp vec4 hg_TexCoord0;\n"
          "varying highp vec4 hg_TexCoord2;\n"
          "uniform defaultp vec4 hg_ProgramLocal0;\n"
          "uniform defaultp vec4 hg_ProgramLocal1;\n"
          "void main()\n"
          "{\n"
          "\n"
          "    defaultp vec4 color;\n"
          "    color = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
          "    if (hg_TexCoord2.z < 0.) color.xyz = hg_ProgramLocal1.xyz;\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w);\n"
          "    color.w *= hg_ProgramLocal0.y;\n"
          "    if (color.w == 0.) discard;\n"
          "\t gl_FragColor = color;\n"
          "}\n"
          "//MD5=56c28ca8:08fd1fcd:e3cb6cf8:3365155c\n"
          "//SIG=01000000:00000000:00000000:00000000:0002:0002:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
  }
  if (!v11)
    v13 = v12;
  if (v8)
    return v10;
  else
    return v13;
}

uint64_t HGFractured::BindTexture(HGFractured::Effect **this, HGHandler *a2, uint64_t a3)
{
  uint64_t v5;
  double v7[17];

  v7[16] = *(double *)MEMORY[0x1E0C80C00];
  HGFractured::Effect::GetTextureMatrix(this[53], v7);
  if ((_DWORD)a3 == 1)
  {
    v5 = 1;
    HGHandler::TexCoord(a2, 1, 0, 0, 0);
    if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    {
LABEL_6:
      (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      v5 = a3;
    }
LABEL_7:
    (*(void (**)(HGHandler *, double *))(*(_QWORD *)a2 + 112))(a2, v7);
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, v5, 0);
    (*(void (**)(HGHandler *, uint64_t, uint64_t))(*(_QWORD *)a2 + 48))(a2, 1, 1);
    return 0;
  }
  if (!(_DWORD)a3)
  {
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    v5 = 0;
    if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
      goto LABEL_6;
    goto LABEL_7;
  }
  return 0xFFFFFFFFLL;
}

uint64_t HGFractured::Bind(HGFractured *this, HGHandler *a2)
{
  uint64_t v4;
  void (*v5)(HGHandler *, _QWORD, uint64_t, uint64_t);

  HGHandler::TexCoord(a2, 2, 0, 0, 0);
  if (*((_BYTE *)this + 432))
  {
    v4 = *((_QWORD *)this + 51);
    v5 = *(void (**)(HGHandler *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a2 + 144);
    if (*(_BYTE *)(*((_QWORD *)this + 53) + 145))
    {
      v5(a2, 0, v4, 4);
      (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 4, *(float *)(*((_QWORD *)this + 51) + 64), -*(float *)(*((_QWORD *)this + 51) + 68), *(float *)(*((_QWORD *)this + 51) + 72), *(float *)(*((_QWORD *)this + 51) + 76));
      (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
      (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 6, *(float *)(*((_QWORD *)this + 51) + 96), -*(float *)(*((_QWORD *)this + 51) + 100), *(float *)(*((_QWORD *)this + 51) + 104), *(float *)(*((_QWORD *)this + 51) + 108));
    }
    else
    {
      v5(a2, 0, v4, 7);
    }
    return 0;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 2);
    return 0;
  }
}

HGFractured *HGFractured::GetOutput(HGFractured *this, HGRenderer *a2)
{
  HGFractured::Effect *v3;
  uint64_t Rect;
  uint64_t v6;
  uint64_t v7;
  HGNode *Input;
  uint64_t v10;
  uint64_t v11;
  float v12;
  unsigned __int32 v13;
  double v14;
  double v15;
  double v16;
  double v17;
  int32x2_t v18;
  float v19;
  float v20;
  float v21;
  __n128 v22;
  __n128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  double v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  double v35;
  double v36;
  HGRect v37;

  v3 = (HGFractured::Effect *)*((_QWORD *)this + 53);
  if (!v3)
    return 0;
  if (HGFractured::Effect::isCropped(v3))
  {
    Rect = HGFractured::Effect::GetRect(*((HGFractured::Effect **)this + 53));
    v7 = v6;
  }
  else
  {
    Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
    Rect = HGRenderer::GetDOD(a2, Input);
    v7 = v10;
    *(_QWORD *)&v37.var0 = Rect;
    *(_QWORD *)&v37.var2 = v7;
    HGFractured::Effect::SetRect(*((_QWORD *)this + 53), v37);
  }
  v11 = *((_QWORD *)this + 51);
  v12 = *(float *)v11;
  v13 = *(_DWORD *)(v11 + 8);
  if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) != 0)
  {
    v19 = (float)(v7 - Rect);
    v20 = (float)(HIDWORD(v7) - HIDWORD(Rect));
    v21 = (float)(v12 * (float)((float)(1.0 / fminf(v19, v20)) + -1.0)) + 1.0;
    *(float *)(*((_QWORD *)this + 51) + 116) = v21;
    *(float *)(*((_QWORD *)this + 51) + 112) = v21;
    *(float *)(*((_QWORD *)this + 51) + 128) = (float)(v19 * 0.5) * (float)(1.0 - v21);
    *(float *)(*((_QWORD *)this + 51) + 132) = (float)(v20 * 0.5) * (float)(1.0 - v21);
  }
  else
  {
    HGFractured::Effect::init(*((HGFractured::Effect **)this + 53), v14, v15, v16, v17, v18);
    HGFractured::Effect::build(*((HGFractured::Effect **)this + 53));
    v22.n128_f32[0] = v12;
    v23.n128_u32[0] = v13;
    HGFractured::Effect::apply(*((HGFractured::Effect **)this + 53), v22, v23, v31, v32, v33, v34, v35, v36, v24, v25, v26, v27, v28, v29, v30);
  }
  return this;
}

char *HGFractured::RenderPage(HGNode *this, HGPage *a2)
{
  char *Buffer;
  HGRenderer *v5;
  HGNode *Input;
  HGNode *v7;
  HGNode *v8;
  unsigned int *NodeTexture;
  HGBitmap *NodeBitmap;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  const HGTransform *ProjectionMatrix;
  uint64_t v17;
  char *v19;
  _BYTE v20[144];
  _BYTE v21[144];
  _BYTE v22[144];
  double v23[17];

  v23[16] = *(double *)MEMORY[0x1E0C80C00];
  v5 = *(HGRenderer **)a2;
  Buffer = (char *)*((_QWORD *)a2 + 1);
  Input = HGRenderer::GetInput(*(HGRenderer **)a2, this, 0);
  v7 = HGRenderer::GetInput(v5, this, 1u);
  v8 = HGRenderer::GetInput(v5, this, 2u);
  if (Input)
  {
    NodeTexture = HGGPURenderer::GetNodeTexture(v5, Input, *(HGRect *)((char *)a2 + 36), 0, 1u);
    *((_QWORD *)a2 + 21) = NodeTexture;
    if (v7)
      goto LABEL_3;
LABEL_18:
    *((_QWORD *)a2 + 22) = 0;
    if (!Buffer)
      goto LABEL_19;
    goto LABEL_5;
  }
  NodeTexture = 0;
  *((_QWORD *)a2 + 21) = 0;
  if (!v7)
    goto LABEL_18;
LABEL_3:
  if (v7 == Input)
  {
    *((_QWORD *)a2 + 22) = NodeTexture;
    (*(void (**)(unsigned int *))(*(_QWORD *)NodeTexture + 16))(NodeTexture);
    if (!Buffer)
      goto LABEL_19;
LABEL_5:
    (*(void (**)(char *))(*(_QWORD *)Buffer + 16))(Buffer);
    if (v8)
      goto LABEL_6;
LABEL_20:
    (*(void (**)(HGRenderer *, char *))(*(_QWORD *)v5 + 144))(v5, Buffer);
    HGGPURenderer::Clear(v5, *((HGRect *)a2 + 1), (float *)(*((_QWORD *)this + 51) + 32), v19);
    v13 = *((_QWORD *)a2 + 21);
    if (v13)
      goto LABEL_14;
LABEL_21:
    v14 = 0;
    v15 = *((_QWORD *)a2 + 22);
    if (!v15)
      goto LABEL_16;
    goto LABEL_15;
  }
  *((_QWORD *)a2 + 22) = HGGPURenderer::GetNodeTexture(v5, v7, *(HGRect *)((char *)a2 + 52), 0, 1u);
  if (Buffer)
    goto LABEL_5;
LABEL_19:
  Buffer = HGGPURenderer::CreateBuffer((uint64_t)v5, *((HGRect *)a2 + 1), *((unsigned int *)a2 + 8), 0, (*((_DWORD *)this + 4) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
  *((_QWORD *)a2 + 1) = Buffer;
  if (!v8)
    goto LABEL_20;
LABEL_6:
  NodeBitmap = HGGPURenderer::GetNodeBitmap(v5, v8, *((HGRect *)a2 + 1), (HGBuffer *)Buffer, 1u);
  if (NodeBitmap != (HGBitmap *)Buffer)
  {
    v11 = HGGPURenderer::ConvertToGLTexture(v5, *((HGRect *)a2 + 1), NodeBitmap);
    (*(void (**)(HGRenderer *, char *))(*(_QWORD *)v5 + 144))(v5, Buffer);
    (*(void (**)(HGRenderer *, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v5 + 152))(v5, 0, v11, 0, 0);
    HGGPURenderer::Copy(v5, *((HGRect *)a2 + 1), 0, v12);
    if (v11 && (HGBitmap *)v11 != NodeBitmap)
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
    (*(void (**)(HGRenderer *, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v5 + 152))(v5, 0, 0, 0, 0);
  }
  if (NodeBitmap)
    (*(void (**)(HGBitmap *))(*(_QWORD *)NodeBitmap + 24))(NodeBitmap);
  v13 = *((_QWORD *)a2 + 21);
  if (!v13)
    goto LABEL_21;
LABEL_14:
  (*(void (**)(HGRenderer *, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v5 + 152))(v5, 0, v13, 0, 0);
  (*(void (**)(_QWORD))(**((_QWORD **)a2 + 21) + 24))(*((_QWORD *)a2 + 21));
  v14 = 1;
  v15 = *((_QWORD *)a2 + 22);
  if (v15)
  {
LABEL_15:
    (*(void (**)(HGRenderer *, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v5 + 152))(v5, 1, v15, 0, 0);
    (*(void (**)(_QWORD))(**((_QWORD **)a2 + 22) + 24))(*((_QWORD *)a2 + 22));
    v14 |= 2u;
  }
LABEL_16:
  HGTransform::HGTransform((HGTransform *)v22);
  ProjectionMatrix = (const HGTransform *)HGGPURenderer::GetProjectionMatrix(v5);
  HGTransform::LoadTransform((HGTransform *)v22, ProjectionMatrix);
  HGTransform::HGTransform((HGTransform *)v21);
  HGFractured::Effect::GetProjectionMatrix(*((_QWORD *)this + 53), v23, *((HGRect *)a2 + 1));
  HGTransform::LoadMatrixd((HGTransform *)v21, v23);
  HGTransform::HGTransform((HGTransform *)v20);
  HGFractured::Effect::GetModelviewMatrix(*((HGFractured::Effect **)this + 53), v23);
  HGTransform::LoadMatrixd((HGTransform *)v20, v23);
  HGTransform::PreMultiply((HGTransform *)v21, (const HGTransform *)v20);
  HGGPURenderer::SetProjectionMatrix(v5, (HGTransform *)v21);
  v17 = (*(uint64_t (**)(HGRenderer *, _QWORD, HGNode *))(*(_QWORD *)v5 + 368))(v5, *((_QWORD *)this + 8), this);
  (*(void (**)(HGNode *, HGPage *, _QWORD, uint64_t))(*(_QWORD *)this + 488))(this, a2, 0, v17);
  HGFractured::Effect::Render(*((HGFractured::Effect **)this + 53), v5, *((HGRect *)a2 + 1), *(float *)(*((_QWORD *)this + 51) + 4), *(float *)(*((_QWORD *)this + 51) + 12), v14);
  (*(void (**)(HGNode *, HGPage *, _QWORD, uint64_t))(*(_QWORD *)this + 496))(this, a2, 0, v17);
  HGGPURenderer::SetProjectionMatrix(v5, (HGTransform *)v22);
  HGTransform::~HGTransform((HGTransform *)v20);
  HGTransform::~HGTransform((HGTransform *)v21);
  HGTransform::~HGTransform((HGTransform *)v22);
  return Buffer;
}

void sub_1B2AFC850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
  HGTransform::~HGTransform((HGTransform *)&a28);
  HGTransform::~HGTransform((HGTransform *)&a46);
  _Unwind_Resume(a1);
}

void sub_1B2AFC888(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
  HGTransform::~HGTransform((HGTransform *)&a46);
  _Unwind_Resume(a1);
}

void sub_1B2AFC89C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
  HGTransform::~HGTransform((HGTransform *)&a10);
  HGTransform::~HGTransform((HGTransform *)&a28);
  HGTransform::~HGTransform((HGTransform *)&a46);
  _Unwind_Resume(a1);
}

uint64_t HGFractured::RenderTile(HGFractured *this, float32x4_t **a2)
{
  uint64_t v4;
  int v5;
  float32x4_t v6;
  int v7;
  int v8;
  float32x4_t *v9;
  uint64_t v10;
  __int128 v11;
  float32x4_t *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  float32x4_t v16;
  float32x4_t v17;
  int v18;
  uint64_t v19;
  float32x4_t v20;
  int32x4_t v21;
  float32x2_t v22;
  float32x4_t *v23;
  float32x4_t v24;
  uint64_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int32x4_t v28;
  float32x4_t *v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int32x4_t v33;
  float32x4_t *v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int32x4_t v38;
  float32x4_t *v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t *v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t *v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t *v55;
  uint64_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int32x4_t v59;
  float32x4_t v60;
  int32x4_t v61;
  float32x4_t v62;
  int32x4_t v63;
  float32x4_t v64;
  int32x4_t v65;
  uint64_t v66;
  uint64_t v67;
  float32x4_t v68;
  int32x4_t v69;
  float32x4_t *v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  int32x4_t v74;
  float32x4_t v75;
  int v76;
  float32x4_t *v77;
  uint64_t v78;
  float32x4_t v79;
  float32x4_t v80;
  int v81;
  float32x4_t *v82;
  float32x4_t v83;
  int32x4_t v84;
  float32x2_t v85;
  float32x4_t *v86;
  float32x4_t v87;
  uint64_t v88;
  float32x4_t v89;
  float32x4_t v90;
  int32x4_t v91;
  float32x4_t *v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  int32x4_t v96;
  float32x4_t *v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  int32x4_t v101;
  float32x4_t *v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t *v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t *v115;
  uint64_t v116;
  float32x4_t v117;
  float32x4_t v118;
  int32x4_t v119;
  float32x4_t v120;
  int32x4_t v121;
  float32x4_t v122;
  int32x4_t v123;
  float32x4_t v124;
  int32x4_t v125;
  uint64_t v126;
  float32x4_t *v127;
  uint64_t v128;
  float32x4_t v129;
  int32x4_t v130;
  float32x4_t *v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t *v134;
  float32x4_t v135;
  int32x4_t v136;
  float32x4_t v137;

  v4 = HGTile::Renderer((HGTile *)a2);
  v5 = (*(uint64_t (**)(HGFractured *, uint64_t))(*(_QWORD *)this + 312))(this, v4);
  *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(*(int32x2_t *)a2), (float32x2_t)0x3F0000003F000000);
  v6.i64[1] = 0x3F80000000000000;
  v7 = *((_DWORD *)a2 + 2) - *a2;
  v8 = *((_DWORD *)a2 + 3) - ((unint64_t)*a2 >> 32);
  v9 = a2[2];
  v10 = *((int *)a2 + 6);
  v11 = *(_OWORD *)*((_QWORD *)this + 51);
  v12 = a2[14];
  if (!v12)
  {
    if (v8 < 1)
      return 0;
    v76 = 0;
    v77 = v9 + 2;
    v78 = 16 * v10;
    v79.i64[0] = 0x3F0000003F000000;
    v79.i64[1] = 0x3F0000003F000000;
    v80 = v6;
    while (v7 < 4)
    {
      LODWORD(v126) = 0;
      v83 = v80;
      if (v7 > 0)
        goto LABEL_31;
LABEL_21:
      v80 = vaddq_f32(v80, (float32x4_t)xmmword_1B304F240);
      ++v76;
      v77 = (float32x4_t *)((char *)v77 + v78);
      v9 = (float32x4_t *)((char *)v9 + v78);
      if (v76 == v8)
        return 0;
    }
    v81 = 0;
    v82 = v77;
    v83 = v80;
    do
    {
      v106 = vaddq_f32(v83, (float32x4_t)xmmword_1B304F230);
      v107 = vaddq_f32(v106, (float32x4_t)xmmword_1B304F230);
      v108 = vaddq_f32(v107, (float32x4_t)xmmword_1B304F230);
      v109 = (float32x4_t *)*((_QWORD *)this + 51);
      v111 = v109[7];
      v110 = v109[8];
      v112 = vaddq_f32(v110, vmulq_f32(v106, v111));
      v113 = vaddq_f32(v110, vmulq_f32(v107, v111));
      v114 = vaddq_f32(v110, vmulq_f32(v108, v111));
      v115 = a2[10];
      v116 = *((int *)a2 + 22);
      v117 = vsubq_f32(vaddq_f32(v110, vmulq_f32(v83, v111)), v6);
      if (v5)
      {
        v84 = vaddq_s32(vcvtq_s32_f32(v117), vcltzq_f32(v117));
        v85 = (float32x2_t)vsubq_f32(v117, vcvtq_f32_s32(v84)).u64[0];
        v86 = &v115[v84.i32[0] + v84.i32[1] * (int)v116];
        v87 = vaddq_f32(*v86, vmulq_n_f32(vsubq_f32(v86[1], *v86), v85.f32[0]));
        v88 = (int)v116 + 1;
        v89 = vaddq_f32(v87, vmulq_lane_f32(vsubq_f32(vaddq_f32(v86[v116], vmulq_n_f32(vsubq_f32(v86[v88], v86[v116]), v85.f32[0])), v87), v85, 1));
        v90 = vsubq_f32(v112, v6);
        v91 = vaddq_s32(vcvtq_s32_f32(v90), vcltzq_f32(v90));
        v90.i64[0] = vsubq_f32(v90, vcvtq_f32_s32(v91)).u64[0];
        v92 = &v115[v91.i32[0] + v91.i32[1] * (int)v116];
        v93 = vaddq_f32(*v92, vmulq_n_f32(vsubq_f32(v92[1], *v92), v90.f32[0]));
        v94 = vaddq_f32(v93, vmulq_lane_f32(vsubq_f32(vaddq_f32(v92[v116], vmulq_n_f32(vsubq_f32(v92[v88], v92[v116]), v90.f32[0])), v93), *(float32x2_t *)v90.f32, 1));
        v95 = vsubq_f32(v113, v6);
        v96 = vaddq_s32(vcvtq_s32_f32(v95), vcltzq_f32(v95));
        v95.i64[0] = vsubq_f32(v95, vcvtq_f32_s32(v96)).u64[0];
        v97 = &v115[v96.i32[0] + v96.i32[1] * (int)v116];
        v98 = vaddq_f32(*v97, vmulq_n_f32(vsubq_f32(v97[1], *v97), v95.f32[0]));
        v99 = vaddq_f32(v98, vmulq_lane_f32(vsubq_f32(vaddq_f32(v97[v116], vmulq_n_f32(vsubq_f32(v97[v88], v97[v116]), v95.f32[0])), v98), *(float32x2_t *)v95.f32, 1));
        v100 = vsubq_f32(v114, v6);
        v101 = vaddq_s32(vcvtq_s32_f32(v100), vcltzq_f32(v100));
        v100.i64[0] = vsubq_f32(v100, vcvtq_f32_s32(v101)).u64[0];
        v102 = &v115[v101.i32[0] + v101.i32[1] * (int)v116];
        v103 = vaddq_f32(*v102, vmulq_n_f32(vsubq_f32(v102[1], *v102), v100.f32[0]));
        v104 = vaddq_f32(v103, vmulq_lane_f32(vsubq_f32(vaddq_f32(v102[v116], vmulq_n_f32(vsubq_f32(v102[v88], v102[v116]), v100.f32[0])), v103), *(float32x2_t *)v100.f32, 1));
      }
      else
      {
        v118 = vaddq_f32(v117, v79);
        v119 = vcvtq_s32_f32(v118);
        v118.i64[0] = vaddq_s32(v119, vcgtq_f32(vcvtq_f32_s32(v119), v118)).u64[0];
        v89 = v115[v118.i32[0] + v118.i32[1] * (int)v116];
        v120 = vaddq_f32(vsubq_f32(v112, v6), v79);
        v121 = vcvtq_s32_f32(v120);
        v120.i64[0] = vaddq_s32(v121, vcgtq_f32(vcvtq_f32_s32(v121), v120)).u64[0];
        v94 = v115[v120.i32[0] + v120.i32[1] * (int)v116];
        v122 = vaddq_f32(vsubq_f32(v113, v6), v79);
        v123 = vcvtq_s32_f32(v122);
        v122.i64[0] = vaddq_s32(v123, vcgtq_f32(vcvtq_f32_s32(v123), v122)).u64[0];
        v99 = v115[v122.i32[0] + v122.i32[1] * (int)v116];
        v124 = vaddq_f32(vsubq_f32(v114, v6), v79);
        v125 = vcvtq_s32_f32(v124);
        v124.i64[0] = vaddq_s32(v125, vcgtq_f32(vcvtq_f32_s32(v125), v124)).u64[0];
        v104 = v115[v124.i32[0] + v124.i32[1] * (int)v116];
      }
      v105 = v109[14];
      v82[-2] = vaddq_f32(v89, vmulq_lane_f32(vsubq_f32(v105, v89), *(float32x2_t *)&v11, 1));
      v82[-1] = vaddq_f32(v94, vmulq_lane_f32(vsubq_f32(v105, v94), *(float32x2_t *)&v11, 1));
      *v82 = vaddq_f32(v99, vmulq_lane_f32(vsubq_f32(v105, v99), *(float32x2_t *)&v11, 1));
      v82[1] = vaddq_f32(v104, vmulq_lane_f32(vsubq_f32(v105, v104), *(float32x2_t *)&v11, 1));
      v82 += 4;
      v83 = vaddq_f32(v108, (float32x4_t)xmmword_1B304F230);
      v81 -= 4;
    }
    while (v7 + v81 > 3);
    LODWORD(v126) = -v81;
    if ((int)v126 >= v7)
      goto LABEL_21;
LABEL_31:
    v126 = v126;
    if (v5)
    {
      do
      {
        v127 = (float32x4_t *)*((_QWORD *)this + 51);
        v128 = *((int *)a2 + 22);
        v129 = vsubq_f32(vaddq_f32(v127[8], vmulq_f32(v83, v127[7])), v6);
        v130 = vaddq_s32(vcvtq_s32_f32(v129), vcltzq_f32(v129));
        v129.i64[0] = vsubq_f32(v129, vcvtq_f32_s32(v130)).u64[0];
        v131 = &a2[10][v130.i32[0] + v130.i32[1] * (int)v128];
        v132 = vaddq_f32(*v131, vmulq_n_f32(vsubq_f32(v131[1], *v131), v129.f32[0]));
        v133 = vaddq_f32(v132, vmulq_lane_f32(vsubq_f32(vaddq_f32(v131[v128], vmulq_n_f32(vsubq_f32(v131[(int)v128 + 1], v131[v128]), v129.f32[0])), v132), *(float32x2_t *)v129.f32, 1));
        v9[v126] = vaddq_f32(v133, vmulq_lane_f32(vsubq_f32(v127[14], v133), *(float32x2_t *)&v11, 1));
        v83 = vaddq_f32(v83, (float32x4_t)xmmword_1B304F230);
        ++v126;
      }
      while (v126 < v7);
    }
    else
    {
      do
      {
        v134 = (float32x4_t *)*((_QWORD *)this + 51);
        v135 = vaddq_f32(vsubq_f32(vaddq_f32(v134[8], vmulq_f32(v83, v134[7])), v6), v79);
        v136 = vcvtq_s32_f32(v135);
        v135.i64[0] = vaddq_s32(v136, vcgtq_f32(vcvtq_f32_s32(v136), v135)).u64[0];
        v137 = a2[10][v135.i32[0] + v135.i32[1] * *((_DWORD *)a2 + 22)];
        v9[v126] = vaddq_f32(v137, vmulq_lane_f32(vsubq_f32(v134[14], v137), *(float32x2_t *)&v11, 1));
        v83 = vaddq_f32(v83, (float32x4_t)xmmword_1B304F230);
        ++v126;
      }
      while (v126 < v7);
    }
    goto LABEL_21;
  }
  if (v8 >= 1)
  {
    v13 = 0;
    v14 = 16 * *((int *)a2 + 30);
    v15 = 16 * v10;
    v16.i64[0] = 0x3F0000003F000000;
    v16.i64[1] = 0x3F0000003F000000;
    v17 = v6;
    while (v7 < 4)
    {
      LODWORD(v66) = 0;
      v20 = v17;
      if (v7 > 0)
        goto LABEL_14;
LABEL_4:
      v17 = vaddq_f32(v17, (float32x4_t)xmmword_1B304F240);
      ++v13;
      v12 = (float32x4_t *)((char *)v12 + v14);
      v9 = (float32x4_t *)((char *)v9 + v15);
      if (v13 == v8)
        return 0;
    }
    v18 = 0;
    v19 = 2;
    v20 = v17;
    do
    {
      v46 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
      v47 = vaddq_f32(v46, (float32x4_t)xmmword_1B304F230);
      v48 = vaddq_f32(v47, (float32x4_t)xmmword_1B304F230);
      v49 = (float32x4_t *)*((_QWORD *)this + 51);
      v51 = v49[7];
      v50 = v49[8];
      v52 = vaddq_f32(v50, vmulq_f32(v46, v51));
      v53 = vaddq_f32(v50, vmulq_f32(v47, v51));
      v54 = vaddq_f32(v50, vmulq_f32(v48, v51));
      v55 = a2[10];
      v56 = *((int *)a2 + 22);
      v57 = vsubq_f32(vaddq_f32(v50, vmulq_f32(v20, v51)), v6);
      if (v5)
      {
        v21 = vaddq_s32(vcvtq_s32_f32(v57), vcltzq_f32(v57));
        v22 = (float32x2_t)vsubq_f32(v57, vcvtq_f32_s32(v21)).u64[0];
        v23 = &v55[v21.i32[0] + v21.i32[1] * (int)v56];
        v24 = vaddq_f32(*v23, vmulq_n_f32(vsubq_f32(v23[1], *v23), v22.f32[0]));
        v25 = (int)v56 + 1;
        v26 = vaddq_f32(v24, vmulq_lane_f32(vsubq_f32(vaddq_f32(v23[v56], vmulq_n_f32(vsubq_f32(v23[v25], v23[v56]), v22.f32[0])), v24), v22, 1));
        v27 = vsubq_f32(v52, v6);
        v28 = vaddq_s32(vcvtq_s32_f32(v27), vcltzq_f32(v27));
        v27.i64[0] = vsubq_f32(v27, vcvtq_f32_s32(v28)).u64[0];
        v29 = &v55[v28.i32[0] + v28.i32[1] * (int)v56];
        v30 = vaddq_f32(*v29, vmulq_n_f32(vsubq_f32(v29[1], *v29), v27.f32[0]));
        v31 = vaddq_f32(v30, vmulq_lane_f32(vsubq_f32(vaddq_f32(v29[v56], vmulq_n_f32(vsubq_f32(v29[v25], v29[v56]), v27.f32[0])), v30), *(float32x2_t *)v27.f32, 1));
        v32 = vsubq_f32(v53, v6);
        v33 = vaddq_s32(vcvtq_s32_f32(v32), vcltzq_f32(v32));
        v32.i64[0] = vsubq_f32(v32, vcvtq_f32_s32(v33)).u64[0];
        v34 = &v55[v33.i32[0] + v33.i32[1] * (int)v56];
        v35 = vaddq_f32(*v34, vmulq_n_f32(vsubq_f32(v34[1], *v34), v32.f32[0]));
        v36 = vaddq_f32(v35, vmulq_lane_f32(vsubq_f32(vaddq_f32(v34[v56], vmulq_n_f32(vsubq_f32(v34[v25], v34[v56]), v32.f32[0])), v35), *(float32x2_t *)v32.f32, 1));
        v37 = vsubq_f32(v54, v6);
        v38 = vaddq_s32(vcvtq_s32_f32(v37), vcltzq_f32(v37));
        v37.i64[0] = vsubq_f32(v37, vcvtq_f32_s32(v38)).u64[0];
        v39 = &v55[v38.i32[0] + v38.i32[1] * (int)v56];
        v40 = vaddq_f32(*v39, vmulq_n_f32(vsubq_f32(v39[1], *v39), v37.f32[0]));
        v41 = vaddq_f32(v40, vmulq_lane_f32(vsubq_f32(vaddq_f32(v39[v56], vmulq_n_f32(vsubq_f32(v39[v25], v39[v56]), v37.f32[0])), v40), *(float32x2_t *)v37.f32, 1));
      }
      else
      {
        v58 = vaddq_f32(v57, v16);
        v59 = vcvtq_s32_f32(v58);
        v58.i64[0] = vaddq_s32(v59, vcgtq_f32(vcvtq_f32_s32(v59), v58)).u64[0];
        v26 = v55[v58.i32[0] + v58.i32[1] * (int)v56];
        v60 = vaddq_f32(vsubq_f32(v52, v6), v16);
        v61 = vcvtq_s32_f32(v60);
        v60.i64[0] = vaddq_s32(v61, vcgtq_f32(vcvtq_f32_s32(v61), v60)).u64[0];
        v31 = v55[v60.i32[0] + v60.i32[1] * (int)v56];
        v62 = vaddq_f32(vsubq_f32(v53, v6), v16);
        v63 = vcvtq_s32_f32(v62);
        v62.i64[0] = vaddq_s32(v63, vcgtq_f32(vcvtq_f32_s32(v63), v62)).u64[0];
        v36 = v55[v62.i32[0] + v62.i32[1] * (int)v56];
        v64 = vaddq_f32(vsubq_f32(v54, v6), v16);
        v65 = vcvtq_s32_f32(v64);
        v64.i64[0] = vaddq_s32(v65, vcgtq_f32(vcvtq_f32_s32(v65), v64)).u64[0];
        v41 = v55[v64.i32[0] + v64.i32[1] * (int)v56];
      }
      v42 = vaddq_f32(v31, vmulq_lane_f32(vsubq_f32(v12[v19 - 1], v31), *(float32x2_t *)&v11, 1));
      v43 = vaddq_f32(v36, vmulq_lane_f32(vsubq_f32(v12[v19], v36), *(float32x2_t *)&v11, 1));
      v44 = vaddq_f32(v41, vmulq_lane_f32(vsubq_f32(v12[v19 + 1], v41), *(float32x2_t *)&v11, 1));
      v45 = &v9[v19];
      v45[-2] = vaddq_f32(v26, vmulq_lane_f32(vsubq_f32(v12[v19 - 2], v26), *(float32x2_t *)&v11, 1));
      v45[-1] = v42;
      *v45 = v43;
      v45[1] = v44;
      v20 = vaddq_f32(v48, (float32x4_t)xmmword_1B304F230);
      v18 -= 4;
      v19 += 4;
    }
    while (v7 + v18 > 3);
    LODWORD(v66) = -v18;
    if ((int)v66 >= v7)
      goto LABEL_4;
LABEL_14:
    v66 = v66;
    if (v5)
    {
      do
      {
        v67 = *((int *)a2 + 22);
        v68 = vsubq_f32(vaddq_f32(*(float32x4_t *)(*((_QWORD *)this + 51) + 128), vmulq_f32(v20, *(float32x4_t *)(*((_QWORD *)this + 51) + 112))), v6);
        v69 = vaddq_s32(vcvtq_s32_f32(v68), vcltzq_f32(v68));
        v68.i64[0] = vsubq_f32(v68, vcvtq_f32_s32(v69)).u64[0];
        v70 = &a2[10][v69.i32[0] + v69.i32[1] * (int)v67];
        v71 = vaddq_f32(*v70, vmulq_n_f32(vsubq_f32(v70[1], *v70), v68.f32[0]));
        v72 = vaddq_f32(v71, vmulq_lane_f32(vsubq_f32(vaddq_f32(v70[v67], vmulq_n_f32(vsubq_f32(v70[(int)v67 + 1], v70[v67]), v68.f32[0])), v71), *(float32x2_t *)v68.f32, 1));
        v9[v66] = vaddq_f32(v72, vmulq_lane_f32(vsubq_f32(v12[v66], v72), *(float32x2_t *)&v11, 1));
        v20 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
        ++v66;
      }
      while (v66 < v7);
    }
    else
    {
      do
      {
        v73 = vaddq_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)(*((_QWORD *)this + 51) + 128), vmulq_f32(v20, *(float32x4_t *)(*((_QWORD *)this + 51) + 112))), v6), v16);
        v74 = vcvtq_s32_f32(v73);
        v73.i64[0] = vaddq_s32(v74, vcgtq_f32(vcvtq_f32_s32(v74), v73)).u64[0];
        v75 = a2[10][v73.i32[0] + v73.i32[1] * *((_DWORD *)a2 + 22)];
        v9[v66] = vaddq_f32(v75, vmulq_lane_f32(vsubq_f32(v12[v66], v75), *(float32x2_t *)&v11, 1));
        v20 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
        ++v66;
      }
      while (v66 < v7);
    }
    goto LABEL_4;
  }
  return 0;
}

uint64_t HGFractured::GetDOD(HGFractured::Effect **this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  int v8;
  float v9;
  double v10;
  float v11;
  double v12;
  float v13;
  double v14;
  float v15;
  double v16;
  float v17;
  uint64_t v18;
  float v19;
  float v20;
  float v21;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  switch(a3)
  {
    case 2:
      if ((*((uint64_t (**)(HGFractured::Effect **, uint64_t))*this + 16))(this, 2))
        return v5;
      break;
    case 1:
      if (!(*(unsigned int (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2)
        && (*((uint64_t (**)(HGFractured::Effect **, uint64_t))*this + 16))(this, 1))
      {
        return HGFractured::Effect::GetRect(this[53]);
      }
      break;
    case 0:
      if ((*(unsigned int (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2))
      {
        v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
        v8 = HGRectGrow(v5, v4, v7);
        v9 = HGRectFloat(v8);
        v13 = HGRectTranslate(v9, v10, v11, v12, -*((float *)this[51] + 32));
        v17 = HGRectScale(v13, v14, v15, v16, 1.0 / *((float *)this[51] + 28));
        return HGRectIntegral(v18, v17, v19, v20, v21);
      }
      return HGFractured::Effect::GetRect(this[53]);
  }
  return 0;
}

uint64_t HGFractured::GetROI(HGFractured *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  float v7;
  double v8;
  float v9;
  double v10;
  float v11;
  double v12;
  float v13;
  double v14;
  float v15;
  uint64_t v16;
  float v17;
  float v18;
  float v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v4 = *(_QWORD *)&a4.var0;
  if (a3 == 2)
  {
    if ((*(uint64_t (**)(HGFractured *, uint64_t))(*(_QWORD *)this + 128))(this, 2))
      return v4;
    return 0;
  }
  if (a3 != 1)
  {
    if (!a3)
    {
      if ((*(unsigned int (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2))
      {
        v7 = HGRectFloat(v4);
        v11 = HGRectScale(v7, v8, v9, v10, *(float *)(*((_QWORD *)this + 51) + 112));
        v15 = HGRectTranslate(v11, v12, v13, v14, *(float *)(*((_QWORD *)this + 51) + 128));
        v20 = HGRectIntegral(v16, v15, v17, v18, v19);
        v22 = v21;
        v23 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
        return HGRectGrow(v20, v22, v23);
      }
      return HGFractured::Effect::GetImageRect(*((HGFractured::Effect **)this + 53));
    }
    return 0;
  }
  if (!(*(uint64_t (**)(HGFractured *, uint64_t))(*(_QWORD *)this + 128))(this, 1)
    || (*(unsigned int (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2))
  {
    return 0;
  }
  return HGFractured::Effect::GetImageRect(*((HGFractured::Effect **)this + 53));
}

void HGFractured::HGFractured(HGFractured *this)
{
  uint64_t v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v2 = off_1E65314E8;
  *(_DWORD *)(v2 + 416) = 8;
  *(_QWORD *)(v2 + 424) = 0;
  *(_BYTE *)(v2 + 432) = 0;
  *(_DWORD *)(v2 + 436) = 1;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B304F240;
  v3[1] = xmmword_1B3524B50;
  v3[2] = 0u;
  v3[3] = xmmword_1B3051560;
  v3[4] = xmmword_1B30530B0;
  v3[5] = xmmword_1B3524B60;
  v3[6] = xmmword_1B3524B70;
  v3[7] = 0u;
  v3[8] = xmmword_1B3524B80;
  v3[9] = xmmword_1B304F230;
  v3[10] = xmmword_1B304F240;
  v3[11] = xmmword_1B304F250;
  v3[12] = xmmword_1B304EFF0;
  v3[13] = xmmword_1B3050F80;
  v3[14] = 0u;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HGFractured *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 1u;
}

void sub_1B2AFD53C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGFractured::~HGFractured(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E65314E8;
  v2 = *((_QWORD *)this + 53);
  if (v2)
  {
    HGFractured::Effect::SetState(v2, 0);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 53) + 24))(*((_QWORD *)this + 53));
  }
  v3 = *((_QWORD *)this + 51);
  if (v3)
    MEMORY[0x1B5E29170](v3, 0x1000C4019FCA701);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_1E65314E8;
  v2 = *((_QWORD *)this + 53);
  if (v2)
  {
    HGFractured::Effect::SetState(v2, 0);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 53) + 24))(*((_QWORD *)this + 53));
  }
  v3 = *((_QWORD *)this + 51);
  if (v3)
    MEMORY[0x1B5E29170](v3, 0x1000C4019FCA701);
  HGNode::~HGNode(this);
  HGObject::operator delete(v4);
}

uint64_t HGFractured::SetEffect(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    (*(void (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  result = *(_QWORD *)(a1 + 424);
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  *(_QWORD *)(a1 + 424) = a2;
  return result;
}

uint64_t HGFractured::SetLighting(uint64_t this, char a2)
{
  *(_BYTE *)(this + 432) = a2;
  return this;
}

uint64_t HGFractured::SetParameter(HGFractured *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v7;
  uint64_t v9;
  float v10;
  uint64_t v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;

  switch((int)a2)
  {
    case 0:
      v7 = (float *)*((_QWORD *)this + 51);
      if (v7)
        goto LABEL_12;
      return 0xFFFFFFFFLL;
    case 1:
      v9 = *((_QWORD *)this + 51);
      v10 = *(float *)(v9 + 16);
      v7 = (float *)(v9 + 16);
      if (v10 == a3)
        goto LABEL_16;
      goto LABEL_19;
    case 2:
      v11 = *((_QWORD *)this + 51);
      v12 = *(float *)(v11 + 32);
      v7 = (float *)(v11 + 32);
      if (v12 == a3)
        goto LABEL_16;
      goto LABEL_19;
    case 3:
      v13 = *((_QWORD *)this + 51);
      v14 = *(float *)(v13 + 48);
      v7 = (float *)(v13 + 48);
      if (v14 == a3)
        goto LABEL_16;
      goto LABEL_19;
    case 4:
      v7 = (float *)(*((_QWORD *)this + 51) + 64);
      goto LABEL_15;
    case 5:
      v7 = (float *)(*((_QWORD *)this + 51) + 80);
LABEL_12:
      if (*v7 == a3)
        goto LABEL_16;
      goto LABEL_19;
    case 6:
      v7 = (float *)(*((_QWORD *)this + 51) + 96);
LABEL_15:
      v15 = sqrtf((float)((float)(a3 * a3) + (float)(a4 * a4)) + (float)(a5 * a5));
      a3 = a3 / v15;
      a4 = a4 / v15;
      a5 = a5 / v15;
      if (*v7 != a3)
        goto LABEL_19;
LABEL_16:
      if (v7[1] == a4 && v7[2] == a5 && v7[3] == a6)
        return 0;
LABEL_19:
      *v7 = a3;
      v7[1] = a4;
      v7[2] = a5;
      v7[3] = a6;
      *((_DWORD *)this + 109) = 1;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    default:
      return 0xFFFFFFFFLL;
  }
}

uint64_t HGFractured::GetParameter(HGFractured *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 6)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

uint64_t HGFractured::SetMultiSampleLevel(HGFractured *this, int a2)
{
  *((_DWORD *)this + 104) = a2;
  return 1;
}

void soKMeansClassifier::soKMeansClassifier(soKMeansClassifier *this)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t i;
  size_t v5;

  v2 = operator new();
  v3 = 0;
  *(_DWORD *)v2 = 0;
  for (i = 1; i != 624; ++i)
  {
    v3 = i + 1812433253 * (v3 ^ (v3 >> 30));
    *(_DWORD *)(v2 + 4 * i) = v3;
  }
  *(_QWORD *)(v2 + 2496) = 0;
  *(_QWORD *)this = v2;
  *((_BYTE *)this + 16) = 0;
  *((_WORD *)this + 12) = 257;
  *((_BYTE *)this + 26) = 1;
  *(_QWORD *)((char *)this + 28) = 0x3F80000000000000;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_QWORD *)this + 16) = 0;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_DWORD *)this + 9) = 1;
  *((_QWORD *)this + 50) = 0;
  *((_QWORD *)this + 51) = 3;
  v5 = 8;
  *((_QWORD *)this + 1) = 1;
  if (sysctlbyname("hw.physicalcpu", (char *)this + 8, &v5, 0, 0))
    sysctlbyname("hw.ncpu", (char *)this + 8, &v5, 0, 0);
  *((_QWORD *)this + 1) = 1;
}

uint64_t soKMeansClassifier::DeleteStats(soKMeansClassifier *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t result;

  v2 = *((_QWORD *)this + 21);
  if (v2)
  {
    MEMORY[0x1B5E2914C](v2, 0x1000C80451B5BE8);
    *((_QWORD *)this + 21) = 0;
  }
  v3 = *((_QWORD *)this + 22);
  if (v3)
  {
    MEMORY[0x1B5E2914C](v3, 0x1000C80451B5BE8);
    *((_QWORD *)this + 22) = 0;
  }
  v4 = *((_QWORD *)this + 32);
  if (v4)
  {
    MEMORY[0x1B5E2914C](v4, 0x1000C80E0EAB150);
    *((_QWORD *)this + 32) = 0;
  }
  v5 = *((_QWORD *)this + 33);
  if (v5)
  {
    MEMORY[0x1B5E2914C](v5, 0x1000C80E0EAB150);
    *((_QWORD *)this + 33) = 0;
  }
  v6 = *((_QWORD *)this + 34);
  if (v6)
  {
    MEMORY[0x1B5E2914C](v6, 0x1000C80E0EAB150);
    *((_QWORD *)this + 34) = 0;
  }
  v7 = *((_QWORD *)this + 35);
  if (v7)
  {
    MEMORY[0x1B5E2914C](v7, 0x1000C80E0EAB150);
    *((_QWORD *)this + 35) = 0;
  }
  v8 = *((_QWORD *)this + 36);
  if (v8)
  {
    MEMORY[0x1B5E2914C](v8, 0x1000C8000313F17);
    *((_QWORD *)this + 36) = 0;
  }
  v9 = *((_QWORD *)this + 37);
  if (v9)
  {
    MEMORY[0x1B5E2914C](v9, 0x1000C8000313F17);
    *((_QWORD *)this + 37) = 0;
  }
  v10 = *((_QWORD *)this + 38);
  if (v10)
  {
    MEMORY[0x1B5E2914C](v10, 0x1000C80E0EAB150);
    *((_QWORD *)this + 38) = 0;
  }
  v11 = *((_QWORD *)this + 39);
  if (v11)
  {
    MEMORY[0x1B5E2914C](v11, 0x1000C80E0EAB150);
    *((_QWORD *)this + 39) = 0;
  }
  v12 = *((_QWORD *)this + 40);
  if (v12)
  {
    MEMORY[0x1B5E2914C](v12, 0x1000C80E0EAB150);
    *((_QWORD *)this + 40) = 0;
  }
  v13 = *((_QWORD *)this + 41);
  if (v13)
  {
    MEMORY[0x1B5E2914C](v13, 0x1000C80E0EAB150);
    *((_QWORD *)this + 41) = 0;
  }
  v14 = *((_QWORD *)this + 25);
  if (v14)
  {
    MEMORY[0x1B5E2914C](v14, 0x1000C8000313F17);
    *((_QWORD *)this + 25) = 0;
  }
  v15 = *((_QWORD *)this + 26);
  if (v15)
  {
    MEMORY[0x1B5E2914C](v15, 0x1000C8000313F17);
    *((_QWORD *)this + 26) = 0;
  }
  v16 = *((_QWORD *)this + 23);
  if (v16)
  {
    MEMORY[0x1B5E2914C](v16, 0x1000C80565EDBD2);
    *((_QWORD *)this + 23) = 0;
  }
  v17 = *((_QWORD *)this + 24);
  if (v17)
  {
    MEMORY[0x1B5E2914C](v17, 0x1000C80565EDBD2);
    *((_QWORD *)this + 24) = 0;
  }
  v18 = *((_QWORD *)this + 27);
  if (v18)
  {
    MEMORY[0x1B5E2914C](v18, 0x1000C8000313F17);
    *((_QWORD *)this + 27) = 0;
  }
  v19 = *((_QWORD *)this + 28);
  if (v19)
  {
    MEMORY[0x1B5E2914C](v19, 0x1000C8000313F17);
    *((_QWORD *)this + 28) = 0;
  }
  v20 = *((_QWORD *)this + 29);
  if (v20)
  {
    MEMORY[0x1B5E2914C](v20, 0x1000C8000313F17);
    *((_QWORD *)this + 29) = 0;
  }
  v21 = *((_QWORD *)this + 30);
  if (v21)
  {
    MEMORY[0x1B5E2914C](v21, 0x1000C8000313F17);
    *((_QWORD *)this + 30) = 0;
  }
  v22 = *((_QWORD *)this + 44);
  if (v22)
  {
    MEMORY[0x1B5E2914C](v22, 0x1000C8000313F17);
    *((_QWORD *)this + 44) = 0;
  }
  v23 = *((_QWORD *)this + 45);
  if (v23)
  {
    MEMORY[0x1B5E2914C](v23, 0x1000C8000313F17);
    *((_QWORD *)this + 45) = 0;
  }
  v24 = *((_QWORD *)this + 46);
  if (v24)
  {
    MEMORY[0x1B5E2914C](v24, 0x1000C8000313F17);
    *((_QWORD *)this + 46) = 0;
  }
  v25 = *((_QWORD *)this + 47);
  if (v25)
  {
    MEMORY[0x1B5E2914C](v25, 0x1000C8000313F17);
    *((_QWORD *)this + 47) = 0;
  }
  v26 = *((_QWORD *)this + 42);
  if (v26)
  {
    MEMORY[0x1B5E2914C](v26, 0x1000C8000313F17);
    *((_QWORD *)this + 42) = 0;
  }
  v27 = *((_QWORD *)this + 43);
  if (v27)
  {
    MEMORY[0x1B5E2914C](v27, 0x1000C8000313F17);
    *((_QWORD *)this + 43) = 0;
  }
  v28 = *((_QWORD *)this + 48);
  if (v28)
  {
    MEMORY[0x1B5E2914C](v28, 0x1000C8000313F17);
    *((_QWORD *)this + 48) = 0;
  }
  result = *((_QWORD *)this + 49);
  if (result)
  {
    result = MEMORY[0x1B5E2914C](result, 0x1000C8000313F17);
    *((_QWORD *)this + 49) = 0;
  }
  return result;
}

_BYTE *soKMeansClassifier::Init(soKMeansClassifier *this, void *a2, unint64_t *a3, unint64_t a4, int a5)
{
  if (*((_QWORD *)this + 13) * *((_QWORD *)this + 12) < (_QWORD)a3 * (_QWORD)a2
    || *((unsigned __int8 *)this + 16) != a5)
  {
    *((_BYTE *)this + 24) = 1;
    *((_QWORD *)this + 12) = ((unint64_t)a2 + 31) & 0xFFFFFFFFFFFFFFE0;
    *((_QWORD *)this + 13) = ((unint64_t)a3 + 31) & 0xFFFFFFFFFFFFFFE0;
  }
  if (*((_QWORD *)this + 20) < a4 || *((unsigned __int8 *)this + 16) != a5)
    *((_BYTE *)this + 25) = 1;
  *((_QWORD *)this + 10) = a2;
  *((_QWORD *)this + 11) = a3;
  *((_QWORD *)this + 14) = (_QWORD)a3 * (_QWORD)a2;
  *((_QWORD *)this + 20) = a4;
  *((_BYTE *)this + 16) = a5;
  soKMeansClassifier::AllocateBuffers((uint64_t)this, a2, a3);
  return soKMeansClassifier::AllocateStats(this);
}

uint64_t soKMeansClassifier::AllocateBuffers(uint64_t this, void *a2, unint64_t *a3)
{
  uint64_t v3;
  HGMemory *v4;
  HGMemory *v5;
  HGMemory *v6;
  HGMemory *v7;
  HGMemory *v8;
  unint64_t *v9;
  unint64_t *v10;
  unint64_t *v11;
  unint64_t *v12;

  if (*(_BYTE *)(this + 24))
  {
    v3 = this;
    v4 = *(HGMemory **)(this + 152);
    if (v4)
    {
      HGMemory::release(v4, a2);
      *(_QWORD *)(v3 + 152) = 0;
    }
    v5 = *(HGMemory **)(v3 + 48);
    if (v5)
    {
      HGMemory::release(v5, a2);
      *(_QWORD *)(v3 + 48) = 0;
    }
    v6 = *(HGMemory **)(v3 + 400);
    if (v6)
    {
      HGMemory::release(v6, a2);
      *(_QWORD *)(v3 + 400) = 0;
    }
    v7 = *(HGMemory **)(v3 + 56);
    if (v7)
    {
      HGMemory::release(v7, a2);
      *(_QWORD *)(v3 + 56) = 0;
    }
    v8 = *(HGMemory **)(v3 + 64);
    if (v8)
    {
      HGMemory::release(v8, a2);
      *(_QWORD *)(v3 + 64) = 0;
    }
    *(_QWORD *)(v3 + 152) = HGMemory::allocate((HGMemory *)(16 * *(_QWORD *)(v3 + 96) * *(_QWORD *)(v3 + 104)), 0, a3);
    *(_QWORD *)(v3 + 56) = HGMemory::allocate((HGMemory *)(*(_QWORD *)(v3 + 104) * *(_QWORD *)(v3 + 96)), 0, v9);
    this = HGMemory::allocate((HGMemory *)(12 * *(_QWORD *)(v3 + 96) * *(_QWORD *)(v3 + 104)), 0, v10);
    *(_QWORD *)(v3 + 400) = this;
    if (*(_BYTE *)(v3 + 16))
    {
      *(_QWORD *)(v3 + 48) = HGMemory::allocate((HGMemory *)(*(_QWORD *)(v3 + 104) * *(_QWORD *)(v3 + 96)), 0, v11);
      this = HGMemory::allocate((HGMemory *)(*(_QWORD *)(v3 + 104) * *(_QWORD *)(v3 + 96)), 0, v12);
      *(_QWORD *)(v3 + 64) = this;
    }
    *(_BYTE *)(v3 + 24) = 0;
  }
  return this;
}

_BYTE *soKMeansClassifier::AllocateStats(_BYTE *this)
{
  _BYTE *v1;
  unint64_t v2;
  void *v3;
  void *v4;
  unint64_t v5;
  void *v6;
  void *v7;

  if (this[25])
  {
    v1 = this;
    soKMeansClassifier::DeleteStats((soKMeansClassifier *)this);
    *((_QWORD *)v1 + 48) = operator new[]();
    *((_QWORD *)v1 + 21) = operator new[]();
    *((_QWORD *)v1 + 32) = operator new[]();
    *((_QWORD *)v1 + 34) = operator new[]();
    *((_QWORD *)v1 + 36) = operator new[]();
    *((_QWORD *)v1 + 38) = operator new[]();
    *((_QWORD *)v1 + 40) = operator new[]();
    *((_QWORD *)v1 + 25) = operator new[]();
    *((_QWORD *)v1 + 27) = operator new[]();
    *((_QWORD *)v1 + 29) = operator new[]();
    v2 = *((_QWORD *)v1 + 20);
    is_mul_ok(v2, 0x60uLL);
    v3 = (void *)operator new[]();
    v4 = v3;
    if (v2)
      bzero(v3, 96 * ((96 * v2 - 96) / 0x60) + 96);
    *((_QWORD *)v1 + 23) = v4;
    *((_QWORD *)v1 + 42) = operator new[]();
    *((_QWORD *)v1 + 44) = operator new[]();
    this = (_BYTE *)operator new[]();
    *((_QWORD *)v1 + 46) = this;
    if (v1[16])
    {
      *((_QWORD *)v1 + 49) = operator new[]();
      *((_QWORD *)v1 + 22) = operator new[]();
      *((_QWORD *)v1 + 33) = operator new[]();
      *((_QWORD *)v1 + 35) = operator new[]();
      *((_QWORD *)v1 + 37) = operator new[]();
      *((_QWORD *)v1 + 39) = operator new[]();
      *((_QWORD *)v1 + 41) = operator new[]();
      *((_QWORD *)v1 + 26) = operator new[]();
      *((_QWORD *)v1 + 28) = operator new[]();
      *((_QWORD *)v1 + 30) = operator new[]();
      v5 = *((_QWORD *)v1 + 20);
      is_mul_ok(v5, 0x60uLL);
      v6 = (void *)operator new[]();
      v7 = v6;
      if (v5)
        bzero(v6, 96 * ((96 * v5 - 96) / 0x60) + 96);
      *((_QWORD *)v1 + 24) = v7;
      *((_QWORD *)v1 + 43) = operator new[]();
      *((_QWORD *)v1 + 45) = operator new[]();
      this = (_BYTE *)operator new[]();
      *((_QWORD *)v1 + 47) = this;
    }
    v1[25] = 0;
  }
  return this;
}

_QWORD *soKMeansClassifier::LoadBuffer(_QWORD *this, unsigned __int8 *a2, uint64_t a3, double a4, double a5, __n128 a6)
{
  unint64_t v6;
  unint64_t v7;
  int8x16_t v8;
  float32x4_t v9;

  this[5] = a2;
  this[15] = a3;
  v6 = this[10];
  if (v6 * this[11])
  {
    v7 = 0;
    v8 = (int8x16_t)vdupq_n_s32(0x4B400000u);
    v9 = (float32x4_t)vdupq_n_s32(0xCB400000);
    do
    {
      a6.n128_u32[0] = *(_DWORD *)(this[5] + this[15] * (v7 / v6) + 4 * (v7 % v6));
      a6 = (__n128)vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8((uint8x8_t)a6.n128_u64[0])), v8), v9);
      *(__n128 *)(this[19] + 16 * v7++) = a6;
      v6 = this[10];
    }
    while (v6 * this[11] > v7);
  }
  return this;
}

void *soKMeansClassifier::LoadMask(void *result, uint64_t a2, uint64_t a3, int *a4)
{
  _QWORD *v5;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  size_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int8x16_t v15;
  int8x16_t v16;
  unint64_t v17;
  int64x2_t v18;
  int64x2_t v19;
  int64x2_t v20;
  int8x8_t *v21;
  unint64_t v22;
  int64x2_t v23;
  int64x2_t v24;
  int64x2_t v25;
  int64x2_t v26;
  int64x2_t v27;
  int8x8_t v28;
  uint16x8_t v29;
  uint32x4_t v30;
  int8x16_t v31;
  int64x2_t v32;
  int64x2_t v33;
  uint32x4_t v34;
  int64x2_t v35;
  uint16x8_t v36;
  uint32x4_t v37;
  int64x2_t v38;
  int64x2_t v39;
  uint32x4_t v40;
  int64x2_t v41;
  int64x2_t v42;
  int64x2_t v43;
  int64x2_t v44;
  int8x16_t *v45;
  unint64_t v46;
  int64x2_t v47;
  int64x2_t v48;
  int64x2_t v49;
  int64x2_t v50;
  int64x2_t v51;
  int64x2_t v52;
  int64x2_t v53;
  int64x2_t v54;
  int64x2_t v55;
  int64x2_t v56;
  int64x2_t v57;
  int64x2_t v58;
  int64x2_t v59;
  int8x16_t v60;
  uint8x16_t v61;
  uint16x8_t v62;
  uint32x4_t v63;
  int8x16_t v64;
  int8x16_t v65;
  int64x2_t v66;
  int64x2_t v67;
  uint32x4_t v68;
  int64x2_t v69;
  uint16x8_t v70;
  uint32x4_t v71;
  int64x2_t v72;
  int64x2_t v73;
  int64x2_t v74;
  uint32x4_t v75;
  int64x2_t v76;
  uint8x16_t v77;
  uint16x8_t v78;
  uint32x4_t v79;
  int64x2_t v80;
  int64x2_t v81;
  uint32x4_t v82;
  int64x2_t v83;
  uint16x8_t v84;
  uint32x4_t v85;
  int64x2_t v86;
  int64x2_t v87;
  int64x2_t v88;
  uint32x4_t v89;
  int64x2_t v90;
  unsigned __int8 *v91;
  unint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  int v96;
  int v97;
  int64x2_t v98;

  *((_DWORD *)result + 5) = 0;
  if (*((_BYTE *)result + 16))
  {
    v5 = result;
    if (*((_QWORD *)result + 11))
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = *((_QWORD *)result + 10);
      v98 = vdupq_n_s64(1uLL);
      while (1)
      {
        result = memcpy((void *)(v5[6] + v8 * v11), (const void *)(a2 + v8 * a3), v11);
        v12 = v5[10];
        if (v12)
        {
          v13 = v5[6];
          if (v12 < 8)
          {
            v14 = 0;
LABEL_18:
            v91 = (unsigned __int8 *)(v13 + v14 + v12 * v8);
            v92 = v12 - v14;
            do
            {
              v94 = *v91++;
              v93 = v94;
              if (v94 == 255)
                ++v10;
              if (!v93)
                ++v9;
              --v92;
            }
            while (v92);
            goto LABEL_4;
          }
          v15.i64[0] = -1;
          v15.i64[1] = -1;
          if (v12 >= 0x10)
          {
            v14 = v12 & 0xFFFFFFFFFFFFFFF0;
            v42 = 0uLL;
            v43 = (int64x2_t)v9;
            v44 = (int64x2_t)v10;
            v45 = (int8x16_t *)(v13 + v12 * v8);
            v46 = v12 & 0xFFFFFFFFFFFFFFF0;
            v47 = 0uLL;
            v48 = 0uLL;
            v49 = 0uLL;
            v50 = 0uLL;
            v51 = 0uLL;
            v52 = 0uLL;
            v53 = 0uLL;
            v54 = 0uLL;
            v55 = 0uLL;
            v56 = 0uLL;
            v57 = 0uLL;
            v58 = 0uLL;
            v59 = 0uLL;
            do
            {
              v60 = *v45++;
              v61 = (uint8x16_t)vceqq_s8(v60, v15);
              v62 = vmovl_u8(*(uint8x8_t *)v61.i8);
              v63 = vmovl_u16(*(uint16x4_t *)v62.i8);
              v64 = (int8x16_t)vdupq_n_s64(1uLL);
              v65.i64[0] = v63.u32[0];
              v65.i64[1] = v63.u32[1];
              v66 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v63.u32[2];
              v65.i64[1] = v63.u32[3];
              v67 = (int64x2_t)vandq_s8(v65, v64);
              v68 = vmovl_high_u16(v62);
              v65.i64[0] = v68.u32[0];
              v65.i64[1] = v68.u32[1];
              v69 = (int64x2_t)vandq_s8(v65, v64);
              v70 = vmovl_high_u8(v61);
              v71 = vmovl_u16(*(uint16x4_t *)v70.i8);
              v65.i64[0] = v71.u32[0];
              v65.i64[1] = v71.u32[1];
              v72 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v68.u32[2];
              v65.i64[1] = v68.u32[3];
              v73 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v71.u32[2];
              v65.i64[1] = v71.u32[3];
              v74 = (int64x2_t)vandq_s8(v65, v64);
              v75 = vmovl_high_u16(v70);
              v65.i64[0] = v75.u32[0];
              v65.i64[1] = v75.u32[1];
              v76 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v75.u32[2];
              v65.i64[1] = v75.u32[3];
              v59 = vaddq_s64(v59, (int64x2_t)vandq_s8(v65, v64));
              v58 = vaddq_s64(v58, v76);
              v57 = vaddq_s64(v57, v74);
              v55 = vaddq_s64(v55, v73);
              v56 = vaddq_s64(v56, v72);
              v54 = vaddq_s64(v54, v69);
              v53 = vaddq_s64(v53, v67);
              v44 = vaddq_s64(v44, v66);
              v77 = (uint8x16_t)vceqzq_s8(v60);
              v78 = vmovl_u8(*(uint8x8_t *)v77.i8);
              v79 = vmovl_u16(*(uint16x4_t *)v78.i8);
              v65.i64[0] = v79.u32[0];
              v65.i64[1] = v79.u32[1];
              v80 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v79.u32[2];
              v65.i64[1] = v79.u32[3];
              v81 = (int64x2_t)vandq_s8(v65, v64);
              v82 = vmovl_high_u16(v78);
              v65.i64[0] = v82.u32[0];
              v65.i64[1] = v82.u32[1];
              v83 = (int64x2_t)vandq_s8(v65, v64);
              v84 = vmovl_high_u8(v77);
              v85 = vmovl_u16(*(uint16x4_t *)v84.i8);
              v65.i64[0] = v85.u32[0];
              v65.i64[1] = v85.u32[1];
              v86 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v82.u32[2];
              v65.i64[1] = v82.u32[3];
              v87 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v85.u32[2];
              v65.i64[1] = v85.u32[3];
              v88 = (int64x2_t)vandq_s8(v65, v64);
              v89 = vmovl_high_u16(v84);
              v65.i64[0] = v89.u32[0];
              v65.i64[1] = v89.u32[1];
              v90 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v89.u32[2];
              v65.i64[1] = v89.u32[3];
              v52 = vaddq_s64(v52, (int64x2_t)vandq_s8(v65, v64));
              v51 = vaddq_s64(v51, v90);
              v50 = vaddq_s64(v50, v88);
              v48 = vaddq_s64(v48, v87);
              v49 = vaddq_s64(v49, v86);
              v47 = vaddq_s64(v47, v83);
              v42 = vaddq_s64(v42, v81);
              v43 = vaddq_s64(v43, v80);
              v46 -= 16;
            }
            while (v46);
            v10 = vaddvq_s64(vaddq_s64(vaddq_s64(vaddq_s64(v44, v56), vaddq_s64(v54, v58)), vaddq_s64(vaddq_s64(v53, v57), vaddq_s64(v55, v59))));
            v9 = vaddvq_s64(vaddq_s64(vaddq_s64(vaddq_s64(v43, v49), vaddq_s64(v47, v51)), vaddq_s64(vaddq_s64(v42, v50), vaddq_s64(v48, v52))));
            if (v12 == v14)
              goto LABEL_4;
            v16 = (int8x16_t)v98;
            if ((v12 & 8) == 0)
              goto LABEL_18;
          }
          else
          {
            v14 = 0;
            v16 = (int8x16_t)v98;
          }
          v17 = v14;
          v14 = v12 & 0xFFFFFFFFFFFFFFF8;
          v18 = (int64x2_t)v9;
          v19 = 0uLL;
          v20 = (int64x2_t)v10;
          v21 = (int8x8_t *)(v13 + v17 + v12 * v8);
          v22 = v17 - (v12 & 0xFFFFFFFFFFFFFFF8);
          v23 = 0uLL;
          v24 = 0uLL;
          v25 = 0uLL;
          v26 = 0uLL;
          v27 = 0uLL;
          do
          {
            v28 = *v21++;
            v29 = vmovl_u8((uint8x8_t)vceq_s8(v28, (int8x8_t)-1));
            v30 = vmovl_u16(*(uint16x4_t *)v29.i8);
            v31.i64[0] = v30.u32[0];
            v31.i64[1] = v30.u32[1];
            v32 = (int64x2_t)vandq_s8(v31, v16);
            v31.i64[0] = v30.u32[2];
            v31.i64[1] = v30.u32[3];
            v33 = (int64x2_t)vandq_s8(v31, v16);
            v34 = vmovl_high_u16(v29);
            v31.i64[0] = v34.u32[0];
            v31.i64[1] = v34.u32[1];
            v35 = (int64x2_t)vandq_s8(v31, v16);
            v31.i64[0] = v34.u32[2];
            v31.i64[1] = v34.u32[3];
            v27 = vaddq_s64(v27, (int64x2_t)vandq_s8(v31, v16));
            v26 = vaddq_s64(v26, v35);
            v25 = vaddq_s64(v25, v33);
            v20 = vaddq_s64(v20, v32);
            v36 = vmovl_u8((uint8x8_t)vceqz_s8(v28));
            v37 = vmovl_u16(*(uint16x4_t *)v36.i8);
            v31.i64[0] = v37.u32[0];
            v31.i64[1] = v37.u32[1];
            v38 = (int64x2_t)vandq_s8(v31, v16);
            v31.i64[0] = v37.u32[2];
            v31.i64[1] = v37.u32[3];
            v39 = (int64x2_t)vandq_s8(v31, v16);
            v40 = vmovl_high_u16(v36);
            v31.i64[0] = v40.u32[0];
            v31.i64[1] = v40.u32[1];
            v41 = (int64x2_t)vandq_s8(v31, v16);
            v31.i64[0] = v40.u32[2];
            v31.i64[1] = v40.u32[3];
            v24 = vaddq_s64(v24, (int64x2_t)vandq_s8(v31, v16));
            v23 = vaddq_s64(v23, v41);
            v19 = vaddq_s64(v19, v39);
            v18 = vaddq_s64(v18, v38);
            v22 += 8;
          }
          while (v22);
          v10 = vaddvq_s64(vaddq_s64(vaddq_s64(v20, v26), vaddq_s64(v25, v27)));
          v9 = vaddvq_s64(vaddq_s64(vaddq_s64(v18, v23), vaddq_s64(v19, v24)));
          if (v12 != v14)
            goto LABEL_18;
        }
LABEL_4:
        if (v5[11] <= (unint64_t)++v8)
          goto LABEL_26;
      }
    }
    v10 = 0;
    v9 = 0;
LABEL_26:
    v95 = 10 * v5[20];
    if (v10 < v95)
      v96 = 1;
    else
      v96 = 3;
    if (v9 >= v95)
      v97 = v96;
    else
      v97 = 2;
    *((_DWORD *)v5 + 5) = v97;
    *a4 = v97;
  }
  return result;
}

uint64_t GenLLHMap(_QWORD *a1)
{
  unint64_t v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  double v21;
  unint64_t v22;
  double v23;
  float32x4_t v24;
  float64x2_t v25;
  float64x2_t v26;
  float64x2_t *v27;
  unint64_t v28;
  double v29;
  float32x4_t v30;
  float64x2_t v31;
  float64x2_t v32;
  float64x2_t *v33;
  long double v34;
  float v35;
  float v36;
  uint64_t v37;
  double v38;
  double v39;
  uint64_t v41;
  uint64_t v42;
  double v43;
  double v44;
  float v45;
  float v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  double v52;
  float32x4_t v53;
  float64x2_t v54;
  float64x2_t v55;
  float64x2_t *v56;
  unint64_t v57;
  double v58;
  float32x4_t v59;
  float64x2_t v60;
  float64x2_t v61;
  float64x2_t *v62;
  size_t v63;
  char *v64;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  float32x4_t v78;
  float32x4_t v79;

  v1 = a1[1];
  v69 = a1[2];
  v2 = v69 - v1;
  if (v69 > v1)
  {
    v3 = *a1;
    v4 = *(_QWORD *)(*a1 + 80);
    if (v4)
    {
      v68 = *(_QWORD *)(v3 + 72);
      v70 = *(_QWORD *)(v3 + 128);
      v77 = *(_QWORD *)(*a1 + 80);
      if (*(_BYTE *)(v3 + 26))
      {
        v67 = *(_QWORD *)(v3 + 48);
        __asm { FMOV            V9.2S, #-1.0 }
        while (1)
        {
          v10 = 0;
          v11 = v68 + v70 * v1;
          v71 = v1;
          v73 = v4 * v1;
          v12 = v67 + v4 * v1;
          v75 = v12;
          do
          {
            v14 = *(unsigned __int8 *)(v12 + v10);
            *(_QWORD *)v11 = _D9;
            if (v14 == 255)
            {
              *(_DWORD *)v11 = *(_DWORD *)(v3 + 32);
              v13 = *(float *)(v3 + 28);
LABEL_8:
              *(float *)(v11 + 4) = v13;
              goto LABEL_9;
            }
            if (!v14)
            {
              *(_DWORD *)v11 = *(_DWORD *)(v3 + 28);
              v13 = *(float *)(v3 + 32);
              goto LABEL_8;
            }
            if (*(_BYTE *)(v3 + 16))
            {
              v15 = *(_QWORD *)(v3 + 160);
              if (v15)
              {
                v16 = 0;
                v17 = 0;
                v78 = *(float32x4_t *)(*(_QWORD *)(v3 + 152) + 16 * v73 + 16 * v10);
                v18 = *(_QWORD *)(v3 + 352);
                v19 = *(_QWORD *)(v3 + 360);
                v20 = 0.0;
                v21 = 0.0;
                do
                {
                  v22 = *(_QWORD *)(v18 + 8 * v17);
                  v23 = 0.0;
                  if (v22 >= 0xA)
                  {
                    v24 = vsubq_f32(v78, *(float32x4_t *)(*(_QWORD *)(v3 + 168) + 16 * v17));
                    v25 = vcvt_hight_f64_f32(v24);
                    v26 = vcvtq_f64_f32(*(float32x2_t *)v24.f32);
                    v27 = (float64x2_t *)(*(_QWORD *)(v3 + 184) + v16);
                    v23 = *(double *)(*(_QWORD *)(v3 + 216) + 8 * v17)
                        * exp((vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v27[1], v26), v27[3], v26, 1), v25, v27[5]), v25).f64[0]+ vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*v27, v26.f64[0]), v27[2], v26, 1), v27[4], v25.f64[0]), v26)))* -0.5);
                  }
                  v28 = *(_QWORD *)(v19 + 8 * v17);
                  v29 = 0.0;
                  if (v28 >= 0xA)
                  {
                    v30 = vsubq_f32(v78, *(float32x4_t *)(*(_QWORD *)(v3 + 176) + 16 * v17));
                    v31 = vcvt_hight_f64_f32(v30);
                    v32 = vcvtq_f64_f32(*(float32x2_t *)v30.f32);
                    v33 = (float64x2_t *)(*(_QWORD *)(v3 + 192) + v16);
                    v29 = *(double *)(*(_QWORD *)(v3 + 224) + 8 * v17)
                        * exp((vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v33[1], v32), v33[3], v32, 1), v31, v33[5]), v31).f64[0]+ vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*v33, v32.f64[0]), v33[2], v32, 1), v33[4], v31.f64[0]), v32)))* -0.5);
                  }
                  v21 = v21 + v23 * (double)v22;
                  v20 = v20 + v29 * (double)v28;
                  ++v17;
                  v16 += 96;
                }
                while (v15 != v17);
              }
              else
              {
                v21 = 0.0;
                v20 = 0.0;
              }
              v34 = v20 / (double)*(unint64_t *)(v3 + 144);
              v35 = log(v21 / (double)*(unint64_t *)(v3 + 136));
              *(float *)v11 = -v35;
              v36 = log(v34);
              v13 = -v36;
              v12 = v75;
              v4 = v77;
              goto LABEL_8;
            }
LABEL_9:
            v11 += 8;
            ++v10;
          }
          while (v10 != v4);
          v1 = v71 + 1;
          if (v71 + 1 == v69)
            goto LABEL_38;
        }
      }
      if (*(_BYTE *)(v3 + 16))
      {
        v37 = *(_QWORD *)(v3 + 160);
        v74 = *(_QWORD *)(v3 + 152);
        v38 = (double)*(unint64_t *)(v3 + 136);
        v39 = (double)*(unint64_t *)(v3 + 144);
        __asm { FMOV            V11.2S, #-1.0 }
        do
        {
          v41 = 0;
          v42 = v68 + v70 * v1;
          v72 = v1;
          v76 = v74 + 16 * v4 * v1;
          do
          {
            *(_QWORD *)v42 = _D11;
            if (v37)
            {
              v47 = 0;
              v48 = 0;
              v79 = *(float32x4_t *)(v76 + 16 * v41);
              v44 = 0.0;
              v43 = 0.0;
              v50 = *(_QWORD *)(v3 + 352);
              v49 = *(_QWORD *)(v3 + 360);
              do
              {
                v51 = *(_QWORD *)(v50 + 8 * v48);
                v52 = 0.0;
                if (v51 >= 0xA)
                {
                  v53 = vsubq_f32(v79, *(float32x4_t *)(*(_QWORD *)(v3 + 168) + 16 * v48));
                  v54 = vcvt_hight_f64_f32(v53);
                  v55 = vcvtq_f64_f32(*(float32x2_t *)v53.f32);
                  v56 = (float64x2_t *)(*(_QWORD *)(v3 + 184) + v47);
                  v52 = *(double *)(*(_QWORD *)(v3 + 216) + 8 * v48)
                      * exp((vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v56[1], v55), v56[3], v55, 1), v54, v56[5]), v54).f64[0]+ vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*v56, v55.f64[0]), v56[2], v55, 1), v56[4], v54.f64[0]), v55)))* -0.5);
                }
                v57 = *(_QWORD *)(v49 + 8 * v48);
                v58 = 0.0;
                if (v57 >= 0xA)
                {
                  v59 = vsubq_f32(v79, *(float32x4_t *)(*(_QWORD *)(v3 + 176) + 16 * v48));
                  v60 = vcvt_hight_f64_f32(v59);
                  v61 = vcvtq_f64_f32(*(float32x2_t *)v59.f32);
                  v62 = (float64x2_t *)(*(_QWORD *)(v3 + 192) + v47);
                  v58 = *(double *)(*(_QWORD *)(v3 + 224) + 8 * v48)
                      * exp((vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v62[1], v61), v62[3], v61, 1), v60, v62[5]), v60).f64[0]+ vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*v62, v61.f64[0]), v62[2], v61, 1), v62[4], v60.f64[0]), v61)))* -0.5);
                }
                v43 = v43 + v52 * (double)v51;
                v44 = v44 + v58 * (double)v57;
                ++v48;
                v47 += 96;
              }
              while (v37 != v48);
            }
            else
            {
              v43 = 0.0;
              v44 = 0.0;
            }
            v45 = log(v43 / v38);
            *(float *)v42 = -v45;
            v46 = log(v44 / v39);
            *(float *)(v42 + 4) = -v46;
            v42 += 8;
            ++v41;
            v4 = v77;
          }
          while (v41 != v77);
          v1 = v72 + 1;
        }
        while (v72 + 1 != v69);
      }
      else
      {
        v63 = 8 * v4;
        v64 = (char *)(v68 + v1 * v70);
        do
        {
          memset_pattern16(v64, &unk_1B3524BC0, v63);
          v64 += v70;
          --v2;
        }
        while (v2);
      }
    }
  }
LABEL_38:
  MEMORY[0x1B5E29170](a1, 0x1020C4024DAA5DELL);
  return 0;
}

uint64_t soKMeansClassifier::GenLikelihoodMap(soKMeansClassifier *this, float *a2, uint64_t a3, char a4, float a5, float a6)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  pthread_t *v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  if (!*((_BYTE *)this + 16))
    return 0xFFFFFFFFLL;
  *((_BYTE *)this + 26) = a4;
  *((float *)this + 7) = a5;
  *((float *)this + 8) = a6;
  *((_QWORD *)this + 9) = a2;
  *((_QWORD *)this + 16) = a3;
  if (*((_QWORD *)this + 1) < 2uLL)
  {
    v17 = (_QWORD *)operator new();
    v18 = *((_QWORD *)this + 11);
    *v17 = this;
    v17[1] = 0;
    v17[2] = v18;
    GenLLHMap(v17);
  }
  else
  {
    v7 = operator new[]();
    v8 = v7;
    v9 = *((_QWORD *)this + 1);
    v10 = *((_QWORD *)this + 11) / v9;
    if (v9 >= 2)
    {
      v11 = 0;
      v12 = (pthread_t *)(v7 + 8);
      v13 = 1;
      v14 = *((_QWORD *)this + 11) / v9;
      do
      {
        if (v13 == v9 - 1)
          v14 = *((_QWORD *)this + 11);
        else
          v14 += v10;
        v11 += v10;
        v15 = (_QWORD *)operator new();
        *v15 = this;
        v15[1] = v11;
        v15[2] = v14;
        pthread_create(v12, 0, (void *(__cdecl *)(void *))GenLLHMap, v15);
        ++v13;
        v9 = *((_QWORD *)this + 1);
        ++v12;
      }
      while (v9 > v13);
    }
    v19 = (_QWORD *)operator new();
    *v19 = this;
    v19[1] = 0;
    v19[2] = v10;
    GenLLHMap(v19);
    if (*((_QWORD *)this + 1) >= 2uLL)
    {
      v20 = 1;
      do
        pthread_join(*(pthread_t *)(v8 + 8 * v20++), 0);
      while (*((_QWORD *)this + 1) > v20);
    }
    MEMORY[0x1B5E2914C](v8, 0x20C8093837F09);
  }
  return 0;
}

double soKMeansClassifier::InitClusterMeans(soKMeansClassifier *this, __n128 inited)
{
  uint64_t v2;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  __n128 v8;
  int v9;
  int v11;
  int v12;

  v2 = *((_QWORD *)this + 10);
  if (v2)
  {
    v4 = *((_QWORD *)this + 11);
    if (v4)
    {
      v5 = v4 * v2 - 1;
      if (*((_BYTE *)this + 16))
      {
        do
        {
          v11 = 0;
          v12 = v5;
          v6 = std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>((uint64_t)&v11, *(_QWORD *)this, &v11);
        }
        while (*(_BYTE *)(*((_QWORD *)this + 6) + v6));
        **((_QWORD **)this + 48) = v6;
        do
        {
          v11 = 0;
          v12 = v5;
          v7 = std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>((uint64_t)&v11, *(_QWORD *)this, &v11);
        }
        while (*(unsigned __int8 *)(*((_QWORD *)this + 6) + v7) != 255);
        **((_QWORD **)this + 49) = v7;
        *(_OWORD *)*((_QWORD *)this + 22) = *(_OWORD *)(*((_QWORD *)this + 19) + 16 * v7);
        v8 = *(__n128 *)(*((_QWORD *)this + 19) + 16 * **((_QWORD **)this + 48));
        *(__n128 *)*((_QWORD *)this + 21) = v8;
        if (*((_DWORD *)this + 9))
          goto LABEL_8;
      }
      else
      {
        v11 = 0;
        v12 = v4 * v2 - 1;
        v9 = std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>((uint64_t)&v11, *(_QWORD *)this, &v11);
        **((_QWORD **)this + 48) = v9;
        v8 = *(__n128 *)(*((_QWORD *)this + 19) + 16 * v9);
        *(__n128 *)*((_QWORD *)this + 21) = v8;
        if (*((_DWORD *)this + 9))
        {
LABEL_8:
          soKMeansClassifier::InitClusterMeans_PP(this);
          return inited.n128_f64[0];
        }
      }
      inited = soKMeansClassifier::InitClusterMeans_Random(this, 0, v8);
      if (*((_BYTE *)this + 16))
        inited.n128_u64[0] = soKMeansClassifier::InitClusterMeans_Random(this, 1, inited).n128_u64[0];
    }
  }
  return inited.n128_f64[0];
}

__n128 soKMeansClassifier::InitClusterMeans_Random(soKMeansClassifier *this, int a2, __n128 result)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unsigned __int8 *v14;
  unint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unsigned int v21;
  unsigned int v22;
  unint64_t v23;
  unint64_t v24;
  unsigned int v25;
  unsigned int v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float v30;
  float v31;
  char v32;
  uint64_t v33;
  float *v34;
  BOOL v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unsigned int v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  char v56;
  uint64_t v57;
  float *v58;
  BOOL v59;
  int v60;

  v3 = *((_QWORD *)this + 10);
  if (v3)
  {
    v4 = *((_QWORD *)this + 11);
    if (v4)
    {
      if (a2)
        v5 = 255;
      else
        v5 = 0;
      v6 = 392;
      if (!a2)
        v6 = 384;
      if (*((_QWORD *)this + 20) >= 2uLL)
      {
        v7 = v4 * v3;
        v8 = *(_QWORD *)((char *)this + v6);
        v9 = __clz(v7);
        v10 = 31;
        if (((v7 << v9) & 0x7FFFFFFF) != 0)
          v10 = 32;
        v11 = v10 - v9;
        v12 = v11 >> 5;
        if ((v11 & 0x1F) != 0)
          ++v12;
        if (*((_BYTE *)this + 16))
        {
          v13 = *(_QWORD *)this;
          v14 = (unsigned __int8 *)*((_QWORD *)this + 6);
          v15 = 1;
          while (1)
          {
LABEL_16:
            if (v7 == 1)
            {
              if (v5 != *v14)
              {
                while (1)
                  ;
              }
              v16 = 0;
            }
            else if (v7)
            {
              if (v12 <= v11)
                v17 = 0xFFFFFFFF >> -(v11 / v12);
              else
                v17 = 0;
              v18 = *(_QWORD *)(v13 + 2496);
              do
              {
                do
                {
                  v19 = 4 * v18;
                  v20 = v18 + 397;
                  v18 = (v18 + 1) % 0x270;
                  v21 = *(_DWORD *)(v13 + 4 * (v20 % 0x270)) ^ ((*(_DWORD *)(v13 + 4 * v18) & 0x7FFFFFFE | *(_DWORD *)(v13 + v19) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(v13 + 4 * v18) << 31) >> 31) & 0x9908B0DF;
                  *(_DWORD *)(v13 + v19) = v21;
                  v22 = ((v21 ^ (v21 >> 11)) << 7) & 0x9D2C5680 ^ v21 ^ (v21 >> 11);
                  LODWORD(v16) = ((v22 << 15) & 0xEFC60000 ^ v22 ^ (((v22 << 15) & 0xEFC60000 ^ v22) >> 18)) & v17;
                }
                while (v16 >= v7);
                *(_QWORD *)(v13 + 2496) = v18;
                v16 = (int)v16;
              }
              while (v5 != v14[(int)v16]);
            }
            else
            {
              v23 = *(_QWORD *)(v13 + 2496);
              do
              {
                v24 = (v23 + 1) % 0x270;
                v25 = *(_DWORD *)(v13 + 4 * ((v23 + 397) % 0x270)) ^ ((*(_DWORD *)(v13 + 4 * v24) & 0x7FFFFFFE | *(_DWORD *)(v13 + 4 * v23) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(v13 + 4 * v24) << 31) >> 31) & 0x9908B0DF;
                *(_DWORD *)(v13 + 4 * v23) = v25;
                *(_QWORD *)(v13 + 2496) = v24;
                v26 = ((v25 ^ (v25 >> 11)) << 7) & 0x9D2C5680 ^ v25 ^ (v25 >> 11);
                v16 = (int)((v26 << 15) & 0xEFC60000 ^ v26 ^ (((v26 << 15) & 0xEFC60000 ^ v26) >> 18));
                v23 = v24;
              }
              while (v5 != v14[v16]);
            }
            v27 = 0;
            v28 = *((_QWORD *)this + 19);
            v29 = v28 + 16 * v15;
            result.n128_u32[0] = *(_DWORD *)v29;
            v30 = *(float *)(v29 + 4);
            v31 = *(float *)(v29 + 8);
            v32 = 1;
            do
            {
              v33 = *(_QWORD *)(v8 + 8 * v27);
              if (v33 == v16)
                goto LABEL_16;
              v34 = (float *)(v28 + 16 * v33);
              v35 = result.n128_f32[0] == *v34;
              if (v30 != v34[1])
                v35 = 0;
              v36 = v35 && v31 == v34[2];
              if (v36)
                v32 = 0;
              if ((v36 & 1) != 0)
                break;
              ++v27;
            }
            while (v27 < v15);
            if ((v32 & 1) != 0)
            {
              *(_QWORD *)(v8 + 8 * v15++) = v16;
              v37 = *((_QWORD *)this + 20);
              if (v37 <= v15)
                break;
            }
          }
        }
        else if (v7 == 1)
        {
          v38 = 1;
          do
          {
            *(_QWORD *)(v8 + 8 * v38++) = 0;
            v37 = *((_QWORD *)this + 20);
          }
          while (v37 > v38);
        }
        else
        {
          v40 = *(_QWORD *)this;
          v41 = *((_QWORD *)this + 19);
          v42 = 1;
          do
          {
            v43 = v41 + 16 * v42;
            do
            {
LABEL_54:
              if (v7)
              {
                v44 = 0xFFFFFFFF >> -(v11 / v12);
                if (v12 > v11)
                  v44 = 0;
                v45 = *(_QWORD *)(v40 + 2496);
                do
                {
                  v46 = 4 * v45;
                  v47 = v45 + 397;
                  v45 = (v45 + 1) % 0x270;
                  v48 = *(_DWORD *)(v40 + 4 * (v47 % 0x270)) ^ ((*(_DWORD *)(v40 + 4 * v45) & 0x7FFFFFFE | *(_DWORD *)(v40 + v46) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(v40 + 4 * v45) << 31) >> 31) & 0x9908B0DF;
                  *(_DWORD *)(v40 + v46) = v48;
                  v49 = ((v48 ^ (v48 >> 11)) << 7) & 0x9D2C5680 ^ v48 ^ (v48 >> 11);
                  v50 = ((v49 << 15) & 0xEFC60000 ^ v49 ^ (((v49 << 15) & 0xEFC60000 ^ v49) >> 18)) & v44;
                }
                while (v50 >= v7);
                *(_QWORD *)(v40 + 2496) = v45;
              }
              else
              {
                v51 = *(_QWORD *)(v40 + 2496);
                v52 = (v51 + 1) % 0x270uLL;
                v53 = 4 * v51;
                LODWORD(v51) = *(_DWORD *)(v40 + 4 * ((v51 + 397) % 0x270uLL)) ^ ((*(_DWORD *)(v40 + 4 * v52) & 0x7FFFFFFE | *(_DWORD *)(v40 + 4 * v51) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(v40 + 4 * v52) << 31) >> 31) & 0x9908B0DF;
                *(_DWORD *)(v40 + v53) = v51;
                *(_QWORD *)(v40 + 2496) = v52;
                LODWORD(v51) = ((v51 ^ (v51 >> 11)) << 7) & 0x9D2C5680 ^ v51 ^ (v51 >> 11);
                v50 = ((_DWORD)v51 << 15) & 0xEFC60000 ^ v51 ^ ((((_DWORD)v51 << 15) & 0xEFC60000 ^ v51) >> 18);
              }
              v54 = 0;
              v55 = (int)v50;
              result.n128_u32[0] = *(_DWORD *)v43;
              v56 = 1;
              do
              {
                v57 = *(_QWORD *)(v8 + 8 * v54);
                if (v57 == v55)
                  goto LABEL_54;
                v58 = (float *)(v41 + 16 * v57);
                v59 = result.n128_f32[0] == *v58;
                if (*(float *)(v43 + 4) != v58[1])
                  v59 = 0;
                v60 = v59 && *(float *)(v43 + 8) == v58[2];
                if (v60)
                  v56 = 0;
                if ((v60 & 1) != 0)
                  break;
                ++v54;
              }
              while (v54 < v42);
            }
            while ((v56 & 1) == 0);
            *(_QWORD *)(v8 + 8 * v42++) = v55;
            v37 = *((_QWORD *)this + 20);
          }
          while (v37 > v42);
        }
        if (v37 >= 2)
        {
          v39 = 1;
          if (a2)
          {
            do
            {
              result = *(__n128 *)(*((_QWORD *)this + 19) + 16 * *(_QWORD *)(v8 + 8 * v39));
              *(__n128 *)(*((_QWORD *)this + 22) + 16 * v39++) = result;
            }
            while (*((_QWORD *)this + 20) > v39);
          }
          else
          {
            do
            {
              result = *(__n128 *)(*((_QWORD *)this + 19) + 16 * *(_QWORD *)(v8 + 8 * v39));
              *(__n128 *)(*((_QWORD *)this + 21) + 16 * v39++) = result;
            }
            while (*((_QWORD *)this + 20) > v39);
          }
        }
      }
    }
  }
  return result;
}

uint64_t soKMeansClassifier::InitClusterMeans_PP(soKMeansClassifier *this)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  pthread_t *v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  double v12;
  double v13;
  double v14;
  int32x4_t v15;
  float32x4_t v16;
  _opaque_pthread_t **v17;
  unint64_t v18;
  _opaque_pthread_t *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  double v26;
  double v27;
  uint64_t v28;
  double v29;
  unint64_t v30;
  double *v31;
  double v32;
  uint64_t i;
  uint64_t v34;
  int v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unsigned int v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unsigned int v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  int v64;
  double v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  int v69;
  double v70;
  unint64_t v71;
  double *v72;
  double v73;
  uint64_t j;
  uint64_t v75;
  uint64_t v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unsigned int v82;
  unint64_t v83;
  uint64_t v84;
  unint64_t v85;
  unsigned int v86;
  unsigned int v87;
  unsigned int v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  double v94;
  uint64_t v95;
  uint64_t v96;
  pthread_t *v97;
  unint64_t v98;
  _QWORD *v99;
  _QWORD *v100;
  int32x4_t v101;
  float32x4_t v102;
  uint64_t v103;
  double v104;
  double v105;
  double *v106;
  double *v107;
  float32x4_t *v108;
  uint64_t v109;
  uint64_t v110;
  float *v111;
  __int32 *v112;
  double v113;
  unint64_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float v118;
  float v119;
  unint64_t v120;
  _opaque_pthread_t **v121;
  _opaque_pthread_t *v122;
  double v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  int8x16_t v131;
  int8x16_t v132;
  uint64_t v133;
  uint64_t v134;
  int v135;
  float32x4_t v137;
  uint64_t v138;
  uint64_t v139;
  float32x4_t v140;
  float32x4_t v141;
  uint64_t result;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  unint64_t v147;
  unint64_t v148;
  unint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  unint64_t v153;
  unint64_t v154;
  unint64_t v155;
  _BOOL8 v156;

  v2 = *((_QWORD *)this + 1);
  v147 = *((_QWORD *)this + 14);
  v148 = v2;
  v3 = v147 / v2;
  v4 = v2 - 2;
  if (v2 < 2)
  {
    v143 = 0;
  }
  else
  {
    v5 = v2 - 1;
    v6 = 0;
    v7 = 0;
    v143 = operator new[]();
    v8 = (pthread_t *)(v143 + 8);
    v9 = v3;
    do
    {
      if (v4 == v6)
        v9 = *((_QWORD *)this + 14);
      else
        v9 += v3;
      v7 += v3;
      v10 = (char *)operator new();
      *(_QWORD *)v10 = this;
      *((_QWORD *)v10 + 1) = v7;
      *((_QWORD *)v10 + 2) = v9;
      *(_OWORD *)(v10 + 24) = 0u;
      *(_OWORD *)(v10 + 40) = 0u;
      *((_QWORD *)v10 + 7) = 1;
      *((_QWORD *)v10 + 8) = v6 + 1;
      pthread_create(v8, 0, (void *(__cdecl *)(void *))ComputeD2, v10);
      ++v6;
      ++v8;
    }
    while (v5 != v6);
    v2 = v148;
  }
  v11 = operator new();
  *(_QWORD *)v11 = this;
  *(_QWORD *)(v11 + 8) = 0;
  *(_QWORD *)(v11 + 16) = v3;
  *(_OWORD *)(v11 + 24) = 0u;
  *(_OWORD *)(v11 + 40) = 0u;
  *(_OWORD *)(v11 + 56) = xmmword_1B3056A60;
  ComputeD2((_QWORD *)v11, COERCE_DOUBLE(1), v12, v13, v14, v15, v16);
  v153 = v2 - 2;
  if (v2 >= 2)
  {
    v17 = (_opaque_pthread_t **)(v143 + 8);
    v18 = v2 - 1;
    do
    {
      v19 = *v17++;
      pthread_join(v19, 0);
      --v18;
    }
    while (v18);
  }
  if (*((_QWORD *)this + 20) >= 2uLL)
  {
    v20 = 0;
    v21 = 0;
    v154 = v2 - 1;
    v22 = 1;
    v151 = 1;
    v23 = 1;
    v24 = 1;
    v156 = 1;
    while (!*((_QWORD *)this + 51))
    {
      v144 = -1;
      v145 = -1;
      v123 = 0.0;
      v29 = 0.0;
LABEL_162:
      *(_QWORD *)(*((_QWORD *)this + 48) + 8 * v22) = v145;
      *(_OWORD *)(*((_QWORD *)this + 21) + 16 * v22) = *(_OWORD *)(*((_QWORD *)this + 19) + 16 * v145);
      **((double **)this + 42) = v123;
      v156 = v23 == 0;
      if (*((_BYTE *)this + 16))
      {
        *(_QWORD *)(*((_QWORD *)this + 49) + 8 * v22) = v144;
        *(_OWORD *)(*((_QWORD *)this + 22) + 16 * v22) = *(_OWORD *)(*((_QWORD *)this + 19) + 16 * v144);
        **((double **)this + 43) = v29;
        v20 = v151;
        v24 = v151 == 0;
      }
      ++v22;
      v21 = v23;
      if (*((_QWORD *)this + 20) <= v22)
        goto LABEL_164;
    }
    v25 = 0;
    v155 = v22 + 1;
    v26 = 0.0;
    v144 = -1;
    v145 = -1;
    v146 = 4 * v21;
    v27 = 0.0;
    v28 = v24;
    v149 = v22;
    while (1)
    {
      v30 = *((_QWORD *)this + 1);
      if (v30 >= 2)
      {
        v31 = (double *)*((_QWORD *)this + 42);
        v32 = *v31;
        for (i = 1; i != v30; ++i)
          v32 = v32 + v31[i];
        *v31 = v32;
      }
      v150 = v23;
      v34 = *((_QWORD *)this + 14);
      v35 = (int)**((double **)this + 42);
      v36 = *(_QWORD *)this;
      v37 = v35 + 1;
      v152 = v25;
      if (*((_BYTE *)this + 16))
      {
        if (v35)
        {
          if (v35 == -1)
          {
            v61 = *(_QWORD *)(v36 + 2496);
            v62 = (v61 + 1) % 0x270uLL;
            v63 = 4 * v61;
            LODWORD(v61) = *(_DWORD *)(v36 + 4 * ((v61 + 397) % 0x270uLL)) ^ ((*(_DWORD *)(v36 + 4 * v62) & 0x7FFFFFFE | *(_DWORD *)(v36 + 4 * v61) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(v36 + 4 * v62) << 31) >> 31) & 0x9908B0DF;
            *(_DWORD *)(v36 + v63) = v61;
            *(_QWORD *)(v36 + 2496) = v62;
            v64 = ((v61 ^ (v61 >> 11)) << 7) & 0x9D2C5680 ^ v61 ^ (v61 >> 11);
            v48 = (v64 << 15) & 0xEFC60000 ^ v64 ^ (((v64 << 15) & 0xEFC60000 ^ v64) >> 18);
            v49 = 0;
            if (!v34)
              goto LABEL_65;
          }
          else
          {
            v38 = __clz(v37);
            v39 = 31;
            if (((v37 << v38) & 0x7FFFFFFF) != 0)
              v39 = 32;
            v40 = v39 - v38;
            v41 = v40 >> 5;
            if ((v40 & 0x1F) != 0)
              ++v41;
            if (v41 <= v40)
              v42 = 0xFFFFFFFF >> -(v40 / v41);
            else
              v42 = 0;
            v43 = *(_QWORD *)(v36 + 2496);
            do
            {
              v44 = 4 * v43;
              v45 = v43 + 397;
              v43 = (v43 + 1) % 0x270;
              v46 = *(_DWORD *)(v36 + 4 * (v45 % 0x270)) ^ ((*(_DWORD *)(v36 + 4 * v43) & 0x7FFFFFFE | *(_DWORD *)(v36 + v44) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(v36 + 4 * v43) << 31) >> 31) & 0x9908B0DF;
              *(_DWORD *)(v36 + v44) = v46;
              v47 = ((v46 ^ (v46 >> 11)) << 7) & 0x9D2C5680 ^ v46 ^ (v46 >> 11);
              v48 = ((v47 << 15) & 0xEFC60000 ^ v47 ^ (((v47 << 15) & 0xEFC60000 ^ v47) >> 18)) & v42;
            }
            while (v48 >= v37);
            *(_QWORD *)(v36 + 2496) = v43;
            v49 = 0;
            if (!v34)
              goto LABEL_65;
          }
        }
        else
        {
          v48 = 0;
          v49 = 0;
          if (!v34)
            goto LABEL_65;
        }
        v65 = (double)(int)v48;
        while (1)
        {
          if (!*(_BYTE *)(*((_QWORD *)this + 6) + v49))
          {
            v65 = v65 - *(float *)(*((_QWORD *)this + 50) + v146 * v34 + 4 * v49);
            if (v65 <= 0.0)
              break;
          }
          if (v34 == ++v49)
            goto LABEL_64;
        }
      }
      else
      {
        if (v35)
        {
          if (v35 == -1)
          {
            v66 = *(_QWORD *)(v36 + 2496);
            v67 = (v66 + 1) % 0x270uLL;
            v68 = 4 * v66;
            LODWORD(v66) = *(_DWORD *)(v36 + 4 * ((v66 + 397) % 0x270uLL)) ^ ((*(_DWORD *)(v36 + 4 * v67) & 0x7FFFFFFE | *(_DWORD *)(v36 + 4 * v66) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(v36 + 4 * v67) << 31) >> 31) & 0x9908B0DF;
            *(_DWORD *)(v36 + v68) = v66;
            *(_QWORD *)(v36 + 2496) = v67;
            v69 = ((v66 ^ (v66 >> 11)) << 7) & 0x9D2C5680 ^ v66 ^ (v66 >> 11);
            v60 = (v69 << 15) & 0xEFC60000 ^ v69 ^ (((v69 << 15) & 0xEFC60000 ^ v69) >> 18);
            v49 = 0;
            if (!v34)
              goto LABEL_65;
          }
          else
          {
            v50 = __clz(v37);
            v51 = 31;
            if (((v37 << v50) & 0x7FFFFFFF) != 0)
              v51 = 32;
            v52 = v51 - v50;
            v53 = v52 >> 5;
            if ((v52 & 0x1F) != 0)
              ++v53;
            if (v53 <= v52)
              v54 = 0xFFFFFFFF >> -(v52 / v53);
            else
              v54 = 0;
            v55 = *(_QWORD *)(v36 + 2496);
            do
            {
              v56 = 4 * v55;
              v57 = v55 + 397;
              v55 = (v55 + 1) % 0x270;
              v58 = *(_DWORD *)(v36 + 4 * (v57 % 0x270)) ^ ((*(_DWORD *)(v36 + 4 * v55) & 0x7FFFFFFE | *(_DWORD *)(v36 + v56) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(v36 + 4 * v55) << 31) >> 31) & 0x9908B0DF;
              *(_DWORD *)(v36 + v56) = v58;
              v59 = ((v58 ^ (v58 >> 11)) << 7) & 0x9D2C5680 ^ v58 ^ (v58 >> 11);
              v60 = ((v59 << 15) & 0xEFC60000 ^ v59 ^ (((v59 << 15) & 0xEFC60000 ^ v59) >> 18)) & v54;
            }
            while (v60 >= v37);
            *(_QWORD *)(v36 + 2496) = v55;
            v49 = 0;
            if (!v34)
              goto LABEL_65;
          }
        }
        else
        {
          v60 = 0;
          v49 = 0;
          if (!v34)
            goto LABEL_65;
        }
        v70 = (double)(int)v60;
        while (1)
        {
          v70 = v70 - *(float *)(*((_QWORD *)this + 50) + v146 * v34 + 4 * v49);
          if (v70 <= 0.0)
            break;
          if (v34 == ++v49)
          {
LABEL_64:
            LODWORD(v49) = v34;
            break;
          }
        }
      }
LABEL_65:
      *(_QWORD *)(*((_QWORD *)this + 48) + 8 * v22) = v49;
      *(_OWORD *)(*((_QWORD *)this + 21) + 16 * v22) = *(_OWORD *)(*((_QWORD *)this + 19) + 16 * v49);
      if (!*((_BYTE *)this + 16))
        goto LABEL_93;
      v71 = *((_QWORD *)this + 1);
      v72 = (double *)*((_QWORD *)this + 43);
      v73 = *v72;
      if (v71 >= 2)
      {
        for (j = 1; j != v71; ++j)
          v73 = v73 + v72[j];
        *v72 = v73;
      }
      v75 = *((_QWORD *)this + 14);
      if ((int)v73)
      {
        v76 = *(_QWORD *)this;
        v77 = (int)v73 + 1;
        if ((int)v73 == -1)
        {
          v90 = *(_QWORD *)(v76 + 2496);
          v91 = (v90 + 1) % 0x270uLL;
          v92 = 4 * v90;
          LODWORD(v90) = *(_DWORD *)(v76 + 4 * ((v90 + 397) % 0x270uLL)) ^ ((*(_DWORD *)(v76 + 4 * v91) & 0x7FFFFFFE | *(_DWORD *)(v76 + 4 * v90) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(v76 + 4 * v91) << 31) >> 31) & 0x9908B0DF;
          *(_DWORD *)(v76 + v92) = v90;
          *(_QWORD *)(v76 + 2496) = v91;
          v93 = ((v90 ^ (v90 >> 11)) << 7) & 0x9D2C5680 ^ v90 ^ (v90 >> 11);
          v88 = (v93 << 15) & 0xEFC60000 ^ v93 ^ (((v93 << 15) & 0xEFC60000 ^ v93) >> 18);
          v89 = 0;
          if (v75)
            goto LABEL_86;
        }
        else
        {
          v78 = __clz(v77);
          v79 = 31;
          if (((v77 << v78) & 0x7FFFFFFF) != 0)
            v79 = 32;
          v80 = v79 - v78;
          v81 = v80 >> 5;
          if ((v80 & 0x1F) != 0)
            ++v81;
          if (v81 <= v80)
            v82 = 0xFFFFFFFF >> -(v80 / v81);
          else
            v82 = 0;
          v83 = *(_QWORD *)(v76 + 2496);
          do
          {
            v84 = 4 * v83;
            v85 = v83 + 397;
            v83 = (v83 + 1) % 0x270;
            v86 = *(_DWORD *)(v76 + 4 * (v85 % 0x270)) ^ ((*(_DWORD *)(v76 + 4 * v83) & 0x7FFFFFFE | *(_DWORD *)(v76 + v84) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(v76 + 4 * v83) << 31) >> 31) & 0x9908B0DF;
            *(_DWORD *)(v76 + v84) = v86;
            v87 = ((v86 ^ (v86 >> 11)) << 7) & 0x9D2C5680 ^ v86 ^ (v86 >> 11);
            v88 = ((v87 << 15) & 0xEFC60000 ^ v87 ^ (((v87 << 15) & 0xEFC60000 ^ v87) >> 18)) & v82;
          }
          while (v88 >= v77);
          *(_QWORD *)(v76 + 2496) = v83;
          v89 = 0;
          if (v75)
          {
LABEL_86:
            v94 = (double)(int)v88;
            while (1)
            {
              if (*(unsigned __int8 *)(*((_QWORD *)this + 6) + v89) == 255)
              {
                v94 = v94 - *(float *)(*((_QWORD *)this + 50) + 4 * v20 * v75 + 4 * v89);
                if (v94 <= 0.0)
                  break;
              }
              if (v75 == ++v89)
              {
                LODWORD(v89) = v75;
                break;
              }
            }
          }
        }
      }
      else
      {
        v88 = 0;
        v89 = 0;
        if (v75)
          goto LABEL_86;
      }
      *(_QWORD *)(*((_QWORD *)this + 49) + 8 * v22) = v89;
      *(_OWORD *)(*((_QWORD *)this + 22) + 16 * v22) = *(_OWORD *)(*((_QWORD *)this + 19) + 16 * v89);
LABEL_93:
      if (v2 >= 2)
      {
        v95 = 0;
        v96 = 0;
        v97 = (pthread_t *)(v143 + 8);
        v98 = v3;
        do
        {
          if (v153 == v95)
            v98 = *((_QWORD *)this + 14);
          else
            v98 += v3;
          v96 += v3;
          v99 = (_QWORD *)operator new();
          *v99 = this;
          v99[1] = v96;
          v99[2] = v98;
          v99[3] = v21;
          v99[4] = v156;
          v99[5] = v20;
          v99[6] = v28;
          v99[7] = v155;
          v99[8] = v95 + 1;
          pthread_create(v97, 0, (void *(__cdecl *)(void *))ComputeD2, v99);
          ++v95;
          ++v97;
        }
        while (v154 != v95);
      }
      v100 = (_QWORD *)operator new();
      *v100 = this;
      v100[1] = 0;
      v100[2] = v3;
      v100[3] = v21;
      v100[4] = v156;
      v100[5] = v20;
      v100[6] = v28;
      v100[7] = v155;
      v100[8] = 0;
      v103 = *((_QWORD *)this + 14);
      if (*((_BYTE *)this + 16))
      {
        v104 = 0.0;
        v105 = 0.0;
        v2 = v148;
        v22 = v149;
        if (v148 <= v147)
        {
          v125 = 0;
          v126 = *((_QWORD *)this + 50);
          v127 = v126 + 4 * v103 * v156;
          v128 = v126 + 4 * v103 * v28;
          v129 = v126 + 4 * v103 * v21;
          v130 = v126 + 4 * v103 * v20;
          v131 = *(int8x16_t *)(*((_QWORD *)this + 22) + 16 * v149);
          v132 = *(int8x16_t *)(*((_QWORD *)this + 21) + 16 * v149);
          v133 = *((_QWORD *)this + 19);
          v134 = *((_QWORD *)this + 6);
          do
          {
            v135 = *(unsigned __int8 *)(v134 + v125);
            if (v135 == 255 || v135 == 0)
            {
              v101.i32[0] = 0;
              v102.i32[0] = *(unsigned __int8 *)(v134 + v125);
              v137 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v102, v101), 0), v132, v131);
              v102 = *(float32x4_t *)(v133 + 16 * v125);
              if (v135 == 255)
                v138 = v130;
              else
                v138 = 0;
              if (v135 == 255)
                v139 = v128;
              else
                v139 = 0;
              if (!*(_BYTE *)(v134 + v125))
              {
                v138 = v129;
                v139 = v127;
              }
              v140 = vsubq_f32(v102, v137);
              v141 = vmulq_f32(v140, v140);
              v101 = (int32x4_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v141, 2), vaddq_f32(v141, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v141.f32, 1)));
              if (*(float *)v101.i32 >= *(float *)(v138 + 4 * v125))
                v101.i32[0] = *(_DWORD *)(v138 + 4 * v125);
              *(_DWORD *)(v139 + 4 * v125) = v101.i32[0];
              *(double *)v101.i64 = *(float *)v101.i32;
              if (v135)
                v104 = v104 + *(double *)v101.i64;
              else
                v105 = v105 + *(double *)v101.i64;
            }
            ++v125;
          }
          while (v3 != v125);
        }
        v106 = (double *)*((_QWORD *)this + 43);
        **((double **)this + 42) = v105;
        *v106 = v104;
      }
      else
      {
        v107 = (double *)*((_QWORD *)this + 42);
        *v107 = 0.0;
        v2 = v148;
        v22 = v149;
        if (v148 <= v147)
        {
          v108 = (float32x4_t *)*((_QWORD *)this + 19);
          v109 = *((_QWORD *)this + 21);
          v110 = *((_QWORD *)this + 50);
          v111 = (float *)(v110 + 4 * v156 * v103);
          v112 = (__int32 *)(v110 + v146 * v103);
          v113 = 0.0;
          v114 = v3;
          do
          {
            v115 = *v108++;
            v116 = vsubq_f32(v115, *(float32x4_t *)(v109 + 16 * v149));
            v117 = vmulq_f32(v116, v116);
            v118 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v117, 2), vaddq_f32(v117, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v117.f32, 1))).f32[0];
            v115.i32[0] = *v112++;
            v119 = v115.f32[0];
            if (v118 >= v115.f32[0])
              v118 = v119;
            *v111++ = v118;
            v113 = v113 + v118;
            *v107 = v113;
            --v114;
          }
          while (v114);
        }
      }
      MEMORY[0x1B5E29170]();
      v120 = v154;
      v121 = (_opaque_pthread_t **)(v143 + 8);
      if (v2 >= 2)
      {
        do
        {
          v122 = *v121++;
          pthread_join(v122, 0);
          --v120;
        }
        while (v120);
      }
      v123 = **((double **)this + 42);
      if (v152)
      {
        if (v27 <= v123)
        {
          v124 = v156;
          v156 = v150;
          v123 = v27;
          if (!*((_BYTE *)this + 16))
            goto LABEL_17;
        }
        else
        {
          v145 = *(_QWORD *)(*((_QWORD *)this + 48) + 8 * v22);
          if (v21 == 1)
          {
            v124 = 2 * !v156;
            if (!*((_BYTE *)this + 16))
              goto LABEL_17;
          }
          else if (v21)
          {
            v124 = !v156;
            if (!*((_BYTE *)this + 16))
              goto LABEL_17;
          }
          else
          {
            v124 = 1;
            if (v156)
              v124 = 2;
            if (!*((_BYTE *)this + 16))
              goto LABEL_17;
          }
        }
        v29 = **((double **)this + 43);
        if (v26 > v29)
        {
          v144 = *(_QWORD *)(*((_QWORD *)this + 49) + 8 * v22);
          if (v20 == 1)
          {
LABEL_160:
            v24 = 2 * (v28 == 0);
            goto LABEL_18;
          }
          if (!v20)
          {
LABEL_150:
            v24 = 1;
            if (v28 == 1)
              v24 = 2;
            goto LABEL_18;
          }
          goto LABEL_159;
        }
      }
      else if (v21 == 1)
      {
        v124 = 2 * !v156;
        v145 = *(_QWORD *)(*((_QWORD *)this + 48) + 8 * v22);
        if (*((_BYTE *)this + 16))
          goto LABEL_148;
      }
      else if (v21)
      {
        v124 = !v156;
        v145 = *(_QWORD *)(*((_QWORD *)this + 48) + 8 * v22);
        if (*((_BYTE *)this + 16))
          goto LABEL_148;
      }
      else
      {
        v124 = 1;
        if (v156)
          v124 = 2;
        v145 = *(_QWORD *)(*((_QWORD *)this + 48) + 8 * v22);
        if (*((_BYTE *)this + 16))
        {
LABEL_148:
          v29 = **((double **)this + 43);
          v144 = *(_QWORD *)(*((_QWORD *)this + 49) + 8 * v22);
          if (v20 == 1)
            goto LABEL_160;
          if (!v20)
            goto LABEL_150;
LABEL_159:
          v24 = v28 == 0;
          goto LABEL_18;
        }
      }
LABEL_17:
      v24 = v28;
      v28 = v151;
      v29 = v26;
LABEL_18:
      v25 = v152 + 1;
      v23 = v156;
      v151 = v28;
      v26 = v29;
      v27 = v123;
      v28 = v24;
      v156 = v124;
      if (*((_QWORD *)this + 51) <= (unint64_t)(v152 + 1))
        goto LABEL_162;
    }
  }
LABEL_164:
  result = v143;
  if (v143)
    JUMPOUT(0x1B5E2914CLL);
  return result;
}

uint64_t ComputeD2(_QWORD *a1, double a2, double a3, double a4, double a5, int32x4_t a6, float32x4_t a7)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  double v15;
  double v16;
  BOOL v17;
  unint64_t v18;
  int8x16_t v19;
  int8x16_t v20;
  uint64_t v21;
  float32x4_t *v22;
  unsigned __int8 *v23;
  unsigned __int32 v24;
  unsigned __int32 v25;
  float32x4_t v27;
  BOOL v28;
  uint64_t v29;
  float32x4_t v30;
  float32x4_t v31;
  double v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  float32x4_t *v44;
  _DWORD *v45;
  float32x4_t *v46;
  double v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int8x16_t v59;
  int8x16_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  float32x4_t v65;
  uint64_t v66;
  uint64_t v67;
  float32x4_t v68;
  float32x4_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  float *v79;
  __int32 *v80;
  float32x4_t *v81;
  double v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float v86;
  float v87;

  v7 = (_QWORD *)*a1;
  if (*(_BYTE *)(*a1 + 16))
  {
    v8 = v7[14];
    v9 = a1[4] * v8;
    v10 = a1[7];
    v11 = a1[6] * v8;
    v12 = v7[50];
    if (v10 == 1)
    {
      v14 = a1[1];
      v13 = a1[2];
      v15 = 0.0;
      v16 = 0.0;
      v17 = v13 > v14;
      v18 = v13 - v14;
      if (v17)
      {
        v19 = *(int8x16_t *)v7[22];
        v20 = *(int8x16_t *)v7[21];
        v21 = v12 + 4 * v14;
        v22 = (float32x4_t *)(v7[19] + 16 * v14);
        v23 = (unsigned __int8 *)(v7[6] + v14);
        do
        {
          v25 = *v23++;
          v24 = v25;
          if (v25 == 255 || v24 == 0)
          {
            a6.i32[0] = 0;
            a7.i32[0] = v24;
            v27 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)a7, a6), 0), v20, v19);
            v28 = v24 == 0;
            if (v24)
              v29 = v11;
            else
              v29 = v9;
            v30 = vsubq_f32(*v22, v27);
            v31 = vmulq_f32(v30, v30);
            a7 = vaddq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1));
            a6 = (int32x4_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 2), a7);
            *(_DWORD *)(v21 + 4 * v29) = a6.i32[0];
            *(double *)a6.i64 = *(float *)a6.i32;
            a7.i32[1] = 0x80000000;
            if (v28)
              v32 = -0.0;
            else
              v32 = *(double *)a6.i64;
            v15 = v15 + v32;
            if (!v28)
              *(double *)a6.i64 = -0.0;
            v16 = v16 + *(double *)a6.i64;
          }
          v21 += 4;
          ++v22;
          --v18;
        }
        while (v18);
      }
    }
    else
    {
      v51 = a1[1];
      v52 = a1[2];
      v15 = 0.0;
      v16 = 0.0;
      if (v51 < v52)
      {
        v53 = v12 + 4 * v9;
        v54 = v12 + 4 * v11;
        v55 = a1[5] * v8;
        v56 = v12 + 4 * a1[3] * v8;
        v57 = v12 + 4 * v55;
        v58 = 16 * v10 - 16;
        v59 = *(int8x16_t *)(v7[22] + v58);
        v60 = *(int8x16_t *)(v7[21] + v58);
        v61 = v7[19];
        v62 = v7[6];
        do
        {
          v63 = *(unsigned __int8 *)(v62 + v51);
          if (v63 == 255 || v63 == 0)
          {
            a6.i32[0] = 0;
            a7.i32[0] = *(unsigned __int8 *)(v62 + v51);
            v65 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)a7, a6), 0), v60, v59);
            a7 = *(float32x4_t *)(v61 + 16 * v51);
            if (v63 == 255)
              v66 = v57;
            else
              v66 = 0;
            if (v63 == 255)
              v67 = v54;
            else
              v67 = 0;
            if (!*(_BYTE *)(v62 + v51))
            {
              v66 = v56;
              v67 = v53;
            }
            v68 = vsubq_f32(a7, v65);
            v69 = vmulq_f32(v68, v68);
            a6 = (int32x4_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v69, 2), vaddq_f32(v69, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v69.f32, 1)));
            if (*(float *)a6.i32 >= *(float *)(v66 + 4 * v51))
              a6.i32[0] = *(_DWORD *)(v66 + 4 * v51);
            *(_DWORD *)(v67 + 4 * v51) = a6.i32[0];
            *(double *)a6.i64 = *(float *)a6.i32;
            if (v63)
              v15 = v15 + *(double *)a6.i64;
            else
              v16 = v16 + *(double *)a6.i64;
          }
          ++v51;
        }
        while (v52 != v51);
      }
    }
    v70 = 8 * a1[8];
    v72 = v7[42];
    v71 = v7[43];
    *(double *)(v72 + v70) = v16;
    *(double *)(v71 + v70) = v15;
  }
  else
  {
    v33 = v7[14];
    v34 = a1[3];
    v35 = a1[4] * v33;
    v36 = v7[42];
    v38 = a1[7];
    v37 = a1[8];
    *(_QWORD *)(v36 + 8 * v37) = 0;
    v40 = a1[1];
    v39 = a1[2];
    v41 = v38 - 1;
    if (v41)
    {
      v17 = v39 > v40;
      v74 = v39 - v40;
      if (v17)
      {
        v75 = v33 * v34;
        v76 = v7[19];
        v77 = v7[21];
        v78 = v7[50];
        v79 = (float *)(v78 + 4 * (v40 + v35));
        v80 = (__int32 *)(v78 + 4 * (v40 + v75));
        v81 = (float32x4_t *)(v76 + 16 * v40);
        v82 = 0.0;
        do
        {
          v83 = *v81++;
          v84 = vsubq_f32(v83, *(float32x4_t *)(v77 + 16 * v41));
          v85 = vmulq_f32(v84, v84);
          v86 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v85, 2), vaddq_f32(v85, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v85.f32, 1))).f32[0];
          v83.i32[0] = *v80++;
          v87 = v83.f32[0];
          if (v86 >= v83.f32[0])
            v86 = v87;
          *v79++ = v86;
          v82 = v82 + v86;
          *(double *)(v36 + 8 * v37) = v82;
          --v74;
        }
        while (v74);
      }
    }
    else
    {
      v42 = v39 - v40;
      if (v39 > v40)
      {
        v43 = v7[19];
        v44 = (float32x4_t *)v7[21];
        v45 = (_DWORD *)(v7[50] + 4 * (v40 + v35));
        v46 = (float32x4_t *)(v43 + 16 * v40);
        v47 = 0.0;
        do
        {
          v48 = *v46++;
          v49 = vsubq_f32(v48, *v44);
          v50 = vmulq_f32(v49, v49);
          v50.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 2), vaddq_f32(v50, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50.f32, 1))).f32[0];
          *v45++ = v50.i32[0];
          v47 = v47 + v50.f32[0];
          *(double *)(v36 + 8 * v37) = v47;
          --v42;
        }
        while (v42);
      }
    }
  }
  MEMORY[0x1B5E29170]();
  return 0;
}

uint64_t FitToClusters(_QWORD *a1)
{
  size_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  unint64_t i;
  _QWORD *v9;
  float32x4_t v10;
  int v11;
  float32x4_t **v12;
  int v13;
  float32x4_t v14;
  float32x4_t v15;
  float v16;
  unint64_t v17;
  int v18;
  uint64_t j;
  float32x4_t v20;
  float32x4_t v21;
  float v22;
  uint64_t v23;
  float64x2_t *v24;
  float64x2_t v25;
  uint64_t v26;
  uint64_t v27;
  float32x4_t v28;
  float64x2_t v29;
  float64x2_t *v30;
  float64x2_t v31;
  float32x4_t v32;
  uint64_t v33;
  float64x2_t v34;
  float32x4_t v35;
  float64x2_t v36;
  float64x2_t *v37;
  float64x2_t v38;
  uint64_t v39;
  _QWORD *v40;
  float64x2_t *v41;
  float64x2_t v42;
  uint64_t v43;
  uint64_t v44;
  float32x4_t v45;
  float64x2_t v46;
  float64x2_t *v47;
  float64x2_t v48;
  float32x4_t v49;
  uint64_t v50;
  float64x2_t v51;
  float32x4_t v52;
  float64x2_t v53;
  float64x2_t *v54;
  float64x2_t v55;
  uint64_t k;
  float32x4_t v57;
  float32x4_t v58;
  float v59;
  uint64_t m;
  float v61;
  _QWORD v63[2];

  v63[1] = *MEMORY[0x1E0C80C00];
  v2 = 4 * *(_QWORD *)(*a1 + 160);
  v3 = ((uint64_t (*)(void))MEMORY[0x1E0C80A78])();
  v4 = (char *)v63 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v3);
  v6 = (char *)v63 - v5;
  if (v7)
  {
    memset_pattern16(v4, &unk_1B3524BC0, v2);
    memset_pattern16(v6, &unk_1B3524BC0, v2);
  }
  for (i = a1[1]; i < a1[2]; ++i)
  {
    v9 = (_QWORD *)*a1;
    if (*(_BYTE *)(*a1 + 16))
    {
      v10 = *(float32x4_t *)(v9[19] + 16 * i);
      if (*(unsigned __int8 *)(v9[6] + i) == 255)
      {
        v13 = 0;
        v12 = (float32x4_t **)(v9 + 22);
        v11 = 1;
        goto LABEL_14;
      }
      if (*(_BYTE *)(v9[6] + i))
        continue;
    }
    else
    {
      v10 = *(float32x4_t *)(v9[19] + 16 * i);
    }
    v11 = 0;
    v12 = (float32x4_t **)(v9 + 21);
    v13 = 1;
LABEL_14:
    v14 = vsubq_f32(v10, **v12);
    v15 = vmulq_f32(v14, v14);
    LODWORD(v16) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).u32[0];
    v17 = v9[20];
    if (v17 < 2)
    {
      v18 = 0;
    }
    else
    {
      v18 = 0;
      if (v13)
      {
        for (j = 1; j != v17; ++j)
        {
          v20 = vsubq_f32(v10, *(float32x4_t *)(v9[21] + 16 * j));
          v21 = vmulq_f32(v20, v20);
          v22 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).f32[0];
          if (v22 < v16)
          {
            v18 = j;
            v16 = v22;
          }
        }
      }
      else if ((v11 & 1) != 0)
      {
        for (k = 1; k != v17; ++k)
        {
          v57 = vsubq_f32(v10, *(float32x4_t *)(v9[22] + 16 * k));
          v58 = vmulq_f32(v57, v57);
          v59 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 2), vaddq_f32(v58, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.f32, 1))).f32[0];
          if (v59 < v16)
          {
            v18 = k;
            v16 = v59;
          }
        }
      }
      else
      {
        for (m = 1; m != v17; ++m)
        {
          v15 = vmulq_f32(v15, v15);
          v61 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).f32[0];
          if (v61 < v16)
          {
            v18 = m;
            v16 = v61;
          }
        }
      }
    }
    if ((v13 & 1) != 0)
    {
      *(_BYTE *)(v9[7] + i) = v18;
      v23 = v18;
      v24 = (float64x2_t *)(*(_QWORD *)(*a1 + 256) + 32 * (v18 + *(_QWORD *)(*a1 + 160) * a1[4]));
      v25 = vaddq_f64(vcvt_hight_f64_f32(v10), v24[1]);
      *v24 = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v10.f32), *v24);
      v24[1] = v25;
      v26 = *a1;
      v27 = 8 * (v18 + *(_QWORD *)(*a1 + 160) * a1[4]);
      ++*(_QWORD *)(*(_QWORD *)(*a1 + 352) + v27);
      if (*((_BYTE *)a1 + 25))
      {
        v28 = vmulq_n_f32(v10, v10.f32[0]);
        v29 = vcvtq_f64_f32(*(float32x2_t *)v28.f32);
        v30 = (float64x2_t *)(*(_QWORD *)(v26 + 304) + 96 * (v23 + *(_QWORD *)(v26 + 160) * a1[4]));
        v31 = vaddq_f64(vcvt_hight_f64_f32(v28), v30[1]);
        *v30 = vaddq_f64(v29, *v30);
        v30[1] = v31;
        v32 = vmulq_lane_f32(v10, *(float32x2_t *)v10.f32, 1);
        v33 = *(_QWORD *)(*a1 + 304) + 96 * (v23 + *(_QWORD *)(*a1 + 160) * a1[4]);
        v34 = *(float64x2_t *)(v33 + 48);
        *(float64x2_t *)(v33 + 32) = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v32.f32), *(float64x2_t *)(v33 + 32));
        *(float64x2_t *)(v33 + 48) = vaddq_f64(vcvt_hight_f64_f32(v32), v34);
        v35 = vmulq_laneq_f32(v10, v10, 2);
        v36 = vcvtq_f64_f32(*(float32x2_t *)v35.f32);
        v37 = (float64x2_t *)(*(_QWORD *)(*a1 + 304) + 96 * (v23 + *(_QWORD *)(*a1 + 160) * a1[4]));
        v38 = vaddq_f64(vcvt_hight_f64_f32(v35), v37[5]);
        v37[4] = vaddq_f64(v36, v37[4]);
        v37[5] = v38;
      }
      if (v16 <= *(float *)&v4[4 * v23])
        continue;
      *(float *)&v4[4 * v23] = v16;
      v39 = *a1;
      v40 = (_QWORD *)(*a1 + 288);
    }
    else
    {
      if (!v11)
        continue;
      *(_BYTE *)(v9[8] + i) = v18;
      v23 = v18;
      v41 = (float64x2_t *)(*(_QWORD *)(*a1 + 264) + 32 * (v18 + *(_QWORD *)(*a1 + 160) * a1[4]));
      v42 = vaddq_f64(vcvt_hight_f64_f32(v10), v41[1]);
      *v41 = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v10.f32), *v41);
      v41[1] = v42;
      v43 = *a1;
      v44 = 8 * (v18 + *(_QWORD *)(*a1 + 160) * a1[4]);
      ++*(_QWORD *)(*(_QWORD *)(*a1 + 360) + v44);
      if (*((_BYTE *)a1 + 25))
      {
        v45 = vmulq_n_f32(v10, v10.f32[0]);
        v46 = vcvtq_f64_f32(*(float32x2_t *)v45.f32);
        v47 = (float64x2_t *)(*(_QWORD *)(v43 + 312) + 96 * (v23 + *(_QWORD *)(v43 + 160) * a1[4]));
        v48 = vaddq_f64(vcvt_hight_f64_f32(v45), v47[1]);
        *v47 = vaddq_f64(v46, *v47);
        v47[1] = v48;
        v49 = vmulq_lane_f32(v10, *(float32x2_t *)v10.f32, 1);
        v50 = *(_QWORD *)(*a1 + 312) + 96 * (v23 + *(_QWORD *)(*a1 + 160) * a1[4]);
        v51 = *(float64x2_t *)(v50 + 48);
        *(float64x2_t *)(v50 + 32) = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v49.f32), *(float64x2_t *)(v50 + 32));
        *(float64x2_t *)(v50 + 48) = vaddq_f64(vcvt_hight_f64_f32(v49), v51);
        v52 = vmulq_laneq_f32(v10, v10, 2);
        v53 = vcvtq_f64_f32(*(float32x2_t *)v52.f32);
        v54 = (float64x2_t *)(*(_QWORD *)(*a1 + 312) + 96 * (v23 + *(_QWORD *)(*a1 + 160) * a1[4]));
        v55 = vaddq_f64(vcvt_hight_f64_f32(v52), v54[5]);
        v54[4] = vaddq_f64(v53, v54[4]);
        v54[5] = v55;
      }
      if (v16 <= *(float *)&v6[4 * v23])
        continue;
      *(float *)&v6[4 * v23] = v16;
      v39 = *a1;
      v40 = (_QWORD *)(*a1 + 296);
    }
    *(double *)(*v40 + 8 * (v23 + *(_QWORD *)(v39 + 160) * a1[4])) = v16;
  }
  MEMORY[0x1B5E29170](a1, 0x1020C4024F7876ELL);
  return 0;
}

uint64_t RefitToClusters(char *a1)
{
  unint64_t v1;
  uint64_t v2;
  int v3;
  float64x2_t v4;
  float64x2_t v5;
  uint64_t v6;
  float64x2_t *v7;
  char *v8;
  char *v9;
  float64x2_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  float64x2_t v15;
  float64x2_t *v16;
  float64x2_t v17;
  float32x4_t v18;
  uint64_t v19;
  float64x2_t v20;
  float32x4_t v21;
  float64x2_t v22;
  float64x2_t *v23;
  float64x2_t v24;
  float32x4_t v25;
  _QWORD *v26;
  unint64_t v27;
  float32x4_t v28;
  float64x2_t v29;
  float64x2_t v30;
  float64x2_t *v31;
  double v32;
  _QWORD *v33;
  unint64_t v34;
  float32x4_t v35;
  float64x2_t v36;
  float64x2_t v37;
  float64x2_t *v38;
  double v39;
  uint64_t v40;
  uint64_t j;
  float32x4_t v42;
  float64x2_t v43;
  float64x2_t v44;
  float64x2_t *v45;
  double v46;
  uint64_t v47;
  int v48;
  uint64_t i;
  float32x4_t v50;
  float64x2_t v51;
  float64x2_t v52;
  float64x2_t *v53;
  double v54;

  v1 = *((_QWORD *)a1 + 1);
  if (v1 < *((_QWORD *)a1 + 2))
  {
    v2 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + 16))
    {
      do
      {
        if (!*(_BYTE *)(v2 + 16))
          goto LABEL_7;
        v25 = *(float32x4_t *)(*(_QWORD *)(v2 + 152) + 16 * v1);
        if (*(_BYTE *)(*(_QWORD *)(v2 + 48) + v1))
        {
          if (*(unsigned __int8 *)(*(_QWORD *)(v2 + 48) + v1) < 0x81u)
            goto LABEL_7;
          v26 = *(_QWORD **)(v2 + 360);
          if (*v26 < 0xAuLL)
          {
            v27 = *(_QWORD *)(v2 + 160);
            if (v27 >= 2)
            {
              v32 = INFINITY;
              goto LABEL_28;
            }
          }
          else
          {
            v27 = *(_QWORD *)(v2 + 160);
            if (v27 > 1)
            {
              v28 = vsubq_f32(v25, *(float32x4_t *)*(_QWORD *)(v2 + 176));
              v29 = vcvt_hight_f64_f32(v28);
              v30 = vcvtq_f64_f32(*(float32x2_t *)v28.f32);
              v31 = *(float64x2_t **)(v2 + 192);
              v32 = vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v31[1], v30), v31[3], v30, 1), v29, v31[5]), v29).f64[0]
                  + vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*v31, v30.f64[0]), v31[2], v30, 1), v31[4], v29.f64[0]), v30))- **(double **)(v2 + 240);
LABEL_28:
              v47 = 0;
              v48 = 0;
              for (i = 1; i != v27; ++i)
              {
                if (v26[i] >= 0xAuLL)
                {
                  v50 = vsubq_f32(v25, *(float32x4_t *)(*(_QWORD *)(v2 + 176) + 16 * i));
                  v51 = vcvt_hight_f64_f32(v50);
                  v52 = vcvtq_f64_f32(*(float32x2_t *)v50.f32);
                  v53 = (float64x2_t *)(*(_QWORD *)(v2 + 192) + v47);
                  v54 = vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v53[7], v52), v53[9], v52, 1), v51, v53[11]), v51).f64[0]
                      + vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v53[6], v52.f64[0]), v53[8], v52, 1), v53[10], v51.f64[0]), v52))- *(double *)(*(_QWORD *)(v2 + 240) + 8 * i);
                }
                else
                {
                  v54 = INFINITY;
                }
                if (v54 <= v32)
                {
                  v48 = i;
                  v32 = v54;
                }
                v47 += 96;
              }
LABEL_36:
              *(_BYTE *)(*(_QWORD *)(v2 + 64) + v1) = v48;
              v4 = vcvt_hight_f64_f32(v25);
              v5 = vcvtq_f64_f32(*(float32x2_t *)v25.f32);
              v6 = v48;
              v7 = (float64x2_t *)(*((_QWORD *)a1 + 7)
                                 + 32 * (v48 + *(_QWORD *)(*(_QWORD *)a1 + 160) * *((_QWORD *)a1 + 3)));
              v8 = a1 + 40;
              v9 = a1 + 72;
              goto LABEL_6;
            }
          }
          v48 = 0;
          goto LABEL_36;
        }
        v33 = *(_QWORD **)(v2 + 352);
        if (*v33 < 0xAuLL)
        {
          v34 = *(_QWORD *)(v2 + 160);
          if (v34 >= 2)
          {
            v39 = INFINITY;
LABEL_19:
            v40 = 0;
            v3 = 0;
            for (j = 1; j != v34; ++j)
            {
              if (v33[j] >= 0xAuLL)
              {
                v42 = vsubq_f32(v25, *(float32x4_t *)(*(_QWORD *)(v2 + 168) + 16 * j));
                v43 = vcvt_hight_f64_f32(v42);
                v44 = vcvtq_f64_f32(*(float32x2_t *)v42.f32);
                v45 = (float64x2_t *)(*(_QWORD *)(v2 + 184) + v40);
                v46 = vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v45[7], v44), v45[9], v44, 1), v43, v45[11]), v43).f64[0]
                    + vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v45[6], v44.f64[0]), v45[8], v44, 1), v45[10], v43.f64[0]), v44))- *(double *)(*(_QWORD *)(v2 + 232) + 8 * j);
              }
              else
              {
                v46 = INFINITY;
              }
              if (v46 <= v39)
              {
                v3 = j;
                v39 = v46;
              }
              v40 += 96;
            }
            goto LABEL_5;
          }
        }
        else
        {
          v34 = *(_QWORD *)(v2 + 160);
          if (v34 > 1)
          {
            v35 = vsubq_f32(v25, *(float32x4_t *)*(_QWORD *)(v2 + 168));
            v36 = vcvt_hight_f64_f32(v35);
            v37 = vcvtq_f64_f32(*(float32x2_t *)v35.f32);
            v38 = *(float64x2_t **)(v2 + 184);
            v39 = vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v38[1], v37), v38[3], v37, 1), v36, v38[5]), v36).f64[0]
                + vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*v38, v37.f64[0]), v38[2], v37, 1), v38[4], v36.f64[0]), v37))- **(double **)(v2 + 232);
            goto LABEL_19;
          }
        }
        v3 = 0;
LABEL_5:
        *(_BYTE *)(*(_QWORD *)(v2 + 56) + v1) = v3;
        v4 = vcvt_hight_f64_f32(v25);
        v5 = vcvtq_f64_f32(*(float32x2_t *)v25.f32);
        v6 = v3;
        v7 = (float64x2_t *)(*((_QWORD *)a1 + 6) + 32 * (v3 + *(_QWORD *)(*(_QWORD *)a1 + 160) * *((_QWORD *)a1 + 3)));
        v8 = a1 + 32;
        v9 = a1 + 64;
LABEL_6:
        v10 = vaddq_f64(v4, v7[1]);
        *v7 = vaddq_f64(v5, *v7);
        v7[1] = v10;
        v11 = *(_QWORD *)v8;
        v12 = *(_QWORD *)a1;
        v13 = 8 * (v6 + *(_QWORD *)(*(_QWORD *)a1 + 160) * *((_QWORD *)a1 + 3));
        ++*(_QWORD *)(v11 + v13);
        v14 = vmulq_n_f32(v25, v25.f32[0]);
        v15 = vcvtq_f64_f32(*(float32x2_t *)v14.f32);
        v16 = (float64x2_t *)(*(_QWORD *)v9 + 96 * (v6 + *(_QWORD *)(v12 + 160) * *((_QWORD *)a1 + 3)));
        v17 = vaddq_f64(vcvt_hight_f64_f32(v14), v16[1]);
        *v16 = vaddq_f64(v15, *v16);
        v16[1] = v17;
        v18 = vmulq_lane_f32(v25, *(float32x2_t *)v25.f32, 1);
        v19 = *(_QWORD *)v9 + 96 * (v6 + *(_QWORD *)(*(_QWORD *)a1 + 160) * *((_QWORD *)a1 + 3));
        v20 = *(float64x2_t *)(v19 + 48);
        *(float64x2_t *)(v19 + 32) = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v18.f32), *(float64x2_t *)(v19 + 32));
        *(float64x2_t *)(v19 + 48) = vaddq_f64(vcvt_hight_f64_f32(v18), v20);
        v21 = vmulq_laneq_f32(v25, v25, 2);
        v22 = vcvtq_f64_f32(*(float32x2_t *)v21.f32);
        v23 = (float64x2_t *)(*(_QWORD *)v9 + 96 * (v6 + *(_QWORD *)(*(_QWORD *)a1 + 160) * *((_QWORD *)a1 + 3)));
        v24 = vaddq_f64(vcvt_hight_f64_f32(v21), v23[5]);
        v23[4] = vaddq_f64(v22, v23[4]);
        v23[5] = v24;
LABEL_7:
        ++v1;
      }
      while (v1 < *((_QWORD *)a1 + 2));
    }
  }
  MEMORY[0x1B5E29170]();
  return 0;
}

uint64_t soKMeansClassifier::Cluster(soKMeansClassifier *this, uint64_t a2, int a3, _BYTE *a4, _BYTE *a5, uint64_t a6, uint64_t a7, char *a8, __n128 a9, char *__dst, uint64_t a11)
{
  float64x2_t v16;
  float64x2_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  double v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  pthread_t *v26;
  unint64_t v27;
  unint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  BOOL v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t i;
  unint64_t v36;
  BOOL v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t j;
  uint64_t v46;
  float64x2_t *v47;
  float64x2_t v48;
  float64x2_t v49;
  float64x2_t *v50;
  float64x2_t v51;
  uint64_t v52;
  float64x2_t *v53;
  float64x2_t *v54;
  float64x2_t v55;
  uint64_t v56;
  float64x2_t *v57;
  float64x2_t *v58;
  float64x2_t v59;
  uint64_t v60;
  float64x2_t *v61;
  float64x2_t *v62;
  float64x2_t v63;
  uint64_t v64;
  float64x2_t *v65;
  float64x2_t *v66;
  float64x2_t v67;
  uint64_t v68;
  float64x2_t *v69;
  float64x2_t *v70;
  float64x2_t v71;
  uint64_t v72;
  float64x2_t *v73;
  float64x2_t *v74;
  float64x2_t v75;
  uint64_t v76;
  float64x2_t *v77;
  float64x2_t *v78;
  float64x2_t v79;
  uint64_t v80;
  unint64_t v81;
  double v82;
  uint64_t v83;
  double v84;
  unsigned int v86;
  uint64_t v87;
  unint64_t v88;
  int8x16_t v89;
  float64x2_t v90;
  float64x2_t v91;
  __int128 v92;
  double v93;
  long double v94;
  long double v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t v98;
  float64x2_t *v99;
  float64x2_t v100;
  float32x4_t v101;
  float64x2_t v102;
  float64x2_t v103;
  float64x2_t v104;
  int8x16_t v105;
  int8x16_t v106;
  float64x2_t *v107;
  int8x16_t v108;
  float64x2_t v109;
  float64x2_t *v110;
  float64x2_t v111;
  float64x2_t v112;
  int8x16_t v113;
  double v114;
  double v115;
  double v116;
  double v117;
  int8x16_t v118;
  float64x2_t v119;
  float64x2_t v120;
  __int128 v121;
  long double v122;
  long double v123;
  unint64_t v124;
  uint64_t v125;
  float64x2_t *v126;
  float64x2_t v127;
  float32x4_t v128;
  float64x2_t v129;
  float64x2_t v130;
  float64x2_t v131;
  int8x16_t v132;
  int8x16_t v133;
  float64x2_t *v134;
  int8x16_t v135;
  float64x2_t v136;
  float64x2_t *v137;
  float64x2_t v138;
  float64x2_t v139;
  int8x16_t v140;
  double v141;
  double v142;
  double v143;
  uint64_t v144;
  char *v145;
  _BYTE *v146;
  unint64_t k;
  float32x4_t v148;
  float32x4_t v149;
  int32x4_t v150;
  unint64_t v151;
  uint64_t v152;
  uint64_t v153;
  unint64_t v154;
  size_t v155;
  _BYTE *v156;
  unint64_t v157;
  float32x4_t v158;
  float32x4_t v159;
  int32x4_t v160;
  char *v161;
  unint64_t v162;
  uint64_t v163;
  uint64_t v164;
  unint64_t v165;
  size_t v166;
  _BYTE *v167;
  uint64_t v170;
  char *v171;
  int8x16_t v172;
  int8x16_t v173;
  int8x16_t v174;
  int8x16_t v175;
  float64x2_t v176;
  float64x2_t v177;
  uint64_t v178;
  float64x2_t v179;
  float64x2_t v180;
  simd_double3x3 __src;
  char v182[96];
  __int128 v183;
  int8x16_t v184;
  float64x2_t v185;
  int8x16_t v186;
  __int128 v187;
  float64x2_t v188;

  if (!*((_QWORD *)this + 10) || !*((_QWORD *)this + 11))
    return 0xFFFFFFFFLL;
  *((_DWORD *)this + 9) = a3;
  soKMeansClassifier::InitClusterMeans(this, a9);
  memset(*((void **)this + 7), 255, *((_QWORD *)this + 14));
  if (*((_BYTE *)this + 16))
    memset(*((void **)this + 8), 255, *((_QWORD *)this + 14));
  v167 = a4;
  v170 = a6;
  v171 = a8;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 18) = 0;
  if (a2)
  {
    v18 = 0;
    v19 = a2 - 1;
    v20 = *((_QWORD *)this + 20);
    v178 = a2;
    while (1)
    {
      bzero(*((void **)this + 44), 8 * v20 * *((_QWORD *)this + 1));
      bzero(*((void **)this + 32), 32 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
      bzero(*((void **)this + 38), 96 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
      if (*((_BYTE *)this + 16))
      {
        bzero(*((void **)this + 45), 8 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
        bzero(*((void **)this + 33), 32 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
        bzero(*((void **)this + 39), 96 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
      }
      if (*((_QWORD *)this + 1) < 2uLL)
      {
        v30 = operator new();
        v31 = *((_QWORD *)this + 14);
        *(_QWORD *)v30 = this;
        *(_QWORD *)(v30 + 8) = 0;
        *(_QWORD *)(v30 + 16) = v31;
        *(_BYTE *)(v30 + 24) = v18 == 0;
        *(_BYTE *)(v30 + 25) = v19 == v18;
        *(_QWORD *)(v30 + 32) = 0;
        FitToClusters((_QWORD *)v30);
        if (*((_QWORD *)this + 20))
          goto LABEL_30;
      }
      else
      {
        v21 = operator new[]();
        v22 = *(double *)&v21;
        v23 = *((_QWORD *)this + 1);
        v24 = *((_QWORD *)this + 14) / v23;
        if (v23 <= 1)
        {
          v32 = v19 == v18;
        }
        else
        {
          v25 = 0;
          *(_QWORD *)&__src.columns[0].f64[0] = v21;
          v26 = (pthread_t *)(v21 + 8);
          v27 = 1;
          v28 = *((_QWORD *)this + 14) / v23;
          do
          {
            if (v27 == v23 - 1)
              v28 = *((_QWORD *)this + 14);
            else
              v28 += v24;
            v25 += v24;
            v29 = (_QWORD *)operator new();
            *v29 = this;
            v29[1] = v25;
            v29[2] = v28;
            *((_BYTE *)v29 + 24) = v18 == 0;
            *((_BYTE *)v29 + 25) = v19 == v18;
            v29[4] = v27;
            pthread_create(v26, 0, (void *(__cdecl *)(void *))FitToClusters, v29);
            ++v27;
            v23 = *((_QWORD *)this + 1);
            ++v26;
          }
          while (v23 > v27);
          a2 = v178;
          v22 = __src.columns[0].f64[0];
          v32 = v19 == v18;
        }
        v33 = operator new();
        *(_QWORD *)v33 = this;
        *(_QWORD *)(v33 + 8) = 0;
        *(_QWORD *)(v33 + 16) = v24;
        *(_BYTE *)(v33 + 24) = v18 == 0;
        *(_BYTE *)(v33 + 25) = v32;
        *(_QWORD *)(v33 + 32) = 0;
        FitToClusters((_QWORD *)v33);
        v34 = *((_QWORD *)this + 1);
        if (v34 >= 2)
        {
          for (i = 1; i < v34; ++i)
          {
            pthread_join(*(pthread_t *)(*(_QWORD *)&v22 + 8 * i), 0);
            v34 = *((_QWORD *)this + 1);
          }
        }
        v36 = *((_QWORD *)this + 20);
        if (v36)
          v37 = v34 >= 2;
        else
          v37 = 0;
        if (v37)
        {
          v41 = 0;
          do
          {
            if (v34 >= 2)
            {
              v42 = (3 * v41);
              v43 = (v42 + 1);
              v44 = (v42 + 2);
              for (j = 1; j < v34; ++j)
              {
                v46 = *((_QWORD *)this + 32);
                v47 = (float64x2_t *)(v46 + 32 * (v41 + v36 * j));
                v48 = *v47;
                v49 = v47[1];
                v50 = (float64x2_t *)(v46 + 32 * v41);
                v51 = vaddq_f64(v49, v50[1]);
                *v50 = vaddq_f64(v48, *v50);
                v50[1] = v51;
                *(_QWORD *)(*((_QWORD *)this + 44) + 8 * v41) += *(_QWORD *)(*((_QWORD *)this + 44)
                                                                           + 8 * (v41 + *((_QWORD *)this + 20) * j));
                if (*((_BYTE *)this + 16))
                {
                  v52 = *((_QWORD *)this + 33);
                  v53 = (float64x2_t *)(v52 + 32 * (v41 + *((_QWORD *)this + 20) * j));
                  v54 = (float64x2_t *)(v52 + 32 * v41);
                  v55 = vaddq_f64(v53[1], v54[1]);
                  *v54 = vaddq_f64(*v53, *v54);
                  v54[1] = v55;
                  *(_QWORD *)(*((_QWORD *)this + 45) + 8 * v41) += *(_QWORD *)(*((_QWORD *)this + 45)
                                                                             + 8 * (v41 + *((_QWORD *)this + 20) * j));
                }
                if (v19 == v18)
                {
                  v56 = *((_QWORD *)this + 38);
                  v57 = (float64x2_t *)(v56 + 96 * (v41 + *((_QWORD *)this + 20) * j));
                  v58 = (float64x2_t *)(v56 + 32 * v42);
                  v59 = vaddq_f64(v57[1], v58[1]);
                  *v58 = vaddq_f64(*v57, *v58);
                  v58[1] = v59;
                  v60 = *((_QWORD *)this + 38);
                  v61 = (float64x2_t *)(v60 + 96 * (v41 + *((_QWORD *)this + 20) * j));
                  v62 = (float64x2_t *)(v60 + 32 * v43);
                  v63 = vaddq_f64(v61[3], v62[1]);
                  *v62 = vaddq_f64(v61[2], *v62);
                  v62[1] = v63;
                  v64 = *((_QWORD *)this + 38);
                  v65 = (float64x2_t *)(v64 + 96 * (v41 + *((_QWORD *)this + 20) * j));
                  v66 = (float64x2_t *)(v64 + 32 * v44);
                  v67 = vaddq_f64(v65[5], v66[1]);
                  *v66 = vaddq_f64(v65[4], *v66);
                  v66[1] = v67;
                  if (*((_BYTE *)this + 16))
                  {
                    v68 = *((_QWORD *)this + 39);
                    v69 = (float64x2_t *)(v68 + 96 * (v41 + *((_QWORD *)this + 20) * j));
                    v70 = (float64x2_t *)(v68 + 32 * v42);
                    v71 = vaddq_f64(v69[1], v70[1]);
                    *v70 = vaddq_f64(*v69, *v70);
                    v70[1] = v71;
                    v72 = *((_QWORD *)this + 39);
                    v73 = (float64x2_t *)(v72 + 96 * (v41 + *((_QWORD *)this + 20) * j));
                    v74 = (float64x2_t *)(v72 + 32 * v43);
                    v75 = vaddq_f64(v73[3], v74[1]);
                    *v74 = vaddq_f64(v73[2], *v74);
                    v74[1] = v75;
                    v76 = *((_QWORD *)this + 39);
                    v77 = (float64x2_t *)(v76 + 96 * (v41 + *((_QWORD *)this + 20) * j));
                    v78 = (float64x2_t *)(v76 + 32 * v44);
                    v79 = vaddq_f64(v77[5], v78[1]);
                    *v78 = vaddq_f64(v77[4], *v78);
                    v78[1] = v79;
                  }
                }
                v80 = *((_QWORD *)this + 36);
                v36 = *((_QWORD *)this + 20);
                v81 = v41 + v36 * j;
                v82 = *(double *)(v80 + 8 * v81);
                if (*(double *)(v80 + 8 * v41) < v82)
                  *(double *)(v80 + 8 * v41) = v82;
                if (*((_BYTE *)this + 16))
                {
                  v83 = *((_QWORD *)this + 37);
                  v84 = *(double *)(v83 + 8 * v81);
                  if (*(double *)(v83 + 8 * v41) < v84)
                    *(double *)(v83 + 8 * v41) = v84;
                }
                v34 = *((_QWORD *)this + 1);
              }
            }
            ++v41;
          }
          while (v36 > v41);
        }
        MEMORY[0x1B5E2914C](*(_QWORD *)&v22, 0x20C8093837F09);
        if (*((_QWORD *)this + 20))
        {
LABEL_30:
          v38 = 0;
          while (1)
          {
            v39 = *(_QWORD *)(*((_QWORD *)this + 44) + 8 * v38);
            if (v39)
            {
              v16.f64[0] = (double)v39;
              *(float32x4_t *)(*((_QWORD *)this + 21) + 16 * v38) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(*(float64x2_t *)(*((_QWORD *)this + 32) + 32 * v38), (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v39), 0))), vdivq_f64(*(float64x2_t *)(*((_QWORD *)this + 32)+ 32 * v38+ 16), v16));
            }
            if (v18)
            {
              if (*((_BYTE *)this + 16))
                goto LABEL_38;
            }
            else
            {
              *((_QWORD *)this + 17) += *(_QWORD *)(*((_QWORD *)this + 44) + 8 * v38);
              if (*((_BYTE *)this + 16))
              {
LABEL_38:
                v40 = *(_QWORD *)(*((_QWORD *)this + 45) + 8 * v38);
                if (v40)
                {
                  v16.f64[0] = (double)v40;
                  *(float32x4_t *)(*((_QWORD *)this + 22) + 16 * v38) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(*(float64x2_t *)(*((_QWORD *)this + 33) + 32 * v38), (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v40), 0))), vdivq_f64(*(float64x2_t *)(*((_QWORD *)this + 33)+ 32 * v38+ 16), v16));
                }
                if (!v18)
                  *((_QWORD *)this + 18) += *(_QWORD *)(*((_QWORD *)this + 45) + 8 * v38);
              }
            }
            ++v38;
            v20 = *((_QWORD *)this + 20);
            if (v20 <= v38)
              goto LABEL_8;
          }
        }
      }
      v20 = 0;
LABEL_8:
      if (++v18 == a2)
        goto LABEL_59;
    }
  }
  v20 = *((_QWORD *)this + 20);
LABEL_59:
  if (v20)
  {
    v86 = 0;
    v87 = 0;
    v88 = 0;
    do
    {
      v97 = *(_QWORD *)(*((_QWORD *)this + 44) + 8 * v88);
      if (v97)
      {
        v98 = *((_QWORD *)this + 38);
        v99 = (float64x2_t *)(v98 + 32 * v86);
        v16.f64[0] = (double)v97;
        v100 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v97), 0);
        v101 = *(float32x4_t *)(*((_QWORD *)this + 21) + 16 * v88);
        v102 = vcvt_hight_f64_f32(v101);
        v103 = vcvtq_f64_f32(*(float32x2_t *)v101.f32);
        v17.f64[0] = v101.f32[0];
        v104 = vmulq_f64(v17, v102);
        v105 = (int8x16_t)vsubq_f64(vdivq_f64(v99[1], v16), v104);
        v106 = (int8x16_t)vsubq_f64(vdivq_f64(*v99, v100), vmulq_n_f64(v103, v101.f32[0]));
        v107 = (float64x2_t *)(v98 + 32 * (v86 + 1));
        v104.f64[0] = COERCE_FLOAT(HIDWORD(*(_QWORD *)(*((_QWORD *)this + 21) + 16 * v88)));
        v108 = (int8x16_t)vsubq_f64(vdivq_f64(v107[1], v16), vmulq_f64(v104, v102));
        v109 = vsubq_f64(vdivq_f64(*v107, v100), vmulq_n_f64(v103, v104.f64[0]));
        v110 = (float64x2_t *)(v98 + 32 * (v86 + 2));
        v111 = vdivq_f64(v110[1], v16);
        v16.f64[0] = COERCE_FLOAT(*(_QWORD *)(*((_QWORD *)this + 21) + 16 * v88 + 8));
        v112 = vsubq_f64(v111, vmulq_f64(v16, v102));
        v113 = (int8x16_t)vsubq_f64(vdivq_f64(*v110, v100), vmulq_n_f64(v103, v16.f64[0]));
        v114 = vmuld_lane_f64(*(double *)v108.i64, (float64x2_t)v113, 1);
        v115 = vmuld_lane_f64(*(double *)v105.i64, (float64x2_t)v113, 1);
        v116 = vmuld_lane_f64(*(double *)v108.i64, (float64x2_t)v106, 1);
        v117 = (v116 - vmuld_lane_f64(*(double *)v105.i64, v109, 1)) * *(double *)v113.i64
             + (vmuld_lane_f64(v112.f64[0], v109, 1) - v114) * *(double *)v106.i64
             - (vmuld_lane_f64(v112.f64[0], (float64x2_t)v106, 1) - v115) * v109.f64[0];
        if (v117 <= 2.22044605e-16)
        {
          *(double *)v118.i64 = *(double *)v106.i64 + 0.01;
          v118.i64[1] = vextq_s8(v106, v106, 8uLL).u64[0];
          *(int8x16_t *)&__src.columns[0].f64[2] = v118;
          v119.f64[0] = v112.f64[0] + 0.01;
          v118.i64[0] = v105.i64[0];
          v118.i64[1] = vextq_s8(v105, v105, 8uLL).u64[0];
          v120.f64[0] = v109.f64[0];
          v120.f64[1] = v109.f64[1] + 0.01;
          v108.i64[1] = vextq_s8(v108, v108, 8uLL).u64[0];
          v173 = v108;
          v175 = v118;
          *(_QWORD *)&v121 = v113.i64[0];
          *((_QWORD *)&v121 + 1) = vextq_s8(v113, v113, 8uLL).u64[0];
          v119.f64[1] = v112.f64[1];
          v117 = *(double *)v113.i64 * (v116 - *(double *)v105.i64 * (v109.f64[1] + 0.01))
               + (*(double *)v106.i64 + 0.01) * ((v109.f64[1] + 0.01) * (v112.f64[0] + 0.01) - v114)
               - v109.f64[0] * (*(double *)&v106.i64[1] * (v112.f64[0] + 0.01) - v115);
          v180 = v120;
          *(_OWORD *)__src.columns[0].f64 = v121;
          v177 = v119;
        }
        else
        {
          *(int8x16_t *)__src.columns[0].f64 = v113;
          *(int8x16_t *)&__src.columns[0].f64[2] = v106;
          v173 = v108;
          v175 = v105;
          v177 = v112;
          v180 = v109;
        }
        *(double *)(*((_QWORD *)this + 25) + 8 * v88) = v117;
        v122 = 1.0 / sqrt(v117);
        *(long double *)(*((_QWORD *)this + 27) + 8 * v88) = v122;
        v123 = log(v122);
        *(long double *)(*((_QWORD *)this + 29) + 8 * v88) = v123 + v123;
        v183 = *(_OWORD *)&__src.columns[0].f64[2];
        v184 = v175;
        v185 = v180;
        v186 = v173;
        v187 = *(_OWORD *)__src.columns[0].f64;
        v188 = v177;
        __invert_d3();
        memmove((void *)(*((_QWORD *)this + 23) + v87), v182, 0x60uLL);
      }
      if (*((_BYTE *)this + 16))
      {
        v124 = *(_QWORD *)(*((_QWORD *)this + 45) + 8 * v88);
        if (v124)
        {
          v125 = *((_QWORD *)this + 39);
          v126 = (float64x2_t *)(v125 + 32 * v86);
          v16.f64[0] = (double)v124;
          v127 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v124), 0);
          v128 = *(float32x4_t *)(*((_QWORD *)this + 22) + 16 * v88);
          v129 = vcvt_hight_f64_f32(v128);
          v130 = vcvtq_f64_f32(*(float32x2_t *)v128.f32);
          v17.f64[0] = v128.f32[0];
          v131 = vmulq_f64(v17, v129);
          v132 = (int8x16_t)vsubq_f64(vdivq_f64(v126[1], v16), v131);
          v133 = (int8x16_t)vsubq_f64(vdivq_f64(*v126, v127), vmulq_n_f64(v130, v128.f32[0]));
          v134 = (float64x2_t *)(v125 + 32 * (v86 + 1));
          v131.f64[0] = COERCE_FLOAT(HIDWORD(*(_QWORD *)(*((_QWORD *)this + 22) + 16 * v88)));
          v135 = (int8x16_t)vsubq_f64(vdivq_f64(v134[1], v16), vmulq_f64(v131, v129));
          v136 = vsubq_f64(vdivq_f64(*v134, v127), vmulq_n_f64(v130, v131.f64[0]));
          v137 = (float64x2_t *)(v125 + 32 * (v86 + 2));
          v138 = vdivq_f64(v137[1], v16);
          v16.f64[0] = COERCE_FLOAT(*(_QWORD *)(*((_QWORD *)this + 22) + 16 * v88 + 8));
          v139 = vsubq_f64(v138, vmulq_f64(v16, v129));
          v140 = (int8x16_t)vsubq_f64(vdivq_f64(*v137, v127), vmulq_n_f64(v130, v16.f64[0]));
          v141 = vmuld_lane_f64(*(double *)v135.i64, (float64x2_t)v140, 1);
          v142 = vmuld_lane_f64(*(double *)v132.i64, (float64x2_t)v140, 1);
          v143 = vmuld_lane_f64(*(double *)v135.i64, (float64x2_t)v133, 1);
          v93 = (v143 - vmuld_lane_f64(*(double *)v132.i64, v136, 1)) * *(double *)v140.i64
              + (vmuld_lane_f64(v139.f64[0], v136, 1) - v141) * *(double *)v133.i64
              - (vmuld_lane_f64(v139.f64[0], (float64x2_t)v133, 1) - v142) * v136.f64[0];
          if (v93 <= 2.22044605e-16)
          {
            *(double *)v89.i64 = *(double *)v133.i64 + 0.01;
            v89.i64[1] = vextq_s8(v133, v133, 8uLL).u64[0];
            *(int8x16_t *)&__src.columns[0].f64[2] = v89;
            v90.f64[0] = v139.f64[0] + 0.01;
            v89.i64[0] = v132.i64[0];
            v89.i64[1] = vextq_s8(v132, v132, 8uLL).u64[0];
            v91.f64[0] = v136.f64[0];
            v91.f64[1] = v136.f64[1] + 0.01;
            v135.i64[1] = vextq_s8(v135, v135, 8uLL).u64[0];
            v172 = v135;
            v174 = v89;
            *(_QWORD *)&v92 = v140.i64[0];
            *((_QWORD *)&v92 + 1) = vextq_s8(v140, v140, 8uLL).u64[0];
            v90.f64[1] = v139.f64[1];
            v93 = *(double *)v140.i64 * (v143 - *(double *)v132.i64 * (v136.f64[1] + 0.01))
                + (*(double *)v133.i64 + 0.01) * ((v136.f64[1] + 0.01) * (v139.f64[0] + 0.01) - v141)
                - v136.f64[0] * (*(double *)&v133.i64[1] * (v139.f64[0] + 0.01) - v142);
            v179 = v91;
            *(_OWORD *)__src.columns[0].f64 = v92;
            v176 = v90;
          }
          else
          {
            *(int8x16_t *)__src.columns[0].f64 = v140;
            *(int8x16_t *)&__src.columns[0].f64[2] = v133;
            v172 = v135;
            v174 = v132;
            v176 = v139;
            v179 = v136;
          }
          *(double *)(*((_QWORD *)this + 26) + 8 * v88) = v93;
          v94 = 1.0 / sqrt(v93);
          *(long double *)(*((_QWORD *)this + 28) + 8 * v88) = v94;
          v95 = log(v94);
          *(long double *)(*((_QWORD *)this + 30) + 8 * v88) = v95 + v95;
          v183 = *(_OWORD *)&__src.columns[0].f64[2];
          v184 = v174;
          v185 = v179;
          v186 = v172;
          v187 = *(_OWORD *)__src.columns[0].f64;
          v188 = v176;
          __invert_d3();
          memmove((void *)(*((_QWORD *)this + 24) + v87), &__src.columns[1], 0x60uLL);
        }
      }
      ++v88;
      v96 = *((_QWORD *)this + 20);
      v87 += 96;
      v86 += 3;
    }
    while (v96 > v88);
    v144 = v170;
    v145 = v171;
    v146 = v167;
    if (v167 && v96)
    {
      for (k = 0; k < v96; ++k)
      {
        v148 = *(float32x4_t *)(*((_QWORD *)this + 21) + 16 * k);
        v148.i32[3] = 0;
        v149 = vmaxnmq_f32(v148, (float32x4_t)0);
        v149.i32[3] = 0;
        v150 = vcvtq_s32_f32(vminnmq_f32(v149, (float32x4_t)xmmword_1B3524BB0));
        v146[1] = v150.i8[4];
        v146[2] = v150.i8[8];
        *v146 = v150.i8[0];
        v96 = *((_QWORD *)this + 20);
        v146 += 4;
      }
    }
  }
  else
  {
    v96 = 0;
    v144 = v170;
    v145 = v171;
  }
  if (v144 && v96)
  {
    v151 = 0;
    v152 = *((_QWORD *)this + 44);
    do
    {
      *(_QWORD *)(v144 + 8 * v151) = *(_QWORD *)(v152 + 8 * v151);
      ++v151;
    }
    while (*((_QWORD *)this + 20) > v151);
  }
  if (v145 && *((_QWORD *)this + 11))
  {
    v153 = 0;
    v154 = 0;
    v155 = *((_QWORD *)this + 10);
    do
    {
      memcpy(v145, (const void *)(*((_QWORD *)this + 7) + v153), v155);
      ++v154;
      v153 += v155;
      v145 += a11;
    }
    while (*((_QWORD *)this + 11) > v154);
  }
  if (*((_BYTE *)this + 16))
  {
    v156 = a5;
    if (a5 && *((_QWORD *)this + 20))
    {
      v157 = 0;
      do
      {
        v158 = *(float32x4_t *)(*((_QWORD *)this + 22) + 16 * v157);
        v158.i32[3] = 0;
        v159 = vmaxnmq_f32(v158, (float32x4_t)0);
        v159.i32[3] = 0;
        v160 = vcvtq_s32_f32(vminnmq_f32(v159, (float32x4_t)xmmword_1B3524BB0));
        v156[1] = v160.i8[4];
        v156[2] = v160.i8[8];
        *v156 = v160.i8[0];
        ++v157;
        v156 += 4;
      }
      while (*((_QWORD *)this + 20) > v157);
    }
    v161 = __dst;
    if (a7 && *((_QWORD *)this + 20))
    {
      v162 = 0;
      v163 = *((_QWORD *)this + 45);
      do
      {
        *(_QWORD *)(a7 + 8 * v162) = *(_QWORD *)(v163 + 8 * v162);
        ++v162;
      }
      while (*((_QWORD *)this + 20) > v162);
    }
    if (__dst && *((_QWORD *)this + 11))
    {
      v164 = 0;
      v165 = 0;
      v166 = *((_QWORD *)this + 10);
      do
      {
        memcpy(v161, (const void *)(*((_QWORD *)this + 8) + v164), v166);
        ++v165;
        v164 += v166;
        v161 += a11;
      }
      while (*((_QWORD *)this + 11) > v165);
    }
  }
  return 0;
}

uint64_t soKMeansClassifier::UpdateClusters(soKMeansClassifier *this, unsigned __int8 *__src, uint64_t a3)
{
  unint64_t v4;
  size_t v5;
  uint64_t v8;
  unint64_t v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  size_t v14;
  uint64_t v15;
  pthread_t *v16;
  unint64_t v17;
  size_t v18;
  _QWORD *v19;
  __int128 v20;
  uint64_t v21;
  __int128 v22;
  unint64_t v23;
  unint64_t i;
  unint64_t v25;
  BOOL v26;
  uint64_t v27;
  __int128 v28;
  float64x2_t v29;
  float64x2_t v30;
  void *v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  float64x2_t v35;
  float64x2_t v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  unint64_t v40;
  int8x16_t v41;
  float64x2_t v42;
  float64x2_t v43;
  __int128 v44;
  double v45;
  uint64_t v46;
  long double v47;
  long double v48;
  unint64_t v49;
  uint64_t v50;
  float64x2_t *v51;
  float64x2_t v52;
  float32x4_t v53;
  float64x2_t v54;
  float64x2_t v55;
  float64x2_t v56;
  int8x16_t v57;
  int8x16_t v58;
  float64x2_t *v59;
  int8x16_t v60;
  float64x2_t v61;
  float64x2_t *v62;
  float64x2_t v63;
  float64x2_t v64;
  int8x16_t v65;
  double v66;
  double v67;
  double v68;
  double v69;
  int8x16_t v70;
  float64x2_t v71;
  float64x2_t v72;
  __int128 v73;
  uint64_t v74;
  long double v75;
  long double v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  float64x2_t *v80;
  float64x2_t v81;
  float32x4_t v82;
  float64x2_t v83;
  float64x2_t v84;
  float64x2_t v85;
  int8x16_t v86;
  int8x16_t v87;
  float64x2_t *v88;
  int8x16_t v89;
  float64x2_t v90;
  float64x2_t *v91;
  float64x2_t v92;
  float64x2_t v93;
  int8x16_t v94;
  double v95;
  double v96;
  double v97;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t j;
  uint64_t v104;
  float64x2_t *v105;
  float64x2_t *v106;
  float64x2_t v107;
  uint64_t v108;
  float64x2_t *v109;
  float64x2_t *v110;
  float64x2_t v111;
  uint64_t v112;
  float64x2_t *v113;
  float64x2_t *v114;
  float64x2_t v115;
  uint64_t v116;
  float64x2_t *v117;
  float64x2_t *v118;
  float64x2_t v119;
  uint64_t v120;
  float64x2_t *v121;
  float64x2_t *v122;
  float64x2_t v123;
  uint64_t v124;
  float64x2_t *v125;
  float64x2_t *v126;
  float64x2_t v127;
  uint64_t v128;
  float64x2_t *v129;
  float64x2_t *v130;
  float64x2_t v131;
  uint64_t v132;
  float64x2_t *v133;
  float64x2_t *v134;
  float64x2_t v135;
  int8x16_t v136;
  int8x16_t v137;
  int8x16_t v138;
  int8x16_t v139;
  float64x2_t v140;
  float64x2_t v141;
  float64x2_t v142;
  float64x2_t v143;
  simd_double3x3 __srca;
  char v145[96];
  __int128 v146;
  int8x16_t v147;
  float64x2_t v148;
  int8x16_t v149;
  __int128 v150;
  float64x2_t v151;

  v5 = *((_QWORD *)this + 10);
  v4 = *((_QWORD *)this + 11);
  if (v4)
  {
    v8 = 0;
    v9 = 0;
    do
    {
      memcpy((void *)(*((_QWORD *)this + 6) + v8), __src, v5);
      ++v9;
      v4 = *((_QWORD *)this + 11);
      __src += a3;
      v8 += v5;
    }
    while (v4 > v9);
    v5 = *((_QWORD *)this + 10);
  }
  v10 = v5 * v4;
  memset(*((void **)this + 7), 255, v5 * v4);
  memset(*((void **)this + 8), 255, v10);
  bzero(*((void **)this + 46), 8 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
  bzero(*((void **)this + 34), 32 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
  bzero(*((void **)this + 40), 96 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
  if (*((_BYTE *)this + 16))
  {
    bzero(*((void **)this + 47), 8 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
    bzero(*((void **)this + 35), 32 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
    bzero(*((void **)this + 41), 96 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
  }
  if (*((_QWORD *)this + 1) < 2uLL)
  {
    v27 = operator new();
    *(_QWORD *)v27 = this;
    *(_QWORD *)(v27 + 8) = 0;
    *(_QWORD *)(v27 + 16) = v10;
    *(_QWORD *)(v27 + 24) = 0;
    v28 = *((_OWORD *)this + 17);
    *(_OWORD *)(v27 + 32) = *((_OWORD *)this + 23);
    *(_OWORD *)(v27 + 48) = v28;
    *(_OWORD *)(v27 + 64) = *((_OWORD *)this + 20);
    RefitToClusters((char *)v27);
  }
  else
  {
    v11 = operator new[]();
    v12 = v11;
    v13 = *((_QWORD *)this + 1);
    v14 = v10 / v13;
    if (v13 >= 2)
    {
      v15 = 0;
      v16 = (pthread_t *)(v11 + 8);
      v17 = 1;
      v18 = v10 / v13;
      do
      {
        v15 += v14;
        if (v17 == v13 - 1)
          v18 = v10;
        else
          v18 += v14;
        v19 = (_QWORD *)operator new();
        *v19 = this;
        v19[1] = v15;
        v19[2] = v18;
        v19[3] = v17;
        v20 = *((_OWORD *)this + 17);
        *((_OWORD *)v19 + 2) = *((_OWORD *)this + 23);
        *((_OWORD *)v19 + 3) = v20;
        *((_OWORD *)v19 + 4) = *((_OWORD *)this + 20);
        pthread_create(v16, 0, (void *(__cdecl *)(void *))RefitToClusters, v19);
        ++v17;
        v13 = *((_QWORD *)this + 1);
        ++v16;
      }
      while (v13 > v17);
    }
    v21 = operator new();
    *(_QWORD *)v21 = this;
    *(_QWORD *)(v21 + 8) = 0;
    *(_QWORD *)(v21 + 16) = v14;
    *(_QWORD *)(v21 + 24) = 0;
    v22 = *((_OWORD *)this + 17);
    *(_OWORD *)(v21 + 32) = *((_OWORD *)this + 23);
    *(_OWORD *)(v21 + 48) = v22;
    *(_OWORD *)(v21 + 64) = *((_OWORD *)this + 20);
    RefitToClusters((char *)v21);
    v23 = *((_QWORD *)this + 1);
    if (v23 >= 2)
    {
      for (i = 1; i < v23; ++i)
      {
        pthread_join(*(pthread_t *)(v12 + 8 * i), 0);
        v23 = *((_QWORD *)this + 1);
      }
    }
    v25 = *((_QWORD *)this + 20);
    if (v25)
      v26 = v23 >= 2;
    else
      v26 = 0;
    if (v26)
    {
      v99 = 0;
      do
      {
        if (v23 >= 2)
        {
          v100 = (3 * v99);
          v101 = (v100 + 1);
          v102 = (v100 + 2);
          for (j = 1; j < v23; ++j)
          {
            v104 = *((_QWORD *)this + 34);
            v105 = (float64x2_t *)(v104 + 32 * (v99 + *((_QWORD *)this + 20) * j));
            v106 = (float64x2_t *)(v104 + 32 * v99);
            v107 = vaddq_f64(v105[1], v106[1]);
            *v106 = vaddq_f64(*v105, *v106);
            v106[1] = v107;
            *(_QWORD *)(*((_QWORD *)this + 46) + 8 * v99) += *(_QWORD *)(*((_QWORD *)this + 46)
                                                                       + 8 * (v99 + *((_QWORD *)this + 20) * j));
            if (*((_BYTE *)this + 16))
            {
              v108 = *((_QWORD *)this + 35);
              if (v108)
              {
                v109 = (float64x2_t *)(v108 + 32 * (v99 + *((_QWORD *)this + 20) * j));
                v110 = (float64x2_t *)(v108 + 32 * v99);
                v111 = vaddq_f64(v109[1], v110[1]);
                *v110 = vaddq_f64(*v109, *v110);
                v110[1] = v111;
                *(_QWORD *)(*((_QWORD *)this + 47) + 8 * v99) += *(_QWORD *)(*((_QWORD *)this + 47)
                                                                           + 8 * (v99 + *((_QWORD *)this + 20) * j));
              }
            }
            v112 = *((_QWORD *)this + 40);
            v113 = (float64x2_t *)(v112 + 96 * (v99 + *((_QWORD *)this + 20) * j));
            v114 = (float64x2_t *)(v112 + 32 * v100);
            v115 = vaddq_f64(v113[1], v114[1]);
            *v114 = vaddq_f64(*v113, *v114);
            v114[1] = v115;
            v116 = *((_QWORD *)this + 40);
            v117 = (float64x2_t *)(v116 + 96 * (v99 + *((_QWORD *)this + 20) * j));
            v118 = (float64x2_t *)(v116 + 32 * v101);
            v119 = vaddq_f64(v117[3], v118[1]);
            *v118 = vaddq_f64(v117[2], *v118);
            v118[1] = v119;
            v120 = *((_QWORD *)this + 40);
            v121 = (float64x2_t *)(v120 + 96 * (v99 + *((_QWORD *)this + 20) * j));
            v122 = (float64x2_t *)(v120 + 32 * v102);
            v123 = vaddq_f64(v121[5], v122[1]);
            *v122 = vaddq_f64(v121[4], *v122);
            v122[1] = v123;
            if (*((_BYTE *)this + 16))
            {
              v124 = *((_QWORD *)this + 41);
              if (v124)
              {
                v125 = (float64x2_t *)(v124 + 96 * (v99 + *((_QWORD *)this + 20) * j));
                v126 = (float64x2_t *)(v124 + 32 * v100);
                v127 = vaddq_f64(v125[1], v126[1]);
                *v126 = vaddq_f64(*v125, *v126);
                v126[1] = v127;
                v128 = *((_QWORD *)this + 41);
                v129 = (float64x2_t *)(v128 + 96 * (v99 + *((_QWORD *)this + 20) * j));
                v130 = (float64x2_t *)(v128 + 32 * v101);
                v131 = vaddq_f64(v129[3], v130[1]);
                *v130 = vaddq_f64(v129[2], *v130);
                v130[1] = v131;
                v132 = *((_QWORD *)this + 41);
                v133 = (float64x2_t *)(v132 + 96 * (v99 + *((_QWORD *)this + 20) * j));
                v134 = (float64x2_t *)(v132 + 32 * v102);
                v135 = vaddq_f64(v133[5], v134[1]);
                *v134 = vaddq_f64(v133[4], *v134);
                v134[1] = v135;
              }
            }
            v23 = *((_QWORD *)this + 1);
          }
          v25 = *((_QWORD *)this + 20);
        }
        ++v99;
      }
      while (v25 > v99);
    }
    MEMORY[0x1B5E2914C](v12, 0x20C8093837F09);
  }
  memcpy(*((void **)this + 44), *((const void **)this + 46), 8 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
  memcpy(*((void **)this + 32), *((const void **)this + 34), 32 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
  memcpy(*((void **)this + 38), *((const void **)this + 40), 96 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
  if (*((_BYTE *)this + 16))
  {
    v31 = (void *)*((_QWORD *)this + 45);
    if (v31)
    {
      memcpy(v31, *((const void **)this + 47), 8 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
      memcpy(*((void **)this + 33), *((const void **)this + 35), 32 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
      memcpy(*((void **)this + 39), *((const void **)this + 41), 96 * *((_QWORD *)this + 20) * *((_QWORD *)this + 1));
    }
  }
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 18) = 0;
  if (*((_QWORD *)this + 20))
  {
    v32 = 0;
    do
    {
      v34 = *((_QWORD *)this + 32) + 32 * v32;
      v35 = *(float64x2_t *)(v34 + 16);
      v29.f64[0] = (double)*(unint64_t *)(*((_QWORD *)this + 44) + 8 * v32);
      v36 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v29.f64[0], 0);
      v29 = vdivq_f64(v35, v29);
      *(float32x4_t *)(*((_QWORD *)this + 21) + 16 * v32) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(*(float64x2_t *)v34, v36)), v29);
      *((_QWORD *)this + 17) += *(_QWORD *)(*((_QWORD *)this + 44) + 8 * v32);
      if (*((_BYTE *)this + 16))
      {
        v37 = *((_QWORD *)this + 45);
        if (v37)
        {
          v35.f64[0] = (double)*(unint64_t *)(v37 + 8 * v32);
          v29 = (float64x2_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(*(float64x2_t *)(*((_QWORD *)this + 33) + 32 * v32), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v35.f64[0], 0))), vdivq_f64(*(float64x2_t *)(*((_QWORD *)this + 33) + 32 * v32 + 16), v35));
          *(float64x2_t *)(*((_QWORD *)this + 22) + 16 * v32) = v29;
          *((_QWORD *)this + 18) += *(_QWORD *)(*((_QWORD *)this + 45) + 8 * v32);
        }
      }
      ++v32;
      v33 = *((_QWORD *)this + 20);
    }
    while (v33 > v32);
    if (v33)
    {
      v38 = 0;
      v39 = 0;
      v40 = 0;
      do
      {
        v49 = *(_QWORD *)(*((_QWORD *)this + 44) + 8 * v40);
        if (v49)
        {
          v50 = *((_QWORD *)this + 38);
          v51 = (float64x2_t *)(v50 + 32 * v38);
          v35.f64[0] = (double)v49;
          v52 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v49), 0);
          v53 = *(float32x4_t *)(*((_QWORD *)this + 21) + 16 * v40);
          v54 = vcvt_hight_f64_f32(v53);
          v55 = vcvtq_f64_f32(*(float32x2_t *)v53.f32);
          v30.f64[0] = v53.f32[0];
          v56 = vmulq_f64(v30, v54);
          v57 = (int8x16_t)vsubq_f64(vdivq_f64(v51[1], v35), v56);
          v58 = (int8x16_t)vsubq_f64(vdivq_f64(*v51, v52), vmulq_n_f64(v55, v53.f32[0]));
          v59 = (float64x2_t *)(v50 + 32 * (v38 + 1));
          v56.f64[0] = COERCE_FLOAT(HIDWORD(*(_QWORD *)(*((_QWORD *)this + 21) + 16 * v40)));
          v60 = (int8x16_t)vsubq_f64(vdivq_f64(v59[1], v35), vmulq_f64(v56, v54));
          v61 = vsubq_f64(vdivq_f64(*v59, v52), vmulq_n_f64(v55, v56.f64[0]));
          v62 = (float64x2_t *)(v50 + 32 * (v38 + 2));
          v63 = vdivq_f64(v62[1], v35);
          v35.f64[0] = COERCE_FLOAT(*(_QWORD *)(*((_QWORD *)this + 21) + 16 * v40 + 8));
          v64 = vsubq_f64(v63, vmulq_f64(v35, v54));
          v65 = (int8x16_t)vsubq_f64(vdivq_f64(*v62, v52), vmulq_n_f64(v55, v35.f64[0]));
          v66 = vmuld_lane_f64(*(double *)v60.i64, (float64x2_t)v65, 1);
          v67 = vmuld_lane_f64(*(double *)v57.i64, (float64x2_t)v65, 1);
          v68 = vmuld_lane_f64(*(double *)v60.i64, (float64x2_t)v58, 1);
          v69 = (v68 - vmuld_lane_f64(*(double *)v57.i64, v61, 1)) * *(double *)v65.i64
              + (vmuld_lane_f64(v64.f64[0], v61, 1) - v66) * *(double *)v58.i64
              - (vmuld_lane_f64(v64.f64[0], (float64x2_t)v58, 1) - v67) * v61.f64[0];
          if (v69 <= 2.22044605e-16)
          {
            *(double *)v70.i64 = *(double *)v58.i64 + 0.01;
            v70.i64[1] = vextq_s8(v58, v58, 8uLL).u64[0];
            *(int8x16_t *)&__srca.columns[0].f64[2] = v70;
            v71.f64[0] = v64.f64[0] + 0.01;
            v70.i64[0] = v57.i64[0];
            v70.i64[1] = vextq_s8(v57, v57, 8uLL).u64[0];
            v72.f64[0] = v61.f64[0];
            v72.f64[1] = v61.f64[1] + 0.01;
            v60.i64[1] = vextq_s8(v60, v60, 8uLL).u64[0];
            v137 = v60;
            v139 = v70;
            *(_QWORD *)&v73 = v65.i64[0];
            *((_QWORD *)&v73 + 1) = vextq_s8(v65, v65, 8uLL).u64[0];
            v71.f64[1] = v64.f64[1];
            v69 = *(double *)v65.i64 * (v68 - *(double *)v57.i64 * (v61.f64[1] + 0.01))
                + (*(double *)v58.i64 + 0.01) * ((v61.f64[1] + 0.01) * (v64.f64[0] + 0.01) - v66)
                - v61.f64[0] * (*(double *)&v58.i64[1] * (v64.f64[0] + 0.01) - v67);
            v143 = v72;
            *(_OWORD *)__srca.columns[0].f64 = v73;
            v141 = v71;
          }
          else
          {
            *(int8x16_t *)__srca.columns[0].f64 = v65;
            *(int8x16_t *)&__srca.columns[0].f64[2] = v58;
            v137 = v60;
            v139 = v57;
            v141 = v64;
            v143 = v61;
          }
          v74 = 8 * v40;
          *(double *)(*((_QWORD *)this + 25) + v74) = v69;
          v75 = 1.0 / sqrt(v69);
          *(long double *)(*((_QWORD *)this + 27) + v74) = v75;
          v76 = log(v75);
          *(long double *)(*((_QWORD *)this + 29) + 8 * v40) = v76 + v76;
          v146 = *(_OWORD *)&__srca.columns[0].f64[2];
          v147 = v139;
          v148 = v143;
          v149 = v137;
          v150 = *(_OWORD *)__srca.columns[0].f64;
          v151 = v141;
          __invert_d3();
          memmove((void *)(*((_QWORD *)this + 23) + v39), v145, 0x60uLL);
        }
        if (*((_BYTE *)this + 16))
        {
          v77 = *((_QWORD *)this + 45);
          if (v77)
          {
            v78 = *(_QWORD *)(v77 + 8 * v40);
            if (v78)
            {
              v79 = *((_QWORD *)this + 39);
              v80 = (float64x2_t *)(v79 + 32 * v38);
              v35.f64[0] = (double)v78;
              v81 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v78), 0);
              v82 = *(float32x4_t *)(*((_QWORD *)this + 22) + 16 * v40);
              v83 = vcvt_hight_f64_f32(v82);
              v84 = vcvtq_f64_f32(*(float32x2_t *)v82.f32);
              v30.f64[0] = v82.f32[0];
              v85 = vmulq_f64(v30, v83);
              v86 = (int8x16_t)vsubq_f64(vdivq_f64(v80[1], v35), v85);
              v87 = (int8x16_t)vsubq_f64(vdivq_f64(*v80, v81), vmulq_n_f64(v84, v82.f32[0]));
              v88 = (float64x2_t *)(v79 + 32 * (v38 + 1));
              v85.f64[0] = COERCE_FLOAT(HIDWORD(*(_QWORD *)(*((_QWORD *)this + 22) + 16 * v40)));
              v89 = (int8x16_t)vsubq_f64(vdivq_f64(v88[1], v35), vmulq_f64(v85, v83));
              v90 = vsubq_f64(vdivq_f64(*v88, v81), vmulq_n_f64(v84, v85.f64[0]));
              v91 = (float64x2_t *)(v79 + 32 * (v38 + 2));
              v92 = vdivq_f64(v91[1], v35);
              v35.f64[0] = COERCE_FLOAT(*(_QWORD *)(*((_QWORD *)this + 22) + 16 * v40 + 8));
              v93 = vsubq_f64(v92, vmulq_f64(v35, v83));
              v94 = (int8x16_t)vsubq_f64(vdivq_f64(*v91, v81), vmulq_n_f64(v84, v35.f64[0]));
              v95 = vmuld_lane_f64(*(double *)v89.i64, (float64x2_t)v94, 1);
              v96 = vmuld_lane_f64(*(double *)v86.i64, (float64x2_t)v94, 1);
              v97 = vmuld_lane_f64(*(double *)v89.i64, (float64x2_t)v87, 1);
              v45 = (v97 - vmuld_lane_f64(*(double *)v86.i64, v90, 1)) * *(double *)v94.i64
                  + (vmuld_lane_f64(v93.f64[0], v90, 1) - v95) * *(double *)v87.i64
                  - (vmuld_lane_f64(v93.f64[0], (float64x2_t)v87, 1) - v96) * v90.f64[0];
              if (v45 <= 2.22044605e-16)
              {
                *(double *)v41.i64 = *(double *)v87.i64 + 0.01;
                v41.i64[1] = vextq_s8(v87, v87, 8uLL).u64[0];
                *(int8x16_t *)&__srca.columns[0].f64[2] = v41;
                v42.f64[0] = v93.f64[0] + 0.01;
                v41.i64[0] = v86.i64[0];
                v41.i64[1] = vextq_s8(v86, v86, 8uLL).u64[0];
                v43.f64[0] = v90.f64[0];
                v43.f64[1] = v90.f64[1] + 0.01;
                v89.i64[1] = vextq_s8(v89, v89, 8uLL).u64[0];
                v136 = v89;
                v138 = v41;
                *(_QWORD *)&v44 = v94.i64[0];
                *((_QWORD *)&v44 + 1) = vextq_s8(v94, v94, 8uLL).u64[0];
                v42.f64[1] = v93.f64[1];
                v45 = *(double *)v94.i64 * (v97 - *(double *)v86.i64 * (v90.f64[1] + 0.01))
                    + (*(double *)v87.i64 + 0.01) * ((v90.f64[1] + 0.01) * (v93.f64[0] + 0.01) - v95)
                    - v90.f64[0] * (*(double *)&v87.i64[1] * (v93.f64[0] + 0.01) - v96);
                v142 = v43;
                *(_OWORD *)__srca.columns[0].f64 = v44;
                v140 = v42;
              }
              else
              {
                *(int8x16_t *)__srca.columns[0].f64 = v94;
                *(int8x16_t *)&__srca.columns[0].f64[2] = v87;
                v136 = v89;
                v138 = v86;
                v140 = v93;
                v142 = v90;
              }
              v46 = 8 * v40;
              *(double *)(*((_QWORD *)this + 26) + v46) = v45;
              v47 = 1.0 / sqrt(v45);
              *(long double *)(*((_QWORD *)this + 28) + v46) = v47;
              v48 = log(v47);
              *(long double *)(*((_QWORD *)this + 30) + 8 * v40) = v48 + v48;
              v146 = *(_OWORD *)&__srca.columns[0].f64[2];
              v147 = v138;
              v148 = v142;
              v149 = v136;
              v150 = *(_OWORD *)__srca.columns[0].f64;
              v151 = v140;
              __invert_d3();
              memmove((void *)(*((_QWORD *)this + 24) + v39), &__srca.columns[1], 0x60uLL);
            }
          }
        }
        ++v40;
        v39 += 96;
        v38 += 3;
      }
      while (*((_QWORD *)this + 20) > v40);
    }
  }
  return 0;
}

uint64_t std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  unint64_t v17;
  unsigned int v18;
  unsigned int v19;

  result = a3[1];
  if ((_DWORD)result != *a3)
  {
    v4 = result - *a3 + 1;
    if ((_DWORD)result - *a3 == -1)
    {
      v16 = *(_QWORD *)(a2 + 2496);
      v17 = (v16 + 1) % 0x270uLL;
      v18 = *(_DWORD *)(a2 + 4 * ((v16 + 397) % 0x270uLL)) ^ ((*(_DWORD *)(a2 + 4 * v17) & 0x7FFFFFFE | *(_DWORD *)(a2 + 4 * v16) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(a2 + 4 * v17) << 31) >> 31) & 0x9908B0DF;
      *(_DWORD *)(a2 + 4 * v16) = v18;
      *(_QWORD *)(a2 + 2496) = v17;
      v19 = ((v18 ^ (v18 >> 11)) << 7) & 0x9D2C5680 ^ v18 ^ (v18 >> 11);
      return (v19 << 15) & 0xEFC60000 ^ v19 ^ (((v19 << 15) & 0xEFC60000 ^ v19) >> 18);
    }
    else
    {
      v5 = __clz(v4);
      v6 = 31;
      if (((v4 << v5) & 0x7FFFFFFF) != 0)
        v6 = 32;
      v7 = v6 - v5;
      v8 = v7 >> 5;
      if ((v7 & 0x1F) != 0)
        ++v8;
      if (v8 <= v7)
        v9 = 0xFFFFFFFF >> -(v7 / v8);
      else
        v9 = 0;
      v10 = *(_QWORD *)(a2 + 2496);
      do
      {
        v11 = 4 * v10;
        v12 = v10 + 397;
        v10 = (v10 + 1) % 0x270;
        v13 = *(_DWORD *)(a2 + 4 * (v12 % 0x270)) ^ ((*(_DWORD *)(a2 + 4 * v10) & 0x7FFFFFFE | *(_DWORD *)(a2 + v11) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(a2 + 4 * v10) << 31) >> 31) & 0x9908B0DF;
        *(_DWORD *)(a2 + v11) = v13;
        v14 = ((v13 ^ (v13 >> 11)) << 7) & 0x9D2C5680 ^ v13 ^ (v13 >> 11);
        v15 = ((v14 << 15) & 0xEFC60000 ^ v14 ^ (((v14 << 15) & 0xEFC60000 ^ v14) >> 18)) & v9;
      }
      while (v15 >= v4);
      *(_QWORD *)(a2 + 2496) = v10;
      return *a3 + v15;
    }
  }
  return result;
}

HGFractured::Effect *HGFractured::Effect::Effect(HGFractured::Effect *this)
{
  uint64_t v2;
  uint64_t v8;
  uint64_t v9;
  HGSynchronizable *v10;

  HGObject::HGObject(this);
  *(_QWORD *)v2 = off_1E6531758;
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  __asm { FMOV            V8.2S, #1.0 }
  *(_QWORD *)(v2 + 32) = 0x100000001;
  *(_QWORD *)(v2 + 40) = _D8;
  *(_DWORD *)(v2 + 48) = 1065353216;
  *(_QWORD *)(v2 + 56) = 0;
  *(_QWORD *)(v2 + 64) = 0;
  *(_QWORD *)(v2 + 104) = 0;
  *(_QWORD *)(v2 + 112) = 0;
  *(_QWORD *)(v2 + 96) = 0;
  *((_QWORD *)this + 9) = HGRectMake4i(0, 0, 0, 0);
  *((_QWORD *)this + 10) = v8;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 15) = 0x400000007;
  *((_BYTE *)this + 128) = 0;
  *((_QWORD *)this + 28) = 0;
  *((_QWORD *)this + 29) = 0;
  *(_QWORD *)((char *)this + 132) = 1065353216;
  *((_DWORD *)this + 35) = 0;
  *((_WORD *)this + 72) = 0;
  *(_QWORD *)((char *)this + 148) = 0x400000003F800000;
  *((_WORD *)this + 78) = 0;
  *((_QWORD *)this + 20) = 0x400000000;
  *((_QWORD *)this + 21) = _D8;
  *((_DWORD *)this + 44) = 0;
  *((_QWORD *)this + 25) = 0x3F80000000000000;
  *(_QWORD *)((char *)this + 180) = HGRectMake4i(0, 0, 0, 0);
  *(_QWORD *)((char *)this + 188) = v9;
  *((_DWORD *)this + 49) = 1065353216;
  *((_DWORD *)this + 60) = 0;
  v10 = (HGSynchronizable *)operator new();
  HGSynchronizable::HGSynchronizable(v10);
  *((_QWORD *)this + 31) = v10;
  return this;
}

void sub_1B2B0294C(_Unwind_Exception *a1)
{
  HGObject *v1;
  uint64_t v2;
  uint64_t v3;

  v3 = v2;
  MEMORY[0x1B5E29170](v3, 0x10A1C40BBCAB520);
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void sub_1B2B0297C(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void sub_1B2B02990(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void sub_1B2B029A4(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGFractured::Effect::~Effect(HGFractured::Effect *this)
{
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;

  *(_QWORD *)this = off_1E6531758;
  v2 = (void *)*((_QWORD *)this + 7);
  if (v2)
    free(v2);
  v3 = (void *)*((_QWORD *)this + 12);
  if (v3)
    free(v3);
  v4 = (void *)*((_QWORD *)this + 13);
  if (v4)
    free(v4);
  v5 = *((_QWORD *)this + 31);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  HGObject::~HGObject(this);
}

{
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  void *v6;

  *(_QWORD *)this = off_1E6531758;
  v2 = (void *)*((_QWORD *)this + 7);
  if (v2)
    free(v2);
  v3 = (void *)*((_QWORD *)this + 12);
  if (v3)
    free(v3);
  v4 = (void *)*((_QWORD *)this + 13);
  if (v4)
    free(v4);
  v5 = *((_QWORD *)this + 31);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  HGObject::~HGObject(this);
  HGObject::operator delete(v6);
}

uint64_t HGFractured::Effect::SetLeftHand(uint64_t this, int a2)
{
  if (*(unsigned __int8 *)(this + 145) != a2)
  {
    *(_BYTE *)(this + 145) = a2;
    *(_DWORD *)(this + 120) |= 6u;
  }
  return this;
}

uint64_t HGFractured::Effect::SetRect(uint64_t this, HGRect a2)
{
  float v2;

  v2 = (float)(a2.var3 - a2.var1) / (float)(a2.var2 - a2.var0);
  if (*(float *)(this + 196) != v2)
  {
    *(float *)(this + 196) = v2;
    *(float *)(this + 132) = v2;
    *(_DWORD *)(this + 120) |= 7u;
  }
  *(HGRect *)(this + 72) = a2;
  *(HGRect *)(this + 180) = a2;
  return this;
}

uint64_t HGFractured::Effect::SetImageRect(uint64_t this, HGRect a2)
{
  float v2;

  v2 = (float)(a2.var3 - a2.var1) / (float)(a2.var2 - a2.var0);
  if (*(float *)(this + 132) != v2)
  {
    *(float *)(this + 44) = v2 / (float)*(unsigned int *)(this + 36);
    *(float *)(this + 132) = v2;
    *(_DWORD *)(this + 120) |= 7u;
  }
  *(HGRect *)(this + 180) = a2;
  return this;
}

float HGFractured::Effect::SetSubdivide(HGFractured::Effect *this, unsigned int a2, unsigned int a3)
{
  float result;
  float v4;

  if (*((_DWORD *)this + 8) != a2 || *((_DWORD *)this + 9) != a3)
  {
    *((_DWORD *)this + 8) = a2;
    *((_DWORD *)this + 9) = a3;
    result = 1.0 / (float)a2;
    v4 = *((float *)this + 33) / (float)a3;
    *((float *)this + 10) = result;
    *((float *)this + 11) = v4;
    *((_DWORD *)this + 30) |= 7u;
  }
  return result;
}

uint64_t HGFractured::Effect::SetShape(uint64_t this, int a2, float a3)
{
  if (*(_DWORD *)(this + 164) != a2 || *(float *)(this + 48) != a3)
  {
    *(_DWORD *)(this + 164) = a2;
    *(_BYTE *)(this + 157) = a2 == 0;
    *(float *)(this + 48) = a3;
    *(_DWORD *)(this + 120) |= 7u;
  }
  return this;
}

uint64_t HGFractured::Effect::SetExtrude(uint64_t this, float a2)
{
  float v2;

  v2 = fmaxf(a2, 0.0);
  if (*(float *)(this + 136) != v2)
  {
    *(_DWORD *)(this + 120) |= 7u;
    *(float *)(this + 136) = v2;
  }
  return this;
}

uint64_t HGFractured::Effect::SetScale(uint64_t this, float a2, float a3)
{
  if (*(float *)(this + 168) != a2 || *(float *)(this + 172) != a3)
  {
    *(float *)(this + 168) = a2;
    *(float *)(this + 172) = a3;
    *(_DWORD *)(this + 120) |= 7u;
  }
  return this;
}

uint64_t HGFractured::Effect::SetDual(uint64_t this, int a2, int a3)
{
  if (*(_DWORD *)(this + 140) != a2 || *(unsigned __int8 *)(this + 144) != a3)
  {
    *(_DWORD *)(this + 140) = a2;
    *(_BYTE *)(this + 144) = a3;
    *(_DWORD *)(this + 120) |= 6u;
  }
  return this;
}

uint64_t HGFractured::Effect::SetDelay(uint64_t this, float a2)
{
  float v2;

  v2 = fmaxf(a2, 0.0);
  if (*(float *)(this + 148) != v2)
  {
    *(float *)(this + 148) = v2;
    *(_DWORD *)(this + 120) |= 6u;
  }
  return this;
}

uint64_t HGFractured::Effect::SetOriginPoint(uint64_t this, float a2, float a3)
{
  *(float *)(this + 208) = a2;
  *(float *)(this + 212) = a3;
  *(_DWORD *)(this + 120) |= 7u;
  return this;
}

uint64_t HGFractured::Effect::SetImpulse(uint64_t this, float a2, float a3)
{
  *(float *)(this + 216) = a2;
  *(float *)(this + 220) = a3;
  *(_DWORD *)(this + 120) |= 7u;
  return this;
}

uint64_t HGFractured::Effect::SetMode(uint64_t this, int a2)
{
  void *v2;
  void *v3;

  switch(a2)
  {
    case 0:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::shatter;
      goto LABEL_20;
    case 1:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::blast;
      goto LABEL_20;
    case 2:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::crumble;
      goto LABEL_20;
    case 3:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::swipe;
      goto LABEL_20;
    case 4:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::vortex;
      goto LABEL_20;
    case 5:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::flip;
      goto LABEL_20;
    case 6:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::whirl;
      goto LABEL_20;
    case 7:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::shutter;
      goto LABEL_20;
    case 8:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::evaporate;
      goto LABEL_20;
    case 9:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::explode;
      goto LABEL_20;
    case 10:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::pulverize;
      goto LABEL_20;
    case 11:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::twirl;
      goto LABEL_20;
    case 12:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::spread;
      goto LABEL_20;
    case 13:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::rotate;
      goto LABEL_20;
    case 14:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::blocks;
      goto LABEL_20;
    case 15:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::bars;
      goto LABEL_20;
    case 16:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::cube;
      goto LABEL_20;
    case 17:
      v2 = *(void **)(this + 224);
      v3 = HGFractured::Effect::test;
LABEL_20:
      if (v2 != v3)
      {
        *(_QWORD *)(this + 224) = v3;
        *(_DWORD *)(this + 120) |= 7u;
      }
      break;
    default:
      return this;
  }
  return this;
}

uint64_t HGFractured::Effect::shatter(HGFractured::Effect *this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  LODWORD(a3) = *((_DWORD *)this + 37);
  if (*(float *)&a3 != 0.0)
  {
    *((_DWORD *)this + 37) = 0;
    *((_DWORD *)this + 30) |= 6u;
  }
  HGFractured::Effect::blast((void **)this, a2, a3, a4, a5, a6, a7);
  return 0;
}

uint64_t HGFractured::Effect::blast(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  char *v8;
  uint64_t v9;
  float32x2_t *v10;
  float32x2_t v11;
  int32x2_t v12;
  float32x2_t v13;
  float64x2_t v20;
  float32x2_t v21;
  float v22;
  float v23;
  float64x2_t v24;
  float32_t v25;
  float64x2_t v26;
  float32x2_t v27;
  float v28;
  float32x2_t v29;
  float v30;
  float32_t v31;

  HGFractured::Effect::build(this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  v8 = (char *)this[8];
  if (v8)
  {
    v9 = 8 * *((int *)this + 31) + 84;
    v10 = (float32x2_t *)((char *)this[7] + 36);
    v11 = 0;
    v12 = vdup_n_s32(0xFD43FDu);
    v13 = (float32x2_t)vdup_n_s32(0x33800000u);
    __asm
    {
      FMOV            V6.2D, #0.125
      FMOV            V7.2D, #1.0
    }
    v20 = (float64x2_t)vdupq_n_s64(0x3FB999999999999AuLL);
    v21 = 0;
    do
    {
      v22 = v10[-5].f32[1] - *((float *)this + 52);
      v23 = v10[-4].f32[0] - (float)(*((float *)this + 53) * *((float *)this + 33));
      v11 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x2B084300C39EC3, vcvt_n_s32_f32(v11, 0x18uLL), v12) & 0xFFFFFF00FFFFFFLL)), v13);
      v10[4] = 0;
      v10[5] = 0;
      v21 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x269EC3009E3779, vcvt_n_s32_f32(v21, 0x18uLL), (int32x2_t)0x343FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v13);
      v24 = vmulq_f64(vcvtq_f64_f32(vadd_f32(v21, (float32x2_t)0xBF000000BF000000)), _Q6);
      v25 = v24.f64[0] + v22;
      v26.f64[1] = *((float64_t *)&_Q7 + 1);
      v26.f64[0] = v23;
      v27 = vcvt_f32_f64(vaddq_f64(v24, v26));
      v10[-3].f32[1] = v25;
      v10[-2] = v27;
      v28 = (float)(v22 * v22) + (float)(v23 * v23);
      v10[2].f32[0] = (float)(vmuls_lane_f32(0.015625, v11, 1) + (float)(sqrtf(v28) * 0.5)) * *((float *)this + 37);
      v10[2].i32[1] = 1065353216;
      v29.i32[0] = *((_DWORD *)this + 54);
      v29.f32[1] = -*((float *)this + 55);
      v10[3] = vcvt_f32_f64(vmulq_f64(vcvtq_f64_f32(v29), v20));
      v29.f32[0] = vmuls_lane_f32(0.0, v27, 1);
      *(float *)v24.f64 = v29.f32[0] - v27.f32[0];
      v29.f32[0] = v25 - v29.f32[0];
      *(float *)v26.f64 = (float)(0.0 * v27.f32[0]) - (float)(v25 * 0.0);
      v30 = sqrtf((float)((float)(*(float *)v24.f64 * *(float *)v24.f64) + (float)(v29.f32[0] * v29.f32[0]))+ (float)(*(float *)v26.f64 * *(float *)v26.f64));
      *(float *)v24.f64 = *(float *)v24.f64 / v30;
      v29.f32[0] = v29.f32[0] / v30;
      *(float *)v26.f64 = *(float *)v26.f64 / v30;
      v10[-1].i32[1] = LODWORD(v24.f64[0]);
      v10->i32[0] = v29.i32[0];
      v10->i32[1] = LODWORD(v26.f64[0]);
      v31 = (vadd_f32(v11, v21).f32[0] * 0.25
           + (float)(1.0
                   - (float)((float)((float)(*(float *)v24.f64 * v25) + (float)(v29.f32[0] * v27.f32[0]))
                           + vmuls_lane_f32(*(float *)v26.f64, v27, 1))))
          * (float)((float)((float)(*((float *)this + 10) * *((float *)this + 11)) / (float)(v10[-4].f32[1] * 3.0))
                  + 0.75);
      v10[1].f32[0] = v31;
      v10[-1].f32[0] = 0.15 / sqrtf(v28 + 0.01);
      v10 = (float32x2_t *)((char *)v10 + v9);
      --v8;
    }
    while (v8);
  }
  return 0;
}

uint64_t HGFractured::Effect::crumble(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  char *v8;
  char *v9;
  uint64_t v10;
  float32x2_t *v11;
  float32x2_t v12;
  float v13;
  float32x2_t v14;
  float32x2_t v15;
  float v16;
  float v17;
  float32x2_t v18;
  int32x2_t v19;
  float *v20;
  float v21;
  float v22;
  float v23;

  HGFractured::Effect::build(this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  v8 = (char *)this[8];
  if (v8)
  {
    v9 = (char *)this[7];
    v10 = 8 * *((int *)this + 31) + 84;
    if (*((_BYTE *)this + 145))
    {
      v11 = (float32x2_t *)(v9 + 36);
      v12 = 0;
      v13 = 0.0;
      v14 = (float32x2_t)vdup_n_s32(0x33800000u);
      v15 = (float32x2_t)vdup_n_s32(0x3E4CCCCDu);
      do
      {
        v16 = v11[-5].f32[1];
        v17 = v11[-4].f32[0];
        v13 = (float)((214013 * vcvts_n_s32_f32(v13, 0x18uLL) + 2531011) & 0xFFFFFF) * 0.000000059605;
        *(float32x2_t *)((char *)&v11[-3] + 4) = 0;
        v11[4] = 0;
        v11[5] = 0;
        v11[-2].i32[1] = 1065353216;
        v11[2].f32[0] = *((float *)this + 37)
                      * (float)((float)((float)(v13 * 0.4)
                                      + (float)(fabsf(v16)
                                              + (float)(*((float *)this + 33)
                                                      - (float)((float)(*((float *)this + 33) * 0.5) - v17))))
                              / (float)(*((float *)this + 33) + 1.1));
        v11[2].i32[1] = 1065353216;
        v12 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0xC39EC3009E3779, vcvt_n_s32_f32(v12, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v14);
        v18 = vmul_f32(vadd_f32(v12, (float32x2_t)0xBF000000BF000000), v15);
        v19 = (int32x2_t)vmul_f32(v18, v18);
        *(float *)v19.i32 = sqrtf(*(float *)&v19.i32[1] + (float)(*(float *)v19.i32 + 1.0));
        v11[-1].f32[1] = -1.0 / *(float *)v19.i32;
        *v11 = vdiv_f32(v18, (float32x2_t)vdup_lane_s32(v19, 0));
        v11[-1].f32[0] = (float)(*((float *)this + 10) + *((float *)this + 11))
                       + (float)(*((float *)this + 10) + *((float *)this + 11));
        v11[1].i32[0] = 1082130432;
        v11 = (float32x2_t *)((char *)v11 + v10);
        --v8;
      }
      while (v8);
    }
    else
    {
      v20 = (float *)(v9 + 52);
      v21 = 0.0;
      do
      {
        v22 = *(v20 - 13);
        v23 = *(v20 - 12);
        v21 = (float)((214013 * vcvts_n_s32_f32(v21, 0x18uLL) + 2531011) & 0xFFFFFF) * 0.000000059605;
        *(_QWORD *)(v20 - 9) = 0;
        *((_QWORD *)v20 + 2) = 0;
        *((_QWORD *)v20 + 3) = 0;
        *(v20 - 7) = 1.0;
        *v20 = *((float *)this + 37)
             * (float)((float)((float)(v21 * 0.4)
                             + (float)(fabsf(v22) + (float)((float)(*((float *)this + 33) * 0.5) - v23)))
                     / (float)(*((float *)this + 33) + 1.1));
        v20[1] = 1.0;
        *(v20 - 6) = (float)(*((float *)this + 10) + *((float *)this + 11))
                   + (float)(*((float *)this + 10) + *((float *)this + 11));
        *(_OWORD *)(v20 - 5) = xmmword_1B3524CF0;
        v20 = (float *)((char *)v20 + v10);
        --v8;
      }
      while (v8);
    }
  }
  return 0;
}

uint64_t HGFractured::Effect::swipe(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  int32x2_t v8;
  char *v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;

  HGFractured::Effect::build(this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  v9 = (char *)this[8];
  if (v9)
  {
    v10 = -0.5;
    if (!*((_BYTE *)this + 145))
      v10 = 0.5;
    v11 = 8 * *((int *)this + 31) + 84;
    v12 = (uint64_t)this[7] + 40;
    v13 = 0;
    v14 = (float32x2_t)vdup_n_s32(0x33800000u);
    do
    {
      v15 = *(float *)(v12 - 40);
      v8.i32[0] = *(_DWORD *)(v12 - 36);
      v13 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x2B084300269EC3, vcvt_n_s32_f32(v13, 0x18uLL), (int32x2_t)0xFD43FD000343FDLL) & 0xFFFFFF00FFFFFFLL)), v14);
      *(_QWORD *)(v12 + 36) = 0;
      *(_QWORD *)(v12 + 28) = 0;
      *(_DWORD *)(v12 - 24) = 1065353216;
      *(float *)v8.i32 = *(float *)v8.i32 + v10;
      v16 = *((float *)this + 10) + *((float *)this + 11);
      v17 = sqrtf((float)(v16 * v16) + (float)((float)(*(float *)v8.i32 * *(float *)v8.i32) + 1.0));
      *(float *)(v12 - 24) = 1.0 / v17;
      *(_DWORD *)(v12 - 20) = v8.i32[0];
      *(float *)(v12 - 20) = *(float *)v8.i32 / v17;
      *(float *)(v12 - 16) = v16 / v17;
      *(float *)(v12 + 12) = (float)(0.05 * v13.f32[0]) + (float)((float)(v15 + 0.5) * 0.5);
      *(_QWORD *)(v12 + 16) = 1065353216;
      *(_DWORD *)(v12 + 24) = 0;
      *(float *)v8.i32 = sqrtf(vmuls_lane_f32(v13.f32[1], v13, 1) + 1.0);
      v18 = v13.f32[1] / *(float *)v8.i32;
      v8 = (int32x2_t)vdiv_f32((float32x2_t)0x3F80000000000000, (float32x2_t)vdup_lane_s32(v8, 0));
      *(int32x2_t *)(v12 - 8) = v8;
      *(float *)v12 = v18;
      v19 = (float)(*((float *)this + 10) * *((float *)this + 11)) / (float)(*(float *)(v12 - 32) * 4.0);
      *(float *)(v12 - 12) = v19 + 1.0;
      *(float *)(v12 + 4) = v19 + 4.0;
      v12 += v11;
      --v9;
    }
    while (v9);
  }
  return 0;
}

float *(*HGFractured::Effect::vortex(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7))(float *this, HGFractured::Effect *a2, __n128 a3, int a4, __n128 a5, double a6, float32x4_t a7, float32x4_t a8, float32x4_t a9, double a10, double a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  __int128 v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  int32x2_t v19;
  int32x2_t v20;
  float32x2_t v21;
  __int128 v23;
  float32x2_t v24;

  HGFractured::Effect::build(this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 1088421888;
  v9 = (char *)this[8];
  if (v9)
  {
    v10 = 8 * *((int *)this + 31) + 84;
    v11 = (uint64_t)this[7] + 36;
    v12 = 0;
    v13 = (float32x2_t)vdup_n_s32(0x33800000u);
    do
    {
      LODWORD(v8) = *(_DWORD *)(v11 - 36);
      v14 = *(float *)(v11 - 32);
      v23 = v8;
      v24 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x2B084300269EC3, vcvt_n_s32_f32(v12, 0x18uLL), (int32x2_t)0xFD43FD000343FDLL) & 0xFFFFFF00FFFFFFLL)), v13);
      *(_QWORD *)(v11 + 32) = 0;
      *(_QWORD *)(v11 + 40) = 0;
      v15 = (float)(*(float *)&v8 * *(float *)&v8) + (float)(v14 * v14);
      v16 = sqrtf(v15) * 10.0;
      v17 = atan2f(v14, *(float *)&v8);
      if (v17 < 0.0)
        v17 = 6.2832 - v17;
      v18 = fmodf(v24.f32[0] + v17, 6.2832);
      v8 = v23;
      v12 = v24;
      *(float *)(v11 + 16) = vmuls_lane_f32(0.05, v24, 1) + (float)((float)((float)(v16 * 6.2832) + v18) / 62.832);
      *(_QWORD *)(v11 - 20) = 0x41200000BE4CCCCDLL;
      *(_DWORD *)(v11 - 12) = -1071644672;
      *(_QWORD *)(v11 + 20) = 1065353216;
      *(_DWORD *)(v11 + 28) = 0;
      *(float *)v19.i32 = sqrtf(v15 + 0.01);
      *(float *)(v11 - 4) = v14 / *(float *)v19.i32;
      v20.i32[0] = 1036831949;
      v21 = (float32x2_t)vdup_lane_s32(v20, 0);
      v21.i32[0] = v23;
      *(float32x2_t *)v11 = vdiv_f32(v21, (float32x2_t)vdup_lane_s32(v19, 0));
      *(float *)v19.i32 = (float)((float)(*((float *)this + 10) * *((float *)this + 11)) / *(float *)(v11 - 28)) + 0.75;
      *(_DWORD *)(v11 - 8) = v19.i32[0];
      *(_DWORD *)(v11 + 8) = v19.i32[0];
      v11 += v10;
      --v9;
    }
    while (v9);
  }
  return HGFractured::Effect::apply_polar;
}

uint64_t HGFractured::Effect::flip(HGFractured::Effect *this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  uint64_t v8;
  uint64_t v9;
  float *v10;
  float v11;
  float v12;

  if (*((_DWORD *)this + 41) != 4 || (LODWORD(a3) = *((_DWORD *)this + 12), *(float *)&a3 != 0.0))
  {
    *((_DWORD *)this + 41) = 4;
    *((_BYTE *)this + 157) = 0;
    *((_DWORD *)this + 12) = 0;
    *((_DWORD *)this + 30) |= 7u;
  }
  HGFractured::Effect::build((void **)this, -1, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  v8 = *((_QWORD *)this + 8);
  if (v8)
  {
    v9 = 8 * *((int *)this + 31) + 84;
    v10 = (float *)(*((_QWORD *)this + 7) + 68);
    v11 = 0.0;
    do
    {
      v12 = *(v10 - 17);
      v11 = (float)((214013 * vcvts_n_s32_f32(v11, 0x18uLL) + 2531011) & 0xFFFFFF) * 0.000000059605;
      *(_QWORD *)(v10 - 11) = 0;
      *(_QWORD *)(v10 - 13) = 0;
      *(v10 - 9) = 0.0;
      *(_QWORD *)v10 = 0;
      *((_QWORD *)v10 + 1) = 0;
      *((_QWORD *)v10 - 4) = 1065353216;
      *(v10 - 6) = 1.0;
      *(v10 - 4) = (float)(v11 * 0.25) + (float)((float)(v12 + 0.5) * 0.25);
      *(_QWORD *)(v10 - 3) = 1056964608;
      *(v10 - 1) = 0.0;
      v10 = (float *)((char *)v10 + v9);
      --v8;
    }
    while (v8);
  }
  return 0;
}

float *(*HGFractured::Effect::whirl(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7))(float *result, float a2, int a3)
{
  char *v8;
  char *v9;
  uint64_t v10;
  char *v11;
  int v12;
  float v13;
  __double2 v14;
  float v15;
  float v16;

  HGFractured::Effect::build(this, 1, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  v8 = (char *)this[8];
  if (v8)
  {
    v9 = (char *)this[7];
    v10 = 8 * *((int *)this + 31) + 84;
    v11 = v9 + 44;
    do
    {
      v12 = *((_DWORD *)v11 - 10);
      if ((*((_DWORD *)v11 - 8) & 4) != 0)
        v13 = -1.0;
      else
        v13 = 1.0;
      v14 = __sincos_stret(*((float *)v11 - 11) * 3.14159265);
      v15 = v14.__sinval * 0.5;
      *((_QWORD *)v11 + 3) = 0;
      *((_QWORD *)v11 + 4) = 0;
      *((float *)v11 - 7) = v15;
      *((_DWORD *)v11 - 6) = v12;
      v16 = v14.__cosval * (float)(v13 * 0.5);
      *((float *)v11 - 5) = v16;
      *((_OWORD *)v11 - 1) = xmmword_1B3053410;
      *(float *)v11 = v13;
      *(_OWORD *)(v11 + 8) = xmmword_1B304F240;
      v11 += v10;
      --v8;
    }
    while (v8);
  }
  return apply_whirl;
}

uint64_t HGFractured::Effect::shutter(HGFractured::Effect *this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  uint64_t v8;
  uint64_t v9;
  float *v10;
  float v11;
  float v12;

  *((_DWORD *)this + 35) = -1;
  HGFractured::Effect::build((void **)this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  v8 = *((_QWORD *)this + 8);
  if (v8)
  {
    v9 = 8 * *((int *)this + 31) + 84;
    v10 = (float *)(*((_QWORD *)this + 7) + 80);
    if (*((_BYTE *)this + 145))
    {
      do
      {
        v11 = *((float *)this + 11) * -0.5;
        *(_QWORD *)(v10 - 3) = 0;
        *(v10 - 1) = v11;
        *v10 = 0.0;
        *(_OWORD *)(v10 - 7) = xmmword_1B304F240;
        *((_OWORD *)v10 - 4) = xmmword_1B304F250;
        *((_OWORD *)v10 - 3) = xmmword_1B3524D00;
        v10 = (float *)((char *)v10 + v9);
        --v8;
      }
      while (v8);
    }
    else
    {
      do
      {
        v12 = *((float *)this + 11) * -0.5;
        *(_QWORD *)(v10 - 3) = 0;
        *(v10 - 1) = v12;
        *v10 = 0.0;
        *(_OWORD *)(v10 - 7) = xmmword_1B304F240;
        *((_OWORD *)v10 - 4) = xmmword_1B304F250;
        *((_OWORD *)v10 - 3) = xmmword_1B3524D10;
        v10 = (float *)((char *)v10 + v9);
        --v8;
      }
      while (v8);
    }
  }
  return 0;
}

uint64_t HGFractured::Effect::evaporate(HGFractured::Effect *this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;

  HGFractured::Effect::build((void **)this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  v8 = *((_QWORD *)this + 8);
  if (v8)
  {
    v9 = *((unsigned __int8 *)this + 145);
    v10 = 8 * *((int *)this + 31) + 84;
    v11 = *((_QWORD *)this + 7) + 36;
    v12 = 0uLL;
    v13 = (float32x4_t)vdupq_n_s32(0x33800000u);
    do
    {
      v17 = *(float *)(v11 - 32);
      v12 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)(*(_OWORD *)&vmlaq_s32((int32x4_t)xmmword_1B3524D30, vcvtq_n_s32_f32(v12, 0x18uLL), (int32x4_t)xmmword_1B3524D20) & __PAIR128__(0xFFFFFF00FFFFFFLL, 0xFFFFFF00FFFFFFLL))), v13);
      v18 = (float)((float)(v12.f32[0] + -0.5) * 0.5) - *(float *)(v11 - 36);
      v19 = (float)((float)((float)(v12.f32[2] + v12.f32[1]) + -1.0) * 0.25) + v17;
      *(_QWORD *)(v11 + 32) = 0;
      *(_QWORD *)(v11 + 40) = 0;
      if ((*(_DWORD *)(v11 - 24) & 8) != 0)
        v20 = -0.25;
      else
        v20 = 0.25;
      v21 = sqrtf((float)((float)(v18 * v18) + (float)(v19 * v19)) + 0.0625);
      *(float *)(v11 - 20) = v18 / v21;
      *(float *)(v11 - 16) = v19 / v21;
      *(float *)(v11 - 12) = v20 / v21;
      *(_DWORD *)(v11 - 8) = 1065353216;
      *(_DWORD *)(v11 + 20) = 1065353216;
      v22 = vmuls_lane_f32(0.5, *(float32x2_t *)v12.f32, 1) + 0.0;
      v23 = vmuls_lane_f32(0.5, v12, 2);
      if (v9)
      {
        v14 = v17 + 0.5;
        v15 = -1.0 - v12.f32[0];
      }
      else
      {
        v14 = 0.5 - v17;
        v15 = v12.f32[0] + 1.0;
      }
      v16 = sqrtf((float)(v23 * v23) + (float)((float)(v15 * v15) + (float)(v22 * v22)));
      *(float *)(v11 + 16) = (float)((float)(v14 + vmuls_lane_f32(*((float *)this + 37), v12, 3))
                                   / (float)(*((float *)this + 37) + 1.0))
                           * 0.4;
      *(float *)(v11 - 4) = v15 / v16;
      *(float *)v11 = v22 / v16;
      *(float *)(v11 + 4) = v23 / v16;
      *(float *)(v11 + 8) = (float)(v12.f32[3]
                                  + (float)(*(float *)(v11 - 28) / (float)(*((float *)this + 10) * *((float *)this + 11))))
                          * 4.0;
      v11 += v10;
      --v8;
    }
    while (v8);
  }
  return 0;
}

uint64_t HGFractured::Effect::explode(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float v12;
  long double v13;
  double v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float32x4_t v23;
  float v24;
  long double v25;
  float32x4_t v27;
  float32x4_t v28;

  HGFractured::Effect::build(this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 1088421888;
  v8 = (char *)this[8];
  if (v8)
  {
    v9 = 8 * *((int *)this + 31) + 84;
    v10 = (uint64_t)this[7] + 36;
    v11 = 0uLL;
    v27 = (float32x4_t)vdupq_n_s32(0x33800000u);
    do
    {
      v21 = *(float *)(v10 - 36);
      v22 = *(float *)(v10 - 32);
      v23 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)(*(_OWORD *)&vmlaq_s32((int32x4_t)xmmword_1B3524D30, vcvtq_n_s32_f32(v11, 0x18uLL), (int32x4_t)xmmword_1B3524D20) & __PAIR128__(0xFFFFFF00FFFFFFLL, 0xFFFFFF00FFFFFFLL))), v27);
      *(_QWORD *)(v10 + 32) = 0;
      *(_QWORD *)(v10 + 40) = 0;
      v24 = (float)((float)(v23.f32[0] + -0.5) * 0.25) + v21;
      v28 = v23;
      if ((*(_BYTE *)(v10 - 24) & 8) != 0)
      {
        v24 = v24 * 16.0;
        v12 = (float)((float)((float)(v23.f32[1] + -0.5) * 0.25) + v22) * 16.0;
        v25 = cos(v21 * 3.14159265);
        v11 = v28;
        v14 = (float)((float)(v28.f32[2] + -0.5) * 0.25) + v25 * -4.0;
      }
      else
      {
        v12 = (float)((float)(v23.f32[1] + -0.5) * 0.25) + v22;
        v13 = cos(v21 * 3.14159265);
        v11 = v28;
        v14 = v13 + (float)((float)(v28.f32[2] + -0.5) * 0.25);
      }
      v15 = v14;
      *(float *)(v10 - 20) = v24;
      *(float *)(v10 - 16) = v12;
      *(float *)(v10 - 12) = v15;
      *(_DWORD *)(v10 - 8) = 1069547520;
      *(float *)(v10 + 16) = vmuls_lane_f32(*((float *)this + 37) * 0.5, v11, 3);
      *(_QWORD *)(v10 + 20) = 1065353216;
      *(_DWORD *)(v10 + 28) = 0;
      v16 = v15 * 0.0;
      v17 = v16 - v12;
      v18 = v24 - v16;
      v19 = (float)(v12 * 0.0) - (float)(v24 * 0.0);
      v20 = sqrtf((float)((float)(v17 * v17) + (float)(v18 * v18)) + (float)(v19 * v19));
      *(float *)(v10 - 4) = v17 / v20;
      *(float *)v10 = v18 / v20;
      *(float *)(v10 + 4) = v19 / v20;
      *(float *)(v10 + 8) = (float)((float)(*((float *)this + 10) * *((float *)this + 11)) * 4.0) / *(float *)(v10 - 28);
      v10 += v9;
      --v8;
    }
    while (v8);
  }
  return 0;
}

uint64_t HGFractured::Effect::pulverize(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v18;
  float32x2_t v19;
  int32x2_t v20;
  float32x2_t v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;

  HGFractured::Effect::build(this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 1084227584;
  v8 = (char *)this[8];
  if (v8)
  {
    v9 = 8 * *((int *)this + 31) + 84;
    v10 = (uint64_t)this[7] + 36;
    v11 = 0;
    v12 = (float32x2_t)vdup_n_s32(0x33800000u);
    __asm { FMOV            V16.2S, #4.0 }
    v18 = 0;
    do
    {
      v18 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x2B084300269EC3, vcvt_n_s32_f32(v18, 0x18uLL), (int32x2_t)0xFD43FD000343FDLL) & 0xFFFFFF00FFFFFFLL)), v12);
      v11 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0xC39EC3009E3779, vcvt_n_s32_f32(v11, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v12);
      v19 = vadd_f32(v11, (float32x2_t)0xBF000000BF000000);
      v20 = (int32x2_t)vmul_f32(v19, v19);
      *(float *)v20.i32 = sqrtf((float)((float)(v18.f32[0] + -0.5) * (float)(v18.f32[0] + -0.5))+ vaddv_f32((float32x2_t)v20));
      *(_QWORD *)(v10 + 32) = 0;
      *(_QWORD *)(v10 + 40) = 0;
      v21 = vmul_f32(vdiv_f32(v19, (float32x2_t)vdup_lane_s32(v20, 0)), _D16);
      v22 = (float)((float)(v18.f32[0] + -0.5) / *(float *)v20.i32) * 4.0;
      *(float32x2_t *)(v10 - 20) = v21;
      *(float *)(v10 - 12) = v22;
      *(_DWORD *)(v10 - 8) = 1065353216;
      v23 = v22 * 0.0;
      *(float *)v20.i32 = v23 - v21.f32[1];
      v24 = v21.f32[0] - v23;
      v21.f32[0] = vmuls_lane_f32(0.0, v21, 1) - (float)(0.0 * v21.f32[0]);
      v25 = *((float *)this + 37) * 0.5;
      *(_QWORD *)(v10 + 20) = 1065353216;
      *(_DWORD *)(v10 + 28) = 0;
      v26 = sqrtf((float)((float)(*(float *)v20.i32 * *(float *)v20.i32) + (float)(v24 * v24))+ (float)(v21.f32[0] * v21.f32[0]));
      *(float *)(v10 - 4) = *(float *)v20.i32 / v26;
      *(float *)v10 = v24 / v26;
      *(float *)(v10 + 4) = v21.f32[0] / v26;
      v21.f32[0] = *((float *)this + 10) * *((float *)this + 11);
      *(float *)(v10 + 16) = vmuls_lane_f32(v25, v18, 1);
      *(float *)(v10 + 8) = (float)(v21.f32[0] * 4.0) / *(float *)(v10 - 28);
      v10 += v9;
      --v8;
    }
    while (v8);
  }
  return 0;
}

float *(*HGFractured::Effect::twirl(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7))(float *result, float a2, int a3)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  float v12;

  HGFractured::Effect::build(this, 1, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  v8 = (char *)this[8];
  if (v8)
  {
    v9 = 8 * *((int *)this + 31) + 84;
    v10 = (uint64_t)this[7] + 44;
    v11 = 0.0;
    do
    {
      v11 = (float)((12268885 * vcvts_n_s32_f32(v11, 0x18uLL) + 10368889) & 0xFFFFFF) * 0.000000059605;
      if ((*(_DWORD *)(v10 - 32) & 8) != 0)
        v12 = -1.0;
      else
        v12 = 1.0;
      *(_QWORD *)(v10 + 24) = 0;
      *(_QWORD *)(v10 + 32) = 0;
      *(_QWORD *)(v10 - 28) = *(_QWORD *)(v10 - 44);
      *(float *)(v10 - 20) = v11 * v12;
      *(_OWORD *)(v10 - 16) = xmmword_1B3053410;
      *(float *)v10 = v12;
      *(_OWORD *)(v10 + 8) = xmmword_1B304F240;
      v10 += v9;
      --v8;
    }
    while (v8);
  }
  return apply_twirl;
}

uint64_t HGFractured::Effect::spread(HGFractured::Effect *this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float64x2_t v13;
  int32x2_t v14;
  float v15;
  float v16;

  HGFractured::Effect::build((void **)this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 1088421888;
  v8 = *((_QWORD *)this + 8);
  if (v8)
  {
    v9 = 8 * *((int *)this + 31) + 84;
    v10 = *((_QWORD *)this + 7) + 52;
    v11 = 0;
    v12 = (float32x2_t)vdup_n_s32(0x33800000u);
    v13 = (float64x2_t)vdupq_n_s64(0x3FB999999999999AuLL);
    v14 = 0;
    do
    {
      while (1)
      {
        v11 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x2B084300269EC3, vcvt_n_s32_f32(v11, 0x18uLL), (int32x2_t)0xFD43FD000343FDLL) & 0xFFFFFF00FFFFFFLL)), v12);
        *(_QWORD *)(v10 + 16) = 0;
        *(_QWORD *)(v10 + 24) = 0;
        v14 = (int32x2_t)vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0xC39EC3009E3779, vcvt_n_s32_f32((float32x2_t)v14, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v12);
        *(float32x2_t *)(v10 - 36) = vcvt_f32_f64(vaddq_f64(vmulq_f64(vcvtq_f64_f32(vadd_f32((float32x2_t)v14, (float32x2_t)0xBF000000BF000000)), v13), vcvtq_f64_f32(*(float32x2_t *)(v10 - 52))));
        *(_DWORD *)(v10 - 28) = 0;
        if (vadd_f32(v11, vadd_f32((float32x2_t)vdup_lane_s32(v14, 1), (float32x2_t)v14)).f32[0] > 1.5)
          break;
        v15 = vmuls_lane_f32(*((float *)this + 37), v11, 1);
        *(_DWORD *)(v10 - 28) = v11.i32[0];
        *(float *)(v10 - 24) = v15 + 1.0;
        *(_OWORD *)v10 = xmmword_1B304EF60;
        *(_OWORD *)(v10 - 20) = xmmword_1B304F230;
        v10 += v9;
        if (!--v8)
          return 0;
      }
      v16 = vmuls_lane_f32(*((float *)this + 37), v11, 1);
      *(float *)(v10 - 28) = -v11.f32[0];
      *(float *)(v10 - 24) = (float)(v16 + 1.0) * 4.0;
      *(_OWORD *)v10 = xmmword_1B304EF60;
      *(_OWORD *)(v10 - 20) = xmmword_1B304F230;
      v10 += v9;
      --v8;
    }
    while (v8);
  }
  return 0;
}

uint64_t HGFractured::Effect::rotate(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  char *v8;
  uint64_t v9;
  float v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;

  HGFractured::Effect::build(this, 1, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  v8 = (char *)this[8];
  if (v8)
  {
    v9 = 8 * *((int *)this + 31) + 84;
    v10 = 1.0;
    if (!*((_BYTE *)this + 145))
      v10 = -1.0;
    v11 = (uint64_t)this[7] + 36;
    v12 = 0.0;
    do
    {
      v13 = *(float *)(v11 - 32);
      v12 = (float)((16598013 * vcvts_n_s32_f32(v12, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      *(_QWORD *)(v11 + 32) = 0;
      *(_QWORD *)(v11 + 40) = 0;
      *(_OWORD *)(v11 - 20) = xmmword_1B304F250;
      *(_DWORD *)(v11 - 4) = 0;
      *(float *)v11 = v10;
      *(_QWORD *)(v11 + 4) = 0x3F80000000000000;
      v14 = (float)((float)(v13 / *((float *)this + 33)) + 0.5) * 0.5;
      *(float *)(v11 + 16) = v14 + (float)(*((float *)this + 37) * (float)((float)(v12 * 0.5) - v14));
      *(_QWORD *)(v11 + 20) = 1056964608;
      *(_DWORD *)(v11 + 28) = 0;
      v11 += v9;
      --v8;
    }
    while (v8);
  }
  return 0;
}

uint64_t HGFractured::Effect::blocks(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  float32x2_t v11;
  float32x2_t v12;

  HGFractured::Effect::build(this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 1088421888;
  v8 = (char *)this[8];
  if (v8)
  {
    v9 = 8 * *((int *)this + 31) + 84;
    v10 = (uint64_t)this[7] + 52;
    v11 = 0;
    v12 = (float32x2_t)vdup_n_s32(0x33800000u);
    do
    {
      v11 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x2B0843009E3779, vcvt_n_s32_f32(v11, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v12);
      *(_QWORD *)(v10 - 36) = 0;
      *(_QWORD *)(v10 + 16) = 0;
      *(_QWORD *)(v10 + 24) = 0;
      *(_DWORD *)(v10 - 28) = 1065353216;
      *(float *)(v10 - 24) = v11.f32[0] + 2.0;
      *(_OWORD *)(v10 - 20) = xmmword_1B304F250;
      *(float *)v10 = vmuls_lane_f32(*((float *)this + 37) * 0.5, v11, 1);
      *(_QWORD *)(v10 + 4) = 1069547520;
      *(_DWORD *)(v10 + 12) = 0;
      v10 += v9;
      --v8;
    }
    while (v8);
  }
  return 0;
}

uint64_t HGFractured::Effect::bars(HGFractured::Effect *this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  uint64_t v8;
  uint64_t v9;
  float v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;

  *((_DWORD *)this + 35) = -1;
  HGFractured::Effect::build((void **)this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  v8 = *((_QWORD *)this + 8);
  if (v8)
  {
    v9 = 8 * *((int *)this + 31) + 84;
    v10 = -1.0;
    if (!*((_BYTE *)this + 145))
      v10 = 1.0;
    v11 = *((_QWORD *)this + 7) + 44;
    v12 = 0.0;
    do
    {
      v13 = *(float *)(v11 - 44);
      v12 = (float)((16598013 * vcvts_n_s32_f32(v12, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      v14 = (float)(*((float *)this + 33) - *((float *)this + 34)) * -0.5;
      *(_QWORD *)(v11 + 24) = 0;
      *(float *)(v11 + 32) = v14;
      *(_DWORD *)(v11 + 36) = 0;
      *(_OWORD *)(v11 - 28) = xmmword_1B304F250;
      *(float *)(v11 + 8) = (float)((float)(v13 + 0.5) * 0.5)
                          + (float)((float)((float)(v12 * 0.5) - (float)((float)(v13 + 0.5) * 0.5))
                                  * *((float *)this + 37));
      *(_QWORD *)(v11 + 12) = 1056964608;
      *(_DWORD *)(v11 + 20) = 0;
      *(float *)(v11 - 12) = v10;
      *(_QWORD *)(v11 - 8) = 0;
      *(_DWORD *)v11 = 1056964608;
      v11 += v9;
      --v8;
    }
    while (v8);
  }
  return 0;
}

uint64_t HGFractured::Effect::cube(HGFractured::Effect *this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  uint64_t v8;
  uint64_t v9;
  float *v10;
  float v11;
  float v12;

  *((_DWORD *)this + 35) = -1;
  HGFractured::Effect::build((void **)this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  v8 = *((_QWORD *)this + 8);
  if (v8)
  {
    v9 = 8 * *((int *)this + 31) + 84;
    v10 = (float *)(*((_QWORD *)this + 7) + 80);
    if (*((_BYTE *)this + 145))
    {
      do
      {
        v11 = (float)(1.0 - *((float *)this + 34)) * -0.5;
        *(_QWORD *)(v10 - 3) = 0;
        *(v10 - 1) = v11;
        *v10 = 0.0;
        *(_OWORD *)(v10 - 7) = xmmword_1B304F240;
        *((_OWORD *)v10 - 4) = xmmword_1B304F250;
        *((_OWORD *)v10 - 3) = xmmword_1B3524D40;
        v10 = (float *)((char *)v10 + v9);
        --v8;
      }
      while (v8);
    }
    else
    {
      do
      {
        v12 = (float)(1.0 - *((float *)this + 34)) * -0.5;
        *(_QWORD *)(v10 - 3) = 0;
        *(v10 - 1) = v12;
        *v10 = 0.0;
        *(_OWORD *)(v10 - 7) = xmmword_1B304F240;
        *((_OWORD *)v10 - 4) = xmmword_1B304F250;
        *((_OWORD *)v10 - 3) = xmmword_1B3524D50;
        v10 = (float *)((char *)v10 + v9);
        --v8;
      }
      while (v8);
    }
  }
  return 0;
}

float *(*HGFractured::Effect::test(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7))(float *result, float a2, int a3)
{
  char *v8;
  uint64_t v9;
  float v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;

  HGFractured::Effect::build(this, 1, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 1084227584;
  v8 = (char *)this[8];
  if (v8)
  {
    v9 = 8 * *((int *)this + 31) + 84;
    v10 = 1.0;
    if (!*((_BYTE *)this + 145))
      v10 = -1.0;
    v11 = (uint64_t)this[7] + 36;
    v12 = 0.0;
    do
    {
      v13 = *(float *)(v11 - 32);
      v12 = (float)((16598013 * vcvts_n_s32_f32(v12, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      *(_QWORD *)(v11 + 32) = 0;
      *(_QWORD *)(v11 + 40) = 0;
      *(_OWORD *)(v11 - 20) = xmmword_1B304F250;
      *(_DWORD *)(v11 - 4) = 0;
      *(float *)v11 = v10;
      *(_QWORD *)(v11 + 4) = 0x3F80000000000000;
      v14 = (float)((float)(v13 / *((float *)this + 33)) + 0.5) * 0.5;
      *(float *)(v11 + 16) = v14 + (float)(*((float *)this + 37) * (float)((float)(v12 * 0.5) - v14));
      *(_QWORD *)(v11 + 20) = 1056964608;
      *(_DWORD *)(v11 + 28) = 0;
      v11 += v9;
      --v8;
    }
    while (v8);
  }
  return apply_test;
}

HGSynchronizable *HGFractured::Effect::SetState(uint64_t a1, int a2)
{
  HGSynchronizable *v4;

  v4 = *(HGSynchronizable **)(a1 + 248);
  HGSynchronizable::Lock(v4);
  *(_DWORD *)(a1 + 240) = a2;
  return HGSynchronizable::Unlock(v4);
}

uint64_t HGFractured::Effect::GetState(HGFractured::Effect *this)
{
  HGSynchronizable *v2;
  uint64_t v3;

  v2 = (HGSynchronizable *)*((_QWORD *)this + 31);
  HGSynchronizable::Lock(v2);
  v3 = *((unsigned int *)this + 60);
  HGSynchronizable::Unlock(v2);
  return v3;
}

uint64_t HGFractured::Effect::init(HGFractured::Effect *this, double a2, double a3, double a4, double a5, int32x2_t a6)
{
  int v6;
  float v8;
  int v9;
  int v10;
  float v11;
  int v12;
  float v13;
  int v14;
  int v15;
  float v16;
  float v17;
  int v18;
  int v19;
  float v20;
  float v21;
  int v22;
  int v23;
  float v24;
  float v25;
  int v26;
  int v27;
  float v28;

  v6 = *((_DWORD *)this + 30);
  if ((v6 & 1) != 0)
  {
    switch(*((_DWORD *)this + 41))
    {
      case 0xFFFFFFFD:
        HGFractured::Effect::gen_brick(this, *((_DWORD *)this + 8), *((_DWORD *)this + 9), *((float *)this + 33), *((float *)this + 12));
        goto LABEL_21;
      case 0xFFFFFFFE:
        v13 = *((float *)this + 12);
        v14 = *((_DWORD *)this + 8);
        v15 = *((_DWORD *)this + 9);
        v16 = *((float *)this + 33);
        if (v13 == 0.0)
          HGFractured::Effect::gen_glass(this, v14, v15, v16);
        else
          HGFractured::Effect::gen_glass(this, v14, v15, v16, v13);
        goto LABEL_21;
      case 0xFFFFFFFF:
        v17 = *((float *)this + 12);
        v18 = *((_DWORD *)this + 8);
        v19 = *((_DWORD *)this + 9);
        v20 = *((float *)this + 33);
        if (v17 == 0.0)
          HGFractured::Effect::gen_glass_2(this, v18, v19, v20);
        else
          HGFractured::Effect::gen_glass_2((uint64_t)this, v18, v19, v20, v17, a4, a5, a6);
        goto LABEL_21;
      case 0:
      case 1:
        v8 = *((float *)this + 12);
        v9 = *((_DWORD *)this + 8);
        v10 = *((_DWORD *)this + 9);
        v11 = *((float *)this + 33);
        if (v8 == 0.0)
          HGFractured::Effect::gen_point(this, v9, v10, v11);
        else
          HGFractured::Effect::gen_point(this, v9, v10, v11, v8);
        v12 = 1;
        goto LABEL_22;
      case 3:
        v21 = *((float *)this + 12);
        v22 = *((_DWORD *)this + 8);
        v23 = *((_DWORD *)this + 9);
        v24 = *((float *)this + 33);
        if (v21 == 0.0)
          HGFractured::Effect::gen_tri(this, v22, v23, v24);
        else
          HGFractured::Effect::gen_tri(this, v22, v23, v24, v21);
        v12 = 3;
        goto LABEL_22;
      case 4:
        v25 = *((float *)this + 12);
        v26 = *((_DWORD *)this + 8);
        v27 = *((_DWORD *)this + 9);
        v28 = *((float *)this + 33);
        if (v25 == 0.0)
          HGFractured::Effect::gen_quad(this, v26, v27, v28);
        else
          HGFractured::Effect::gen_quad(this, v26, v27, v28, v25);
LABEL_21:
        v12 = 4;
LABEL_22:
        *((_DWORD *)this + 31) = v12;
        break;
      default:
        break;
    }
    *((_DWORD *)this + 30) &= ~1u;
  }
  return v6 & 1;
}

_QWORD *HGFractured::Effect::gen_point(_QWORD *this, int a2, int a3, float a4, float a5)
{
  _QWORD *v9;
  uint64_t v10;
  size_t v11;
  void *v12;
  int v13;
  float v14;
  float v15;
  uint64_t v16;
  float32x2_t v17;
  float v18;
  float32x2_t v19;
  int v20;

  v9 = this;
  v10 = a3 * (uint64_t)a2;
  v11 = 92 * v10;
  if (this[2] < (unint64_t)(92 * v10))
  {
    v12 = (void *)this[7];
    v9[2] = v11;
    this = malloc_type_realloc(v12, v11, 0xACDDD8C9uLL);
    v9[7] = this;
  }
  v9[8] = v10;
  if (a3 >= 1 && a2 >= 1)
  {
    v13 = 0;
    v14 = 1.0 / (float)a2;
    v15 = a4 / (float)a3;
    v16 = v9[7];
    v17 = 0;
    v18 = 0.0;
    v19 = (float32x2_t)vdup_n_s32(0x33800000u);
    do
    {
      v20 = 0;
      do
      {
        v17 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0xC39EC3009E3779, vcvt_n_s32_f32(v17, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v19);
        v18 = (float)((16598013 * vcvts_n_s32_f32(v18, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        *(float *)v16 = (float)((float)(v14 * (float)((float)v20 + 0.5)) + -0.5)
                      + (float)((float)(v14 * a5) * (float)(v17.f32[0] + -0.5));
        *(float *)(v16 + 4) = (float)((float)(v15 * (float)((float)v13 + 0.5)) - (float)(a4 * 0.5))
                            + (float)((float)(v15 * a5) * (float)(v17.f32[1] + -0.5));
        *(_QWORD *)(v16 + 84) = *(_QWORD *)v16;
        *(float *)(v16 + 8) = v14 * v15;
        *(_DWORD *)(v16 + 12) = v20 & 1 | (2 * (v13 & 1)) & 0xFB | (4 * ((v20 ^ v13) & 1)) | (8 * (v18 < 0.5));
        v16 += 92;
        ++v20;
      }
      while (a2 != v20);
      ++v13;
    }
    while (v13 != a3);
  }
  return this;
}

_QWORD *HGFractured::Effect::gen_point(_QWORD *this, int a2, int a3, float a4)
{
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  void *v10;
  int v11;
  float v12;
  float v13;
  uint64_t v14;
  float v15;
  int v16;

  v7 = this;
  v8 = a3 * (uint64_t)a2;
  v9 = 92 * v8;
  if (this[2] < (unint64_t)(92 * v8))
  {
    v10 = (void *)this[7];
    v7[2] = v9;
    this = malloc_type_realloc(v10, v9, 0x52DE36EEuLL);
    v7[7] = this;
  }
  v7[8] = v8;
  if (a3 >= 1 && a2 >= 1)
  {
    v11 = 0;
    v12 = 1.0 / (float)a2;
    v13 = a4 / (float)a3;
    v14 = v7[7];
    v15 = 0.0;
    do
    {
      v16 = 0;
      do
      {
        v15 = (float)((16598013 * vcvts_n_s32_f32(v15, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        *(float *)v14 = (float)(v12 * (float)((float)v16 + 0.5)) + -0.5;
        *(float *)(v14 + 4) = (float)(v13 * (float)((float)v11 + 0.5)) - (float)(a4 * 0.5);
        *(_QWORD *)(v14 + 84) = *(_QWORD *)v14;
        *(float *)(v14 + 8) = v12 * v13;
        *(_DWORD *)(v14 + 12) = v16 & 1 | (2 * (v11 & 1)) & 0xFB | (4 * ((v16 ^ v11) & 1)) | (8 * (v15 < 0.5));
        v14 += 92;
        ++v16;
      }
      while (a2 != v16);
      ++v11;
    }
    while (v11 != a3);
  }
  return this;
}

float *HGFractured::Effect::gen_tri(HGFractured::Effect *this, int a2, int a3, float a4, float a5)
{
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  size_t v13;
  float *result;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  int v24;
  float v25;
  float v26;
  int v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float *v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  uint64_t v39;
  float v40;
  int v41;
  float32x2_t v42;
  float v43;
  float v44;
  float v45;
  float v46;
  int v47;
  int v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  float v67;
  int v68;
  float v69;
  uint64_t v70;
  float *v71;
  int v72;
  int v73;
  float32x2_t v74;
  char v75;
  float v76;
  uint64_t v77;
  uint64_t v78;
  float v79;
  int v80;
  uint64_t v81;
  float v82;
  float v83;
  int v84;
  uint64_t v85;
  int v86;
  float v87;
  float v88;
  float v89;
  float *v90;
  uint64_t v91;
  uint64_t v92;
  float v93;
  uint64_t v94;
  float v95;
  float v96;
  float v97;
  float v98;
  int v99;
  uint64_t v100;
  float v101;
  unint64_t v102;
  unint64_t v103;
  float v104;
  uint64_t v105;
  float v106;
  int v107;
  int v108;
  float v109;
  float v110;
  uint64_t v111;
  int v112;
  float32x2_t v113;
  float v114;
  float *v115;
  uint64_t v116;
  uint64_t v117;
  float v118;
  float v119;
  uint64_t v120;
  float v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;

  v10 = a2 * (uint64_t)a3;
  v11 = 2 * v10;
  v12 = 216 * v10;
  v13 = *((_QWORD *)this + 2);
  result = (float *)*((_QWORD *)this + 7);
  if (v13 < v12)
  {
    *((_QWORD *)this + 2) = v12;
    result = (float *)malloc_type_realloc(result, v12, 0xBA50F26uLL);
    *((_QWORD *)this + 7) = result;
  }
  *((_QWORD *)this + 8) = v11;
  v15 = 1.0 / (float)a2;
  v16 = a4 * 0.5;
  v17 = v15 * a5;
  if (a3 >= 2)
  {
    v18 = a4 / (float)a3;
    v19 = v18 * a5;
    v20 = -v16;
    v21 = v15 + -0.5;
    v22 = v18 - v16;
    v23 = (float)(v18 - v16) + (float)((float)(v18 * a5) * 0.26414);
    v24 = a2 - 1;
    v25 = (float)-v16 - v16;
    v26 = v16 - v16;
    if (a2 < 2)
    {
      v41 = 0;
      v42 = (float32x2_t)0x3D95DBD03CB5F4C0;
      v40 = 0.35764;
      v34 = -0.5;
      v32 = -0.5;
      v31 = result;
    }
    else
    {
      v27 = 0;
      v28 = (float32x2_t)0x3E2C210C3F1E3779;
      v29 = (float32x2_t)0x3E1A7B0C3F439EC3;
      v30 = (float32x2_t)vdup_n_s32(0x33800000u);
      v31 = result;
      v32 = -0.5;
      v33 = v15 + -0.5;
      v34 = -0.5;
      do
      {
        v35 = v34;
        v36 = v23;
        v37 = v32;
        v29 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x269EC300C39EC3, vcvt_n_s32_f32(v29, 0x18uLL), (int32x2_t)0x343FD00FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v30);
        v28 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x2B0843009E3779, vcvt_n_s32_f32(v28, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v30);
        v31[21] = v32;
        v31[22] = v20;
        v32 = v33 + (float)(v17 * (float)(v29.f32[1] + -0.5));
        v31[23] = v32;
        v31[24] = v20;
        v38 = v33 + (float)(v17 * (float)(v28.f32[0] + -0.5));
        v23 = v22 + (float)(v19 * (float)(v29.f32[0] + -0.5));
        v31[25] = v38;
        v31[26] = v23;
        *v31 = (float)((float)(v37 + v32) + v38) * 0.33333;
        v31[1] = (float)(v25 + v23) * 0.33333;
        v31[2] = vabds_f32((float)(v32 - v37) * (float)(v23 + v16), v26 * (float)(v38 - v37)) * 0.5;
        *((_DWORD *)v31 + 3) = v27 & 1 | (8 * (v28.f32[1] < 0.5));
        v39 = *(_QWORD *)(v31 + 25);
        *((_QWORD *)v31 + 24) = v39;
        v34 = *(float *)&v39;
        v31[50] = v35;
        v31[51] = v36;
        v31[52] = v37;
        v31[53] = v20;
        v31[27] = (float)(v37 + (float)(v35 + *(float *)&v39)) * 0.33333;
        v31[28] = (float)((float)(v36 + *((float *)&v39 + 1)) - v16) * 0.33333;
        v31[29] = vabds_f32((float)(v35 - *(float *)&v39) * (float)(v20 - *((float *)&v39 + 1)), (float)(v36 - *((float *)&v39 + 1)) * (float)(v37 - *(float *)&v39))* 0.5;
        *((_DWORD *)v31 + 30) = v27 & 1 | (8 * (v28.f32[1] >= 0.5)) | 4;
        v33 = (float)(v15 * (float)(v27 + 2)) + -0.5;
        v31 += 54;
        ++v27;
      }
      while (v24 != v27);
      v40 = (float)((16598013 * vcvts_n_s32_f32(v29.f32[0], 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
      v41 = v24 & 1;
      v42 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x2B0843009E3779, vcvt_n_s32_f32(v28, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), (float32x2_t)vdup_n_s32(0x33800000u));
    }
    v69 = v19 * (float)(v40 + -0.5);
    v31[21] = v32;
    v31[22] = v20;
    v31[23] = 0.5;
    v31[24] = v20;
    v31[25] = 0.5;
    v31[26] = v22 + v69;
    *v31 = (float)((float)(v32 + 0.5) + 0.5) * 0.33333;
    v31[1] = (float)(v25 + (float)(v22 + v69)) * 0.33333;
    v31[2] = vabds_f32((float)(0.5 - v32) * (float)((float)(v22 + v69) + v16), v26 * (float)(0.5 - v32)) * 0.5;
    *((_DWORD *)v31 + 3) = v41 | (8 * (v42.f32[1] < 0.5));
    v70 = *(_QWORD *)(v31 + 25);
    *((_QWORD *)v31 + 24) = v70;
    v31[50] = v34;
    v31[51] = v23;
    v31[52] = v32;
    v31[53] = v20;
    v31[27] = (float)(v32 + (float)(v34 + *(float *)&v70)) * 0.33333;
    v31[28] = (float)((float)(v23 + *((float *)&v70 + 1)) - v16) * 0.33333;
    v31[29] = vabds_f32((float)(v34 - *(float *)&v70) * (float)(v20 - *((float *)&v70 + 1)), (float)(v23 - *((float *)&v70 + 1)) * (float)(v32 - *(float *)&v70))* 0.5;
    *((_DWORD *)v31 + 30) = v41 | (8 * (v42.f32[1] >= 0.5)) | 4;
    v71 = v31 + 54;
    if (a3 <= 2)
    {
      v107 = 2;
      if (a2 >= 2)
      {
LABEL_32:
        v111 = 0;
        v112 = 0;
        v113 = (float32x2_t)vdup_n_s32(0x33800000u);
        v110 = -0.5;
        do
        {
          v114 = v110;
          v42 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x2B0843009E3779, vcvt_n_s32_f32(v42, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v113);
          v115 = &v71[v111];
          v116 = *(_QWORD *)&result[v111 + 50];
          *(_QWORD *)(v115 + 21) = v116;
          v117 = *(_QWORD *)&result[v111 + 48];
          v118 = v21 + (float)(v17 * (float)(v42.f32[0] + -0.5));
          v115[25] = v118;
          v115[26] = v16;
          *((_QWORD *)v115 + 26) = v116;
          *(_QWORD *)(v115 + 23) = v117;
          v119 = (float)(*(float *)&v117 - *(float *)&v116) * (float)(v16 - *((float *)&v116 + 1));
          v109 = v42.f32[1];
          *v115 = (float)(v118 + (float)(*(float *)&v116 + *(float *)&v117)) * 0.33333;
          v115[1] = (float)((float)(*((float *)&v116 + 1) + *((float *)&v117 + 1)) + v16) * 0.33333;
          LODWORD(v117) = v112 & 1 | v107;
          *((_DWORD *)v115 + 3) = v117 | (8 * (v42.f32[1] < 0.5));
          v120 = *(_QWORD *)&v71[v111 + 25];
          v121 = vabds_f32(v119, (float)(*((float *)&v117 + 1) - *((float *)&v116 + 1)) * (float)(v118 - *(float *)&v116));
          *((_QWORD *)v115 + 24) = v120;
          v115[50] = v114;
          v115[51] = v16;
          v110 = *(float *)&v120;
          v115[2] = v121 * 0.5;
          v115[27] = (float)((float)(v114 + *(float *)&v120) + *(float *)&v116) * 0.33333;
          v115[28] = (float)((float)(v16 + *((float *)&v120 + 1)) + *((float *)&v116 + 1)) * 0.33333;
          v115[29] = vabds_f32((float)(v114 - *(float *)&v120) * (float)(*((float *)&v116 + 1) - *((float *)&v120 + 1)), (float)(v16 - *((float *)&v120 + 1)) * (float)(*(float *)&v116 - *(float *)&v120))* 0.5;
          *((_DWORD *)v115 + 30) = v117 | (8 * (v42.f32[1] >= 0.5)) | 4;
          v21 = (float)(v15 * (float)(v112 + 2)) + -0.5;
          ++v112;
          v111 += 54;
        }
        while (v24 != v112);
        v108 = v24 & 1;
        result = (float *)((char *)result + v111 * 4);
        v71 = (float *)((char *)v71 + v111 * 4);
        goto LABEL_35;
      }
    }
    else
    {
      v72 = a3 - 1;
      v73 = 1;
      v74 = (float32x2_t)vdup_n_s32(0x33800000u);
      do
      {
        v82 = (float)(v18 * (float)((float)v73 + 1.0)) - v16;
        v83 = v69 + v82;
        v84 = 2 * (v73 & 1);
        if (a2 < 2)
        {
          v75 = 0;
          v76 = -0.5;
        }
        else
        {
          v85 = 0;
          v86 = 0;
          v76 = -0.5;
          v87 = v15 + -0.5;
          do
          {
            v88 = v76;
            v40 = (float)((16598013 * vcvts_n_s32_f32(v40, 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
            v42 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x2B0843009E3779, vcvt_n_s32_f32(v42, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v74);
            v89 = v83;
            v90 = &v71[v85];
            v91 = *(_QWORD *)&result[v85 + 50];
            *(_QWORD *)(v90 + 21) = v91;
            v92 = *(_QWORD *)&result[v85 + 48];
            v93 = v87 + (float)(v17 * (float)(v42.f32[0] + -0.5));
            v83 = v82 + (float)(v19 * (float)(v40 + -0.5));
            *(_QWORD *)(v90 + 23) = v92;
            *((_QWORD *)v90 + 26) = v91;
            v94 = v91;
            v95 = *((float *)&v91 + 1) - v83;
            if ((float)((float)(v89 - v83) * (float)(*(float *)&v91 - v93)) >= (float)((float)(v88 - v93)
                                                                                      * (float)(*((float *)&v91 + 1)
                                                                                              - v83)))
              v83 = v89;
            v96 = *(float *)&v92 - v93;
            if ((float)((float)(*(float *)&v91 - v93) * (float)(*((float *)&v92 + 1) - v83)) <= (float)(v95 * (float)(*(float *)&v92 - v93)))
              v93 = *(float *)&v92;
            if ((float)((float)(*((float *)&v92 + 1) - v83) * (float)(v88 - v93)) <= (float)(v96 * (float)(v89 - v83)))
              v93 = *(float *)&v92;
            v90[25] = v93;
            v90[26] = v83;
            v90[1] = (float)((float)(*((float *)&v91 + 1) + *((float *)&v92 + 1)) + v83) * 0.33333;
            v97 = (float)((float)(*(float *)&v91 + *(float *)&v92) + v93) * 0.33333;
            v98 = (float)(*((float *)&v92 + 1) - *((float *)&v91 + 1)) * (float)(v93 - *(float *)&v91);
            *v90 = v97;
            v99 = v86 & 1 | v84;
            *((_DWORD *)v90 + 3) = v99 | (8 * (v42.f32[1] < 0.5));
            v100 = *(_QWORD *)(v90 + 25);
            v101 = vabds_f32((float)(*(float *)&v92 - *(float *)&v94) * (float)(v83 - *((float *)&v94 + 1)), v98);
            *((_QWORD *)v90 + 24) = v100;
            v90[50] = v88;
            v90[51] = v89;
            v76 = *(float *)&v100;
            v90[2] = v101 * 0.5;
            v90[27] = (float)((float)(v88 + *(float *)&v100) + *(float *)&v94) * 0.33333;
            v90[28] = (float)((float)(v89 + *((float *)&v100 + 1)) + *((float *)&v94 + 1)) * 0.33333;
            v90[29] = vabds_f32((float)(v88 - *(float *)&v100) * (float)(*((float *)&v94 + 1) - *((float *)&v100 + 1)), (float)(v89 - *((float *)&v100 + 1)) * (float)(*(float *)&v94 - *(float *)&v100))* 0.5;
            *((_DWORD *)v90 + 30) = v99 | (8 * (v42.f32[1] >= 0.5)) | 4;
            v87 = (float)(v15 * (float)(v86 + 2)) + -0.5;
            ++v86;
            v85 += 54;
          }
          while (v24 != v86);
          result = (float *)((char *)result + v85 * 4);
          v71 = (float *)((char *)v71 + v85 * 4);
          v75 = a2 - 1;
        }
        v40 = (float)((16598013 * vcvts_n_s32_f32(v40, 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
        v69 = v19 * (float)(v40 + -0.5);
        v77 = *((_QWORD *)result + 25);
        *(_QWORD *)(v71 + 21) = v77;
        v78 = *((_QWORD *)result + 24);
        *(_QWORD *)(v71 + 23) = v78;
        v79 = v82 + v69;
        v71[25] = 0.5;
        v71[26] = v79;
        *((_QWORD *)v71 + 26) = v77;
        *v71 = (float)((float)(*(float *)&v77 + *(float *)&v78) + 0.5) * 0.33333;
        v71[1] = (float)((float)(*((float *)&v77 + 1) + *((float *)&v78 + 1)) + v79) * 0.33333;
        v71[2] = vabds_f32((float)(*(float *)&v78 - *(float *)&v77) * (float)(v79 - *((float *)&v77 + 1)), (float)(*((float *)&v78 + 1) - *((float *)&v77 + 1)) * (float)(0.5 - *(float *)&v77))* 0.5;
        v80 = v75 & 1 | v84;
        v81 = *(_QWORD *)(v71 + 25);
        *((_QWORD *)v71 + 24) = v81;
        v71[50] = v76;
        v71[51] = v83;
        v71[27] = (float)((float)(v76 + *(float *)&v81) + *(float *)&v77) * 0.33333;
        v71[28] = (float)((float)(v83 + *((float *)&v81 + 1)) + *((float *)&v77 + 1)) * 0.33333;
        v71[29] = vabds_f32((float)(v76 - *(float *)&v81) * (float)(*((float *)&v77 + 1) - *((float *)&v81 + 1)), (float)(v83 - *((float *)&v81 + 1)) * (float)(*(float *)&v77 - *(float *)&v81))* 0.5;
        result += 54;
        ++v73;
        v42 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x2B0843009E3779, vcvt_n_s32_f32(v42, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v74);
        *((_DWORD *)v71 + 3) = v80 | (8 * (v42.f32[1] < 0.5));
        *((_DWORD *)v71 + 30) = v80 | (8 * (v42.f32[1] >= 0.5)) | 4;
        v71 += 54;
      }
      while (v73 != v72);
      v107 = 2 * (v72 & 1);
      if (a2 >= 2)
        goto LABEL_32;
    }
    v108 = 0;
    v109 = v42.f32[1];
    v110 = -0.5;
LABEL_35:
    v67 = (float)((16598013 * vcvts_n_s32_f32(v109, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
    v122 = *((_QWORD *)result + 25);
    *(_QWORD *)(v71 + 21) = v122;
    v123 = *((_QWORD *)result + 24);
    *(_QWORD *)(v71 + 23) = v123;
    v71[25] = 0.5;
    v71[26] = v16;
    *((_QWORD *)v71 + 26) = v122;
    v124 = v122;
    *v71 = (float)((float)(*(float *)&v122 + *(float *)&v123) + 0.5) * 0.33333;
    v71[1] = (float)((float)(*((float *)&v122 + 1) + *((float *)&v123 + 1)) + v16) * 0.33333;
    v71[2] = vabds_f32((float)(*(float *)&v123 - *(float *)&v122) * (float)(v16 - *((float *)&v122 + 1)), (float)(*((float *)&v123 + 1) - *((float *)&v122 + 1)) * (float)(0.5 - *(float *)&v122))* 0.5;
    v68 = v108 | v107;
    *((_DWORD *)v71 + 3) = v108 | v107 | (8 * (v67 < 0.5));
    v125 = *(_QWORD *)(v71 + 25);
    *((_QWORD *)v71 + 24) = v125;
    v71[50] = v110;
    v71[51] = v16;
    v71[27] = (float)((float)(v110 + *(float *)&v125) + *(float *)&v124) * 0.33333;
    v71[28] = (float)((float)(v16 + *((float *)&v125 + 1)) + *((float *)&v124 + 1)) * 0.33333;
    v106 = (float)((float)(v110 - *(float *)&v125) * (float)(*((float *)&v124 + 1) - *((float *)&v125 + 1)))
         - (float)((float)(v16 - *((float *)&v125 + 1)) * (float)(*(float *)&v124 - *(float *)&v125));
    goto LABEL_36;
  }
  v43 = -v16;
  v44 = (float)((float)((float)-v16 - v16) + v16) * 0.33333;
  v45 = v16 - v16;
  v46 = v16 + v16;
  if (a2 < 2)
  {
    v68 = 0;
    v51 = -0.5;
    v67 = 0.16809;
    v50 = -0.5;
  }
  else
  {
    v47 = 0;
    v48 = a2 - 1;
    v49 = 0.0;
    v50 = -0.5;
    v51 = -0.5;
    v52 = 1.0 / (float)a2;
    v53 = 0.0;
    v54 = 0.0;
    do
    {
      v55 = v51;
      v56 = v50;
      v57 = v52 + -0.5;
      v49 = (float)((12268885 * vcvts_n_s32_f32(v49, 0x18uLL) + 10368889) & 0xFFFFFF) * 0.000000059605;
      v53 = (float)((214013 * vcvts_n_s32_f32(v53, 0x18uLL) + 2531011) & 0xFFFFFF) * 0.000000059605;
      v54 = (float)((16598013 * vcvts_n_s32_f32(v54, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      result[21] = v50;
      result[22] = v43;
      v50 = v57 + (float)(v17 * (float)(v53 + -0.5));
      result[23] = v50;
      result[24] = v43;
      v58 = v57 + (float)(v17 * (float)(v49 + -0.5));
      result[25] = v58;
      result[26] = v16;
      v59 = (float)(v56 + v50) + v58;
      v60 = v50 - v56;
      v61 = v58 - v56;
      v62 = v60 * v46;
      v63 = v45 * v61;
      *((_DWORD *)result + 3) = v47 & 1 | (8 * (v54 < 0.5));
      v64 = *(_QWORD *)(result + 25);
      *((_QWORD *)result + 24) = v64;
      result[50] = v55;
      result[51] = v16;
      v65 = HIDWORD(v64);
      v51 = *(float *)&v64;
      v66 = *(_QWORD *)(result + 21);
      *((_QWORD *)result + 26) = v66;
      *result = v59 * 0.33333;
      result[1] = v44;
      result[2] = vabds_f32(v62, v63) * 0.5;
      result[27] = (float)((float)(v55 + v51) + *(float *)&v66) * 0.33333;
      result[28] = (float)((float)(v16 + *(float *)&v65) + *((float *)&v66 + 1)) * 0.33333;
      *((_DWORD *)result + 30) = v47 & 1 | (8 * (v54 >= 0.5)) | 4;
      result[29] = vabds_f32((float)(v55 - v51) * (float)(*((float *)&v66 + 1) - *(float *)&v65), (float)(v16 - *(float *)&v65) * (float)(*(float *)&v66 - v51))* 0.5;
      v52 = v15 * (float)(v47 + 2);
      result += 54;
      ++v47;
    }
    while (v48 != v47);
    v67 = (float)((16598013 * vcvts_n_s32_f32(v54, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
    v68 = v48 & 1;
  }
  result[21] = v50;
  result[22] = v43;
  result[23] = 0.5;
  result[24] = v43;
  result[25] = 0.5;
  result[26] = v16;
  *result = (float)((float)(v50 + 0.5) + 0.5) * 0.33333;
  result[1] = v44;
  result[2] = vabds_f32((float)(0.5 - v50) * v46, v45 * (float)(0.5 - v50)) * 0.5;
  *((_DWORD *)result + 3) = v68 | (8 * (v67 < 0.5));
  v102 = *(_QWORD *)(result + 25);
  *((_QWORD *)result + 24) = v102;
  result[50] = v51;
  result[51] = v16;
  v103 = HIDWORD(v102);
  v104 = *(float *)&v102;
  v105 = *(_QWORD *)(result + 21);
  *((_QWORD *)result + 26) = v105;
  result[27] = (float)((float)(v51 + v104) + *(float *)&v105) * 0.33333;
  result[28] = (float)((float)(v16 + *(float *)&v103) + *((float *)&v105 + 1)) * 0.33333;
  v106 = (float)((float)(v51 - v104) * (float)(*((float *)&v105 + 1) - *(float *)&v103))
       - (float)((float)(v16 - *(float *)&v103) * (float)(*(float *)&v105 - v104));
  v71 = result;
LABEL_36:
  v71[29] = fabsf(v106) * 0.5;
  *((_DWORD *)v71 + 30) = v68 | (8 * (v67 >= 0.5)) | 4;
  return result;
}

float *HGFractured::Effect::gen_tri(HGFractured::Effect *this, int a2, int a3, float a4)
{
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  size_t v11;
  float *result;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  int v21;
  float v22;
  int v23;
  float v24;
  float *v25;
  float v26;
  float v27;
  float v28;
  float v29;
  uint64_t v30;
  float v31;
  int v32;
  float v33;
  int v34;
  int v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  float v45;
  int v46;
  uint64_t v47;
  float *v48;
  int v49;
  int v50;
  char v51;
  float v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  float v57;
  int v58;
  uint64_t v59;
  int v60;
  float v61;
  float v62;
  float *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  float v69;
  uint64_t v70;
  float v71;
  float v72;
  float v73;
  int v74;
  int v75;
  float v76;
  uint64_t v77;
  int v78;
  float v79;
  float *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  float v88;
  float v89;

  v8 = a2 * (uint64_t)a3;
  v9 = 2 * v8;
  v10 = 216 * v8;
  v11 = *((_QWORD *)this + 2);
  result = (float *)*((_QWORD *)this + 7);
  if (v11 < v10)
  {
    *((_QWORD *)this + 2) = v10;
    result = (float *)malloc_type_realloc(result, v10, 0x9B0B8F84uLL);
    *((_QWORD *)this + 7) = result;
  }
  *((_QWORD *)this + 8) = v9;
  v13 = 1.0 / (float)a2;
  v14 = a4 / (float)a3;
  v15 = a4 * 0.5;
  v16 = (float)(v13 * 0.5) * v14;
  v17 = -(float)(a4 * 0.5);
  if (a3 >= 2)
  {
    v18 = -0.5;
    v19 = v13 + -0.5;
    v20 = v14 - v15;
    v21 = a2 - 1;
    v22 = (float)((float)(v17 - v15) + (float)(v14 - v15)) * 0.33333;
    if (a2 < 2)
    {
      v32 = 0;
      v31 = 0.16809;
      v29 = -0.5;
      v25 = result;
    }
    else
    {
      v23 = 0;
      v24 = 0.0;
      v25 = result;
      v26 = -0.5;
      v27 = v13 + -0.5;
      do
      {
        v28 = v18;
        v29 = v27;
        v24 = (float)((16598013 * vcvts_n_s32_f32(v24, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        v25[25] = v27;
        v25[26] = v20;
        *((_DWORD *)v25 + 3) = v23 & 1 | (8 * (v24 < 0.5));
        v30 = *(_QWORD *)(v25 + 25);
        *((_QWORD *)v25 + 24) = v30;
        v18 = *(float *)&v30;
        v25[21] = v26;
        v25[22] = v17;
        v25[23] = v27;
        v25[24] = v17;
        *v25 = (float)(v27 + (float)(v27 + v26)) * 0.33333;
        v25[1] = v22;
        v25[2] = v16;
        v25[50] = v28;
        v25[51] = v20;
        v25[52] = v26;
        v25[53] = v17;
        v25[27] = (float)(v26 + (float)(v28 + *(float *)&v30)) * 0.33333;
        v25[28] = (float)((float)(v20 + *((float *)&v30 + 1)) - v15) * 0.33333;
        v25[29] = v16;
        *((_DWORD *)v25 + 30) = v23 & 1 | (8 * (v24 >= 0.5)) | 4;
        v27 = (float)(v13 * (float)(v23 + 2)) + -0.5;
        v25 += 54;
        ++v23;
        v26 = v29;
      }
      while (v21 != v23);
      v31 = (float)((16598013 * vcvts_n_s32_f32(v24, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      v32 = v21 & 1;
    }
    v25[21] = v29;
    v25[22] = v17;
    v25[23] = 0.5;
    v25[24] = v17;
    v25[25] = 0.5;
    v25[26] = v20;
    *v25 = (float)((float)(v29 + 0.5) + 0.5) * 0.33333;
    v25[1] = v22;
    v25[2] = v16;
    *((_DWORD *)v25 + 3) = v32 | (8 * (v31 < 0.5));
    v47 = *(_QWORD *)(v25 + 25);
    *((_QWORD *)v25 + 24) = v47;
    v25[50] = v18;
    v25[51] = v20;
    v25[52] = v29;
    v25[53] = v17;
    v25[27] = (float)(v29 + (float)(v18 + *(float *)&v47)) * 0.33333;
    v25[28] = (float)((float)(v20 + *((float *)&v47 + 1)) - v15) * 0.33333;
    v25[29] = v16;
    *((_DWORD *)v25 + 30) = v32 | (8 * (v31 >= 0.5)) | 4;
    v48 = v25 + 54;
    if (a3 <= 2)
    {
      v74 = 2;
      if (a2 >= 2)
      {
LABEL_26:
        v77 = 0;
        v78 = 0;
        v76 = -0.5;
        do
        {
          v79 = v76;
          v80 = &v48[v77];
          v31 = (float)((16598013 * vcvts_n_s32_f32(v31, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
          v81 = *(_QWORD *)&result[v77 + 50];
          *(_QWORD *)(v80 + 21) = v81;
          v82 = *(_QWORD *)&result[v77 + 48];
          *(_QWORD *)(v80 + 23) = v82;
          v80[25] = v19;
          v80[26] = v15;
          *((_QWORD *)v80 + 26) = v81;
          *v80 = (float)(v19 + (float)(*(float *)&v81 + *(float *)&v82)) * 0.33333;
          v80[1] = (float)((float)(*((float *)&v81 + 1) + *((float *)&v82 + 1)) + v15) * 0.33333;
          v80[2] = v16;
          LODWORD(v82) = v78 & 1 | v74;
          *((_DWORD *)v80 + 3) = v82 | (8 * (v31 < 0.5));
          v83 = *(_QWORD *)&v48[v77 + 25];
          *((_QWORD *)v80 + 24) = v83;
          v80[50] = v76;
          v80[51] = v15;
          v76 = *(float *)&v83;
          v80[27] = (float)((float)(v79 + *(float *)&v83) + *(float *)&v81) * 0.33333;
          v80[28] = (float)((float)(v15 + *((float *)&v83 + 1)) + *((float *)&v81 + 1)) * 0.33333;
          v80[29] = v16;
          *((_DWORD *)v80 + 30) = v82 | (8 * (v31 >= 0.5)) | 4;
          v19 = (float)(v13 * (float)(v78 + 2)) + -0.5;
          ++v78;
          v77 += 54;
        }
        while (v21 != v78);
        v75 = v21 & 1;
        result = (float *)((char *)result + v77 * 4);
        v48 = (float *)((char *)v48 + v77 * 4);
        goto LABEL_29;
      }
    }
    else
    {
      v49 = a3 - 1;
      v50 = 1;
      do
      {
        v57 = (float)(v14 * (float)((float)v50 + 1.0)) - v15;
        v58 = 2 * (v50 & 1);
        if (a2 < 2)
        {
          v51 = 0;
          v52 = -0.5;
        }
        else
        {
          v59 = 0;
          v60 = 0;
          v52 = -0.5;
          v61 = v13 + -0.5;
          do
          {
            v62 = v52;
            v63 = &v48[v59];
            v31 = (float)((16598013 * vcvts_n_s32_f32(v31, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
            v64 = *(_QWORD *)&result[v59 + 50];
            *(_QWORD *)(v63 + 21) = v64;
            v65 = *(_QWORD *)&result[v59 + 48];
            *(_QWORD *)(v63 + 23) = v65;
            v63[25] = v61;
            v63[26] = v57;
            *((_QWORD *)v63 + 26) = v64;
            *v63 = (float)(v61 + (float)(*(float *)&v64 + *(float *)&v65)) * 0.33333;
            v63[1] = (float)((float)(*((float *)&v64 + 1) + *((float *)&v65 + 1)) + v57) * 0.33333;
            v63[2] = v16;
            LODWORD(v65) = v60 & 1 | v58;
            *((_DWORD *)v63 + 3) = v65 | (8 * (v31 < 0.5));
            v66 = *(_QWORD *)&v48[v59 + 25];
            *((_QWORD *)v63 + 24) = v66;
            v63[50] = v52;
            v63[51] = v57;
            v52 = *(float *)&v66;
            v63[27] = (float)((float)(v62 + *(float *)&v66) + *(float *)&v64) * 0.33333;
            v63[28] = (float)((float)(v57 + *((float *)&v66 + 1)) + *((float *)&v64 + 1)) * 0.33333;
            v63[29] = v16;
            *((_DWORD *)v63 + 30) = v65 | (8 * (v31 >= 0.5)) | 4;
            v61 = (float)(v13 * (float)(v60 + 2)) + -0.5;
            ++v60;
            v59 += 54;
          }
          while (v21 != v60);
          result = (float *)((char *)result + v59 * 4);
          v48 = (float *)((char *)v48 + v59 * 4);
          v51 = a2 - 1;
        }
        v31 = (float)((16598013 * vcvts_n_s32_f32(v31, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        v53 = *((_QWORD *)result + 25);
        *(_QWORD *)(v48 + 21) = v53;
        v54 = *((_QWORD *)result + 24);
        *(_QWORD *)(v48 + 23) = v54;
        v48[25] = 0.5;
        v48[26] = v57;
        *((_QWORD *)v48 + 26) = v53;
        *v48 = (float)((float)(*(float *)&v53 + *(float *)&v54) + 0.5) * 0.33333;
        v48[1] = (float)((float)(*((float *)&v53 + 1) + *((float *)&v54 + 1)) + v57) * 0.33333;
        v48[2] = v16;
        v55 = v51 & 1 | v58;
        *((_DWORD *)v48 + 3) = v55 | (8 * (v31 < 0.5));
        v56 = *(_QWORD *)(v48 + 25);
        *((_QWORD *)v48 + 24) = v56;
        v48[50] = v52;
        v48[51] = v57;
        v48[27] = (float)((float)(v52 + *(float *)&v56) + *(float *)&v53) * 0.33333;
        v48[28] = (float)((float)(v57 + *((float *)&v56 + 1)) + *((float *)&v53 + 1)) * 0.33333;
        v48[29] = v16;
        *((_DWORD *)v48 + 30) = v55 | (8 * (v31 >= 0.5)) | 4;
        result += 54;
        ++v50;
        v48 += 54;
      }
      while (v50 != v49);
      v74 = 2 * (v49 & 1);
      if (a2 >= 2)
        goto LABEL_26;
    }
    v75 = 0;
    v76 = -0.5;
LABEL_29:
    v45 = (float)((16598013 * vcvts_n_s32_f32(v31, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
    v84 = *((_QWORD *)result + 25);
    *(_QWORD *)(v48 + 21) = v84;
    v85 = *((_QWORD *)result + 24);
    *(_QWORD *)(v48 + 23) = v85;
    v48[25] = 0.5;
    v48[26] = v15;
    *((_QWORD *)v48 + 26) = v84;
    v86 = v84;
    *v48 = (float)((float)(*(float *)&v84 + *(float *)&v85) + 0.5) * 0.33333;
    v48[1] = (float)((float)(*((float *)&v84 + 1) + *((float *)&v85 + 1)) + v15) * 0.33333;
    v48[2] = v16;
    v46 = v75 | v74;
    *((_DWORD *)v48 + 3) = v75 | v74 | (8 * (v45 < 0.5));
    v87 = *(_QWORD *)(v48 + 25);
    *((_QWORD *)v48 + 24) = v87;
    v48[50] = v76;
    v48[51] = v15;
    v88 = v76 + *(float *)&v87;
    v89 = v15 + *((float *)&v87 + 1);
    v72 = v88 + *(float *)&v86;
    v73 = v89 + *((float *)&v86 + 1);
    goto LABEL_30;
  }
  v33 = (float)((float)(v17 - v15) + v15) * 0.33333;
  if (a2 < 2)
  {
    v46 = 0;
    v39 = -0.5;
    v45 = 0.16809;
    v37 = -0.5;
  }
  else
  {
    v34 = 0;
    v35 = a2 - 1;
    v36 = 0.0;
    v37 = -0.5;
    v38 = 1.0 / (float)a2;
    v39 = -0.5;
    do
    {
      v40 = v39;
      v41 = v37;
      v37 = v38 + -0.5;
      v36 = (float)((16598013 * vcvts_n_s32_f32(v36, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      result[21] = v41;
      result[22] = v17;
      result[23] = v38 + -0.5;
      result[24] = v17;
      result[25] = v38 + -0.5;
      result[26] = v15;
      *result = (float)((float)(v38 + -0.5) + (float)(v41 + (float)(v38 + -0.5))) * 0.33333;
      result[1] = v33;
      result[2] = v16;
      *((_DWORD *)result + 3) = v34 & 1 | (8 * (v36 < 0.5));
      v42 = *(_QWORD *)(result + 25);
      *((_QWORD *)result + 24) = v42;
      result[50] = v40;
      result[51] = v15;
      v43 = HIDWORD(v42);
      v39 = *(float *)&v42;
      v44 = *(_QWORD *)(result + 21);
      *((_QWORD *)result + 26) = v44;
      result[27] = (float)((float)(v40 + v39) + *(float *)&v44) * 0.33333;
      result[28] = (float)((float)(v15 + *(float *)&v43) + *((float *)&v44 + 1)) * 0.33333;
      result[29] = v16;
      *((_DWORD *)result + 30) = v34 & 1 | (8 * (v36 >= 0.5)) | 4;
      v38 = v13 * (float)(v34 + 2);
      result += 54;
      ++v34;
    }
    while (v35 != v34);
    v45 = (float)((16598013 * vcvts_n_s32_f32(v36, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
    v46 = v35 & 1;
  }
  result[21] = v37;
  result[22] = v17;
  result[23] = 0.5;
  result[24] = v17;
  result[25] = 0.5;
  result[26] = v15;
  *result = (float)((float)(v37 + 0.5) + 0.5) * 0.33333;
  result[1] = v33;
  result[2] = v16;
  *((_DWORD *)result + 3) = v46 | (8 * (v45 < 0.5));
  v67 = *(_QWORD *)(result + 25);
  *((_QWORD *)result + 24) = v67;
  result[50] = v39;
  result[51] = v15;
  v68 = HIDWORD(v67);
  v69 = *(float *)&v67;
  v70 = *(_QWORD *)(result + 21);
  *((_QWORD *)result + 26) = v70;
  v71 = v15 + *(float *)&v68;
  v72 = (float)(v39 + v69) + *(float *)&v70;
  v73 = v71 + *((float *)&v70 + 1);
  v48 = result;
LABEL_30:
  v48[27] = v72 * 0.33333;
  v48[28] = v73 * 0.33333;
  v48[29] = v16;
  *((_DWORD *)v48 + 30) = v46 | (8 * (v45 >= 0.5)) | 4;
  return result;
}

float *HGFractured::Effect::gen_quad(HGFractured::Effect *this, int a2, int a3, float a4, float a5)
{
  int32x2_t v5;
  uint64_t v11;
  size_t v12;
  unint64_t v13;
  float *result;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  int v24;
  float v25;
  float v26;
  int v27;
  float32x2_t v28;
  float v29;
  float v30;
  float32x2_t v31;
  float *v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  int v40;
  float32x2_t v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  int v47;
  int v48;
  float32x2_t v49;
  float v50;
  float32x2_t v51;
  float v52;
  float v53;
  float32x2_t v54;
  int v55;
  int v56;
  float v57;
  float *v58;
  int v59;
  int v60;
  float32x2_t v61;
  unsigned __int8 v62;
  float v63;
  unint64_t v64;
  unint64_t v65;
  float v66;
  uint64_t v67;
  float v68;
  float v69;
  float32x2_t v70;
  float v71;
  float v72;
  int v73;
  uint64_t v74;
  int v75;
  float v76;
  float v77;
  float v78;
  float *v79;
  uint64_t v80;
  uint64_t v81;
  float v82;
  float v83;
  unsigned int v84;
  float32x2_t v85;
  uint64_t v86;
  int v87;
  int v88;
  float32x2_t v89;
  float v90;
  float *v91;
  uint64_t v92;
  uint64_t v93;
  float v94;
  uint64_t v95;
  uint64_t v96;

  v11 = a3 * (uint64_t)a2;
  v12 = 116 * v11;
  v13 = *((_QWORD *)this + 2);
  result = (float *)*((_QWORD *)this + 7);
  if (v13 < 116 * v11)
  {
    *((_QWORD *)this + 2) = v12;
    result = (float *)malloc_type_realloc(result, v12, 0xF1CDF0C1uLL);
    *((_QWORD *)this + 7) = result;
  }
  *((_QWORD *)this + 8) = v11;
  v15 = 1.0 / (float)a2;
  v16 = a4 * 0.5;
  v17 = v15 * a5;
  if (a3 < 2)
  {
    v42 = -v16;
    v43 = (float)-v16 - v16;
    v44 = (float)((float)(v43 + v16) + v16) * 0.25;
    v45 = v16 - v16;
    v46 = v16 + v16;
    if (a2 < 2)
    {
      v55 = 0;
      v54 = (float32x2_t)0xBF000000BF000000;
      v56 = 8;
    }
    else
    {
      v47 = 0;
      v48 = a2 - 1;
      v49 = (float32x2_t)0x3E1A7B0C3F1E3779;
      v50 = 0.16809;
      v51 = (float32x2_t)vdup_n_s32(0x33800000u);
      v52 = -0.5;
      *(float *)v5.i32 = 1.0 / (float)a2;
      v53 = -0.5;
      do
      {
        *(float *)v5.i32 = *(float *)v5.i32 + -0.5;
        v50 = (float)((16598013 * vcvts_n_s32_f32(v50, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        result[21] = v52;
        result[22] = v42;
        v49 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x269EC3009E3779, vcvt_n_s32_f32(v49, 0x18uLL), (int32x2_t)0x343FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v51);
        v5 = vdup_lane_s32(v5, 0);
        v54 = vadd_f32((float32x2_t)v5, vmul_n_f32(vadd_f32(v49, (float32x2_t)0xBF000000BF000000), v17));
        result[23] = v54.f32[1];
        result[24] = v42;
        result[25] = v54.f32[0];
        result[26] = v16;
        result[27] = v53;
        result[28] = v16;
        *(float *)v5.i32 = v15 * (float)(v47 + 2);
        *result = (float)(v53 + (float)((float)(v52 + v54.f32[1]) + v54.f32[0])) * 0.25;
        result[1] = v44;
        result[2] = (float)(vabds_f32((float)(v54.f32[1] - v52) * v46, v45 * (float)(v54.f32[0] - v52))
                          + vabds_f32(v43 * (float)(v53 - v54.f32[0]), (float)(v52 - v54.f32[0]) * v45))
                  * 0.5;
        *((_DWORD *)result + 3) = (4 * (v47 & 1)) | (8 * (v50 < 0.5)) | v47 & 1;
        result += 29;
        ++v47;
        v52 = v54.f32[1];
        v53 = v54.f32[0];
      }
      while (v48 != v47);
      v55 = v48 & 1;
      v56 = 8
          * ((float)((float)((16598013 * vcvts_n_s32_f32(v50, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605) < 0.5);
    }
    result[21] = v54.f32[1];
    result[22] = v42;
    result[23] = 0.5;
    result[24] = v42;
    result[25] = 0.5;
    result[26] = v16;
    result[27] = v54.f32[0];
    result[28] = v16;
    *result = (float)(v54.f32[0] + (float)((float)(v54.f32[1] + 0.5) + 0.5)) * 0.25;
    result[1] = v44;
    result[2] = (float)(vabds_f32((float)(0.5 - v54.f32[1]) * v46, v45 * (float)(0.5 - v54.f32[1]))
                      + vabds_f32(v43 * (float)(v54.f32[0] + -0.5), (float)(v54.f32[1] + -0.5) * v45))
              * 0.5;
    v84 = v56 | (4 * v55) | v55;
    v58 = result;
  }
  else
  {
    v18 = a4 / (float)a3;
    v19 = v18 * a5;
    v20 = -v16;
    v21 = v15 + -0.5;
    v22 = v18 - v16;
    v23 = (float)(v18 - v16) + (float)((float)(v18 * a5) * 0.26414);
    v24 = a2 - 1;
    v25 = (float)-v16 - v16;
    v26 = v16 - v16;
    if (a2 < 2)
    {
      v40 = 0;
      v41 = (float32x2_t)0x3CB5F4C03D95DBD0;
      v39 = 0.35764;
      v35 = -0.5;
      v33 = -0.5;
      v32 = result;
    }
    else
    {
      v27 = 0;
      v28 = (float32x2_t)0x3F1E37793E2C210CLL;
      v29 = 0.15086;
      v30 = 0.76414;
      v31 = (float32x2_t)vdup_n_s32(0x33800000u);
      v32 = result;
      v33 = -0.5;
      v34 = v15 + -0.5;
      v35 = -0.5;
      do
      {
        v36 = v35;
        v37 = v23;
        v38 = v33;
        v30 = (float)((16598013 * vcvts_n_s32_f32(v30, 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
        v29 = (float)((214013 * vcvts_n_s32_f32(v29, 0x18uLL) + 2531011) & 0xFFFFFF) * 0.000000059605;
        v28 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v28, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v31);
        v32[21] = v33;
        v32[22] = v20;
        v33 = v34 + (float)(v17 * (float)(v29 + -0.5));
        v32[23] = v33;
        v32[24] = v20;
        v35 = v34 + (float)(v17 * (float)(v28.f32[1] + -0.5));
        v23 = v22 + (float)(v19 * (float)(v30 + -0.5));
        v32[25] = v35;
        v32[26] = v23;
        v32[27] = v36;
        v32[28] = v37;
        v34 = (float)(v15 * (float)(v27 + 2)) + -0.5;
        *v32 = (float)(v36 + (float)((float)(v38 + v33) + v35)) * 0.25;
        v32[1] = (float)((float)(v25 + v23) + v37) * 0.25;
        v32[2] = (float)(vabds_f32((float)(v33 - v38) * (float)(v23 + v16), v26 * (float)(v35 - v38))
                       + vabds_f32((float)(v20 - v23) * (float)(v36 - v35), (float)(v38 - v35) * (float)(v37 - v23)))
               * 0.5;
        *((_DWORD *)v32 + 3) = (4 * (v27 & 1)) | (8 * (v28.f32[0] < 0.5)) | v27 & 1;
        v32 += 29;
        ++v27;
      }
      while (v24 != v27);
      v39 = (float)((16598013 * vcvts_n_s32_f32(v30, 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
      v40 = v24 & 1;
      v41 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v28, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), (float32x2_t)vdup_n_s32(0x33800000u));
    }
    v32[21] = v33;
    v32[22] = v20;
    v32[23] = 0.5;
    v32[24] = v20;
    v57 = v22 + (float)(v19 * (float)(v39 + -0.5));
    v32[25] = 0.5;
    v32[26] = v57;
    v32[27] = v35;
    v32[28] = v23;
    *v32 = (float)(v35 + (float)((float)(v33 + 0.5) + 0.5)) * 0.25;
    v32[1] = (float)((float)(v25 + v57) + v23) * 0.25;
    v32[2] = (float)(vabds_f32((float)(0.5 - v33) * (float)(v57 + v16), v26 * (float)(0.5 - v33))
                   + vabds_f32((float)(v20 - v57) * (float)(v35 + -0.5), (float)(v33 + -0.5) * (float)(v23 - v57)))
           * 0.5;
    *((_DWORD *)v32 + 3) = (4 * v40) | (8 * (v41.f32[0] < 0.5)) | v40;
    v58 = v32 + 29;
    if (a3 <= 2)
    {
      LOBYTE(v59) = 1;
    }
    else
    {
      v59 = a3 - 1;
      v60 = 1;
      v61 = (float32x2_t)vdup_n_s32(0x33800000u);
      do
      {
        v69 = (float)((16598013 * vcvts_n_s32_f32(v39, 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
        v70 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v41, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v61);
        v71 = (float)(v18 * (float)((float)v60 + 1.0)) - v16;
        v72 = v71 + (float)(v19 * (float)(v69 + -0.5));
        v73 = 2 * (v60 & 1);
        if (a2 < 2)
        {
          v62 = 0;
          v63 = -0.5;
        }
        else
        {
          v74 = 0;
          v75 = 0;
          v63 = -0.5;
          v76 = v15 + -0.5;
          do
          {
            v77 = v63;
            v69 = (float)((16598013 * vcvts_n_s32_f32(v69, 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
            v70 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v70, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v61);
            v78 = v72;
            v79 = &v58[v74];
            v80 = *(_QWORD *)&result[v74 + 27];
            *(_QWORD *)(v79 + 21) = v80;
            v81 = *(_QWORD *)&result[v74 + 25];
            v82 = v76 + (float)(v17 * (float)(v70.f32[1] + -0.5));
            v72 = v71 + (float)(v19 * (float)(v69 + -0.5));
            *(_QWORD *)(v79 + 23) = v81;
            v83 = *((float *)&v80 + 1) - v72;
            if ((float)((float)(v78 - v72) * (float)(*(float *)&v80 - v82)) >= (float)((float)(v63 - v82)
                                                                                      * (float)(*((float *)&v80 + 1)
                                                                                              - v72)))
              v72 = v78;
            if ((float)((float)(*(float *)&v80 - v82) * (float)(*((float *)&v81 + 1) - v72)) <= (float)(v83 * (float)(*(float *)&v81 - v82)))
              v63 = *(float *)&v81;
            else
              v63 = v82;
            v79[27] = v77;
            v79[28] = v78;
            if ((float)((float)(*((float *)&v81 + 1) - v72) * (float)(v77 - v63)) <= (float)((float)(*(float *)&v81 - v82)
                                                                                            * (float)(v78 - v72)))
              v63 = *(float *)&v81;
            v76 = (float)(v15 * (float)(v75 + 2)) + -0.5;
            v79[25] = v63;
            v79[26] = v72;
            *v79 = (float)(v77 + (float)((float)(*(float *)&v80 + *(float *)&v81) + v63)) * 0.25;
            v79[1] = (float)((float)((float)(*((float *)&v80 + 1) + *((float *)&v81 + 1)) + v72) + v78) * 0.25;
            v79[2] = (float)(vabds_f32((float)(*(float *)&v81 - *(float *)&v80) * (float)(v72 - *((float *)&v80 + 1)), (float)(*((float *)&v81 + 1) - *((float *)&v80 + 1)) * (float)(v63 - *(float *)&v80))+ vabds_f32((float)(*((float *)&v80 + 1) - v72) * (float)(v77 - v63), (float)(*(float *)&v80 - v63) * (float)(v78 - v72)))* 0.5;
            *((_DWORD *)v79 + 3) = v75 & 1 | (4 * ((v75 ^ v60) & 1)) | (8 * (v70.f32[0] < 0.5)) | v73;
            ++v75;
            v74 += 29;
          }
          while (v24 != v75);
          result = (float *)((char *)result + v74 * 4);
          v58 = (float *)((char *)v58 + v74 * 4);
          v62 = a2 - 1;
        }
        v39 = (float)((16598013 * vcvts_n_s32_f32(v69, 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
        v64 = *(_QWORD *)(result + 27);
        *(_QWORD *)(v58 + 21) = v64;
        v65 = HIDWORD(v64);
        v66 = *(float *)&v64;
        v67 = *(_QWORD *)(result + 25);
        *(_QWORD *)(v58 + 23) = v67;
        v68 = v71 + (float)(v19 * (float)(v39 + -0.5));
        v58[25] = 0.5;
        v58[26] = v68;
        v58[27] = v63;
        v58[28] = v72;
        *v58 = (float)(v63 + (float)((float)(v66 + *(float *)&v67) + 0.5)) * 0.25;
        v58[1] = (float)((float)((float)(*(float *)&v65 + *((float *)&v67 + 1)) + v68) + v72) * 0.25;
        v58[2] = (float)(vabds_f32((float)(*(float *)&v67 - v66) * (float)(v68 - *(float *)&v65), (float)(*((float *)&v67 + 1) - *(float *)&v65) * (float)(0.5 - v66))+ vabds_f32((float)(*(float *)&v65 - v68) * (float)(v63 + -0.5), (float)(v66 + -0.5) * (float)(v72 - v68)))* 0.5;
        LODWORD(v67) = v62 & 1 | (4 * ((v62 ^ v60) & 1));
        result += 29;
        ++v60;
        v41 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v70, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v61);
        *((_DWORD *)v58 + 3) = v67 | (8 * (v41.f32[0] < 0.5)) | v73;
        v58 += 29;
      }
      while (v60 != v59);
    }
    v85.f32[0] = (float)((16598013 * vcvts_n_s32_f32(v41.f32[0], 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
    if (a2 <= 1)
    {
      LOBYTE(v24) = 0;
      v88 = 2 * (v59 & 1);
      v90 = -0.5;
    }
    else
    {
      v86 = 0;
      v87 = 0;
      v88 = 2 * (v59 & 1);
      v85.f32[1] = (float)((12268885 * vcvts_n_s32_f32(v41.f32[1], 0x18uLL) + 10368889) & 0xFFFFFF) * 0.000000059605;
      v89 = (float32x2_t)vdup_n_s32(0x33800000u);
      v90 = -0.5;
      do
      {
        v91 = &v58[v86];
        v85 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v85, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v89);
        v92 = *(_QWORD *)&result[v86 + 27];
        *(_QWORD *)(v91 + 21) = v92;
        v93 = *(_QWORD *)&result[v86 + 25];
        v94 = v90;
        v90 = v21 + (float)(v17 * (float)(v85.f32[1] + -0.5));
        v91[27] = v94;
        v91[28] = v16;
        *(_QWORD *)(v91 + 23) = v93;
        v21 = (float)(v15 * (float)(v87 + 2)) + -0.5;
        v91[25] = v90;
        v91[26] = v16;
        *v91 = (float)(v94 + (float)(v90 + (float)(*(float *)&v92 + *(float *)&v93))) * 0.25;
        v91[1] = (float)((float)((float)(*((float *)&v92 + 1) + *((float *)&v93 + 1)) + v16) + v16) * 0.25;
        v91[2] = (float)(vabds_f32((float)(*(float *)&v93 - *(float *)&v92) * (float)(v16 - *((float *)&v92 + 1)), (float)(*((float *)&v93 + 1) - *((float *)&v92 + 1)) * (float)(v90 - *(float *)&v92))+ vabds_f32((float)(*((float *)&v92 + 1) - v16) * (float)(v94 - v90), (float)(*(float *)&v92 - v90) * v26))* 0.5;
        *((_DWORD *)v91 + 3) = v87 & 1 | (4 * ((v87 ^ v59) & 1)) | (8 * (v85.f32[0] < 0.5)) | v88;
        ++v87;
        v86 += 29;
      }
      while (v24 != v87);
      result = (float *)((char *)result + v86 * 4);
      v58 = (float *)((char *)v58 + v86 * 4);
    }
    v95 = *(_QWORD *)(result + 27);
    *(_QWORD *)(v58 + 21) = v95;
    v96 = *(_QWORD *)(result + 25);
    *(_QWORD *)(v58 + 23) = v96;
    v58[25] = 0.5;
    v58[26] = v16;
    v58[27] = v90;
    v58[28] = v16;
    *v58 = (float)(v90 + (float)((float)(*(float *)&v95 + *(float *)&v96) + 0.5)) * 0.25;
    v58[1] = (float)((float)((float)(*((float *)&v95 + 1) + *((float *)&v96 + 1)) + v16) + v16) * 0.25;
    v58[2] = (float)(vabds_f32((float)(*(float *)&v96 - *(float *)&v95) * (float)(v16 - *((float *)&v95 + 1)), (float)(*((float *)&v96 + 1) - *((float *)&v95 + 1)) * (float)(0.5 - *(float *)&v95))+ vabds_f32((float)(*((float *)&v95 + 1) - v16) * (float)(v90 + -0.5), (float)(*(float *)&v95 + -0.5) * v26))* 0.5;
    v84 = v24 & 1 | v88 & 0xFFFFFFFB | (4 * ((v24 ^ v59) & 1)) | (8
                                                                                                  * ((float)((float)((16598013 * vcvts_n_s32_f32(v85.f32[0], 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605) < 0.5));
  }
  *((_DWORD *)v58 + 3) = v84;
  return result;
}

float *HGFractured::Effect::gen_quad(HGFractured::Effect *this, int a2, int a3, float a4)
{
  uint64_t v8;
  size_t v9;
  unint64_t v10;
  float *result;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  int v20;
  float v21;
  int v22;
  float v23;
  float *v24;
  float v25;
  float v26;
  float v27;
  int v28;
  float v29;
  int v30;
  int v31;
  float v32;
  float v33;
  float v34;
  float v35;
  int v36;
  int v37;
  float *v38;
  int v39;
  int v40;
  unsigned __int8 v41;
  float v42;
  unint64_t v43;
  unint64_t v44;
  float v45;
  uint64_t v46;
  float v47;
  int v48;
  uint64_t v49;
  int v50;
  float v51;
  float v52;
  float *v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  float v59;
  float v60;
  float *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;

  v8 = a3 * (uint64_t)a2;
  v9 = 116 * v8;
  v10 = *((_QWORD *)this + 2);
  result = (float *)*((_QWORD *)this + 7);
  if (v10 < 116 * v8)
  {
    *((_QWORD *)this + 2) = v9;
    result = (float *)malloc_type_realloc(result, v9, 0x17C5E199uLL);
    *((_QWORD *)this + 7) = result;
  }
  *((_QWORD *)this + 8) = v8;
  v12 = 1.0 / (float)a2;
  v13 = a4 / (float)a3;
  v14 = a4 * 0.5;
  v15 = v12 * v13;
  v16 = -(float)(a4 * 0.5);
  if (a3 < 2)
  {
    v29 = (float)((float)((float)(v16 - v14) + v14) + v14) * 0.25;
    if (a2 < 2)
    {
      v36 = 0;
      v34 = -0.5;
      v37 = 8;
    }
    else
    {
      v30 = 0;
      v31 = a2 - 1;
      v32 = 0.0;
      v33 = 1.0 / (float)a2;
      v34 = -0.5;
      do
      {
        v35 = v34;
        v34 = v33 + -0.5;
        v32 = (float)((16598013 * vcvts_n_s32_f32(v32, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        result[21] = v35;
        result[22] = v16;
        result[23] = v33 + -0.5;
        result[24] = v16;
        result[25] = v33 + -0.5;
        result[26] = v14;
        result[27] = v35;
        result[28] = v14;
        v33 = v12 * (float)(v30 + 2);
        *result = (float)(v35 + (float)(v34 + (float)(v35 + v34))) * 0.25;
        result[1] = v29;
        result[2] = v15;
        *((_DWORD *)result + 3) = (4 * (v30 & 1)) | (8 * (v32 < 0.5)) | v30 & 1;
        result += 29;
        ++v30;
      }
      while (v31 != v30);
      v36 = v31 & 1;
      v37 = 8
          * ((float)((float)((16598013 * vcvts_n_s32_f32(v32, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605) < 0.5);
    }
    result[21] = v34;
    result[22] = v16;
    result[23] = 0.5;
    result[24] = v16;
    result[25] = 0.5;
    result[26] = v14;
    result[27] = v34;
    result[28] = v14;
    *result = (float)(v34 + (float)((float)(v34 + 0.5) + 0.5)) * 0.25;
    result[1] = v29;
    result[2] = v15;
    *((_DWORD *)result + 3) = v37 | (4 * v36) | v36;
  }
  else
  {
    v17 = -0.5;
    v18 = v12 + -0.5;
    v19 = v13 - v14;
    v20 = a2 - 1;
    v21 = (float)((float)((float)(v16 - v14) + (float)(v13 - v14)) + (float)(v13 - v14)) * 0.25;
    if (a2 < 2)
    {
      v28 = 0;
      v27 = 0.16809;
      v24 = result;
    }
    else
    {
      v22 = 0;
      v23 = 0.0;
      v24 = result;
      v25 = v12 + -0.5;
      do
      {
        v26 = v17;
        v17 = v25;
        v23 = (float)((16598013 * vcvts_n_s32_f32(v23, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        v24[21] = v26;
        v24[22] = v16;
        v24[23] = v25;
        v24[24] = v16;
        v24[25] = v25;
        v24[26] = v19;
        v24[27] = v26;
        v24[28] = v19;
        v25 = (float)(v12 * (float)(v22 + 2)) + -0.5;
        *v24 = (float)(v26 + (float)(v17 + (float)(v26 + v17))) * 0.25;
        v24[1] = v21;
        v24[2] = v15;
        *((_DWORD *)v24 + 3) = (4 * (v22 & 1)) | (8 * (v23 < 0.5)) | v22 & 1;
        v24 += 29;
        ++v22;
      }
      while (v20 != v22);
      v27 = (float)((16598013 * vcvts_n_s32_f32(v23, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      v28 = v20 & 1;
    }
    v24[21] = v17;
    v24[22] = v16;
    v24[23] = 0.5;
    v24[24] = v16;
    v24[25] = 0.5;
    v24[26] = v19;
    v24[27] = v17;
    v24[28] = v19;
    *v24 = (float)(v17 + (float)((float)(v17 + 0.5) + 0.5)) * 0.25;
    v24[1] = v21;
    v24[2] = v15;
    *((_DWORD *)v24 + 3) = (4 * v28) | (8 * (v27 < 0.5)) | v28;
    v38 = v24 + 29;
    if (a3 <= 2)
    {
      v39 = 1;
    }
    else
    {
      v39 = a3 - 1;
      v40 = 1;
      do
      {
        v47 = (float)(v13 * (float)((float)v40 + 1.0)) - v14;
        v48 = 2 * (v40 & 1);
        if (a2 < 2)
        {
          v41 = 0;
          v42 = -0.5;
        }
        else
        {
          v49 = 0;
          v50 = 0;
          v42 = -0.5;
          v51 = v12 + -0.5;
          do
          {
            v52 = v42;
            v42 = v51;
            v53 = &v38[v49];
            v27 = (float)((16598013 * vcvts_n_s32_f32(v27, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
            v54 = *(_QWORD *)&result[v49 + 27];
            *(_QWORD *)(v53 + 21) = v54;
            v55 = *(_QWORD *)&result[v49 + 25];
            *(_QWORD *)(v53 + 23) = v55;
            v53[25] = v51;
            v53[26] = v47;
            v53[27] = v52;
            v53[28] = v47;
            v51 = (float)(v12 * (float)(v50 + 2)) + -0.5;
            *v53 = (float)(v52 + (float)(v42 + (float)(*(float *)&v54 + *(float *)&v55))) * 0.25;
            v53[1] = (float)((float)((float)(*((float *)&v54 + 1) + *((float *)&v55 + 1)) + v47) + v47) * 0.25;
            v53[2] = v15;
            *((_DWORD *)v53 + 3) = v50 & 1 | (4 * ((v50 ^ v40) & 1)) | (8 * (v27 < 0.5)) | v48;
            ++v50;
            v49 += 29;
          }
          while (v20 != v50);
          result = (float *)((char *)result + v49 * 4);
          v38 = (float *)((char *)v38 + v49 * 4);
          v41 = a2 - 1;
        }
        v27 = (float)((16598013 * vcvts_n_s32_f32(v27, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        v43 = *(_QWORD *)(result + 27);
        *(_QWORD *)(v38 + 21) = v43;
        v44 = HIDWORD(v43);
        v45 = *(float *)&v43;
        v46 = *(_QWORD *)(result + 25);
        *(_QWORD *)(v38 + 23) = v46;
        v38[25] = 0.5;
        v38[26] = v47;
        v38[27] = v42;
        v38[28] = v47;
        *v38 = (float)(v42 + (float)((float)(v45 + *(float *)&v46) + 0.5)) * 0.25;
        v38[1] = (float)((float)((float)(*(float *)&v44 + *((float *)&v46 + 1)) + v47) + v47) * 0.25;
        v38[2] = v15;
        *((_DWORD *)v38 + 3) = v41 & 1 | (4 * ((v41 ^ v40) & 1)) | (8 * (v27 < 0.5)) | v48;
        result += 29;
        ++v40;
        v38 += 29;
      }
      while (v40 != v39);
    }
    v56 = 2 * (v39 & 1);
    if (a2 < 2)
    {
      LOBYTE(v20) = 0;
      v59 = -0.5;
    }
    else
    {
      v57 = 0;
      v58 = 0;
      v59 = -0.5;
      do
      {
        v60 = v59;
        v59 = v18;
        v61 = &v38[v57];
        v27 = (float)((16598013 * vcvts_n_s32_f32(v27, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        v62 = *(_QWORD *)&result[v57 + 27];
        *(_QWORD *)(v61 + 21) = v62;
        v63 = *(_QWORD *)&result[v57 + 25];
        *(_QWORD *)(v61 + 23) = v63;
        v61[25] = v18;
        v61[26] = v14;
        v61[27] = v60;
        v61[28] = v14;
        v18 = (float)(v12 * (float)(v58 + 2)) + -0.5;
        *v61 = (float)(v60 + (float)(v59 + (float)(*(float *)&v62 + *(float *)&v63))) * 0.25;
        v61[1] = (float)((float)((float)(*((float *)&v62 + 1) + *((float *)&v63 + 1)) + v14) + v14) * 0.25;
        v61[2] = v15;
        *((_DWORD *)v61 + 3) = v58 & 1 | (4 * ((v58 ^ v39) & 1)) | (8 * (v27 < 0.5)) | v56;
        ++v58;
        v57 += 29;
      }
      while (v20 != v58);
      result = (float *)((char *)result + v57 * 4);
      v38 = (float *)((char *)v38 + v57 * 4);
    }
    v64 = *(_QWORD *)(result + 27);
    *(_QWORD *)(v38 + 21) = v64;
    v65 = *(_QWORD *)(result + 25);
    *(_QWORD *)(v38 + 23) = v65;
    v38[25] = 0.5;
    v38[26] = v14;
    v38[27] = v59;
    v38[28] = v14;
    *v38 = (float)(v59 + (float)((float)(*(float *)&v64 + *(float *)&v65) + 0.5)) * 0.25;
    v38[1] = (float)((float)((float)(*((float *)&v64 + 1) + *((float *)&v65 + 1)) + v14) + v14) * 0.25;
    v38[2] = v15;
    *((_DWORD *)v38 + 3) = v20 & 1 | (4 * ((v20 ^ v39) & 1)) | (8
                                                                                                * ((float)((float)((16598013 * vcvts_n_s32_f32(v27, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605) < 0.5)) | v56;
  }
  return result;
}

void HGFractured::Effect::gen_glass(HGFractured::Effect *this, int a2, int a3, float a4, float a5)
{
  int v8;
  size_t v9;
  float *v10;
  float v12;
  double v13;
  int v14;
  int v15;
  float v16;
  float v17;
  float32x2_t v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float32x2_t v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float sinval;
  float cosval;
  __float2 v30;
  __float2 v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  int v41;
  int v42;
  int v43;
  int v44;
  float v45;
  int v46;
  float v47;
  int v48;
  float32x4_t v49;
  float32x4_t v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  long double v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float *v68;
  char v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  BOOL v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  int v92;
  float *v95;
  int v96;
  int v97;
  float v98;
  float v99;
  float32x2_t v100;
  float v101;
  float v102;
  int v103;
  float v104;
  double v105;
  float v106;
  float32x2_t v107;
  int v108;
  int v109;
  float v110;

  v8 = (int)fmaxf((float)a2, 4.0);
  v9 = 116 * a3 * (uint64_t)v8 + 464;
  v10 = (float *)*((_QWORD *)this + 7);
  if (*((_QWORD *)this + 2) < v9)
  {
    *((_QWORD *)this + 2) = v9;
    v10 = (float *)malloc_type_realloc(v10, v9, 0x6ADE3286uLL);
    *((_QWORD *)this + 7) = v10;
  }
  if ((float)(a4 * 0.5) <= 0.5)
    v12 = a4 * 0.5;
  else
    v12 = 0.5;
  v13 = pow(1.5, (double)(a3 - 1));
  v95 = v10;
  v14 = v8 - 1;
  if (v8 >= 1)
  {
    v15 = 0;
    v16 = 6.28318531 / (double)v8;
    v102 = v16;
    v17 = v12 * 0.99 / v13;
    v101 = v17;
    v106 = v17 * a5;
    v105 = v17;
    v18 = 0;
    v100 = (float32x2_t)vdup_n_s32(0x33800000u);
    v19 = -0.5;
    v20 = 0.0;
    v98 = a4 * 0.5;
    v99 = a4;
    v96 = v8 - 1;
    v97 = v8;
    do
    {
      while (1)
      {
        v23 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x269EC3009E3779, vcvt_n_s32_f32(v18, 0x18uLL), (int32x2_t)0x343FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v100);
        if (v15 == v14)
          v24 = 0.61803;
        else
          v24 = (float)((12268885 * vcvts_n_s32_f32(v23.f32[0], 0x18uLL) + 10368889) & 0xFFFFFF) * 0.000000059605;
        v104 = (float)((16598013 * vcvts_n_s32_f32(v20, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        v25 = v23.f32[1];
        v26 = (float)(v23.f32[0] + 0.61803) * v19;
        v27 = (float)(v23.f32[1] + 0.15086) * 0.5;
        v107 = v23;
        v30 = __sincosf_stret((float)((float)((float)(v23.f32[0] + v19) * a5) + (float)v15) * v102);
        cosval = v30.__cosval;
        sinval = v30.__sinval;
        v103 = v15 + 1;
        v31 = __sincosf_stret((float)((float)((float)(v24 + -0.5) * a5) + (float)(v15 + 1)) * v102);
        v19 = -0.5;
        v33 = v31.__cosval;
        v32 = v31.__sinval;
        v34 = (float)((float)((float)(a5 * 0.5) * v26) + 1.0) * v101;
        v35 = 0.5;
        v36 = (float)(v106 * (float)((float)(v27 * a5) + -0.5)) + v34;
        v37 = v34 * v30.__cosval;
        v38 = v34 * v30.__sinval;
        v39 = v36 * v31.__cosval;
        v40 = v36 * v31.__sinval;
        v10[21] = v39;
        v10[22] = v40;
        v10[23] = 0.0;
        v10[24] = 0.0;
        v10[25] = v37;
        v10[26] = v38;
        v10[27] = v39;
        v10[28] = v40;
        *v10 = (float)((float)(v37 + 0.0) + v39) / 3.0;
        v10[1] = (float)((float)(v38 + 0.0) + v40) / 3.0;
        v10[2] = vabds_f32((float)(0.0 - v39) * (float)(v38 - v40), (float)(0.0 - v40) * (float)(v37 - v39)) * 0.5;
        v41 = v15 & 1;
        v42 = 8 * (v104 < 0.5);
        *((_DWORD *)v10 + 3) = v41 | (4 * (v15 & 1)) & 0xF7 | v42;
        if (a3 < 3)
        {
          v68 = v10 + 29;
          v69 = 1;
          v71 = v98;
          v70 = v99;
        }
        else
        {
          v43 = 2;
          v44 = 1033231312;
          v45 = 0.15452;
          v46 = 1052187892;
          v47 = 0.022211;
          v48 = 2;
          do
          {
            v49.i64[0] = __PAIR64__(v46, LODWORD(v47));
            v49.i64[1] = __PAIR64__(v44, LODWORD(v45));
            v50 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)(*(_OWORD *)&vmlaq_s32((int32x4_t)xmmword_1B3524D30, vcvtq_n_s32_f32(v49, 0x18uLL), (int32x4_t)xmmword_1B3524D20) & __PAIR128__(0xFFFFFF00FFFFFFLL, 0xFFFFFF00FFFFFFLL))), (float32x4_t)vdupq_n_s32(0x33800000u));
            v110 = v50.f32[0];
            v51 = v50.f32[2];
            v108 = v50.i32[1];
            v109 = v50.i32[3];
            v52 = (float)(v25 + v45) * 0.5;
            v53 = v25;
            v54 = sinval;
            v55 = v32;
            v56 = cosval;
            v57 = v33;
            v58 = pow(1.5, (float)((float)v43 + (float)((float)((float)(v107.f32[0] + v47) * v19) * a5)));
            v33 = v57;
            cosval = v56;
            v32 = v55;
            sinval = v54;
            v25 = v53;
            v19 = -0.5;
            *(float *)&v58 = v58 * v105;
            v35 = 0.5;
            v59 = (float)(v106 * (float)((float)(v52 * a5) + -0.5)) + *(float *)&v58;
            v60 = v10[27];
            v61 = v10[25];
            v62 = v56 * *(float *)&v58;
            v63 = v33 * v59;
            v10[29] = (float)((float)(v33 * v59) + (float)((float)(v56 * *(float *)&v58) + (float)(v60 + v61))) * 0.25;
            v10 += 29;
            v64 = *(v10 - 1);
            v10[21] = v60;
            v10[22] = v64;
            v65 = *(v10 - 3);
            v10[23] = v61;
            v10[24] = v65;
            *(float *)&v58 = sinval * *(float *)&v58;
            v66 = v32 * v59;
            v10[25] = v62;
            v10[26] = *(float *)&v58;
            v10[27] = v63;
            v10[28] = v66;
            v67 = (float)(v66 + (float)(*(float *)&v58 + (float)(v64 + v65))) * 0.25;
            *(float *)&v58 = vabds_f32((float)(v10[23] - v10[21]) * (float)(*(float *)&v58 - v10[22]), (float)(v10[24] - v10[22]) * (float)(v62 - v10[21]))+ vabds_f32((float)(v10[22] - *(float *)&v58) * (float)(v63 - v62), (float)(v10[21] - v62) * (float)(v66 - *(float *)&v58));
            v46 = v108;
            v44 = v109;
            v10[1] = v67;
            v10[2] = *(float *)&v58 * 0.5;
            *((_DWORD *)v10 + 3) = v48 & 2 | (4 * (((v43 - 1) ^ v15) & 1)) | v41 | v42;
            v48 += 2;
            ++v43;
            v47 = v110;
            v45 = v51;
          }
          while (a3 != v43);
          v39 = v10[27];
          v40 = v10[28];
          v68 = v10 + 29;
          v8 = v97;
          v69 = a3 - 1;
          v37 = v10[25];
          v38 = v10[26];
          v71 = v98;
          v70 = v99;
          v14 = v96;
        }
        if (cosval >= 0.0)
          v72 = cosval;
        else
          v72 = -cosval;
        if (sinval >= 0.0)
          v73 = sinval;
        else
          v73 = -sinval;
        v74 = 0.5;
        v75 = v71;
        if (v73 != (float)(v72 * v70))
        {
          if (v73 < (float)(v72 * v70))
          {
            v75 = (float)(v73 * 0.5) / v72;
          }
          else
          {
            v75 = v71;
            v74 = (float)(v71 * v72) / v73;
          }
        }
        if (cosval < 0.0)
          v74 = -v74;
        v76 = -v75;
        if (sinval >= 0.0)
          v76 = v75;
        v77 = -v33;
        if (v33 >= 0.0)
          v77 = v33;
        v78 = -v32;
        if (v32 >= 0.0)
          v78 = v32;
        v79 = v77 * v70;
        v80 = (float)(v71 * v77) / v78;
        v81 = (float)(v78 * v35) / v77;
        if (v78 < v79)
          v80 = v35;
        else
          v81 = v71;
        v82 = v78 == v79;
        if (v78 == v79)
          v83 = v71;
        else
          v83 = v81;
        if (v82)
          v84 = v35;
        else
          v84 = v80;
        if (v33 < 0.0)
          v84 = -v84;
        if (v32 < 0.0)
          v83 = -v83;
        v10[50] = v39;
        v10[51] = v40;
        v10[52] = v37;
        v10[53] = v38;
        v10[54] = v74;
        v10[55] = v76;
        v10[56] = v84;
        v10[57] = v83;
        v85 = (float)((float)((float)(v40 + v38) + v76) + v83) * 0.25;
        *v68 = (float)((float)((float)(v39 + v37) + v74) + v84) * 0.25;
        v86 = v10[50];
        v87 = v10[51];
        v88 = v10[54];
        v89 = v10[55];
        v90 = vabds_f32((float)(v10[52] - v86) * (float)(v89 - v87), (float)(v10[53] - v87) * (float)(v88 - v86));
        v91 = vabds_f32((float)(v87 - v89) * (float)(v10[56] - v88), (float)(v86 - v88) * (float)(v10[57] - v89));
        v10[30] = v85;
        v10[31] = (float)(v90 + v91) * v35;
        v92 = (4 * ((v69 ^ v15) & 1)) | (2 * (v69 & 1)) | v41 | v42;
        *((_DWORD *)v10 + 32) = v92;
        if (v76 != v83 && v74 != v84)
          break;
        v10 += 58;
        v18 = v107;
        v20 = v104;
        ++v15;
        if (v103 == v8)
          goto LABEL_60;
      }
      if ((float)(v83 * v84) >= 0.0)
        v21 = v74;
      else
        v21 = v84;
      if ((float)(v83 * v84) >= 0.0)
        v22 = v83;
      else
        v22 = v76;
      v10[79] = v84;
      v10[80] = v83;
      v10[81] = v74;
      v10[82] = v76;
      v10[83] = v21;
      v10[84] = v22;
      v10[85] = v21;
      v10[86] = v22;
      v10[58] = (float)(v21 + (float)((float)(v74 + v84) + v21)) * 0.25;
      v10[59] = (float)(v22 + (float)((float)(v76 + v83) + v22)) * 0.25;
      v10[60] = (float)(vabds_f32((float)(v74 - v84) * (float)(v22 - v83), (float)(v76 - v83) * (float)(v21 - v84))
                      + vabds_f32((float)(v83 - v22) * (float)(v21 - v21), (float)(v84 - v21) * (float)(v22 - v22)))
              * v35;
      *((_DWORD *)v10 + 61) = v92;
      v10 += 87;
      v18 = v107;
      v20 = v104;
      ++v15;
    }
    while (v103 != v8);
  }
LABEL_60:
  *((_QWORD *)this + 8) = 0x34F72C234F72C235 * (v10 - v95);
}

void HGFractured::Effect::gen_glass(HGFractured::Effect *this, int a2, int a3, float a4)
{
  int v5;
  size_t v6;
  void *v7;
  void *v9;
  float v10;
  float v11;
  double v12;
  int v13;
  float v14;
  float v15;
  double v16;
  float *v17;
  float v18;
  __float2 v19;
  int v20;
  __float2 v21;
  float v22;
  float v23;
  float v24;
  float v25;
  int v26;
  int v27;
  int v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float *v38;
  char v39;
  float v40;
  float v41;
  float cosval;
  float sinval;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  int v54;
  float v55;
  float v56;
  _BYTE *v58;
  int v59;
  float v60;
  float v61;
  float v62;
  float v63;

  v5 = (int)fmaxf((float)a2, 4.0);
  v6 = 116 * a3 * (uint64_t)v5 + 464;
  v7 = (void *)*((_QWORD *)this + 7);
  v63 = a4;
  if (*((_QWORD *)this + 2) < v6)
  {
    *((_QWORD *)this + 2) = v6;
    v9 = malloc_type_realloc(v7, v6, 0xF2EAA3DCuLL);
    a4 = v63;
    v7 = v9;
    *((_QWORD *)this + 7) = v9;
  }
  v10 = a4 * 0.5;
  v62 = v10;
  if (v10 <= 0.5)
    v11 = v10;
  else
    v11 = 0.5;
  v12 = pow(1.5, (double)(a3 - 1));
  v58 = v7;
  if (v5 >= 1)
  {
    v13 = 0;
    v14 = 6.28318531 / (double)v5;
    v61 = v14;
    v15 = v11 * 0.99 / v12;
    v60 = v15;
    v16 = v15;
    v17 = (float *)v7;
    v18 = 0.0;
    v59 = v5;
    do
    {
      v18 = (float)((16598013 * vcvts_n_s32_f32(v18, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      v19 = __sincosf_stret(v61 * (float)v13);
      v20 = v13 + 1;
      v21 = __sincosf_stret(v61 * (float)(v13 + 1));
      v22 = v19.__cosval * v60;
      v23 = v19.__sinval * v60;
      v24 = v21.__cosval * v60;
      v25 = v21.__sinval * v60;
      v17[21] = v21.__cosval * v60;
      v17[22] = v21.__sinval * v60;
      v17[23] = 0.0;
      v17[24] = 0.0;
      v17[25] = v19.__cosval * v60;
      v17[26] = v19.__sinval * v60;
      v17[27] = v21.__cosval * v60;
      v17[28] = v21.__sinval * v60;
      *v17 = (float)((float)((float)(v19.__cosval * v60) + 0.0) + (float)(v21.__cosval * v60)) / 3.0;
      v17[1] = (float)((float)((float)(v19.__sinval * v60) + 0.0) + (float)(v21.__sinval * v60)) / 3.0;
      v17[2] = vabds_f32((float)(0.0 - (float)(v21.__cosval * v60))* (float)((float)(v19.__sinval * v60) - (float)(v21.__sinval * v60)), (float)(0.0 - (float)(v21.__sinval * v60))* (float)((float)(v19.__cosval * v60) - (float)(v21.__cosval * v60)))* 0.5;
      v26 = v13 & 1;
      *((_DWORD *)v17 + 3) = (4 * v26) | (8 * (v18 < 0.5)) | v26;
      if (a3 < 3)
      {
        v38 = v17 + 29;
        v39 = 1;
        v41 = v62;
        v40 = v63;
      }
      else
      {
        v27 = 2;
        v28 = 2;
        do
        {
          v18 = (float)((16598013 * vcvts_n_s32_f32(v18, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
          v29 = pow(1.5, (double)v27) * v16;
          v30 = v17[27];
          v31 = v17[25];
          v32 = v19.__cosval * v29;
          v33 = v21.__cosval * v29;
          v17[29] = (float)((float)(v21.__cosval * v29) + (float)((float)(v19.__cosval * v29) + (float)(v30 + v31)))
                  * 0.25;
          v17 += 29;
          v34 = *(v17 - 1);
          v17[21] = v30;
          v17[22] = v34;
          v35 = *(v17 - 3);
          v17[23] = v31;
          v17[24] = v35;
          v36 = v19.__sinval * v29;
          v37 = v21.__sinval * v29;
          v17[25] = v32;
          v17[26] = v36;
          v17[27] = v33;
          v17[28] = v37;
          v17[1] = (float)(v37 + (float)(v36 + (float)(v34 + v35))) * 0.25;
          v17[2] = (float)(vabds_f32((float)(v17[23] - v17[21]) * (float)(v36 - v17[22]), (float)(v17[24] - v17[22]) * (float)(v32 - v17[21]))+ vabds_f32((float)(v17[22] - v36) * (float)(v33 - v32), (float)(v17[21] - v32) * (float)(v37 - v36)))* 0.5;
          *((_DWORD *)v17 + 3) = v28 & 2 | (4 * (((v27 - 1) ^ v13) & 1)) | (8 * (v18 < 0.5)) | v26;
          v28 += 2;
          ++v27;
        }
        while (a3 != v27);
        v24 = v17[27];
        v25 = v17[28];
        v38 = v17 + 29;
        v5 = v59;
        v39 = a3 - 1;
        v22 = v17[25];
        v23 = v17[26];
        v41 = v62;
        v40 = v63;
        v20 = v13 + 1;
      }
      cosval = -v19.__cosval;
      if (v19.__cosval >= 0.0)
        cosval = v19.__cosval;
      if (v19.__sinval >= 0.0)
        sinval = v19.__sinval;
      else
        sinval = -v19.__sinval;
      v44 = 0.5;
      v45 = v41;
      v46 = 0.5;
      if (sinval != (float)(cosval * v40))
      {
        if (sinval < (float)(cosval * v40))
        {
          v45 = (float)(sinval * 0.5) / cosval;
        }
        else
        {
          v45 = v41;
          v46 = (float)(v41 * cosval) / sinval;
        }
      }
      v47 = -v46;
      if (v19.__cosval >= 0.0)
        v47 = v46;
      if (v19.__sinval < 0.0)
        v45 = -v45;
      if (v21.__cosval >= 0.0)
        v48 = v21.__cosval;
      else
        v48 = -v21.__cosval;
      if (v21.__sinval >= 0.0)
        v49 = v21.__sinval;
      else
        v49 = -v21.__sinval;
      v50 = v41;
      if (v49 != (float)(v48 * v40))
      {
        if (v49 < (float)(v48 * v40))
        {
          v50 = (float)(v49 * 0.5) / v48;
        }
        else
        {
          v50 = v41;
          v44 = (float)(v41 * v48) / v49;
        }
      }
      if (v21.__cosval < 0.0)
        v44 = -v44;
      if (v21.__sinval < 0.0)
        v50 = -v50;
      v17[50] = v24;
      v17[51] = v25;
      v17[52] = v22;
      v17[53] = v23;
      v17[54] = v47;
      v17[55] = v45;
      v17[56] = v44;
      v17[57] = v50;
      v51 = (float)((float)((float)(v25 + v23) + v45) + v50) * 0.25;
      *v38 = (float)((float)((float)(v24 + v22) + v47) + v44) * 0.25;
      v52 = v17[50];
      v53 = (float)(vabds_f32((float)(v17[52] - v52) * (float)(v17[55] - v17[51]), (float)(v17[53] - v17[51]) * (float)(v17[54] - v52))+ vabds_f32((float)(v17[51] - v17[55]) * (float)(v17[56] - v17[54]), (float)(v52 - v17[54]) * (float)(v17[57] - v17[55])))* 0.5;
      v17[30] = v51;
      v17[31] = v53;
      v54 = (4 * ((v39 ^ v13) & 1)) | (2 * (v39 & 1)) | (8 * (v18 < 0.5)) | v26;
      *((_DWORD *)v17 + 32) = v54;
      v7 = v17 + 58;
      if (v45 != v50 && v47 != v44)
      {
        if ((float)(v50 * v44) >= 0.0)
          v55 = v47;
        else
          v55 = v44;
        if ((float)(v50 * v44) >= 0.0)
          v56 = v50;
        else
          v56 = v45;
        v17[79] = v44;
        v17[80] = v50;
        v17[81] = v47;
        v17[82] = v45;
        v17[83] = v55;
        v17[84] = v56;
        v17[85] = v55;
        v17[86] = v56;
        v17[58] = (float)(v55 + (float)((float)(v47 + v44) + v55)) * 0.25;
        v17[59] = (float)(v56 + (float)((float)(v45 + v50) + v56)) * 0.25;
        v17[60] = (float)(vabds_f32((float)(v47 - v44) * (float)(v56 - v50), (float)(v45 - v50) * (float)(v55 - v44))
                        + vabds_f32((float)(v50 - v56) * (float)(v55 - v55), (float)(v44 - v55) * (float)(v56 - v56)))
                * 0.5;
        *((_DWORD *)v17 + 61) = v54;
        v7 = v17 + 87;
      }
      v17 = (float *)v7;
      v13 = v20;
    }
    while (v20 != v5);
  }
  *((_QWORD *)this + 8) = 0x34F72C234F72C235 * (((_BYTE *)v7 - v58) >> 2);
}

uint64_t HGFractured::Effect::gen_glass_2(uint64_t this, int a2, int a3, float a4, float a5, double a6, double a7, int32x2_t a8)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  size_t v12;
  void *v13;
  uint64_t v14;
  float v15;
  float v16;
  uint64_t v17;
  int v18;
  float v19;
  float v20;
  uint64_t v21;
  void *v22;
  size_t v23;
  void *v24;
  float32x2_t v25;
  float v26;
  __float2 v27;
  __float2 v28;
  float v29;
  float v30;
  float v31;
  float v32;
  unsigned int v33;
  int32x2_t v34;
  uint64_t v35;
  float32x4_t v36;
  uint64_t v37;
  float *v38;
  float *v39;
  float *v40;
  uint64_t v41;
  float v42;
  float32x2_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  float v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  float v56;
  uint64_t v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  int32x2_t v64;
  uint64_t v65;
  float32x4_t v66;
  uint64_t v67;
  float *v68;
  float *v69;
  float *v70;
  uint64_t v71;
  float v72;
  uint64_t v73;
  void *v74;
  size_t v75;
  void *v76;
  void *v77;
  size_t v78;
  void *v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  float v83;
  uint64_t v84;
  uint64_t v85;
  void *v86;
  size_t v87;
  void *v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  float v97;
  void *v98;
  size_t v99;
  void *v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  unint64_t v107;
  float v108;
  uint64_t v109;
  uint64_t v110;
  void *v111;
  size_t v112;
  void *v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  unint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  float v125;
  void *v126;
  size_t v127;
  void *v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t v135;
  float v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  void *v142;
  size_t v143;
  void *v144;
  unint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  float v156;
  int v157;
  float v158;
  int v159;
  uint64_t v160;
  float32x2_t v161;
  int v162;
  uint64_t v163;
  uint64_t v164;
  float32x2_t v165;
  uint64_t v166;
  float32x4_t v167;
  double v168;
  double v169;
  double v170;
  int32x2_t v171;
  float32x2_t v174;
  float v175;
  float v176;
  float v177;
  float32x2_t v178;
  float32x2_t v179;
  unint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  float v189[8];
  _QWORD v190[2];
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  float v194;
  float v195;
  float v196;
  float v197;
  float v198;
  float v199;
  float v200;
  float v201;
  uint64_t v202;
  float32x4x2_t v203;
  float32x4x2_t v204;
  float32x4x2_t v205;
  float32x4x2_t v206;
  float32x4x2_t v207;
  float32x4x2_t v208;

  v8 = this;
  v202 = *MEMORY[0x1E0C80C00];
  v9 = (int)fmaxf((float)a3, 2.0);
  v10 = (int)fmaxf((float)a2, 4.0);
  v11 = v9 * v10 + 4;
  v12 = 116 * v11;
  if (*(_QWORD *)(this + 16) >= 116 * v11)
  {
    v11 = *(_QWORD *)(this + 16) / 0x74uLL;
    v14 = *(_QWORD *)(this + 56);
  }
  else
  {
    v13 = *(void **)(this + 56);
    *(_QWORD *)(v8 + 16) = v12;
    this = (uint64_t)malloc_type_realloc(v13, v12, 0xB7B6A059uLL);
    v14 = this;
    *(_QWORD *)(v8 + 56) = this;
  }
  v15 = *(float *)(v8 + 208);
  *(float *)a8.i32 = *(float *)(v8 + 212) * a4;
  v194 = -0.5 - v15;
  v195 = (float)-(float)(a4 * 0.5) - *(float *)a8.i32;
  v196 = 0.5 - v15;
  v197 = v195;
  v198 = 0.5 - v15;
  v199 = (float)(a4 * 0.5) - *(float *)a8.i32;
  v200 = -0.5 - v15;
  v201 = v199;
  if ((int)v10 >= 1)
  {
    v171 = a8;
    v16 = 6.28318531 / (double)(int)v10;
    v158 = v16;
    v17 = 0;
    v18 = 0;
    v19 = log2((double)(2 * v9));
    v20 = 0.25 / (double)v9;
    v166 = v10 + 1;
    v157 = v10 - 1;
    v169 = v19;
    v170 = v20;
    v156 = fabsf(a5) * 0.5;
    v168 = (double)(int)v10 + -1.0;
    v160 = v10 + 4;
    v163 = v10 + 2;
    v164 = v10 + 3;
    v21 = 0x3E873D863DF1BBC8;
    v165 = 0;
    v174 = (float32x2_t)vdup_n_s32(0x33800000u);
    v159 = v10;
    v167 = (float32x4_t)vdupq_lane_s32(v171, 0);
    do
    {
      v178 = (float32x2_t)v21;
      if (v17 + 1 > v11)
      {
        v22 = *(void **)(v8 + 56);
        v11 = v166 + v17;
        v23 = 116 * (v166 + v17);
        *(_QWORD *)(v8 + 16) = v23;
        v24 = malloc_type_realloc(v22, v23, 0x31085643uLL);
        *(_QWORD *)(v8 + 56) = v24;
        v14 = (uint64_t)v24 + 116 * v17;
      }
      v25 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x2B0843009E3779, vcvt_n_s32_f32(v165, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v174);
      if (v18 == v157)
        v26 = 0.61803;
      else
        v26 = (float)((12268885 * vcvts_n_s32_f32(v25.f32[0], 0x18uLL) + 10368889) & 0xFFFFFF) * 0.000000059605;
      v165 = v25;
      v27 = __sincosf_stret((float)((float)((float)(v25.f32[0] + -0.5) * a5) + (float)v18) * v158);
      v162 = v18 + 1;
      v28 = __sincosf_stret((float)((float)((float)(v26 + -0.5) * a5) + (float)(v18 + 1)) * v158);
      v29 = exp2((float)((float)(v156 * v178.f32[0]) + 0.0) / v168 * v169) * v170;
      v30 = exp2((float)(vmuls_lane_f32(v156, v178, 1) + 0.0) / v168 * v169) * v170;
      v31 = v28.__cosval * v30;
      v32 = v28.__sinval * v30;
      *(float *)(v14 + 84) = v28.__cosval * v30;
      *(float *)(v14 + 88) = v28.__sinval * v30;
      *(_QWORD *)(v14 + 92) = 0;
      *(float *)(v14 + 100) = v27.__cosval * v29;
      *(float *)(v14 + 104) = v27.__sinval * v29;
      *(float *)(v14 + 108) = v28.__cosval * v30;
      *(float *)(v14 + 112) = v28.__sinval * v30;
      v33 = clip((uint64_t)&v194, (float *)(v14 + 84), (uint64_t)v190, a4);
      if (!v33)
        goto LABEL_20;
      v34.i32[0] = *(_DWORD *)(v8 + 208);
      if (v33 >= 8)
      {
        v35 = v33 & 0xFFFFFFF8;
        v36 = (float32x4_t)vdupq_lane_s32(v34, 0);
        v37 = v35;
        v38 = (float *)&v193;
        do
        {
          v39 = v38 - 8;
          v203 = vld2q_f32(v39);
          v205 = vld2q_f32(v38);
          v207.val[0] = vaddq_f32(v36, v203.val[0]);
          v207.val[1] = vaddq_f32(v167, v203.val[1]);
          v203.val[0] = vaddq_f32(v36, v205.val[0]);
          v203.val[1] = vaddq_f32(v167, v205.val[1]);
          vst2q_f32(v39, v207);
          vst2q_f32(v38, v203);
          v38 += 16;
          v37 -= 8;
        }
        while (v37);
        if (v35 == v33)
          goto LABEL_20;
      }
      else
      {
        v35 = 0;
      }
      v40 = (float *)&v190[v35] + 1;
      v41 = v33 - v35;
      do
      {
        v42 = *(float *)v171.i32 + *v40;
        *(v40 - 1) = *(float *)v34.i32 + *(v40 - 1);
        *v40 = v42;
        v40 += 2;
        --v41;
      }
      while (v41);
LABEL_20:
      v176 = v27.__sinval * v29;
      v177 = v27.__cosval * v29;
      v43 = v178;
      v161 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0xC39EC3009E3779, vcvt_n_s32_f32(vadd_f32(v178, (float32x2_t)0x3F0000003F000000), 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v174);
      v44 = v190[0];
      v45 = v190[1];
      *(_QWORD *)(v14 + 84) = v190[0];
      *(_QWORD *)(v14 + 92) = v45;
      v46 = HIDWORD(v44);
      v47 = *(float *)&v44;
      v48 = v191;
      v49 = v192;
      *(_QWORD *)(v14 + 100) = v191;
      *(_QWORD *)(v14 + 108) = v49;
      *(float *)v14 = (float)((float)((float)(v47 + *(float *)&v45) + *(float *)&v48) + *(float *)&v49) * 0.25;
      *(float *)(v14 + 4) = (float)((float)((float)(*(float *)&v46 + *((float *)&v45 + 1)) + *((float *)&v48 + 1))
                                  + *((float *)&v49 + 1))
                          * 0.25;
      *(float *)(v14 + 8) = (float)(vabds_f32((float)(*(float *)&v45 - v47) * (float)(*((float *)&v48 + 1) - *(float *)&v46), (float)(*((float *)&v45 + 1) - *(float *)&v46) * (float)(*(float *)&v48 - v47))+ vabds_f32((float)(*(float *)&v46 - *((float *)&v48 + 1))* (float)(*(float *)&v49 - *(float *)&v48), (float)(v47 - *(float *)&v48)* (float)(*((float *)&v49 + 1) - *((float *)&v48 + 1))))* 0.5;
      v50 = v18 & 1;
      v51 = 8 * (v165.f32[1] < 0.5);
      *(_DWORD *)(v14 + 12) = v50 | (4 * (v18 & 1)) & 0xF7 | v51;
      v14 += 116;
      v52 = 1;
      ++v17;
      while (1)
      {
        v175 = v32;
        v59 = v31;
        v179 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0xC39EC3009E3779, vcvt_n_s32_f32(v43, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v174);
        v60 = exp2((float)((float)((float)(v179.f32[0] + -0.5) * a5) + (float)v52) / v168 * v169) * v170;
        v61 = exp2((float)((float)((float)(v179.f32[1] + -0.5) * a5) + (float)v52) / v168 * v169) * v170;
        v189[0] = v177;
        v189[1] = v176;
        v62 = v27.__cosval * v60;
        v63 = v27.__sinval * v60;
        v189[2] = v27.__cosval * v60;
        v189[3] = v27.__sinval * v60;
        v31 = v28.__cosval * v61;
        v32 = v28.__sinval * v61;
        v189[4] = v28.__cosval * v61;
        v189[5] = v28.__sinval * v61;
        v189[6] = v59;
        v189[7] = v175;
        this = clip((uint64_t)&v194, v189, (uint64_t)&v180, a4);
        if (!(_DWORD)this)
          break;
        v64.i32[0] = *(_DWORD *)(v8 + 208);
        if (this < 8)
        {
          v65 = 0;
LABEL_31:
          v70 = (float *)&v180 + 2 * v65 + 1;
          v71 = this - v65;
          do
          {
            v72 = *(float *)v171.i32 + *v70;
            *(v70 - 1) = *(float *)v64.i32 + *(v70 - 1);
            *v70 = v72;
            v70 += 2;
            --v71;
          }
          while (v71);
          goto LABEL_33;
        }
        v65 = this & 0xFFFFFFF8;
        v66 = (float32x4_t)vdupq_lane_s32(v64, 0);
        v67 = v65;
        v68 = (float *)&v184;
        do
        {
          v69 = v68 - 8;
          v204 = vld2q_f32(v69);
          v206 = vld2q_f32(v68);
          v208.val[0] = vaddq_f32(v66, v204.val[0]);
          v208.val[1] = vaddq_f32(v167, v204.val[1]);
          v204.val[0] = vaddq_f32(v66, v206.val[0]);
          v204.val[1] = vaddq_f32(v167, v206.val[1]);
          vst2q_f32(v69, v208);
          vst2q_f32(v68, v204);
          v68 += 16;
          v67 -= 8;
        }
        while (v67);
        if (v65 != this)
          goto LABEL_31;
LABEL_33:
        switch((int)this)
        {
          case 0:
          case 1:
          case 2:
            goto LABEL_6;
          case 3:
            v73 = v17 + 1;
            if (v17 + 1 > v11)
            {
              v74 = *(void **)(v8 + 56);
              v11 = v166 + v17;
              v75 = 116 * (v166 + v17);
              *(_QWORD *)(v8 + 16) = v75;
              v76 = malloc_type_realloc(v74, v75, 0x7DA7290FuLL);
              *(_QWORD *)(v8 + 56) = v76;
              v14 = (uint64_t)v76 + 116 * v17;
            }
            v53 = v180;
            v54 = v181;
            *(_QWORD *)(v14 + 84) = v180;
            *(_QWORD *)(v14 + 92) = v54;
            *(_QWORD *)(v14 + 108) = v53;
            v55 = HIDWORD(v53);
            v56 = *(float *)&v53;
            v57 = v182;
            *(_QWORD *)(v14 + 100) = v182;
            *(float *)v14 = (float)((float)(v56 + *(float *)&v54) + *(float *)&v57) / 3.0;
            *(float *)(v14 + 4) = (float)((float)(*(float *)&v55 + *((float *)&v54 + 1)) + *((float *)&v57 + 1)) / 3.0;
            v58 = vabds_f32((float)(*(float *)&v54 - v56) * (float)(*((float *)&v57 + 1) - *(float *)&v55), (float)(*((float *)&v54 + 1) - *(float *)&v55) * (float)(*(float *)&v57 - v56));
            goto LABEL_22;
          case 4:
            v73 = v17 + 1;
            if (v17 + 1 > v11)
            {
              v77 = *(void **)(v8 + 56);
              v11 = v166 + v17;
              v78 = 116 * (v166 + v17);
              *(_QWORD *)(v8 + 16) = v78;
              v79 = malloc_type_realloc(v77, v78, 0xA0564FA1uLL);
              *(_QWORD *)(v8 + 56) = v79;
              v14 = (uint64_t)v79 + 116 * v17;
            }
            v80 = v180;
            v81 = v181;
            *(_QWORD *)(v14 + 84) = v180;
            *(_QWORD *)(v14 + 92) = v81;
            v82 = HIDWORD(v80);
            v83 = *(float *)&v80;
            v84 = v182;
            v85 = v183;
            *(_QWORD *)(v14 + 100) = v182;
            *(_QWORD *)(v14 + 108) = v85;
            *(float *)v14 = (float)((float)((float)(v83 + *(float *)&v81) + *(float *)&v84) + *(float *)&v85) * 0.25;
            *(float *)(v14 + 4) = (float)((float)((float)(*(float *)&v82 + *((float *)&v81 + 1)) + *((float *)&v84 + 1))
                                        + *((float *)&v85 + 1))
                                * 0.25;
            v58 = vabds_f32((float)(*(float *)&v81 - v83) * (float)(*((float *)&v84 + 1) - *(float *)&v82), (float)(*((float *)&v81 + 1) - *(float *)&v82) * (float)(*(float *)&v84 - v83))+ vabds_f32((float)(*(float *)&v82 - *((float *)&v84 + 1)) * (float)(*(float *)&v85 - *(float *)&v84), (float)(v83 - *(float *)&v84) * (float)(*((float *)&v85 + 1) - *((float *)&v84 + 1)));
LABEL_22:
            *(float *)(v14 + 8) = v58 * 0.5;
            *(_DWORD *)(v14 + 12) = (4 * ((v52 ^ v18) & 1)) | (2 * (v52 & 1)) | v50 | v51;
            v14 += 116;
            goto LABEL_23;
          case 5:
            v73 = v17 + 2;
            if (v17 + 2 > v11)
            {
              v86 = *(void **)(v8 + 56);
              v11 = v163 + v17;
              v87 = 116 * (v163 + v17);
              *(_QWORD *)(v8 + 16) = v87;
              v88 = malloc_type_realloc(v86, v87, 0x4E4C189CuLL);
              *(_QWORD *)(v8 + 56) = v88;
              v14 = (uint64_t)v88 + 116 * v17;
            }
            v89 = v180;
            v90 = v181;
            *(_QWORD *)(v14 + 84) = v180;
            *(_QWORD *)(v14 + 92) = v90;
            v91 = v182;
            v92 = v183;
            *(_QWORD *)(v14 + 100) = v182;
            *(_QWORD *)(v14 + 108) = v92;
            *(float *)v14 = (float)((float)((float)(*(float *)&v89 + *(float *)&v90) + *(float *)&v91) + *(float *)&v92)
                          * 0.25;
            *(float *)(v14 + 4) = (float)((float)((float)(*((float *)&v89 + 1) + *((float *)&v90 + 1))
                                                + *((float *)&v91 + 1))
                                        + *((float *)&v92 + 1))
                                * 0.25;
            *(float *)(v14 + 8) = (float)(vabds_f32((float)(*(float *)&v90 - *(float *)&v89)* (float)(*((float *)&v91 + 1) - *((float *)&v89 + 1)), (float)(*((float *)&v90 + 1) - *((float *)&v89 + 1))* (float)(*(float *)&v91 - *(float *)&v89))+ vabds_f32((float)(*((float *)&v89 + 1) - *((float *)&v91 + 1))* (float)(*(float *)&v92 - *(float *)&v91), (float)(*(float *)&v89 - *(float *)&v91)* (float)(*((float *)&v92 + 1) - *((float *)&v91 + 1))))* 0.5;
            v93 = (4 * ((v52 ^ v18) & 1)) | (2 * (v52 & 1)) | v50 | v51;
            *(_DWORD *)(v14 + 12) = v93;
            v94 = v180;
            v95 = v183;
            v96 = v184;
            *(_QWORD *)(v14 + 216) = v184;
            *(_QWORD *)(v14 + 224) = v94;
            *(_QWORD *)(v14 + 200) = v94;
            *(_QWORD *)(v14 + 208) = v95;
            *(float *)(v14 + 116) = (float)((float)(*(float *)&v94 + *(float *)&v95) + *(float *)&v96) / 3.0;
            *(float *)(v14 + 120) = (float)((float)(*((float *)&v94 + 1) + *((float *)&v95 + 1)) + *((float *)&v96 + 1))
                                  / 3.0;
            v97 = vabds_f32((float)(*(float *)&v95 - *(float *)&v94) * (float)(*((float *)&v96 + 1) - *((float *)&v94 + 1)), (float)(*((float *)&v95 + 1) - *((float *)&v94 + 1)) * (float)(*(float *)&v96 - *(float *)&v94))* 0.5;
            goto LABEL_45;
          case 6:
            v73 = v17 + 2;
            if (v17 + 2 > v11)
            {
              v98 = *(void **)(v8 + 56);
              v11 = v163 + v17;
              v99 = 116 * (v163 + v17);
              *(_QWORD *)(v8 + 16) = v99;
              v100 = malloc_type_realloc(v98, v99, 0x5134492BuLL);
              *(_QWORD *)(v8 + 56) = v100;
              v14 = (uint64_t)v100 + 116 * v17;
            }
            v101 = v180;
            v102 = v181;
            *(_QWORD *)(v14 + 84) = v180;
            *(_QWORD *)(v14 + 92) = v102;
            v103 = v182;
            v104 = v183;
            *(_QWORD *)(v14 + 100) = v182;
            *(_QWORD *)(v14 + 108) = v104;
            *(float *)v14 = (float)((float)((float)(*(float *)&v101 + *(float *)&v102) + *(float *)&v103)
                                  + *(float *)&v104)
                          * 0.25;
            *(float *)(v14 + 4) = (float)((float)((float)(*((float *)&v101 + 1) + *((float *)&v102 + 1))
                                                + *((float *)&v103 + 1))
                                        + *((float *)&v104 + 1))
                                * 0.25;
            *(float *)(v14 + 8) = (float)(vabds_f32((float)(*(float *)&v102 - *(float *)&v101)* (float)(*((float *)&v103 + 1) - *((float *)&v101 + 1)), (float)(*((float *)&v102 + 1) - *((float *)&v101 + 1))* (float)(*(float *)&v103 - *(float *)&v101))+ vabds_f32((float)(*((float *)&v101 + 1) - *((float *)&v103 + 1))* (float)(*(float *)&v104 - *(float *)&v103), (float)(*(float *)&v101 - *(float *)&v103)* (float)(*((float *)&v104 + 1) - *((float *)&v103 + 1))))* 0.5;
            v93 = (4 * ((v52 ^ v18) & 1)) | (2 * (v52 & 1)) | v50 | v51;
            *(_DWORD *)(v14 + 12) = v93;
            v105 = v180;
            v106 = v183;
            *(_QWORD *)(v14 + 200) = v180;
            *(_QWORD *)(v14 + 208) = v106;
            v107 = HIDWORD(v105);
            v108 = *(float *)&v105;
            v109 = v184;
            v110 = v185;
            *(_QWORD *)(v14 + 216) = v184;
            *(_QWORD *)(v14 + 224) = v110;
            *(float *)(v14 + 116) = (float)((float)((float)(v108 + *(float *)&v106) + *(float *)&v109) + *(float *)&v110)
                                  * 0.25;
            *(float *)(v14 + 120) = (float)((float)((float)(*(float *)&v107 + *((float *)&v106 + 1))
                                                  + *((float *)&v109 + 1))
                                          + *((float *)&v110 + 1))
                                  * 0.25;
            v97 = (float)(vabds_f32((float)(*(float *)&v106 - v108) * (float)(*((float *)&v109 + 1) - *(float *)&v107), (float)(*((float *)&v106 + 1) - *(float *)&v107) * (float)(*(float *)&v109 - v108))+ vabds_f32((float)(*(float *)&v107 - *((float *)&v109 + 1))* (float)(*(float *)&v110 - *(float *)&v109), (float)(v108 - *(float *)&v109) * (float)(*((float *)&v110 + 1) - *((float *)&v109 + 1))))* 0.5;
LABEL_45:
            *(float *)(v14 + 124) = v97;
            *(_DWORD *)(v14 + 128) = v93;
            v14 += 232;
            goto LABEL_23;
          case 7:
            v73 = v17 + 3;
            if (v17 + 3 > v11)
            {
              v111 = *(void **)(v8 + 56);
              v11 = v164 + v17;
              v112 = 116 * (v164 + v17);
              *(_QWORD *)(v8 + 16) = v112;
              v113 = malloc_type_realloc(v111, v112, 0x83FFC6ABuLL);
              *(_QWORD *)(v8 + 56) = v113;
              v14 = (uint64_t)v113 + 116 * v17;
            }
            v114 = v180;
            v115 = v181;
            *(_QWORD *)(v14 + 84) = v180;
            *(_QWORD *)(v14 + 92) = v115;
            v116 = v182;
            v117 = v183;
            *(_QWORD *)(v14 + 100) = v182;
            *(_QWORD *)(v14 + 108) = v117;
            *(float *)v14 = (float)((float)((float)(*(float *)&v114 + *(float *)&v115) + *(float *)&v116)
                                  + *(float *)&v117)
                          * 0.25;
            *(float *)(v14 + 4) = (float)((float)((float)(*((float *)&v114 + 1) + *((float *)&v115 + 1))
                                                + *((float *)&v116 + 1))
                                        + *((float *)&v117 + 1))
                                * 0.25;
            *(float *)(v14 + 8) = (float)(vabds_f32((float)(*(float *)&v115 - *(float *)&v114)* (float)(*((float *)&v116 + 1) - *((float *)&v114 + 1)), (float)(*((float *)&v115 + 1) - *((float *)&v114 + 1))* (float)(*(float *)&v116 - *(float *)&v114))+ vabds_f32((float)(*((float *)&v114 + 1) - *((float *)&v116 + 1))* (float)(*(float *)&v117 - *(float *)&v116), (float)(*(float *)&v114 - *(float *)&v116)* (float)(*((float *)&v117 + 1) - *((float *)&v116 + 1))))* 0.5;
            v118 = (4 * ((v52 ^ v18) & 1)) | (2 * (v52 & 1)) | v50 | v51;
            *(_DWORD *)(v14 + 12) = v118;
            v119 = v180;
            v120 = v183;
            v121 = v186;
            *(_QWORD *)(v14 + 216) = v186;
            *(_QWORD *)(v14 + 224) = v119;
            *(_QWORD *)(v14 + 200) = v119;
            *(_QWORD *)(v14 + 208) = v120;
            *(_QWORD *)(v14 + 316) = v121;
            *(_QWORD *)(v14 + 324) = v120;
            v122 = v120;
            *(float *)(v14 + 116) = (float)((float)(*(float *)&v119 + *(float *)&v120) + *(float *)&v121) / 3.0;
            *(float *)(v14 + 120) = (float)((float)(*((float *)&v119 + 1) + *((float *)&v120 + 1))
                                          + *((float *)&v121 + 1))
                                  / 3.0;
            *(float *)(v14 + 124) = vabds_f32((float)(*(float *)&v120 - *(float *)&v119)* (float)(*((float *)&v121 + 1) - *((float *)&v119 + 1)), (float)(*((float *)&v120 + 1) - *((float *)&v119 + 1))* (float)(*(float *)&v121 - *(float *)&v119))* 0.5;
            *(_DWORD *)(v14 + 128) = v118;
            v123 = v184;
            *(_QWORD *)(v14 + 332) = v184;
            v124 = v185;
            *(_QWORD *)(v14 + 340) = v185;
            *(float *)(v14 + 232) = (float)((float)((float)(*(float *)&v121 + *(float *)&v122) + *(float *)&v123)
                                          + *(float *)&v124)
                                  * 0.25;
            *(float *)(v14 + 236) = (float)((float)((float)(*((float *)&v121 + 1) + *((float *)&v122 + 1))
                                                  + *((float *)&v123 + 1))
                                          + *((float *)&v124 + 1))
                                  * 0.25;
            v125 = (float)(vabds_f32((float)(*(float *)&v122 - *(float *)&v121)* (float)(*((float *)&v123 + 1) - *((float *)&v121 + 1)), (float)(*((float *)&v122 + 1) - *((float *)&v121 + 1))* (float)(*(float *)&v123 - *(float *)&v121))+ vabds_f32((float)(*((float *)&v121 + 1) - *((float *)&v123 + 1))* (float)(*(float *)&v124 - *(float *)&v123), (float)(*(float *)&v121 - *(float *)&v123)* (float)(*((float *)&v124 + 1) - *((float *)&v123 + 1))))* 0.5;
            goto LABEL_52;
          case 8:
            v73 = v17 + 3;
            if (v17 + 3 > v11)
            {
              v126 = *(void **)(v8 + 56);
              v11 = v164 + v17;
              v127 = 116 * (v164 + v17);
              *(_QWORD *)(v8 + 16) = v127;
              v128 = malloc_type_realloc(v126, v127, 0x9148B6F5uLL);
              *(_QWORD *)(v8 + 56) = v128;
              v14 = (uint64_t)v128 + 116 * v17;
            }
            v129 = v180;
            v130 = v181;
            *(_QWORD *)(v14 + 84) = v180;
            *(_QWORD *)(v14 + 92) = v130;
            v131 = v182;
            v132 = v183;
            *(_QWORD *)(v14 + 100) = v182;
            *(_QWORD *)(v14 + 108) = v132;
            *(float *)v14 = (float)((float)((float)(*(float *)&v129 + *(float *)&v130) + *(float *)&v131)
                                  + *(float *)&v132)
                          * 0.25;
            *(float *)(v14 + 4) = (float)((float)((float)(*((float *)&v129 + 1) + *((float *)&v130 + 1))
                                                + *((float *)&v131 + 1))
                                        + *((float *)&v132 + 1))
                                * 0.25;
            *(float *)(v14 + 8) = (float)(vabds_f32((float)(*(float *)&v130 - *(float *)&v129)* (float)(*((float *)&v131 + 1) - *((float *)&v129 + 1)), (float)(*((float *)&v130 + 1) - *((float *)&v129 + 1))* (float)(*(float *)&v131 - *(float *)&v129))+ vabds_f32((float)(*((float *)&v129 + 1) - *((float *)&v131 + 1))* (float)(*(float *)&v132 - *(float *)&v131), (float)(*(float *)&v129 - *(float *)&v131)* (float)(*((float *)&v132 + 1) - *((float *)&v131 + 1))))* 0.5;
            v118 = (4 * ((v52 ^ v18) & 1)) | (2 * (v52 & 1)) | v50 | v51;
            *(_DWORD *)(v14 + 12) = v118;
            v133 = v180;
            v134 = v183;
            *(_QWORD *)(v14 + 200) = v180;
            *(_QWORD *)(v14 + 208) = v134;
            v135 = HIDWORD(v133);
            v136 = *(float *)&v133;
            v137 = v184;
            v138 = v187;
            *(_QWORD *)(v14 + 216) = v184;
            *(_QWORD *)(v14 + 224) = v138;
            *(_QWORD *)(v14 + 316) = v138;
            *(_QWORD *)(v14 + 324) = v137;
            v139 = v137;
            *(float *)(v14 + 116) = (float)((float)((float)(v136 + *(float *)&v134) + *(float *)&v137) + *(float *)&v138)
                                  * 0.25;
            *(float *)(v14 + 120) = (float)((float)((float)(*(float *)&v135 + *((float *)&v134 + 1))
                                                  + *((float *)&v137 + 1))
                                          + *((float *)&v138 + 1))
                                  * 0.25;
            *(float *)(v14 + 124) = (float)(vabds_f32((float)(*(float *)&v134 - v136)* (float)(*((float *)&v137 + 1) - *(float *)&v135), (float)(*((float *)&v134 + 1) - *(float *)&v135)* (float)(*(float *)&v137 - v136))+ vabds_f32((float)(*(float *)&v135 - *((float *)&v137 + 1))* (float)(*(float *)&v138 - *(float *)&v137), (float)(v136 - *(float *)&v137)* (float)(*((float *)&v138 + 1) - *((float *)&v137 + 1))))* 0.5;
            *(_DWORD *)(v14 + 128) = v118;
            v140 = v185;
            *(_QWORD *)(v14 + 332) = v185;
            v141 = v186;
            *(_QWORD *)(v14 + 340) = v186;
            *(float *)(v14 + 232) = (float)((float)((float)(*(float *)&v138 + *(float *)&v139) + *(float *)&v140)
                                          + *(float *)&v141)
                                  * 0.25;
            *(float *)(v14 + 236) = (float)((float)((float)(*((float *)&v138 + 1) + *((float *)&v139 + 1))
                                                  + *((float *)&v140 + 1))
                                          + *((float *)&v141 + 1))
                                  * 0.25;
            v125 = (float)(vabds_f32((float)(*(float *)&v139 - *(float *)&v138)* (float)(*((float *)&v140 + 1) - *((float *)&v138 + 1)), (float)(*((float *)&v139 + 1) - *((float *)&v138 + 1))* (float)(*(float *)&v140 - *(float *)&v138))+ vabds_f32((float)(*((float *)&v138 + 1) - *((float *)&v140 + 1))* (float)(*(float *)&v141 - *(float *)&v140), (float)(*(float *)&v138 - *(float *)&v140)* (float)(*((float *)&v141 + 1) - *((float *)&v140 + 1))))* 0.5;
LABEL_52:
            *(float *)(v14 + 240) = v125;
            *(_DWORD *)(v14 + 244) = v118;
            v14 += 348;
            goto LABEL_23;
          case 9:
            v73 = v17 + 4;
            if (v17 + 4 > v11)
            {
              v142 = *(void **)(v8 + 56);
              v11 = v160 + v17;
              v143 = 116 * (v160 + v17);
              *(_QWORD *)(v8 + 16) = v143;
              v144 = malloc_type_realloc(v142, v143, 0x4A1BFCC3uLL);
              *(_QWORD *)(v8 + 56) = v144;
              v14 = (uint64_t)v144 + 116 * v17;
            }
            v145 = v180;
            v146 = v181;
            *(_QWORD *)(v14 + 84) = v180;
            *(_QWORD *)(v14 + 92) = v146;
            v147 = v182;
            v148 = v183;
            *(_QWORD *)(v14 + 100) = v182;
            *(_QWORD *)(v14 + 108) = v148;
            *(float *)v14 = (float)((float)((float)(*(float *)&v145 + *(float *)&v146) + *(float *)&v147)
                                  + *(float *)&v148)
                          * 0.25;
            *(float *)(v14 + 4) = (float)((float)((float)(*((float *)&v145 + 1) + *((float *)&v146 + 1))
                                                + *((float *)&v147 + 1))
                                        + *((float *)&v148 + 1))
                                * 0.25;
            *(float *)(v14 + 8) = (float)(vabds_f32((float)(*(float *)&v146 - *(float *)&v145)* (float)(*((float *)&v147 + 1) - *((float *)&v145 + 1)), (float)(*((float *)&v146 + 1) - *((float *)&v145 + 1))* (float)(*(float *)&v147 - *(float *)&v145))+ vabds_f32((float)(*((float *)&v145 + 1) - *((float *)&v147 + 1))* (float)(*(float *)&v148 - *(float *)&v147), (float)(*(float *)&v145 - *(float *)&v147)* (float)(*((float *)&v148 + 1) - *((float *)&v147 + 1))))* 0.5;
            LODWORD(v145) = (4 * ((v52 ^ v18) & 1)) | (2 * (v52 & 1)) | v50 | v51;
            *(_DWORD *)(v14 + 12) = v145;
            v149 = v180;
            v150 = v183;
            *(_QWORD *)(v14 + 200) = v180;
            *(_QWORD *)(v14 + 208) = v150;
            v151 = v185;
            v152 = v188;
            *(_QWORD *)(v14 + 316) = v150;
            v153 = v184;
            *(_QWORD *)(v14 + 332) = v151;
            *(_QWORD *)(v14 + 340) = v150;
            *(_QWORD *)(v14 + 216) = v151;
            *(_QWORD *)(v14 + 224) = v152;
            *(_QWORD *)(v14 + 324) = v153;
            *(float *)(v14 + 116) = (float)((float)((float)(*(float *)&v149 + *(float *)&v150) + *(float *)&v151)
                                          + *(float *)&v152)
                                  * 0.25;
            *(float *)(v14 + 120) = (float)((float)((float)(*((float *)&v149 + 1) + *((float *)&v150 + 1))
                                                  + *((float *)&v151 + 1))
                                          + *((float *)&v152 + 1))
                                  * 0.25;
            *(float *)(v14 + 124) = (float)(vabds_f32((float)(*(float *)&v150 - *(float *)&v149)* (float)(*((float *)&v151 + 1) - *((float *)&v149 + 1)), (float)(*((float *)&v150 + 1) - *((float *)&v149 + 1))* (float)(*(float *)&v151 - *(float *)&v149))+ vabds_f32((float)(*((float *)&v149 + 1) - *((float *)&v151 + 1))* (float)(*(float *)&v152 - *(float *)&v151), (float)(*(float *)&v149 - *(float *)&v151)* (float)(*((float *)&v152 + 1) - *((float *)&v151 + 1))))* 0.5;
            *(_DWORD *)(v14 + 128) = v145;
            v155 = v186;
            v154 = v187;
            *(_QWORD *)(v14 + 432) = v187;
            *(_QWORD *)(v14 + 440) = v153;
            *(float *)(v14 + 232) = (float)((float)(*(float *)&v150 + *(float *)&v153) + *(float *)&v151) / 3.0;
            *(float *)(v14 + 236) = (float)((float)(*((float *)&v150 + 1) + *((float *)&v153 + 1))
                                          + *((float *)&v151 + 1))
                                  / 3.0;
            *(float *)(v14 + 240) = vabds_f32((float)(*(float *)&v153 - *(float *)&v150)* (float)(*((float *)&v151 + 1) - *((float *)&v150 + 1)), (float)(*((float *)&v153 + 1) - *((float *)&v150 + 1))* (float)(*(float *)&v151 - *(float *)&v150))* 0.5;
            *(_DWORD *)(v14 + 244) = v145;
            *(_QWORD *)(v14 + 448) = v151;
            *(_QWORD *)(v14 + 456) = v155;
            *(float *)(v14 + 348) = (float)((float)((float)(*(float *)&v154 + *(float *)&v153) + *(float *)&v151)
                                          + *(float *)&v155)
                                  * 0.25;
            *(float *)(v14 + 352) = (float)((float)((float)(*((float *)&v154 + 1) + *((float *)&v153 + 1))
                                                  + *((float *)&v151 + 1))
                                          + *((float *)&v155 + 1))
                                  * 0.25;
            *(float *)(v14 + 356) = (float)(vabds_f32((float)(*(float *)&v153 - *(float *)&v154)* (float)(*((float *)&v151 + 1) - *((float *)&v154 + 1)), (float)(*((float *)&v153 + 1) - *((float *)&v154 + 1))* (float)(*(float *)&v151 - *(float *)&v154))+ vabds_f32((float)(*((float *)&v154 + 1) - *((float *)&v151 + 1))* (float)(*(float *)&v155 - *(float *)&v151), (float)(*(float *)&v154 - *(float *)&v151)* (float)(*((float *)&v155 + 1) - *((float *)&v151 + 1))))* 0.5;
            *(_DWORD *)(v14 + 360) = v145;
            v14 += 464;
LABEL_23:
            v17 = v73;
            break;
          default:
            break;
        }
        v176 = v63;
        v177 = v62;
        ++v52;
        v43 = v179;
      }
LABEL_6:
      ++v18;
      v21 = (uint64_t)v161;
    }
    while (v162 != v159);
  }
  *(_QWORD *)(v8 + 64) = 0x34F72C234F72C235 * ((v14 - *(_QWORD *)(v8 + 56)) >> 2);
  return this;
}

void HGFractured::Effect::gen_glass_2(HGFractured::Effect *this, int a2, int a3, float a4)
{
  int v5;
  uint64_t v6;
  unint64_t v7;
  size_t v8;
  void *v9;
  char *v10;
  double v11;
  uint64_t v12;
  float v13;
  float v14;
  float v15;
  double v16;
  float v17;
  void *v18;
  size_t v19;
  char *v20;
  __float2 v21;
  __float2 v22;
  float v23;
  float v24;
  uint64_t v25;
  int v26;
  char v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  float v38;
  uint64_t v39;
  float v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  size_t v44;
  char *v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  float v49;
  uint64_t v50;
  float v51;
  void *v52;
  size_t v53;
  char *v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  float v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  void *v62;
  size_t v63;
  char *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  float v73;
  float v74;
  uint64_t v75;
  uint64_t v76;
  float v77;
  float v78;
  float v79;
  void *v80;
  size_t v81;
  char *v82;
  void *v83;
  size_t v84;
  char *v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  float v93;
  uint64_t v94;
  uint64_t v95;
  void *v96;
  size_t v97;
  char *v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  float v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  void *v112;
  size_t v113;
  char *v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  float v126;
  float v127;
  int v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  HGFractured::Effect *v134;
  int v135;
  int v136;
  double v137;
  float v138;
  float v140;
  uint64_t v141;
  unint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  unint64_t v151;
  float v152;
  float v153;
  float v154;
  float v155;
  unint64_t v156;
  int v157;
  float v158;
  int v159;
  float v160;
  int v161;
  float v162;
  int v163;
  float v164;
  uint64_t v165;

  v165 = *MEMORY[0x1E0C80C00];
  v5 = (int)fmaxf((float)a3, 2.0);
  v6 = (int)fmaxf((float)a2, 4.0);
  v7 = v5 * v6 + 4;
  v8 = 116 * v7;
  if (*((_QWORD *)this + 2) >= 116 * v7)
  {
    v7 = *((_QWORD *)this + 2) / 0x74uLL;
    v10 = (char *)*((_QWORD *)this + 7);
  }
  else
  {
    v9 = (void *)*((_QWORD *)this + 7);
    *((_QWORD *)this + 2) = v8;
    v10 = (char *)malloc_type_realloc(v9, v8, 0x70B54298uLL);
    *((_QWORD *)this + 7) = v10;
  }
  v134 = this;
  v11 = log2((double)(2 * v5));
  v157 = -1090519040;
  v158 = -(float)(a4 * 0.5);
  v159 = 1056964608;
  v160 = v158;
  v161 = 1056964608;
  v162 = a4 * 0.5;
  v163 = -1090519040;
  v164 = a4 * 0.5;
  if ((int)v6 >= 1)
  {
    v12 = 0;
    v136 = 0;
    v13 = 6.28318531 / (double)(int)v6;
    v14 = 0.25 / (double)v5;
    v15 = v11;
    v138 = v15;
    v126 = v14;
    v127 = v13;
    v137 = v14;
    v16 = (double)(int)v6 + -1.0;
    v132 = v6 + 3;
    v133 = v6 + 1;
    v130 = v6 + 4;
    v131 = v6 + 2;
    v17 = 0.0;
    v128 = v6;
LABEL_7:
    if (v12 + 1 > v7)
    {
      v18 = (void *)*((_QWORD *)v134 + 7);
      v7 = v133 + v12;
      v19 = 116 * (v133 + v12);
      *((_QWORD *)v134 + 2) = v19;
      v20 = (char *)malloc_type_realloc(v18, v19, 0x19A1A0CEuLL);
      *((_QWORD *)v134 + 7) = v20;
      v10 = &v20[116 * v12];
    }
    v17 = (float)((16598013 * vcvts_n_s32_f32(v17, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
    v21 = __sincosf_stret(v127 * (float)v136);
    v129 = v136 + 1;
    v22 = __sincosf_stret(v127 * (float)(v136 + 1));
    v23 = v22.__cosval * v126;
    *((float *)v10 + 21) = v22.__cosval * v126;
    *((float *)v10 + 22) = v22.__sinval * v126;
    *((float *)v10 + 27) = v22.__cosval * v126;
    *((float *)v10 + 28) = v22.__sinval * v126;
    v24 = v21.__cosval * v126;
    *((float *)v10 + 25) = v21.__cosval * v126;
    *((float *)v10 + 26) = v21.__sinval * v126;
    v25 = COERCE_UNSIGNED_INT(v21.__sinval * v126);
    *((_DWORD *)v10 + 23) = 0;
    *((_DWORD *)v10 + 24) = 0;
    *(float *)v10 = (float)((float)((float)(v21.__cosval * v126) + 0.0) + (float)(v22.__cosval * v126)) / 3.0;
    *((float *)v10 + 1) = (float)((float)((float)(v21.__sinval * v126) + 0.0) + (float)(v22.__sinval * v126)) / 3.0;
    v135 = v136 & 1;
    *((float *)v10 + 2) = vabds_f32((float)(0.0 - (float)(v22.__cosval * v126))* (float)((float)(v21.__sinval * v126) - (float)(v22.__sinval * v126)), (float)(0.0 - (float)(v22.__sinval * v126))* (float)((float)(v21.__cosval * v126) - (float)(v22.__cosval * v126)))* 0.5;
    *((_DWORD *)v10 + 3) = (4 * v135) | (8 * (v17 < 0.5)) | v135;
    v10 += 116;
    v26 = 1;
    v27 = 2;
    ++v12;
    v28 = COERCE_UNSIGNED_INT(v22.__sinval * v126);
    while (1)
    {
      v17 = (float)((16598013 * vcvts_n_s32_f32(v17, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      v38 = exp2((float)(v138 * (float)v26) / v16) * v137;
      v151 = LODWORD(v24) | (unint64_t)(v25 << 32);
      v152 = v21.__cosval * v38;
      v153 = v21.__sinval * v38;
      v154 = v22.__cosval * v38;
      v155 = v22.__sinval * v38;
      v156 = LODWORD(v23) | (unint64_t)(v28 << 32);
      v23 = v22.__cosval * v38;
      v28 = COERCE_UNSIGNED_INT(v22.__sinval * v38);
      v24 = v21.__cosval * v38;
      v25 = COERCE_UNSIGNED_INT(v21.__sinval * v38);
      switch(clip((uint64_t)&v157, (float *)&v151, (uint64_t)&v142, a4))
      {
        case 0u:
        case 1u:
        case 2u:
          ++v136;
          if (v129 != v128)
            goto LABEL_7;
          goto LABEL_37;
        case 3u:
          v140 = v24;
          v39 = v25;
          v40 = v23;
          v41 = v28;
          v42 = v12 + 1;
          if (v12 + 1 > v7)
          {
            v43 = (void *)*((_QWORD *)v134 + 7);
            v7 = v133 + v12;
            v44 = 116 * (v133 + v12);
            *((_QWORD *)v134 + 2) = v44;
            v45 = (char *)malloc_type_realloc(v43, v44, 0x81342ADBuLL);
            *((_QWORD *)v134 + 7) = v45;
            v10 = &v45[116 * v12];
          }
          v46 = v142;
          v47 = v143;
          *(_QWORD *)(v10 + 84) = v142;
          *(_QWORD *)(v10 + 92) = v47;
          *(_QWORD *)(v10 + 108) = v46;
          v48 = HIDWORD(v46);
          v49 = *(float *)&v46;
          v50 = v144;
          *(_QWORD *)(v10 + 100) = v144;
          *(float *)v10 = (float)((float)(v49 + *(float *)&v47) + *(float *)&v50) / 3.0;
          *((float *)v10 + 1) = (float)((float)(*(float *)&v48 + *((float *)&v47 + 1)) + *((float *)&v50 + 1)) / 3.0;
          v51 = vabds_f32((float)(*(float *)&v47 - v49) * (float)(*((float *)&v50 + 1) - *(float *)&v48), (float)(*((float *)&v47 + 1) - *(float *)&v48) * (float)(*(float *)&v50 - v49));
          goto LABEL_21;
        case 4u:
          v140 = v24;
          v39 = v25;
          v40 = v23;
          v41 = v28;
          v42 = v12 + 1;
          if (v12 + 1 > v7)
          {
            v52 = (void *)*((_QWORD *)v134 + 7);
            v53 = 116 * (v133 + v12);
            *((_QWORD *)v134 + 2) = v53;
            v54 = (char *)malloc_type_realloc(v52, v53, 0x45C63B28uLL);
            *((_QWORD *)v134 + 7) = v54;
            v10 = &v54[116 * v12];
            v7 = v133 + v12;
          }
          v55 = v142;
          v56 = v143;
          *(_QWORD *)(v10 + 84) = v142;
          *(_QWORD *)(v10 + 92) = v56;
          v57 = HIDWORD(v55);
          v58 = *(float *)&v55;
          v59 = v144;
          v60 = v145;
          *(_QWORD *)(v10 + 100) = v144;
          *(_QWORD *)(v10 + 108) = v60;
          *(float *)v10 = (float)((float)((float)(v58 + *(float *)&v56) + *(float *)&v59) + *(float *)&v60) * 0.25;
          *((float *)v10 + 1) = (float)((float)((float)(*(float *)&v57 + *((float *)&v56 + 1)) + *((float *)&v59 + 1))
                                      + *((float *)&v60 + 1))
                              * 0.25;
          v51 = vabds_f32((float)(*(float *)&v56 - v58) * (float)(*((float *)&v59 + 1) - *(float *)&v57), (float)(*((float *)&v56 + 1) - *(float *)&v57) * (float)(*(float *)&v59 - v58))+ vabds_f32((float)(*(float *)&v57 - *((float *)&v59 + 1)) * (float)(*(float *)&v60 - *(float *)&v59), (float)(v58 - *(float *)&v59) * (float)(*((float *)&v60 + 1) - *((float *)&v59 + 1)));
LABEL_21:
          *((float *)v10 + 2) = v51 * 0.5;
          *((_DWORD *)v10 + 3) = v27 & 2 | (4 * ((v26 ^ v136) & 1)) | (8 * (v17 < 0.5)) | v135;
          v10 += 116;
          v12 = v42;
          v28 = v41;
          v23 = v40;
          v25 = v39;
          v24 = v140;
          break;
        case 5u:
          v141 = v28;
          v61 = v12 + 2;
          if (v12 + 2 > v7)
          {
            v80 = (void *)*((_QWORD *)v134 + 7);
            v81 = 116 * (v131 + v12);
            *((_QWORD *)v134 + 2) = v81;
            v82 = (char *)malloc_type_realloc(v80, v81, 0xEC1F2C52uLL);
            *((_QWORD *)v134 + 7) = v82;
            v10 = &v82[116 * v12];
            v7 = v131 + v12;
          }
          v29 = v142;
          v30 = v143;
          *(_QWORD *)(v10 + 84) = v142;
          *(_QWORD *)(v10 + 92) = v30;
          v31 = v144;
          v32 = v145;
          *(_QWORD *)(v10 + 100) = v144;
          *(_QWORD *)(v10 + 108) = v32;
          *(float *)v10 = (float)((float)((float)(*(float *)&v29 + *(float *)&v30) + *(float *)&v31) + *(float *)&v32)
                        * 0.25;
          *((float *)v10 + 1) = (float)((float)((float)(*((float *)&v29 + 1) + *((float *)&v30 + 1))
                                              + *((float *)&v31 + 1))
                                      + *((float *)&v32 + 1))
                              * 0.25;
          *((float *)v10 + 2) = (float)(vabds_f32((float)(*(float *)&v30 - *(float *)&v29)* (float)(*((float *)&v31 + 1) - *((float *)&v29 + 1)), (float)(*((float *)&v30 + 1) - *((float *)&v29 + 1))* (float)(*(float *)&v31 - *(float *)&v29))+ vabds_f32((float)(*((float *)&v29 + 1) - *((float *)&v31 + 1))* (float)(*(float *)&v32 - *(float *)&v31), (float)(*(float *)&v29 - *(float *)&v31)* (float)(*((float *)&v32 + 1) - *((float *)&v31 + 1))))* 0.5;
          v33 = v27 & 2 | (4 * ((v26 ^ v136) & 1)) | (8 * (v17 < 0.5)) | v135;
          *((_DWORD *)v10 + 3) = v33;
          v34 = v142;
          v35 = v145;
          v36 = v146;
          *((_QWORD *)v10 + 27) = v146;
          *((_QWORD *)v10 + 28) = v34;
          *((_QWORD *)v10 + 25) = v34;
          *((_QWORD *)v10 + 26) = v35;
          *((float *)v10 + 29) = (float)((float)(*(float *)&v34 + *(float *)&v35) + *(float *)&v36) / 3.0;
          *((float *)v10 + 30) = (float)((float)(*((float *)&v34 + 1) + *((float *)&v35 + 1)) + *((float *)&v36 + 1))
                               / 3.0;
          v37 = vabds_f32((float)(*(float *)&v35 - *(float *)&v34) * (float)(*((float *)&v36 + 1) - *((float *)&v34 + 1)), (float)(*((float *)&v35 + 1) - *((float *)&v34 + 1)) * (float)(*(float *)&v36 - *(float *)&v34));
          goto LABEL_11;
        case 6u:
          v141 = v28;
          v61 = v12 + 2;
          if (v12 + 2 > v7)
          {
            v83 = (void *)*((_QWORD *)v134 + 7);
            v84 = 116 * (v131 + v12);
            *((_QWORD *)v134 + 2) = v84;
            v85 = (char *)malloc_type_realloc(v83, v84, 0xCE099756uLL);
            *((_QWORD *)v134 + 7) = v85;
            v10 = &v85[116 * v12];
            v7 = v131 + v12;
          }
          v86 = v142;
          v87 = v143;
          *(_QWORD *)(v10 + 84) = v142;
          *(_QWORD *)(v10 + 92) = v87;
          v88 = v144;
          v89 = v145;
          *(_QWORD *)(v10 + 100) = v144;
          *(_QWORD *)(v10 + 108) = v89;
          *(float *)v10 = (float)((float)((float)(*(float *)&v86 + *(float *)&v87) + *(float *)&v88) + *(float *)&v89)
                        * 0.25;
          *((float *)v10 + 1) = (float)((float)((float)(*((float *)&v86 + 1) + *((float *)&v87 + 1))
                                              + *((float *)&v88 + 1))
                                      + *((float *)&v89 + 1))
                              * 0.25;
          *((float *)v10 + 2) = (float)(vabds_f32((float)(*(float *)&v87 - *(float *)&v86)* (float)(*((float *)&v88 + 1) - *((float *)&v86 + 1)), (float)(*((float *)&v87 + 1) - *((float *)&v86 + 1))* (float)(*(float *)&v88 - *(float *)&v86))+ vabds_f32((float)(*((float *)&v86 + 1) - *((float *)&v88 + 1))* (float)(*(float *)&v89 - *(float *)&v88), (float)(*(float *)&v86 - *(float *)&v88)* (float)(*((float *)&v89 + 1) - *((float *)&v88 + 1))))* 0.5;
          v33 = v27 & 2 | (4 * ((v26 ^ v136) & 1)) | (8 * (v17 < 0.5)) | v135;
          *((_DWORD *)v10 + 3) = v33;
          v90 = v142;
          v91 = v145;
          *((_QWORD *)v10 + 25) = v142;
          *((_QWORD *)v10 + 26) = v91;
          v92 = HIDWORD(v90);
          v93 = *(float *)&v90;
          v94 = v146;
          v95 = v147;
          *((_QWORD *)v10 + 27) = v146;
          *((_QWORD *)v10 + 28) = v95;
          *((float *)v10 + 29) = (float)((float)((float)(v93 + *(float *)&v91) + *(float *)&v94) + *(float *)&v95)
                               * 0.25;
          *((float *)v10 + 30) = (float)((float)((float)(*(float *)&v92 + *((float *)&v91 + 1)) + *((float *)&v94 + 1))
                                       + *((float *)&v95 + 1))
                               * 0.25;
          v37 = vabds_f32((float)(*(float *)&v91 - v93) * (float)(*((float *)&v94 + 1) - *(float *)&v92), (float)(*((float *)&v91 + 1) - *(float *)&v92) * (float)(*(float *)&v94 - v93))+ vabds_f32((float)(*(float *)&v92 - *((float *)&v94 + 1)) * (float)(*(float *)&v95 - *(float *)&v94), (float)(v93 - *(float *)&v94) * (float)(*((float *)&v95 + 1) - *((float *)&v94 + 1)));
LABEL_11:
          *((float *)v10 + 31) = v37 * 0.5;
          *((_DWORD *)v10 + 32) = v33;
          v10 += 232;
          goto LABEL_12;
        case 7u:
          v141 = v28;
          v61 = v12 + 3;
          if (v12 + 3 > v7)
          {
            v62 = (void *)*((_QWORD *)v134 + 7);
            v63 = 116 * (v132 + v12);
            *((_QWORD *)v134 + 2) = v63;
            v64 = (char *)malloc_type_realloc(v62, v63, 0x975870BCuLL);
            *((_QWORD *)v134 + 7) = v64;
            v10 = &v64[116 * v12];
            v7 = v132 + v12;
          }
          v65 = v142;
          v66 = v143;
          *(_QWORD *)(v10 + 84) = v142;
          *(_QWORD *)(v10 + 92) = v66;
          v67 = v144;
          v68 = v145;
          *(_QWORD *)(v10 + 100) = v144;
          *(_QWORD *)(v10 + 108) = v68;
          *(float *)v10 = (float)((float)((float)(*(float *)&v65 + *(float *)&v66) + *(float *)&v67) + *(float *)&v68)
                        * 0.25;
          *((float *)v10 + 1) = (float)((float)((float)(*((float *)&v65 + 1) + *((float *)&v66 + 1))
                                              + *((float *)&v67 + 1))
                                      + *((float *)&v68 + 1))
                              * 0.25;
          *((float *)v10 + 2) = (float)(vabds_f32((float)(*(float *)&v66 - *(float *)&v65)* (float)(*((float *)&v67 + 1) - *((float *)&v65 + 1)), (float)(*((float *)&v66 + 1) - *((float *)&v65 + 1))* (float)(*(float *)&v67 - *(float *)&v65))+ vabds_f32((float)(*((float *)&v65 + 1) - *((float *)&v67 + 1))* (float)(*(float *)&v68 - *(float *)&v67), (float)(*(float *)&v65 - *(float *)&v67)* (float)(*((float *)&v68 + 1) - *((float *)&v67 + 1))))* 0.5;
          v69 = v27 & 2 | (4 * ((v26 ^ v136) & 1)) | (8 * (v17 < 0.5)) | v135;
          *((_DWORD *)v10 + 3) = v69;
          v70 = v142;
          v71 = v145;
          v72 = v148;
          *((_QWORD *)v10 + 27) = v148;
          *((_QWORD *)v10 + 28) = v70;
          *((_QWORD *)v10 + 25) = v70;
          *((_QWORD *)v10 + 26) = v71;
          *(_QWORD *)(v10 + 316) = v72;
          *(_QWORD *)(v10 + 324) = v71;
          v74 = *((float *)&v71 + 1);
          v73 = *(float *)&v71;
          *((float *)v10 + 29) = (float)((float)(*(float *)&v70 + *(float *)&v71) + *(float *)&v72) / 3.0;
          *((float *)v10 + 30) = (float)((float)(*((float *)&v70 + 1) + *((float *)&v71 + 1)) + *((float *)&v72 + 1))
                               / 3.0;
          *((float *)v10 + 31) = vabds_f32((float)(*(float *)&v71 - *(float *)&v70)* (float)(*((float *)&v72 + 1) - *((float *)&v70 + 1)), (float)(*((float *)&v71 + 1) - *((float *)&v70 + 1))* (float)(*(float *)&v72 - *(float *)&v70))* 0.5;
          *((_DWORD *)v10 + 32) = v69;
          v75 = v146;
          *(_QWORD *)(v10 + 332) = v146;
          v76 = v147;
          *(_QWORD *)(v10 + 340) = v147;
          *((float *)v10 + 58) = (float)((float)((float)(*(float *)&v72 + v73) + *(float *)&v75) + *(float *)&v76)
                               * 0.25;
          *((float *)v10 + 59) = (float)((float)((float)(*((float *)&v72 + 1) + v74) + *((float *)&v75 + 1))
                                       + *((float *)&v76 + 1))
                               * 0.25;
          v77 = vabds_f32((float)(v73 - *(float *)&v72) * (float)(*((float *)&v75 + 1) - *((float *)&v72 + 1)), (float)(v74 - *((float *)&v72 + 1)) * (float)(*(float *)&v75 - *(float *)&v72));
          v78 = (float)(*((float *)&v72 + 1) - *((float *)&v75 + 1)) * (float)(*(float *)&v76 - *(float *)&v75);
          v79 = (float)(*(float *)&v72 - *(float *)&v75) * (float)(*((float *)&v76 + 1) - *((float *)&v75 + 1));
          goto LABEL_33;
        case 8u:
          v141 = v28;
          v61 = v12 + 3;
          if (v12 + 3 > v7)
          {
            v96 = (void *)*((_QWORD *)v134 + 7);
            v97 = 116 * (v132 + v12);
            *((_QWORD *)v134 + 2) = v97;
            v98 = (char *)malloc_type_realloc(v96, v97, 0x8B4ABC86uLL);
            *((_QWORD *)v134 + 7) = v98;
            v10 = &v98[116 * v12];
            v7 = v132 + v12;
          }
          v99 = v142;
          v100 = v143;
          *(_QWORD *)(v10 + 84) = v142;
          *(_QWORD *)(v10 + 92) = v100;
          v101 = v144;
          v102 = v145;
          *(_QWORD *)(v10 + 100) = v144;
          *(_QWORD *)(v10 + 108) = v102;
          *(float *)v10 = (float)((float)((float)(*(float *)&v99 + *(float *)&v100) + *(float *)&v101) + *(float *)&v102)
                        * 0.25;
          *((float *)v10 + 1) = (float)((float)((float)(*((float *)&v99 + 1) + *((float *)&v100 + 1))
                                              + *((float *)&v101 + 1))
                                      + *((float *)&v102 + 1))
                              * 0.25;
          *((float *)v10 + 2) = (float)(vabds_f32((float)(*(float *)&v100 - *(float *)&v99)* (float)(*((float *)&v101 + 1) - *((float *)&v99 + 1)), (float)(*((float *)&v100 + 1) - *((float *)&v99 + 1))* (float)(*(float *)&v101 - *(float *)&v99))+ vabds_f32((float)(*((float *)&v99 + 1) - *((float *)&v101 + 1))* (float)(*(float *)&v102 - *(float *)&v101), (float)(*(float *)&v99 - *(float *)&v101)* (float)(*((float *)&v102 + 1) - *((float *)&v101 + 1))))* 0.5;
          v69 = v27 & 2 | (4 * ((v26 ^ v136) & 1)) | (8 * (v17 < 0.5)) | v135;
          *((_DWORD *)v10 + 3) = v69;
          v103 = v142;
          v104 = v145;
          *((_QWORD *)v10 + 25) = v142;
          *((_QWORD *)v10 + 26) = v104;
          v105 = HIDWORD(v103);
          v106 = *(float *)&v103;
          v107 = v146;
          v108 = v149;
          *((_QWORD *)v10 + 27) = v146;
          *((_QWORD *)v10 + 28) = v108;
          *(_QWORD *)(v10 + 316) = v108;
          *(_QWORD *)(v10 + 324) = v107;
          v109 = v107;
          *((float *)v10 + 29) = (float)((float)((float)(v106 + *(float *)&v104) + *(float *)&v107) + *(float *)&v108)
                               * 0.25;
          *((float *)v10 + 30) = (float)((float)((float)(*(float *)&v105 + *((float *)&v104 + 1)) + *((float *)&v107 + 1))
                                       + *((float *)&v108 + 1))
                               * 0.25;
          *((float *)v10 + 31) = (float)(vabds_f32((float)(*(float *)&v104 - v106)* (float)(*((float *)&v107 + 1) - *(float *)&v105), (float)(*((float *)&v104 + 1) - *(float *)&v105)* (float)(*(float *)&v107 - v106))+ vabds_f32((float)(*(float *)&v105 - *((float *)&v107 + 1))* (float)(*(float *)&v108 - *(float *)&v107), (float)(v106 - *(float *)&v107)* (float)(*((float *)&v108 + 1) - *((float *)&v107 + 1))))* 0.5;
          *((_DWORD *)v10 + 32) = v69;
          v110 = v147;
          *(_QWORD *)(v10 + 332) = v147;
          v111 = v148;
          *(_QWORD *)(v10 + 340) = v148;
          *((float *)v10 + 58) = (float)((float)((float)(*(float *)&v108 + *(float *)&v109) + *(float *)&v110)
                                       + *(float *)&v111)
                               * 0.25;
          *((float *)v10 + 59) = (float)((float)((float)(*((float *)&v108 + 1) + *((float *)&v109 + 1))
                                               + *((float *)&v110 + 1))
                                       + *((float *)&v111 + 1))
                               * 0.25;
          v77 = vabds_f32((float)(*(float *)&v109 - *(float *)&v108) * (float)(*((float *)&v110 + 1) - *((float *)&v108 + 1)), (float)(*((float *)&v109 + 1) - *((float *)&v108 + 1)) * (float)(*(float *)&v110 - *(float *)&v108));
          v78 = (float)(*((float *)&v108 + 1) - *((float *)&v110 + 1)) * (float)(*(float *)&v111 - *(float *)&v110);
          v79 = (float)(*(float *)&v108 - *(float *)&v110) * (float)(*((float *)&v111 + 1) - *((float *)&v110 + 1));
LABEL_33:
          *((float *)v10 + 60) = (float)(v77 + vabds_f32(v78, v79)) * 0.5;
          *((_DWORD *)v10 + 61) = v69;
          v10 += 348;
          goto LABEL_12;
        case 9u:
          v141 = v28;
          v61 = v12 + 4;
          if (v12 + 4 > v7)
          {
            v112 = (void *)*((_QWORD *)v134 + 7);
            v113 = 116 * (v130 + v12);
            *((_QWORD *)v134 + 2) = v113;
            v114 = (char *)malloc_type_realloc(v112, v113, 0xFEBABAD4uLL);
            *((_QWORD *)v134 + 7) = v114;
            v10 = &v114[116 * v12];
            v7 = v130 + v12;
          }
          v115 = v142;
          v116 = v143;
          *(_QWORD *)(v10 + 84) = v142;
          *(_QWORD *)(v10 + 92) = v116;
          v117 = v144;
          v118 = v145;
          *(_QWORD *)(v10 + 100) = v144;
          *(_QWORD *)(v10 + 108) = v118;
          *(float *)v10 = (float)((float)((float)(*(float *)&v115 + *(float *)&v116) + *(float *)&v117) + *(float *)&v118)
                        * 0.25;
          *((float *)v10 + 1) = (float)((float)((float)(*((float *)&v115 + 1) + *((float *)&v116 + 1))
                                              + *((float *)&v117 + 1))
                                      + *((float *)&v118 + 1))
                              * 0.25;
          *((float *)v10 + 2) = (float)(vabds_f32((float)(*(float *)&v116 - *(float *)&v115)* (float)(*((float *)&v117 + 1) - *((float *)&v115 + 1)), (float)(*((float *)&v116 + 1) - *((float *)&v115 + 1))* (float)(*(float *)&v117 - *(float *)&v115))+ vabds_f32((float)(*((float *)&v115 + 1) - *((float *)&v117 + 1))* (float)(*(float *)&v118 - *(float *)&v117), (float)(*(float *)&v115 - *(float *)&v117)* (float)(*((float *)&v118 + 1) - *((float *)&v117 + 1))))* 0.5;
          LODWORD(v115) = v27 & 2 | (4 * ((v26 ^ v136) & 1)) | (8 * (v17 < 0.5)) | v135;
          *((_DWORD *)v10 + 3) = v115;
          v119 = v142;
          v120 = v145;
          *((_QWORD *)v10 + 25) = v142;
          *((_QWORD *)v10 + 26) = v120;
          v121 = v147;
          v122 = v150;
          *(_QWORD *)(v10 + 316) = v120;
          v123 = v146;
          *(_QWORD *)(v10 + 332) = v121;
          *(_QWORD *)(v10 + 340) = v120;
          *((_QWORD *)v10 + 27) = v121;
          *((_QWORD *)v10 + 28) = v122;
          *(_QWORD *)(v10 + 324) = v123;
          *((float *)v10 + 29) = (float)((float)((float)(*(float *)&v119 + *(float *)&v120) + *(float *)&v121)
                                       + *(float *)&v122)
                               * 0.25;
          *((float *)v10 + 30) = (float)((float)((float)(*((float *)&v119 + 1) + *((float *)&v120 + 1))
                                               + *((float *)&v121 + 1))
                                       + *((float *)&v122 + 1))
                               * 0.25;
          *((float *)v10 + 31) = (float)(vabds_f32((float)(*(float *)&v120 - *(float *)&v119)* (float)(*((float *)&v121 + 1) - *((float *)&v119 + 1)), (float)(*((float *)&v120 + 1) - *((float *)&v119 + 1))* (float)(*(float *)&v121 - *(float *)&v119))+ vabds_f32((float)(*((float *)&v119 + 1) - *((float *)&v121 + 1))* (float)(*(float *)&v122 - *(float *)&v121), (float)(*(float *)&v119 - *(float *)&v121)* (float)(*((float *)&v122 + 1) - *((float *)&v121 + 1))))* 0.5;
          *((_DWORD *)v10 + 32) = v115;
          v125 = v148;
          v124 = v149;
          *((_QWORD *)v10 + 54) = v149;
          *((_QWORD *)v10 + 55) = v123;
          *((float *)v10 + 58) = (float)((float)(*(float *)&v120 + *(float *)&v123) + *(float *)&v121) / 3.0;
          *((float *)v10 + 59) = (float)((float)(*((float *)&v120 + 1) + *((float *)&v123 + 1)) + *((float *)&v121 + 1))
                               / 3.0;
          *((float *)v10 + 60) = vabds_f32((float)(*(float *)&v123 - *(float *)&v120)* (float)(*((float *)&v121 + 1) - *((float *)&v120 + 1)), (float)(*((float *)&v123 + 1) - *((float *)&v120 + 1))* (float)(*(float *)&v121 - *(float *)&v120))* 0.5;
          *((_DWORD *)v10 + 61) = v115;
          *((_QWORD *)v10 + 56) = v121;
          *((_QWORD *)v10 + 57) = v125;
          *((float *)v10 + 87) = (float)((float)((float)(*(float *)&v124 + *(float *)&v123) + *(float *)&v121)
                                       + *(float *)&v125)
                               * 0.25;
          *((float *)v10 + 88) = (float)((float)((float)(*((float *)&v124 + 1) + *((float *)&v123 + 1))
                                               + *((float *)&v121 + 1))
                                       + *((float *)&v125 + 1))
                               * 0.25;
          *((float *)v10 + 89) = (float)(vabds_f32((float)(*(float *)&v123 - *(float *)&v124)* (float)(*((float *)&v121 + 1) - *((float *)&v124 + 1)), (float)(*((float *)&v123 + 1) - *((float *)&v124 + 1))* (float)(*(float *)&v121 - *(float *)&v124))+ vabds_f32((float)(*((float *)&v124 + 1) - *((float *)&v121 + 1))* (float)(*(float *)&v125 - *(float *)&v121), (float)(*(float *)&v124 - *(float *)&v121)* (float)(*((float *)&v125 + 1) - *((float *)&v121 + 1))))* 0.5;
          *((_DWORD *)v10 + 90) = v115;
          v10 += 464;
LABEL_12:
          v12 = v61;
          v28 = v141;
          break;
        default:
          break;
      }
      ++v26;
      v27 += 2;
    }
  }
LABEL_37:
  *((_QWORD *)v134 + 8) = 0x34F72C234F72C235 * ((uint64_t)&v10[-*((_QWORD *)v134 + 7)] >> 2);
}

void *HGFractured::Effect::gen_brick(HGFractured::Effect *this, int a2, int a3, float a4, float a5)
{
  uint64_t v10;
  size_t v11;
  unint64_t v12;
  void *result;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  int v22;
  float v23;
  int v24;
  float32x2_t v25;
  float v26;
  float32x2_t v27;
  float *v28;
  float v29;
  int v30;
  float32x2_t v31;
  float v32;
  float v33;
  int v34;
  float v35;
  float v36;
  float *v37;
  float v38;
  int v39;
  int v40;
  int v41;
  int v42;
  float *v43;
  int v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  int v50;
  int v51;
  float v52;
  int v53;
  float v54;
  char v55;
  int v56;
  unsigned __int8 v57;
  int v58;
  float32x2_t v59;
  int v60;
  float v61;
  int v62;
  float v63;
  int v64;
  int v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  int v71;
  float v72;
  float v73;
  int v74;

  v10 = (a2 + 1) * (uint64_t)a3;
  v11 = 116 * v10;
  v12 = *((_QWORD *)this + 2);
  result = (void *)*((_QWORD *)this + 7);
  if (v12 < 116 * v10)
  {
    *((_QWORD *)this + 2) = v11;
    result = malloc_type_realloc(result, v11, 0x413E0218uLL);
    *((_QWORD *)this + 7) = result;
  }
  *((_QWORD *)this + 8) = v10;
  v14 = 1.0 / (float)a2;
  v15 = a4 / (float)a3;
  v16 = a4 * 0.5;
  v17 = v14 * v15;
  v18 = -(float)(a4 * 0.5);
  if (a3 <= 1)
  {
    v32 = -0.5;
    v33 = (float)((float)((float)(v18 - v16) + v16) + v16) * 0.25;
    if (a2 < 1)
    {
      v39 = 0;
      v40 = 8;
      v37 = (float *)result;
    }
    else
    {
      v34 = 0;
      v35 = 0.0;
      v36 = 1.0;
      v37 = (float *)result;
      do
      {
        v38 = v32;
        v32 = (float)(v14 * (float)((float)((float)(a5 * -0.5) + -0.5) + v36)) + -0.5;
        v35 = (float)((16598013 * vcvts_n_s32_f32(v35, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        v37[21] = v38;
        v37[22] = v18;
        v37[23] = v32;
        v37[24] = v18;
        v37[25] = v32;
        v37[26] = v16;
        v37[27] = v38;
        v37[28] = v16;
        v36 = (float)(v34 + 2);
        *v37 = (float)(v38 + (float)(v32 + (float)(v38 + v32))) * 0.25;
        v37[1] = v33;
        v37[2] = v17;
        *((_DWORD *)v37 + 3) = (4 * (v34 & 1)) | (8 * (v35 < 0.5)) | v34 & 1;
        v37 += 29;
        ++v34;
      }
      while (a2 != v34);
      v39 = a2 & 1;
      v40 = 8
          * ((float)((float)((16598013 * vcvts_n_s32_f32(v35, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605) < 0.5);
    }
    v37[21] = v32;
    v37[22] = v18;
    v37[23] = 0.5;
    v37[24] = v18;
    v37[25] = 0.5;
    v37[26] = v16;
    v37[27] = v32;
    v37[28] = v16;
    *v37 = (float)(v32 + (float)((float)(v32 + 0.5) + 0.5)) * 0.25;
    v37[1] = v33;
    v37[2] = v17;
    v74 = v40 | (4 * v39) | v39;
  }
  else
  {
    v19 = -0.5;
    v20 = (float)(a5 * 0.11803) + -0.5;
    v21 = v15 - v16;
    v22 = a2 - (v20 == 0.0);
    v23 = (float)((float)((float)(v18 - v16) + v21) + v21) * 0.25;
    if (v22 < 1)
    {
      v30 = 0;
      v31 = (float32x2_t)0x3CB5F4C03D95DBD0;
      v28 = (float *)result;
    }
    else
    {
      v24 = 0;
      v25 = (float32x2_t)0x3F1E37793E2C210CLL;
      v26 = 1.0;
      v27 = (float32x2_t)vdup_n_s32(0x33800000u);
      v28 = (float *)result;
      do
      {
        v29 = v19;
        v19 = (float)(v14 * (float)(v20 + v26)) + -0.5;
        v25 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v25, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v27);
        v28[21] = v29;
        v28[22] = v18;
        v28[23] = v19;
        v28[24] = v18;
        v28[25] = v19;
        v28[26] = v21;
        v26 = (float)(v24 + 2);
        v28[27] = v29;
        v28[28] = v21;
        *v28 = (float)(v29 + (float)(v19 + (float)(v29 + v19))) * 0.25;
        v28[1] = v23;
        v28[2] = v17;
        *((_DWORD *)v28 + 3) = (4 * (v24 & 1)) | (8 * (v25.f32[0] < 0.5)) | v24 & 1;
        v28 += 29;
        ++v24;
      }
      while (v22 != v24);
      v30 = v22 & 1;
      v31 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v25, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), (float32x2_t)vdup_n_s32(0x33800000u));
    }
    v28[21] = v19;
    v28[22] = v18;
    v28[23] = 0.5;
    v28[24] = v18;
    v28[25] = 0.5;
    v28[26] = v21;
    v28[27] = v19;
    v28[28] = v21;
    *v28 = (float)(v19 + (float)((float)(v19 + 0.5) + 0.5)) * 0.25;
    v28[1] = v23;
    v28[2] = v17;
    *((_DWORD *)v28 + 3) = (4 * v30) | (8 * (v31.f32[0] < 0.5)) | v30;
    if (a3 <= 2)
      v41 = 2;
    else
      v41 = a3;
    v42 = v41 - 1;
    v43 = v28 + 29;
    if (v42 == 1)
    {
      v37 = v43;
    }
    else
    {
      v58 = 1;
      v59 = (float32x2_t)vdup_n_s32(0x33800000u);
      do
      {
        v65 = v58 & 1;
        if ((v58 & 1) != 0)
          v66 = 0.0;
        else
          v66 = -0.5;
        v67 = v66 + (float)((float)(v31.f32[1] + -0.5) * a5);
        v68 = (float)(v15 * (float)((float)v58 + 1.0)) - v16;
        v60 = a2 - (v67 == 0.0);
        v69 = (float)(v14 * (float)(v67 + 1.0)) + -0.5;
        v70 = v68 - v15;
        if (v60 <= 0)
        {
          LOBYTE(v60) = 0;
          v61 = (float)((float)((float)(v70 + v70) + v68) + v68) * 0.25;
          v62 = 2 * v65;
          v63 = -0.5;
        }
        else
        {
          v71 = 0;
          v62 = 2 * v65;
          v61 = (float)((float)((float)(v70 + v70) + v68) + v68) * 0.25;
          v63 = -0.5;
          do
          {
            v72 = v63;
            v63 = v69;
            v31 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v31, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v59);
            v43[21] = v72;
            v43[22] = v70;
            v43[23] = v69;
            v43[24] = v70;
            v43[25] = v69;
            v43[26] = v68;
            v43[27] = v72;
            v43[28] = v68;
            v73 = v67 + (float)(v71 + 2);
            *v43 = (float)(v72 + (float)(v63 + (float)(v72 + v63))) * 0.25;
            v43[1] = v61;
            v43[2] = v17;
            *((_DWORD *)v43 + 3) = v71 & 1 | (4 * ((v71 ^ v58) & 1)) | (8 * (v31.f32[0] < 0.5)) | v62;
            v43 += 29;
            ++v71;
            v69 = (float)(v14 * v73) + -0.5;
          }
          while (v60 != v71);
        }
        v43[21] = v63;
        v43[22] = v70;
        v43[23] = v69;
        v43[24] = v70;
        v43[25] = 0.5;
        v43[26] = v68;
        v43[27] = v63;
        v43[28] = v68;
        *v43 = (float)(v63 + (float)((float)(v63 + v69) + 0.5)) * 0.25;
        v43[1] = v61;
        v43[2] = v17;
        v64 = (4 * ((v60 ^ v58++) & 1)) | v60 & 1 | v62;
        v37 = v43 + 29;
        v31 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(_QWORD *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v31, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v59);
        *((_DWORD *)v43 + 3) = v64 | (8 * (v31.f32[0] < 0.5));
        v43 += 29;
      }
      while (v58 != v42);
    }
    v44 = v42 & 1;
    v45 = 0.0;
    v46 = -0.5;
    if ((v42 & 1) == 0)
      v45 = -0.5;
    v47 = v45 + (float)((float)(v31.f32[1] + -0.5) * a5);
    v48 = (float)(v14 * (float)(v47 + 1.0)) + -0.5;
    v49 = v16 - v15;
    v50 = a2 - v44;
    if (a2 <= v44)
    {
      v57 = 0;
      v52 = (float)((float)((float)(v49 + v49) + v16) + v16) * 0.25;
      v51 = 2 * v44;
    }
    else
    {
      v51 = 2 * v44;
      v52 = (float)((float)((float)(v49 + v49) + v16) + v16) * 0.25;
      v53 = 2;
      v46 = -0.5;
      do
      {
        v54 = v46;
        v46 = v48;
        v31.f32[0] = (float)((16598013 * vcvts_n_s32_f32(v31.f32[0], 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        v37[21] = v54;
        v37[22] = v49;
        v37[23] = v48;
        v37[24] = v49;
        v37[25] = v48;
        v37[26] = v16;
        v37[27] = v54;
        v37[28] = v16;
        *v37 = (float)(v54 + (float)(v48 + (float)(v54 + v48))) * 0.25;
        v37[1] = v52;
        v37[2] = v17;
        *((_DWORD *)v37 + 3) = ((_BYTE)v53 - 2) & 1 | (4 * (((v53 - 2) ^ v42) & 1)) | (8 * (v31.f32[0] < 0.5)) | v51;
        v37 += 29;
        v48 = (float)(v14 * (float)(v47 + (float)v53)) + -0.5;
        v55 = v53 + 1;
        v56 = v53++ - 1;
      }
      while (v56 < v50);
      v57 = v55 - 2;
    }
    v37[21] = v46;
    v37[22] = v49;
    v37[23] = v48;
    v37[24] = v49;
    v37[25] = 0.5;
    v37[26] = v16;
    v37[27] = v46;
    v37[28] = v16;
    *v37 = (float)(v46 + (float)((float)(v46 + v48) + 0.5)) * 0.25;
    v37[1] = v52;
    v37[2] = v17;
    v74 = (4 * ((v57 ^ v42) & 1)) | v57 & 1 | v51 | (8
                                                                    * ((float)((float)((16598013
                                                                                      * vcvts_n_s32_f32(v31.f32[0], 0x18uLL)+ 2820163) & 0xFFFFFF)* 0.000000059605) < 0.5));
  }
  *((_DWORD *)v37 + 3) = v74;
  *((_QWORD *)this + 8) = 0x34F72C234F72C235 * (((char *)v37 - (_BYTE *)result) >> 2);
  return result;
}

uint64_t HGFractured::Effect::build(HGFractured::Effect *this)
{
  uint64_t (*v2)(HGFractured::Effect *);

  if ((*((_BYTE *)this + 120) & 2) == 0)
    return 1;
  v2 = (uint64_t (*)(HGFractured::Effect *))*((_QWORD *)this + 28);
  if (v2)
  {
    *((_QWORD *)this + 29) = v2(this);
    *((_DWORD *)this + 30) &= ~2u;
    return 1;
  }
  return 0;
}

uint64_t HGFractured::Effect::apply(HGFractured::Effect *this, __n128 a2, __n128 a3, double a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, double a8, double a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  int v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  void (*v29)(HGFractured::Effect *, _QWORD, float);
  int v30;

  v17 = *((_DWORD *)this + 30);
  if ((v17 & 4) != 0 || *((float *)this + 22) != a2.n128_f32[0] || *((float *)this + 23) != a3.n128_f32[0])
  {
    v18 = fabsf(a2.n128_f32[0]);
    if (a2.n128_f32[0] >= 0.0)
      v18 = a2.n128_f32[0];
    v19 = fabsf(a3.n128_f32[0]);
    if (a3.n128_f32[0] >= 0.0)
      v19 = a3.n128_f32[0];
    v20 = *((float *)this + 50);
    if (v18 >= v20)
    {
      v22 = *((float *)this + 51);
      if (v18 > v22)
      {
        *(float *)&a9 = 1.0 - v22;
        v23 = fminf(fmaxf((float)(v18 - v22) / (float)(1.0 - v22), 0.0), 1.0);
        *(float *)&a8 = v23 * v23;
        v18 = v22 + (float)((float)(1.0 - v22) * (float)((float)(v23 * v23) * (float)(3.0 - (float)(v23 + v23))));
      }
    }
    else
    {
      v21 = fminf(fmaxf(v18 / v20, 0.0), 1.0);
      LODWORD(a8) = 3.0;
      v18 = v20 * (float)((float)(v21 * v21) * (float)(3.0 - (float)(v21 + v21)));
    }
    if (v19 >= v20)
    {
      v25 = *((float *)this + 51);
      if (v19 > v25)
      {
        *(float *)&a8 = 1.0 - v25;
        v26 = fminf(fmaxf((float)(v19 - v25) / (float)(1.0 - v25), 0.0), 1.0);
        LODWORD(a9) = 3.0;
        v19 = v25 + (float)((float)(1.0 - v25) * (float)((float)(v26 * v26) * (float)(3.0 - (float)(v26 + v26))));
      }
    }
    else
    {
      v24 = fminf(fmaxf(v19 / v20, 0.0), 1.0);
      LODWORD(a8) = 3.0;
      v19 = v20 * (float)((float)(v24 * v24) * (float)(3.0 - (float)(v24 + v24)));
    }
    if (a2.n128_f32[0] >= 0.0)
      v27 = v18;
    else
      v27 = -v18;
    if (a3.n128_f32[0] >= 0.0)
      v28 = v19;
    else
      v28 = -v19;
    v29 = (void (*)(HGFractured::Effect *, _QWORD, float))*((_QWORD *)this + 29);
    if (v29)
    {
      if ((v17 & 4) == 0)
      {
        if (*((float *)this + 22) != v27)
          v29(this, 0, v27);
        if (!*((_DWORD *)this + 35) || *((float *)this + 23) == v28)
          goto LABEL_39;
        goto LABEL_35;
      }
      v29(this, 0, v27);
      if (*((_DWORD *)this + 35))
LABEL_35:
        (*((void (**)(HGFractured::Effect *, float))this + 29))(this, v28);
LABEL_39:
      *((float *)this + 22) = v27;
      *((float *)this + 23) = v28;
      *((_DWORD *)this + 30) &= ~4u;
      return 1;
    }
    if ((v17 & 4) == 0 && *((float *)this + 22) == v27)
    {
      v30 = *((_DWORD *)this + 35);
      if (!v30)
        goto LABEL_39;
    }
    else
    {
      a2.n128_u32[0] = *((_DWORD *)this + 34);
      LODWORD(a4) = 0;
      a5.i32[0] = 0;
      a6.i32[0] = 0;
      a7.i32[0] = 1.0;
      a3.n128_f32[0] = v27;
      emit((uint64_t)this, *((float **)this + 12), *((float **)this + 7), *((_QWORD *)this + 8), *((_DWORD *)this + 31), 0, a2, a3, a4, a5, a6, a7, a15, a16, a8, a9, 0.0, 0, 0,
        0x3F800000u);
      v30 = *((_DWORD *)this + 35);
      if (!v30)
        goto LABEL_39;
      if ((v17 & 4) != 0)
      {
LABEL_38:
        a2.n128_u32[0] = *((_DWORD *)this + 34);
        LODWORD(a4) = 0;
        a5.i32[0] = 0;
        a6.i32[0] = 0;
        a7.i32[0] = 1.0;
        a3.n128_f32[0] = v28;
        emit((uint64_t)this, *((float **)this + 13), *((float **)this + 7), *((_QWORD *)this + 8), *((_DWORD *)this + 31), v30, a2, a3, a4, a5, a6, a7, a15, a16, a8, a9, 0.0, 0, 0,
          0x3F800000u);
        goto LABEL_39;
      }
    }
    if (*((float *)this + 23) == v28)
      goto LABEL_39;
    goto LABEL_38;
  }
  return 1;
}

BOOL HGFractured::Effect::isCropped(HGFractured::Effect *this)
{
  return *((_DWORD *)this + 20) > *((_DWORD *)this + 18) && *((_DWORD *)this + 21) > *((_DWORD *)this + 19);
}

uint64_t HGFractured::Effect::GetRect(HGFractured::Effect *this)
{
  return *((_QWORD *)this + 9);
}

uint64_t HGFractured::Effect::GetImageRect(HGFractured::Effect *this)
{
  return *(_QWORD *)((char *)this + 180);
}

uint64_t HGFractured::Effect::GetProjectionMatrix(uint64_t this, double *a2, HGRect a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  int v13;
  float v14;
  double v15;
  double v16;
  double *v18;
  double v19;

  v3 = (double)(*(_DWORD *)(this + 80) - *(_DWORD *)(this + 72));
  v4 = (double)(*(_DWORD *)(this + 84) - *(_DWORD *)(this + 76));
  v5 = v3 * 0.5 / (double)(*(_DWORD *)(this + 188) - *(_DWORD *)(this + 180));
  v6 = v4 * 0.5 / (double)(*(_DWORD *)(this + 192) - *(_DWORD *)(this + 184));
  v7 = (v5 + v5) * (double)a3.var0 / v3 - v5;
  v8 = (v5 + v5) * (double)a3.var2 / v3 - v5;
  v9 = *(float *)(this + 196);
  v10 = ((v6 + v6) * (double)a3.var1 / v4 - v6) * v9;
  v11 = ((v6 + v6) * (double)a3.var3 / v4 - v6) * v9;
  v12 = *(float *)(this + 152) + 0.0000305175781;
  v13 = *(unsigned __int8 *)(this + 128);
  *(float *)&v4 = v8 - v7;
  *(float *)&v9 = v11 - v10;
  v14 = v12 + -0.0000305175781;
  v15 = *(float *)&v4;
  *a2 = 2.0 / *(float *)&v4;
  v16 = *(float *)&v9;
  _Q2 = 0uLL;
  *(_OWORD *)(a2 + 1) = 0u;
  *(_OWORD *)(a2 + 3) = 0u;
  a2[5] = 2.0 / v16;
  v18 = a2 + 6;
  if (v13)
  {
    v19 = v14;
    *(_OWORD *)v18 = 0uLL;
    *((_OWORD *)a2 + 4) = 0uLL;
    a2[10] = -2.0 / v19;
    a2[11] = 0.0;
    __asm { FMOV            V2.2D, #1.0 }
    *(double *)&_Q2 = -(v12 + 0.0000305175781) / v19;
    a2[12] = -(v8 + v7) / v15;
    a2[13] = -(v11 + v10) / v16;
  }
  else
  {
    *v18 = 0.0;
    a2[7] = 0.0;
    a2[8] = (v8 + v7) / v15;
    a2[9] = (v11 + v10) / v16;
    a2[10] = -(v12 + 0.0000305175781) / v14;
    a2[11] = -1.0;
    *(double *)&_Q2 = v12 * -2.0 * 0.0000305175781 / v14;
    a2[12] = 0.0;
    a2[13] = 0.0;
  }
  *((_OWORD *)a2 + 7) = _Q2;
  return this;
}

double HGFractured::Effect::GetModelviewMatrix(HGFractured::Effect *this, double *a2)
{
  double result;

  *a2 = 1.0;
  *(_OWORD *)(a2 + 1) = 0u;
  *(_OWORD *)(a2 + 3) = 0u;
  a2[5] = 1.0;
  *((_OWORD *)a2 + 3) = 0u;
  *((_OWORD *)a2 + 4) = 0u;
  a2[10] = 1.0;
  a2[11] = 0.0;
  a2[12] = 0.0;
  a2[13] = 0.0;
  result = *((float *)this + 44) + -1.0 + (float)(*((float *)this + 34) * -0.5);
  a2[14] = result;
  a2[15] = 1.0;
  return result;
}

double HGFractured::Effect::GetTextureMatrix(HGFractured::Effect *this, double *a2)
{
  int v2;
  float v3;
  float v4;
  double result;

  v2 = *((_DWORD *)this + 45);
  v3 = (float)(*((_DWORD *)this + 47) - v2);
  *a2 = v3;
  *(_OWORD *)(a2 + 1) = 0u;
  *(_OWORD *)(a2 + 3) = 0u;
  a2[5] = v3;
  *((_OWORD *)a2 + 3) = 0u;
  *((_OWORD *)a2 + 4) = 0u;
  *((_OWORD *)a2 + 5) = xmmword_1B304EED0;
  v4 = v3 * 0.5;
  a2[12] = (float)(v4 + (float)v2);
  a2[13] = (float)((float)(v4 * *((float *)this + 33)) + (float)*((int *)this + 46));
  result = 0.0;
  *((_OWORD *)a2 + 7) = xmmword_1B304EEE0;
  return result;
}

void HGFractured::Effect::Render(HGFractured::Effect *this, HGGPURenderer *a2, HGRect a3, float a4, float a5, char a6)
{
  float v7;
  float v8;
  _BOOL4 v10;
  float v11;
  char *v12;
  char *v13;
  const GLvoid *v14;
  _BOOL4 v15;
  const GLvoid **v16;

  v7 = a5;
  v8 = a4;
  if (*((_DWORD *)this + 35))
  {
    v10 = fabsf(*((float *)this + 23)) < fabsf(*((float *)this + 22));
    if (*((_BYTE *)this + 156))
      goto LABEL_20;
  }
  else
  {
    v10 = 0;
    if (*((_BYTE *)this + 156))
      goto LABEL_20;
  }
  if (v10)
    a4 = a5;
  if (a4 >= 1.0)
  {
    if (v10)
      v11 = a5;
    else
      v11 = v8;
    if (v11 <= 0.0)
      goto LABEL_12;
    goto LABEL_24;
  }
LABEL_20:
  glBlendFunc(0x302u, 0x303u);
  glEnable(0xBE2u);
  if (v10)
    v11 = v7;
  else
    v11 = v8;
  if (v11 <= 0.0)
  {
LABEL_12:
    if (*((float *)this + 34) == 0.0)
      goto LABEL_14;
    goto LABEL_13;
  }
LABEL_24:
  v12 = (char *)this + 8 * v10;
  v14 = (const GLvoid *)*((_QWORD *)v12 + 12);
  v13 = v12 + 96;
  glVertexAttribPointer(0, 3, 0x1406u, 0, 48, v14);
  glEnableVertexAttribArray(0);
  if ((a6 & 1) != 0)
  {
    glVertexAttribPointer(8u, 2, 0x1406u, 0, 48, (const GLvoid *)(*((_QWORD *)this + 12) + 32));
    glEnableVertexAttribArray(8u);
  }
  if ((a6 & 2) != 0)
  {
    glVertexAttribPointer(9u, 2, 0x1406u, 0, 48, (const GLvoid *)(*((_QWORD *)this + 12) + 40));
    glEnableVertexAttribArray(9u);
  }
  glVertexAttribPointer(0xAu, 4, 0x1406u, 0, 48, (const GLvoid *)(*(_QWORD *)v13 + 16));
  glEnableVertexAttribArray(0xAu);
  if (*((float *)this + 34) != 0.0)
  {
LABEL_13:
    glCullFace(0x405u);
    glEnable(0xB44u);
  }
LABEL_14:
  glDrawArrays(4 * (*((_DWORD *)this + 31) != 1), 0, *((_DWORD *)this + 28));
  if (*((_DWORD *)this + 35))
  {
    if (v10)
      v7 = v8;
    if (v7 < 1.0 || *((_BYTE *)this + 156))
    {
      glBlendFunc(0x302u, 0x303u);
      glEnable(0xBE2u);
    }
    else
    {
      glDisable(0xBE2u);
    }
    v15 = *((_DWORD *)this + 31) != 1;
    v16 = (const GLvoid **)((char *)this + 8 * !v10);
    glVertexAttribPointer(0, 3, 0x1406u, 0, 48, v16[12]);
    glVertexAttribPointer(0xAu, 4, 0x1406u, 0, 48, (char *)v16[12] + 16);
    glDrawArrays(4 * v15, 0, *((_DWORD *)this + 28));
    if (v7 < 1.0 || *((_BYTE *)this + 156))
      goto LABEL_36;
  }
  else if (v11 < 1.0 || *((_BYTE *)this + 156))
  {
LABEL_36:
    glDisable(0xBE2u);
  }
  if (*((float *)this + 34) != 0.0)
    glDisable(0xB44u);
  glDisableVertexAttribArray(0xAu);
  if ((a6 & 2) != 0)
    glDisableVertexAttribArray(9u);
  if ((a6 & 1) != 0)
    glDisableVertexAttribArray(8u);
  glDisableVertexAttribArray(0);
}

uint64_t clip(uint64_t a1, float *a2, uint64_t a3, float a4)
{
  float v4;
  float v5;
  float v6;
  _BOOL4 v7;
  _BOOL4 v8;
  float v9;
  float v10;
  float v11;
  int v13;
  float v14;
  float v15;
  float v16;
  int v18;
  float v19;
  int v21;
  int v22;
  int v23;
  float v24;
  unsigned int v25;
  _BOOL4 v26;
  unsigned int v27;
  float v28;
  float v29;
  unsigned int v30;
  _BOOL4 v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  int v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  float *v42;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  float *v48;
  float *v49;
  int v50;
  float32x2_t v51;
  float *v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float *v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float32x2_t v70;
  float *v71;
  float v72;
  float v73;
  float *v74;
  float v75;
  float v76;
  float *v77;
  float v78;
  float v79;
  float *v80;
  float v81;
  float v82;
  float *v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  _BOOL4 v97;
  float *v98;
  float v99;
  float v100;
  float *v101;
  float v102;
  float v103;
  float *v104;
  float v105;
  float v106;
  float *v107;
  float v108;
  float v109;
  float *v110;
  float v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  _BOOL4 v124;
  BOOL v125;
  _DWORD v127[2];
  unsigned int v128;
  unsigned int v129;
  uint64_t v130;

  v130 = *MEMORY[0x1E0C80C00];
  v4 = a4 * 0.5;
  v6 = *a2;
  v5 = a2[1];
  v7 = fabsf(*a2) <= 0.5;
  v8 = fabsf(v5) <= (float)(a4 * 0.5) && v7;
  v9 = a2[2];
  v10 = a2[3];
  v11 = fabsf(v9);
  if (fabsf(v10) > v4 || v11 > 0.5)
    v13 = 0;
  else
    v13 = 2;
  v14 = a2[4];
  v15 = a2[5];
  v16 = fabsf(v14);
  if (fabsf(v15) > v4 || v16 > 0.5)
    v18 = 0;
  else
    v18 = 4;
  v19 = fabsf(a2[6]);
  if (fabsf(a2[7]) > v4 || v19 > 0.5)
    v21 = 0;
  else
    v21 = 8;
  v22 = v13 | v8;
  v23 = v18 | v21;
  v24 = -(float)(v9 * a4);
  v25 = 2 * (v10 > (float)(v9 * a4));
  v26 = v10 >= v24;
  if (v10 > 0.0)
  {
    v26 = v10 > v24;
    v25 = 2 * (v10 >= (float)(v9 * a4));
  }
  v27 = (v25 | v26) ^ (v25 >> 1);
  v28 = v14 * a4;
  v29 = -(float)(v14 * a4);
  v30 = 2 * (v15 >= v28);
  v31 = v15 > v29;
  if (v15 > 0.0)
  {
    v31 = v15 >= v29;
    v30 = 2 * (v15 > v28);
  }
  v32 = (v30 | v31) ^ (v30 >> 1);
  v127[1] = v27;
  v128 = v32;
  if (v27 == v32)
  {
    v32 = v27;
    if ((float)((float)((float)(v6 - v14) * (float)(v10 - v15)) - (float)((float)(v9 - v14) * (float)(v5 - v15))) >= 0.0)
      goto LABEL_31;
    goto LABEL_30;
  }
  if (v32 < v27)
  {
LABEL_30:
    v32 |= 4u;
    v128 = v32;
  }
LABEL_31:
  v33 = 0;
  v34 = 0;
  v35 = v22 | v23;
  v129 = v32;
  v127[0] = v27;
  do
  {
    v36 = v33 + 1;
    v37 = v127[v33];
    v38 = (v33 + 1) & 3;
    v39 = (v33 + 1) & 3;
    v40 = v127[v39];
    v41 = (1 << v33) & v35;
    if (v41)
    {
      v42 = &a2[2 * v33];
      v43 = (v34 + 1);
      *(_QWORD *)(a3 + 8 * (int)v34) = *(_QWORD *)v42;
      if (((v35 >> v38) & 1) != 0)
        goto LABEL_32;
      if (v37 == v40)
      {
        if ((v37 & 1) != 0)
        {
          v125 = *v42 == *(float *)(a1 + 8 * (v37 & 3));
          v44 = v37;
          v34 = (v34 + 1);
          if (v125)
            goto LABEL_33;
        }
        else
        {
          v44 = v37;
          v34 = (v34 + 1);
          if (a2[2 * v33 + 1] == *(float *)(a1 + 8 * (v37 & 3) + 4))
            goto LABEL_33;
        }
      }
      else
      {
        v44 = v37 + 1;
      }
    }
    else if (v37 == v40)
    {
      v44 = v127[v33];
      v43 = v34;
      if (((v35 >> v38) & 1) == 0)
        goto LABEL_33;
    }
    else
    {
      v44 = v127[v33];
      v43 = v34;
    }
    if (v38)
    {
      v45 = (1 << v38) & v35;
      v46 = ((_BYTE)v33 + 2) & 3;
      v47 = ((_BYTE)v33 - 1) & 3;
      v34 = v43;
      v48 = &a2[2 * v33];
      v49 = &a2[2 * v39];
      do
      {
        if (v40 == v44 && v37 != v40 && v45)
          break;
        v50 = v44 + 1;
        v51 = *(float32x2_t *)(a1 + 8 * ((v44 + 1) & 3));
        v52 = (float *)(a1 + 8 * (v44 & 3));
        v53 = *v52;
        v54 = v52[1];
        v55 = v48[1];
        v56 = v49[1];
        v57 = (float *)(a3 + 8 * (int)v34);
        v58 = *v48 - *v49;
        v59 = v55 - v56;
        v60 = (float)((float)(v54 - v51.f32[1]) * v58) - (float)((float)(v53 - v51.f32[0]) * (float)(v55 - v56));
        v61 = (float)(*v48 * v56) - (float)(v55 * *v49);
        v62 = vmuls_lane_f32(v53, v51, 1) - (float)(v54 * v51.f32[0]);
        v63 = (float)((float)((float)(v53 - v51.f32[0]) * v61) - (float)(v62 * v58)) / v60;
        v64 = (float)((float)((float)(v54 - v51.f32[1]) * v61) - (float)(v62 * v59)) / v60;
        *v57 = v63;
        v57[1] = v64;
        v65 = vabds_f32(v51.f32[0], v53);
        v66 = vabds_f32(v51.f32[1], v54);
        v67 = (float)(v64 - v54) / (float)(v51.f32[1] - v54);
        v68 = (float)(v63 - v53) / (float)(v51.f32[0] - v53);
        if (v65 <= v66)
          v68 = v67;
        if (v68 < 0.0 || v68 > 1.0)
        {
          if (v44 < v40)
          {
            v70 = vmul_f32((float32x2_t)vrev64_s32((int32x2_t)vsub_f32(v51, *(float32x2_t *)&a2[2 * v46])), vsub_f32(*(float32x2_t *)&a2[2 * v47], *(float32x2_t *)&a2[2 * v46]));
            if (vsub_f32(v70, (float32x2_t)vdup_lane_s32((int32x2_t)v70, 1)).f32[0] > 0.0)
            {
              v34 = (v34 + 1);
              *(float32x2_t *)v57 = v51;
            }
          }
        }
        else
        {
          v34 = (v34 + 1);
        }
        ++v44;
      }
      while (v40 + 1 != v50);
    }
    else
    {
      if (v41)
      {
        if (v8)
          goto LABEL_32;
      }
      else
      {
        v71 = (float *)(a1 + 8 * (v44 & 3));
        v72 = *v71;
        v73 = v71[1];
        v74 = (float *)(a1 + 8 * (((_BYTE)v44 + 1) & 3));
        v75 = *v74;
        v76 = v74[1];
        v77 = &a2[2 * v33];
        v78 = *v77;
        v79 = v77[1];
        v80 = &a2[2 * v39];
        v81 = *v80;
        v82 = v80[1];
        v83 = (float *)(a3 + 8 * (int)v43);
        v84 = v78 - v81;
        v85 = v79 - v82;
        v86 = (float)((float)(v73 - v76) * (float)(v78 - v81)) - (float)((float)(v72 - v75) * (float)(v79 - v82));
        v87 = (float)(v78 * v82) - (float)(v79 * v81);
        v88 = (float)(v72 * v76) - (float)(v73 * v75);
        v89 = (float)((float)((float)(v72 - v75) * v87) - (float)(v88 * v84)) / v86;
        v90 = (float)((float)((float)(v73 - v76) * v87) - (float)(v88 * v85)) / v86;
        *v83 = v89;
        v83[1] = v90;
        v91 = v75 - v72;
        v92 = vabds_f32(v75, v72);
        v93 = v76 - v73;
        v94 = vabds_f32(v76, v73);
        v95 = (float)(v90 - v73) / v93;
        v96 = (float)(v89 - v72) / v91;
        if (v92 <= v94)
          v96 = v95;
        v97 = v96 >= 0.0;
        if (v96 > 1.0)
          v97 = 0;
        v43 = (v43 + v97);
        if (v8)
        {
LABEL_32:
          v34 = v43;
          goto LABEL_33;
        }
      }
      v98 = (float *)(a1 + 8 * (v40 & 3));
      v99 = *v98;
      v100 = v98[1];
      v101 = (float *)(a1 + 8 * (((_BYTE)v40 + 1) & 3));
      v102 = *v101;
      v103 = v101[1];
      v104 = &a2[2 * v33];
      v105 = *v104;
      v106 = v104[1];
      v107 = &a2[2 * v39];
      v108 = *v107;
      v109 = v107[1];
      v110 = (float *)(a3 + 8 * (int)v43);
      v111 = v105 - v108;
      v112 = v106 - v109;
      v113 = (float)((float)(v100 - v103) * (float)(v105 - v108)) - (float)((float)(v99 - v102) * (float)(v106 - v109));
      v114 = (float)(v105 * v109) - (float)(v106 * v108);
      v115 = (float)(v99 * v103) - (float)(v100 * v102);
      v116 = (float)((float)((float)(v99 - v102) * v114) - (float)(v115 * v111)) / v113;
      v117 = (float)((float)((float)(v100 - v103) * v114) - (float)(v115 * v112)) / v113;
      *v110 = v116;
      v110[1] = v117;
      v118 = v102 - v99;
      v119 = vabds_f32(v102, v99);
      v120 = v103 - v100;
      v121 = vabds_f32(v103, v100);
      v122 = (float)(v117 - v100) / v120;
      v123 = (float)(v116 - v99) / v118;
      if (v119 <= v121)
        v123 = v122;
      v124 = v123 >= 0.0;
      if (v123 > 1.0)
        v124 = 0;
      v34 = (v43 + v124);
    }
LABEL_33:
    v33 = v36;
  }
  while (v36 != 4);
  return v34;
}

void HGFractured::Effect::build(void **this, int a2, int a3, double a4, double a5, double a6, double a7, int32x2_t a8)
{
  void *v11;
  char *v12;
  int v13;
  size_t v14;
  void *v15;
  void *v16;
  malloc_type_id_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  size_t v22;
  void *v23;
  void *v24;
  malloc_type_id_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  size_t v29;
  size_t v30;
  void *v31;
  void *v32;
  malloc_type_id_t v33;
  int v34;
  void *v35;
  size_t v36;
  void *v37;
  void *v38;
  malloc_type_id_t v39;
  float *v40;
  float *i;
  float v42;
  _QWORD *v43;
  char *v44;
  float *k;
  float v46;
  char *v47;
  float v48;
  _QWORD *v49;
  char *v50;
  float *j;
  float v52;
  char *v53;
  float v54;
  char *v55;
  float v56;
  float v57;
  float *v58;
  unsigned int v59;
  unint64_t v60;
  float v61;
  unsigned int v62;
  float v63;
  float v64;
  unsigned int v65;
  float v66;
  unsigned int v67;
  int v68;
  float v69;
  float v70;
  int v71;
  char *v72;
  float *v73;
  uint64_t v74;
  float v75;
  int v76;
  float v77;
  int v78;
  char *v79;
  int v80;
  float v81;
  float v82;
  float *v83;
  float *v84;
  unsigned int v85;
  unint64_t v86;
  float v87;
  unsigned int v88;
  float v89;
  float v90;
  unsigned int v91;
  float v92;
  unsigned int v93;
  int v94;
  float v95;
  float v96;
  int v97;
  float v98;
  int v99;
  char *v100;
  float *v101;
  uint64_t v102;
  float v103;
  int v104;

  HGFractured::Effect::init((HGFractured::Effect *)this, a4, a5, a6, a7, a8);
  v12 = (char *)this[7];
  v11 = this[8];
  v13 = *((_DWORD *)this + 31);
  if (v13 != 4)
  {
    if (v13 != 3)
    {
      if (v13 == 1)
      {
        v14 = (size_t)this[3];
        if (v14 >= 48 * (uint64_t)v11)
        {
          if (!*((_DWORD *)this + 35) || this[13])
            goto LABEL_41;
          v16 = 0;
          v17 = 1253900132;
        }
        else
        {
          v15 = this[12];
          this[3] = (void *)(48 * (_QWORD)v11);
          this[12] = malloc_type_realloc(v15, 48 * (_QWORD)v11, 0x9C946008uLL);
          v16 = this[13];
          if (!*((_DWORD *)this + 35))
          {
            if (v16)
            {
              free(v16);
              this[13] = 0;
            }
            goto LABEL_41;
          }
          v14 = (size_t)this[3];
          v17 = 897561819;
        }
        this[13] = malloc_type_realloc(v16, v14, v17);
LABEL_41:
        bzero(this[12], 48 * (_QWORD)v11);
        if (*((_DWORD *)this + 35))
          bzero(this[13], 48 * (_QWORD)v11);
        this[14] = v11;
        v40 = (float *)((char *)this[12] + 44);
        for (i = (float *)(v12 + 88); ; i += 23)
        {
          *(_QWORD *)(v40 - 3) = *(_QWORD *)(i - 1);
          if (a2 < 1)
          {
            if (a2 < 0)
            {
              *(v40 - 1) = (float)(*(i - 22) + *(i - 22)) - *(i - 1);
              if (a3 < 1)
              {
LABEL_53:
                if (a3 < 0)
                  v42 = (float)(*(i - 21) + *(i - 21)) - *i;
                else
                  v42 = *i;
                goto LABEL_45;
              }
            }
            else
            {
              *(v40 - 1) = *(i - 1);
              if (a3 < 1)
                goto LABEL_53;
            }
          }
          else
          {
            *(v40 - 1) = -*(i - 1);
            if (a3 < 1)
              goto LABEL_53;
          }
          v42 = -*i;
LABEL_45:
          *v40 = v42;
          v40 += 12;
          v11 = (char *)v11 - 1;
          if (!v11)
            return;
        }
      }
      if (*((float *)this + 34) == 0.0)
        v34 = 3;
      else
        v34 = 12;
      v35 = (void *)((_QWORD)v11 * (v34 * v13));
      v36 = (size_t)this[3];
      if (v36 >= 48 * (uint64_t)v35)
      {
        if (!*((_DWORD *)this + 35) || this[13])
          goto LABEL_770;
        v38 = 0;
        v39 = 2311274053;
      }
      else
      {
        v37 = this[12];
        this[3] = (void *)(48 * (_QWORD)v35);
        this[12] = malloc_type_realloc(v37, 48 * (_QWORD)v35, 0xC3F04B7DuLL);
        v38 = this[13];
        if (!*((_DWORD *)this + 35))
        {
          if (v38)
          {
            free(v38);
            this[13] = 0;
          }
          goto LABEL_770;
        }
        v36 = (size_t)this[3];
        v39 = 1055899342;
      }
      this[13] = malloc_type_realloc(v38, v36, v39);
LABEL_770:
      bzero(this[12], 48 * (_QWORD)v35);
      if (*((_DWORD *)this + 35))
        bzero(this[13], 48 * (_QWORD)v35);
      this[14] = v35;
      v55 = (char *)this[12];
      while (1)
      {
        *((_QWORD *)v55 + 4) = *(_QWORD *)v12;
        v56 = *(float *)v12;
        if (a2 < 1)
        {
          if (a2 < 0)
          {
            *((float *)v55 + 10) = (float)(v56 + v56) - v56;
            v57 = *((float *)v12 + 1);
            if (a3 >= 1)
            {
LABEL_779:
              *((float *)v55 + 11) = -v57;
              *((_QWORD *)v55 + 10) = *(_QWORD *)(v12 + 84);
              if (a2 >= 1)
                goto LABEL_784;
              goto LABEL_787;
            }
          }
          else
          {
            *((float *)v55 + 10) = v56;
            v57 = *((float *)v12 + 1);
            if (a3 >= 1)
              goto LABEL_779;
          }
        }
        else
        {
          *((float *)v55 + 10) = -v56;
          v57 = *((float *)v12 + 1);
          if (a3 >= 1)
            goto LABEL_779;
        }
        if (a3 < 0)
        {
          *((float *)v55 + 11) = (float)(v57 + v57) - v57;
          *((_QWORD *)v55 + 10) = *(_QWORD *)(v12 + 84);
          if (a2 >= 1)
          {
LABEL_784:
            *((float *)v55 + 22) = -*((float *)v12 + 21);
            if (a3 >= 1)
              goto LABEL_789;
            goto LABEL_792;
          }
        }
        else
        {
          *((float *)v55 + 11) = v57;
          *((_QWORD *)v55 + 10) = *(_QWORD *)(v12 + 84);
          if (a2 >= 1)
            goto LABEL_784;
        }
LABEL_787:
        if (a2 < 0)
        {
          *((float *)v55 + 22) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
          if (a3 >= 1)
          {
LABEL_789:
            *((float *)v55 + 23) = -*((float *)v12 + 22);
            *((_QWORD *)v55 + 16) = *(_QWORD *)(v12 + 92);
            if (a2 >= 1)
              goto LABEL_794;
            goto LABEL_797;
          }
        }
        else
        {
          *((_DWORD *)v55 + 22) = *((_DWORD *)v12 + 21);
          if (a3 >= 1)
            goto LABEL_789;
        }
LABEL_792:
        if (a3 < 0)
        {
          *((float *)v55 + 23) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
          *((_QWORD *)v55 + 16) = *(_QWORD *)(v12 + 92);
          if (a2 >= 1)
          {
LABEL_794:
            *((float *)v55 + 34) = -*((float *)v12 + 23);
            if (a3 >= 1)
              goto LABEL_799;
            goto LABEL_802;
          }
        }
        else
        {
          *((_DWORD *)v55 + 23) = *((_DWORD *)v12 + 22);
          *((_QWORD *)v55 + 16) = *(_QWORD *)(v12 + 92);
          if (a2 >= 1)
            goto LABEL_794;
        }
LABEL_797:
        if (a2 < 0)
        {
          *((float *)v55 + 34) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
          if (a3 >= 1)
          {
LABEL_799:
            *((float *)v55 + 35) = -*((float *)v12 + 24);
            if ((*((_DWORD *)this + 31) - 3) <= 0xFFFFFFFD)
              goto LABEL_804;
            goto LABEL_837;
          }
        }
        else
        {
          *((_DWORD *)v55 + 34) = *((_DWORD *)v12 + 23);
          if (a3 >= 1)
            goto LABEL_799;
        }
LABEL_802:
        if (a3 < 0)
        {
          *((float *)v55 + 35) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
          if ((*((_DWORD *)this + 31) - 3) > 0xFFFFFFFD)
            goto LABEL_837;
LABEL_804:
          v58 = (float *)(v12 + 104);
          v59 = 5;
          v60 = 1;
          while (2)
          {
            v62 = v59 - 2;
            *(_QWORD *)&v55[48 * v59 - 64] = *(_QWORD *)v12;
            v63 = *(float *)v12;
            if (a2 < 1)
            {
              if (a2 < 0)
              {
                *(float *)&v55[48 * v62 + 40] = (float)(v63 + v63) - v63;
                v64 = *((float *)v12 + 1);
                if (a3 >= 1)
                  goto LABEL_812;
              }
              else
              {
                *(float *)&v55[48 * v62 + 40] = v63;
                v64 = *((float *)v12 + 1);
                if (a3 >= 1)
                  goto LABEL_812;
              }
LABEL_814:
              if (a3 < 0)
                v64 = (float)(v64 + v64) - v64;
            }
            else
            {
              *(float *)&v55[48 * v62 + 40] = -v63;
              v64 = *((float *)v12 + 1);
              if (a3 < 1)
                goto LABEL_814;
LABEL_812:
              v64 = -v64;
            }
            *(float *)&v55[48 * v62 + 44] = v64;
            v65 = v59 - 1;
            *(_QWORD *)&v55[48 * v59 - 16] = *(_QWORD *)(v58 - 3);
            if (a2 < 1)
            {
              if (a2 < 0)
              {
                *(float *)&v55[48 * v65 + 40] = (float)(*(float *)v12 + *(float *)v12) - *(v58 - 3);
                if (a3 >= 1)
                  goto LABEL_821;
              }
              else
              {
                *(float *)&v55[48 * v65 + 40] = *(v58 - 3);
                if (a3 >= 1)
                  goto LABEL_821;
              }
LABEL_823:
              if (a3 < 0)
                v66 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *(v58 - 2);
              else
                v66 = *(v58 - 2);
            }
            else
            {
              *(float *)&v55[48 * v65 + 40] = -*(v58 - 3);
              if (a3 < 1)
                goto LABEL_823;
LABEL_821:
              v66 = -*(v58 - 2);
            }
            *(float *)&v55[48 * v65 + 44] = v66;
            *(_QWORD *)&v55[48 * v59 + 32] = *(_QWORD *)(v58 - 1);
            if (a2 < 1)
            {
              if ((a2 & 0x80000000) == 0)
              {
                v67 = v59;
                *(float *)&v55[48 * v59 + 40] = *(v58 - 1);
                if (a3 < 1)
                  goto LABEL_833;
                goto LABEL_805;
              }
              v67 = v59;
              *(float *)&v55[48 * v59 + 40] = (float)(*(float *)v12 + *(float *)v12) - *(v58 - 1);
              if (a3 >= 1)
                goto LABEL_805;
LABEL_833:
              if (a3 < 0)
                v61 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *v58;
              else
                v61 = *v58;
            }
            else
            {
              v67 = v59;
              *(float *)&v55[48 * v59 + 40] = -*(v58 - 1);
              if (a3 < 1)
                goto LABEL_833;
LABEL_805:
              v61 = -*v58;
            }
            ++v60;
            *(float *)&v55[48 * v67 + 44] = v61;
            v58 += 2;
            v59 += 3;
            if (v60 >= (*((_DWORD *)this + 31) - 1))
              goto LABEL_838;
            continue;
          }
        }
        *((_DWORD *)v55 + 35) = *((_DWORD *)v12 + 24);
        if ((*((_DWORD *)this + 31) - 3) <= 0xFFFFFFFD)
          goto LABEL_804;
LABEL_837:
        LODWORD(v60) = 1;
LABEL_838:
        v68 = 3 * v60;
        *(_QWORD *)&v55[48 * (3 * v60) + 32] = *(_QWORD *)v12;
        v69 = *(float *)v12;
        if (a2 < 1)
        {
          if (a2 < 0)
          {
            *(float *)&v55[48 * v68 + 40] = (float)(v69 + v69) - v69;
            v70 = *((float *)v12 + 1);
            if (a3 >= 1)
            {
LABEL_843:
              v70 = -v70;
              goto LABEL_847;
            }
          }
          else
          {
            *(float *)&v55[48 * v68 + 40] = v69;
            v70 = *((float *)v12 + 1);
            if (a3 >= 1)
              goto LABEL_843;
          }
        }
        else
        {
          *(float *)&v55[48 * v68 + 40] = -v69;
          v70 = *((float *)v12 + 1);
          if (a3 >= 1)
            goto LABEL_843;
        }
        if (a3 < 0)
          v70 = (float)(v70 + v70) - v70;
LABEL_847:
        *(float *)&v55[48 * v68 + 44] = v70;
        v71 = v68 + 1;
        v72 = &v12[8 * v60];
        v74 = *(_QWORD *)(v72 + 84);
        v73 = (float *)(v72 + 84);
        *(_QWORD *)&v55[48 * (v68 + 1) + 32] = v74;
        if (a2 < 1)
        {
          if (a2 < 0)
          {
            v60 = v60;
            *(float *)&v55[48 * v71 + 40] = (float)(*(float *)v12 + *(float *)v12) - *v73;
            if (a3 >= 1)
            {
LABEL_852:
              v75 = -*(float *)&v12[8 * v60 + 88];
              goto LABEL_857;
            }
          }
          else
          {
            v60 = v60;
            *(float *)&v55[48 * v71 + 40] = *v73;
            if (a3 >= 1)
              goto LABEL_852;
          }
        }
        else
        {
          v60 = v60;
          *(float *)&v55[48 * v71 + 40] = -*v73;
          if (a3 >= 1)
            goto LABEL_852;
        }
        if (a3 < 0)
          v75 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *(float *)&v12[8 * v60 + 88];
        else
          v75 = *(float *)&v12[8 * v60 + 88];
LABEL_857:
        *(float *)&v55[48 * v71 + 44] = v75;
        v76 = v68 + 2;
        *(_QWORD *)&v55[48 * (v68 + 2) + 32] = *(_QWORD *)(v12 + 84);
        if (a2 < 1)
        {
          if (a2 < 0)
          {
            *(float *)&v55[48 * v76 + 40] = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
            if (a3 < 1)
            {
LABEL_864:
              if (a3 < 0)
                v77 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
              else
                v77 = *((float *)v12 + 22);
              goto LABEL_867;
            }
          }
          else
          {
            *(_DWORD *)&v55[48 * v76 + 40] = *((_DWORD *)v12 + 21);
            if (a3 < 1)
              goto LABEL_864;
          }
        }
        else
        {
          *(float *)&v55[48 * v76 + 40] = -*((float *)v12 + 21);
          if (a3 < 1)
            goto LABEL_864;
        }
        v77 = -*((float *)v12 + 22);
LABEL_867:
        *(float *)&v55[48 * v76 + 44] = v77;
        v78 = *((_DWORD *)this + 31);
        v79 = &v55[144 * v78];
        if (*((float *)this + 34) == 0.0)
        {
          v55 += 48 * (3 * v78);
          v12 += 8 * v78 + 84;
          v11 = (char *)v11 - 1;
          if (!v11)
            return;
        }
        else
        {
          v80 = v68 + 3;
          *(_QWORD *)&v55[48 * (v68 + 3) + 32] = *(_QWORD *)v12;
          v81 = *(float *)v12;
          if (a2 < 1)
          {
            if (a2 < 0)
            {
              *(float *)&v55[48 * v80 + 40] = (float)(v81 + v81) - v81;
              v82 = *((float *)v12 + 1);
              if (a3 >= 1)
              {
LABEL_873:
                v82 = -v82;
                goto LABEL_877;
              }
            }
            else
            {
              *(float *)&v55[48 * v80 + 40] = v81;
              v82 = *((float *)v12 + 1);
              if (a3 >= 1)
                goto LABEL_873;
            }
          }
          else
          {
            *(float *)&v55[48 * v80 + 40] = -v81;
            v82 = *((float *)v12 + 1);
            if (a3 >= 1)
              goto LABEL_873;
          }
          if (a3 < 0)
            v82 = (float)(v82 + v82) - v82;
LABEL_877:
          v83 = (float *)&v55[48 * v80];
          v83[11] = v82;
          *((_QWORD *)v83 + 10) = *(_QWORD *)(v12 + 92);
          if (a2 < 1)
          {
            if (a2 < 0)
            {
              v83[22] = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
              if (a3 >= 1)
              {
LABEL_882:
                v83[23] = -*((float *)v12 + 24);
                *((_QWORD *)v83 + 16) = *(_QWORD *)(v12 + 84);
                if (a2 >= 1)
                  goto LABEL_887;
                goto LABEL_890;
              }
            }
            else
            {
              v83[22] = *((float *)v12 + 23);
              if (a3 >= 1)
                goto LABEL_882;
            }
          }
          else
          {
            v83[22] = -*((float *)v12 + 23);
            if (a3 >= 1)
              goto LABEL_882;
          }
          if (a3 < 0)
          {
            v83[23] = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
            *((_QWORD *)v83 + 16) = *(_QWORD *)(v12 + 84);
            if (a2 >= 1)
            {
LABEL_887:
              v83[34] = -*((float *)v12 + 21);
              if (a3 >= 1)
                goto LABEL_892;
              goto LABEL_895;
            }
          }
          else
          {
            v83[23] = *((float *)v12 + 24);
            *((_QWORD *)v83 + 16) = *(_QWORD *)(v12 + 84);
            if (a2 >= 1)
              goto LABEL_887;
          }
LABEL_890:
          if (a2 < 0)
          {
            v83[34] = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
            if (a3 >= 1)
            {
LABEL_892:
              v83[35] = -*((float *)v12 + 22);
              if ((*((_DWORD *)this + 31) - 3) <= 0xFFFFFFFD)
                goto LABEL_897;
              goto LABEL_930;
            }
          }
          else
          {
            v83[34] = *((float *)v12 + 21);
            if (a3 >= 1)
              goto LABEL_892;
          }
LABEL_895:
          if (a3 < 0)
          {
            v83[35] = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
            if ((*((_DWORD *)this + 31) - 3) > 0xFFFFFFFD)
              goto LABEL_930;
LABEL_897:
            v84 = (float *)(v12 + 104);
            v85 = 5;
            v86 = 1;
            while (2)
            {
              v88 = v85 - 2;
              *(_QWORD *)&v83[12 * v85 - 16] = *(_QWORD *)v12;
              v89 = *(float *)v12;
              if (a2 < 1)
              {
                if (a2 < 0)
                {
                  v83[12 * v88 + 10] = (float)(v89 + v89) - v89;
                  v90 = *((float *)v12 + 1);
                  if (a3 >= 1)
                    goto LABEL_905;
                }
                else
                {
                  v83[12 * v88 + 10] = v89;
                  v90 = *((float *)v12 + 1);
                  if (a3 >= 1)
                    goto LABEL_905;
                }
LABEL_907:
                if (a3 < 0)
                  v90 = (float)(v90 + v90) - v90;
              }
              else
              {
                v83[12 * v88 + 10] = -v89;
                v90 = *((float *)v12 + 1);
                if (a3 < 1)
                  goto LABEL_907;
LABEL_905:
                v90 = -v90;
              }
              v83[12 * v88 + 11] = v90;
              v91 = v85 - 1;
              *(_QWORD *)&v83[12 * v85 - 4] = *(_QWORD *)(v84 - 1);
              if (a2 < 1)
              {
                if (a2 < 0)
                {
                  v83[12 * v91 + 10] = (float)(*(float *)v12 + *(float *)v12) - *(v84 - 1);
                  if (a3 >= 1)
                    goto LABEL_914;
                }
                else
                {
                  v83[12 * v91 + 10] = *(v84 - 1);
                  if (a3 >= 1)
                    goto LABEL_914;
                }
LABEL_916:
                if (a3 < 0)
                  v92 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *v84;
                else
                  v92 = *v84;
              }
              else
              {
                v83[12 * v91 + 10] = -*(v84 - 1);
                if (a3 < 1)
                  goto LABEL_916;
LABEL_914:
                v92 = -*v84;
              }
              v83[12 * v91 + 11] = v92;
              *(_QWORD *)&v83[12 * v85 + 8] = *(_QWORD *)(v84 - 3);
              if (a2 < 1)
              {
                if ((a2 & 0x80000000) == 0)
                {
                  v93 = v85;
                  v83[12 * v85 + 10] = *(v84 - 3);
                  if (a3 < 1)
                    goto LABEL_926;
                  goto LABEL_898;
                }
                v93 = v85;
                v83[12 * v85 + 10] = (float)(*(float *)v12 + *(float *)v12) - *(v84 - 3);
                if (a3 >= 1)
                  goto LABEL_898;
LABEL_926:
                if (a3 < 0)
                  v87 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *(v84 - 2);
                else
                  v87 = *(v84 - 2);
              }
              else
              {
                v93 = v85;
                v83[12 * v85 + 10] = -*(v84 - 3);
                if (a3 < 1)
                  goto LABEL_926;
LABEL_898:
                v87 = -*(v84 - 2);
              }
              ++v86;
              v83[12 * v93 + 11] = v87;
              v84 += 2;
              v85 += 3;
              if (v86 >= (*((_DWORD *)this + 31) - 1))
                goto LABEL_931;
              continue;
            }
          }
          v83[35] = *((float *)v12 + 22);
          if ((*((_DWORD *)this + 31) - 3) <= 0xFFFFFFFD)
            goto LABEL_897;
LABEL_930:
          LODWORD(v86) = 1;
LABEL_931:
          v94 = 3 * v86;
          *(_QWORD *)&v83[12 * (3 * v86) + 8] = *(_QWORD *)v12;
          v95 = *(float *)v12;
          if (a2 < 1)
          {
            if (a2 < 0)
            {
              v83[12 * v94 + 10] = (float)(v95 + v95) - v95;
              v96 = *((float *)v12 + 1);
              if (a3 >= 1)
              {
LABEL_936:
                v96 = -v96;
                goto LABEL_940;
              }
            }
            else
            {
              v83[12 * v94 + 10] = v95;
              v96 = *((float *)v12 + 1);
              if (a3 >= 1)
                goto LABEL_936;
            }
          }
          else
          {
            v83[12 * v94 + 10] = -v95;
            v96 = *((float *)v12 + 1);
            if (a3 >= 1)
              goto LABEL_936;
          }
          if (a3 < 0)
            v96 = (float)(v96 + v96) - v96;
LABEL_940:
          v83[12 * v94 + 11] = v96;
          v97 = v94 + 1;
          *(_QWORD *)&v83[12 * (v94 + 1) + 8] = *(_QWORD *)(v12 + 84);
          if (a2 < 1)
          {
            if (a2 < 0)
            {
              v83[12 * v97 + 10] = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
              if (a3 >= 1)
              {
LABEL_945:
                v98 = -*((float *)v12 + 22);
                goto LABEL_950;
              }
            }
            else
            {
              v83[12 * v97 + 10] = *((float *)v12 + 21);
              if (a3 >= 1)
                goto LABEL_945;
            }
          }
          else
          {
            v83[12 * v97 + 10] = -*((float *)v12 + 21);
            if (a3 >= 1)
              goto LABEL_945;
          }
          if (a3 < 0)
            v98 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
          else
            v98 = *((float *)v12 + 22);
LABEL_950:
          v83[12 * v97 + 11] = v98;
          v99 = v94 + 2;
          v100 = &v12[8 * v86];
          v102 = *(_QWORD *)(v100 + 84);
          v101 = (float *)(v100 + 84);
          *(_QWORD *)&v83[12 * v99 + 8] = v102;
          if (a2 < 1)
          {
            if (a2 < 0)
            {
              v86 = v86;
              v83[12 * v99 + 10] = (float)(*(float *)v12 + *(float *)v12) - *v101;
              if (a3 < 1)
              {
LABEL_957:
                if (a3 < 0)
                  v103 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *(float *)&v12[8 * v86 + 88];
                else
                  v103 = *(float *)&v12[8 * v86 + 88];
                goto LABEL_960;
              }
            }
            else
            {
              v86 = v86;
              v83[12 * v99 + 10] = *v101;
              if (a3 < 1)
                goto LABEL_957;
            }
          }
          else
          {
            v86 = v86;
            v83[12 * v99 + 10] = -*v101;
            if (a3 < 1)
              goto LABEL_957;
          }
          v103 = -*(float *)&v12[8 * v86 + 88];
LABEL_960:
          v83[12 * v99 + 11] = v103;
          v104 = *((_DWORD *)this + 31);
          v55 = &v79[144 * v104];
          v12 += 8 * v104 + 84;
          v11 = (char *)v11 - 1;
          if (!v11)
            return;
        }
      }
    }
    v26 = 24;
    if (*((float *)this + 34) == 0.0)
      v26 = 3;
    v27 = v26 * (_QWORD)v11;
    v28 = 3 * v26 * (_QWORD)v11;
    v29 = 16 * v28;
    v30 = (size_t)this[3];
    if (v30 >= 16 * v28)
    {
      if (!*((_DWORD *)this + 35) || this[13])
        goto LABEL_489;
      v32 = 0;
      v33 = 2644485375;
    }
    else
    {
      v31 = this[12];
      this[3] = (void *)v29;
      this[12] = malloc_type_realloc(v31, 16 * v28, 0x227C306EuLL);
      v32 = this[13];
      if (!*((_DWORD *)this + 35))
      {
        if (v32)
        {
          free(v32);
          this[13] = 0;
        }
        goto LABEL_489;
      }
      v30 = (size_t)this[3];
      v33 = 3462485609;
    }
    this[13] = malloc_type_realloc(v32, v30, v33);
LABEL_489:
    bzero(this[12], v29);
    if (*((_DWORD *)this + 35))
      bzero(this[13], v29);
    this[14] = (void *)v27;
    v49 = this[12];
    if (*((float *)this + 34) == 0.0)
    {
      v50 = (char *)(v49 + 10);
      for (j = (float *)(v12 + 104); ; j += 27)
      {
        *((_QWORD *)v50 - 6) = *(_QWORD *)(j - 5);
        if (a2 < 1)
        {
          if (a2 < 0)
          {
            *((float *)v50 - 10) = (float)(*(j - 26) + *(j - 26)) - *(j - 5);
            if (a3 >= 1)
            {
LABEL_500:
              *((float *)v50 - 9) = -*(j - 4);
              *(_QWORD *)v50 = *(_QWORD *)(j - 3);
              if (a2 >= 1)
                goto LABEL_505;
              goto LABEL_508;
            }
          }
          else
          {
            *((float *)v50 - 10) = *(j - 5);
            if (a3 >= 1)
              goto LABEL_500;
          }
        }
        else
        {
          *((float *)v50 - 10) = -*(j - 5);
          if (a3 >= 1)
            goto LABEL_500;
        }
        if (a3 < 0)
        {
          *((float *)v50 - 9) = (float)(*(j - 25) + *(j - 25)) - *(j - 4);
          *(_QWORD *)v50 = *(_QWORD *)(j - 3);
          if (a2 >= 1)
          {
LABEL_505:
            *((float *)v50 + 2) = -*(j - 3);
            if (a3 >= 1)
              goto LABEL_510;
            goto LABEL_513;
          }
        }
        else
        {
          *((float *)v50 - 9) = *(j - 4);
          *(_QWORD *)v50 = *(_QWORD *)(j - 3);
          if (a2 >= 1)
            goto LABEL_505;
        }
LABEL_508:
        if (a2 < 0)
        {
          *((float *)v50 + 2) = (float)(*(j - 26) + *(j - 26)) - *(j - 3);
          if (a3 >= 1)
          {
LABEL_510:
            *((float *)v50 + 3) = -*(j - 2);
            *((_QWORD *)v50 + 6) = *(_QWORD *)(j - 1);
            if (a2 >= 1)
              goto LABEL_515;
            goto LABEL_518;
          }
        }
        else
        {
          *((float *)v50 + 2) = *(j - 3);
          if (a3 >= 1)
            goto LABEL_510;
        }
LABEL_513:
        if (a3 < 0)
        {
          *((float *)v50 + 3) = (float)(*(j - 25) + *(j - 25)) - *(j - 2);
          *((_QWORD *)v50 + 6) = *(_QWORD *)(j - 1);
          if (a2 >= 1)
          {
LABEL_515:
            *((float *)v50 + 14) = -*(j - 1);
            if (a3 < 1)
              goto LABEL_522;
            goto LABEL_493;
          }
        }
        else
        {
          *((float *)v50 + 3) = *(j - 2);
          *((_QWORD *)v50 + 6) = *(_QWORD *)(j - 1);
          if (a2 >= 1)
            goto LABEL_515;
        }
LABEL_518:
        if (a2 < 0)
        {
          *((float *)v50 + 14) = (float)(*(j - 26) + *(j - 26)) - *(j - 1);
          if (a3 < 1)
          {
LABEL_522:
            if (a3 < 0)
              v52 = (float)(*(j - 25) + *(j - 25)) - *j;
            else
              v52 = *j;
            goto LABEL_494;
          }
        }
        else
        {
          *((float *)v50 + 14) = *(j - 1);
          if (a3 < 1)
            goto LABEL_522;
        }
LABEL_493:
        v52 = -*j;
LABEL_494:
        *((float *)v50 + 15) = v52;
        v50 += 144;
        v11 = (char *)v11 - 1;
        if (!v11)
          return;
      }
    }
    v53 = (char *)&v49[36 * (_QWORD)v11];
    while (1)
    {
      v49[4] = *(_QWORD *)(v12 + 84);
      if (a2 < 1)
      {
        if (a2 < 0)
        {
          *((float *)v49 + 10) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
          if (a3 >= 1)
          {
LABEL_533:
            *((float *)v49 + 11) = -*((float *)v12 + 22);
            v49[10] = *(_QWORD *)(v12 + 92);
            if (a2 >= 1)
              goto LABEL_538;
            goto LABEL_541;
          }
        }
        else
        {
          *((_DWORD *)v49 + 10) = *((_DWORD *)v12 + 21);
          if (a3 >= 1)
            goto LABEL_533;
        }
      }
      else
      {
        *((float *)v49 + 10) = -*((float *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_533;
      }
      if (a3 < 0)
      {
        *((float *)v49 + 11) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
        v49[10] = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_538:
          *((float *)v49 + 22) = -*((float *)v12 + 23);
          if (a3 >= 1)
            goto LABEL_543;
          goto LABEL_546;
        }
      }
      else
      {
        *((_DWORD *)v49 + 11) = *((_DWORD *)v12 + 22);
        v49[10] = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
          goto LABEL_538;
      }
LABEL_541:
      if (a2 < 0)
      {
        *((float *)v49 + 22) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_543:
          *((float *)v49 + 23) = -*((float *)v12 + 24);
          v49[16] = *(_QWORD *)(v12 + 100);
          if (a2 >= 1)
            goto LABEL_548;
          goto LABEL_551;
        }
      }
      else
      {
        *((_DWORD *)v49 + 22) = *((_DWORD *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_543;
      }
LABEL_546:
      if (a3 < 0)
      {
        *((float *)v49 + 23) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        v49[16] = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_548:
          *((float *)v49 + 34) = -*((float *)v12 + 25);
          if (a3 >= 1)
            goto LABEL_553;
          goto LABEL_556;
        }
      }
      else
      {
        *((_DWORD *)v49 + 23) = *((_DWORD *)v12 + 24);
        v49[16] = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_548;
      }
LABEL_551:
      if (a2 < 0)
      {
        *((float *)v49 + 34) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_553:
          *((float *)v49 + 35) = -*((float *)v12 + 26);
          v49[22] = *(_QWORD *)(v12 + 84);
          if (a2 >= 1)
            goto LABEL_558;
          goto LABEL_561;
        }
      }
      else
      {
        *((_DWORD *)v49 + 34) = *((_DWORD *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_553;
      }
LABEL_556:
      if (a3 < 0)
      {
        *((float *)v49 + 35) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        v49[22] = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
        {
LABEL_558:
          *((float *)v49 + 46) = -*((float *)v12 + 21);
          if (a3 >= 1)
            goto LABEL_563;
          goto LABEL_566;
        }
      }
      else
      {
        *((_DWORD *)v49 + 35) = *((_DWORD *)v12 + 26);
        v49[22] = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_558;
      }
LABEL_561:
      if (a2 < 0)
      {
        *((float *)v49 + 46) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 >= 1)
        {
LABEL_563:
          *((float *)v49 + 47) = -*((float *)v12 + 22);
          v49[28] = *(_QWORD *)(v12 + 100);
          if (a2 >= 1)
            goto LABEL_568;
          goto LABEL_571;
        }
      }
      else
      {
        *((_DWORD *)v49 + 46) = *((_DWORD *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_563;
      }
LABEL_566:
      if (a3 < 0)
      {
        *((float *)v49 + 47) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
        v49[28] = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_568:
          *((float *)v49 + 58) = -*((float *)v12 + 25);
          if (a3 >= 1)
            goto LABEL_573;
          goto LABEL_576;
        }
      }
      else
      {
        *((_DWORD *)v49 + 47) = *((_DWORD *)v12 + 22);
        v49[28] = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_568;
      }
LABEL_571:
      if (a2 < 0)
      {
        *((float *)v49 + 58) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_573:
          *((float *)v49 + 59) = -*((float *)v12 + 26);
          v49[34] = *(_QWORD *)(v12 + 92);
          if (a2 >= 1)
            goto LABEL_578;
          goto LABEL_581;
        }
      }
      else
      {
        *((_DWORD *)v49 + 58) = *((_DWORD *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_573;
      }
LABEL_576:
      if (a3 < 0)
      {
        *((float *)v49 + 59) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        v49[34] = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_578:
          *((float *)v49 + 70) = -*((float *)v12 + 23);
          if (a3 >= 1)
            goto LABEL_583;
          goto LABEL_586;
        }
      }
      else
      {
        *((_DWORD *)v49 + 59) = *((_DWORD *)v12 + 26);
        v49[34] = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
          goto LABEL_578;
      }
LABEL_581:
      if (a2 < 0)
      {
        *((float *)v49 + 70) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_583:
          *((float *)v49 + 71) = -*((float *)v12 + 24);
          *((_QWORD *)v53 + 4) = *(_QWORD *)(v12 + 92);
          if (a2 >= 1)
            goto LABEL_588;
          goto LABEL_591;
        }
      }
      else
      {
        *((_DWORD *)v49 + 70) = *((_DWORD *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_583;
      }
LABEL_586:
      if (a3 < 0)
      {
        *((float *)v49 + 71) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        *((_QWORD *)v53 + 4) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_588:
          *((float *)v53 + 10) = -*((float *)v12 + 23);
          if (a3 >= 1)
            goto LABEL_593;
          goto LABEL_596;
        }
      }
      else
      {
        *((_DWORD *)v49 + 71) = *((_DWORD *)v12 + 24);
        *((_QWORD *)v53 + 4) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
          goto LABEL_588;
      }
LABEL_591:
      if (a2 < 0)
      {
        *((float *)v53 + 10) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_593:
          *((float *)v53 + 11) = -*((float *)v12 + 24);
          *((_QWORD *)v53 + 10) = *(_QWORD *)(v12 + 84);
          if (a2 >= 1)
            goto LABEL_598;
          goto LABEL_601;
        }
      }
      else
      {
        *((_DWORD *)v53 + 10) = *((_DWORD *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_593;
      }
LABEL_596:
      if (a3 < 0)
      {
        *((float *)v53 + 11) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        *((_QWORD *)v53 + 10) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
        {
LABEL_598:
          *((float *)v53 + 22) = -*((float *)v12 + 21);
          if (a3 >= 1)
            goto LABEL_603;
          goto LABEL_606;
        }
      }
      else
      {
        *((_DWORD *)v53 + 11) = *((_DWORD *)v12 + 24);
        *((_QWORD *)v53 + 10) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_598;
      }
LABEL_601:
      if (a2 < 0)
      {
        *((float *)v53 + 22) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 >= 1)
        {
LABEL_603:
          *((float *)v53 + 23) = -*((float *)v12 + 22);
          *((_QWORD *)v53 + 16) = *(_QWORD *)(v12 + 84);
          if (a2 >= 1)
            goto LABEL_608;
          goto LABEL_611;
        }
      }
      else
      {
        *((_DWORD *)v53 + 22) = *((_DWORD *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_603;
      }
LABEL_606:
      if (a3 < 0)
      {
        *((float *)v53 + 23) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
        *((_QWORD *)v53 + 16) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
        {
LABEL_608:
          *((float *)v53 + 34) = -*((float *)v12 + 21);
          if (a3 >= 1)
            goto LABEL_613;
          goto LABEL_616;
        }
      }
      else
      {
        *((_DWORD *)v53 + 23) = *((_DWORD *)v12 + 22);
        *((_QWORD *)v53 + 16) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_608;
      }
LABEL_611:
      if (a2 < 0)
      {
        *((float *)v53 + 34) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 >= 1)
        {
LABEL_613:
          *((float *)v53 + 35) = -*((float *)v12 + 22);
          *((_QWORD *)v53 + 22) = *(_QWORD *)(v12 + 84);
          if (a2 >= 1)
            goto LABEL_618;
          goto LABEL_621;
        }
      }
      else
      {
        *((_DWORD *)v53 + 34) = *((_DWORD *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_613;
      }
LABEL_616:
      if (a3 < 0)
      {
        *((float *)v53 + 35) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
        *((_QWORD *)v53 + 22) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
        {
LABEL_618:
          *((float *)v53 + 46) = -*((float *)v12 + 21);
          if (a3 >= 1)
            goto LABEL_623;
          goto LABEL_626;
        }
      }
      else
      {
        *((_DWORD *)v53 + 35) = *((_DWORD *)v12 + 22);
        *((_QWORD *)v53 + 22) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_618;
      }
LABEL_621:
      if (a2 < 0)
      {
        *((float *)v53 + 46) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 >= 1)
        {
LABEL_623:
          *((float *)v53 + 47) = -*((float *)v12 + 22);
          *((_QWORD *)v53 + 28) = *(_QWORD *)(v12 + 92);
          if (a2 >= 1)
            goto LABEL_628;
          goto LABEL_631;
        }
      }
      else
      {
        *((_DWORD *)v53 + 46) = *((_DWORD *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_623;
      }
LABEL_626:
      if (a3 < 0)
      {
        *((float *)v53 + 47) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
        *((_QWORD *)v53 + 28) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_628:
          *((float *)v53 + 58) = -*((float *)v12 + 23);
          if (a3 >= 1)
            goto LABEL_633;
          goto LABEL_636;
        }
      }
      else
      {
        *((_DWORD *)v53 + 47) = *((_DWORD *)v12 + 22);
        *((_QWORD *)v53 + 28) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
          goto LABEL_628;
      }
LABEL_631:
      if (a2 < 0)
      {
        *((float *)v53 + 58) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_633:
          *((float *)v53 + 59) = -*((float *)v12 + 24);
          *((_QWORD *)v53 + 34) = *(_QWORD *)(v12 + 92);
          if (a2 >= 1)
            goto LABEL_638;
          goto LABEL_641;
        }
      }
      else
      {
        *((_DWORD *)v53 + 58) = *((_DWORD *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_633;
      }
LABEL_636:
      if (a3 < 0)
      {
        *((float *)v53 + 59) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        *((_QWORD *)v53 + 34) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_638:
          *((float *)v53 + 70) = -*((float *)v12 + 23);
          if (a3 >= 1)
            goto LABEL_643;
          goto LABEL_646;
        }
      }
      else
      {
        *((_DWORD *)v53 + 59) = *((_DWORD *)v12 + 24);
        *((_QWORD *)v53 + 34) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
          goto LABEL_638;
      }
LABEL_641:
      if (a2 < 0)
      {
        *((float *)v53 + 70) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_643:
          *((float *)v53 + 71) = -*((float *)v12 + 24);
          *((_QWORD *)v53 + 40) = *(_QWORD *)(v12 + 100);
          if (a2 >= 1)
            goto LABEL_648;
          goto LABEL_651;
        }
      }
      else
      {
        *((_DWORD *)v53 + 70) = *((_DWORD *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_643;
      }
LABEL_646:
      if (a3 < 0)
      {
        *((float *)v53 + 71) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        *((_QWORD *)v53 + 40) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_648:
          *((float *)v53 + 82) = -*((float *)v12 + 25);
          if (a3 >= 1)
            goto LABEL_653;
          goto LABEL_656;
        }
      }
      else
      {
        *((_DWORD *)v53 + 71) = *((_DWORD *)v12 + 24);
        *((_QWORD *)v53 + 40) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_648;
      }
LABEL_651:
      if (a2 < 0)
      {
        *((float *)v53 + 82) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_653:
          *((float *)v53 + 83) = -*((float *)v12 + 26);
          *((_QWORD *)v53 + 46) = *(_QWORD *)(v12 + 92);
          if (a2 >= 1)
            goto LABEL_658;
          goto LABEL_661;
        }
      }
      else
      {
        *((_DWORD *)v53 + 82) = *((_DWORD *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_653;
      }
LABEL_656:
      if (a3 < 0)
      {
        *((float *)v53 + 83) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        *((_QWORD *)v53 + 46) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_658:
          *((float *)v53 + 94) = -*((float *)v12 + 23);
          if (a3 >= 1)
            goto LABEL_663;
          goto LABEL_666;
        }
      }
      else
      {
        *((_DWORD *)v53 + 83) = *((_DWORD *)v12 + 26);
        *((_QWORD *)v53 + 46) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
          goto LABEL_658;
      }
LABEL_661:
      if (a2 < 0)
      {
        *((float *)v53 + 94) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_663:
          *((float *)v53 + 95) = -*((float *)v12 + 24);
          *((_QWORD *)v53 + 52) = *(_QWORD *)(v12 + 92);
          if (a2 >= 1)
            goto LABEL_668;
          goto LABEL_671;
        }
      }
      else
      {
        *((_DWORD *)v53 + 94) = *((_DWORD *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_663;
      }
LABEL_666:
      if (a3 < 0)
      {
        *((float *)v53 + 95) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        *((_QWORD *)v53 + 52) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_668:
          *((float *)v53 + 106) = -*((float *)v12 + 23);
          if (a3 >= 1)
            goto LABEL_673;
          goto LABEL_676;
        }
      }
      else
      {
        *((_DWORD *)v53 + 95) = *((_DWORD *)v12 + 24);
        *((_QWORD *)v53 + 52) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
          goto LABEL_668;
      }
LABEL_671:
      if (a2 < 0)
      {
        *((float *)v53 + 106) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_673:
          *((float *)v53 + 107) = -*((float *)v12 + 24);
          *((_QWORD *)v53 + 58) = *(_QWORD *)(v12 + 92);
          if (a2 >= 1)
            goto LABEL_678;
          goto LABEL_681;
        }
      }
      else
      {
        *((_DWORD *)v53 + 106) = *((_DWORD *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_673;
      }
LABEL_676:
      if (a3 < 0)
      {
        *((float *)v53 + 107) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        *((_QWORD *)v53 + 58) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_678:
          *((float *)v53 + 118) = -*((float *)v12 + 23);
          if (a3 >= 1)
            goto LABEL_683;
          goto LABEL_686;
        }
      }
      else
      {
        *((_DWORD *)v53 + 107) = *((_DWORD *)v12 + 24);
        *((_QWORD *)v53 + 58) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
          goto LABEL_678;
      }
LABEL_681:
      if (a2 < 0)
      {
        *((float *)v53 + 118) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_683:
          *((float *)v53 + 119) = -*((float *)v12 + 24);
          *((_QWORD *)v53 + 64) = *(_QWORD *)(v12 + 100);
          if (a2 >= 1)
            goto LABEL_688;
          goto LABEL_691;
        }
      }
      else
      {
        *((_DWORD *)v53 + 118) = *((_DWORD *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_683;
      }
LABEL_686:
      if (a3 < 0)
      {
        *((float *)v53 + 119) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        *((_QWORD *)v53 + 64) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_688:
          *((float *)v53 + 130) = -*((float *)v12 + 25);
          if (a3 >= 1)
            goto LABEL_693;
          goto LABEL_696;
        }
      }
      else
      {
        *((_DWORD *)v53 + 119) = *((_DWORD *)v12 + 24);
        *((_QWORD *)v53 + 64) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_688;
      }
LABEL_691:
      if (a2 < 0)
      {
        *((float *)v53 + 130) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_693:
          *((float *)v53 + 131) = -*((float *)v12 + 26);
          *((_QWORD *)v53 + 70) = *(_QWORD *)(v12 + 100);
          if (a2 >= 1)
            goto LABEL_698;
          goto LABEL_701;
        }
      }
      else
      {
        *((_DWORD *)v53 + 130) = *((_DWORD *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_693;
      }
LABEL_696:
      if (a3 < 0)
      {
        *((float *)v53 + 131) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        *((_QWORD *)v53 + 70) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_698:
          *((float *)v53 + 142) = -*((float *)v12 + 25);
          if (a3 >= 1)
            goto LABEL_703;
          goto LABEL_706;
        }
      }
      else
      {
        *((_DWORD *)v53 + 131) = *((_DWORD *)v12 + 26);
        *((_QWORD *)v53 + 70) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_698;
      }
LABEL_701:
      if (a2 < 0)
      {
        *((float *)v53 + 142) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_703:
          *((float *)v53 + 143) = -*((float *)v12 + 26);
          *((_QWORD *)v53 + 76) = *(_QWORD *)(v12 + 84);
          if (a2 >= 1)
            goto LABEL_708;
          goto LABEL_711;
        }
      }
      else
      {
        *((_DWORD *)v53 + 142) = *((_DWORD *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_703;
      }
LABEL_706:
      if (a3 < 0)
      {
        *((float *)v53 + 143) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        *((_QWORD *)v53 + 76) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
        {
LABEL_708:
          *((float *)v53 + 154) = -*((float *)v12 + 21);
          if (a3 >= 1)
            goto LABEL_713;
          goto LABEL_716;
        }
      }
      else
      {
        *((_DWORD *)v53 + 143) = *((_DWORD *)v12 + 26);
        *((_QWORD *)v53 + 76) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_708;
      }
LABEL_711:
      if (a2 < 0)
      {
        *((float *)v53 + 154) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 >= 1)
        {
LABEL_713:
          *((float *)v53 + 155) = -*((float *)v12 + 22);
          *((_QWORD *)v53 + 82) = *(_QWORD *)(v12 + 100);
          if (a2 >= 1)
            goto LABEL_718;
          goto LABEL_721;
        }
      }
      else
      {
        *((_DWORD *)v53 + 154) = *((_DWORD *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_713;
      }
LABEL_716:
      if (a3 < 0)
      {
        *((float *)v53 + 155) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
        *((_QWORD *)v53 + 82) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_718:
          *((float *)v53 + 166) = -*((float *)v12 + 25);
          if (a3 >= 1)
            goto LABEL_723;
          goto LABEL_726;
        }
      }
      else
      {
        *((_DWORD *)v53 + 155) = *((_DWORD *)v12 + 22);
        *((_QWORD *)v53 + 82) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_718;
      }
LABEL_721:
      if (a2 < 0)
      {
        *((float *)v53 + 166) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_723:
          *((float *)v53 + 167) = -*((float *)v12 + 26);
          *((_QWORD *)v53 + 88) = *(_QWORD *)(v12 + 100);
          if (a2 >= 1)
            goto LABEL_728;
          goto LABEL_731;
        }
      }
      else
      {
        *((_DWORD *)v53 + 166) = *((_DWORD *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_723;
      }
LABEL_726:
      if (a3 < 0)
      {
        *((float *)v53 + 167) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        *((_QWORD *)v53 + 88) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_728:
          *((float *)v53 + 178) = -*((float *)v12 + 25);
          if (a3 >= 1)
            goto LABEL_733;
          goto LABEL_736;
        }
      }
      else
      {
        *((_DWORD *)v53 + 167) = *((_DWORD *)v12 + 26);
        *((_QWORD *)v53 + 88) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_728;
      }
LABEL_731:
      if (a2 < 0)
      {
        *((float *)v53 + 178) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_733:
          *((float *)v53 + 179) = -*((float *)v12 + 26);
          *((_QWORD *)v53 + 94) = *(_QWORD *)(v12 + 100);
          if (a2 >= 1)
            goto LABEL_738;
          goto LABEL_741;
        }
      }
      else
      {
        *((_DWORD *)v53 + 178) = *((_DWORD *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_733;
      }
LABEL_736:
      if (a3 < 0)
      {
        *((float *)v53 + 179) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        *((_QWORD *)v53 + 94) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_738:
          *((float *)v53 + 190) = -*((float *)v12 + 25);
          if (a3 >= 1)
            goto LABEL_743;
          goto LABEL_746;
        }
      }
      else
      {
        *((_DWORD *)v53 + 179) = *((_DWORD *)v12 + 26);
        *((_QWORD *)v53 + 94) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_738;
      }
LABEL_741:
      if (a2 < 0)
      {
        *((float *)v53 + 190) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_743:
          *((float *)v53 + 191) = -*((float *)v12 + 26);
          *((_QWORD *)v53 + 100) = *(_QWORD *)(v12 + 84);
          if (a2 >= 1)
            goto LABEL_748;
          goto LABEL_751;
        }
      }
      else
      {
        *((_DWORD *)v53 + 190) = *((_DWORD *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_743;
      }
LABEL_746:
      if (a3 < 0)
      {
        *((float *)v53 + 191) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        *((_QWORD *)v53 + 100) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
        {
LABEL_748:
          *((float *)v53 + 202) = -*((float *)v12 + 21);
          if (a3 >= 1)
            goto LABEL_753;
          goto LABEL_756;
        }
      }
      else
      {
        *((_DWORD *)v53 + 191) = *((_DWORD *)v12 + 26);
        *((_QWORD *)v53 + 100) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_748;
      }
LABEL_751:
      if (a2 < 0)
      {
        *((float *)v53 + 202) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 >= 1)
        {
LABEL_753:
          *((float *)v53 + 203) = -*((float *)v12 + 22);
          *((_QWORD *)v53 + 106) = *(_QWORD *)(v12 + 84);
          if (a2 >= 1)
            goto LABEL_758;
          goto LABEL_761;
        }
      }
      else
      {
        *((_DWORD *)v53 + 202) = *((_DWORD *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_753;
      }
LABEL_756:
      if (a3 < 0)
      {
        *((float *)v53 + 203) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
        *((_QWORD *)v53 + 106) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
        {
LABEL_758:
          *((float *)v53 + 214) = -*((float *)v12 + 21);
          if (a3 < 1)
            goto LABEL_765;
          goto LABEL_526;
        }
      }
      else
      {
        *((_DWORD *)v53 + 203) = *((_DWORD *)v12 + 22);
        *((_QWORD *)v53 + 106) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_758;
      }
LABEL_761:
      if (a2 < 0)
      {
        *((float *)v53 + 214) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 < 1)
        {
LABEL_765:
          if (a3 < 0)
            v54 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
          else
            v54 = *((float *)v12 + 22);
          goto LABEL_527;
        }
      }
      else
      {
        *((_DWORD *)v53 + 214) = *((_DWORD *)v12 + 21);
        if (a3 < 1)
          goto LABEL_765;
      }
LABEL_526:
      v54 = -*((float *)v12 + 22);
LABEL_527:
      *((float *)v53 + 215) = v54;
      v49 += 36;
      v53 += 864;
      v12 += 108;
      v11 = (char *)v11 - 1;
      if (!v11)
        return;
    }
  }
  v18 = 36;
  if (*((float *)this + 34) == 0.0)
    v18 = 6;
  v19 = v18 * (_QWORD)v11;
  v20 = 3 * v18 * (_QWORD)v11;
  v21 = 16 * v20;
  v22 = (size_t)this[3];
  if (v22 >= 16 * v20)
  {
    if (!*((_DWORD *)this + 35) || this[13])
      goto LABEL_58;
    v24 = 0;
    v25 = 2743976168;
  }
  else
  {
    v23 = this[12];
    this[3] = (void *)v21;
    this[12] = malloc_type_realloc(v23, 16 * v20, 0x4704CCD1uLL);
    v24 = this[13];
    if (!*((_DWORD *)this + 35))
    {
      if (v24)
      {
        free(v24);
        this[13] = 0;
      }
      goto LABEL_58;
    }
    v22 = (size_t)this[3];
    v25 = 1948624706;
  }
  this[13] = malloc_type_realloc(v24, v22, v25);
LABEL_58:
  bzero(this[12], v21);
  if (*((_DWORD *)this + 35))
    bzero(this[13], v21);
  this[14] = (void *)v19;
  v43 = this[12];
  if (*((float *)this + 34) == 0.0)
  {
    v44 = (char *)(v43 + 22);
    for (k = (float *)(v12 + 84); ; k += 29)
    {
      *((_QWORD *)v44 - 18) = *(_QWORD *)k;
      if (a2 < 1)
      {
        if (a2 < 0)
        {
          *((float *)v44 - 34) = (float)(*(k - 21) + *(k - 21)) - *k;
          if (a3 >= 1)
          {
LABEL_69:
            *((float *)v44 - 33) = -k[1];
            *((_QWORD *)v44 - 12) = *((_QWORD *)k + 1);
            if (a2 >= 1)
              goto LABEL_74;
            goto LABEL_77;
          }
        }
        else
        {
          *((float *)v44 - 34) = *k;
          if (a3 >= 1)
            goto LABEL_69;
        }
      }
      else
      {
        *((float *)v44 - 34) = -*k;
        if (a3 >= 1)
          goto LABEL_69;
      }
      if (a3 < 0)
      {
        *((float *)v44 - 33) = (float)(*(k - 20) + *(k - 20)) - k[1];
        *((_QWORD *)v44 - 12) = *((_QWORD *)k + 1);
        if (a2 >= 1)
        {
LABEL_74:
          *((float *)v44 - 22) = -k[2];
          if (a3 >= 1)
            goto LABEL_79;
          goto LABEL_82;
        }
      }
      else
      {
        *((float *)v44 - 33) = k[1];
        *((_QWORD *)v44 - 12) = *((_QWORD *)k + 1);
        if (a2 >= 1)
          goto LABEL_74;
      }
LABEL_77:
      if (a2 < 0)
      {
        *((float *)v44 - 22) = (float)(*(k - 21) + *(k - 21)) - k[2];
        if (a3 >= 1)
        {
LABEL_79:
          *((float *)v44 - 21) = -k[3];
          *((_QWORD *)v44 - 6) = *((_QWORD *)k + 2);
          if (a2 >= 1)
            goto LABEL_84;
          goto LABEL_87;
        }
      }
      else
      {
        *((float *)v44 - 22) = k[2];
        if (a3 >= 1)
          goto LABEL_79;
      }
LABEL_82:
      if (a3 < 0)
      {
        *((float *)v44 - 21) = (float)(*(k - 20) + *(k - 20)) - k[3];
        *((_QWORD *)v44 - 6) = *((_QWORD *)k + 2);
        if (a2 >= 1)
        {
LABEL_84:
          *((float *)v44 - 10) = -k[4];
          if (a3 >= 1)
            goto LABEL_89;
          goto LABEL_92;
        }
      }
      else
      {
        *((float *)v44 - 21) = k[3];
        *((_QWORD *)v44 - 6) = *((_QWORD *)k + 2);
        if (a2 >= 1)
          goto LABEL_84;
      }
LABEL_87:
      if (a2 < 0)
      {
        *((float *)v44 - 10) = (float)(*(k - 21) + *(k - 21)) - k[4];
        if (a3 >= 1)
        {
LABEL_89:
          *((float *)v44 - 9) = -k[5];
          *(_QWORD *)v44 = *((_QWORD *)k + 2);
          if (a2 >= 1)
            goto LABEL_94;
          goto LABEL_97;
        }
      }
      else
      {
        *((float *)v44 - 10) = k[4];
        if (a3 >= 1)
          goto LABEL_89;
      }
LABEL_92:
      if (a3 < 0)
      {
        *((float *)v44 - 9) = (float)(*(k - 20) + *(k - 20)) - k[5];
        *(_QWORD *)v44 = *((_QWORD *)k + 2);
        if (a2 >= 1)
        {
LABEL_94:
          *((float *)v44 + 2) = -k[4];
          if (a3 >= 1)
            goto LABEL_99;
          goto LABEL_102;
        }
      }
      else
      {
        *((float *)v44 - 9) = k[5];
        *(_QWORD *)v44 = *((_QWORD *)k + 2);
        if (a2 >= 1)
          goto LABEL_94;
      }
LABEL_97:
      if (a2 < 0)
      {
        *((float *)v44 + 2) = (float)(*(k - 21) + *(k - 21)) - k[4];
        if (a3 >= 1)
        {
LABEL_99:
          *((float *)v44 + 3) = -k[5];
          *((_QWORD *)v44 + 6) = *((_QWORD *)k + 3);
          if (a2 >= 1)
            goto LABEL_104;
          goto LABEL_107;
        }
      }
      else
      {
        *((float *)v44 + 2) = k[4];
        if (a3 >= 1)
          goto LABEL_99;
      }
LABEL_102:
      if (a3 < 0)
      {
        *((float *)v44 + 3) = (float)(*(k - 20) + *(k - 20)) - k[5];
        *((_QWORD *)v44 + 6) = *((_QWORD *)k + 3);
        if (a2 >= 1)
        {
LABEL_104:
          *((float *)v44 + 14) = -k[6];
          if (a3 >= 1)
            goto LABEL_109;
          goto LABEL_112;
        }
      }
      else
      {
        *((float *)v44 + 3) = k[5];
        *((_QWORD *)v44 + 6) = *((_QWORD *)k + 3);
        if (a2 >= 1)
          goto LABEL_104;
      }
LABEL_107:
      if (a2 < 0)
      {
        *((float *)v44 + 14) = (float)(*(k - 21) + *(k - 21)) - k[6];
        if (a3 >= 1)
        {
LABEL_109:
          *((float *)v44 + 15) = -k[7];
          *((_QWORD *)v44 + 12) = *(_QWORD *)k;
          if (a2 >= 1)
            goto LABEL_114;
          goto LABEL_117;
        }
      }
      else
      {
        *((float *)v44 + 14) = k[6];
        if (a3 >= 1)
          goto LABEL_109;
      }
LABEL_112:
      if (a3 < 0)
      {
        *((float *)v44 + 15) = (float)(*(k - 20) + *(k - 20)) - k[7];
        *((_QWORD *)v44 + 12) = *(_QWORD *)k;
        if (a2 >= 1)
        {
LABEL_114:
          *((float *)v44 + 26) = -*k;
          if (a3 < 1)
            goto LABEL_121;
          goto LABEL_62;
        }
      }
      else
      {
        *((float *)v44 + 15) = k[7];
        *((_QWORD *)v44 + 12) = *(_QWORD *)k;
        if (a2 >= 1)
          goto LABEL_114;
      }
LABEL_117:
      if (a2 < 0)
      {
        *((float *)v44 + 26) = (float)(*(k - 21) + *(k - 21)) - *k;
        if (a3 < 1)
        {
LABEL_121:
          if (a3 < 0)
            v46 = (float)(*(k - 20) + *(k - 20)) - k[1];
          else
            v46 = k[1];
          goto LABEL_63;
        }
      }
      else
      {
        *((float *)v44 + 26) = *k;
        if (a3 < 1)
          goto LABEL_121;
      }
LABEL_62:
      v46 = -k[1];
LABEL_63:
      *((float *)v44 + 27) = v46;
      v44 += 288;
      v11 = (char *)v11 - 1;
      if (!v11)
        return;
    }
  }
  v47 = (char *)&v43[72 * (_QWORD)v11];
  do
  {
    v43[4] = *(_QWORD *)(v12 + 84);
    if (a2 < 1)
    {
      if (a2 < 0)
      {
        *((float *)v43 + 10) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 >= 1)
        {
LABEL_132:
          *((float *)v43 + 11) = -*((float *)v12 + 22);
          v43[10] = *(_QWORD *)(v12 + 92);
          if (a2 >= 1)
            goto LABEL_137;
          goto LABEL_140;
        }
      }
      else
      {
        *((_DWORD *)v43 + 10) = *((_DWORD *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_132;
      }
    }
    else
    {
      *((float *)v43 + 10) = -*((float *)v12 + 21);
      if (a3 >= 1)
        goto LABEL_132;
    }
    if (a3 < 0)
    {
      *((float *)v43 + 11) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      v43[10] = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_137:
        *((float *)v43 + 22) = -*((float *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_142;
        goto LABEL_145;
      }
    }
    else
    {
      *((_DWORD *)v43 + 11) = *((_DWORD *)v12 + 22);
      v43[10] = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
        goto LABEL_137;
    }
LABEL_140:
    if (a2 < 0)
    {
      *((float *)v43 + 22) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_142:
        *((float *)v43 + 23) = -*((float *)v12 + 24);
        v43[16] = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_147;
        goto LABEL_150;
      }
    }
    else
    {
      *((_DWORD *)v43 + 22) = *((_DWORD *)v12 + 23);
      if (a3 >= 1)
        goto LABEL_142;
    }
LABEL_145:
    if (a3 < 0)
    {
      *((float *)v43 + 23) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      v43[16] = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_147:
        *((float *)v43 + 34) = -*((float *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_152;
        goto LABEL_155;
      }
    }
    else
    {
      *((_DWORD *)v43 + 23) = *((_DWORD *)v12 + 24);
      v43[16] = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
        goto LABEL_147;
    }
LABEL_150:
    if (a2 < 0)
    {
      *((float *)v43 + 34) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_152:
        *((float *)v43 + 35) = -*((float *)v12 + 26);
        v43[22] = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_157;
        goto LABEL_160;
      }
    }
    else
    {
      *((_DWORD *)v43 + 34) = *((_DWORD *)v12 + 25);
      if (a3 >= 1)
        goto LABEL_152;
    }
LABEL_155:
    if (a3 < 0)
    {
      *((float *)v43 + 35) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      v43[22] = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_157:
        *((float *)v43 + 46) = -*((float *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_162;
        goto LABEL_165;
      }
    }
    else
    {
      *((_DWORD *)v43 + 35) = *((_DWORD *)v12 + 26);
      v43[22] = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
        goto LABEL_157;
    }
LABEL_160:
    if (a2 < 0)
    {
      *((float *)v43 + 46) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_162:
        *((float *)v43 + 47) = -*((float *)v12 + 26);
        v43[28] = *(_QWORD *)(v12 + 108);
        if (a2 >= 1)
          goto LABEL_167;
        goto LABEL_170;
      }
    }
    else
    {
      *((_DWORD *)v43 + 46) = *((_DWORD *)v12 + 25);
      if (a3 >= 1)
        goto LABEL_162;
    }
LABEL_165:
    if (a3 < 0)
    {
      *((float *)v43 + 47) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      v43[28] = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_167:
        *((float *)v43 + 58) = -*((float *)v12 + 27);
        if (a3 >= 1)
          goto LABEL_172;
        goto LABEL_175;
      }
    }
    else
    {
      *((_DWORD *)v43 + 47) = *((_DWORD *)v12 + 26);
      v43[28] = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
        goto LABEL_167;
    }
LABEL_170:
    if (a2 < 0)
    {
      *((float *)v43 + 58) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_172:
        *((float *)v43 + 59) = -*((float *)v12 + 28);
        v43[34] = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_177;
        goto LABEL_180;
      }
    }
    else
    {
      *((_DWORD *)v43 + 58) = *((_DWORD *)v12 + 27);
      if (a3 >= 1)
        goto LABEL_172;
    }
LABEL_175:
    if (a3 < 0)
    {
      *((float *)v43 + 59) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      v43[34] = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_177:
        *((float *)v43 + 70) = -*((float *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_182;
        goto LABEL_185;
      }
    }
    else
    {
      *((_DWORD *)v43 + 59) = *((_DWORD *)v12 + 28);
      v43[34] = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
        goto LABEL_177;
    }
LABEL_180:
    if (a2 < 0)
    {
      *((float *)v43 + 70) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_182:
        *((float *)v43 + 71) = -*((float *)v12 + 22);
        v43[40] = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_187;
        goto LABEL_190;
      }
    }
    else
    {
      *((_DWORD *)v43 + 70) = *((_DWORD *)v12 + 21);
      if (a3 >= 1)
        goto LABEL_182;
    }
LABEL_185:
    if (a3 < 0)
    {
      *((float *)v43 + 71) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      v43[40] = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_187:
        *((float *)v43 + 82) = -*((float *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_192;
        goto LABEL_195;
      }
    }
    else
    {
      *((_DWORD *)v43 + 71) = *((_DWORD *)v12 + 22);
      v43[40] = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
        goto LABEL_187;
    }
LABEL_190:
    if (a2 < 0)
    {
      *((float *)v43 + 82) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_192:
        *((float *)v43 + 83) = -*((float *)v12 + 22);
        v43[46] = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_197;
        goto LABEL_200;
      }
    }
    else
    {
      *((_DWORD *)v43 + 82) = *((_DWORD *)v12 + 21);
      if (a3 >= 1)
        goto LABEL_192;
    }
LABEL_195:
    if (a3 < 0)
    {
      *((float *)v43 + 83) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      v43[46] = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_197:
        *((float *)v43 + 94) = -*((float *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_202;
        goto LABEL_205;
      }
    }
    else
    {
      *((_DWORD *)v43 + 83) = *((_DWORD *)v12 + 22);
      v43[46] = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
        goto LABEL_197;
    }
LABEL_200:
    if (a2 < 0)
    {
      *((float *)v43 + 94) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_202:
        *((float *)v43 + 95) = -*((float *)v12 + 26);
        v43[52] = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
          goto LABEL_207;
        goto LABEL_210;
      }
    }
    else
    {
      *((_DWORD *)v43 + 94) = *((_DWORD *)v12 + 25);
      if (a3 >= 1)
        goto LABEL_202;
    }
LABEL_205:
    if (a3 < 0)
    {
      *((float *)v43 + 95) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      v43[52] = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_207:
        *((float *)v43 + 106) = -*((float *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_212;
        goto LABEL_215;
      }
    }
    else
    {
      *((_DWORD *)v43 + 95) = *((_DWORD *)v12 + 26);
      v43[52] = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
        goto LABEL_207;
    }
LABEL_210:
    if (a2 < 0)
    {
      *((float *)v43 + 106) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_212:
        *((float *)v43 + 107) = -*((float *)v12 + 24);
        v43[58] = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_217;
        goto LABEL_220;
      }
    }
    else
    {
      *((_DWORD *)v43 + 106) = *((_DWORD *)v12 + 23);
      if (a3 >= 1)
        goto LABEL_212;
    }
LABEL_215:
    if (a3 < 0)
    {
      *((float *)v43 + 107) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      v43[58] = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_217:
        *((float *)v43 + 118) = -*((float *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_222;
        goto LABEL_225;
      }
    }
    else
    {
      *((_DWORD *)v43 + 107) = *((_DWORD *)v12 + 24);
      v43[58] = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
        goto LABEL_217;
    }
LABEL_220:
    if (a2 < 0)
    {
      *((float *)v43 + 118) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_222:
        *((float *)v43 + 119) = -*((float *)v12 + 26);
        v43[64] = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_227;
        goto LABEL_230;
      }
    }
    else
    {
      *((_DWORD *)v43 + 118) = *((_DWORD *)v12 + 25);
      if (a3 >= 1)
        goto LABEL_222;
    }
LABEL_225:
    if (a3 < 0)
    {
      *((float *)v43 + 119) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      v43[64] = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_227:
        *((float *)v43 + 130) = -*((float *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_232;
        goto LABEL_235;
      }
    }
    else
    {
      *((_DWORD *)v43 + 119) = *((_DWORD *)v12 + 26);
      v43[64] = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
        goto LABEL_227;
    }
LABEL_230:
    if (a2 < 0)
    {
      *((float *)v43 + 130) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_232:
        *((float *)v43 + 131) = -*((float *)v12 + 22);
        v43[70] = *(_QWORD *)(v12 + 108);
        if (a2 >= 1)
          goto LABEL_237;
        goto LABEL_240;
      }
    }
    else
    {
      *((_DWORD *)v43 + 130) = *((_DWORD *)v12 + 21);
      if (a3 >= 1)
        goto LABEL_232;
    }
LABEL_235:
    if (a3 < 0)
    {
      *((float *)v43 + 131) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      v43[70] = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_237:
        *((float *)v43 + 142) = -*((float *)v12 + 27);
        if (a3 >= 1)
          goto LABEL_242;
        goto LABEL_245;
      }
    }
    else
    {
      *((_DWORD *)v43 + 131) = *((_DWORD *)v12 + 22);
      v43[70] = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
        goto LABEL_237;
    }
LABEL_240:
    if (a2 < 0)
    {
      *((float *)v43 + 142) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_242:
        *((float *)v43 + 143) = -*((float *)v12 + 28);
        *((_QWORD *)v47 + 4) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
          goto LABEL_247;
        goto LABEL_250;
      }
    }
    else
    {
      *((_DWORD *)v43 + 142) = *((_DWORD *)v12 + 27);
      if (a3 >= 1)
        goto LABEL_242;
    }
LABEL_245:
    if (a3 < 0)
    {
      *((float *)v43 + 143) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      *((_QWORD *)v47 + 4) = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_247:
        *((float *)v47 + 10) = -*((float *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_252;
        goto LABEL_255;
      }
    }
    else
    {
      *((_DWORD *)v43 + 143) = *((_DWORD *)v12 + 28);
      *((_QWORD *)v47 + 4) = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
        goto LABEL_247;
    }
LABEL_250:
    if (a2 < 0)
    {
      *((float *)v47 + 10) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_252:
        *((float *)v47 + 11) = -*((float *)v12 + 24);
        *((_QWORD *)v47 + 10) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_257;
        goto LABEL_260;
      }
    }
    else
    {
      *((_DWORD *)v47 + 10) = *((_DWORD *)v12 + 23);
      if (a3 >= 1)
        goto LABEL_252;
    }
LABEL_255:
    if (a3 < 0)
    {
      *((float *)v47 + 11) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      *((_QWORD *)v47 + 10) = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_257:
        *((float *)v47 + 22) = -*((float *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_262;
        goto LABEL_265;
      }
    }
    else
    {
      *((_DWORD *)v47 + 11) = *((_DWORD *)v12 + 24);
      *((_QWORD *)v47 + 10) = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
        goto LABEL_257;
    }
LABEL_260:
    if (a2 < 0)
    {
      *((float *)v47 + 22) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_262:
        *((float *)v47 + 23) = -*((float *)v12 + 22);
        *((_QWORD *)v47 + 16) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_267;
        goto LABEL_270;
      }
    }
    else
    {
      *((_DWORD *)v47 + 22) = *((_DWORD *)v12 + 21);
      if (a3 >= 1)
        goto LABEL_262;
    }
LABEL_265:
    if (a3 < 0)
    {
      *((float *)v47 + 23) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      *((_QWORD *)v47 + 16) = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_267:
        *((float *)v47 + 34) = -*((float *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_272;
        goto LABEL_275;
      }
    }
    else
    {
      *((_DWORD *)v47 + 23) = *((_DWORD *)v12 + 22);
      *((_QWORD *)v47 + 16) = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
        goto LABEL_267;
    }
LABEL_270:
    if (a2 < 0)
    {
      *((float *)v47 + 34) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_272:
        *((float *)v47 + 35) = -*((float *)v12 + 22);
        *((_QWORD *)v47 + 22) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_277;
        goto LABEL_280;
      }
    }
    else
    {
      *((_DWORD *)v47 + 34) = *((_DWORD *)v12 + 21);
      if (a3 >= 1)
        goto LABEL_272;
    }
LABEL_275:
    if (a3 < 0)
    {
      *((float *)v47 + 35) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      *((_QWORD *)v47 + 22) = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_277:
        *((float *)v47 + 46) = -*((float *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_282;
        goto LABEL_285;
      }
    }
    else
    {
      *((_DWORD *)v47 + 35) = *((_DWORD *)v12 + 22);
      *((_QWORD *)v47 + 22) = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
        goto LABEL_277;
    }
LABEL_280:
    if (a2 < 0)
    {
      *((float *)v47 + 46) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_282:
        *((float *)v47 + 47) = -*((float *)v12 + 22);
        *((_QWORD *)v47 + 28) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
          goto LABEL_287;
        goto LABEL_290;
      }
    }
    else
    {
      *((_DWORD *)v47 + 46) = *((_DWORD *)v12 + 21);
      if (a3 >= 1)
        goto LABEL_282;
    }
LABEL_285:
    if (a3 < 0)
    {
      *((float *)v47 + 47) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      *((_QWORD *)v47 + 28) = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_287:
        *((float *)v47 + 58) = -*((float *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_292;
        goto LABEL_295;
      }
    }
    else
    {
      *((_DWORD *)v47 + 47) = *((_DWORD *)v12 + 22);
      *((_QWORD *)v47 + 28) = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
        goto LABEL_287;
    }
LABEL_290:
    if (a2 < 0)
    {
      *((float *)v47 + 58) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_292:
        *((float *)v47 + 59) = -*((float *)v12 + 24);
        *((_QWORD *)v47 + 34) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
          goto LABEL_297;
        goto LABEL_300;
      }
    }
    else
    {
      *((_DWORD *)v47 + 58) = *((_DWORD *)v12 + 23);
      if (a3 >= 1)
        goto LABEL_292;
    }
LABEL_295:
    if (a3 < 0)
    {
      *((float *)v47 + 59) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      *((_QWORD *)v47 + 34) = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_297:
        *((float *)v47 + 70) = -*((float *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_302;
        goto LABEL_305;
      }
    }
    else
    {
      *((_DWORD *)v47 + 59) = *((_DWORD *)v12 + 24);
      *((_QWORD *)v47 + 34) = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
        goto LABEL_297;
    }
LABEL_300:
    if (a2 < 0)
    {
      *((float *)v47 + 70) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_302:
        *((float *)v47 + 71) = -*((float *)v12 + 24);
        *((_QWORD *)v47 + 40) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_307;
        goto LABEL_310;
      }
    }
    else
    {
      *((_DWORD *)v47 + 70) = *((_DWORD *)v12 + 23);
      if (a3 >= 1)
        goto LABEL_302;
    }
LABEL_305:
    if (a3 < 0)
    {
      *((float *)v47 + 71) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      *((_QWORD *)v47 + 40) = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_307:
        *((float *)v47 + 82) = -*((float *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_312;
        goto LABEL_315;
      }
    }
    else
    {
      *((_DWORD *)v47 + 71) = *((_DWORD *)v12 + 24);
      *((_QWORD *)v47 + 40) = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
        goto LABEL_307;
    }
LABEL_310:
    if (a2 < 0)
    {
      *((float *)v47 + 82) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_312:
        *((float *)v47 + 83) = -*((float *)v12 + 26);
        *((_QWORD *)v47 + 46) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
          goto LABEL_317;
        goto LABEL_320;
      }
    }
    else
    {
      *((_DWORD *)v47 + 82) = *((_DWORD *)v12 + 25);
      if (a3 >= 1)
        goto LABEL_312;
    }
LABEL_315:
    if (a3 < 0)
    {
      *((float *)v47 + 83) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      *((_QWORD *)v47 + 46) = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_317:
        *((float *)v47 + 94) = -*((float *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_322;
        goto LABEL_325;
      }
    }
    else
    {
      *((_DWORD *)v47 + 83) = *((_DWORD *)v12 + 26);
      *((_QWORD *)v47 + 46) = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
        goto LABEL_317;
    }
LABEL_320:
    if (a2 < 0)
    {
      *((float *)v47 + 94) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_322:
        *((float *)v47 + 95) = -*((float *)v12 + 24);
        *((_QWORD *)v47 + 52) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
          goto LABEL_327;
        goto LABEL_330;
      }
    }
    else
    {
      *((_DWORD *)v47 + 94) = *((_DWORD *)v12 + 23);
      if (a3 >= 1)
        goto LABEL_322;
    }
LABEL_325:
    if (a3 < 0)
    {
      *((float *)v47 + 95) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      *((_QWORD *)v47 + 52) = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_327:
        *((float *)v47 + 106) = -*((float *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_332;
        goto LABEL_335;
      }
    }
    else
    {
      *((_DWORD *)v47 + 95) = *((_DWORD *)v12 + 24);
      *((_QWORD *)v47 + 52) = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
        goto LABEL_327;
    }
LABEL_330:
    if (a2 < 0)
    {
      *((float *)v47 + 106) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_332:
        *((float *)v47 + 107) = -*((float *)v12 + 24);
        *((_QWORD *)v47 + 58) = *(_QWORD *)(v12 + 92);
        if (a2 >= 1)
          goto LABEL_337;
        goto LABEL_340;
      }
    }
    else
    {
      *((_DWORD *)v47 + 106) = *((_DWORD *)v12 + 23);
      if (a3 >= 1)
        goto LABEL_332;
    }
LABEL_335:
    if (a3 < 0)
    {
      *((float *)v47 + 107) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      *((_QWORD *)v47 + 58) = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_337:
        *((float *)v47 + 118) = -*((float *)v12 + 23);
        if (a3 >= 1)
          goto LABEL_342;
        goto LABEL_345;
      }
    }
    else
    {
      *((_DWORD *)v47 + 107) = *((_DWORD *)v12 + 24);
      *((_QWORD *)v47 + 58) = *(_QWORD *)(v12 + 92);
      if (a2 >= 1)
        goto LABEL_337;
    }
LABEL_340:
    if (a2 < 0)
    {
      *((float *)v47 + 118) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_342:
        *((float *)v47 + 119) = -*((float *)v12 + 24);
        *((_QWORD *)v47 + 64) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_347;
        goto LABEL_350;
      }
    }
    else
    {
      *((_DWORD *)v47 + 118) = *((_DWORD *)v12 + 23);
      if (a3 >= 1)
        goto LABEL_342;
    }
LABEL_345:
    if (a3 < 0)
    {
      *((float *)v47 + 119) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      *((_QWORD *)v47 + 64) = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_347:
        *((float *)v47 + 130) = -*((float *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_352;
        goto LABEL_355;
      }
    }
    else
    {
      *((_DWORD *)v47 + 119) = *((_DWORD *)v12 + 24);
      *((_QWORD *)v47 + 64) = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
        goto LABEL_347;
    }
LABEL_350:
    if (a2 < 0)
    {
      *((float *)v47 + 130) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_352:
        *((float *)v47 + 131) = -*((float *)v12 + 26);
        *((_QWORD *)v47 + 70) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_357;
        goto LABEL_360;
      }
    }
    else
    {
      *((_DWORD *)v47 + 130) = *((_DWORD *)v12 + 25);
      if (a3 >= 1)
        goto LABEL_352;
    }
LABEL_355:
    if (a3 < 0)
    {
      *((float *)v47 + 131) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      *((_QWORD *)v47 + 70) = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_357:
        *((float *)v47 + 142) = -*((float *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_362;
        goto LABEL_365;
      }
    }
    else
    {
      *((_DWORD *)v47 + 131) = *((_DWORD *)v12 + 26);
      *((_QWORD *)v47 + 70) = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
        goto LABEL_357;
    }
LABEL_360:
    if (a2 < 0)
    {
      *((float *)v47 + 142) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_362:
        *((float *)v47 + 143) = -*((float *)v12 + 26);
        *((_QWORD *)v47 + 76) = *(_QWORD *)(v12 + 108);
        if (a2 >= 1)
          goto LABEL_367;
        goto LABEL_370;
      }
    }
    else
    {
      *((_DWORD *)v47 + 142) = *((_DWORD *)v12 + 25);
      if (a3 >= 1)
        goto LABEL_362;
    }
LABEL_365:
    if (a3 < 0)
    {
      *((float *)v47 + 143) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      *((_QWORD *)v47 + 76) = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_367:
        *((float *)v47 + 154) = -*((float *)v12 + 27);
        if (a3 >= 1)
          goto LABEL_372;
        goto LABEL_375;
      }
    }
    else
    {
      *((_DWORD *)v47 + 143) = *((_DWORD *)v12 + 26);
      *((_QWORD *)v47 + 76) = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
        goto LABEL_367;
    }
LABEL_370:
    if (a2 < 0)
    {
      *((float *)v47 + 154) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_372:
        *((float *)v47 + 155) = -*((float *)v12 + 28);
        *((_QWORD *)v47 + 82) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_377;
        goto LABEL_380;
      }
    }
    else
    {
      *((_DWORD *)v47 + 154) = *((_DWORD *)v12 + 27);
      if (a3 >= 1)
        goto LABEL_372;
    }
LABEL_375:
    if (a3 < 0)
    {
      *((float *)v47 + 155) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      *((_QWORD *)v47 + 82) = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_377:
        *((float *)v47 + 166) = -*((float *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_382;
        goto LABEL_385;
      }
    }
    else
    {
      *((_DWORD *)v47 + 155) = *((_DWORD *)v12 + 28);
      *((_QWORD *)v47 + 82) = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
        goto LABEL_377;
    }
LABEL_380:
    if (a2 < 0)
    {
      *((float *)v47 + 166) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_382:
        *((float *)v47 + 167) = -*((float *)v12 + 26);
        *((_QWORD *)v47 + 88) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_387;
        goto LABEL_390;
      }
    }
    else
    {
      *((_DWORD *)v47 + 166) = *((_DWORD *)v12 + 25);
      if (a3 >= 1)
        goto LABEL_382;
    }
LABEL_385:
    if (a3 < 0)
    {
      *((float *)v47 + 167) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      *((_QWORD *)v47 + 88) = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_387:
        *((float *)v47 + 178) = -*((float *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_392;
        goto LABEL_395;
      }
    }
    else
    {
      *((_DWORD *)v47 + 167) = *((_DWORD *)v12 + 26);
      *((_QWORD *)v47 + 88) = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
        goto LABEL_387;
    }
LABEL_390:
    if (a2 < 0)
    {
      *((float *)v47 + 178) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_392:
        *((float *)v47 + 179) = -*((float *)v12 + 26);
        *((_QWORD *)v47 + 94) = *(_QWORD *)(v12 + 100);
        if (a2 >= 1)
          goto LABEL_397;
        goto LABEL_400;
      }
    }
    else
    {
      *((_DWORD *)v47 + 178) = *((_DWORD *)v12 + 25);
      if (a3 >= 1)
        goto LABEL_392;
    }
LABEL_395:
    if (a3 < 0)
    {
      *((float *)v47 + 179) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      *((_QWORD *)v47 + 94) = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_397:
        *((float *)v47 + 190) = -*((float *)v12 + 25);
        if (a3 >= 1)
          goto LABEL_402;
        goto LABEL_405;
      }
    }
    else
    {
      *((_DWORD *)v47 + 179) = *((_DWORD *)v12 + 26);
      *((_QWORD *)v47 + 94) = *(_QWORD *)(v12 + 100);
      if (a2 >= 1)
        goto LABEL_397;
    }
LABEL_400:
    if (a2 < 0)
    {
      *((float *)v47 + 190) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_402:
        *((float *)v47 + 191) = -*((float *)v12 + 26);
        *((_QWORD *)v47 + 100) = *(_QWORD *)(v12 + 108);
        if (a2 >= 1)
          goto LABEL_407;
        goto LABEL_410;
      }
    }
    else
    {
      *((_DWORD *)v47 + 190) = *((_DWORD *)v12 + 25);
      if (a3 >= 1)
        goto LABEL_402;
    }
LABEL_405:
    if (a3 < 0)
    {
      *((float *)v47 + 191) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      *((_QWORD *)v47 + 100) = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_407:
        *((float *)v47 + 202) = -*((float *)v12 + 27);
        if (a3 >= 1)
          goto LABEL_412;
        goto LABEL_415;
      }
    }
    else
    {
      *((_DWORD *)v47 + 191) = *((_DWORD *)v12 + 26);
      *((_QWORD *)v47 + 100) = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
        goto LABEL_407;
    }
LABEL_410:
    if (a2 < 0)
    {
      *((float *)v47 + 202) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_412:
        *((float *)v47 + 203) = -*((float *)v12 + 28);
        *((_QWORD *)v47 + 106) = *(_QWORD *)(v12 + 108);
        if (a2 >= 1)
          goto LABEL_417;
        goto LABEL_420;
      }
    }
    else
    {
      *((_DWORD *)v47 + 202) = *((_DWORD *)v12 + 27);
      if (a3 >= 1)
        goto LABEL_412;
    }
LABEL_415:
    if (a3 < 0)
    {
      *((float *)v47 + 203) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      *((_QWORD *)v47 + 106) = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_417:
        *((float *)v47 + 214) = -*((float *)v12 + 27);
        if (a3 >= 1)
          goto LABEL_422;
        goto LABEL_425;
      }
    }
    else
    {
      *((_DWORD *)v47 + 203) = *((_DWORD *)v12 + 28);
      *((_QWORD *)v47 + 106) = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
        goto LABEL_417;
    }
LABEL_420:
    if (a2 < 0)
    {
      *((float *)v47 + 214) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_422:
        *((float *)v47 + 215) = -*((float *)v12 + 28);
        *((_QWORD *)v47 + 112) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_427;
        goto LABEL_430;
      }
    }
    else
    {
      *((_DWORD *)v47 + 214) = *((_DWORD *)v12 + 27);
      if (a3 >= 1)
        goto LABEL_422;
    }
LABEL_425:
    if (a3 < 0)
    {
      *((float *)v47 + 215) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      *((_QWORD *)v47 + 112) = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_427:
        *((float *)v47 + 226) = -*((float *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_432;
        goto LABEL_435;
      }
    }
    else
    {
      *((_DWORD *)v47 + 215) = *((_DWORD *)v12 + 28);
      *((_QWORD *)v47 + 112) = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
        goto LABEL_427;
    }
LABEL_430:
    if (a2 < 0)
    {
      *((float *)v47 + 226) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_432:
        *((float *)v47 + 227) = -*((float *)v12 + 22);
        *((_QWORD *)v47 + 118) = *(_QWORD *)(v12 + 108);
        if (a2 >= 1)
          goto LABEL_437;
        goto LABEL_440;
      }
    }
    else
    {
      *((_DWORD *)v47 + 226) = *((_DWORD *)v12 + 21);
      if (a3 >= 1)
        goto LABEL_432;
    }
LABEL_435:
    if (a3 < 0)
    {
      *((float *)v47 + 227) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      *((_QWORD *)v47 + 118) = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_437:
        *((float *)v47 + 238) = -*((float *)v12 + 27);
        if (a3 >= 1)
          goto LABEL_442;
        goto LABEL_445;
      }
    }
    else
    {
      *((_DWORD *)v47 + 227) = *((_DWORD *)v12 + 22);
      *((_QWORD *)v47 + 118) = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
        goto LABEL_437;
    }
LABEL_440:
    if (a2 < 0)
    {
      *((float *)v47 + 238) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_442:
        *((float *)v47 + 239) = -*((float *)v12 + 28);
        *((_QWORD *)v47 + 124) = *(_QWORD *)(v12 + 108);
        if (a2 >= 1)
          goto LABEL_447;
        goto LABEL_450;
      }
    }
    else
    {
      *((_DWORD *)v47 + 238) = *((_DWORD *)v12 + 27);
      if (a3 >= 1)
        goto LABEL_442;
    }
LABEL_445:
    if (a3 < 0)
    {
      *((float *)v47 + 239) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      *((_QWORD *)v47 + 124) = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_447:
        *((float *)v47 + 250) = -*((float *)v12 + 27);
        if (a3 >= 1)
          goto LABEL_452;
        goto LABEL_455;
      }
    }
    else
    {
      *((_DWORD *)v47 + 239) = *((_DWORD *)v12 + 28);
      *((_QWORD *)v47 + 124) = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
        goto LABEL_447;
    }
LABEL_450:
    if (a2 < 0)
    {
      *((float *)v47 + 250) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_452:
        *((float *)v47 + 251) = -*((float *)v12 + 28);
        *((_QWORD *)v47 + 130) = *(_QWORD *)(v12 + 108);
        if (a2 >= 1)
          goto LABEL_457;
        goto LABEL_460;
      }
    }
    else
    {
      *((_DWORD *)v47 + 250) = *((_DWORD *)v12 + 27);
      if (a3 >= 1)
        goto LABEL_452;
    }
LABEL_455:
    if (a3 < 0)
    {
      *((float *)v47 + 251) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      *((_QWORD *)v47 + 130) = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_457:
        *((float *)v47 + 262) = -*((float *)v12 + 27);
        if (a3 >= 1)
          goto LABEL_462;
        goto LABEL_465;
      }
    }
    else
    {
      *((_DWORD *)v47 + 251) = *((_DWORD *)v12 + 28);
      *((_QWORD *)v47 + 130) = *(_QWORD *)(v12 + 108);
      if (a2 >= 1)
        goto LABEL_457;
    }
LABEL_460:
    if (a2 < 0)
    {
      *((float *)v47 + 262) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_462:
        *((float *)v47 + 263) = -*((float *)v12 + 28);
        *((_QWORD *)v47 + 136) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_467;
        goto LABEL_470;
      }
    }
    else
    {
      *((_DWORD *)v47 + 262) = *((_DWORD *)v12 + 27);
      if (a3 >= 1)
        goto LABEL_462;
    }
LABEL_465:
    if (a3 < 0)
    {
      *((float *)v47 + 263) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      *((_QWORD *)v47 + 136) = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_467:
        *((float *)v47 + 274) = -*((float *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_472;
        goto LABEL_475;
      }
    }
    else
    {
      *((_DWORD *)v47 + 263) = *((_DWORD *)v12 + 28);
      *((_QWORD *)v47 + 136) = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
        goto LABEL_467;
    }
LABEL_470:
    if (a2 < 0)
    {
      *((float *)v47 + 274) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_472:
        *((float *)v47 + 275) = -*((float *)v12 + 22);
        *((_QWORD *)v47 + 142) = *(_QWORD *)(v12 + 84);
        if (a2 >= 1)
          goto LABEL_477;
        goto LABEL_480;
      }
    }
    else
    {
      *((_DWORD *)v47 + 274) = *((_DWORD *)v12 + 21);
      if (a3 >= 1)
        goto LABEL_472;
    }
LABEL_475:
    if (a3 < 0)
    {
      *((float *)v47 + 275) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      *((_QWORD *)v47 + 142) = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_477:
        *((float *)v47 + 286) = -*((float *)v12 + 21);
        if (a3 >= 1)
          goto LABEL_125;
        goto LABEL_484;
      }
    }
    else
    {
      *((_DWORD *)v47 + 275) = *((_DWORD *)v12 + 22);
      *((_QWORD *)v47 + 142) = *(_QWORD *)(v12 + 84);
      if (a2 >= 1)
        goto LABEL_477;
    }
LABEL_480:
    if (a2 < 0)
    {
      *((float *)v47 + 286) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_125:
        v48 = -*((float *)v12 + 22);
        goto LABEL_126;
      }
    }
    else
    {
      *((_DWORD *)v47 + 286) = *((_DWORD *)v12 + 21);
      if (a3 >= 1)
        goto LABEL_125;
    }
LABEL_484:
    if (a3 < 0)
      v48 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
    else
      v48 = *((float *)v12 + 22);
LABEL_126:
    *((float *)v47 + 287) = v48;
    v43 += 72;
    v47 += 1152;
    v12 += 116;
    v11 = (char *)v11 - 1;
  }
  while (v11);
}

float *emit(uint64_t a1, float *a2, float *a3, unint64_t a4, unsigned int a5, int a6, __n128 a7, __n128 a8, double a9, float32x4_t a10, float32x4_t a11, float32x4_t a12, uint64_t a13, uint64_t a14, double a15, double a16, float a17, __int32 a18, unsigned __int32 a19, unsigned __int32 a20)
{
  float32x4_t v18;
  __n128 v19;
  float32x4_t v20;
  __n128 v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  __n128 v25;
  float *v28;
  float v29;
  float *v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  float v34;
  float v35;
  float v36;
  float v37;
  uint64_t v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  int32x2_t v55;
  uint64_t v56;
  float v57;
  float *j;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float32x4_t v73;
  float v74;
  __float2 v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  uint64_t v96;
  float v97;
  float *i;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float32x4_t v106;
  float32x4_t v107;
  int8x16_t v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  __float2 v114;
  float32x2_t v115;
  float32x2_t v116;
  float v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  int8x16_t v132;
  int8x16_t v133;
  float32x4_t v134;
  float32x4_t v135;
  int8x16_t v136;
  int8x16_t v137;
  float32x4_t v138;
  int8x16_t v139;
  int8x16_t v140;
  float32x4_t v141;
  float32x4_t v142;
  int8x16_t v143;
  int8x16_t v144;
  float32x4_t *v145;
  float v146;
  float v147;
  float v148;
  float v149;
  float v150;
  float v151;
  float v152;
  float v153;
  float v154;
  float v155;
  float v156;
  float v157;
  float v158;
  float v159;
  float v160;
  float v161;
  float v162;
  float v163;
  float v164;
  float v165;
  float v166;
  float v167;
  float v168;
  float v169;
  float v170;
  float v171;
  float v172;
  float v173;
  float v174;
  float v175;
  float v176;
  float v177;
  float v178;
  float v179;
  float v180;
  float v181;
  float v182;
  float v183;
  float v184;
  float v185;
  float v186;
  uint64_t v187;
  float *v188;
  float v189;
  float v190;
  float v191;
  float v192;
  float v193;
  float v194;
  float v195;
  float v196;
  float v197;
  float v198;
  float v199;
  float v200;
  float v201;
  float v202;
  float v203;
  float v204;
  float v205;
  float v206;
  float v207;
  float v208;
  float v209;
  float v210;
  float v211;
  float v212;
  float v213;
  float v214;
  float v215;
  __float2 v216;
  float v217;
  float v218;
  __n128 v219;
  float v220;
  float v221;
  float v222;
  float v223;
  float v224;
  float v225;
  float v226;
  float v227;
  float v228;
  float v229;
  float v230;
  float v231;
  float v232;
  float v233;
  float v234;
  float v235;
  float v236;
  float v237;
  float v238;
  float v239;
  float v240;
  float v241;
  float v242;
  float v243;
  float v244;
  float v245;
  float v246;
  float v247;
  float v248;
  float v249;
  float v250;
  float v251;
  float v252;
  _OWORD *v253;
  float v254;
  float v255;
  float v256;
  float v257;
  float v258;
  float v259;
  float v260;
  float v261;
  float v262;
  float v263;
  float v264;
  float v265;
  float v266;
  float v267;
  float v268;
  float v269;
  float v270;
  float v271;
  float v272;
  float v273;
  float v274;
  float v275;
  float v276;
  float v277;
  float v278;
  float v279;
  float v280;
  float v281;
  float v282;
  unsigned int v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  float *v288;
  uint64_t v289;
  float v290;
  float v291;
  float v292;
  float v293;
  float v294;
  float v295;
  float v296;
  float v297;
  float v298;
  float v299;
  unint64_t v300;
  float v301;
  float v302;
  float v303;
  float v304;
  float v305;
  float v306;
  float v307;
  uint64_t v308;
  float *v309;
  __float2 v310;
  float v311;
  float v312;
  float v313;
  float v314;
  float v315;
  float v316;
  float v317;
  float v318;
  float v319;
  float v320;
  float v321;
  float v322;
  float v323;
  float v324;
  float v325;
  float v326;
  float v327;
  float v328;
  float v329;
  float v330;
  float v331;
  float v332;
  float v333;
  float v334;
  float v335;
  float v336;
  float v337;
  float v338;
  float v339;
  float v340;
  float v341;
  float v342;
  float v343;
  __n128 v344;
  unsigned int v345;
  float *v346;
  uint64_t v347;
  float v348;
  float v349;
  float *v350;
  __int128 v351;
  float *v352;
  float v353;
  float v354;
  float v355;
  float v356;
  float v357;
  float v358;
  float v359;
  float v360;
  float v361;
  float *v362;
  int v363;
  float v364;
  float v365;
  float v366;
  float v367;
  unsigned int v368;
  float *v369;
  float *v370;
  float *v371;
  float *v372;
  float v373;
  float v374;
  float v375;
  float v376;
  float *v377;
  float v378;
  float v379;
  float v380;
  float v381;
  float v382;
  float v383;
  float v384;
  unsigned int v385;
  uint64_t v386;
  float *v387;
  float *v388;
  float v389;
  float v390;
  float v391;
  float v392;
  float *v393;
  float *v394;
  int v395;
  unsigned int v396;
  float *v397;
  float *v398;
  float *v399;
  uint64_t v400;
  unsigned int v401;
  float *v402;
  float *v403;
  float v404;
  float v405;
  float v406;
  float v407;
  float *v408;
  float v409;
  float v410;
  float v411;
  float v412;
  float v413;
  float v414;
  float v415;
  float v416;
  float v417;
  float v418;
  float v419;
  uint64_t v420;
  uint64_t v421;
  __int128 v422;
  uint64_t v423;
  __int128 v424;
  uint64_t v425;
  uint64_t v426;
  __int128 v427;
  __int128 v428;
  uint64_t v429;
  unsigned int v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  float v435;
  float v436;
  float v437;
  float v438;
  unint64_t v439;
  float v440;
  uint64_t v441;
  float32x4_t v442;
  float v443;
  float v444;
  float v445;
  float v446;
  float v447;
  float v448;
  unsigned __int32 v449;
  float32_t v450;
  float v451;
  unint64_t v452;
  float v453;
  float v454;
  __n128 v455;
  __n128 v456;
  float v457;

  v28 = a3;
  v448 = a7.n128_f32[0];
  v449 = a12.u32[0];
  v25.n128_u32[0] = a11.i32[0];
  v20.i32[0] = LODWORD(a9);
  v29 = a8.n128_f32[0];
  v30 = a2;
  v31 = a1;
  v32 = a1 + 8 * (a6 != 0);
  if (a6)
  {
    v33 = *(_BYTE *)(a1 + 144) == 0;
    v34 = -1.0;
    v35 = -2.0;
    v36 = -1.0;
    goto LABEL_5;
  }
  if (*(_DWORD *)(a1 + 140))
  {
    v33 = *(_BYTE *)(a1 + 144) == 0;
    v34 = 0.0;
    v35 = 1.0;
    v36 = 0.0;
LABEL_5:
    v453 = v36;
    if (v33)
      v37 = v35;
    else
      v37 = v34;
    v38 = *(_QWORD *)(v32 + 96);
    v39 = a3[15];
    if (v39 == 0.0)
      goto LABEL_33;
    goto LABEL_9;
  }
  v35 = 1.0;
  v37 = 0.0;
  v453 = 0.0;
  v38 = *(_QWORD *)(v32 + 96);
  v39 = a3[15];
  if (v39 == 0.0)
    goto LABEL_33;
LABEL_9:
  v40 = a3[16];
  if (v40 != 0.0)
  {
    v42 = a3[13];
    v41 = a3[14];
    if (v29 >= 0.0)
    {
      v46 = fminf(fmaxf(v29 - v42, 0.0), v41);
    }
    else
    {
      v43 = fminf(fmaxf((float)(v29 + 1.0) - v42, 0.0), v41) - v41;
      v44 = v42 - (float)(v41 + -1.0);
      if (v44 <= v29)
        v45 = 0.0;
      else
        v45 = v29 - v44;
      if (v41 > 1.0)
        v46 = v45;
      else
        v46 = v43;
    }
    v47 = 1.0 / (float)(v46 * v46);
    v48 = v39 + v47;
    if ((float)(v39 + v47) > 0.0)
      v48 = 0.0;
    v49 = v39 - v47;
    if ((float)(v39 - v47) < 0.0)
      v49 = 0.0;
    if (v39 >= 0.0)
      v50 = v49;
    else
      v50 = v48;
    a3[15] = v50;
    v51 = v40 + v47;
    if ((float)(v40 + v47) > 0.0)
      v51 = 0.0;
    v52 = v40 - v47;
    if (v52 < 0.0)
      v52 = 0.0;
    if (v40 >= 0.0)
      v53 = v52;
    else
      v53 = v51;
    a3[16] = v53;
  }
LABEL_33:
  v55.i32[0] = a18;
  a7.n128_u32[0] = a19;
  a8.n128_u32[0] = a20;
  v446 = v37;
  v447 = v29;
  if (a5 == 4)
  {
    v96 = v38 + 48 * (0x5555555555555556 * (((uint64_t)a2 - v38) >> 4) + 12 * *(_QWORD *)(a1 + 64));
    v97 = 1.0;
    v20.i32[1] = a10.i32[0];
    v55.i32[1] = a19;
    v444 = v29 + 1.0;
    for (i = a3 + 14; ; i += 29)
    {
      v99 = *(i - 1);
      v100 = fminf(fmaxf(v29 - v99, 0.0), *i);
      v101 = fminf(fmaxf(v444 - v99, 0.0), *i) - *i;
      v102 = v99 - (float)(*i + -1.0);
      if (v102 <= v29)
        v103 = 0.0;
      else
        v103 = v29 - v102;
      if (*i <= v97)
        v103 = v101;
      if (v29 < 0.0)
        a12.f32[0] = v103;
      else
        a12.f32[0] = v100;
      v104 = *(float *)(v31 + 168) + (float)(fabsf(a12.f32[0]) * (float)(*(float *)(v31 + 172) - *(float *)(v31 + 168)));
      v105 = v104 * v448;
      a11.f32[0] = (float)(v104 * v448) * 0.5;
      if (a4 && a12.f32[0] == 0.0)
      {
        v106.i64[0] = *((_QWORD *)i - 7);
        v106.i64[1] = v106.i64[0];
        a10 = vmulq_n_f32(vsubq_f32(*(float32x4_t *)(i + 11), v106), v104);
        v22 = (int8x16_t)vaddq_f32(v106, a10);
        v107 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a11.f32, 0);
        v108 = (int8x16_t)vaddq_f32(v106, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(i + 7), v106), v104));
        v109 = 1.0;
        v110 = 0.0;
        v111 = 0.0;
        v112 = 0.0;
        v113 = 1.0;
      }
      else
      {
        v24.f32[0] = *(i - 14);
        if (a4)
        {
          v454 = v104;
          v450 = (float)(v104 * v448) * 0.5;
          v439 = a12.i64[0];
          v441 = v24.i64[0];
          v114 = __sincosf_stret((float)(a12.f32[0] * (float)(*(i - 3) * 6.2832)) * 0.5);
          a8.n128_f32[0] = v114.__cosval;
          a12.i32[1] = HIDWORD(v439);
          v24.i64[0] = v441;
          v104 = v454;
          a10.f32[0] = *(i - 7);
          a17 = *(i - 6) * v114.__sinval;
          v115.f32[0] = *(i - 10);
          v22.i32[0] = *(__int32 *)(i - 13);
          v25.n128_f32[0] = *(float *)&v439 * (float)(a10.f32[0] * *(i - 8));
          v115.i32[1] = a10.i32[0];
          a10.f32[1] = *(i - 9);
          v55 = (int32x2_t)vmul_n_f32(*(float32x2_t *)(i - 5), v114.__sinval);
          a11.f32[0] = v450;
          v116 = vmul_f32(v115, *(float32x2_t *)a10.f32);
          a10.i32[1] = HIDWORD(v439);
          a9 = COERCE_DOUBLE(vmul_n_f32(vmul_n_f32(*(float32x2_t *)(i + 1), *(float *)&v439), *(float *)&v439));
          *(float32x2_t *)v20.f32 = vadd_f32(vadd_f32((float32x2_t)__PAIR64__(v22.u32[0], v441), vmul_n_f32(v116, *(float *)&v439)), *(float32x2_t *)&a9);
          v117 = 1.0;
        }
        else
        {
          v22.i32[0] = *(__int32 *)(i - 13);
          v117 = *(float *)&v449;
        }
        *(int32x2_t *)v118.f32 = v55;
        *(int32x2_t *)&v118.u32[2] = v55;
        v119.i64[0] = v20.i64[0];
        v119.i64[1] = v20.i64[0];
        a10.f32[0] = i[5];
        *(float *)&a9 = a11.f32[0] - a10.f32[0];
        a12.f32[0] = (float)(a11.f32[0] - a10.f32[0]) * *(float *)v55.i32;
        v23.f32[0] = a17 * (float)(a11.f32[0] - a10.f32[0]);
        *(float *)&v449 = v117;
        v113 = i[6] + (float)(v117 + (float)((float)(a8.n128_f32[0] * 0.0) + (float)(0.0 - i[6])));
        v120.f32[0] = i[13];
        v121.f32[0] = i[14];
        v120.f32[1] = i[11];
        v120.f32[2] = i[9];
        v120.f32[3] = i[7];
        v121.f32[1] = i[12];
        v121.f32[2] = i[10];
        v121.f32[3] = i[8];
        v122.i32[0] = vdupq_lane_s32(v55, 1).u32[0];
        v123 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 0);
        v23 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
        v124 = vsubq_f32(v121, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.i8, 0));
        v121.i64[0] = *(_QWORD *)(i + 3);
        v121.i64[1] = v121.i64[0];
        v125 = vsubq_f32(vmulq_n_f32(vsubq_f32(v120, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 0)), v104), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v121.f32, 0));
        v126 = vsubq_f32(vmulq_n_f32(v124, v104), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v121.f32, 1));
        v127 = vsubq_f32(vmulq_n_f32(v126, a17), vmulq_n_f32(v125, *(float *)v55.i32));
        v24 = vaddq_f32(v127, v127);
        v128 = vsubq_f32(vmulq_lane_f32(v125, (float32x2_t)v55, 1), v123);
        v129 = vaddq_f32(v128, v128);
        v130 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a12.f32, 0), vmulq_lane_f32(v126, (float32x2_t)v55, 1));
        v131 = vaddq_f32(v130, v130);
        v132 = (int8x16_t)vzip1q_s32((int32x4_t)v24, (int32x4_t)v131);
        v133 = (int8x16_t)vzip2q_s32((int32x4_t)v24, (int32x4_t)v131);
        v134 = vmulq_f32(v118, (float32x4_t)vextq_s8(v133, v133, 8uLL));
        v135 = vmulq_f32(v118, (float32x4_t)vextq_s8(v132, v132, 8uLL));
        v122.f32[1] = a17;
        v122.i64[1] = v122.i64[0];
        v136 = (int8x16_t)vzip1q_s32((int32x4_t)v129, (int32x4_t)v24);
        v137 = (int8x16_t)vzip2q_s32((int32x4_t)v129, (int32x4_t)v24);
        v138 = vsubq_f32(v135, vmulq_f32(v122, (float32x4_t)vextq_s8(v136, v136, 8uLL)));
        v139 = (int8x16_t)vzip1q_s32((int32x4_t)v125, (int32x4_t)v126);
        v140 = (int8x16_t)vzip2q_s32((int32x4_t)v125, (int32x4_t)v126);
        v141 = vaddq_f32((float32x4_t)vextq_s8(v140, v140, 8uLL), vsubq_f32(v134, vmulq_f32(v122, (float32x4_t)vextq_s8(v137, v137, 8uLL))));
        v142 = vaddq_f32((float32x4_t)vextq_s8(v139, v139, 8uLL), v138);
        v143 = (int8x16_t)vzip1q_s32((int32x4_t)v131, (int32x4_t)v129);
        v144 = (int8x16_t)vzip2q_s32((int32x4_t)v131, (int32x4_t)v129);
        a12 = vaddq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)v25.n128_u64[0], 0), vaddq_f32(vmulq_n_f32(v24, a8.n128_f32[0]), vaddq_f32(v23, vsubq_f32(vmulq_n_f32(v129, a17), vmulq_n_f32(v131, *(float *)v55.i32)))));
        v22 = (int8x16_t)vaddq_f32(v121, vaddq_f32(v119, vaddq_f32(vmulq_n_f32((float32x4_t)vextq_s8(v143, v143, 8uLL), a8.n128_f32[0]), v142)));
        a11 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a10.f32, 0);
        v108 = (int8x16_t)vaddq_f32(v121, vaddq_f32(v119, vaddq_f32(vmulq_n_f32((float32x4_t)vextq_s8(v144, v144, 8uLL), a8.n128_f32[0]), v141)));
        v107 = vaddq_f32(a11, a12);
        v141.f32[0] = vmuls_lane_f32(0.0, (float32x2_t)v55, 1);
        a11.f32[0] = (float)(*(float *)v55.i32 - v141.f32[0]) + (float)(*(float *)v55.i32 - v141.f32[0]);
        v141.f32[0] = (float)(v141.f32[0] - a17) + (float)(v141.f32[0] - a17);
        a12.f32[0] = (float)((float)(a17 * 0.0) - (float)(0.0 * *(float *)v55.i32))
                   + (float)((float)(a17 * 0.0) - (float)(0.0 * *(float *)v55.i32));
        v110 = (float)(a8.n128_f32[0] * a11.f32[0])
             + (float)((float)((float)(a12.f32[0] * *(float *)v55.i32) - vmuls_lane_f32(v141.f32[0], (float32x2_t)v55, 1))+ 0.0);
        v111 = (float)(a8.n128_f32[0] * v141.f32[0])
             + (float)((float)(vmuls_lane_f32(a11.f32[0], (float32x2_t)v55, 1) - (float)(a17 * a12.f32[0])) + 0.0);
        v109 = (float)(a8.n128_f32[0] * a12.f32[0])
             + (float)((float)((float)(a17 * v141.f32[0]) - (float)(a11.f32[0] * *(float *)v55.i32)) + v97);
        v112 = (float)(a8.n128_f32[0] * 0.0) + 0.0;
      }
      *(_QWORD *)v30 = v108.i64[0];
      v30[2] = v107.f32[3];
      v30[3] = v113;
      v30[4] = v110;
      v30[5] = v111;
      v30[6] = v109;
      v30[7] = v453;
      *((_QWORD *)v30 + 6) = vextq_s8(v108, v108, 8uLL).u64[0];
      v30[14] = v107.f32[2];
      v30[15] = v113;
      v30[16] = v110;
      v30[17] = v111;
      v30[18] = v109;
      v30[19] = v453;
      *((_QWORD *)v30 + 12) = v22.i64[0];
      v30[26] = v107.f32[1];
      v30[27] = v113;
      v30[28] = v110;
      v30[29] = v111;
      v30[30] = v109;
      v30[31] = v453;
      *((_QWORD *)v30 + 18) = v22.i64[0];
      v30[38] = v107.f32[1];
      v30[39] = v113;
      v30[40] = v110;
      v30[41] = v111;
      v30[42] = v109;
      v30[43] = v453;
      *(_QWORD *)&a9 = vextq_s8(v22, v22, 8uLL).u64[0];
      *((double *)v30 + 24) = a9;
      v30[50] = v107.f32[0];
      v30[51] = v113;
      v30[52] = v110;
      v30[53] = v111;
      v30[54] = v109;
      v30[55] = v453;
      *((_QWORD *)v30 + 30) = v108.i64[0];
      v30[62] = v107.f32[3];
      v30[63] = v113;
      v30[64] = v110;
      v145 = (float32x4_t *)(v30 + 72);
      v30[65] = v111;
      v30[66] = v109;
      v30[67] = v453;
      if (v105 <= 0.0)
      {
        v30 += 72;
        if (a4 < 2)
          return v30;
      }
      else
      {
        v146 = v105 * v110;
        v147 = v105 * v111;
        v148 = v105 * v109;
        v149 = v105 * v112;
        v455 = v25;
        v150 = *(float *)v108.i32 - (float)(v105 * v110);
        v151 = *(float *)&v108.i32[1] - (float)(v105 * v111);
        v152 = v107.f32[3] - (float)(v105 * v109);
        v153 = v113 - v149;
        v30[72] = v150;
        v30[73] = v151;
        v30[74] = v152;
        v30[75] = v153;
        v30[76] = v110;
        v30[77] = v111;
        v30[78] = v109;
        v30[79] = v37;
        a10.i32[1] = v20.i32[1];
        v30[84] = *(float *)v22.i32 - v146;
        v30[85] = *(float *)&v22.i32[1] - v147;
        v30[86] = v107.f32[1] - v148;
        v30[87] = v153;
        v30[88] = v110;
        v30[89] = v111;
        v30[90] = v109;
        v30[91] = v446;
        v30[96] = *(float *)&v108.i32[2] - v146;
        v30[97] = *(float *)&v108.i32[3] - v147;
        v97 = 1.0;
        v30[98] = v107.f32[2] - v148;
        v37 = v446;
        v30[99] = v153;
        v30[100] = v110;
        v30[101] = v111;
        v30[102] = v109;
        v30[103] = v446;
        *((_OWORD *)v30 + 27) = *((_OWORD *)v30 + 21);
        v30[112] = v110;
        v30[113] = v111;
        v30[114] = v109;
        v30[115] = v446;
        *((float32x4_t *)v30 + 30) = *v145;
        v30[124] = v110;
        v30[125] = v111;
        v30[126] = v109;
        v30[127] = v446;
        v30[132] = *(float *)&v22.i32[2] - v146;
        v30[133] = *(float *)&v22.i32[3] - v147;
        v30[134] = v107.f32[0] - v148;
        v30[135] = v153;
        v30[136] = v110;
        v30[137] = v111;
        v30[138] = v109;
        v30[139] = v446;
        v154 = v151 - *(float *)&v108.i32[3];
        v29 = v447;
        v155 = (float)((float)(*(float *)&v108.i32[1] - *(float *)&v108.i32[3]) * (float)(v152 - v107.f32[2]))
             - (float)((float)(v107.f32[3] - v107.f32[2]) * v154);
        v156 = (float)((float)(v150 - *(float *)&v108.i32[2]) * (float)(v107.f32[3] - v107.f32[2]))
             - (float)((float)(*(float *)v108.i32 - *(float *)&v108.i32[2]) * (float)(v152 - v107.f32[2]));
        v157 = (float)((float)(*(float *)v108.i32 - *(float *)&v108.i32[2]) * v154)
             - (float)((float)(*(float *)&v108.i32[1] - *(float *)&v108.i32[3]) * (float)(v150 - *(float *)&v108.i32[2]));
        v158 = sqrtf((float)(v157 * v157) + (float)((float)(v155 * v155) + (float)(v156 * v156)));
        v159 = v156 / v158;
        v160 = v157 / v158;
        *(_QWORD *)v96 = v108.i64[1];
        *(_DWORD *)(v96 + 8) = v107.i32[2];
        *(float *)(v96 + 12) = v113;
        *(float *)(v96 + 16) = v155 / v158;
        *(float *)(v96 + 20) = v159;
        *(float *)(v96 + 24) = v160;
        *(float *)(v96 + 28) = v35;
        *(_QWORD *)(v96 + 48) = v108.i64[0];
        *(_DWORD *)(v96 + 56) = v107.i32[3];
        *(float *)(v96 + 60) = v113;
        *(float *)(v96 + 64) = v155 / v158;
        *(float *)(v96 + 68) = v159;
        *(float *)(v96 + 72) = v160;
        *(float *)(v96 + 76) = v35;
        *(float32x4_t *)(v96 + 96) = *v145;
        *(float *)(v96 + 112) = v155 / v158;
        *(float *)(v96 + 116) = v159;
        *(float *)(v96 + 120) = v160;
        *(float *)(v96 + 124) = v35;
        *(float32x4_t *)(v96 + 144) = *v145;
        *(float *)(v96 + 160) = v155 / v158;
        *(float *)(v96 + 164) = v159;
        *(float *)(v96 + 168) = v160;
        *(float *)(v96 + 172) = v35;
        *(_OWORD *)(v96 + 192) = *((_OWORD *)v30 + 24);
        *(float *)(v96 + 208) = v155 / v158;
        *(float *)(v96 + 212) = v159;
        *(float *)(v96 + 216) = v160;
        *(float *)(v96 + 220) = v35;
        *(_QWORD *)(v96 + 240) = v108.i64[1];
        *(_DWORD *)(v96 + 248) = v107.i32[2];
        *(float *)(v96 + 252) = v113;
        *(float *)(v96 + 256) = v155 / v158;
        *(float *)(v96 + 260) = v159;
        *(float *)(v96 + 264) = v160;
        *(float *)(v96 + 268) = v35;
        v161 = v30[96] - *(float *)v22.i32;
        v162 = v30[97] - *(float *)&v22.i32[1];
        v163 = v30[98] - v107.f32[1];
        v164 = (float)((float)(*(float *)&v108.i32[3] - *(float *)&v22.i32[1]) * v163)
             - (float)((float)(v107.f32[2] - v107.f32[1]) * v162);
        v25 = v455;
        v165 = (float)((float)(v107.f32[2] - v107.f32[1]) * v161)
             - (float)((float)(*(float *)&v108.i32[2] - *(float *)v22.i32) * v163);
        v166 = (float)((float)(*(float *)&v108.i32[2] - *(float *)v22.i32) * v162)
             - (float)((float)(*(float *)&v108.i32[3] - *(float *)&v22.i32[1]) * v161);
        v167 = sqrtf((float)(v166 * v166) + (float)((float)(v164 * v164) + (float)(v165 * v165)));
        v168 = v165 / v167;
        v169 = v166 / v167;
        *(_QWORD *)(v96 + 288) = v22.i64[0];
        *(_DWORD *)(v96 + 296) = v107.i32[1];
        *(float *)(v96 + 300) = v113;
        *(float *)(v96 + 304) = v164 / v167;
        *(float *)(v96 + 308) = v168;
        *(float *)(v96 + 312) = v169;
        *(float *)(v96 + 316) = v35;
        *(_QWORD *)(v96 + 336) = v108.i64[1];
        *(_DWORD *)(v96 + 344) = v107.i32[2];
        *(float *)(v96 + 348) = v113;
        *(float *)(v96 + 352) = v164 / v167;
        *(float *)(v96 + 356) = v168;
        *(float *)(v96 + 360) = v169;
        *(float *)(v96 + 364) = v35;
        *(_OWORD *)(v96 + 384) = *((_OWORD *)v30 + 24);
        *(float *)(v96 + 400) = v164 / v167;
        *(float *)(v96 + 404) = v168;
        *(float *)(v96 + 408) = v169;
        *(float *)(v96 + 412) = v35;
        *(_OWORD *)(v96 + 432) = *((_OWORD *)v30 + 24);
        *(float *)(v96 + 448) = v164 / v167;
        *(float *)(v96 + 452) = v168;
        *(float *)(v96 + 456) = v169;
        *(float *)(v96 + 460) = v35;
        *(_OWORD *)(v96 + 480) = *((_OWORD *)v30 + 21);
        *(float *)(v96 + 496) = v164 / v167;
        *(float *)(v96 + 500) = v168;
        *(float *)(v96 + 504) = v169;
        *(float *)(v96 + 508) = v35;
        *(_QWORD *)(v96 + 528) = v22.i64[0];
        *(_DWORD *)(v96 + 536) = v107.i32[1];
        *(float *)(v96 + 540) = v113;
        *(float *)(v96 + 544) = v164 / v167;
        *(float *)(v96 + 548) = v168;
        *(float *)(v96 + 552) = v169;
        *(float *)(v96 + 556) = v35;
        v170 = v30[84] - *(float *)&v22.i32[2];
        v171 = v30[85] - *(float *)&v22.i32[3];
        v172 = v30[86] - v107.f32[0];
        v173 = (float)((float)(*(float *)&v22.i32[1] - *(float *)&v22.i32[3]) * v172)
             - (float)((float)(v107.f32[1] - v107.f32[0]) * v171);
        v174 = (float)((float)(v107.f32[1] - v107.f32[0]) * v170)
             - (float)((float)(*(float *)v22.i32 - *(float *)&v22.i32[2]) * v172);
        v175 = (float)((float)(*(float *)v22.i32 - *(float *)&v22.i32[2]) * v171)
             - (float)((float)(*(float *)&v22.i32[1] - *(float *)&v22.i32[3]) * v170);
        v176 = sqrtf((float)(v175 * v175) + (float)((float)(v173 * v173) + (float)(v174 * v174)));
        v177 = v174 / v176;
        v178 = v175 / v176;
        *(_DWORD *)(v96 + 576) = v22.i32[2];
        *(_DWORD *)(v96 + 580) = v22.i32[3];
        *(_DWORD *)(v96 + 584) = v107.i32[0];
        *(float *)(v96 + 588) = v113;
        *(float *)(v96 + 592) = v173 / v176;
        *(float *)(v96 + 596) = v177;
        *(float *)(v96 + 600) = v178;
        *(float *)(v96 + 604) = v35;
        *(_QWORD *)(v96 + 624) = v22.i64[0];
        *(_DWORD *)(v96 + 632) = v107.i32[1];
        *(float *)(v96 + 636) = v113;
        *(float *)(v96 + 640) = v173 / v176;
        *(float *)(v96 + 644) = v177;
        *(float *)(v96 + 648) = v178;
        *(float *)(v96 + 652) = v35;
        *(_OWORD *)(v96 + 672) = *((_OWORD *)v30 + 21);
        *(float *)(v96 + 688) = v173 / v176;
        *(float *)(v96 + 692) = v177;
        *(float *)(v96 + 696) = v178;
        *(float *)(v96 + 700) = v35;
        *(_OWORD *)(v96 + 720) = *((_OWORD *)v30 + 21);
        *(float *)(v96 + 736) = v173 / v176;
        *(float *)(v96 + 740) = v177;
        *(float *)(v96 + 744) = v178;
        *(float *)(v96 + 748) = v35;
        *(_OWORD *)(v96 + 768) = *((_OWORD *)v30 + 33);
        *(float *)(v96 + 784) = v173 / v176;
        *(float *)(v96 + 788) = v177;
        *(float *)(v96 + 792) = v178;
        *(float *)(v96 + 796) = v35;
        *(_DWORD *)(v96 + 816) = v22.i32[2];
        *(_DWORD *)(v96 + 820) = v22.i32[3];
        *(_DWORD *)(v96 + 824) = v107.i32[0];
        *(float *)(v96 + 828) = v113;
        *(float *)(v96 + 832) = v173 / v176;
        *(float *)(v96 + 836) = v177;
        *(float *)(v96 + 840) = v178;
        *(float *)(v96 + 844) = v35;
        *(float *)v22.i32 = v30[132] - *(float *)v108.i32;
        v179 = v30[133] - *(float *)&v108.i32[1];
        v180 = v30[134] - v107.f32[3];
        v181 = (float)((float)(*(float *)&v22.i32[3] - *(float *)&v108.i32[1]) * v180)
             - (float)((float)(v107.f32[0] - v107.f32[3]) * v179);
        v182 = (float)((float)(v107.f32[0] - v107.f32[3]) * *(float *)v22.i32)
             - (float)((float)(*(float *)&v22.i32[2] - *(float *)v108.i32) * v180);
        v183 = (float)((float)(*(float *)&v22.i32[2] - *(float *)v108.i32) * v179)
             - (float)((float)(*(float *)&v22.i32[3] - *(float *)&v108.i32[1]) * *(float *)v22.i32);
        v184 = sqrtf((float)(v183 * v183) + (float)((float)(v181 * v181) + (float)(v182 * v182)));
        *(float *)v22.i32 = v181 / v184;
        v185 = v182 / v184;
        *(_QWORD *)(v96 + 864) = v108.i64[0];
        *(_DWORD *)(v96 + 872) = v107.i32[3];
        *(float *)(v96 + 876) = v113;
        *(float *)(v96 + 880) = v181 / v184;
        *(float *)(v96 + 884) = v185;
        v186 = v183 / v184;
        *(float *)(v96 + 888) = v186;
        *(float *)(v96 + 892) = v35;
        *(_DWORD *)(v96 + 912) = v22.i32[2];
        *(_DWORD *)(v96 + 916) = v22.i32[3];
        *(_DWORD *)(v96 + 920) = v107.i32[0];
        *(float *)(v96 + 924) = v113;
        *(float *)(v96 + 928) = v181 / v184;
        *(float *)(v96 + 932) = v185;
        *(float *)(v96 + 936) = v186;
        *(float *)(v96 + 940) = v35;
        *(_OWORD *)(v96 + 960) = *((_OWORD *)v30 + 33);
        *(float *)(v96 + 976) = v181 / v184;
        *(float *)(v96 + 980) = v185;
        *(float *)(v96 + 984) = v186;
        *(float *)(v96 + 988) = v35;
        *(_OWORD *)(v96 + 1008) = *((_OWORD *)v30 + 33);
        *(float *)(v96 + 1024) = v181 / v184;
        *(float *)(v96 + 1028) = v185;
        *(float *)(v96 + 1032) = v186;
        *(float *)(v96 + 1036) = v35;
        a11 = *v145;
        *(float32x4_t *)(v96 + 1056) = *v145;
        *(_DWORD *)(v96 + 1072) = v22.i32[0];
        *(float *)(v96 + 1076) = v185;
        *(float *)(v96 + 1080) = v186;
        *(float *)(v96 + 1084) = v35;
        *(_QWORD *)(v96 + 1104) = v108.i64[0];
        *(_DWORD *)(v96 + 1112) = v107.i32[3];
        *(float *)(v96 + 1116) = v113;
        *(_DWORD *)(v96 + 1120) = v22.i32[0];
        *(float *)(v96 + 1124) = v185;
        *(float *)(v96 + 1128) = v186;
        *(float *)(v96 + 1132) = v35;
        v30 += 144;
        v96 += 1152;
        if (a4 < 2)
          return v30;
      }
      --a4;
    }
  }
  if (a5 == 3)
  {
    v442 = v20;
    v187 = v38 + 48 * (6 * *(_QWORD *)(a1 + 64) + (((uint64_t)a2 - v38) >> 4));
    v445 = v29 + 1.0;
    v188 = a3 + 26;
    v189 = -1.0;
    while (1)
    {
      v190 = *(v188 - 13);
      v191 = *(v188 - 12);
      v192 = fminf(fmaxf(v29 - v190, 0.0), v191);
      v193 = fminf(fmaxf(v445 - v190, 0.0), v191) - v191;
      v194 = v190 - (float)(v191 + v189);
      if (v194 <= v29)
        v195 = 0.0;
      else
        v195 = v29 - v194;
      if (v191 <= 1.0)
        v195 = v193;
      if (v29 < 0.0)
        v196 = v195;
      else
        v196 = v192;
      v197 = *(float *)(v31 + 168) + (float)(fabsf(v196) * (float)(*(float *)(v31 + 172) - *(float *)(v31 + 168)));
      v198 = v197 * v448;
      v199 = (float)(v197 * v448) * 0.5;
      if (a4 && v196 == 0.0)
      {
        v200 = *(v188 - 26);
        v201 = *(v188 - 25);
        v202 = v200 + (float)(v197 * (float)(*(v188 - 5) - v200));
        v203 = v201 + (float)(v197 * (float)(*(v188 - 4) - v201));
        v204 = v200 + (float)(v197 * (float)(*(v188 - 3) - v200));
        v205 = v201 + (float)(v197 * (float)(*(v188 - 2) - v201));
        v206 = v200 + (float)(v197 * (float)(*(v188 - 1) - v200));
        v207 = v201 + (float)(v197 * (float)(*v188 - v201));
        v208 = 1.0;
        v209 = 0.0;
        v210 = 0.0;
        v211 = 0.0;
        v212 = 1.0;
        v213 = (float)(v197 * v448) * 0.5;
        v214 = v213;
      }
      else
      {
        v215 = *(v188 - 26);
        if (a4)
        {
          v216 = __sincosf_stret((float)(v196 * (float)(*(v188 - 15) * 6.2832)) * 0.5);
          a8.n128_f32[0] = v216.__cosval;
          a17 = *(v188 - 18) * v216.__sinval;
          *(float *)v55.i32 = *(v188 - 17) * v216.__sinval;
          a7.n128_f32[0] = *(v188 - 16) * v216.__sinval;
          v217 = *(v188 - 19);
          v19.n128_f32[0] = (float)(v215 + (float)(v196 * (float)(*(v188 - 22) * v217)))
                          + (float)(v196 * (float)(v196 * *(v188 - 11)));
          v218 = *(v188 - 25);
          v219.n128_f32[0] = v196 * (float)(v217 * *(v188 - 20));
          v456 = v219;
          a10.f32[0] = (float)(v218 + (float)(v196 * (float)(v217 * *(v188 - 21))))
                     + (float)(v196 * (float)(v196 * *(v188 - 10)));
          v220 = 1.0;
        }
        else
        {
          v218 = *(v188 - 25);
          v456 = v25;
          v19 = (__n128)v442;
          v220 = *(float *)&v449;
        }
        v221 = *(v188 - 9);
        v222 = *(v188 - 8);
        v223 = (float)(v197 * (float)(*(v188 - 5) - v215)) - v221;
        v224 = (float)(v197 * (float)(*(v188 - 4) - v218)) - v222;
        v225 = *(v188 - 7);
        v226 = v199 - v225;
        v227 = *(float *)v55.i32 * (float)(v199 - v225);
        v228 = a17 * (float)(v199 - v225);
        v229 = (float)(v227 - (float)(a7.n128_f32[0] * v224)) + (float)(v227 - (float)(a7.n128_f32[0] * v224));
        v230 = (float)((float)(a7.n128_f32[0] * v223) - v228) + (float)((float)(a7.n128_f32[0] * v223) - v228);
        v231 = (float)((float)(a17 * v224) - (float)(*(float *)v55.i32 * v223))
             + (float)((float)(a17 * v224) - (float)(*(float *)v55.i32 * v223));
        v232 = (float)(v199 - v225) + (float)((float)(a17 * v230) - (float)(*(float *)v55.i32 * v229));
        v233 = (float)(a8.n128_f32[0] * v229)
             + (float)(v223 + (float)((float)(*(float *)v55.i32 * v231) - (float)(a7.n128_f32[0] * v230)));
        v234 = (float)(a8.n128_f32[0] * v230)
             + (float)(v224 + (float)((float)(a7.n128_f32[0] * v229) - (float)(a17 * v231)));
        v235 = (float)(a8.n128_f32[0] * v231) + v232;
        *(float *)&v449 = v220;
        v212 = *(v188 - 6) + (float)(v220 + (float)((float)(a8.n128_f32[0] * 0.0) + (float)(0.0 - *(v188 - 6))));
        v236 = (float)(v197 * (float)(*(v188 - 3) - v215)) - v221;
        v237 = (float)(v197 * (float)(*(v188 - 2) - v218)) - v222;
        v238 = (float)(v227 - (float)(a7.n128_f32[0] * v237)) + (float)(v227 - (float)(a7.n128_f32[0] * v237));
        v239 = (float)((float)(a7.n128_f32[0] * v236) - v228) + (float)((float)(a7.n128_f32[0] * v236) - v228);
        v240 = (float)((float)(a17 * v237) - (float)(*(float *)v55.i32 * v236))
             + (float)((float)(a17 * v237) - (float)(*(float *)v55.i32 * v236));
        v241 = (float)(a8.n128_f32[0] * v238)
             + (float)(v236 + (float)((float)(*(float *)v55.i32 * v240) - (float)(a7.n128_f32[0] * v239)));
        v242 = (float)(a8.n128_f32[0] * v239)
             + (float)(v237 + (float)((float)(a7.n128_f32[0] * v238) - (float)(a17 * v240)));
        v243 = (float)(a8.n128_f32[0] * v240)
             + (float)((float)(v199 - v225) + (float)((float)(a17 * v239) - (float)(*(float *)v55.i32 * v238)));
        v244 = (float)(v197 * (float)(*(v188 - 1) - v215)) - v221;
        v245 = (float)(v197 * (float)(*v188 - v218)) - v222;
        v246 = (float)(v227 - (float)(a7.n128_f32[0] * v245)) + (float)(v227 - (float)(a7.n128_f32[0] * v245));
        v247 = (float)((float)(a7.n128_f32[0] * v244) - v228) + (float)((float)(a7.n128_f32[0] * v244) - v228);
        v248 = (float)((float)(a17 * v245) - (float)(*(float *)v55.i32 * v244))
             + (float)((float)(a17 * v245) - (float)(*(float *)v55.i32 * v244));
        v249 = v245 + (float)((float)(a7.n128_f32[0] * v246) - (float)(a17 * v248));
        v202 = v221 + (float)(v19.n128_f32[0] + v233);
        v203 = v222 + (float)(a10.f32[0] + v234);
        v214 = v225 + (float)(v456.n128_f32[0] + v235);
        v204 = v221 + (float)(v19.n128_f32[0] + v241);
        v205 = v222 + (float)(a10.f32[0] + v242);
        v213 = v225 + (float)(v456.n128_f32[0] + v243);
        v442 = (float32x4_t)v19;
        v206 = v221
             + (float)(v19.n128_f32[0]
                     + (float)((float)(a8.n128_f32[0] * v246)
                             + (float)(v244 + (float)((float)(*(float *)v55.i32 * v248) - (float)(a7.n128_f32[0] * v247)))));
        v207 = v222 + (float)(a10.f32[0] + (float)((float)(a8.n128_f32[0] * v247) + v249));
        v199 = v225
             + (float)(v456.n128_f32[0]
                     + (float)((float)(a8.n128_f32[0] * v248)
                             + (float)(v226 + (float)((float)(a17 * v247) - (float)(*(float *)v55.i32 * v246)))));
        v250 = (float)(*(float *)v55.i32 - (float)(a7.n128_f32[0] * 0.0))
             + (float)(*(float *)v55.i32 - (float)(a7.n128_f32[0] * 0.0));
        v251 = (float)((float)(a7.n128_f32[0] * 0.0) - a17) + (float)((float)(a7.n128_f32[0] * 0.0) - a17);
        v252 = (float)((float)(a17 * 0.0) - (float)(*(float *)v55.i32 * 0.0))
             + (float)((float)(a17 * 0.0) - (float)(*(float *)v55.i32 * 0.0));
        v209 = (float)(a8.n128_f32[0] * v250)
             + (float)((float)((float)(*(float *)v55.i32 * v252) - (float)(a7.n128_f32[0] * v251)) + 0.0);
        v210 = (float)(a8.n128_f32[0] * v251)
             + (float)((float)((float)(a7.n128_f32[0] * v250) - (float)(a17 * v252)) + 0.0);
        v208 = (float)(a8.n128_f32[0] * v252)
             + (float)((float)((float)(a17 * v251) - (float)(*(float *)v55.i32 * v250)) + 1.0);
        v211 = (float)(a8.n128_f32[0] * 0.0) + 0.0;
        v25 = v456;
        v37 = v446;
        v189 = -1.0;
      }
      *v30 = v202;
      v30[1] = v203;
      v30[2] = v214;
      v30[3] = v212;
      v30[4] = v209;
      v30[5] = v210;
      v30[6] = v208;
      v30[7] = v453;
      v30[12] = v204;
      v30[13] = v205;
      v30[14] = v213;
      v30[15] = v212;
      v30[16] = v209;
      v30[17] = v210;
      v30[18] = v208;
      v30[19] = v453;
      v30[24] = v206;
      v30[25] = v207;
      v30[26] = v199;
      v30[27] = v212;
      v30[28] = v209;
      v30[29] = v210;
      v253 = v30 + 36;
      v30[30] = v208;
      v30[31] = v453;
      if (v198 <= 0.0)
      {
        v30 += 36;
        v29 = v447;
        if (a4 < 2)
          return v30;
      }
      else
      {
        v254 = v202 - (float)(v198 * v209);
        v255 = v203 - (float)(v198 * v210);
        v19 = v25;
        v256 = v214 - (float)(v198 * v208);
        v257 = v212 - (float)(v198 * v211);
        v30[36] = v254;
        v30[37] = v255;
        v30[38] = v256;
        v30[39] = v257;
        v30[40] = v209;
        v30[41] = v210;
        v30[42] = v208;
        v30[43] = v37;
        v30[48] = v206 - (float)(v198 * v209);
        v30[49] = v207 - (float)(v198 * v210);
        v30[50] = v199 - (float)(v198 * v208);
        v30[51] = v257;
        v30[52] = v209;
        v30[53] = v210;
        v30[54] = v208;
        v30[55] = v37;
        v30[60] = v204 - (float)(v198 * v209);
        v30[61] = v205 - (float)(v198 * v210);
        v30[62] = v213 - (float)(v198 * v208);
        v30[63] = v257;
        v30[64] = v209;
        v30[65] = v210;
        v30[66] = v208;
        v30[67] = v37;
        v258 = v256 - v213;
        v25 = v19;
        v259 = (float)((float)(v203 - v205) * v258) - (float)((float)(v214 - v213) * (float)(v255 - v205));
        v260 = (float)((float)(v254 - v204) * (float)(v214 - v213)) - (float)((float)(v202 - v204) * v258);
        v261 = (float)((float)(v202 - v204) * (float)(v255 - v205))
             - (float)((float)(v203 - v205) * (float)(v254 - v204));
        v262 = sqrtf((float)(v261 * v261) + (float)((float)(v259 * v259) + (float)(v260 * v260)));
        v263 = v260 / v262;
        v264 = v261 / v262;
        *(float *)v187 = v204;
        *(float *)(v187 + 4) = v205;
        *(float *)(v187 + 8) = v213;
        *(float *)(v187 + 12) = v212;
        *(float *)(v187 + 16) = v259 / v262;
        *(float *)(v187 + 20) = v263;
        *(float *)(v187 + 24) = v264;
        *(float *)(v187 + 28) = v35;
        *(float *)(v187 + 48) = v202;
        *(float *)(v187 + 52) = v203;
        *(float *)(v187 + 56) = v214;
        *(float *)(v187 + 60) = v212;
        *(float *)(v187 + 64) = v259 / v262;
        *(float *)(v187 + 68) = v263;
        *(float *)(v187 + 72) = v264;
        *(float *)(v187 + 76) = v35;
        *(_OWORD *)(v187 + 96) = *v253;
        *(float *)(v187 + 112) = v259 / v262;
        *(float *)(v187 + 116) = v263;
        *(float *)(v187 + 120) = v264;
        *(float *)(v187 + 124) = v35;
        *(_OWORD *)(v187 + 144) = *v253;
        *(float *)(v187 + 160) = v259 / v262;
        *(float *)(v187 + 164) = v263;
        *(float *)(v187 + 168) = v264;
        *(float *)(v187 + 172) = v35;
        *(_OWORD *)(v187 + 192) = *((_OWORD *)v30 + 15);
        *(float *)(v187 + 208) = v259 / v262;
        *(float *)(v187 + 212) = v263;
        *(float *)(v187 + 216) = v264;
        *(float *)(v187 + 220) = v35;
        *(float *)(v187 + 240) = v204;
        *(float *)(v187 + 244) = v205;
        *(float *)(v187 + 248) = v213;
        *(float *)(v187 + 252) = v212;
        *(float *)(v187 + 256) = v259 / v262;
        *(float *)(v187 + 260) = v263;
        *(float *)(v187 + 264) = v264;
        *(float *)(v187 + 268) = v35;
        v265 = v30[60] - v206;
        v266 = v30[61] - v207;
        v267 = v30[62] - v199;
        v268 = (float)((float)(v205 - v207) * v267) - (float)((float)(v213 - v199) * v266);
        v269 = (float)((float)(v213 - v199) * v265) - (float)((float)(v204 - v206) * v267);
        v270 = (float)((float)(v204 - v206) * v266) - (float)((float)(v205 - v207) * v265);
        v271 = sqrtf((float)(v270 * v270) + (float)((float)(v268 * v268) + (float)(v269 * v269)));
        v272 = v269 / v271;
        v273 = v270 / v271;
        *(float *)(v187 + 288) = v206;
        *(float *)(v187 + 292) = v207;
        *(float *)(v187 + 296) = v199;
        *(float *)(v187 + 300) = v212;
        *(float *)(v187 + 304) = v268 / v271;
        *(float *)(v187 + 308) = v272;
        *(float *)(v187 + 312) = v273;
        *(float *)(v187 + 316) = v35;
        *(float *)(v187 + 336) = v204;
        *(float *)(v187 + 340) = v205;
        *(float *)(v187 + 344) = v213;
        *(float *)(v187 + 348) = v212;
        *(float *)(v187 + 352) = v268 / v271;
        *(float *)(v187 + 356) = v272;
        *(float *)(v187 + 360) = v273;
        *(float *)(v187 + 364) = v35;
        *(_OWORD *)(v187 + 384) = *((_OWORD *)v30 + 15);
        *(float *)(v187 + 400) = v268 / v271;
        *(float *)(v187 + 404) = v272;
        *(float *)(v187 + 408) = v273;
        *(float *)(v187 + 412) = v35;
        *(_OWORD *)(v187 + 432) = *((_OWORD *)v30 + 15);
        *(float *)(v187 + 448) = v268 / v271;
        *(float *)(v187 + 452) = v272;
        *(float *)(v187 + 456) = v273;
        *(float *)(v187 + 460) = v35;
        *(_OWORD *)(v187 + 480) = *((_OWORD *)v30 + 12);
        *(float *)(v187 + 496) = v268 / v271;
        *(float *)(v187 + 500) = v272;
        *(float *)(v187 + 504) = v273;
        *(float *)(v187 + 508) = v35;
        *(float *)(v187 + 528) = v206;
        *(float *)(v187 + 532) = v207;
        *(float *)(v187 + 536) = v199;
        *(float *)(v187 + 540) = v212;
        *(float *)(v187 + 544) = v268 / v271;
        *(float *)(v187 + 548) = v272;
        *(float *)(v187 + 552) = v273;
        *(float *)(v187 + 556) = v35;
        v274 = v30[48] - v202;
        v275 = v30[49] - v203;
        v276 = v30[50] - v214;
        v277 = (float)((float)(v207 - v203) * v276) - (float)((float)(v199 - v214) * v275);
        v278 = (float)((float)(v199 - v214) * v274) - (float)((float)(v206 - v202) * v276);
        v279 = (float)((float)(v206 - v202) * v275) - (float)((float)(v207 - v203) * v274);
        v280 = sqrtf((float)(v279 * v279) + (float)((float)(v277 * v277) + (float)(v278 * v278)));
        v281 = v278 / v280;
        *(float *)(v187 + 576) = v202;
        *(float *)(v187 + 580) = v203;
        *(float *)(v187 + 584) = v214;
        *(float *)(v187 + 588) = v212;
        *(float *)(v187 + 592) = v277 / v280;
        *(float *)(v187 + 596) = v281;
        v282 = v279 / v280;
        *(float *)(v187 + 600) = v282;
        *(float *)(v187 + 604) = v35;
        *(float *)(v187 + 624) = v206;
        *(float *)(v187 + 628) = v207;
        *(float *)(v187 + 632) = v199;
        *(float *)(v187 + 636) = v212;
        *(float *)(v187 + 640) = v277 / v280;
        *(float *)(v187 + 644) = v281;
        *(float *)(v187 + 648) = v282;
        *(float *)(v187 + 652) = v35;
        *(_OWORD *)(v187 + 672) = *((_OWORD *)v30 + 12);
        *(float *)(v187 + 688) = v277 / v280;
        *(float *)(v187 + 692) = v281;
        *(float *)(v187 + 696) = v282;
        *(float *)(v187 + 700) = v35;
        *(_OWORD *)(v187 + 720) = *((_OWORD *)v30 + 12);
        *(float *)(v187 + 736) = v277 / v280;
        *(float *)(v187 + 740) = v281;
        *(float *)(v187 + 744) = v282;
        *(float *)(v187 + 748) = v35;
        *(_OWORD *)(v187 + 768) = *v253;
        *(float *)(v187 + 784) = v277 / v280;
        *(float *)(v187 + 788) = v281;
        *(float *)(v187 + 792) = v282;
        *(float *)(v187 + 796) = v35;
        *(float *)(v187 + 816) = v202;
        *(float *)(v187 + 820) = v203;
        *(float *)(v187 + 824) = v214;
        *(float *)(v187 + 828) = v212;
        *(float *)(v187 + 832) = v277 / v280;
        *(float *)(v187 + 836) = v281;
        *(float *)(v187 + 840) = v282;
        *(float *)(v187 + 844) = v35;
        v30 += 72;
        v187 += 864;
        v29 = v447;
        if (a4 < 2)
          return v30;
      }
      v188 += 27;
      --a4;
    }
  }
  v56 = a5 - 1;
  if (a5 != 1)
  {
    v283 = 3 * a5;
    v284 = 6 * a5;
    v285 = v38 + 48 * (0xAAAAAAAAAAAAAAABLL * (((uint64_t)a2 - v38) >> 4) + *(_QWORD *)(v31 + 64) * v284);
    v435 = v35;
    v436 = v29 + 1.0;
    v286 = 8 * (int)(a5 - 4) + 116;
    v287 = v56 - 1;
    v288 = v28 + 26;
    v289 = 6 * a5;
    v290 = a12.f32[0];
    v433 = v56 - 1;
    v434 = v31;
    v431 = a5 - 1;
    v432 = v289;
    while (1)
    {
      v291 = v28[13];
      v292 = v28[14];
      v293 = fminf(fmaxf(v29 - v291, 0.0), v292);
      v294 = fminf(fmaxf(v436 - v291, 0.0), v292) - v292;
      v295 = v291 - (float)(v292 + -1.0);
      if (v295 <= v29)
        v296 = 0.0;
      else
        v296 = v29 - v295;
      if (v292 <= 1.0)
        v296 = v294;
      if (v29 < 0.0)
        v297 = v296;
      else
        v297 = v293;
      v298 = *(float *)(v31 + 168) + (float)(fabsf(v297) * (float)(*(float *)(v31 + 172) - *(float *)(v31 + 168)));
      v299 = (float)(v298 * v448) * 0.5;
      v300 = a4 - 1;
      if (a4 && v297 == 0.0)
      {
        v301 = *v28 + (float)(v298 * (float)(v28[21] - *v28));
        v302 = v28[1] + (float)(v298 * (float)(v28[22] - v28[1]));
        v303 = 1.0;
        v304 = 0.0;
        v305 = 0.0;
        v437 = 0.0;
        v306 = (float)(v298 * v448) * 0.5;
        v307 = 1.0;
        a17 = 0.0;
        v55.i32[0] = 0;
        a7.n128_u32[0] = 0;
        v18.i32[0] = 1.0;
        v24.i32[0] = 0;
        a10.i32[0] = 0;
        v21.n128_u32[0] = 0;
        v451 = 1.0;
      }
      else
      {
        if (a4)
        {
          v452 = a4;
          v308 = v284;
          v309 = v288;
          v310 = __sincosf_stret((float)(v297 * (float)(v28[11] * 6.2832)) * 0.5);
          a8.n128_f32[0] = v310.__cosval;
          v289 = v432;
          v287 = v433;
          v288 = v309;
          v284 = v308;
          v31 = v434;
          a4 = v452;
          LODWORD(v56) = v431;
          a17 = v28[8] * v310.__sinval;
          *(float *)v55.i32 = v28[9] * v310.__sinval;
          a7.n128_f32[0] = v28[10] * v310.__sinval;
          v311 = v28[7];
          v20.f32[0] = (float)(*v28 + (float)(v297 * (float)(v28[4] * v311))) + (float)(v297 * (float)(v297 * v28[15]));
          v25.n128_f32[0] = v297 * (float)(v311 * v28[6]);
          a10.f32[0] = (float)(v28[1] + (float)(v297 * (float)(v311 * v28[5])))
                     + (float)(v297 * (float)(v297 * v28[16]));
          v290 = 1.0;
        }
        v451 = v290;
        v312 = v28[17];
        v313 = v28[18];
        v314 = v28[19];
        v315 = (float)(*(float *)v55.i32 * (float)(v299 - v314)) - (float)(a7.n128_f32[0] * (float)(0.0 - v313));
        v316 = (float)(a7.n128_f32[0] * (float)(0.0 - v312)) - (float)(a17 * (float)(v299 - v314));
        v317 = (float)(a17 * (float)(0.0 - v313)) - (float)(*(float *)v55.i32 * (float)(0.0 - v312));
        v318 = v315 + v315;
        v319 = v316 + v316;
        v320 = v317 + v317;
        v301 = v312
             + (float)(v20.f32[0]
                     + (float)((float)(a8.n128_f32[0] * v318)
                             + (float)((float)(0.0 - v312)
                                     + (float)((float)(*(float *)v55.i32 * v320) - (float)(a7.n128_f32[0] * v319)))));
        v302 = v313
             + (float)(a10.f32[0]
                     + (float)((float)(a8.n128_f32[0] * v319)
                             + (float)((float)(0.0 - v313)
                                     + (float)((float)(a7.n128_f32[0] * v318) - (float)(a17 * v320)))));
        v306 = v314
             + (float)(v25.n128_f32[0]
                     + (float)((float)(a8.n128_f32[0] * v320)
                             + (float)((float)(v299 - v314)
                                     + (float)((float)(a17 * v319) - (float)(*(float *)v55.i32 * v318)))));
        v307 = v28[20] + (float)(v290 + (float)((float)(a8.n128_f32[0] * 0.0) + (float)(0.0 - v28[20])));
        v321 = (float)(*(float *)v55.i32 - (float)(a7.n128_f32[0] * 0.0))
             + (float)(*(float *)v55.i32 - (float)(a7.n128_f32[0] * 0.0));
        v322 = (float)((float)(a7.n128_f32[0] * 0.0) - a17) + (float)((float)(a7.n128_f32[0] * 0.0) - a17);
        v323 = (float)((float)(a17 * 0.0) - (float)(*(float *)v55.i32 * 0.0))
             + (float)((float)(a17 * 0.0) - (float)(*(float *)v55.i32 * 0.0));
        v304 = (float)(a8.n128_f32[0] * v321)
             + (float)((float)((float)(*(float *)v55.i32 * v323) - (float)(a7.n128_f32[0] * v322)) + 0.0);
        v305 = (float)(a8.n128_f32[0] * v322)
             + (float)((float)((float)(a7.n128_f32[0] * v321) - (float)(a17 * v323)) + 0.0);
        v303 = (float)(a8.n128_f32[0] * v323)
             + (float)((float)((float)(a17 * v322) - (float)(*(float *)v55.i32 * v321)) + 1.0);
        v437 = (float)(a8.n128_f32[0] * 0.0) + 0.0;
        v18 = (float32x4_t)a8;
        v21 = v25;
        v24 = v20;
      }
      v457 = v301;
      *v30 = v301;
      v443 = v302;
      v30[1] = v302;
      v438 = v306;
      v440 = v307;
      v30[2] = v306;
      v30[3] = v307;
      v30[4] = v304;
      v30[5] = v305;
      v30[6] = v303;
      v30[7] = v453;
      v324 = v28[17];
      v325 = v28[18];
      v326 = (float)(v298 * (float)(v28[21] - *v28)) - v324;
      v327 = (float)(v298 * (float)(v28[22] - v28[1])) - v325;
      v328 = v28[19];
      v329 = v28[20];
      v330 = (float)((float)(*(float *)v55.i32 * (float)(v299 - v328)) - (float)(a7.n128_f32[0] * v327))
           + (float)((float)(*(float *)v55.i32 * (float)(v299 - v328)) - (float)(a7.n128_f32[0] * v327));
      v331 = (float)((float)(a7.n128_f32[0] * v326) - (float)(a17 * (float)(v299 - v328)))
           + (float)((float)(a7.n128_f32[0] * v326) - (float)(a17 * (float)(v299 - v328)));
      v332 = (float)((float)(a17 * v327) - (float)(*(float *)v55.i32 * v326))
           + (float)((float)(a17 * v327) - (float)(*(float *)v55.i32 * v326));
      v333 = (float)(v298 * v448) * 0.5;
      v334 = v18.f32[0] * 0.0;
      v30[12] = v324
              + (float)(v24.f32[0]
                      + (float)((float)(v18.f32[0] * v330)
                              + (float)(v326
                                      + (float)((float)(*(float *)v55.i32 * v332) - (float)(a7.n128_f32[0] * v331)))));
      v30[13] = v325
              + (float)(a10.f32[0]
                      + (float)((float)(v18.f32[0] * v331)
                              + (float)(v327 + (float)((float)(a7.n128_f32[0] * v330) - (float)(a17 * v332)))));
      v30[14] = v328
              + (float)(v21.n128_f32[0]
                      + (float)((float)(v18.f32[0] * v332)
                              + (float)((float)(v299 - v328)
                                      + (float)((float)(a17 * v331) - (float)(*(float *)v55.i32 * v330)))));
      v30[15] = v329 + (float)(v451 + (float)((float)(v18.f32[0] * 0.0) + (float)(0.0 - v329)));
      v30[16] = v304;
      v30[17] = v305;
      v30[18] = v303;
      v30[19] = v453;
      v335 = v28[17];
      v336 = v28[18];
      v337 = (float)(v298 * (float)(v28[23] - *v28)) - v335;
      v338 = (float)(v298 * (float)(v28[24] - v28[1])) - v336;
      v339 = v28[19];
      v340 = v28[20];
      v341 = (float)((float)(*(float *)v55.i32 * (float)(v299 - v339)) - (float)(a7.n128_f32[0] * v338))
           + (float)((float)(*(float *)v55.i32 * (float)(v299 - v339)) - (float)(a7.n128_f32[0] * v338));
      v342 = (float)((float)(a7.n128_f32[0] * v337) - (float)(a17 * (float)(v299 - v339)))
           + (float)((float)(a7.n128_f32[0] * v337) - (float)(a17 * (float)(v299 - v339)));
      v343 = (float)((float)(a17 * v338) - (float)(*(float *)v55.i32 * v337))
           + (float)((float)(a17 * v338) - (float)(*(float *)v55.i32 * v337));
      v344 = v21;
      v21 = a7;
      v30[24] = v335
              + (float)(v24.f32[0]
                      + (float)((float)(v18.f32[0] * v341)
                              + (float)(v337
                                      + (float)((float)(*(float *)v55.i32 * v343) - (float)(a7.n128_f32[0] * v342)))));
      v30[25] = v336
              + (float)(a10.f32[0]
                      + (float)((float)(v18.f32[0] * v342)
                              + (float)(v338 + (float)((float)(a7.n128_f32[0] * v341) - (float)(a17 * v343)))));
      v30[26] = v339
              + (float)(v344.n128_f32[0]
                      + (float)((float)(v18.f32[0] * v343)
                              + (float)((float)(v299 - v339)
                                      + (float)((float)(a17 * v342) - (float)(*(float *)v55.i32 * v341)))));
      v30[27] = v340 + (float)(v451 + (float)((float)(v18.f32[0] * 0.0) + (float)(0.0 - v340)));
      v30[28] = v304;
      v30[29] = v305;
      v30[30] = v303;
      v30[31] = v453;
      v25 = v344;
      v20 = v24;
      if (v56 < 2)
      {
        v363 = 1;
        v364 = v446;
        v29 = v447;
        v290 = v451;
        a8 = (__n128)v18;
        v365 = v298 * v448;
        v366 = v457;
        v348 = v443;
        v367 = v438;
        v349 = v440;
      }
      else
      {
        v345 = 2;
        v346 = v288;
        v347 = v287;
        a8 = (__n128)v18;
        v348 = v443;
        v349 = v440;
        do
        {
          v350 = &v30[12 * v345 + 12];
          *v350 = v457;
          v350[1] = v443;
          v350[2] = v438;
          v350[3] = v440;
          v350[4] = v304;
          v350[5] = v305;
          v350[6] = v303;
          v351 = *(_OWORD *)&v30[12 * v345];
          v352 = &v30[12 * v345 + 24];
          v350[7] = v453;
          *(_OWORD *)v352 = v351;
          v352[4] = v304;
          v352[5] = v305;
          v352[6] = v303;
          v352[7] = v453;
          *(float *)&v351 = *(v346 - 1) - *v28;
          v353 = *v346;
          v346 += 2;
          v354 = v28[17];
          v355 = v28[18];
          *(float *)&v351 = (float)(v298 * *(float *)&v351) - v354;
          v356 = v28[19];
          v357 = (float)(v298 * (float)(v353 - v28[1])) - v355;
          v18 = a10;
          v21 = v25;
          v358 = (float)((float)(*(float *)v55.i32 * (float)(v333 - v356)) - (float)(a7.n128_f32[0] * v357))
               + (float)((float)(*(float *)v55.i32 * (float)(v333 - v356)) - (float)(a7.n128_f32[0] * v357));
          v359 = (float)((float)(a7.n128_f32[0] * *(float *)&v351) - (float)(a17 * (float)(v333 - v356)))
               + (float)((float)(a7.n128_f32[0] * *(float *)&v351) - (float)(a17 * (float)(v333 - v356)));
          v360 = (float)((float)(a17 * v357) - (float)(*(float *)v55.i32 * *(float *)&v351))
               + (float)((float)(a17 * v357) - (float)(*(float *)v55.i32 * *(float *)&v351));
          *(float *)&v351 = v354
                          + (float)(v20.f32[0]
                                  + (float)((float)(a8.n128_f32[0] * v358)
                                          + (float)(*(float *)&v351
                                                  + (float)((float)(*(float *)v55.i32 * v360)
                                                          - (float)(a7.n128_f32[0] * v359)))));
          v361 = v28[20] + (float)(v451 + (float)(v334 + (float)(0.0 - v28[20])));
          v345 += 3;
          v362 = &v30[12 * v345];
          *(_DWORD *)v362 = v351;
          v362[1] = v355
                  + (float)(a10.f32[0]
                          + (float)((float)(a8.n128_f32[0] * v359)
                                  + (float)(v357 + (float)((float)(a7.n128_f32[0] * v358) - (float)(a17 * v360)))));
          v362[3] = v361;
          v362[2] = v356
                  + (float)(v25.n128_f32[0]
                          + (float)((float)(a8.n128_f32[0] * v360)
                                  + (float)((float)(v333 - v356)
                                          + (float)((float)(a17 * v359) - (float)(*(float *)v55.i32 * v358)))));
          v362[4] = v304;
          v362[5] = v305;
          v362[6] = v303;
          v362[7] = v453;
          --v347;
        }
        while (v347);
        v363 = v56;
        v364 = v446;
        v29 = v447;
        v290 = v451;
        v35 = v435;
        v365 = v298 * v448;
        v366 = v457;
        v367 = v438;
      }
      v368 = 3 * v363;
      v369 = &v30[12 * v368];
      *v369 = v366;
      v369[1] = v348;
      v369[2] = v367;
      v369[3] = v349;
      v369[4] = v304;
      v369[5] = v305;
      v369[6] = v303;
      v369[7] = v453;
      v370 = &v30[12 * v368 + 12];
      *(_OWORD *)v370 = *(_OWORD *)&v30[12 * v368 - 12];
      v370[4] = v304;
      v370[5] = v305;
      v370[6] = v303;
      v370[7] = v453;
      v371 = &v30[12 * v368 + 24];
      *(_OWORD *)v371 = *((_OWORD *)v30 + 3);
      v371[4] = v304;
      v371[5] = v305;
      v371[6] = v303;
      v371[7] = v453;
      v372 = &v30[12 * v283];
      if (v365 == 0.0)
      {
        v30 += 12 * v283;
        if (a4 < 2)
          return v30;
      }
      else
      {
        v373 = v365 * v304;
        v374 = v365 * v305;
        v375 = v365 * v303;
        v376 = v365 * v437;
        *v372 = v366 - (float)(v365 * v304);
        v372[1] = v348 - (float)(v365 * v305);
        v372[2] = v367 - (float)(v365 * v303);
        v372[3] = v349 - (float)(v365 * v437);
        v377 = &v30[12 * v283];
        v377[4] = v304;
        v377[5] = v305;
        v377[6] = v303;
        v377[7] = v364;
        v378 = v30[24] - (float)(v365 * v304);
        v379 = v30[25] - (float)(v365 * v305);
        v380 = v30[26] - (float)(v365 * v303);
        v381 = v30[27] - v376;
        v372[12] = v378;
        v372[13] = v379;
        v372[14] = v380;
        v372[15] = v381;
        v372[16] = v304;
        v372[17] = v305;
        v372[18] = v303;
        v372[19] = v364;
        v382 = v30[13] - v374;
        v383 = v30[14] - v375;
        v384 = v30[15] - v376;
        v372[24] = v30[12] - v373;
        v372[25] = v382;
        v372[26] = v383;
        v372[27] = v384;
        v372[28] = v304;
        v372[29] = v305;
        v372[30] = v303;
        v372[31] = v364;
        if (v56 < 2)
        {
          v395 = 1;
        }
        else
        {
          v385 = 5;
          v386 = v287;
          do
          {
            v387 = &v372[12 * v385 - 24];
            *(_OWORD *)v387 = *(_OWORD *)v372;
            v387[4] = v304;
            v387[5] = v305;
            v387[6] = v303;
            v387[7] = v364;
            v388 = &v30[12 * v385];
            v389 = *v388 - v373;
            v390 = v388[1] - v374;
            v391 = v388[2] - v375;
            v392 = v388[3] - v376;
            v393 = &v372[12 * v385 - 12];
            *v393 = v389;
            v393[1] = v390;
            v393[2] = v391;
            v393[3] = v392;
            v393[4] = v304;
            v393[5] = v305;
            v393[6] = v303;
            v393[7] = v364;
            v394 = &v372[12 * v385];
            *(_OWORD *)v394 = *(_OWORD *)&v372[12 * v385 - 48];
            v394[4] = v304;
            v394[5] = v305;
            v394[6] = v303;
            v394[7] = v364;
            v385 += 3;
            --v386;
          }
          while (v386);
          v395 = v56;
        }
        v396 = 3 * v395;
        v397 = &v372[12 * v396];
        *(_OWORD *)v397 = *(_OWORD *)v372;
        v397[4] = v304;
        v397[5] = v305;
        v397[6] = v303;
        v397[7] = v364;
        v398 = &v372[12 * v396 + 12];
        *(_OWORD *)v398 = *((_OWORD *)v372 + 6);
        v398[4] = v304;
        v398[5] = v305;
        v398[6] = v303;
        v398[7] = v364;
        v399 = &v372[12 * v396 + 24];
        *(_OWORD *)v399 = *(_OWORD *)&v372[12 * v396 - 24];
        v399[4] = v304;
        v399[5] = v305;
        v399[6] = v303;
        v399[7] = v364;
        if (a5)
        {
          v400 = 0;
          v401 = 2;
          do
          {
            v402 = &v30[12 * v401 - 12];
            v403 = &v30[12 * v401];
            v404 = v403[1];
            v405 = *v402 - *v403;
            v406 = v403[2];
            v407 = v402[1] - v404;
            v408 = &v372[12 * v401];
            v409 = *v408 - *v403;
            v410 = v408[1] - v404;
            v411 = v402[2] - v406;
            v412 = v408[2] - v406;
            v413 = (float)(v407 * v412) - (float)(v411 * v410);
            v414 = (float)(v411 * v409) - (float)(v405 * v412);
            v415 = (float)(v405 * v410) - (float)(v407 * v409);
            v416 = sqrtf((float)(v415 * v415) + (float)((float)(v413 * v413) + (float)(v414 * v414)));
            v417 = v413 / v416;
            v418 = v414 / v416;
            v419 = v415 / v416;
            v420 = v285 + 48 * v400;
            *(_OWORD *)v420 = *(_OWORD *)v403;
            *(float *)(v420 + 16) = v413 / v416;
            *(float *)(v420 + 20) = v418;
            *(float *)(v420 + 24) = v419;
            *(float *)(v420 + 28) = v35;
            v421 = v285 + 48 * (v400 + 1);
            v422 = *(_OWORD *)v402;
            *(float *)(v421 + 16) = v417;
            *(float *)(v421 + 20) = v418;
            *(float *)(v421 + 24) = v419;
            *(float *)(v421 + 28) = v35;
            *(_OWORD *)v421 = v422;
            v423 = v285 + 48 * (v400 + 2);
            v424 = *(_OWORD *)v408;
            *(float *)(v423 + 16) = v417;
            *(float *)(v423 + 20) = v418;
            *(_OWORD *)v423 = v424;
            *(float *)(v423 + 24) = v419;
            *(float *)(v423 + 28) = v35;
            v425 = v285 + 48 * (v400 + 3);
            *(_OWORD *)v425 = *(_OWORD *)v408;
            *(float *)(v425 + 16) = v417;
            *(float *)(v425 + 20) = v418;
            *(float *)(v425 + 24) = v419;
            *(float *)(v425 + 28) = v35;
            v426 = v285 + 48 * (v400 + 4);
            v427 = *(_OWORD *)&v372[12 * v401 - 12];
            *(float *)(v426 + 16) = v417;
            *(float *)(v426 + 20) = v418;
            *(float *)(v426 + 24) = v419;
            *(float *)(v426 + 28) = v35;
            *(_OWORD *)v426 = v427;
            v428 = *(_OWORD *)v403;
            v429 = v285 + 48 * (v400 + 5);
            *(float *)(v429 + 16) = v417;
            *(float *)(v429 + 20) = v418;
            *(_OWORD *)v429 = v428;
            *(float *)(v429 + 24) = v419;
            *(float *)(v429 + 28) = v35;
            v400 += 6;
            v401 += 3;
          }
          while (v289 != v400);
        }
        v30 = &v372[12 * v283];
        v285 += 48 * v284;
        if (a4 < 2)
          return v30;
      }
      v28 = (float *)((char *)v28 + v286);
      v288 = (float *)((char *)v288 + v286);
      a4 = v300;
    }
  }
  v57 = v29 + 1.0;
  v30 = a2 + 12;
  for (j = a3 + 11; ; j += 23)
  {
    v59 = j[2];
    v60 = j[3];
    v61 = fminf(fmaxf(v447 - v59, 0.0), v60);
    v62 = fminf(fmaxf(v57 - v59, 0.0), v60) - v60;
    v63 = v59 - (float)(v60 + -1.0);
    if (v63 <= v447)
      v64 = 0.0;
    else
      v64 = v447 - v63;
    if (v60 <= 1.0)
      v64 = v62;
    v65 = v447 < 0.0 ? v64 : v61;
    v66 = (float)((float)(*(float *)(v31 + 168)
                        + (float)(fabsf(v65) * (float)(*(float *)(v31 + 172) - *(float *)(v31 + 168))))
                * v448)
        * 0.5;
    if (a4 && v65 == 0.0)
    {
      v67 = j[10];
      v68 = j[11];
      v69 = 1.0;
      v70 = 0.0;
      v71 = 0.0;
      v72 = 1.0;
    }
    else
    {
      v73 = v20;
      v74 = *(j - 11);
      if (a4)
      {
        v75 = __sincosf_stret((float)(v65 * (float)(*j * 6.2832)) * 0.5);
        a8.n128_f32[0] = v75.__cosval;
        a17 = *(j - 3) * v75.__sinval;
        *(float *)v55.i32 = *(j - 2) * v75.__sinval;
        a7.n128_f32[0] = *(j - 1) * v75.__sinval;
        v76 = *(j - 4);
        v73.f32[0] = (float)(v74 + (float)(v65 * (float)(*(j - 7) * v76))) + (float)(v65 * (float)(v65 * j[4]));
        v77 = *(j - 10);
        v25.n128_f32[0] = v65 * (float)(v76 * *(j - 5));
        a10.f32[0] = (float)(v77 + (float)(v65 * (float)(v76 * *(j - 6)))) + (float)(v65 * (float)(v65 * j[5]));
        v78 = 1.0;
      }
      else
      {
        v77 = *(j - 10);
        v78 = *(float *)&v449;
      }
      v79 = j[6];
      v80 = j[7];
      v81 = (float)(j[10] - v74) - v79;
      v82 = (float)(j[11] - v77) - v80;
      v83 = j[8];
      v84 = (float)((float)(*(float *)v55.i32 * (float)(v66 - v83)) - (float)(a7.n128_f32[0] * v82))
          + (float)((float)(*(float *)v55.i32 * (float)(v66 - v83)) - (float)(a7.n128_f32[0] * v82));
      v85 = (float)((float)(a7.n128_f32[0] * v81) - (float)(a17 * (float)(v66 - v83)))
          + (float)((float)(a7.n128_f32[0] * v81) - (float)(a17 * (float)(v66 - v83)));
      v86 = (float)((float)(a17 * v82) - (float)(*(float *)v55.i32 * v81))
          + (float)((float)(a17 * v82) - (float)(*(float *)v55.i32 * v81));
      v87 = (float)(a17 * v85) - (float)(*(float *)v55.i32 * v84);
      v88 = v73.f32[0]
          + (float)((float)(a8.n128_f32[0] * v84)
                  + (float)(v81 + (float)((float)(*(float *)v55.i32 * v86) - (float)(a7.n128_f32[0] * v85))));
      v89 = a10.f32[0]
          + (float)((float)(a8.n128_f32[0] * v85)
                  + (float)(v82 + (float)((float)(a7.n128_f32[0] * v84) - (float)(a17 * v86))));
      *(float *)&v449 = v78;
      v67 = v79 + v88;
      v68 = v80 + v89;
      v66 = v83 + (float)(v25.n128_f32[0] + (float)((float)(a8.n128_f32[0] * v86) + (float)((float)(v66 - v83) + v87)));
      v72 = j[9] + (float)(v78 + (float)((float)(a8.n128_f32[0] * 0.0) + (float)(0.0 - j[9])));
      v90 = (float)(*(float *)v55.i32 - (float)(a7.n128_f32[0] * 0.0))
          + (float)(*(float *)v55.i32 - (float)(a7.n128_f32[0] * 0.0));
      v91 = (float)((float)(a7.n128_f32[0] * 0.0) - a17) + (float)((float)(a7.n128_f32[0] * 0.0) - a17);
      v92 = (float)((float)(a17 * 0.0) - (float)(*(float *)v55.i32 * 0.0))
          + (float)((float)(a17 * 0.0) - (float)(*(float *)v55.i32 * 0.0));
      v93 = (float)((float)(a7.n128_f32[0] * v90) - (float)(a17 * v92)) + 0.0;
      v94 = (float)((float)(a17 * v91) - (float)(*(float *)v55.i32 * v90)) + 1.0;
      v95 = a8.n128_f32[0] * v92;
      v70 = (float)(a8.n128_f32[0] * v90)
          + (float)((float)((float)(*(float *)v55.i32 * v92) - (float)(a7.n128_f32[0] * v91)) + 0.0);
      v71 = (float)(a8.n128_f32[0] * v91) + v93;
      v69 = v95 + v94;
      v20 = v73;
    }
    *(v30 - 12) = v67;
    *(v30 - 11) = v68;
    *(v30 - 10) = v66;
    *(v30 - 9) = v72;
    *(v30 - 8) = v70;
    *(v30 - 7) = v71;
    *(v30 - 6) = v69;
    *(v30 - 5) = v453;
    if (a4 < 2)
      break;
    v30 += 12;
    --a4;
  }
  return v30;
}

float *HGFractured::Effect::apply_polar(float *this, HGFractured::Effect *a2, __n128 a3, int a4, __n128 a5, double a6, float32x4_t a7, float32x4_t a8, float32x4_t a9, double a10, double a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  int v16;
  float v17;
  uint64_t v18;
  unint64_t v19;
  float *v20;
  float *v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  __float2 v32;
  __float2 v33;
  float v34;
  __int32 v35;
  unsigned __int32 v36;
  unsigned __int32 v37;
  float v38;

  if (*((_QWORD *)this + 8))
  {
    v16 = (int)a2;
    v17 = a3.n128_f32[0];
    v18 = (uint64_t)this;
    v19 = 0;
    v20 = *(float **)&this[2 * ((_DWORD)a2 != 0) + 24];
    v21 = (float *)*((_QWORD *)this + 7);
    v38 = a3.n128_f32[0] + 1.0;
    do
    {
      v23 = *v21;
      v24 = v21[1];
      v26 = v21[13];
      v25 = v21[14];
      if (v17 >= 0.0)
      {
        v28 = fminf(fmaxf(v17 - v26, 0.0), v25);
        if (v28 != 0.0)
          goto LABEL_13;
      }
      else if (v25 <= 1.0)
      {
        v28 = fminf(fmaxf(v38 - v26, 0.0), v25) - v25;
        if (v28 != 0.0)
          goto LABEL_13;
      }
      else
      {
        v27 = v26 - (float)(v25 + -1.0);
        if (v27 > v17)
        {
          v28 = v17 - v27;
          if ((float)(v17 - v27) != 0.0)
          {
LABEL_13:
            v29 = v21[7];
            v30 = sqrtf((float)(v23 * v23) + (float)(v24 * v24)) + (float)(v28 * (float)(v21[4] * v29));
            v31 = atan2f(v21[1], *v21);
            v32 = __sincosf_stret(v31 + (float)(v28 * (float)(v29 * v21[5])));
            v22 = v28 * (float)(v29 * v21[6]);
            v23 = (float)(v28 * (float)(v28 * v21[15])) + (float)(v30 * v32.__cosval);
            v24 = (float)(v30 * v32.__sinval) + (float)(v28 * (float)(v28 * v21[16]));
            v33 = __sincosf_stret((float)(v28 * (float)(v21[11] * 6.2832)) * 0.5);
            a5.n128_f32[0] = v33.__cosval;
            *(float *)&a6 = v21[8] * v33.__sinval;
            a7.f32[0] = v21[9] * v33.__sinval;
            a8.f32[0] = v21[10] * v33.__sinval;
            goto LABEL_4;
          }
        }
      }
      a5.n128_u32[0] = 1.0;
      LODWORD(a6) = 0;
      a7.i32[0] = 0;
      a8.i32[0] = 0;
      v22 = 0.0;
LABEL_4:
      a3.n128_u32[0] = *(_DWORD *)(v18 + 136);
      v36 = a8.i32[0];
      v37 = a5.n128_u32[0];
      a5.n128_u32[0] = 0;
      a9.i32[0] = 1.0;
      v34 = *(float *)&a6;
      v35 = a7.i32[0];
      *(float *)&a6 = v23;
      a7.f32[0] = v24;
      a8.f32[0] = v22;
      this = emit(v18, v20, v21, 0, *(_DWORD *)(v18 + 124), v16, a3, a5, a6, a7, a8, a9, a15, a16, a10, a11, v34, v35, v36,
               v37);
      v20 = this;
      v21 += 2 * *(int *)(v18 + 124) + 21;
      ++v19;
    }
    while (v19 < *(_QWORD *)(v18 + 64));
  }
  return this;
}

float *apply_whirl(float *result, float a2, int a3)
{
  uint64_t v4;
  unint64_t v5;
  float *v6;
  uint64_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float32x2_t v17;
  double v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  __float2 v24;
  double v25;
  double v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  double v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  __n128 v37;
  __n128 v38;
  uint64_t v39;
  uint64_t v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  BOOL v47;
  float v48;
  float v49;
  double v50;
  float v51;
  __float2 v52;
  float v53;
  float32x2_t v54;
  float v60;
  float v61;
  float v62;
  float v64;
  float32x2_t v65;
  unsigned int v66;

  if (*((_QWORD *)result + 8))
  {
    v4 = (uint64_t)result;
    v5 = 0;
    v6 = *(float **)&result[2 * (a3 != 0) + 24];
    v7 = *((_QWORD *)result + 7);
    v8 = 1.0;
    v9 = 0.5;
    v10 = 0.25;
    do
    {
      v41 = *(float *)v7;
      v66 = *(_DWORD *)(v7 + 4);
      v42 = *(float *)(v7 + 52);
      v43 = *(float *)(v7 + 56);
      v44 = fminf(fmaxf(a2 - v42, 0.0), v43);
      v45 = fminf(fmaxf((float)(a2 + 1.0) - v42, 0.0), v43) - v43;
      v46 = v42 - (float)(v43 + -1.0);
      v47 = v46 > a2;
      v48 = a2 - v46;
      if (!v47)
        v48 = 0.0;
      if (v43 <= v8)
        v48 = v45;
      if (a2 < 0.0)
        v49 = v48;
      else
        v49 = v44;
      v50 = -(*(float *)(v7 + 28) * -3.14159265 * v49);
      if (a3 >= 0)
        v50 = *(float *)(v7 + 28) * -3.14159265 * v49;
      v51 = v50;
      v52 = __sincosf_stret(v51 * v9);
      v53 = *(float *)(v7 + 16);
      v54 = *(float32x2_t *)(v7 + 20);
      if (v49 < v10)
      {
        v11 = v10 - v49;
        if (v49 < 0.125)
          v11 = v49;
        v12 = (float)(v11 * 0.1) * 8.0;
        v13 = fminf(fmaxf(v49 * 4.0, 0.0), v8);
        v14 = (float)(v13 * v13) * (float)(3.0 - (float)(v13 + v13));
        v64 = v14 + (float)(v8 - v14);
        v15 = v14 * v10;
        v16 = (float)((float)(v53 * v14) + (float)(v41 * (float)(v8 - v14)))
            - (float)(v12 + (float)((float)(v14 * v10) * (float)((float)(v53 * v14) + (float)(v41 * (float)(v8 - v14)))));
        v17 = vadd_f32(vmul_n_f32(v54, v14), vmul_n_f32((float32x2_t)v66, v8 - v14));
      }
      else
      {
        if (v49 < 0.75)
        {
          v16 = v53 + (float)(v53 * -0.25);
          __asm { FMOV            V1.2S, #-0.25 }
          v65 = vadd_f32(v54, vmul_f32(v54, _D1));
          v18 = v41 * 3.14159265;
          v64 = 1.0;
          goto LABEL_7;
        }
        v60 = v8 - v49;
        if (v49 < 0.875)
          v60 = v49 + -0.75;
        v61 = fminf(fmaxf((float)(v49 + -0.75) * 4.0, 0.0), v8);
        v62 = (float)(v61 * v61) * (float)(3.0 - (float)(v61 + v61));
        v64 = v62 + (float)(v8 - v62);
        v15 = (float)(v8 - v62) * v10;
        v16 = (float)((float)(v41 * v62) + (float)(v53 * (float)(v8 - v62)))
            - (float)((float)((float)(v60 * 0.1) * 8.0)
                    + (float)(v15 * (float)((float)(v41 * v62) + (float)(v53 * (float)(v8 - v62)))));
        v17 = vadd_f32(vmul_n_f32((float32x2_t)v66, v62), vmul_n_f32(v54, v8 - v62));
      }
      v65 = vsub_f32(v17, vmul_n_f32(v17, v15));
      v18 = v41 * 3.14159265 * *(float *)(v7 + 44);
LABEL_7:
      v20 = *(float *)(v7 + 32);
      v19 = *(float *)(v7 + 36);
      v21 = *(float *)(v7 + 40);
      v22 = v21 * v52.__sinval;
      v23 = v18 * v52.__cosval;
      v24 = __sincosf_stret(v23 * 0.5);
      *(float *)&v25 = v21 * v24.__sinval;
      *(float *)&v26 = v19 * v24.__sinval;
      v27 = vmuls_lane_f32(v19 * v52.__sinval, v65, 1);
      v28 = vmuls_lane_f32(v20 * v52.__sinval, v65, 1);
      v29 = (float)(v27 - (float)(v22 * v65.f32[0])) + (float)(v27 - (float)(v22 * v65.f32[0]));
      v30 = (float)((float)(v22 * v16) - v28) + (float)((float)(v22 * v16) - v28);
      v31 = (float)((float)((float)(v20 * v52.__sinval) * v65.f32[0]) - (float)((float)(v19 * v52.__sinval) * v16))
          + (float)((float)((float)(v20 * v52.__sinval) * v65.f32[0]) - (float)((float)(v19 * v52.__sinval) * v16));
      v32 = v65.f32[1]
          + (float)((float)((float)(v20 * v52.__sinval) * v30) - (float)((float)(v19 * v52.__sinval) * v29));
      *(float *)&v33 = (float)(v52.__cosval * v29)
                     + (float)(v16
                             + (float)((float)((float)(v19 * v52.__sinval) * v31)
                                     - (float)((float)(v21 * v52.__sinval) * v30)));
      v34.f32[0] = (float)(v52.__cosval * v30)
                 + (float)(v65.f32[0]
                         + (float)((float)((float)(v21 * v52.__sinval) * v29)
                                 - (float)((float)(v20 * v52.__sinval) * v31)));
      v35.f32[0] = (float)(v52.__cosval * v31) + v32;
      v36.f32[0] = (float)(v52.__cosval * 0.0) + v64;
      v37.n128_u32[0] = *(_DWORD *)(v4 + 136);
      v38.n128_u32[0] = 0;
      result = emit(v4, v6, (float *)v7, 0, *(_DWORD *)(v4 + 124), a3, v37, v38, v33, v34, v35, v36, v39, v40, v26, v25, (float)((float)((float)(v20 * v52.__sinval) * v24.__cosval)+ (float)((float)((float)(v19 * v52.__sinval) * (float)(v21 * v24.__sinval))+ (float)(v52.__cosval * (float)(v20 * v24.__sinval))))
               - (float)((float)(v21 * v52.__sinval) * (float)(v19 * v24.__sinval)),
                 COERCE__INT32((float)((float)((float)(v21 * v52.__sinval) * (float)(v20 * v24.__sinval))+ (float)((float)((float)(v19 * v52.__sinval) * v24.__cosval)+ (float)(v52.__cosval * (float)(v19 * v24.__sinval))))- (float)((float)(v20 * v52.__sinval) * (float)(v21 * v24.__sinval))), COERCE_UNSIGNED_INT32((float)((float)(v52.__cosval * (float)(v21 * v24.__sinval))+ (float)((float)((float)(v21 * v52.__sinval) * v24.__cosval)+ (float)((float)(v20 * v52.__sinval) * (float)(v19 * v24.__sinval))))- (float)((float)(v19 * v52.__sinval) * (float)(v20 * v24.__sinval))), COERCE_UNSIGNED_INT32((float)((float)((float)(v52.__cosval * v24.__cosval)- (float)((float)(v20 * v52.__sinval) * (float)(v20 * v24.__sinval)))- (float)((float)(v21 * v52.__sinval) * (float)(v21 * v24.__sinval)))- (float)((float)(v19 * v52.__sinval) * (float)(v19 * v24.__sinval))));
      v9 = 0.5;
      v6 = result;
      v7 += 8 * *(int *)(v4 + 124) + 84;
      ++v5;
      v8 = 1.0;
      v10 = 0.25;
    }
    while (v5 < *(_QWORD *)(v4 + 64));
  }
  return result;
}

float *apply_twirl(float *result, float a2, int a3)
{
  uint64_t v4;
  unint64_t v5;
  float *v6;
  float v7;
  float32x2_t *v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  double v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  __float2 v22;
  double v23;
  double v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  double v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  __n128 v36;
  __n128 v37;
  uint64_t v38;
  uint64_t v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  BOOL v45;
  float v46;
  float v47;
  double v48;
  float v49;
  __float2 v50;
  float32x2_t v51;
  float v52;
  float v53;
  float32x2_t v55;
  float v56;
  float32x2_t v57;

  if (*((_QWORD *)result + 8))
  {
    v4 = (uint64_t)result;
    v5 = 0;
    v6 = *(float **)&result[2 * (a3 != 0) + 24];
    v7 = 1.0;
    v8 = (float32x2_t *)*((_QWORD *)result + 7);
    v9 = 0.5;
    do
    {
      v57 = *v8;
      v40 = v8[6].f32[1];
      v41 = v8[7].f32[0];
      v42 = fminf(fmaxf(a2 - v40, 0.0), v41);
      v43 = fminf(fmaxf((float)(a2 + 1.0) - v40, 0.0), v41) - v41;
      v44 = v40 - (float)(v41 + -1.0);
      v45 = v44 > a2;
      v46 = a2 - v44;
      if (!v45)
        v46 = 0.0;
      if (v41 <= v7)
        v46 = v43;
      if (a2 < 0.0)
        v47 = v46;
      else
        v47 = v42;
      v48 = -(v8[3].f32[1] * -3.14159265 * v47);
      if (a3 >= 0)
        v48 = v8[3].f32[1] * -3.14159265 * v47;
      v49 = v48;
      v50 = __sincosf_stret(v49 * v9);
      v51 = v8[2];
      v13 = v8[3].f32[0];
      if (v47 < 0.25)
      {
        v10 = fminf(fmaxf(v47 * 4.0, 0.0), v7);
        v11 = (float)(v10 * v10) * (float)(3.0 - (float)(v10 + v10));
        v12 = v57.f32[0];
        v55 = vadd_f32(vmul_n_f32(v51, v11), vmul_n_f32(v57, v7 - v11));
        v13 = (float)(v13 * v11) + (float)((float)(v7 - v11) * 0.0);
        v14 = v11 + (float)(v7 - v11);
      }
      else
      {
        if (v47 < 0.75)
        {
          v15 = v57.f32[0] * 3.14159265;
          v56 = 1.0;
          v16 = 0.5;
          v55 = v8[2];
          goto LABEL_5;
        }
        v52 = fminf(fmaxf((float)(v47 + -0.75) * 4.0, 0.0), v7);
        v53 = (float)(v52 * v52) * (float)(3.0 - (float)(v52 + v52));
        v12 = v57.f32[0];
        v55 = vadd_f32(vmul_n_f32(v57, v53), vmul_n_f32(v51, v7 - v53));
        v13 = (float)(v53 * 0.0) + (float)(v13 * (float)(v7 - v53));
        v14 = v53 + (float)(v7 - v53);
      }
      v56 = v14;
      v15 = v12 * 3.14159265 * v8[5].f32[1];
      v16 = 0.5;
LABEL_5:
      v18 = v8[4].f32[0];
      v17 = v8[4].f32[1];
      v19 = v17 * v50.__sinval;
      v20 = v8[5].f32[0];
      v21 = v15 * v50.__cosval;
      v22 = __sincosf_stret(v21 * v16);
      *(float *)&v23 = v20 * v22.__sinval;
      *(float *)&v24 = v17 * v22.__sinval;
      v25 = vmuls_lane_f32(v20 * v50.__sinval, v55, 1);
      v26 = vmuls_lane_f32(v18 * v50.__sinval, v55, 1);
      v27 = (float)((float)(v19 * v13) - v25) + (float)((float)(v19 * v13) - v25);
      v28 = (float)((float)((float)(v20 * v50.__sinval) * v55.f32[0]) - (float)((float)(v18 * v50.__sinval) * v13))
          + (float)((float)((float)(v20 * v50.__sinval) * v55.f32[0]) - (float)((float)(v18 * v50.__sinval) * v13));
      v29 = (float)(v26 - (float)(v19 * v55.f32[0])) + (float)(v26 - (float)(v19 * v55.f32[0]));
      v30 = v55.f32[1]
          + (float)((float)((float)(v20 * v50.__sinval) * v27) - (float)((float)(v18 * v50.__sinval) * v29));
      v31 = v13 + (float)((float)((float)(v18 * v50.__sinval) * v28) - (float)((float)(v17 * v50.__sinval) * v27));
      *(float *)&v32 = (float)(v50.__cosval * v27)
                     + (float)(v55.f32[0]
                             + (float)((float)((float)(v17 * v50.__sinval) * v29)
                                     - (float)((float)(v20 * v50.__sinval) * v28)));
      v33.f32[0] = (float)(v50.__cosval * v28) + v30;
      v34.f32[0] = (float)(v50.__cosval * v29) + v31;
      v35.f32[0] = (float)(v50.__cosval * 0.0) + v56;
      v36.n128_u32[0] = *(_DWORD *)(v4 + 136);
      v37.n128_u32[0] = 0;
      result = emit(v4, v6, (float *)v8, 0, *(_DWORD *)(v4 + 124), a3, v36, v37, v32, v33, v34, v35, v38, v39, v24, v23, (float)((float)((float)(v18 * v50.__sinval) * v22.__cosval)+ (float)((float)((float)(v17 * v50.__sinval) * (float)(v20 * v22.__sinval))+ (float)(v50.__cosval * (float)(v18 * v22.__sinval))))
               - (float)((float)(v20 * v50.__sinval) * (float)(v17 * v22.__sinval)),
                 COERCE__INT32((float)((float)((float)(v20 * v50.__sinval) * (float)(v18 * v22.__sinval))+ (float)((float)((float)(v17 * v50.__sinval) * v22.__cosval)+ (float)(v50.__cosval * (float)(v17 * v22.__sinval))))- (float)((float)(v18 * v50.__sinval) * (float)(v20 * v22.__sinval))), COERCE_UNSIGNED_INT32((float)((float)(v50.__cosval * (float)(v20 * v22.__sinval))+ (float)((float)((float)(v20 * v50.__sinval) * v22.__cosval)+ (float)((float)(v18 * v50.__sinval) * (float)(v17 * v22.__sinval))))- (float)((float)(v17 * v50.__sinval) * (float)(v18 * v22.__sinval))), COERCE_UNSIGNED_INT32((float)((float)((float)(v50.__cosval * v22.__cosval)- (float)((float)(v18 * v50.__sinval) * (float)(v18 * v22.__sinval)))- (float)((float)(v20 * v50.__sinval) * (float)(v20 * v22.__sinval)))- (float)((float)(v17 * v50.__sinval) * (float)(v17 * v22.__sinval))));
      v9 = 0.5;
      v6 = result;
      v8 = (float32x2_t *)((char *)v8 + 8 * *(int *)(v4 + 124) + 84);
      ++v5;
      v7 = 1.0;
    }
    while (v5 < *(_QWORD *)(v4 + 64));
  }
  return result;
}

float *apply_test(float *result, float a2, int a3)
{
  uint64_t v5;
  unint64_t v6;
  float *v7;
  float *v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  double v17;
  float v18;
  __float2 v19;
  float v20;
  __int32 v21;
  unsigned __int32 v22;
  __n128 v23;
  float32x4_t v24;
  float32x4_t v25;
  __n128 v26;
  float32x4_t v27;
  double v28;
  uint64_t v29;
  uint64_t v30;
  double v31;
  double v32;
  float v33;
  float v34;

  if (*((_QWORD *)result + 8))
  {
    v5 = (uint64_t)result;
    v6 = 0;
    v7 = *(float **)&result[2 * (a3 != 0) + 24];
    v8 = (float *)*((_QWORD *)result + 7);
    v33 = a2 + 1.0;
    do
    {
      v9 = v8[1];
      v34 = *v8;
      v10 = v8[13];
      v11 = v8[14];
      v12 = fminf(fmaxf(a2 - v10, 0.0), v11);
      v13 = fminf(fmaxf(v33 - v10, 0.0), v11) - v11;
      v14 = v10 - (float)(v11 + -1.0);
      if (v14 <= a2)
        v15 = 0.0;
      else
        v15 = a2 - v14;
      if (v11 <= 1.0)
        v15 = v13;
      if (a2 < 0.0)
        v16 = v15;
      else
        v16 = v12;
      v17 = -(v8[11] * 6.28318531 * v16);
      if (a3 >= 0)
        v17 = v8[11] * 6.28318531 * v16;
      v18 = v17;
      v19 = __sincosf_stret(v18 * 0.5);
      v20 = v8[8] * v19.__sinval;
      *(float *)&v21 = v8[9] * v19.__sinval;
      *(float *)&v22 = v8[10] * v19.__sinval;
      v23.n128_f64[0] = sin((float)(v16 + v16) * 3.14159265);
      v23.n128_f32[0] = v23.n128_f64[0];
      v24.f32[0] = v9 * (float)((float)(v23.n128_f32[0] * 0.35) + 1.0);
      v25.f32[0] = 0.0 - v23.n128_f32[0];
      v23.n128_u32[0] = *(_DWORD *)(v5 + 136);
      v26.n128_u32[0] = 0;
      v27.i32[0] = 1.0;
      *(float *)&v28 = v34;
      result = emit(v5, v7, v8, 0, *(_DWORD *)(v5 + 124), a3, v23, v26, v28, v24, v25, v27, v29, v30, v31, v32, v20, v21, v22,
                 LODWORD(v19.__cosval));
      v7 = result;
      v8 += 2 * *(int *)(v5 + 124) + 21;
      ++v6;
    }
    while (v6 < *(_QWORD *)(v5 + 64));
  }
  return result;
}

int8x16_t HGColorGammaLUTInfo::HGColorGammaLUTInfo(uint64_t a1, uint64_t a2, int a3, int a4, float a5, float a6, __n128 a7, int8x16_t a8, int8x16_t a9, int8x16_t a10, __n128 a11, int8x16_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int8x16_t a17)
{
  uint64_t v18;
  __n128 v19;
  __n128 v20;
  int8x16_t result;

  v18 = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a4, a5, a6);
  *(_QWORD *)v18 = &off_1E65317A8;
  v19 = a7;
  v19.n128_u32[3] = a8.i32[0];
  *(_DWORD *)(v18 + 36) = a3;
  *(__n128 *)(v18 + 40) = v19;
  *(int8x16_t *)(v18 + 56) = vextq_s8(vextq_s8(a8, a8, 0xCuLL), a9, 8uLL);
  *(int8x16_t *)(v18 + 72) = vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a9, (int32x4_t)a9), a10, 0xCuLL);
  v20 = a11;
  v20.n128_u32[3] = a12.i32[0];
  *(__n128 *)(v18 + 88) = v20;
  result = vextq_s8(vextq_s8(a12, a12, 0xCuLL), a17, 8uLL);
  *(int8x16_t *)(v18 + 104) = result;
  *(_DWORD *)(v18 + 120) = a17.i32[2];
  return result;
}

float *HGColorGammaLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  float *result;
  float *v4;

  if (!lpsrc)
    return 0;
  if (result)
  {
    v4 = result;
    result = (float *)HGApplyNDLUTInfo::isEqual(a1, result);
    if ((_DWORD)result)
    {
      if (*(_DWORD *)(a1 + 36) == *((_DWORD *)v4 + 9))
      {
        if (*(float *)(a1 + 40) == v4[10]
          && *(float *)(a1 + 44) == v4[11]
          && *(float *)(a1 + 48) == v4[12]
          && *(float *)(a1 + 52) == v4[13]
          && *(float *)(a1 + 56) == v4[14]
          && *(float *)(a1 + 60) == v4[15]
          && *(float *)(a1 + 64) == v4[16]
          && *(float *)(a1 + 68) == v4[17]
          && *(float *)(a1 + 72) == v4[18]
          && *(float *)(a1 + 76) == v4[19]
          && *(float *)(a1 + 80) == v4[20]
          && *(float *)(a1 + 84) == v4[21]
          && *(float *)(a1 + 88) == v4[22]
          && *(float *)(a1 + 92) == v4[23]
          && *(float *)(a1 + 96) == v4[24]
          && *(float *)(a1 + 100) == v4[25]
          && *(float *)(a1 + 104) == v4[26]
          && *(float *)(a1 + 108) == v4[27]
          && *(float *)(a1 + 112) == v4[28]
          && *(float *)(a1 + 116) == v4[29])
        {
          return (float *)(*(float *)(a1 + 120) == v4[30]);
        }
        else
        {
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void HGColorGammaLUTInfo::colorAtIndex(HGColorGammaLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  float v14;
  float v15;
  double v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  double v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;

  switch(*((_DWORD *)this + 9))
  {
    case 0:
      if (a2 >= 0.0)
      {
        *a5 = powf(a2, *((float *)this + 10));
        *a6 = powf(a2, *((float *)this + 11));
        v15 = powf(a2, *((float *)this + 12));
      }
      else
      {
        v14 = -a2;
        *a5 = -powf(-a2, *((float *)this + 10));
        *a6 = -powf(v14, *((float *)this + 11));
        v15 = -powf(v14, *((float *)this + 12));
      }
      goto LABEL_36;
    case 1:
      v16 = a2;
      v17 = *((float *)this + 16);
      v18 = *((float *)this + 13);
      v19 = 0.0;
      v20 = 0.0;
      if (-v17 / v18 <= a2)
        v20 = powf(v17 + (float)(v18 * a2), *((float *)this + 10));
      *a5 = v20;
      v21 = *((float *)this + 17);
      v22 = *((float *)this + 14);
      if (-v21 / v22 <= v16)
        v19 = powf(v21 + (float)(v22 * a2), *((float *)this + 11));
      *a6 = v19;
      v23 = *((float *)this + 18);
      v24 = *((float *)this + 15);
      v15 = 0.0;
      if (-v23 / v24 > v16)
        goto LABEL_36;
      v25 = v23 + (float)(v24 * a2);
      goto LABEL_16;
    case 2:
      v26 = a2;
      v27 = *((float *)this + 16);
      v28 = *((float *)this + 13);
      if (-v27 / v28 <= a2)
        v29 = powf(v27 + (float)(v28 * a2), *((float *)this + 10)) + *((float *)this + 19);
      else
        v29 = *((float *)this + 19);
      *a5 = v29;
      v32 = *((float *)this + 17);
      v33 = *((float *)this + 14);
      if (-v32 / v33 <= v26)
        v34 = powf(v32 + (float)(v33 * a2), *((float *)this + 11)) + *((float *)this + 20);
      else
        v34 = *((float *)this + 20);
      *a6 = v34;
      v35 = *((float *)this + 18);
      v36 = *((float *)this + 15);
      if (-v35 / v36 > v26)
      {
        v15 = *((float *)this + 21);
        goto LABEL_36;
      }
      v30 = powf(v35 + (float)(v36 * a2), *((float *)this + 12));
      v31 = *((float *)this + 21);
      goto LABEL_35;
    case 3:
      if (*((float *)this + 22) <= a2)
      {
        *a5 = powf((float)(*((float *)this + 13) * a2) + *((float *)this + 16), *((float *)this + 10));
        if (*((float *)this + 23) <= a2)
        {
LABEL_14:
          *a6 = powf((float)(*((float *)this + 14) * a2) + *((float *)this + 17), *((float *)this + 11));
          if (*((float *)this + 24) <= a2)
            goto LABEL_15;
          goto LABEL_27;
        }
      }
      else
      {
        *a5 = *((float *)this + 19) * a2;
        if (*((float *)this + 23) <= a2)
          goto LABEL_14;
      }
      *a6 = *((float *)this + 20) * a2;
      if (*((float *)this + 24) <= a2)
      {
LABEL_15:
        v25 = (float)(*((float *)this + 15) * a2) + *((float *)this + 18);
LABEL_16:
        v15 = powf(v25, *((float *)this + 12));
        goto LABEL_36;
      }
LABEL_27:
      v15 = *((float *)this + 21) * a2;
      goto LABEL_36;
    case 4:
      if (*((float *)this + 22) > a2)
      {
        *a5 = (float)(*((float *)this + 19) * a2) + *((float *)this + 28);
        if (*((float *)this + 23) <= a2)
          goto LABEL_19;
LABEL_29:
        *a6 = (float)(*((float *)this + 20) * a2) + *((float *)this + 29);
        if (*((float *)this + 24) <= a2)
          goto LABEL_20;
        goto LABEL_30;
      }
      *a5 = powf((float)(*((float *)this + 13) * a2) + *((float *)this + 16), *((float *)this + 10))
          + *((float *)this + 25);
      if (*((float *)this + 23) > a2)
        goto LABEL_29;
LABEL_19:
      *a6 = powf((float)(*((float *)this + 14) * a2) + *((float *)this + 17), *((float *)this + 11))
          + *((float *)this + 26);
      if (*((float *)this + 24) <= a2)
      {
LABEL_20:
        v30 = powf((float)(*((float *)this + 15) * a2) + *((float *)this + 18), *((float *)this + 12));
        v31 = *((float *)this + 27);
        goto LABEL_35;
      }
LABEL_30:
      v30 = *((float *)this + 21) * a2;
      v31 = *((float *)this + 30);
LABEL_35:
      v15 = v30 + v31;
LABEL_36:
      *a7 = v15;
LABEL_37:
      *a8 = 1.0;
      return;
    default:
      goto LABEL_37;
  }
}

double HGArriLogCDefaultToneCurveLUTInfo::HGArriLogCDefaultToneCurveLUTInfo(uint64_t a1, uint64_t a2, char a3, int a4, float a5, float a6)
{
  uint64_t v7;
  double result;

  v7 = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a4, a5, a6);
  *(_QWORD *)v7 = &off_1E65317F8;
  *(_BYTE *)(v7 + 120) = a3;
  *(_OWORD *)(v7 + 40) = xmmword_1B35254C0;
  *(_OWORD *)(v7 + 88) = xmmword_1B35254D0;
  *(_OWORD *)(v7 + 56) = xmmword_1B35254E0;
  *(_OWORD *)(v7 + 104) = xmmword_1B35254F0;
  result = -4.04163265;
  *(_OWORD *)(v7 + 72) = xmmword_1B3525500;
  return result;
}

unsigned __int8 *HGArriLogCDefaultToneCurveLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  unsigned __int8 *result;
  unsigned __int8 *v4;

  if (!lpsrc)
    return 0;
  if (result)
  {
    v4 = result;
    result = (unsigned __int8 *)HGApplyNDLUTInfo::isEqual(a1, result);
    if ((_DWORD)result)
      return (unsigned __int8 *)(*(unsigned __int8 *)(a1 + 120) == v4[120]);
  }
  return result;
}

void HGArriLogCDefaultToneCurveLUTInfo::colorAtIndex(HGArriLogCDefaultToneCurveLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  float v12;
  double v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  unsigned __int8 v17;
  long double v18;
  double v19;
  int v20;
  double v21;

  v12 = 0.0;
  if (a2 > 0.0)
  {
    v12 = 1.0;
    if (a2 < 1.0)
    {
      v13 = a2;
      if (a2 >= 0.256)
      {
        if (v13 >= 0.391)
        {
          if (v13 >= 0.57)
          {
            if (v13 >= 0.65)
            {
              v14 = 4;
              if (a2 >= 1.0)
                v14 = 5;
            }
            else
            {
              v14 = 3;
            }
          }
          else
          {
            v14 = 2;
          }
        }
        else
        {
          v14 = 1;
        }
      }
      else
      {
        v14 = 0;
      }
      v15 = v14;
      v16 = *(double *)&HGArriLogCDefaultToneCurveLUTInfo::a0[v15]
          + (v13 - *(double *)&HGArriLogCDefaultToneCurveLUTInfo::xi[v15])
          * (*(double *)&HGArriLogCDefaultToneCurveLUTInfo::a1[v15]
           + (v13 - *(double *)&HGArriLogCDefaultToneCurveLUTInfo::xi[v15])
           * (*(double *)((char *)this + v15 * 8 + 80) * (v13 - *(double *)&HGArriLogCDefaultToneCurveLUTInfo::xi[v15])
            + *(double *)((char *)this + v15 * 8 + 40)));
      if (*((_BYTE *)this + 120))
      {
        v17 = atomic_load((unsigned __int8 *)&qword_1ED4DAB28);
        if ((v17 & 1) == 0)
        {
          v21 = v16;
          v20 = __cxa_guard_acquire(&qword_1ED4DAB28);
          v16 = v21;
          if (v20)
          {
            _MergedGlobals_17 = 0x3F732E5BF55474D3;
            __cxa_guard_release(&qword_1ED4DAB28);
            v16 = v21;
          }
        }
        if (v16 > 0.0562318841)
        {
          v16 = (v16 + 0.097) / 1.097;
          v18 = 2.725;
LABEL_21:
          v19 = pow(v16, v18);
          goto LABEL_22;
        }
        v19 = v16 / 0.0562318841 * *(double *)&_MergedGlobals_17;
      }
      else
      {
        if (v16 >= 0.0)
        {
          v18 = 2.4;
          goto LABEL_21;
        }
        v19 = -pow(-v16, 2.4);
      }
LABEL_22:
      v12 = v19;
    }
  }
  *a5 = v12;
  *a6 = v12;
  *a7 = v12;
  *a8 = 1.0;
}

uint64_t HGArriLogCLinearizationLUTInfo::HGArriLogCLinearizationLUTInfo(uint64_t a1, uint64_t a2, unsigned int a3, int a4, float a5, float a6)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  double *v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;

  v8 = 1;
  v9 = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a4, a5, a6);
  *(_QWORD *)v9 = &off_1E6531848;
  *(_DWORD *)(v9 + 36) = 0;
  if (a3 >= 0xB4)
  {
    *(_DWORD *)(a1 + 36) = 1;
    if (a3 >= 0xE1)
    {
      v8 = 2;
      *(_DWORD *)(a1 + 36) = 2;
      if (a3 >= 0x11D)
      {
        v8 = 3;
        *(_DWORD *)(a1 + 36) = 3;
        if (a3 >= 0x168)
        {
          v8 = 4;
          *(_DWORD *)(a1 + 36) = 4;
          if (a3 >= 0x1C2)
          {
            v8 = 5;
            *(_DWORD *)(a1 + 36) = 5;
            if (a3 >= 0x23A)
            {
              v8 = 6;
              *(_DWORD *)(a1 + 36) = 6;
              if (a3 >= 0x2D0)
              {
                v8 = 7;
                *(_DWORD *)(a1 + 36) = 7;
                if (a3 >= 0x384)
                {
                  v8 = 8;
                  *(_DWORD *)(a1 + 36) = 8;
                  if (a3 >= 0x474)
                  {
                    if (a3 < 0x5A0)
                      v10 = 9;
                    else
                      v10 = 10;
                    *(_DWORD *)(a1 + 36) = v10;
                    if (a3 < 0x5A0)
                      v8 = 9;
                    else
                      v8 = 10;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    v8 = 0;
  }
  v11 = (double *)((char *)&HGArriLogCLinearizationLUTInfo::linearizationParameters + 56 * v8);
  v12 = v11[1];
  v13 = v11[3];
  v14 = v11[4];
  v15 = v11[5];
  v16 = v11[6];
  *(long double *)(a1 + 40) = (v14 + v13 * log10(v12 * 5.55555556 + v11[2]) + v12 * v15 + v16) * 0.5;
  *(double *)(a1 + 48) = 2.30258509 / v13;
  return a1;
}

_DWORD *HGArriLogCLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  _DWORD *result;
  _DWORD *v4;

  if (!lpsrc)
    return 0;
  if (result)
  {
    v4 = result;
    result = HGApplyNDLUTInfo::isEqual(a1, result);
    if ((_DWORD)result)
      return (_DWORD *)(*(_DWORD *)(a1 + 36) == v4[9]);
  }
  return result;
}

float HGArriLogCLinearizationLUTInfo::colorAtIndex(HGArriLogCLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  double v12;
  double v13;
  unsigned int v14;
  double *v15;
  double v16;
  double v17;
  float result;

  v12 = a2;
  if (a2 > 1.0)
    v12 = 1.0;
  if (a2 >= 0.0)
    v13 = v12;
  else
    v13 = 0.0;
  v14 = *((_DWORD *)this + 9);
  if (v13 <= *((double *)this + 5))
  {
    v17 = (v13 - HGArriLogCLinearizationLUTInfo::linearizationParameters[7 * v14 + 6])
        / HGArriLogCLinearizationLUTInfo::linearizationParameters[7 * v14 + 5];
  }
  else
  {
    v15 = &HGArriLogCLinearizationLUTInfo::linearizationParameters[7 * v14];
    v16 = v15[2];
    v17 = (exp((v13 - v15[4]) * *((double *)this + 6)) - v16) / 5.55555556;
  }
  result = v17 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

_QWORD *HGArriLogC4LinearizationLUTInfo::HGArriLogC4LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E6531898;
  return result;
}

void *HGArriLogC4LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

float HGArriLogC4LinearizationLUTInfo::colorAtIndex(HGArriLogC4LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  unsigned __int8 v12;
  unsigned __int8 v13;
  double v14;
  double v15;
  float result;
  int v17;
  int v18;
  float v19;
  float v20;

  v12 = atomic_load((unsigned __int8 *)&qword_1ED4DAB38);
  if ((v12 & 1) == 0)
  {
    v19 = a2;
    v17 = __cxa_guard_acquire(&qword_1ED4DAB38);
    a2 = v19;
    if (v17)
    {
      qword_1ED4DAB30 = 0x3FBD14B4E7E63D19;
      __cxa_guard_release(&qword_1ED4DAB38);
      a2 = v19;
    }
  }
  v13 = atomic_load((unsigned __int8 *)&qword_1ED4DAB48);
  if ((v13 & 1) == 0)
  {
    v20 = a2;
    v18 = __cxa_guard_acquire(&qword_1ED4DAB48);
    a2 = v20;
    if (v18)
    {
      qword_1ED4DAB40 = 0xBF927D887F3231C4;
      __cxa_guard_release(&qword_1ED4DAB48);
      a2 = v20;
    }
  }
  v14 = 0.0;
  if (a2 < 0.0 || (v14 = 1.0, a2 > 1.0) || (v14 = a2, a2 >= 0.0))
    v15 = (exp2((v14 + -0.0928641251) * 14.0 / 0.907135875 + 6.0) + -64.0) / 2231.82631;
  else
    v15 = *(double *)&qword_1ED4DAB30 * v14 + *(double *)&qword_1ED4DAB40;
  result = v15 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

double HGCanonLogToneCurveLUTInfo::kMinLogGamma(HGCanonLogToneCurveLUTInfo *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_1ED4DAB58);
  if ((v1 & 1) != 0 || !__cxa_guard_acquire(&qword_1ED4DAB58))
    return *(double *)&qword_1ED4DAB50;
  qword_1ED4DAB50 = 0x3FA371775C883CCDLL;
  __cxa_guard_release(&qword_1ED4DAB58);
  return *(double *)&qword_1ED4DAB50;
}

double HGCanonLogToneCurveLUTInfo::kMaxLogGamma(HGCanonLogToneCurveLUTInfo *this)
{
  unsigned __int8 v1;
  unsigned __int8 v2;

  v1 = atomic_load((unsigned __int8 *)&qword_1ED4DAB68);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4DAB68))
  {
    qword_1ED4DAB60 = 0x3FF33A573B3EED8ALL;
    __cxa_guard_release(&qword_1ED4DAB68);
  }
  v2 = atomic_load((unsigned __int8 *)&qword_1ED4DAB78);
  if ((v2 & 1) != 0 || !__cxa_guard_acquire(&qword_1ED4DAB78))
    return *(double *)&qword_1ED4DAB70;
  *(double *)&qword_1ED4DAB70 = log10(*(double *)&qword_1ED4DAB60 * 10.1596 + 1.0) * 0.529136 + 0.0730597;
  __cxa_guard_release(&qword_1ED4DAB78);
  return *(double *)&qword_1ED4DAB70;
}

_QWORD *HGCanonLogToneCurveLUTInfo::HGCanonLogToneCurveLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E65318E8;
  return result;
}

void *HGCanonLogToneCurveLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

float HGCanonLogToneCurveLUTInfo::colorAtIndex(HGCanonLogToneCurveLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  unsigned __int8 v12;
  double v13;
  BOOL v14;
  _BOOL4 v15;
  double v16;
  double v17;
  double v18;
  long double v19;
  double v20;
  double v21;
  long double v22;
  double v23;
  float result;
  int v25;
  float v26;

  v12 = atomic_load((unsigned __int8 *)&qword_1ED4DAB88);
  if ((v12 & 1) == 0)
  {
    v26 = a2;
    v25 = __cxa_guard_acquire(&qword_1ED4DAB88);
    a2 = v26;
    if (v25)
    {
      qword_1ED4DAB80 = 0x40116808484C167BLL;
      __cxa_guard_release(&qword_1ED4DAB88);
      a2 = v26;
    }
  }
  v13 = a2;
  v14 = v13 < 0.0730597;
  v15 = v13 < 0.0730597;
  v16 = 0.0730597 - v13;
  v17 = v13 + -0.0730597;
  if (v14)
    v17 = v16;
  v18 = dbl_1B3525510[v15];
  v19 = (exp(v17 * *(double *)&qword_1ED4DAB80) + -1.0) / v18;
  if (v19 >= 0.018)
  {
    v21 = pow(v19, 0.45) * 1.099 + -0.099;
    v22 = 1.09474886;
    if (v21 > 1.09474886)
    {
LABEL_11:
      v23 = pow(v22, 1.956);
      goto LABEL_12;
    }
  }
  else
  {
    v20 = -0.0730593607;
    if (v19 <= -0.018)
      goto LABEL_10;
    v21 = v19 * 4.5;
    if (v19 * 4.5 < -0.0730593607)
      goto LABEL_10;
  }
  v22 = v21;
  v20 = v21;
  if (v21 >= 0.0)
    goto LABEL_11;
LABEL_10:
  v23 = -pow(-v20, 1.956);
LABEL_12:
  result = v23;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

_QWORD *HGCanonLogLinearizationLUTInfo::HGCanonLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E6531938;
  return result;
}

void *HGCanonLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

float HGCanonLogLinearizationLUTInfo::colorAtIndex(HGCanonLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  double v12;
  double v13;
  unsigned __int8 v14;
  BOOL v15;
  _BOOL4 v16;
  double v17;
  double v18;
  double v19;
  float result;
  int v21;
  double v22;

  v12 = a2;
  v13 = -0.0730593607;
  if (v12 >= -0.0730593607)
  {
    v13 = v12;
    if (v12 > 1.09474886)
      v13 = 1.09474886;
  }
  v14 = atomic_load((unsigned __int8 *)&qword_1ED4DAB98);
  if ((v14 & 1) == 0)
  {
    v22 = v13;
    v21 = __cxa_guard_acquire(&qword_1ED4DAB98);
    v13 = v22;
    if (v21)
    {
      qword_1ED4DAB90 = 0x40116808484C167BLL;
      __cxa_guard_release(&qword_1ED4DAB98);
      v13 = v22;
    }
  }
  v15 = v13 < 0.0730597;
  v16 = v13 < 0.0730597;
  v17 = 0.0730597 - v13;
  v18 = v13 + -0.0730597;
  if (v15)
    v18 = v17;
  v19 = dbl_1B3525510[v16];
  result = (exp(v18 * *(double *)&qword_1ED4DAB90) + -1.0) / v19;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

_QWORD *HGCanonLog2LinearizationLUTInfo::HGCanonLog2LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E6531988;
  return result;
}

void *HGCanonLog2LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

float HGCanonLog2LinearizationLUTInfo::colorAtIndex(HGCanonLog2LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  float result;

  v12 = a2;
  v13 = -0.0730593607;
  if (v12 >= -0.0730593607 && ((v14 = 1.09474886, v12 > 1.09474886) || (v14 = v12, v13 = v12, v12 >= 0.035388128)))
  {
    v15 = v14 + -0.035388128;
    v16 = 87.0993755;
  }
  else
  {
    v15 = 0.035388128 - v13;
    v16 = -87.0993755;
  }
  result = (exp(v15 / 0.122411586) + -1.0) / v16;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

_QWORD *HGCanonLog3LinearizationLUTInfo::HGCanonLog3LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E65319D8;
  return result;
}

void *HGCanonLog3LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

float HGCanonLog3LinearizationLUTInfo::colorAtIndex(HGCanonLog3LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  unsigned __int8 v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  double v15;
  double v16;
  double v17;
  double v18;
  float result;
  int v20;
  int v21;
  int v22;
  float v23;
  float v24;
  float v25;

  v12 = atomic_load((unsigned __int8 *)&qword_1ED4DABA8);
  if ((v12 & 1) == 0)
  {
    v23 = a2;
    v20 = __cxa_guard_acquire(&qword_1ED4DABA8);
    a2 = v23;
    if (v20)
    {
      qword_1ED4DABA0 = 0x3FA4DEB50262DEBFLL;
      __cxa_guard_release(&qword_1ED4DABA8);
      a2 = v23;
    }
  }
  v13 = atomic_load((unsigned __int8 *)&qword_1ED4DABB8);
  if ((v13 & 1) == 0)
  {
    v24 = a2;
    v21 = __cxa_guard_acquire(&qword_1ED4DABB8);
    a2 = v24;
    if (v21)
    {
      qword_1ED4DABB0 = 0x3FBAF8AEDB215573;
      __cxa_guard_release(&qword_1ED4DABB8);
      a2 = v24;
    }
  }
  v14 = atomic_load((unsigned __int8 *)&qword_1ED4DABC8);
  if ((v14 & 1) == 0)
  {
    v25 = a2;
    v22 = __cxa_guard_acquire(&qword_1ED4DABC8);
    a2 = v25;
    if (v22)
    {
      qword_1ED4DABC0 = 0x401579709D43F5C0;
      __cxa_guard_release(&qword_1ED4DABC8);
      a2 = v25;
    }
  }
  v15 = a2;
  v16 = -0.0730593607;
  if (v15 >= -0.0730593607)
  {
    v16 = v15;
    if (v15 > 1.09474886)
      v16 = 1.09474886;
  }
  if (v16 >= *(double *)&qword_1ED4DABA0)
  {
    if (v16 <= *(double *)&qword_1ED4DABB0)
    {
      v17 = v16 + -0.073059361;
      v18 = 2.3069815;
    }
    else
    {
      v17 = exp((v16 + -0.069886632) * *(double *)&qword_1ED4DABC0) + -1.0;
      v18 = 14.98325;
    }
  }
  else
  {
    v17 = exp((0.07623209 - v16) * *(double *)&qword_1ED4DABC0) + -1.0;
    v18 = -14.98325;
  }
  result = v17 / v18;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

_QWORD *HGSonySLog2LinearizationLUTInfo::HGSonySLog2LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E6531A28;
  return result;
}

void *HGSonySLog2LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

float HGSonySLog2LinearizationLUTInfo::colorAtIndex(HGSonySLog2LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  double v12;
  double v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  double v16;
  double v17;
  float result;
  int v19;
  int v20;
  double v21;
  double v22;

  v12 = a2;
  v13 = -0.0730593607;
  if (v12 >= -0.0730593607)
  {
    v13 = v12;
    if (v12 > 1.09474886)
      v13 = 1.09474886;
  }
  v14 = atomic_load((unsigned __int8 *)&qword_1ED4DABD8);
  if ((v14 & 1) == 0)
  {
    v21 = v13;
    v19 = __cxa_guard_acquire(&qword_1ED4DABD8);
    v13 = v21;
    if (v19)
    {
      qword_1ED4DABD0 = 0x3F9EB8A3FBF49AE0;
      __cxa_guard_release(&qword_1ED4DABD8);
      v13 = v21;
    }
  }
  v15 = atomic_load((unsigned __int8 *)&qword_1ED4DABE8);
  if ((v15 & 1) == 0)
  {
    v22 = v13;
    v20 = __cxa_guard_acquire(&qword_1ED4DABE8);
    v13 = v22;
    if (v20)
    {
      qword_1ED4DABE0 = 0x4015492995272697;
      __cxa_guard_release(&qword_1ED4DABE8);
      v13 = v22;
    }
  }
  if (v13 >= *(double *)&qword_1ED4DABD0)
  {
    v16 = exp((v13 + -0.646596) * *(double *)&qword_1ED4DABE0) + -0.037584;
    v17 = 1.41290323;
  }
  else
  {
    v16 = v13 - *(double *)&qword_1ED4DABD0;
    v17 = 0.282580645;
  }
  result = v16 * v17;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

_QWORD *HGSonySLog3LinearizationLUTInfo::HGSonySLog3LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E6531A78;
  return result;
}

void *HGSonySLog3LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

float HGSonySLog3LinearizationLUTInfo::colorAtIndex(HGSonySLog3LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  unsigned __int8 v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  double v15;
  double v16;
  double v17;
  float result;
  int v19;
  int v20;
  int v21;
  float v22;
  float v23;
  float v24;

  v12 = atomic_load((unsigned __int8 *)&qword_1ED4DABF8);
  if ((v12 & 1) == 0)
  {
    v22 = a2;
    v19 = __cxa_guard_acquire(&qword_1ED4DABF8);
    a2 = v22;
    if (v19)
    {
      qword_1ED4DABF0 = 0x406566BABBEF8B7ALL;
      __cxa_guard_release(&qword_1ED4DABF8);
      a2 = v22;
    }
  }
  v13 = atomic_load((unsigned __int8 *)&qword_1ED4DAC08);
  if ((v13 & 1) == 0)
  {
    v23 = a2;
    v20 = __cxa_guard_acquire(&qword_1ED4DAC08);
    a2 = v23;
    if (v20)
    {
      *(double *)&qword_1ED4DAC00 = *(double *)&qword_1ED4DABF0 + -95.0;
      __cxa_guard_release(&qword_1ED4DAC08);
      a2 = v23;
    }
  }
  v14 = atomic_load((unsigned __int8 *)&qword_1ED4DAC18);
  if ((v14 & 1) == 0)
  {
    v24 = a2;
    v21 = __cxa_guard_acquire(&qword_1ED4DAC18);
    a2 = v24;
    if (v21)
    {
      qword_1ED4DAC10 = 0x3F820882EBA5480ALL;
      __cxa_guard_release(&qword_1ED4DAC18);
      a2 = v24;
    }
  }
  v15 = 0.0;
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
      v15 = a2;
    else
      v15 = 1.0;
  }
  v16 = v15 * 1023.0;
  if (v15 * 1023.0 >= *(double *)&qword_1ED4DABF0)
    v17 = exp((v16 + -420.0) * *(double *)&qword_1ED4DAC10) * 0.19 + -0.01;
  else
    v17 = (v16 + -95.0) / *(double *)&qword_1ED4DAC00 * 0.01125;
  result = v17 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

_QWORD *HGPanasonicVLogLinearizationLUTInfo::HGPanasonicVLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E6531AC8;
  return result;
}

void *HGPanasonicVLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

float HGPanasonicVLogLinearizationLUTInfo::colorAtIndex(HGPanasonicVLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  unsigned __int8 v12;
  unsigned __int8 v13;
  double v14;
  double v15;
  float result;
  int v17;
  int v18;
  float v19;
  float v20;

  v12 = atomic_load((unsigned __int8 *)&qword_1ED4DAC28);
  if ((v12 & 1) == 0)
  {
    v19 = a2;
    v17 = __cxa_guard_acquire(&qword_1ED4DAC28);
    a2 = v19;
    if (v17)
    {
      qword_1ED4DAC20 = 0x3FC72B00BE1A1A7DLL;
      __cxa_guard_release(&qword_1ED4DAC28);
      a2 = v19;
    }
  }
  v13 = atomic_load((unsigned __int8 *)&qword_1ED4DAC38);
  if ((v13 & 1) == 0)
  {
    v20 = a2;
    v18 = __cxa_guard_acquire(&qword_1ED4DAC38);
    a2 = v20;
    if (v18)
    {
      qword_1ED4DAC30 = 0x402311635B128422;
      __cxa_guard_release(&qword_1ED4DAC38);
      a2 = v20;
    }
  }
  v14 = 0.0;
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
    {
      v14 = a2;
      if (a2 < *(double *)&qword_1ED4DAC20)
        goto LABEL_7;
LABEL_9:
      v15 = exp((v14 + -0.598206) * *(double *)&qword_1ED4DAC30) + -0.00873;
      goto LABEL_10;
    }
    v14 = 1.0;
  }
  if (v14 >= *(double *)&qword_1ED4DAC20)
    goto LABEL_9;
LABEL_7:
  v15 = (v14 + -0.125) / 5.6;
LABEL_10:
  result = v15 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

_QWORD *HGNikonNLogLinearizationLUTInfo::HGNikonNLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E6531B18;
  return result;
}

void *HGNikonNLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

float HGNikonNLogLinearizationLUTInfo::colorAtIndex(HGNikonNLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  unsigned __int8 v12;
  double v13;
  double v14;
  float result;
  int v16;
  float v17;

  v12 = atomic_load((unsigned __int8 *)&qword_1ED4DAC48);
  if ((v12 & 1) == 0)
  {
    v17 = a2;
    v16 = __cxa_guard_acquire(&qword_1ED4DAC48);
    a2 = v17;
    if (v16)
    {
      qword_1ED4DAC40 = 0x3FDC42A6121F81AALL;
      __cxa_guard_release(&qword_1ED4DAC48);
      a2 = v17;
    }
  }
  v13 = 0.0;
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
    {
      v13 = a2;
      if (a2 < *(double *)&qword_1ED4DAC40)
        goto LABEL_6;
LABEL_8:
      v14 = exp((v13 + -0.605083089) / 0.146627566);
      goto LABEL_9;
    }
    v13 = 1.0;
  }
  if (v13 >= *(double *)&qword_1ED4DAC40)
    goto LABEL_8;
LABEL_6:
  v14 = v13 / 0.635386119 * (v13 / 0.635386119 * (v13 / 0.635386119)) + -0.0075;
LABEL_9:
  result = v14 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

uint64_t HGBMDFilmLinearizationLUTInfo::HGBMDFilmLinearizationLUTInfo(uint64_t a1, uint64_t a2, char a3, int a4, float a5, float a6)
{
  uint64_t result;

  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a4, a5, a6);
  *(_QWORD *)result = &off_1E6531B68;
  *(_BYTE *)(result + 36) = a3;
  return result;
}

unsigned __int8 *HGBMDFilmLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  unsigned __int8 *result;
  unsigned __int8 *v4;

  if (!lpsrc)
    return 0;
  if (result)
  {
    v4 = result;
    result = (unsigned __int8 *)HGApplyNDLUTInfo::isEqual(a1, result);
    if ((_DWORD)result)
      return (unsigned __int8 *)(*(unsigned __int8 *)(a1 + 36) == v4[36]);
  }
  return result;
}

float HGBMDFilmLinearizationLUTInfo::colorAtIndex(HGBMDFilmLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  double v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  double v15;
  double v16;
  double v17;
  double v18;
  unsigned __int8 v19;
  unsigned __int8 v20;
  double v21;
  float result;
  int v23;
  int v24;
  int v25;
  int v26;
  double v27;
  double v28;
  double v29;
  double v30;

  v12 = 0.0;
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
    {
      v12 = a2;
      if (*((_BYTE *)this + 36))
        goto LABEL_5;
LABEL_11:
      v19 = atomic_load((unsigned __int8 *)&qword_1ED4DAC58);
      if ((v19 & 1) == 0)
      {
        v29 = v12;
        v25 = __cxa_guard_acquire(&qword_1ED4DAC58);
        v12 = v29;
        if (v25)
        {
          qword_1ED4DAC50 = 0x3FBD384ED1A78752;
          __cxa_guard_release(&qword_1ED4DAC58);
          v12 = v29;
        }
      }
      v20 = atomic_load((unsigned __int8 *)&qword_1ED4DAC68);
      if ((v20 & 1) == 0)
      {
        v30 = v12;
        v26 = __cxa_guard_acquire(&qword_1ED4DAC68);
        v12 = v30;
        if (v26)
        {
          qword_1ED4DAC60 = 0x40190DFAF2EFA06ALL;
          __cxa_guard_release(&qword_1ED4DAC68);
          v12 = v30;
        }
      }
      if (v12 < *(double *)&qword_1ED4DAC50)
      {
        v15 = v12 + -0.0928641251;
        v16 = 0.7659482;
        goto LABEL_15;
      }
      v17 = exp((v12 + -0.3644932) * *(double *)&qword_1ED4DAC60);
      v18 = -0.1806583;
LABEL_17:
      v21 = v17 + v18;
      goto LABEL_18;
    }
    v12 = 1.0;
  }
  if (!*((_BYTE *)this + 36))
    goto LABEL_11;
LABEL_5:
  v13 = atomic_load((unsigned __int8 *)&qword_1ED4DAC78);
  if ((v13 & 1) == 0)
  {
    v27 = v12;
    v23 = __cxa_guard_acquire(&qword_1ED4DAC78);
    v12 = v27;
    if (v23)
    {
      qword_1ED4DAC70 = 0x3FBB97B1767A8EEALL;
      __cxa_guard_release(&qword_1ED4DAC78);
      v12 = v27;
    }
  }
  v14 = atomic_load((unsigned __int8 *)&qword_1ED4DAC88);
  if ((v14 & 1) == 0)
  {
    v28 = v12;
    v24 = __cxa_guard_acquire(&qword_1ED4DAC88);
    v12 = v28;
    if (v24)
    {
      qword_1ED4DAC80 = 0x400FA32D714B55AELL;
      __cxa_guard_release(&qword_1ED4DAC88);
      v12 = v28;
    }
  }
  if (v12 >= *(double *)&qword_1ED4DAC70)
  {
    v17 = exp((v12 + -0.2982706) * *(double *)&qword_1ED4DAC80);
    v18 = -0.4430254;
    goto LABEL_17;
  }
  v15 = v12 + -0.0928641251;
  v16 = 0.5370933;
LABEL_15:
  v21 = v15 / v16;
LABEL_18:
  result = v21 * 0.200222469;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

_QWORD *HGAppleLogLinearizationLUTInfo::HGAppleLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E6531BB8;
  return result;
}

void *HGAppleLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

float HGAppleLogLinearizationLUTInfo::colorAtIndex(HGAppleLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  unsigned __int8 v12;
  unsigned __int8 v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  float result;
  int v20;
  int v21;
  float v22;
  float v23;

  v12 = atomic_load((unsigned __int8 *)&qword_1ED4DAC98);
  if ((v12 & 1) == 0)
  {
    v22 = a2;
    v20 = __cxa_guard_acquire(&qword_1ED4DAC98);
    a2 = v22;
    if (v20)
    {
      qword_1ED4DAC90 = 0x3FCAB1F0CDAACC3ELL;
      __cxa_guard_release(&qword_1ED4DAC98);
      a2 = v22;
    }
  }
  v13 = atomic_load((unsigned __int8 *)&qword_1ED4DACA8);
  if ((v13 & 1) == 0)
  {
    v23 = a2;
    v21 = __cxa_guard_acquire(&qword_1ED4DACA8);
    a2 = v23;
    if (v21)
    {
      qword_1ED4DACA0 = 0x4020368B277C7D96;
      __cxa_guard_release(&qword_1ED4DACA8);
      a2 = v23;
    }
  }
  v14 = a2;
  if (a2 > 1.0)
    v14 = 1.0;
  if (a2 >= 0.0)
    v15 = v14;
  else
    v15 = 0.0;
  if (v15 >= *(double *)&qword_1ED4DAC90)
  {
    v17 = exp((v15 + -0.69336945) * *(double *)&qword_1ED4DACA0);
    v18 = -0.00964052;
LABEL_13:
    v16 = v17 + v18;
    goto LABEL_14;
  }
  if (v15 >= 0.0)
  {
    v17 = sqrt(v15 / 47.2871124);
    v18 = -0.05641088;
    goto LABEL_13;
  }
  v16 = -0.05641088;
LABEL_14:
  result = v16 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

_QWORD *HGDJIDLogLinearizationLUTInfo::HGDJIDLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E6531C08;
  return result;
}

void *HGDJIDLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

float HGDJIDLogLinearizationLUTInfo::colorAtIndex(HGDJIDLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  unsigned __int8 v12;
  unsigned __int8 v13;
  double v14;
  double v15;
  double v16;
  float result;
  int v18;
  int v19;
  float v20;
  float v21;

  v12 = atomic_load((unsigned __int8 *)&qword_1ED4DACB8);
  if ((v12 & 1) == 0)
  {
    v20 = a2;
    v18 = __cxa_guard_acquire(&qword_1ED4DACB8);
    a2 = v20;
    if (v18)
    {
      qword_1ED4DACB0 = 0x3FC1E81CC48A70B5;
      __cxa_guard_release(&qword_1ED4DACB8);
      a2 = v20;
    }
  }
  v13 = atomic_load((unsigned __int8 *)&qword_1ED4DACC8);
  if ((v13 & 1) == 0)
  {
    v21 = a2;
    v19 = __cxa_guard_acquire(&qword_1ED4DACC8);
    a2 = v21;
    if (v19)
    {
      qword_1ED4DACC0 = 0x4021F1463A0B6A33;
      __cxa_guard_release(&qword_1ED4DACC8);
      a2 = v21;
    }
  }
  v14 = 0.0;
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
    {
      v14 = a2;
      if (a2 > *(double *)&qword_1ED4DACB0)
        goto LABEL_7;
LABEL_9:
      v15 = v14 + -0.0929;
      v16 = 6.025;
      goto LABEL_10;
    }
    v14 = 1.0;
  }
  if (v14 <= *(double *)&qword_1ED4DACB0)
    goto LABEL_9;
LABEL_7:
  v15 = exp((v14 + -0.584555) * *(double *)&qword_1ED4DACC0) + -0.0108;
  v16 = 0.9892;
LABEL_10:
  result = v15 / v16 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

_QWORD *HGFujifilmFLogLinearizationLUTInfo::HGFujifilmFLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E6531C58;
  return result;
}

void *HGFujifilmFLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

float HGFujifilmFLogLinearizationLUTInfo::colorAtIndex(HGFujifilmFLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  unsigned __int8 v12;
  unsigned __int8 v13;
  double v14;
  double v15;
  double v16;
  float result;
  int v18;
  int v19;
  float v20;
  float v21;

  v12 = atomic_load((unsigned __int8 *)&qword_1ED4DACD8);
  if ((v12 & 1) == 0)
  {
    v20 = a2;
    v18 = __cxa_guard_acquire(&qword_1ED4DACD8);
    a2 = v20;
    if (v18)
    {
      qword_1ED4DACD0 = 0x3FB9C026A3080D26;
      __cxa_guard_release(&qword_1ED4DACD8);
      a2 = v20;
    }
  }
  v13 = atomic_load((unsigned __int8 *)&qword_1ED4DACE8);
  if ((v13 & 1) == 0)
  {
    v21 = a2;
    v19 = __cxa_guard_acquire(&qword_1ED4DACE8);
    a2 = v21;
    if (v19)
    {
      qword_1ED4DACE0 = 0x401AB8C38E6C7294;
      __cxa_guard_release(&qword_1ED4DACE8);
      a2 = v21;
    }
  }
  v14 = 0.0;
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
    {
      v14 = a2;
      if (a2 < *(double *)&qword_1ED4DACD0)
        goto LABEL_7;
LABEL_9:
      v15 = exp((v14 + -0.790453) * *(double *)&qword_1ED4DACE0) + -0.009468;
      v16 = 0.555555556;
      goto LABEL_10;
    }
    v14 = 1.0;
  }
  if (v14 >= *(double *)&qword_1ED4DACD0)
    goto LABEL_9;
LABEL_7:
  v15 = v14 + -0.092864;
  v16 = 8.735631;
LABEL_10:
  result = v15 / v16 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

_QWORD *HGFujifilmFLog2LinearizationLUTInfo::HGFujifilmFLog2LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E6531CA8;
  return result;
}

void *HGFujifilmFLog2LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

float HGFujifilmFLog2LinearizationLUTInfo::colorAtIndex(HGFujifilmFLog2LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  unsigned __int8 v12;
  unsigned __int8 v13;
  double v14;
  double v15;
  double v16;
  float result;
  int v18;
  int v19;
  float v20;
  float v21;

  v12 = atomic_load((unsigned __int8 *)&qword_1ED4DACF8);
  if ((v12 & 1) == 0)
  {
    v20 = a2;
    v18 = __cxa_guard_acquire(&qword_1ED4DACF8);
    a2 = v20;
    if (v18)
    {
      qword_1ED4DACF0 = 0x3FB9C69A8FA91FF2;
      __cxa_guard_release(&qword_1ED4DACF8);
      a2 = v20;
    }
  }
  v13 = atomic_load((unsigned __int8 *)&qword_1ED4DAD08);
  if ((v13 & 1) == 0)
  {
    v21 = a2;
    v19 = __cxa_guard_acquire(&qword_1ED4DAD08);
    a2 = v21;
    if (v19)
    {
      qword_1ED4DAD00 = 0x4022C66B961C7A0CLL;
      __cxa_guard_release(&qword_1ED4DAD08);
      a2 = v21;
    }
  }
  v14 = 0.0;
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
    {
      v14 = a2;
      if (a2 < *(double *)&qword_1ED4DACF0)
        goto LABEL_7;
LABEL_9:
      v15 = exp((v14 + -0.384316) * *(double *)&qword_1ED4DAD00) + -0.064829;
      v16 = 5.55555556;
      goto LABEL_10;
    }
    v14 = 1.0;
  }
  if (v14 >= *(double *)&qword_1ED4DACF0)
    goto LABEL_9;
LABEL_7:
  v15 = v14 + -0.092864;
  v16 = 8.799461;
LABEL_10:
  result = v15 / v16 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

_QWORD *HGAYCCToneCurveToLinearLUTInfo::HGAYCCToneCurveToLinearLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E6531CF8;
  return result;
}

void *HGAYCCToneCurveToLinearLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

void HGAYCCToneCurveToLinearLUTInfo::colorAtIndex(HGAYCCToneCurveToLinearLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  float v12;

  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
      v12 = powf(a2, 1.956);
    else
      v12 = (float)((float)((float)(a2 + -1.0) * 0.225) / 0.08) + 1.0;
  }
  else
  {
    v12 = powf(a2 / -0.08, 2.2) * -0.225;
  }
  *a5 = v12;
  *a6 = v12;
  *a7 = v12;
  *a8 = 1.0;
}

_QWORD *HGLinearToAYCCToneCurveLUTInfo::HGLinearToAYCCToneCurveLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E6531D48;
  return result;
}

void *HGLinearToAYCCToneCurveLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

void HGLinearToAYCCToneCurveLUTInfo::colorAtIndex(HGLinearToAYCCToneCurveLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  float v12;

  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
      v12 = powf(a2, 0.51125);
    else
      v12 = (float)((float)((float)(a2 + -1.0) * 0.08) / 0.225) + 1.0;
  }
  else
  {
    v12 = powf(a2 / -0.225, 0.45455) * -0.08;
  }
  *a5 = v12;
  *a6 = v12;
  *a7 = v12;
  *a8 = 1.0;
}

_QWORD *HG_ERsRGBToneCurveToLinearLUTInfo::HG_ERsRGBToneCurveToLinearLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E6531D98;
  return result;
}

void *HG_ERsRGBToneCurveToLinearLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

void HG_ERsRGBToneCurveToLinearLUTInfo::colorAtIndex(HG_ERsRGBToneCurveToLinearLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  float v13;
  float v14;

  v13 = fabsf(a2);
  if (v13 >= 0.04045)
    v14 = powf((float)(v13 * 0.94787) + 0.05213, 2.4);
  else
    v14 = v13 * 0.07734;
  if (a2 < 0.0)
    v14 = -v14;
  *a5 = v14;
  *a6 = v14;
  *a7 = v14;
  *a8 = 1.0;
}

_QWORD *HGLinearToERsRGBToneCurveLUTInfo::HGLinearToERsRGBToneCurveLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  _QWORD *result;

  result = (_QWORD *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &off_1E6531DE8;
  return result;
}

void *HGLinearToERsRGBToneCurveLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  void *v3;

  if (lpsrc
  {
    return HGApplyNDLUTInfo::isEqual(a1, v3);
  }
  else
  {
    return 0;
  }
}

void HGLinearToERsRGBToneCurveLUTInfo::colorAtIndex(HGLinearToERsRGBToneCurveLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  float v13;
  float v14;

  v13 = fabsf(a2);
  if (v13 >= 0.0031308)
    v14 = powf(v13 * 1.1371, 0.41667) + -0.055;
  else
    v14 = v13 * 12.92;
  if (a2 < 0.0)
    v14 = -v14;
  *a5 = v14;
  *a6 = v14;
  *a7 = v14;
  *a8 = 1.0;
}

void HGColorGammaLUTInfo::~HGColorGammaLUTInfo(HGColorGammaLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGColorGammaLUTInfo::duplicate(HGColorGammaLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  *(_OWORD *)(v2 + 20) = *(_OWORD *)((char *)this + 20);
  *(_QWORD *)v2 = &off_1E65317A8;
  *(_OWORD *)(v2 + 68) = *(_OWORD *)((char *)this + 68);
  *(_OWORD *)(v2 + 84) = *(_OWORD *)((char *)this + 84);
  *(_OWORD *)(v2 + 100) = *(_OWORD *)((char *)this + 100);
  *(_QWORD *)(v2 + 116) = *(_QWORD *)((char *)this + 116);
  *(_OWORD *)(v2 + 36) = *(_OWORD *)((char *)this + 36);
  result = *(__n128 *)((char *)this + 52);
  *(__n128 *)(v2 + 52) = result;
  return result;
}

void HGArriLogCDefaultToneCurveLUTInfo::~HGArriLogCDefaultToneCurveLUTInfo(HGArriLogCDefaultToneCurveLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGArriLogCDefaultToneCurveLUTInfo::duplicate(HGArriLogCDefaultToneCurveLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  *(_OWORD *)(v2 + 20) = *(_OWORD *)((char *)this + 20);
  *(_QWORD *)v2 = &off_1E65317F8;
  *(_OWORD *)(v2 + 72) = *(_OWORD *)((char *)this + 72);
  *(_OWORD *)(v2 + 88) = *(_OWORD *)((char *)this + 88);
  *(_OWORD *)(v2 + 104) = *(_OWORD *)((char *)this + 104);
  *(_BYTE *)(v2 + 120) = *((_BYTE *)this + 120);
  *(_OWORD *)(v2 + 40) = *(_OWORD *)((char *)this + 40);
  result = *(__n128 *)((char *)this + 56);
  *(__n128 *)(v2 + 56) = result;
  return result;
}

void HGArriLogCLinearizationLUTInfo::~HGArriLogCLinearizationLUTInfo(HGArriLogCLinearizationLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGArriLogCLinearizationLUTInfo::duplicate(HGArriLogCLinearizationLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  *(_OWORD *)(v2 + 20) = *(_OWORD *)((char *)this + 20);
  *(_QWORD *)v2 = &off_1E6531848;
  result = *(__n128 *)((char *)this + 36);
  *(__n128 *)(v2 + 36) = result;
  *(_DWORD *)(v2 + 52) = *((_DWORD *)this + 13);
  return result;
}

void HGArriLogC4LinearizationLUTInfo::~HGArriLogC4LinearizationLUTInfo(HGArriLogC4LinearizationLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGArriLogC4LinearizationLUTInfo::duplicate(HGArriLogC4LinearizationLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531898;
  return result;
}

void HGCanonLogToneCurveLUTInfo::~HGCanonLogToneCurveLUTInfo(HGCanonLogToneCurveLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGCanonLogToneCurveLUTInfo::duplicate(HGCanonLogToneCurveLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E65318E8;
  return result;
}

void HGCanonLogLinearizationLUTInfo::~HGCanonLogLinearizationLUTInfo(HGCanonLogLinearizationLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGCanonLogLinearizationLUTInfo::duplicate(HGCanonLogLinearizationLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531938;
  return result;
}

void HGCanonLog2LinearizationLUTInfo::~HGCanonLog2LinearizationLUTInfo(HGCanonLog2LinearizationLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGCanonLog2LinearizationLUTInfo::duplicate(HGCanonLog2LinearizationLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531988;
  return result;
}

void HGCanonLog3LinearizationLUTInfo::~HGCanonLog3LinearizationLUTInfo(HGCanonLog3LinearizationLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGCanonLog3LinearizationLUTInfo::duplicate(HGCanonLog3LinearizationLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E65319D8;
  return result;
}

void HGSonySLog2LinearizationLUTInfo::~HGSonySLog2LinearizationLUTInfo(HGSonySLog2LinearizationLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGSonySLog2LinearizationLUTInfo::duplicate(HGSonySLog2LinearizationLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531A28;
  return result;
}

void HGSonySLog3LinearizationLUTInfo::~HGSonySLog3LinearizationLUTInfo(HGSonySLog3LinearizationLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGSonySLog3LinearizationLUTInfo::duplicate(HGSonySLog3LinearizationLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531A78;
  return result;
}

void HGPanasonicVLogLinearizationLUTInfo::~HGPanasonicVLogLinearizationLUTInfo(HGPanasonicVLogLinearizationLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGPanasonicVLogLinearizationLUTInfo::duplicate(HGPanasonicVLogLinearizationLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531AC8;
  return result;
}

void HGNikonNLogLinearizationLUTInfo::~HGNikonNLogLinearizationLUTInfo(HGNikonNLogLinearizationLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGNikonNLogLinearizationLUTInfo::duplicate(HGNikonNLogLinearizationLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531B18;
  return result;
}

void HGBMDFilmLinearizationLUTInfo::~HGBMDFilmLinearizationLUTInfo(HGBMDFilmLinearizationLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGBMDFilmLinearizationLUTInfo::duplicate(HGBMDFilmLinearizationLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531B68;
  *(_BYTE *)(v2 + 36) = *((_BYTE *)this + 36);
  return result;
}

void HGAppleLogLinearizationLUTInfo::~HGAppleLogLinearizationLUTInfo(HGAppleLogLinearizationLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGAppleLogLinearizationLUTInfo::duplicate(HGAppleLogLinearizationLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531BB8;
  return result;
}

void HGDJIDLogLinearizationLUTInfo::~HGDJIDLogLinearizationLUTInfo(HGDJIDLogLinearizationLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGDJIDLogLinearizationLUTInfo::duplicate(HGDJIDLogLinearizationLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531C08;
  return result;
}

void HGFujifilmFLogLinearizationLUTInfo::~HGFujifilmFLogLinearizationLUTInfo(HGFujifilmFLogLinearizationLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGFujifilmFLogLinearizationLUTInfo::duplicate(HGFujifilmFLogLinearizationLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531C58;
  return result;
}

void HGFujifilmFLog2LinearizationLUTInfo::~HGFujifilmFLog2LinearizationLUTInfo(HGFujifilmFLog2LinearizationLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGFujifilmFLog2LinearizationLUTInfo::duplicate(HGFujifilmFLog2LinearizationLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531CA8;
  return result;
}

void HGAYCCToneCurveToLinearLUTInfo::~HGAYCCToneCurveToLinearLUTInfo(HGAYCCToneCurveToLinearLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGAYCCToneCurveToLinearLUTInfo::duplicate(HGAYCCToneCurveToLinearLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531CF8;
  return result;
}

void HGLinearToAYCCToneCurveLUTInfo::~HGLinearToAYCCToneCurveLUTInfo(HGLinearToAYCCToneCurveLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGLinearToAYCCToneCurveLUTInfo::duplicate(HGLinearToAYCCToneCurveLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531D48;
  return result;
}

void HG_ERsRGBToneCurveToLinearLUTInfo::~HG_ERsRGBToneCurveToLinearLUTInfo(HG_ERsRGBToneCurveToLinearLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HG_ERsRGBToneCurveToLinearLUTInfo::duplicate(HG_ERsRGBToneCurveToLinearLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531D98;
  return result;
}

void HGLinearToERsRGBToneCurveLUTInfo::~HGLinearToERsRGBToneCurveLUTInfo(HGLinearToERsRGBToneCurveLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

__n128 HGLinearToERsRGBToneCurveLUTInfo::duplicate(HGLinearToERsRGBToneCurveLUTInfo *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = *(_OWORD *)((char *)this + 8);
  result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(v2 + 20) = result;
  *(_QWORD *)v2 = &off_1E6531DE8;
  return result;
}

void HGColorClamp::HGColorClamp(HGColorClamp *this)
{
  _QWORD *v2;
  HgcColorClamp *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6531E38;
  v3 = (HgcColorClamp *)HGObject::operator new(0x1A0uLL);
  HgcColorClamp::HgcColorClamp(v3);
  *((_QWORD *)this + 51) = v3;
  __asm { FMOV            V0.4S, #1.0 }
  *((_OWORD *)this + 26) = _Q0;
  *((_QWORD *)this + 54) = 0;
  *((_QWORD *)this + 55) = 0;
}

void sub_1B2B15F28(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2B15F44(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGColorClamp::HGColorClamp(HGColorClamp *this, int32x2_t a2, int32x2_t a3)
{
  _QWORD *v4;
  HgcColorClamp *v5;

  HGNode::HGNode((HGNode *)this);
  *v4 = off_1E6531E38;
  v5 = (HgcColorClamp *)HGObject::operator new(0x1A0uLL);
  HgcColorClamp::HgcColorClamp(v5);
  *((_QWORD *)this + 51) = v5;
  *((int32x4_t *)this + 26) = vdupq_lane_s32(a3, 0);
  *((int32x4_t *)this + 27) = vdupq_lane_s32(a2, 0);
}

void sub_1B2B15FC4(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2B15FE0(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGColorClamp::~HGColorClamp(HGColorClamp *this)
{
  *(_QWORD *)this = off_1E6531E38;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 51) + 24))(*((_QWORD *)this + 51));
  HGNode::~HGNode((HGNode *)this);
}

{
  void *v2;

  *(_QWORD *)this = off_1E6531E38;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 51) + 24))(*((_QWORD *)this + 51));
  HGNode::~HGNode((HGNode *)this);
  HGObject::operator delete(v2);
}

uint64_t HGColorClamp::SetParameter(HGColorClamp *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if ((_DWORD)a2 == 1)
  {
    *((float *)this + 108) = a3;
    *((float *)this + 109) = a4;
    *((float *)this + 110) = a5;
    *((float *)this + 111) = a6;
    HGNode::ClearBits((HGNode *)this, a2, a7);
    return 1;
  }
  else if ((_DWORD)a2)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    *((float *)this + 104) = a3;
    *((float *)this + 105) = a4;
    *((float *)this + 106) = a5;
    *((float *)this + 107) = a6;
    HGNode::ClearBits((HGNode *)this, a2, a7);
    return 1;
  }
}

float *HGColorClamp::SetClampMaxValues(float *this, float a2, float a3, float a4, float a5)
{
  this[104] = a2;
  this[105] = a3;
  this[106] = a4;
  this[107] = a5;
  return this;
}

float *HGColorClamp::SetClampMinValues(float *this, float a2, float a3, float a4, float a5)
{
  this[108] = a2;
  this[109] = a3;
  this[110] = a4;
  this[111] = a5;
  return this;
}

uint64_t HGColorClamp::GetOutput(HGColorClamp *this, HGRenderer *a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *((_QWORD *)this + 51);
  v4 = (*(uint64_t (**)(HGColorClamp *, _QWORD))(*(_QWORD *)this + 128))(this, 0);
  (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v3 + 120))(v3, 0, v4);
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 0, *((float *)this + 104), *((float *)this + 105), *((float *)this + 106), *((float *)this + 107));
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 1, *((float *)this + 108), *((float *)this + 109), *((float *)this + 110), *((float *)this + 111));
  return *((_QWORD *)this + 51);
}

void HFDenseCRFInterface::HFDenseCRFInterface(HFDenseCRFInterface *this, const __CFUUID *a2)
{
  HFDenseCRF *v4;

  *(_QWORD *)this = &off_1E65320A0;
  v4 = (HFDenseCRF *)operator new();
  HFDenseCRF::HFDenseCRF(v4, a2);
  *((_QWORD *)this + 1) = v4;
}

void sub_1B2B161FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x81C40B8603338);
  _Unwind_Resume(a1);
}

void HFDenseCRFInterface::~HFDenseCRFInterface(HFDenseCRFInterface *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_1E65320A0;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_1E65320A0;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  JUMPOUT(0x1B5E29170);
}

uint64_t HFDenseCRFInterface::GenerateMask(HFDenseCRF **this, HGBitmap *a2, HGBitmap *a3, HGBitmap *a4, float a5, float a6, float a7, float a8, float a9, float a10, uint64_t a11)
{
  return HFDenseCRF::GenerateMask(this[1], a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

__n128 HgcSampler::Create(HgcSampler *this)
{
  uint64_t v1;
  __int128 v7;
  __n128 result;

  v1 = operator new();
  *(_OWORD *)v1 = xmmword_1B304F230;
  *(_OWORD *)(v1 + 16) = xmmword_1B304F240;
  *(_OWORD *)(v1 + 32) = xmmword_1B304F250;
  *(_OWORD *)(v1 + 48) = xmmword_1B304EFF0;
  *(_QWORD *)(v1 + 64) = 0;
  *(_QWORD *)(v1 + 72) = 0;
  __asm { FMOV            V0.4S, #1.0 }
  *(_QWORD *)&v7 = 0x4000000040000000;
  *((_QWORD *)&v7 + 1) = 0x4000000040000000;
  *(_OWORD *)(v1 + 80) = _Q0;
  *(_OWORD *)(v1 + 96) = v7;
  result.n128_u64[0] = 0x3F0000003F000000;
  result.n128_u64[1] = 0x3F0000003F000000;
  *(__n128 *)(v1 + 112) = result;
  *(_OWORD *)(v1 + 128) = xmmword_1B3525760;
  return result;
}

uint64_t HgcSampler::Destroy(uint64_t result)
{
  if (result)
    JUMPOUT(0x1B5E29170);
  return result;
}

uint64_t (*HgcSampler::Init(uint64_t a1, uint64_t a2, int a3))(int32x4_t *a1, float32x4_t *a2)
{
  int32x4_t v5;
  int32x4_t v6;
  float32x2_t v7;
  float32x4_t v8;
  float32x2_t v9;
  float32x4_t v10;
  char v11;
  uint64_t (*v12)(int32x4_t *, float32x4_t *);
  uint64_t (*v13)(int32x4_t *, float32x4_t *);
  float64x2_t v15[5];
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  (*(void (**)(uint64_t, float64x2_t *))(*(_QWORD *)a2 + 48))(a2, v15);
  v5 = (int32x4_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v15[0]), v15[1]);
  v6 = (int32x4_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v15[2]), v15[3]);
  *(int32x4_t *)a1 = v5;
  *(int32x4_t *)(a1 + 16) = v6;
  v7 = vcvt_f32_f64(v16);
  v8 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v17), v18);
  v9 = vcvt_f32_f64(v18);
  *(float32x4_t *)(a1 + 32) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v15[4]), v16);
  *(float32x4_t *)(a1 + 48) = v8;
  v10.i64[0] = vuzp2q_s32(vuzp2q_s32(v6, v5), v6).u64[0];
  v10.i64[1] = __PAIR64__(v9.u32[1], v7.u32[1]);
  v11 = vaddvq_s32((int32x4_t)vbicq_s8((int8x16_t)xmmword_1B30541E0, (int8x16_t)vceqq_f32(v10, (float32x4_t)xmmword_1B304EFF0)));
  v12 = GetAffineNearestTile;
  if (a3 > 0)
    v12 = GetAffineLinearTile;
  v13 = GetPerspNearestTile;
  if (a3 > 0)
    v13 = GetPerspLinearTile;
  if ((v11 & 0xF) != 0)
    return v13;
  else
    return v12;
}

uint64_t GetAffineLinearTile(int32x4_t *a1, float32x4_t *a2)
{
  int v2;
  int v3;
  float32x4_t v4;
  int64x2_t v5;
  float32x4_t v6;
  int v7;
  float32x4_t v8;
  uint64_t v9;
  uint64_t v10;
  const double *i64;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  const double *v16;
  float32x4_t v17;
  float32x4_t v18;
  uint64_t v19;
  int32x2_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  int32x2_t v30;
  float32x4_t *v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t *v35;
  float32x4_t *v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t *v43;
  float32x4_t v44;

  v2 = a1->i32[3] - a1->i32[1];
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = (float32x4_t)vdupq_lane_s64(vcvtq_f32_s32(*a1).i64[0], 0);
    v5 = (int64x2_t)vsubq_f32(vcvtq_f32_s32(a1[13]), v4);
    v6 = (float32x4_t)vdupq_lane_s64(v5.i64[0], 0);
    v7 = a1->i32[2] - a1->i32[0];
    v8 = vsubq_f32((float32x4_t)vdupq_laneq_s64(v5, 1), a2[6]);
    v9 = a1[5].i64[0];
    v10 = a1[5].i32[2];
    i64 = (const double *)a2[1].i64;
    v12 = (float32x4_t)vld1q_dup_f64(i64);
    v13 = (float32x4_t)vdupq_lane_s64(vaddq_f32(*a2, *a2).i64[0], 0);
    v14.i64[0] = a2[4].i64[0];
    v14.i64[1] = a2->i64[0];
    v15 = vaddq_f32(a2[7], v4);
    v16 = (const double *)a2[3].i64;
    v17 = (float32x4_t)vld1q_dup_f64(v16);
    v18 = vaddq_f32(v14, vsubq_f32(vaddq_f32(vmulq_f32(v12, (float32x4_t)vsriq_n_s64((int64x2_t)v15, (int64x2_t)v15, 0x20uLL)), vaddq_f32(v17, vmulq_f32((float32x4_t)vdupq_lane_s64(a2->i64[0], 0), (float32x4_t)vsliq_n_s64((int64x2_t)v15, (int64x2_t)v15, 0x20uLL)))), v15));
    v19 = a1[1].i64[0];
    v20 = vdup_n_s32(v10);
    v21 = 16 * a1[1].i32[2];
    while (v7 < 2)
    {
      v22 = 0;
      v24 = v18;
      if (v7 > 0)
        goto LABEL_10;
LABEL_3:
      v18 = vaddq_f32(v12, v18);
      ++v3;
      v19 += v21;
      if (v3 == v2)
        return 0;
    }
    v22 = 0;
    v23 = v7;
    v24 = v18;
    do
    {
      v25 = vmaxq_f32(v24, v6);
      v26 = vminq_f32(v25, v8);
      v27 = vcvtq_f32_s32(vcvtq_s32_f32(v26));
      v28 = vaddq_f32(v27, vcvtq_f32_s32(vcgtq_f32(v27, v26)));
      v29 = (int8x16_t)vshlq_n_s32(vcvtq_s32_f32(v28), 2uLL);
      v30 = (int32x2_t)vextq_s8(v29, v29, 8uLL).u64[0];
      *(int32x2_t *)v29.i8 = vmla_s32(vzip1_s32(*(int32x2_t *)v29.i8, v30), vzip2_s32(*(int32x2_t *)v29.i8, v30), v20);
      v31 = (float32x4_t *)(v9 + 4 * v29.i32[0]);
      v32 = vminq_f32(vsubq_f32(v25, v28), a2[5]);
      v33 = vaddq_f32(*v31, vmulq_n_f32(vsubq_f32(v31[1], *v31), v32.f32[0]));
      v34 = vaddq_f32(v31[v10], vmulq_n_f32(vsubq_f32(v31[v10 + 1], v31[v10]), v32.f32[0]));
      v35 = (float32x4_t *)(v19 + 16 * v22);
      *v35 = vaddq_f32(v33, vmulq_lane_f32(vsubq_f32(v34, v33), *(float32x2_t *)v32.f32, 1));
      v36 = (float32x4_t *)(v9 + 4 * v29.i32[1]);
      v37 = vaddq_f32(*v36, vmulq_laneq_f32(vsubq_f32(v36[1], *v36), v32, 2));
      v35[1] = vaddq_f32(v37, vmulq_laneq_f32(vsubq_f32(vaddq_f32(v36[v10], vmulq_laneq_f32(vsubq_f32(v36[v10 + 1], v36[v10]), v32, 2)), v37), v32, 3));
      v24 = vaddq_f32(v13, v24);
      v22 += 2;
      v23 -= 2;
    }
    while (v23 > 1);
    v22 = v22;
    if ((int)v22 >= v7)
      goto LABEL_3;
    do
    {
LABEL_10:
      v38 = vmaxq_f32(v24, v6);
      v39 = vminq_f32(v38, v8);
      v40 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v41 = vaddq_f32(v40, vcvtq_f32_s32(vcgtq_f32(v40, v39)));
      v42 = vsubq_f32(v38, v41);
      v41.i64[0] = vshlq_n_s32(vcvtq_s32_f32(v41), 2uLL).u64[0];
      v42.i64[0] = vminq_f32(v42, a2[5]).u64[0];
      v43 = (float32x4_t *)(v9 + 4 * (v41.i32[0] + v41.i32[1] * (int)v10));
      v44 = vaddq_f32(*v43, vmulq_n_f32(vsubq_f32(v43[1], *v43), v42.f32[0]));
      *(float32x4_t *)(v19 + 16 * v22) = vaddq_f32(v44, vmulq_lane_f32(vsubq_f32(vaddq_f32(v43[v10], vmulq_n_f32(vsubq_f32(v43[v10 + 1], v43[v10]), v42.f32[0])), v44), *(float32x2_t *)v42.f32, 1));
      v24 = vaddq_f32(v24, *a2);
      ++v22;
    }
    while (v22 < v7);
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetAffineNearestTile(int32x4_t *a1, float32x4_t *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t v4;
  float32x4_t v5;
  int64x2_t v6;
  float32x4_t v7;
  float32x4_t v8;
  uint64_t v9;
  unsigned int v10;
  const double *i64;
  float32x4_t v12;
  uint64_t v13;
  const double *v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  uint64_t v18;
  int v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int32x4_t v23;
  _OWORD *v24;
  uint64_t v25;
  _OWORD *v26;
  unint64_t v27;
  _OWORD *v28;
  _OWORD *v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int32x4_t v33;
  int32x4_t v34;
  int32x4_t v35;
  int32x4_t v36;
  int32x4_t v37;
  _OWORD *v38;
  float32x4_t v39;
  int32x4_t v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int32x4_t v46;

  v2 = a1->i32[3] - a1->i32[1];
  if (v2 >= 1)
  {
    v3 = (a1->i32[2] - a1->i32[0]);
    v4 = (float32x4_t)vdupq_lane_s64(vcvtq_f32_s32(*a1).i64[0], 0);
    v5 = vaddq_f32(a2[7], v4);
    v6 = (int64x2_t)vaddq_f32(a2[8], vsubq_f32(vcvtq_f32_s32(a1[13]), v4));
    v7 = (float32x4_t)vdupq_lane_s64(v6.i64[0], 0);
    v8 = (float32x4_t)vdupq_laneq_s64(v6, 1);
    v9 = a1[5].i64[0];
    v10 = a1[5].u32[2];
    i64 = (const double *)a2[1].i64;
    v12 = (float32x4_t)vld1q_dup_f64(i64);
    v13 = a1[1].i64[0];
    v14 = (const double *)a2[3].i64;
    v15 = (float32x4_t)vld1q_dup_f64(v14);
    v16 = vsubq_f32(vaddq_f32(vmulq_f32(v12, (float32x4_t)vsriq_n_s64((int64x2_t)v5, (int64x2_t)v5, 0x20uLL)), vaddq_f32(v15, vmulq_f32((float32x4_t)vdupq_lane_s64(a2->i64[0], 0), (float32x4_t)vsliq_n_s64((int64x2_t)v5, (int64x2_t)v5, 0x20uLL)))), v4);
    v5.i64[0] = a2[4].i64[0];
    v5.i64[1] = a2->i64[0];
    v17 = vaddq_f32(v5, v16);
    v18 = a1[1].i32[2];
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v41 = 0;
        v42 = 16 * (a1->i32[2] - a1->i32[0]);
        do
        {
          v43 = 0;
          v44 = v17;
          do
          {
            v45 = vminq_f32(vmaxq_f32(v44, v7), v8);
            v46 = vcvtq_s32_f32(v45);
            v45.i64[0] = vshlq_n_s32(vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)), 2uLL).u64[0];
            *(_OWORD *)(v13 + v43) = *(_OWORD *)(v9 + 4 * (int)(v45.i32[0] + v45.i32[1] * v10));
            v44 = vaddq_f32(v44, *a2);
            v43 += 16;
          }
          while (v42 != v43);
          v17 = vaddq_f32(v12, v17);
          ++v41;
          v13 += 16 * v18;
        }
        while (v41 != v2);
      }
    }
    else
    {
      v19 = 0;
      v20 = vaddq_f32(*a2, *a2);
      v21 = (float32x4_t)vdupq_lane_s64(v20.i64[0], 0);
      v22 = (float32x4_t)vdupq_lane_s64(vaddq_f32(v20, v20).i64[0], 0);
      v23 = vdupq_n_s32(v10);
      v24 = (_OWORD *)(v13 + 32);
      v25 = 16 * v18;
      v26 = (_OWORD *)(v13 + 64);
      do
      {
        v27 = 0;
        v28 = v26;
        v29 = v24;
        v30 = v17;
        do
        {
          v31 = vminq_f32(vmaxq_f32(v30, v7), v8);
          v32 = vminq_f32(vmaxq_f32(vaddq_f32(v21, v30), v7), v8);
          v33 = vcvtq_s32_f32(v31);
          v34 = vcvtq_s32_f32(v32);
          v35 = vshlq_n_s32(vaddq_s32(v33, vcgtq_f32(vcvtq_f32_s32(v33), v31)), 2uLL);
          v36 = vshlq_n_s32(vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v32)), 2uLL);
          v37 = vmlaq_s32(vuzp1q_s32(v35, v36), vuzp2q_s32(v35, v36), v23);
          *(v29 - 2) = *(_OWORD *)(v9 + 4 * v37.i32[0]);
          *(v29 - 1) = *(_OWORD *)(v9 + 4 * v37.i32[1]);
          v38 = v28;
          *v29 = *(_OWORD *)(v9 + 4 * v37.i32[2]);
          v29[1] = *(_OWORD *)(v9 + 4 * v37.i32[3]);
          v30 = vaddq_f32(v22, v30);
          v27 += 4;
          v29 += 4;
          v28 += 4;
        }
        while ((uint64_t)v27 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v27)
        {
          do
          {
            v39 = vminq_f32(vmaxq_f32(v30, v7), v8);
            v40 = vcvtq_s32_f32(v39);
            v39.i64[0] = vshlq_n_s32(vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)), 2uLL).u64[0];
            *v38++ = *(_OWORD *)(v9 + 4 * (int)(v39.i32[0] + v39.i32[1] * v10));
            v30 = vaddq_f32(v30, *a2);
            ++v27;
          }
          while (v27 < v3);
        }
        v17 = vaddq_f32(v12, v17);
        ++v19;
        v24 = (_OWORD *)((char *)v24 + v25);
        v26 = (_OWORD *)((char *)v26 + v25);
      }
      while (v19 != v2);
    }
  }
  return 0;
}

uint64_t GetPerspLinearTile(int32x4_t *a1, float32x4_t *a2)
{
  int v2;
  int v3;
  float32x4_t v4;
  int v5;
  float32x4_t v6;
  int64x2_t v7;
  float32x4_t v8;
  float32x4_t v9;
  uint64_t v10;
  float32x4_t v11;
  int32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  uint64_t v17;
  int32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  uint64_t v21;
  int32x2_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v34;
  int32x2_t v35;
  __int32 v36;
  float32x4_t *v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t *v41;
  float32x4_t *v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t *v50;
  float32x4_t v51;

  v2 = a1->i32[3] - a1->i32[1];
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = (float32x4_t)vdupq_lane_s64(vcvtq_f32_s32(*a1).i64[0], 0);
    v5 = a1->i32[2] - a1->i32[0];
    v6 = vaddq_f32(a2[7], v4);
    v7 = (int64x2_t)vsubq_f32(vcvtq_f32_s32(a1[13]), v4);
    v8 = (float32x4_t)vdupq_lane_s64(v7.i64[0], 0);
    v9 = vsubq_f32((float32x4_t)vdupq_laneq_s64(v7, 1), a2[6]);
    v10 = a1[5].i64[0];
    v11 = a2[1];
    v12 = (int32x4_t)vaddq_f32(*a2, *a2);
    v13 = (float32x4_t)vdupq_lane_s64(v11.i64[0], 0);
    v14 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3);
    v15 = (float32x4_t)vdupq_lane_s64(v12.i64[0], 0);
    v16 = (float32x4_t)vdupq_laneq_s32(v12, 3);
    v17 = a1[5].i32[2];
    v19 = vaddq_f32(vaddq_f32(a2[3], vmulq_n_f32(*a2, v6.f32[0])), vmulq_lane_f32(v11, *(float32x2_t *)v6.f32, 1));
    v18 = (int32x4_t)vaddq_f32(*a2, v19);
    *(int32x2_t *)v20.f32 = vdup_laneq_s32((int32x4_t)v19, 3);
    v19.i64[1] = v18.i64[0];
    *(int32x2_t *)&v20.u32[2] = vdup_laneq_s32(v18, 3);
    v21 = a1[1].i64[0];
    v22 = vdup_n_s32(v17);
    v23 = 16 * a1[1].i32[2];
    while (v5 < 2)
    {
      v24 = 0;
      v27 = v20;
      v26 = v19;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v19 = vaddq_f32(v13, v19);
      v20 = vaddq_f32(v14, v20);
      ++v3;
      v21 += v23;
      if (v3 == v2)
        return 0;
    }
    v24 = 0;
    v25 = v5;
    v26 = v19;
    v27 = v20;
    do
    {
      v28 = vrecpeq_f32(v27);
      v29 = vmulq_f32(v28, vrecpsq_f32(v27, v28));
      v30 = vmaxq_f32(vsubq_f32(vmulq_f32(v26, vmulq_f32(v29, vrecpsq_f32(v27, v29))), v6), v8);
      v31 = vminq_f32(v30, v9);
      v32 = vcvtq_f32_s32(vcvtq_s32_f32(v31));
      v33 = vaddq_f32(v32, vcvtq_f32_s32(vcgtq_f32(v32, v31)));
      v34 = (int8x16_t)vshlq_n_s32(vcvtq_s32_f32(v33), 2uLL);
      v35 = (int32x2_t)vextq_s8(v34, v34, 8uLL).u64[0];
      *(int32x2_t *)v34.i8 = vmla_s32(vzip1_s32(*(int32x2_t *)v34.i8, v35), vzip2_s32(*(int32x2_t *)v34.i8, v35), v22);
      v36 = v34.i32[1];
      v37 = (float32x4_t *)(v10 + 4 * v34.i32[0]);
      v38 = vminq_f32(vsubq_f32(v30, v33), a2[5]);
      v39 = vaddq_f32(*v37, vmulq_n_f32(vsubq_f32(v37[1], *v37), v38.f32[0]));
      v40 = vsubq_f32(vaddq_f32(v37[v17], vmulq_n_f32(vsubq_f32(v37[v17 + 1], v37[v17]), v38.f32[0])), v39);
      v41 = (float32x4_t *)(v21 + 16 * v24);
      *v41 = vaddq_f32(v39, vmulq_lane_f32(v40, *(float32x2_t *)v38.f32, 1));
      v42 = (float32x4_t *)(v10 + 4 * v36);
      v43 = vaddq_f32(*v42, vmulq_laneq_f32(vsubq_f32(v42[1], *v42), v38, 2));
      v41[1] = vaddq_f32(v43, vmulq_laneq_f32(vsubq_f32(vaddq_f32(v42[v17], vmulq_laneq_f32(vsubq_f32(v42[v17 + 1], v42[v17]), v38, 2)), v43), v38, 3));
      v26 = vaddq_f32(v15, v26);
      v27 = vaddq_f32(v16, v27);
      v24 += 2;
      v25 -= 2;
    }
    while (v25 > 1);
    v24 = v24;
    if ((int)v24 >= v5)
      goto LABEL_3;
    do
    {
LABEL_10:
      v44 = vrecpeq_f32(v27);
      v45 = vmulq_f32(v44, vrecpsq_f32(v27, v44));
      v46 = vmaxq_f32(vsubq_f32(vmulq_f32(v26, vmulq_f32(v45, vrecpsq_f32(v27, v45))), v6), v8);
      v47 = vminq_f32(v46, v9);
      v48 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      v49 = vaddq_f32(v48, vcvtq_f32_s32(vcgtq_f32(v48, v47)));
      v46.i64[0] = vminq_f32(vsubq_f32(v46, v49), a2[5]).u64[0];
      v49.i64[0] = vshlq_n_s32(vcvtq_s32_f32(v49), 2uLL).u64[0];
      v50 = (float32x4_t *)(v10 + 4 * (v49.i32[0] + v49.i32[1] * (int)v17));
      v51 = vaddq_f32(*v50, vmulq_n_f32(vsubq_f32(v50[1], *v50), v46.f32[0]));
      *(float32x4_t *)(v21 + 16 * v24) = vaddq_f32(v51, vmulq_lane_f32(vsubq_f32(vaddq_f32(v50[v17], vmulq_n_f32(vsubq_f32(v50[v17 + 1], v50[v17]), v46.f32[0])), v51), *(float32x2_t *)v46.f32, 1));
      v26 = vaddq_f32(v26, *a2);
      v27 = vaddq_f32(v27, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 3));
      ++v24;
    }
    while (v24 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetPerspNearestTile(int32x4_t *a1, float32x4_t *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t v4;
  int64x2_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  uint64_t v9;
  unsigned int v10;
  _OWORD *v11;
  float32x4_t v12;
  int32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  uint64_t v18;
  int v19;
  int32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int32x2_t v23;
  uint64_t v24;
  _OWORD *v25;
  unint64_t v26;
  _OWORD *v27;
  int v28;
  float32x4_t v29;
  float32x4_t v30;
  _OWORD *v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int32x4_t v35;
  int8x16_t v36;
  _OWORD *v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int32x4_t v45;

  v2 = a1->i32[3] - a1->i32[1];
  if (v2 >= 1)
  {
    v3 = (a1->i32[2] - a1->i32[0]);
    v4 = (float32x4_t)vdupq_lane_s64(vcvtq_f32_s32(*a1).i64[0], 0);
    v5 = (int64x2_t)vsubq_f32(vcvtq_f32_s32(a1[13]), v4);
    v6 = (float32x4_t)vdupq_lane_s64(v5.i64[0], 0);
    v7 = vaddq_f32(a2[7], v4);
    v8 = vsubq_f32((float32x4_t)vdupq_laneq_s64(v5, 1), a2[5]);
    v9 = a1[5].i64[0];
    v10 = a1[5].u32[2];
    v11 = (_OWORD *)a1[1].i64[0];
    v12 = a2[1];
    v15 = vaddq_f32(vaddq_f32(a2[3], vmulq_n_f32(*a2, v7.f32[0])), vmulq_lane_f32(v12, *(float32x2_t *)v7.f32, 1));
    v13 = (int32x4_t)vaddq_f32(*a2, v15);
    *(int32x2_t *)v14.f32 = vdup_laneq_s32((int32x4_t)v15, 3);
    *(int32x2_t *)&v14.u32[2] = vdup_laneq_s32(v13, 3);
    v15.i64[1] = v13.i64[0];
    v16 = (float32x4_t)vdupq_lane_s64(v12.i64[0], 0);
    v17 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3);
    v18 = a1[1].i32[2];
    if ((int)v3 < 2)
    {
      if ((_DWORD)v3 == 1)
      {
        do
        {
          v42 = vrecpeq_f32(v14);
          v43 = vmulq_f32(v42, vrecpsq_f32(v14, v42));
          v44 = vaddq_f32(vminq_f32(vmaxq_f32(vsubq_f32(vmulq_f32(v15, vmulq_f32(v43, vrecpsq_f32(v14, v43))), v7), v6), v8), a2[7]);
          v45 = vcvtq_s32_f32(v44);
          v44.i64[0] = vshlq_n_s32(vaddq_s32(v45, vcgtq_f32(vcvtq_f32_s32(v45), v44)), 2uLL).u64[0];
          *v11 = *(_OWORD *)(v9 + 4 * (int)(v44.i32[0] + v44.i32[1] * v10));
          v15 = vaddq_f32(v16, v15);
          v14 = vaddq_f32(v17, v14);
          v11 += v18;
          --v2;
        }
        while (v2);
      }
    }
    else
    {
      v19 = 0;
      v20 = (int32x4_t)vaddq_f32(*a2, *a2);
      v21 = (float32x4_t)vdupq_lane_s64(v20.i64[0], 0);
      v22 = (float32x4_t)vdupq_laneq_s32(v20, 3);
      v23 = vdup_n_s32(v10);
      v24 = 16 * v18;
      v25 = v11 + 2;
      do
      {
        v26 = 0;
        v27 = v25;
        v28 = v3;
        v29 = v15;
        v30 = v14;
        do
        {
          v31 = v27;
          v32 = vrecpeq_f32(v30);
          v33 = vmulq_f32(v32, vrecpsq_f32(v30, v32));
          v34 = vaddq_f32(vminq_f32(vmaxq_f32(vsubq_f32(vmulq_f32(v29, vmulq_f32(v33, vrecpsq_f32(v30, v33))), v7), v6), v8), a2[7]);
          v35 = vcvtq_s32_f32(v34);
          v36 = (int8x16_t)vshlq_n_s32(vaddq_s32(v35, vcgtq_f32(vcvtq_f32_s32(v35), v34)), 2uLL);
          v35.i64[0] = vextq_s8(v36, v36, 8uLL).u64[0];
          *(int32x2_t *)v36.i8 = vmla_s32(vzip1_s32(*(int32x2_t *)v36.i8, *(int32x2_t *)v35.i8), vzip2_s32(*(int32x2_t *)v36.i8, *(int32x2_t *)v35.i8), v23);
          v37 = &v11[v26];
          *v37 = *(_OWORD *)(v9 + 4 * v36.i32[0]);
          v37[1] = *(_OWORD *)(v9 + 4 * v36.i32[1]);
          v29 = vaddq_f32(v21, v29);
          v30 = vaddq_f32(v22, v30);
          v26 += 2;
          v28 -= 2;
          v27 += 2;
        }
        while (v28 > 1);
        if ((int)v3 > (int)v26)
        {
          do
          {
            v38 = vrecpeq_f32(v30);
            v39 = vmulq_f32(v38, vrecpsq_f32(v30, v38));
            v40 = vaddq_f32(vminq_f32(vmaxq_f32(vsubq_f32(vmulq_f32(v29, vmulq_f32(v39, vrecpsq_f32(v30, v39))), v7), v6), v8), a2[7]);
            v41 = vcvtq_s32_f32(v40);
            v40.i64[0] = vshlq_n_s32(vaddq_s32(v41, vcgtq_f32(vcvtq_f32_s32(v41), v40)), 2uLL).u64[0];
            *v31++ = *(_OWORD *)(v9 + 4 * (int)(v40.i32[0] + v40.i32[1] * v10));
            v29 = vaddq_f32(v29, *a2);
            v30 = vaddq_f32(v30, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 3));
            ++v26;
          }
          while (v26 < v3);
        }
        v15 = vaddq_f32(v16, v15);
        v14 = vaddq_f32(v17, v14);
        ++v19;
        v11 = (_OWORD *)((char *)v11 + v24);
        v25 = (_OWORD *)((char *)v25 + v24);
      }
      while (v19 != v2);
    }
  }
  return 0;
}

const char *GetApply1DProgram(HGRenderer *a1, int a2, int a3)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (a3)
  {
    if (a2)
    {
      if (Target == 396048)
      {
        if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
          return "//Metal1.0     \n"
                 "//LEN=0000000695\n"
                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                 "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
                 "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
                 "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
                 "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
                 "{\n"
                 "    const half4 c0 = half4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
                 "    half4 r0, r1, r2, r3;\n"
                 "    FragmentOut output;\n"
                 "\n"
                 "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
                 "    r1 = r0*half4(hg_Params[0].xxxx) + half4(hg_Params[0].yyyy);\n"
                 "    r1 = fmax(r1, c0.xxxx);\n"
                 "    r1 = fmin(r1, half4(hg_Params[1]));\n"
                 "    r2.xyz = r1.xyz*half3(hg_Params[0].www);\n"
                 "    r2.xyz = floor(r2.xyz);\n"
                 "    r2.xyz = r2.xyz + c0.yyy;\n"
                 "    r1 = r1 - half4(hg_Params[0].zzzz)*floor(r1/half4(hg_Params[0].zzzz));\n"
                 "    r1 = r1 + c0.yyyy;\n"
                 "    r3.x = r1.x;\n"
                 "    r3.y = r2.x;\n"
                 "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
                 "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
                 "    r1.x = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).x;\n"
                 "    r3.x = r1.y;\n"
                 "    r3.y = r2.y;\n"
                 "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
                 "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
                 "    r1.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).y;\n"
                 "    r3.x = r1.z;\n"
                 "    r3.y = r2.z;\n"
                 "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
                 "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
                 "    r1.z = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).z;\n"
                 "    output.color0 = select(float4(r1), float4(r0), hg_Params[2] < 0.00000h);\n"
                 "    return output;\n"
                 "}\n"
                 "//MD5=088a2ea0:e59dd2d6:fba2ff6e:81cad2ec\n"
                 "//SIG=00400000:00000001:00000001:00000003:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
        else
          return "//Metal1.0     \n"
                 "//LEN=0000000601\n"
                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                 "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
                 "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
                 "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
                 "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
                 "{\n"
                 "    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
                 "    float4 r0, r1, r2, r3;\n"
                 "    FragmentOut output;\n"
                 "\n"
                 "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
                 "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
                 "    r1 = fmax(r1, c0.xxxx);\n"
                 "    r1 = fmin(r1, hg_Params[1]);\n"
                 "    r2.xyz = r1.xyz*hg_Params[0].www;\n"
                 "    r2.xyz = floor(r2.xyz);\n"
                 "    r2.xyz = r2.xyz + c0.yyy;\n"
                 "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
                 "    r1 = r1 + c0.yyyy;\n"
                 "    r3.x = r1.x;\n"
                 "    r3.y = r2.x;\n"
                 "    r3.xy = r3.xy + hg_Params[3].xy;\n"
                 "    r3.xy = r3.xy*hg_Params[3].zw;\n"
                 "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
                 "    r3.x = r1.y;\n"
                 "    r3.y = r2.y;\n"
                 "    r3.xy = r3.xy + hg_Params[3].xy;\n"
                 "    r3.xy = r3.xy*hg_Params[3].zw;\n"
                 "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
                 "    r3.x = r1.z;\n"
                 "    r3.y = r2.z;\n"
                 "    r3.xy = r3.xy + hg_Params[3].xy;\n"
                 "    r3.xy = r3.xy*hg_Params[3].zw;\n"
                 "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
                 "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
                 "    return output;\n"
                 "}\n"
                 "//MD5=9263a2c0:8288b26d:8fbddfa1:77a5bd13\n"
                 "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
      }
      if (Target > 0x6060F
        && !(*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
      {
        return "//GLfs2.0      \n"
               "//LEN=000000068d\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#endif\n"
               "#define defaultp mediump\n"
               "uniform defaultp sampler2D hg_Texture0;\n"
               "uniform defaultp sampler2D hg_Texture1;\n"
               "uniform mediump vec4 hg_ProgramLocal0;\n"
               "uniform mediump vec4 hg_ProgramLocal1;\n"
               "uniform mediump vec4 hg_ProgramLocal2;\n"
               "uniform mediump vec4 hg_ProgramLocal3;\n"
               "varying highp vec4 hg_TexCoord0;\n"
               "void main()\n"
               "{\n"
               "    const mediump vec4 c0 = vec4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
               "    mediump vec4 r0, r1, r2, r3;\n"
               "\n"
               "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
               "    r1 = r0*hg_ProgramLocal0.xxxx + hg_ProgramLocal0.yyyy;\n"
               "    r1 = max(r1, c0.xxxx);\n"
               "    r1 = min(r1, hg_ProgramLocal1);\n"
               "    r2.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
               "    r2.xyz = floor(r2.xyz);\n"
               "    r2.xyz = r2.xyz + c0.yyy;\n"
               "    r1 = mod(r1, hg_ProgramLocal0.zzzz);\n"
               "    r1 = r1 + c0.yyyy;\n"
               "    r3.x = r1.x;\n"
               "    r3.y = r2.x;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.x = texture2D(hg_Texture1, r3.xy).x;\n"
               "    r3.x = r1.y;\n"
               "    r3.y = r2.y;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.y = texture2D(hg_Texture1, r3.xy).y;\n"
               "    r3.x = r1.z;\n"
               "    r3.y = r2.z;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.z = texture2D(hg_Texture1, r3.xy).z;\n"
               "    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r1.x, hg_ProgramLocal2.y < 0.00000 ? r0.y :"
               " r1.y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r1.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r1.w);\n"
               "}\n"
               "//MD5=a5cfaee8:157e3765:82b70125:1b812651\n"
               "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
      }
      return 0;
    }
    if (Target != 396048)
    {
      if (Target > 0x6060F
        && !(*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
      {
        return "//GLfs2.0      \n"
               "//LEN=0000000715\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#endif\n"
               "#define defaultp mediump\n"
               "uniform defaultp sampler2D hg_Texture0;\n"
               "uniform defaultp sampler2D hg_Texture1;\n"
               "uniform mediump vec4 hg_ProgramLocal0;\n"
               "uniform mediump vec4 hg_ProgramLocal1;\n"
               "uniform mediump vec4 hg_ProgramLocal2;\n"
               "uniform mediump vec4 hg_ProgramLocal3;\n"
               "varying highp vec4 hg_TexCoord0;\n"
               "void main()\n"
               "{\n"
               "    const mediump vec4 c0 = vec4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
               "    mediump vec4 r0, r1, r2, r3;\n"
               "\n"
               "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
               "    r1 = r0*hg_ProgramLocal0.xxxx + hg_ProgramLocal0.yyyy;\n"
               "    r1 = max(r1, c0.xxxx);\n"
               "    r1 = min(r1, hg_ProgramLocal1);\n"
               "    r2 = r1*hg_ProgramLocal0.wwww;\n"
               "    r2 = floor(r2);\n"
               "    r2 = r2 + c0.yyyy;\n"
               "    r1 = mod(r1, hg_ProgramLocal0.zzzz);\n"
               "    r1 = r1 + c0.yyyy;\n"
               "    r3.x = r1.x;\n"
               "    r3.y = r2.x;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.x = texture2D(hg_Texture1, r3.xy).x;\n"
               "    r3.x = r1.y;\n"
               "    r3.y = r2.y;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.y = texture2D(hg_Texture1, r3.xy).y;\n"
               "    r3.x = r1.z;\n"
               "    r3.y = r2.z;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.z = texture2D(hg_Texture1, r3.xy).z;\n"
               "    r3.x = r1.w;\n"
               "    r3.y = r2.w;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.w = texture2D(hg_Texture1, r3.xy).w;\n"
               "    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r1.x, hg_ProgramLocal2.y < 0.00000 ? r0.y :"
               " r1.y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r1.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r1.w);\n"
               "}\n"
               "//MD5=7949d19f:647deb0d:606cf61d:25a04486\n"
               "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
      }
      return 0;
    }
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000073b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*half4(hg_Params[0].xxxx) + half4(hg_Params[0].yyyy);\n"
             "    r1 = fmax(r1, c0.xxxx);\n"
             "    r1 = fmin(r1, half4(hg_Params[1]));\n"
             "    r2 = r1*half4(hg_Params[0].wwww);\n"
             "    r2 = floor(r2);\n"
             "    r2 = r2 + c0.yyyy;\n"
             "    r1 = r1 - half4(hg_Params[0].zzzz)*floor(r1/half4(hg_Params[0].zzzz));\n"
             "    r1 = r1 + c0.yyyy;\n"
             "    r3.x = r1.x;\n"
             "    r3.y = r2.x;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.x = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).x;\n"
             "    r3.x = r1.y;\n"
             "    r3.y = r2.y;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).y;\n"
             "    r3.x = r1.z;\n"
             "    r3.y = r2.z;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.z = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).z;\n"
             "    r3.x = r1.w;\n"
             "    r3.y = r2.w;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.w = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).w;\n"
             "    output.color0 = select(float4(r1), float4(r0), hg_Params[2] < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b5146dd3:d04f9178:3aab6ef7:97b6a091\n"
             "//SIG=00400000:00000001:00000001:00000003:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000068a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
             "    r1 = fmax(r1, c0.xxxx);\n"
             "    r1 = fmin(r1, hg_Params[1]);\n"
             "    r2 = r1*hg_Params[0].wwww;\n"
             "    r2 = floor(r2);\n"
             "    r2 = r2 + c0.yyyy;\n"
             "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
             "    r1 = r1 + c0.yyyy;\n"
             "    r3.x = r1.x;\n"
             "    r3.y = r2.x;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
             "    r3.x = r1.y;\n"
             "    r3.y = r2.y;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
             "    r3.x = r1.z;\n"
             "    r3.y = r2.z;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
             "    r3.x = r1.w;\n"
             "    r3.y = r2.w;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.w = hg_Texture1.sample(hg_Sampler1, r3.xy).w;\n"
             "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=aa6d9d69:00cc6589:b7bb52c4:fb672a48\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
  else if (a2)
  {
    if (Target != 396048)
    {
      if (Target > 0x6060F
        && !(*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
      {
        return "//GLfs2.0      \n"
               "//LEN=00000006b2\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#endif\n"
               "#define defaultp mediump\n"
               "uniform defaultp sampler2D hg_Texture0;\n"
               "uniform defaultp sampler2D hg_Texture1;\n"
               "uniform mediump vec4 hg_ProgramLocal0;\n"
               "uniform mediump vec4 hg_ProgramLocal1;\n"
               "uniform mediump vec4 hg_ProgramLocal2;\n"
               "uniform mediump vec4 hg_ProgramLocal3;\n"
               "varying highp vec4 hg_TexCoord0;\n"
               "void main()\n"
               "{\n"
               "    const mediump vec4 c0 = vec4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
               "    mediump vec4 r0, r1, r2, r3;\n"
               "\n"
               "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
               "    r1 = r0*hg_ProgramLocal0.xxxx + hg_ProgramLocal0.yyyy;\n"
               "    r1 = max(r1, c0.xxxx);\n"
               "    r1 = min(r1, hg_ProgramLocal1);\n"
               "    r1 = floor(r1 + vec4(0.500000));\n"
               "    r2.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
               "    r2.xyz = floor(r2.xyz);\n"
               "    r2.xyz = r2.xyz + c0.yyy;\n"
               "    r1 = mod(r1, hg_ProgramLocal0.zzzz);\n"
               "    r1 = r1 + c0.yyyy;\n"
               "    r3.x = r1.x;\n"
               "    r3.y = r2.x;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.x = texture2D(hg_Texture1, r3.xy).x;\n"
               "    r3.x = r1.y;\n"
               "    r3.y = r2.y;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.y = texture2D(hg_Texture1, r3.xy).y;\n"
               "    r3.x = r1.z;\n"
               "    r3.y = r2.z;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.z = texture2D(hg_Texture1, r3.xy).z;\n"
               "    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r1.x, hg_ProgramLocal2.y < 0.00000 ? r0.y :"
               " r1.y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r1.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r1.w);\n"
               "}\n"
               "//MD5=fe9c2870:f4fd6520:781b2d50:b5800b8f\n"
               "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
      }
      return 0;
    }
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000006a9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*half4(hg_Params[0].xxxx) + half4(hg_Params[0].yyyy);\n"
             "    r1 = fmax(r1, c0.xxxx);\n"
             "    r1 = fmin(r1, half4(hg_Params[1]));\n"
             "    r1 = round(r1);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = floor(r2.xyz);\n"
             "    r2.xyz = r2.xyz + c0.yyy;\n"
             "    r1 = r1 - half4(hg_Params[0].zzzz)*floor(r1/half4(hg_Params[0].zzzz));\n"
             "    r1 = r1 + c0.yyyy;\n"
             "    r3.x = r1.x;\n"
             "    r3.y = r2.x;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.x = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).x;\n"
             "    r3.x = r1.y;\n"
             "    r3.y = r2.y;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).y;\n"
             "    r3.x = r1.z;\n"
             "    r3.y = r2.z;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.z = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).z;\n"
             "    output.color0 = select(float4(r1), float4(r0), hg_Params[2] < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ba2b5020:e21a8fc7:4195c0d3:4952a624\n"
             "//SIG=00400000:00000001:00000001:00000003:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000615\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
             "    r1 = fmax(r1, c0.xxxx);\n"
             "    r1 = fmin(r1, hg_Params[1]);\n"
             "    r1 = round(r1);\n"
             "    r2.xyz = r1.xyz*hg_Params[0].www;\n"
             "    r2.xyz = floor(r2.xyz);\n"
             "    r2.xyz = r2.xyz + c0.yyy;\n"
             "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
             "    r1 = r1 + c0.yyyy;\n"
             "    r3.x = r1.x;\n"
             "    r3.y = r2.x;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
             "    r3.x = r1.y;\n"
             "    r3.y = r2.y;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
             "    r3.x = r1.z;\n"
             "    r3.y = r2.z;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
             "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=3489e71d:d8b87767:07e113d5:dac13266\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
  else
  {
    if (Target != 396048)
    {
      if (Target > 0x6060F
        && !(*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
      {
        return "//GLfs2.0      \n"
               "//LEN=000000073a\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#endif\n"
               "#define defaultp mediump\n"
               "uniform defaultp sampler2D hg_Texture0;\n"
               "uniform defaultp sampler2D hg_Texture1;\n"
               "uniform mediump vec4 hg_ProgramLocal0;\n"
               "uniform mediump vec4 hg_ProgramLocal1;\n"
               "uniform mediump vec4 hg_ProgramLocal2;\n"
               "uniform mediump vec4 hg_ProgramLocal3;\n"
               "varying highp vec4 hg_TexCoord0;\n"
               "void main()\n"
               "{\n"
               "    const mediump vec4 c0 = vec4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
               "    mediump vec4 r0, r1, r2, r3;\n"
               "\n"
               "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
               "    r1 = r0*hg_ProgramLocal0.xxxx + hg_ProgramLocal0.yyyy;\n"
               "    r1 = max(r1, c0.xxxx);\n"
               "    r1 = min(r1, hg_ProgramLocal1);\n"
               "    r1 = floor(r1 + vec4(0.500000));\n"
               "    r2 = r1*hg_ProgramLocal0.wwww;\n"
               "    r2 = floor(r2);\n"
               "    r2 = r2 + c0.yyyy;\n"
               "    r1 = mod(r1, hg_ProgramLocal0.zzzz);\n"
               "    r1 = r1 + c0.yyyy;\n"
               "    r3.x = r1.x;\n"
               "    r3.y = r2.x;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.x = texture2D(hg_Texture1, r3.xy).x;\n"
               "    r3.x = r1.y;\n"
               "    r3.y = r2.y;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.y = texture2D(hg_Texture1, r3.xy).y;\n"
               "    r3.x = r1.z;\n"
               "    r3.y = r2.z;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.z = texture2D(hg_Texture1, r3.xy).z;\n"
               "    r3.x = r1.w;\n"
               "    r3.y = r2.w;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.w = texture2D(hg_Texture1, r3.xy).w;\n"
               "    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r1.x, hg_ProgramLocal2.y < 0.00000 ? r0.y :"
               " r1.y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r1.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r1.w);\n"
               "}\n"
               "//MD5=cf4b61f8:5234da11:e8d20cae:98f38ab4\n"
               "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
      }
      return 0;
    }
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000074f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*half4(hg_Params[0].xxxx) + half4(hg_Params[0].yyyy);\n"
             "    r1 = fmax(r1, c0.xxxx);\n"
             "    r1 = fmin(r1, half4(hg_Params[1]));\n"
             "    r1 = round(r1);\n"
             "    r2 = r1*half4(hg_Params[0].wwww);\n"
             "    r2 = floor(r2);\n"
             "    r2 = r2 + c0.yyyy;\n"
             "    r1 = r1 - half4(hg_Params[0].zzzz)*floor(r1/half4(hg_Params[0].zzzz));\n"
             "    r1 = r1 + c0.yyyy;\n"
             "    r3.x = r1.x;\n"
             "    r3.y = r2.x;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.x = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).x;\n"
             "    r3.x = r1.y;\n"
             "    r3.y = r2.y;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).y;\n"
             "    r3.x = r1.z;\n"
             "    r3.y = r2.z;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.z = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).z;\n"
             "    r3.x = r1.w;\n"
             "    r3.y = r2.w;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.w = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).w;\n"
             "    output.color0 = select(float4(r1), float4(r0), hg_Params[2] < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=131ada21:fe61a7dd:c3645ed8:df8b231e\n"
             "//SIG=00400000:00000001:00000001:00000003:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000069e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
             "    r1 = fmax(r1, c0.xxxx);\n"
             "    r1 = fmin(r1, hg_Params[1]);\n"
             "    r1 = round(r1);\n"
             "    r2 = r1*hg_Params[0].wwww;\n"
             "    r2 = floor(r2);\n"
             "    r2 = r2 + c0.yyyy;\n"
             "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
             "    r1 = r1 + c0.yyyy;\n"
             "    r3.x = r1.x;\n"
             "    r3.y = r2.x;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
             "    r3.x = r1.y;\n"
             "    r3.y = r2.y;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
             "    r3.x = r1.z;\n"
             "    r3.y = r2.z;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
             "    r3.x = r1.w;\n"
             "    r3.y = r2.w;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.w = hg_Texture1.sample(hg_Sampler1, r3.xy).w;\n"
             "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=52ea6efa:ae1d09bb:5ff0d6c3:c1f69c84\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
}

void InitApply1DProgramDescriptor(HGProgramDescriptor *this, int a2, int a3)
{
  if (a3)
  {
    if (a2)
      HGProgramDescriptor::SetVisibleShaderWithSource(this, "Apply1Dx3LUTLinear_hgc_visible", "//Metal1.0     \n//LEN=00000004bb\n[[ visible ]] FragmentOut Apply1Dx3LUTLinear_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
        "    float4 r0, r1, r2, r3;\n"
        "    FragmentOut output;\n"
        "\n"
        "    r0 = color0;\n"
        "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
        "    r1 = fmax(r1, c0.xxxx);\n"
        "    r1 = fmin(r1, hg_Params[1]);\n"
        "    r2.xyz = r1.xyz*hg_Params[0].www;\n"
        "    r2.xyz = floor(r2.xyz);\n"
        "    r2.xyz = r2.xyz + c0.yyy;\n"
        "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
        "    r1 = r1 + c0.yyyy;\n"
        "    r3.x = r1.x;\n"
        "    r3.y = r2.x;\n"
        "    r3.xy = r3.xy + hg_Params[3].xy;\n"
        "    r3.xy = r3.xy*hg_Params[3].zw;\n"
        "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
        "    r3.x = r1.y;\n"
        "    r3.y = r2.y;\n"
        "    r3.xy = r3.xy + hg_Params[3].xy;\n"
        "    r3.xy = r3.xy*hg_Params[3].zw;\n"
        "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
        "    r3.x = r1.z;\n"
        "    r3.y = r2.z;\n"
        "    r3.xy = r3.xy + hg_Params[3].xy;\n"
        "    r3.xy = r3.xy*hg_Params[3].zw;\n"
        "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
        "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
        "    return output;\n"
        "}\n");
    HGProgramDescriptor::SetVisibleShaderWithSource(this, "Apply1Dx4LUTLinear_hgc_visible", "//Metal1.0     \n//LEN=0000000544\n[[ visible ]] FragmentOut Apply1Dx4LUTLinear_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
      "    float4 r0, r1, r2, r3;\n"
      "    FragmentOut output;\n"
      "\n"
      "    r0 = color0;\n"
      "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
      "    r1 = fmax(r1, c0.xxxx);\n"
      "    r1 = fmin(r1, hg_Params[1]);\n"
      "    r2 = r1*hg_Params[0].wwww;\n"
      "    r2 = floor(r2);\n"
      "    r2 = r2 + c0.yyyy;\n"
      "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
      "    r1 = r1 + c0.yyyy;\n"
      "    r3.x = r1.x;\n"
      "    r3.y = r2.x;\n"
      "    r3.xy = r3.xy + hg_Params[3].xy;\n"
      "    r3.xy = r3.xy*hg_Params[3].zw;\n"
      "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
      "    r3.x = r1.y;\n"
      "    r3.y = r2.y;\n"
      "    r3.xy = r3.xy + hg_Params[3].xy;\n"
      "    r3.xy = r3.xy*hg_Params[3].zw;\n"
      "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
      "    r3.x = r1.z;\n"
      "    r3.y = r2.z;\n"
      "    r3.xy = r3.xy + hg_Params[3].xy;\n"
      "    r3.xy = r3.xy*hg_Params[3].zw;\n"
      "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
      "    r3.x = r1.w;\n"
      "    r3.y = r2.w;\n"
      "    r3.xy = r3.xy + hg_Params[3].xy;\n"
      "    r3.xy = r3.xy*hg_Params[3].zw;\n"
      "    r1.w = hg_Texture1.sample(hg_Sampler1, r3.xy).w;\n"
      "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
      "    return output;\n"
      "}\n");
  }
  if (a2)
    HGProgramDescriptor::SetVisibleShaderWithSource(this, "Apply1Dx3LUTNearest_hgc_visible", "//Metal1.0     \n//LEN=00000004d0\n[[ visible ]] FragmentOut Apply1Dx3LUTNearest_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
      "    float4 r0, r1, r2, r3;\n"
      "    FragmentOut output;\n"
      "\n"
      "    r0 = color0;\n"
      "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
      "    r1 = fmax(r1, c0.xxxx);\n"
      "    r1 = fmin(r1, hg_Params[1]);\n"
      "    r1 = round(r1);\n"
      "    r2.xyz = r1.xyz*hg_Params[0].www;\n"
      "    r2.xyz = floor(r2.xyz);\n"
      "    r2.xyz = r2.xyz + c0.yyy;\n"
      "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
      "    r1 = r1 + c0.yyyy;\n"
      "    r3.x = r1.x;\n"
      "    r3.y = r2.x;\n"
      "    r3.xy = r3.xy + hg_Params[3].xy;\n"
      "    r3.xy = r3.xy*hg_Params[3].zw;\n"
      "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
      "    r3.x = r1.y;\n"
      "    r3.y = r2.y;\n"
      "    r3.xy = r3.xy + hg_Params[3].xy;\n"
      "    r3.xy = r3.xy*hg_Params[3].zw;\n"
      "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
      "    r3.x = r1.z;\n"
      "    r3.y = r2.z;\n"
      "    r3.xy = r3.xy + hg_Params[3].xy;\n"
      "    r3.xy = r3.xy*hg_Params[3].zw;\n"
      "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
      "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
      "    return output;\n"
      "}\n");
  HGProgramDescriptor::SetVisibleShaderWithSource(this, "Apply1Dx4LUTNearest_hgc_visible", "//Metal1.0     \n//LEN=0000000559\n[[ visible ]] FragmentOut Apply1Dx4LUTNearest_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
    "    r1 = fmax(r1, c0.xxxx);\n"
    "    r1 = fmin(r1, hg_Params[1]);\n"
    "    r1 = round(r1);\n"
    "    r2 = r1*hg_Params[0].wwww;\n"
    "    r2 = floor(r2);\n"
    "    r2 = r2 + c0.yyyy;\n"
    "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
    "    r1 = r1 + c0.yyyy;\n"
    "    r3.x = r1.x;\n"
    "    r3.y = r2.x;\n"
    "    r3.xy = r3.xy + hg_Params[3].xy;\n"
    "    r3.xy = r3.xy*hg_Params[3].zw;\n"
    "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
    "    r3.x = r1.y;\n"
    "    r3.y = r2.y;\n"
    "    r3.xy = r3.xy + hg_Params[3].xy;\n"
    "    r3.xy = r3.xy*hg_Params[3].zw;\n"
    "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
    "    r3.x = r1.z;\n"
    "    r3.y = r2.z;\n"
    "    r3.xy = r3.xy + hg_Params[3].xy;\n"
    "    r3.xy = r3.xy*hg_Params[3].zw;\n"
    "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
    "    r3.x = r1.w;\n"
    "    r3.y = r2.w;\n"
    "    r3.xy = r3.xy + hg_Params[3].xy;\n"
    "    r3.xy = r3.xy*hg_Params[3].zw;\n"
    "    r1.w = hg_Texture1.sample(hg_Sampler1, r3.xy).w;\n"
    "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B17CAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void **a21,void **a22)
{
  void **v23;
  void **v24;

  if (a18 < 0)
    operator delete(__p);
  if (a21)
  {
    v23 = a22;
    v24 = a21;
    if (a22 != a21)
    {
      do
      {
        if (*((char *)v23 - 17) < 0)
          operator delete(*(v23 - 5));
        v23 -= 6;
      }
      while (v23 != a21);
      v24 = a21;
    }
    operator delete(v24);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Get1DLUTLinearTile(HGTile *a1, const float *a2, float32x4_t *a3, float32x4_t *a4, int a5)
{
  int32x4_t v5;
  int32x4_t v6;
  int v7;
  float v8;
  int v9;
  __int128 v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int8x16_t v21;
  uint64_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int32x4_t v25;
  float32x4_t v26;
  int32x4_t v27;
  float32x4_t v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t v31;
  int32x4_t v32;
  float32x4_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int8x16_t v40;
  float32x4_t v41;
  uint64_t v42;
  float32x4_t v43;
  int32x4_t v44;
  uint64_t v45;
  int32x4_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int8x16_t v53;
  uint64_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int32x4_t v57;
  float32x4_t v58;
  int32x4_t v59;
  float32x4_t v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  float32x4_t v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int8x16_t v74;
  float32x4_t v75;
  uint64_t v76;
  float32x4_t v77;
  int32x4_t v78;
  int32x4_t v79;
  uint64_t v80;

  v7 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
  v8 = a4->f32[3];
  v9 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  v10 = *(_OWORD *)a2;
  v11 = *a3;
  v12 = *a4;
  v13 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
  v14 = *((_QWORD *)a1 + 12);
  if (a5)
  {
    if (v8 >= 0.0)
    {
      if (v9 >= 1 && v7 >= 1)
      {
        v47 = 0;
        v48 = *((_QWORD *)a1 + 10);
        v49 = *((_QWORD *)a1 + 2);
        v50 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        v51 = 16 * *((int *)a1 + 6);
        v52 = 16 * *((int *)a1 + 22);
        v53 = (int8x16_t)vcltzq_f32(v12);
        do
        {
          v54 = 0;
          do
          {
            v55 = *(float32x4_t *)(v48 + v54);
            v56 = vminq_f32(vmaxq_f32(vaddq_f32(v13, vmulq_n_f32(v55, *(float *)&v10)), (float32x4_t)0), v11);
            v57 = vcvtq_s32_f32(v56);
            v58 = vcvtq_f32_s32(v57);
            v59 = vshlq_n_s32(v57, 2uLL);
            v60 = vsubq_f32(v56, v58);
            v61 = v59.i32[2];
            v58.i64[1] = v59.i32[3];
            v59.i64[1] = v59.i32[1];
            v62 = (uint64_t *)(v14 + 4 * v59.i32[0]);
            v63 = (uint64_t *)(v14 + 4 * v59.i32[1]);
            v64 = v14 + 4 * v61;
            v65 = v14 + 4 * v58.i64[1];
            v59.i64[0] = vslid_n_s64(*v62, *(_QWORD *)(v64 + 8), 0x20uLL);
            v58.i64[0] = vsrid_n_s64(*(_QWORD *)(v65 + 8), *v63, 0x20uLL);
            v66 = (float32x4_t)vzip1q_s32(v59, (int32x4_t)v58);
            v58.i64[0] = vslid_n_s64(v62[2], *(_QWORD *)(v64 + 24), 0x20uLL);
            v5.i64[0] = vsrid_n_s64(*(_QWORD *)(v65 + 24), v63[2], 0x20uLL);
            *(int8x16_t *)(v49 + v54) = vbslq_s8(v53, (int8x16_t)v55, (int8x16_t)vaddq_f32(v66, vmulq_f32(v60, vsubq_f32((float32x4_t)vzip1q_s32((int32x4_t)v58, v5), v66))));
            v54 += 16;
          }
          while (v50 != v54);
          ++v47;
          v49 += v51;
          v48 += v52;
        }
        while (v47 != v9);
      }
    }
    else if (v9 >= 1 && v7 >= 1)
    {
      v15 = 0;
      v16 = *((_QWORD *)a1 + 10);
      v17 = *((_QWORD *)a1 + 2);
      v18 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
      v19 = 16 * *((int *)a1 + 6);
      v20 = 16 * *((int *)a1 + 22);
      v21 = (int8x16_t)vcltzq_f32(v12);
      do
      {
        v22 = 0;
        do
        {
          v23 = *(float32x4_t *)(v16 + v22);
          v24 = vminq_f32(vmaxq_f32(vaddq_f32(v13, vmulq_n_f32(v23, *(float *)&v10)), (float32x4_t)0), v11);
          v25 = vcvtq_s32_f32(v24);
          v26 = vcvtq_f32_s32(v25);
          v27 = vshlq_n_s32(v25, 2uLL);
          v28 = vsubq_f32(v24, v26);
          v26.i64[0] = vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL).u64[0];
          v29 = (uint64_t *)(v14 + 4 * v27.i32[0]);
          v27.i64[1] = v26.i32[1];
          v30 = (uint64_t *)(v14 + 4 * v26.i32[0]);
          v31 = v14 + 4 * v26.i32[1];
          v27.i64[0] = vslid_n_s64(*v29, *(_QWORD *)(v31 + 8), 0x20uLL);
          v32 = (int32x4_t)vextq_s8((int8x16_t)v23, (int8x16_t)v23, 8uLL);
          v6.i64[0] = vsrid_n_s64(v32.i64[0], *v30, 0x20uLL);
          v33 = (float32x4_t)vzip1q_s32(v27, v6);
          v5.i64[0] = vslid_n_s64(v29[2], *(_QWORD *)(v31 + 24), 0x20uLL);
          v32.i64[0] = vsrid_n_s64(v32.i64[0], v30[2], 0x20uLL);
          *(int8x16_t *)(v17 + v22) = vbslq_s8(v21, (int8x16_t)v23, (int8x16_t)vaddq_f32(v33, vmulq_f32(v28, vsubq_f32((float32x4_t)vzip1q_s32(v5, v32), v33))));
          v22 += 16;
        }
        while (v18 != v22);
        ++v15;
        v17 += v19;
        v16 += v20;
      }
      while (v15 != v9);
    }
  }
  else if (v8 >= 0.0)
  {
    if (v9 >= 1 && v7 >= 1)
    {
      v67 = 0;
      v68 = v14 + 8;
      v69 = *((_QWORD *)a1 + 10);
      v70 = *((_QWORD *)a1 + 2);
      v71 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
      v72 = 16 * *((int *)a1 + 6);
      v73 = 16 * *((int *)a1 + 22);
      v74 = (int8x16_t)vcltzq_f32(v12);
      v75.i64[0] = 0x3F0000003F000000;
      v75.i64[1] = 0x3F0000003F000000;
      do
      {
        v76 = 0;
        do
        {
          v77 = *(float32x4_t *)(v69 + v76);
          v78 = vshlq_n_s32(vcvtq_s32_f32(vaddq_f32(vminq_f32(vmaxq_f32(vaddq_f32(v13, vmulq_n_f32(v77, *(float *)&v10)), (float32x4_t)0), v11), v75)), 2uLL);
          v79.i64[1] = v78.i32[3];
          v80 = 4 * v78.i32[1];
          v78.i64[0] = vslid_n_s64(*(_QWORD *)(v14 + 4 * v78.i32[0]), *(_QWORD *)(v68 + 4 * v78.i32[2]), 0x20uLL);
          v79.i64[0] = vsrid_n_s64(*(_QWORD *)(v68 + 4 * v78.i32[3]), *(_QWORD *)(v14 + v80), 0x20uLL);
          *(int8x16_t *)(v70 + v76) = vbslq_s8(v74, (int8x16_t)v77, (int8x16_t)vzip1q_s32(v78, v79));
          v76 += 16;
        }
        while (v71 != v76);
        ++v67;
        v70 += v72;
        v69 += v73;
      }
      while (v67 != v9);
    }
  }
  else if (v9 >= 1 && v7 >= 1)
  {
    v34 = 0;
    v35 = *((_QWORD *)a1 + 10);
    v36 = *((_QWORD *)a1 + 2);
    v37 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v38 = 16 * *((int *)a1 + 6);
    v39 = 16 * *((int *)a1 + 22);
    v40 = (int8x16_t)vcltzq_f32(v12);
    v41.i64[0] = 0x3F0000003F000000;
    v41.i64[1] = 0x3F0000003F000000;
    do
    {
      v42 = 0;
      do
      {
        v43 = *(float32x4_t *)(v35 + v42);
        v44 = vshlq_n_s32(vcvtq_s32_f32(vaddq_f32(vminq_f32(vmaxq_f32(vaddq_f32(v13, vmulq_n_f32(v43, *(float *)&v10)), (float32x4_t)0), v11), v41)), 2uLL);
        v45 = 4 * v44.i32[1];
        v44.i64[0] = vslid_n_s64(*(_QWORD *)(v14 + 4 * v44.i32[0]), *(_QWORD *)(v14 + 8 + 4 * v44.i32[2]), 0x20uLL);
        v46 = (int32x4_t)vextq_s8((int8x16_t)v43, (int8x16_t)v43, 8uLL);
        v46.i64[0] = vsrid_n_s64(v46.i64[0], *(_QWORD *)(v14 + v45), 0x20uLL);
        *(int8x16_t *)(v36 + v42) = vbslq_s8(v40, (int8x16_t)v43, (int8x16_t)vzip1q_s32(v44, v46));
        v42 += 16;
      }
      while (v37 != v42);
      ++v34;
      v36 += v38;
      v35 += v39;
    }
    while (v34 != v9);
  }
  return 0;
}

void HGLegacyBlend::HGLegacyBlend(HGLegacyBlend *this)
{
  _QWORD *v2;
  _OWORD *v3;
  uint64_t v9;
  char *v10;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65320D0;
  v2[51] = 0;
  v3 = (_OWORD *)operator new();
  __asm { FMOV            V1.4S, #1.0 }
  v3[2] = 0u;
  v3[3] = _Q1;
  v3[4] = xmmword_1B3050F70;
  *((_QWORD *)this + 55) = v3;
  *((_DWORD *)this + 106) = 0;
  *((_DWORD *)this + 104) = 1065353216;
  *v3 = _Q1;
  v3[1] = 0u;
  HGNode::ClearBits((HGNode *)this, v9, v10);
  *(_QWORD *)((char *)this + 428) = 0x100000000;
  *((_DWORD *)this + 105) = 1065353216;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2B182C4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 408);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

uint64_t HGLegacyBlend::SetParameter(HGLegacyBlend *this, uint64_t a2, double a3, double a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  unsigned int v8;
  uint64_t result;
  unsigned int v10;
  int v11;

  v7 = 0xFFFFFFFFLL;
  switch((int)a2)
  {
    case 0:
      v8 = vcvtms_s32_f32(*(float *)&a3);
      if (v8 > 8)
        goto LABEL_7;
      if (*((_DWORD *)this + 106) == v8)
      {
        v7 = 0;
        goto LABEL_5;
      }
      *((_DWORD *)this + 106) = v8;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      result = 1;
      break;
    case 1:
      *((_DWORD *)this + 104) = LODWORD(a3);
      *(int32x4_t *)*((_QWORD *)this + 55) = vdupq_lane_s32(*(int32x2_t *)&a3, 0);
      HGNode::ClearBits((HGNode *)this, a2, a7);
      result = 1;
      break;
    case 2:
      v10 = vcvtms_s32_f32(*(float *)&a3);
      v11 = v10 != 0;
      if (*((_DWORD *)this + 107) == v11)
      {
LABEL_7:
        result = 0xFFFFFFFFLL;
      }
      else
      {
        *((_DWORD *)this + 107) = v11;
        *((_DWORD *)this + 108) = v10 == 0;
        HGNode::ClearBits((HGNode *)this, a2, a7);
        result = 1;
      }
      break;
    case 5:
      *((_DWORD *)this + 105) = LODWORD(a3);
      *(float *)&a4 = 1.0 / *(float *)&a3;
      *(int32x4_t *)(*((_QWORD *)this + 55) + 16) = vdupq_lane_s32(*(int32x2_t *)&a4, 0);
      *(int32x4_t *)(*((_QWORD *)this + 55) + 32) = vdupq_lane_s32(*(int32x2_t *)&a3, 0);
      HGNode::ClearBits((HGNode *)this, a2, a7);
      result = 1;
      break;
    default:
LABEL_5:
      result = v7;
      break;
  }
  return result;
}

void HGLegacyBlend::~HGLegacyBlend(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E65320D0;
  v2 = *((_QWORD *)this + 55);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  v3 = *((_QWORD *)this + 51);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E65320D0;
  v2 = *((_QWORD *)this + 55);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  v3 = *((_QWORD *)this + 51);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_1E65320D0;
  v2 = *((_QWORD *)this + 55);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  v3 = *((_QWORD *)this + 51);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
  HGObject::operator delete(v4);
}

uint64_t HGLegacyBlend::GetParameter(HGLegacyBlend *this, int a2, float *a3)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;

  result = 0xFFFFFFFFLL;
  switch(a2)
  {
    case 0:
      v5 = *((_DWORD *)this + 106);
      goto LABEL_5;
    case 1:
      v6 = *((_QWORD *)this + 55);
      *a3 = *(float *)v6;
      a3[1] = *(float *)(v6 + 4);
      a3[2] = *(float *)(v6 + 8);
      v7 = *(_DWORD *)(v6 + 12);
      goto LABEL_7;
    case 2:
      v5 = *((_DWORD *)this + 107);
LABEL_5:
      *a3 = (float)v5;
      a3[1] = 0.0;
      a3[2] = 0.0;
      v7 = 0;
      goto LABEL_7;
    case 5:
      v8 = *((_QWORD *)this + 55);
      *a3 = *(float *)(v8 + 32);
      a3[1] = *(float *)(v8 + 36);
      a3[2] = *(float *)(v8 + 40);
      v7 = *(_DWORD *)(v8 + 44);
LABEL_7:
      result = 0;
      *((_DWORD *)a3 + 3) = v7;
      break;
    default:
      return result;
  }
  return result;
}

HGLegacyBlend *HGLegacyBlend::Clone(HGLegacyBlend *this)
{
  HGLegacyBlend *v2;

  v2 = (HGLegacyBlend *)HGObject::operator new(0x1C0uLL);
  HGLegacyBlend::HGLegacyBlend(v2);
  (*(void (**)(HGLegacyBlend *, _QWORD, float, float, float, float))(*(_QWORD *)v2 + 96))(v2, 0, (float)*((int *)this + 106), 0.0, 0.0, 0.0);
  (*(void (**)(HGLegacyBlend *, uint64_t, float, float, float, float))(*(_QWORD *)v2 + 96))(v2, 1, *((float *)this + 104), 0.0, 0.0, 0.0);
  (*(void (**)(HGLegacyBlend *, uint64_t, float, float, float, float))(*(_QWORD *)v2 + 96))(v2, 2, (float)*((int *)this + 107), 0.0, 0.0, 0.0);
  return v2;
}

void sub_1B2B18670(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGNode *HGLegacyBlend::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGNode *Input;
  HGNode *v5;
  HGNode *v6;
  float v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  Input = HGRenderer::GetInput(a2, this, *((_DWORD *)this + 107));
  v5 = HGRenderer::GetInput(a2, this, *((_DWORD *)this + 108));
  v6 = v5;
  if (!Input)
    return v6;
  if (!v5)
    return Input;
  v7 = *((float *)this + 104);
  if (v7 == 0.0)
    return Input;
  if (v7 == 1.0 && *((_DWORD *)this + 106) == 8)
    return v6;
  if (!*((_DWORD *)this + 107))
    return this;
  v9 = (*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 576))(this);
  v10 = *((_QWORD *)this + 51);
  if (v10 == v9)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
    v9 = *((_QWORD *)this + 51);
  }
  else
  {
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
    *((_QWORD *)this + 51) = v9;
  }
  (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(_QWORD *)v9 + 96))(v9, 2, 0.0, 0.0, 0.0, 0.0);
  (*(void (**)(_QWORD, _QWORD, HGNode *))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 0, Input);
  (*(void (**)(_QWORD, uint64_t, HGNode *))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 1, v6);
  v11 = *((_QWORD *)this + 51);
  v12 = (*(uint64_t (**)(HGNode *, uint64_t))(*(_QWORD *)this + 152))(this, 1);
  (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v11 + 136))(v11, 0, v12);
  v13 = *((_QWORD *)this + 51);
  v14 = (*(uint64_t (**)(HGNode *, _QWORD))(*(_QWORD *)this + 152))(this, 0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v13 + 136))(v13, 1, v14);
  v15 = *((_QWORD *)this + 51);
  v16 = (*(uint64_t (**)(HGNode *, uint64_t))(*(_QWORD *)this + 152))(this, 0xFFFFFFFFLL);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v15 + 136))(v15, 0xFFFFFFFFLL, v16);
  return (HGNode *)*((_QWORD *)this + 51);
}

void sub_1B2B1888C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t HGLegacyBlend::GetDOD(HGLegacyBlend *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HGLegacyBlend::GetROI(HGNode *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  HGNode *Input;
  uint64_t DOD;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a3 > 1)
    return 0;
  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  Input = HGRenderer::GetInput(a2, this, a3);
  DOD = HGRenderer::GetDOD(a2, Input);
  v10 = HGRectIntersection(DOD, v9, v5, v4);
  if (HGRectIsNull(v10, v11))
    return 0;
  return v5;
}

uint64_t HGLegacyBlend::RenderTile(HGLegacyBlend *this, HGTile *a2, int a3, float *a4)
{
  _OWORD *v4;
  __int128 v5;
  const float *v6;
  float32x4_t v7;
  const float *v8;
  float32x4_t v9;
  float32x4_t *v10;
  float32x4_t *v11;
  float32x4_t *v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  float32x4_t *v21;
  float32x4_t *v22;
  unint64_t v23;
  float32x4_t *v24;
  float32x4_t *v25;
  uint64_t v26;
  float32x4_t *v27;
  float32x4_t *v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t *v32;
  float32x4_t v33;
  int v34;
  unint64_t v35;
  float32x4_t *v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  float32x4_t *v42;
  float32x4_t *v43;
  unint64_t v44;
  float32x4_t *v45;
  float32x4_t *v46;
  uint64_t v47;
  float32x4_t *v48;
  float32x4_t *v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t *v53;
  float32x4_t v54;
  uint64_t v55;
  int v56;
  int v57;
  char *v58;
  uint64_t v59;
  unsigned int v60;
  size_t v61;
  uint64_t v62;
  unsigned int v63;
  signed int v64;
  size_t v65;
  int v66;
  uint64_t v67;
  int v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  _OWORD *v75;
  __int128 *v76;
  unint64_t v77;
  __int128 *v78;
  _OWORD *v79;
  uint64_t v80;
  _OWORD *v81;
  __int128 *v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t *v86;
  __int128 v87;
  size_t v88;
  uint64_t v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  unint64_t v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  _OWORD v105[5];

  if (!a4)
    return 1;
  v4 = (_OWORD *)*((_QWORD *)this + 55);
  v105[0] = *v4;
  v5 = v4[4];
  v105[3] = v4[3];
  v105[4] = v5;
  *(float *)&v5 = *a4;
  v105[0] = vdupq_lane_s32(*(int32x2_t *)&v5, 0);
  v6 = a4 + 4;
  v7 = vld1q_dup_f32(v6);
  v105[1] = v7;
  v8 = a4 + 8;
  v9 = vld1q_dup_f32(v8);
  v105[2] = v9;
  v10 = (float32x4_t *)*((_QWORD *)a2 + 10);
  v11 = (float32x4_t *)*((_QWORD *)a2 + 12);
  if (v10)
  {
    if (v11)
    {
      ((void (*)(HGTile *, _OWORD *, HGLegacyBlend *))s_func_blend_table[a3])(a2, v105, this);
    }
    else if (a3 == 8)
    {
      v34 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
      if (v34 >= 1)
      {
        v35 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        v36 = (float32x4_t *)*((_QWORD *)a2 + 2);
        v37 = *((int *)a2 + 6);
        v38 = *((int *)a2 + 22);
        if ((int)v35 < 4)
        {
          if ((int)v35 >= 1)
          {
            v95 = 0;
            v96 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
            v97 = 16 * v37;
            v98 = 16 * v38;
            do
            {
              v99 = 0;
              do
              {
                v36[v99 / 0x10] = vsubq_f32(v10[v99 / 0x10], vmulq_n_f32(v10[v99 / 0x10], *(float *)&v5));
                v99 += 16;
              }
              while (v96 != v99);
              ++v95;
              v36 = (float32x4_t *)((char *)v36 + v97);
              v10 = (float32x4_t *)((char *)v10 + v98);
            }
            while (v95 != v34);
          }
        }
        else
        {
          v39 = 0;
          v40 = 16 * v38;
          v41 = 16 * v37;
          v42 = v36 + 4;
          v43 = v10 + 4;
          do
          {
            v44 = 0;
            v45 = v43;
            v46 = v42;
            v47 = 3;
            do
            {
              v48 = v46;
              v49 = v45;
              v50 = vsubq_f32(v10[v47 - 2], vmulq_n_f32(v10[v47 - 2], *(float *)&v5));
              v51 = vsubq_f32(v10[v47 - 1], vmulq_n_f32(v10[v47 - 1], *(float *)&v5));
              v52 = vsubq_f32(v10[v47], vmulq_n_f32(v10[v47], *(float *)&v5));
              v53 = &v36[v47];
              v53[-3] = vsubq_f32(v10[v47 - 3], vmulq_n_f32(v10[v47 - 3], *(float *)&v5));
              v53[-2] = v50;
              v44 += 4;
              v53[-1] = v51;
              *v53 = v52;
              v47 += 4;
              v46 += 4;
              v45 = v49 + 4;
            }
            while ((uint64_t)v44 < (uint64_t)(v35 - 3));
            if ((int)v35 > (int)v44)
            {
              do
              {
                v54 = *v49++;
                *v48++ = vsubq_f32(v54, vmulq_n_f32(v54, *(float *)&v5));
                ++v44;
              }
              while (v44 < v35);
            }
            ++v39;
            v10 = (float32x4_t *)((char *)v10 + v40);
            v36 = (float32x4_t *)((char *)v36 + v41);
            v42 = (float32x4_t *)((char *)v42 + v41);
            v43 = (float32x4_t *)((char *)v43 + v40);
          }
          while (v39 != v34);
        }
      }
    }
    else
    {
      v67 = *((_QWORD *)a2 + 2);
      if ((float32x4_t *)v67 != v10)
      {
        v68 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
        if (v68 >= 1)
        {
          v69 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
          v70 = *((int *)a2 + 6);
          v71 = *((int *)a2 + 22);
          if ((int)v69 < 4)
          {
            if ((int)v69 >= 1)
            {
              v100 = 0;
              v101 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
              v102 = 16 * v70;
              v103 = 16 * v71;
              do
              {
                v104 = 0;
                do
                {
                  *(float32x4_t *)(v67 + v104) = v10[v104 / 0x10];
                  v104 += 16;
                }
                while (v101 != v104);
                ++v100;
                v67 += v102;
                v10 = (float32x4_t *)((char *)v10 + v103);
              }
              while (v100 != v68);
            }
          }
          else
          {
            v72 = 0;
            v73 = 16 * v71;
            v74 = 16 * v70;
            v75 = (_OWORD *)(v67 + 64);
            v76 = (__int128 *)&v10[4];
            do
            {
              v77 = 0;
              v78 = v76;
              v79 = v75;
              v80 = 3;
              do
              {
                v81 = v79;
                v82 = v78;
                v83 = v10[v80 - 2];
                v84 = v10[v80 - 1];
                v85 = v10[v80];
                v86 = (float32x4_t *)(v67 + v80 * 16);
                v86[-3] = v10[v80 - 3];
                v86[-2] = v83;
                v77 += 4;
                v86[-1] = v84;
                *v86 = v85;
                v80 += 4;
                v79 += 4;
                v78 = v82 + 4;
              }
              while ((uint64_t)v77 < (uint64_t)(v69 - 3));
              if ((int)v69 > (int)v77)
              {
                do
                {
                  v87 = *v82++;
                  *v81++ = v87;
                  ++v77;
                }
                while (v77 < v69);
              }
              ++v72;
              v10 = (float32x4_t *)((char *)v10 + v73);
              v67 += v74;
              v75 = (_OWORD *)((char *)v75 + v74);
              v76 = (__int128 *)((char *)v76 + v73);
            }
            while (v72 != v68);
          }
        }
      }
    }
  }
  else if (v11)
  {
    v13 = (float32x4_t *)*((_QWORD *)a2 + 2);
    if (*(float *)&v5 != 1.0 || v13 != v11)
    {
      v14 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
      if (v14 >= 1)
      {
        v15 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        v16 = *((int *)a2 + 6);
        v17 = *((int *)a2 + 26);
        if ((int)v15 < 4)
        {
          if ((int)v15 >= 1)
          {
            v90 = 0;
            v91 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
            v92 = 16 * v16;
            v93 = 16 * v17;
            do
            {
              v94 = 0;
              do
              {
                v13[v94 / 0x10] = vmulq_n_f32(v11[v94 / 0x10], *(float *)&v5);
                v94 += 16;
              }
              while (v91 != v94);
              ++v90;
              v13 = (float32x4_t *)((char *)v13 + v92);
              v11 = (float32x4_t *)((char *)v11 + v93);
            }
            while (v90 != v14);
          }
        }
        else
        {
          v18 = 0;
          v19 = 16 * v17;
          v20 = 16 * v16;
          v21 = v13 + 4;
          v22 = v11 + 4;
          do
          {
            v23 = 0;
            v24 = v22;
            v25 = v21;
            v26 = 3;
            do
            {
              v27 = v25;
              v28 = v24;
              v29 = vmulq_n_f32(v11[v26 - 2], *(float *)&v5);
              v30 = vmulq_n_f32(v11[v26 - 1], *(float *)&v5);
              v31 = vmulq_n_f32(v11[v26], *(float *)&v5);
              v32 = &v13[v26];
              v32[-3] = vmulq_n_f32(v11[v26 - 3], *(float *)&v5);
              v32[-2] = v29;
              v23 += 4;
              v32[-1] = v30;
              *v32 = v31;
              v26 += 4;
              v25 += 4;
              v24 = v28 + 4;
            }
            while ((uint64_t)v23 < (uint64_t)(v15 - 3));
            if ((int)v15 > (int)v23)
            {
              do
              {
                v33 = *v28++;
                *v27++ = vmulq_n_f32(v33, *(float *)&v5);
                ++v23;
              }
              while (v23 < v15);
            }
            ++v18;
            v11 = (float32x4_t *)((char *)v11 + v19);
            v13 = (float32x4_t *)((char *)v13 + v20);
            v21 = (float32x4_t *)((char *)v21 + v20);
            v22 = (float32x4_t *)((char *)v22 + v19);
          }
          while (v18 != v14);
        }
      }
    }
  }
  else
  {
    v55 = (*((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1));
    if ((int)v55 >= 1)
    {
      v56 = *((_DWORD *)a2 + 2);
      v57 = v56 - *(_DWORD *)a2;
      v58 = (char *)*((_QWORD *)a2 + 2);
      v59 = *((int *)a2 + 6);
      v60 = v57 - 4;
      if (v57 < 4)
      {
        if (v57 >= 1)
        {
          v88 = 16 * (v56 + ~*(_DWORD *)a2) + 16;
          v89 = 16 * v59;
          do
          {
            bzero(v58, v88);
            v58 += v89;
            LODWORD(v55) = v55 - 1;
          }
          while ((_DWORD)v55);
        }
      }
      else
      {
        v61 = ((unint64_t)(v60 >> 2) << 6) + 64;
        v62 = 16 * v59;
        v63 = v60 & 0xFFFFFFFC;
        v64 = (v60 & 0xFFFFFFFC) + 5;
        if (v57 > v64)
          v64 = v57;
        v65 = 16 * (v64 - v63 - 5) + 16;
        v66 = v63 + 4;
        do
        {
          bzero(v58, v61);
          if (v57 > v66)
            bzero(&v58[v61], v65);
          v58 += v62;
          --v55;
        }
        while (v55);
      }
    }
  }
  return 0;
}

uint64_t HGLegacyBlend::RenderTile(HGLegacyBlend *this, HGTile *a2)
{
  return (*(uint64_t (**)(HGLegacyBlend *, HGTile *, _QWORD, _QWORD))(*(_QWORD *)this + 584))(this, a2, *((unsigned int *)this + 106), *((_QWORD *)this + 55));
}

HGBitmap *HGLegacyBlend::RenderPageDispatcher<(HGGPURenderAPI)0>(HGNode *a1, HGRect *a2)
{
  HGRenderer *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  HGNode *Input;

  v4 = *(HGRenderer **)&a2->var0;
  v5 = (*(uint64_t (**)(HGNode *, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 400))(a1, *(_QWORD *)&a2->var0, *((unsigned int *)a1 + 108), *(_QWORD *)&a2[1].var0, *(_QWORD *)&a2[1].var2);
  if (HGRectIsNull(v5, v6))
  {
    v7 = *((_DWORD *)a1 + 107);
LABEL_6:
    Input = HGRenderer::GetInput(v4, a1, v7);
    return HGGPURenderer::GetNodeBitmap(v4, Input, a2[1], *(HGBuffer **)&a2->var2, 1u);
  }
  if (*((float *)a1 + 104) == 1.0)
  {
    v8 = (*(uint64_t (**)(HGNode *, HGRenderer *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 400))(a1, v4, *((unsigned int *)a1 + 107), *(_QWORD *)&a2[1].var0, *(_QWORD *)&a2[1].var2);
    if (HGRectIsNull(v8, v9))
    {
      v7 = *((_DWORD *)a1 + 108);
      goto LABEL_6;
    }
  }
  return (HGBitmap *)HGNode::RenderPage(a1, a2);
}

HGBitmap *HGLegacyBlend::RenderPageDispatcher<(HGGPURenderAPI)1>(HGNode *a1, HGPage *a2)
{
  HGRenderer *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  HGNode *Input;

  v4 = *(HGRenderer **)a2;
  v5 = (*(uint64_t (**)(HGNode *, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 400))(a1, *(_QWORD *)a2, *((unsigned int *)a1 + 108), *((_QWORD *)a2 + 2), *((_QWORD *)a2 + 3));
  if (HGRectIsNull(v5, v6))
  {
    v7 = *((_DWORD *)a1 + 107);
LABEL_6:
    Input = HGRenderer::GetInput(v4, a1, v7);
    return HGGPURenderer::GetNodeBitmap(v4, Input, *((HGRect *)a2 + 1), *((HGBuffer **)a2 + 1), 1u);
  }
  if (*((float *)a1 + 104) == 1.0)
  {
    v8 = (*(uint64_t (**)(HGNode *, HGRenderer *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 400))(a1, v4, *((unsigned int *)a1 + 107), *((_QWORD *)a2 + 2), *((_QWORD *)a2 + 3));
    if (HGRectIsNull(v8, v9))
    {
      v7 = *((_DWORD *)a1 + 108);
      goto LABEL_6;
    }
  }
  return (HGBitmap *)HGNode::RenderPageMetal(a1, a2);
}

uint64_t HGLegacyBlend::GetProgram(HGLegacyBlend *this, HGRenderer *a2)
{
  return s_arb_blend_table[*((int *)this + 106)](a2);
}

uint64_t HGLegacyBlend::InitProgramDescriptor(HGNode *this, HGProgramDescriptor *a2)
{
  uint64_t v2;

  v2 = *((int *)this + 106);
  if ((int)v2 < 9)
    s_programdesc_blend_table[v2](a2);
  return HGNode::InitProgramDescriptor(this, a2);
}

uint64_t HGLegacyBlend::BindTexture(HGLegacyBlend *this, HGHandler *a2, int a3)
{
  HGHandler::TexCoord(a2, a3, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  return 0;
}

uint64_t HGLegacyBlend::Bind(HGLegacyBlend *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 55), 1);
  return 0;
}

uint64_t GetHGBlendNormalTile(uint64_t a1, float32x4_t *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  float32x4_t *v16;
  unint64_t v17;
  unint64_t v18;
  float32x4_t *v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t *v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  float32x4_t v44;

  v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    v4 = *(float32x4_t **)(a1 + 80);
    v5 = *(float32x4_t **)(a1 + 96);
    v6 = *(float32x4_t **)(a1 + 16);
    v7 = *(int *)(a1 + 24);
    v8 = *(int *)(a1 + 104);
    v9 = *(int *)(a1 + 88);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v38 = 0;
        v39 = 16 * v9;
        v40 = 16 * v8;
        v41 = 16 * v7;
        v42 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          v43 = 0;
          do
          {
            v44 = vmulq_f32(v5[v43 / 0x10], *a2);
            v6[v43 / 0x10] = vaddq_f32(v44, vmulq_f32(v4[v43 / 0x10], vsubq_f32(a2[3], (float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 3))));
            v43 += 16;
          }
          while (v42 != v43);
          ++v38;
          v4 = (float32x4_t *)((char *)v4 + v39);
          v5 = (float32x4_t *)((char *)v5 + v40);
          v6 = (float32x4_t *)((char *)v6 + v41);
        }
        while (v38 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = vmulq_f32(v5[v17], *a2);
          v26 = vmulq_f32(v5[v17 + 1], *a2);
          v27 = vmulq_f32(v5[v17 + 2], *a2);
          v28 = vmulq_f32(v5[v17 + 3], *a2);
          v29 = a2[3];
          v30 = vaddq_f32(v26, vmulq_f32(v4[v17 + 1], vsubq_f32(v29, (float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 3))));
          v31 = vaddq_f32(v27, vmulq_f32(v4[v17 + 2], vsubq_f32(v29, (float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 3))));
          v32 = vaddq_f32(v28, vmulq_f32(v4[v17 + 3], vsubq_f32(v29, (float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 3))));
          v33 = &v6[v17];
          *v33 = vaddq_f32(v25, vmulq_f32(v4[v17], vsubq_f32(v29, (float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 3))));
          v33[1] = v30;
          v18 += 4;
          v17 += 4;
          v33[2] = v31;
          v33[3] = v32;
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            v34 = *v22++;
            v35 = v34;
            v36 = *v23++;
            v37 = vmulq_f32(v36, *a2);
            *v24++ = vaddq_f32(v37, vmulq_f32(v35, vsubq_f32(a2[3], (float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 3))));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        v5 = (float32x4_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (float32x4_t *)((char *)v4 + v13);
        v14 = (float32x4_t *)((char *)v14 + v13);
        v15 = (float32x4_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendAddTile(uint64_t a1, uint64_t a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  int8x16_t *v16;
  unint64_t v17;
  unint64_t v18;
  int8x16_t *v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  int8x16_t *v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int8x16_t v37;
  int8x16_t v38;
  int8x16_t *v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;

  v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    v4 = *(float32x4_t **)(a1 + 80);
    v5 = *(float32x4_t **)(a1 + 96);
    v6 = *(int8x16_t **)(a1 + 16);
    v7 = *(int *)(a1 + 24);
    v8 = *(int *)(a1 + 104);
    v9 = *(int *)(a1 + 88);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v45 = 0;
        v46 = 16 * v9;
        v47 = 16 * v8;
        v48 = 16 * v7;
        v49 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          v50 = 0;
          do
          {
            v51 = v4[v50 / 0x10];
            v52 = vmulq_f32(v5[v50 / 0x10], *(float32x4_t *)a2);
            v53 = vaddq_f32(v51, v52);
            v6[v50 / 0x10] = vbslq_s8(*(int8x16_t *)(a2 + 64), (int8x16_t)vsubq_f32(v53, vmulq_f32(v51, v52)), (int8x16_t)v53);
            v50 += 16;
          }
          while (v49 != v50);
          ++v45;
          v4 = (float32x4_t *)((char *)v4 + v46);
          v5 = (float32x4_t *)((char *)v5 + v47);
          v6 = (int8x16_t *)((char *)v6 + v48);
        }
        while (v45 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = v4[v17];
          v26 = v4[v17 + 1];
          v27 = v4[v17 + 2];
          v28 = v4[v17 + 3];
          v29 = vmulq_f32(v5[v17], *(float32x4_t *)a2);
          v30 = vmulq_f32(v5[v17 + 1], *(float32x4_t *)a2);
          v31 = vmulq_f32(v5[v17 + 2], *(float32x4_t *)a2);
          v32 = vmulq_f32(v5[v17 + 3], *(float32x4_t *)a2);
          v33 = vaddq_f32(v25, v29);
          v34 = vaddq_f32(v26, v30);
          v35 = vaddq_f32(v27, v31);
          v36 = vaddq_f32(v28, v32);
          v37 = (int8x16_t)vsubq_f32(v33, vmulq_f32(v25, v29));
          v38 = *(int8x16_t *)(a2 + 64);
          v39 = &v6[v17];
          *v39 = vbslq_s8(v38, v37, (int8x16_t)v33);
          v39[1] = vbslq_s8(v38, (int8x16_t)vsubq_f32(v34, vmulq_f32(v26, v30)), (int8x16_t)v34);
          v18 += 4;
          v17 += 4;
          v39[2] = vbslq_s8(v38, (int8x16_t)vsubq_f32(v35, vmulq_f32(v27, v31)), (int8x16_t)v35);
          v39[3] = vbslq_s8(v38, (int8x16_t)vsubq_f32(v36, vmulq_f32(v28, v32)), (int8x16_t)v36);
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            v40 = *v22++;
            v41 = v40;
            v42 = *v23++;
            v43 = vmulq_f32(v42, *(float32x4_t *)a2);
            v44 = vaddq_f32(v41, v43);
            *v24++ = vbslq_s8(*(int8x16_t *)(a2 + 64), (int8x16_t)vsubq_f32(v44, vmulq_f32(v41, v43)), (int8x16_t)v44);
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        v5 = (float32x4_t *)((char *)v5 + v11);
        v6 = (int8x16_t *)((char *)v6 + v12);
        v4 = (float32x4_t *)((char *)v4 + v13);
        v14 = (float32x4_t *)((char *)v14 + v13);
        v15 = (float32x4_t *)((char *)v15 + v11);
        v16 = (int8x16_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendBehindTile(uint64_t a1, float32x4_t *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  float32x4_t *v16;
  unint64_t v17;
  unint64_t v18;
  float32x4_t *v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t *v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;

  v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    v4 = *(float32x4_t **)(a1 + 80);
    v5 = *(float32x4_t **)(a1 + 96);
    v6 = *(float32x4_t **)(a1 + 16);
    v7 = *(int *)(a1 + 24);
    v8 = *(int *)(a1 + 104);
    v9 = *(int *)(a1 + 88);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v33 = 0;
        v34 = 16 * v9;
        v35 = 16 * v8;
        v36 = 16 * v7;
        v37 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          v38 = 0;
          do
          {
            v6[v38 / 0x10] = vaddq_f32(v4[v38 / 0x10], vmulq_f32(vmulq_f32(v5[v38 / 0x10], *a2), vsubq_f32(a2[3], (float32x4_t)vdupq_laneq_s32((int32x4_t)v4[v38 / 0x10], 3))));
            v38 += 16;
          }
          while (v37 != v38);
          ++v33;
          v4 = (float32x4_t *)((char *)v4 + v34);
          v5 = (float32x4_t *)((char *)v5 + v35);
          v6 = (float32x4_t *)((char *)v6 + v36);
        }
        while (v33 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = a2[3];
          v26 = vaddq_f32(v4[v17 + 1], vmulq_f32(vmulq_f32(v5[v17 + 1], *a2), vsubq_f32(v25, (float32x4_t)vdupq_laneq_s32((int32x4_t)v4[v17 + 1], 3))));
          v27 = vaddq_f32(v4[v17 + 2], vmulq_f32(vmulq_f32(v5[v17 + 2], *a2), vsubq_f32(v25, (float32x4_t)vdupq_laneq_s32((int32x4_t)v4[v17 + 2], 3))));
          v28 = vaddq_f32(v4[v17 + 3], vmulq_f32(vmulq_f32(v5[v17 + 3], *a2), vsubq_f32(v25, (float32x4_t)vdupq_laneq_s32((int32x4_t)v4[v17 + 3], 3))));
          v29 = &v6[v17];
          *v29 = vaddq_f32(v4[v17], vmulq_f32(vmulq_f32(v5[v17], *a2), vsubq_f32(v25, (float32x4_t)vdupq_laneq_s32((int32x4_t)v4[v17], 3))));
          v29[1] = v26;
          v18 += 4;
          v17 += 4;
          v29[2] = v27;
          v29[3] = v28;
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            v30 = *v22++;
            v31 = v30;
            v32 = *v23++;
            *v24++ = vaddq_f32(v31, vmulq_f32(vmulq_f32(v32, *a2), vsubq_f32(a2[3], (float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 3))));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        v5 = (float32x4_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (float32x4_t *)((char *)v4 + v13);
        v14 = (float32x4_t *)((char *)v14 + v13);
        v15 = (float32x4_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendDarkenTile(uint64_t a1, float32x4_t *a2)
{
  int v2;
  uint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  float32x4_t *v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  int v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t *v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;

  v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    v4 = *(float32x4_t **)(a1 + 80);
    v5 = *(float32x4_t **)(a1 + 96);
    v6 = *(float32x4_t **)(a1 + 16);
    v7 = *(int *)(a1 + 24);
    v8 = *(int *)(a1 + 104);
    v9 = *(int *)(a1 + 88);
    if ((int)v3 < 3)
    {
      if ((int)v3 >= 1)
      {
        v46 = 0;
        v47 = 16 * v9;
        v48 = 16 * v8;
        v49 = 16 * v7;
        v50 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          v51 = 0;
          do
          {
            v52 = v4[v51 / 0x10];
            v53 = vmulq_f32(v5[v51 / 0x10], *a2);
            v54 = vmulq_laneq_f32(v53, v52, 3);
            v55 = vmulq_laneq_f32(v52, v53, 3);
            v6[v51 / 0x10] = vaddq_f32(vminq_f32(v54, v55), vsubq_f32(vsubq_f32(vaddq_f32(v52, v53), v54), v55));
            v51 += 16;
          }
          while (v50 != v51);
          ++v46;
          v4 = (float32x4_t *)((char *)v4 + v47);
          v5 = (float32x4_t *)((char *)v5 + v48);
          v6 = (float32x4_t *)((char *)v6 + v49);
        }
        while (v46 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 3;
      v15 = v5 + 3;
      v16 = v6 + 3;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = 3;
        v20 = v16;
        v21 = v15;
        v22 = v14;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v26 = v19;
          v27 = v4[v17];
          v28 = v4[v17 + 1];
          v29 = v4[v17 + 2];
          v30 = vmulq_f32(v5[v17], *a2);
          v31 = vmulq_f32(v5[v17 + 1], *a2);
          v32 = vmulq_f32(v5[v17 + 2], *a2);
          v33 = vmulq_laneq_f32(v30, v27, 3);
          v34 = vmulq_laneq_f32(v31, v28, 3);
          v35 = vmulq_laneq_f32(v32, v29, 3);
          v36 = vmulq_laneq_f32(v27, v30, 3);
          v37 = vmulq_laneq_f32(v28, v31, 3);
          v38 = vmulq_laneq_f32(v29, v32, 3);
          v39 = &v6[v17];
          v18 += 3;
          v17 += 3;
          v22 += 3;
          *v39 = vaddq_f32(vminq_f32(v33, v36), vsubq_f32(vsubq_f32(vaddq_f32(v27, v30), v33), v36));
          v39[1] = vaddq_f32(vminq_f32(v34, v37), vsubq_f32(vsubq_f32(vaddq_f32(v28, v31), v34), v37));
          v39[2] = vaddq_f32(vminq_f32(v35, v38), vsubq_f32(vsubq_f32(vaddq_f32(v29, v32), v35), v38));
          v21 += 3;
          v20 += 3;
          v19 = v26 + 3;
        }
        while (v18 < v3 - 2);
        if ((int)v3 > (int)v18)
        {
          do
          {
            v40 = *v23++;
            v41 = v40;
            v42 = *v24++;
            v43 = vmulq_f32(v42, *a2);
            v44 = vmulq_laneq_f32(v43, v41, 3);
            v45 = vmulq_laneq_f32(v41, v43, 3);
            *v25++ = vaddq_f32(vminq_f32(v44, v45), vsubq_f32(vsubq_f32(vaddq_f32(v41, v43), v44), v45));
            ++v26;
          }
          while ((int)v3 > v26);
        }
        ++v10;
        v5 = (float32x4_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (float32x4_t *)((char *)v4 + v13);
        v14 = (float32x4_t *)((char *)v14 + v13);
        v15 = (float32x4_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendDifferenceTile(uint64_t a1, uint64_t a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  float32x4_t *v16;
  unint64_t v17;
  unint64_t v18;
  float32x4_t *v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int8x16_t v45;
  float32x4_t *v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;

  v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    v4 = *(float32x4_t **)(a1 + 80);
    v5 = *(float32x4_t **)(a1 + 96);
    v6 = *(float32x4_t **)(a1 + 16);
    v7 = *(int *)(a1 + 24);
    v8 = *(int *)(a1 + 104);
    v9 = *(int *)(a1 + 88);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v54 = 0;
        v55 = 16 * v9;
        v56 = 16 * v8;
        v57 = 16 * v7;
        v58 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          v59 = 0;
          do
          {
            v60 = v4[v59 / 0x10];
            v61 = vmulq_f32(v5[v59 / 0x10], *(float32x4_t *)a2);
            v62 = vmulq_laneq_f32(v61, v60, 3);
            v63 = vmulq_laneq_f32(v60, v61, 3);
            v64 = vsubq_f32(vaddq_f32(v60, v61), v62);
            v6[v59 / 0x10] = vaddq_f32(vabdq_f32(v62, v63), (float32x4_t)vbslq_s8(*(int8x16_t *)(a2 + 64), (int8x16_t)v64, (int8x16_t)vsubq_f32(v64, v63)));
            v59 += 16;
          }
          while (v58 != v59);
          ++v54;
          v4 = (float32x4_t *)((char *)v4 + v55);
          v5 = (float32x4_t *)((char *)v5 + v56);
          v6 = (float32x4_t *)((char *)v6 + v57);
        }
        while (v54 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = v4[v17];
          v26 = v4[v17 + 1];
          v27 = v4[v17 + 2];
          v28 = v4[v17 + 3];
          v29 = vmulq_f32(v5[v17], *(float32x4_t *)a2);
          v30 = vmulq_f32(v5[v17 + 1], *(float32x4_t *)a2);
          v31 = vmulq_f32(v5[v17 + 2], *(float32x4_t *)a2);
          v32 = vmulq_f32(v5[v17 + 3], *(float32x4_t *)a2);
          v33 = vmulq_laneq_f32(v29, v25, 3);
          v34 = vmulq_laneq_f32(v30, v26, 3);
          v35 = vmulq_laneq_f32(v31, v27, 3);
          v36 = vmulq_laneq_f32(v32, v28, 3);
          v37 = vmulq_laneq_f32(v25, v29, 3);
          v38 = vmulq_laneq_f32(v26, v30, 3);
          v39 = vmulq_laneq_f32(v27, v31, 3);
          v40 = vmulq_laneq_f32(v28, v32, 3);
          v41 = vsubq_f32(vaddq_f32(v25, v29), v33);
          v42 = vsubq_f32(vaddq_f32(v26, v30), v34);
          v43 = vsubq_f32(vaddq_f32(v27, v31), v35);
          v44 = vsubq_f32(vaddq_f32(v28, v32), v36);
          v45 = *(int8x16_t *)(a2 + 64);
          v46 = &v6[v17];
          *v46 = vaddq_f32(vabdq_f32(v33, v37), (float32x4_t)vbslq_s8(v45, (int8x16_t)v41, (int8x16_t)vsubq_f32(v41, v37)));
          v46[1] = vaddq_f32(vabdq_f32(v34, v38), (float32x4_t)vbslq_s8(v45, (int8x16_t)v42, (int8x16_t)vsubq_f32(v42, v38)));
          v18 += 4;
          v17 += 4;
          v46[2] = vaddq_f32(vabdq_f32(v35, v39), (float32x4_t)vbslq_s8(v45, (int8x16_t)v43, (int8x16_t)vsubq_f32(v43, v39)));
          v46[3] = vaddq_f32(vabdq_f32(v36, v40), (float32x4_t)vbslq_s8(v45, (int8x16_t)v44, (int8x16_t)vsubq_f32(v44, v40)));
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            v47 = *v22++;
            v48 = v47;
            v49 = *v23++;
            v50 = vmulq_f32(v49, *(float32x4_t *)a2);
            v51 = vmulq_laneq_f32(v50, v48, 3);
            v52 = vmulq_laneq_f32(v48, v50, 3);
            v53 = vsubq_f32(vaddq_f32(v48, v50), v51);
            *v24++ = vaddq_f32(vabdq_f32(v51, v52), (float32x4_t)vbslq_s8(*(int8x16_t *)(a2 + 64), (int8x16_t)v53, (int8x16_t)vsubq_f32(v53, v52)));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        v5 = (float32x4_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (float32x4_t *)((char *)v4 + v13);
        v14 = (float32x4_t *)((char *)v14 + v13);
        v15 = (float32x4_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendLightenTile(uint64_t a1, float32x4_t *a2)
{
  int v2;
  uint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  float32x4_t *v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  int v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t *v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;

  v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    v4 = *(float32x4_t **)(a1 + 80);
    v5 = *(float32x4_t **)(a1 + 96);
    v6 = *(float32x4_t **)(a1 + 16);
    v7 = *(int *)(a1 + 24);
    v8 = *(int *)(a1 + 104);
    v9 = *(int *)(a1 + 88);
    if ((int)v3 < 3)
    {
      if ((int)v3 >= 1)
      {
        v46 = 0;
        v47 = 16 * v9;
        v48 = 16 * v8;
        v49 = 16 * v7;
        v50 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          v51 = 0;
          do
          {
            v52 = v4[v51 / 0x10];
            v53 = vmulq_f32(v5[v51 / 0x10], *a2);
            v54 = vmulq_laneq_f32(v53, v52, 3);
            v55 = vmulq_laneq_f32(v52, v53, 3);
            v6[v51 / 0x10] = vaddq_f32(vmaxq_f32(v54, v55), vsubq_f32(vsubq_f32(vaddq_f32(v52, v53), v54), v55));
            v51 += 16;
          }
          while (v50 != v51);
          ++v46;
          v4 = (float32x4_t *)((char *)v4 + v47);
          v5 = (float32x4_t *)((char *)v5 + v48);
          v6 = (float32x4_t *)((char *)v6 + v49);
        }
        while (v46 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 3;
      v15 = v5 + 3;
      v16 = v6 + 3;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = 3;
        v20 = v16;
        v21 = v15;
        v22 = v14;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v26 = v19;
          v27 = v4[v17];
          v28 = v4[v17 + 1];
          v29 = v4[v17 + 2];
          v30 = vmulq_f32(v5[v17], *a2);
          v31 = vmulq_f32(v5[v17 + 1], *a2);
          v32 = vmulq_f32(v5[v17 + 2], *a2);
          v33 = vmulq_laneq_f32(v30, v27, 3);
          v34 = vmulq_laneq_f32(v31, v28, 3);
          v35 = vmulq_laneq_f32(v32, v29, 3);
          v36 = vmulq_laneq_f32(v27, v30, 3);
          v37 = vmulq_laneq_f32(v28, v31, 3);
          v38 = vmulq_laneq_f32(v29, v32, 3);
          v39 = &v6[v17];
          v18 += 3;
          v17 += 3;
          v22 += 3;
          *v39 = vaddq_f32(vmaxq_f32(v33, v36), vsubq_f32(vsubq_f32(vaddq_f32(v27, v30), v33), v36));
          v39[1] = vaddq_f32(vmaxq_f32(v34, v37), vsubq_f32(vsubq_f32(vaddq_f32(v28, v31), v34), v37));
          v39[2] = vaddq_f32(vmaxq_f32(v35, v38), vsubq_f32(vsubq_f32(vaddq_f32(v29, v32), v35), v38));
          v21 += 3;
          v20 += 3;
          v19 = v26 + 3;
        }
        while (v18 < v3 - 2);
        if ((int)v3 > (int)v18)
        {
          do
          {
            v40 = *v23++;
            v41 = v40;
            v42 = *v24++;
            v43 = vmulq_f32(v42, *a2);
            v44 = vmulq_laneq_f32(v43, v41, 3);
            v45 = vmulq_laneq_f32(v41, v43, 3);
            *v25++ = vaddq_f32(vmaxq_f32(v44, v45), vsubq_f32(vsubq_f32(vaddq_f32(v41, v43), v44), v45));
            ++v26;
          }
          while ((int)v3 > v26);
        }
        ++v10;
        v5 = (float32x4_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (float32x4_t *)((char *)v4 + v13);
        v14 = (float32x4_t *)((char *)v14 + v13);
        v15 = (float32x4_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendMultiplyTile(uint64_t a1, float32x4_t *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  float32x4_t *v16;
  unint64_t v17;
  unint64_t v18;
  float32x4_t *v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t *v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  float32x4_t v43;

  v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    v4 = *(float32x4_t **)(a1 + 80);
    v5 = *(float32x4_t **)(a1 + 96);
    v6 = *(float32x4_t **)(a1 + 16);
    v7 = *(int *)(a1 + 24);
    v8 = *(int *)(a1 + 104);
    v9 = *(int *)(a1 + 88);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v37 = 0;
        v38 = 16 * v9;
        v39 = 16 * v8;
        v40 = 16 * v7;
        v41 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          v42 = 0;
          do
          {
            v43 = vmulq_f32(v5[v42 / 0x10], *a2);
            v6[v42 / 0x10] = vaddq_f32(vaddq_f32(vmulq_f32(v4[v42 / 0x10], v43), vsubq_f32(v43, vmulq_laneq_f32(v43, v4[v42 / 0x10], 3))), vsubq_f32(v4[v42 / 0x10], vmulq_laneq_f32(v4[v42 / 0x10], v43, 3)));
            v42 += 16;
          }
          while (v41 != v42);
          ++v37;
          v4 = (float32x4_t *)((char *)v4 + v38);
          v5 = (float32x4_t *)((char *)v5 + v39);
          v6 = (float32x4_t *)((char *)v6 + v40);
        }
        while (v37 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = vmulq_f32(v5[v17], *a2);
          v26 = vmulq_f32(v5[v17 + 1], *a2);
          v27 = vmulq_f32(v5[v17 + 2], *a2);
          v28 = vmulq_f32(v5[v17 + 3], *a2);
          v29 = vaddq_f32(vaddq_f32(vmulq_f32(v4[v17 + 1], v26), vsubq_f32(v26, vmulq_laneq_f32(v26, v4[v17 + 1], 3))), vsubq_f32(v4[v17 + 1], vmulq_laneq_f32(v4[v17 + 1], v26, 3)));
          v30 = vaddq_f32(vaddq_f32(vmulq_f32(v4[v17 + 2], v27), vsubq_f32(v27, vmulq_laneq_f32(v27, v4[v17 + 2], 3))), vsubq_f32(v4[v17 + 2], vmulq_laneq_f32(v4[v17 + 2], v27, 3)));
          v31 = vaddq_f32(vaddq_f32(vmulq_f32(v4[v17 + 3], v28), vsubq_f32(v28, vmulq_laneq_f32(v28, v4[v17 + 3], 3))), vsubq_f32(v4[v17 + 3], vmulq_laneq_f32(v4[v17 + 3], v28, 3)));
          v32 = &v6[v17];
          *v32 = vaddq_f32(vaddq_f32(vmulq_f32(v4[v17], v25), vsubq_f32(v25, vmulq_laneq_f32(v25, v4[v17], 3))), vsubq_f32(v4[v17], vmulq_laneq_f32(v4[v17], v25, 3)));
          v32[1] = v29;
          v18 += 4;
          v17 += 4;
          v32[2] = v30;
          v32[3] = v31;
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            v33 = *v22++;
            v34 = v33;
            v35 = *v23++;
            v36 = vmulq_f32(v35, *a2);
            *v24++ = vaddq_f32(vaddq_f32(vmulq_f32(v34, v36), vsubq_f32(v36, vmulq_laneq_f32(v36, v34, 3))), vsubq_f32(v34, vmulq_laneq_f32(v34, v36, 3)));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        v5 = (float32x4_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (float32x4_t *)((char *)v4 + v13);
        v14 = (float32x4_t *)((char *)v14 + v13);
        v15 = (float32x4_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendScreenTile(uint64_t a1, float32x4_t *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  float32x4_t *v16;
  unint64_t v17;
  unint64_t v18;
  float32x4_t *v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t *v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  float32x4_t v43;

  v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    v4 = *(float32x4_t **)(a1 + 80);
    v5 = *(float32x4_t **)(a1 + 96);
    v6 = *(float32x4_t **)(a1 + 16);
    v7 = *(int *)(a1 + 24);
    v8 = *(int *)(a1 + 104);
    v9 = *(int *)(a1 + 88);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v37 = 0;
        v38 = 16 * v9;
        v39 = 16 * v8;
        v40 = 16 * v7;
        v41 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          v42 = 0;
          do
          {
            v43 = vmulq_f32(v5[v42 / 0x10], *a2);
            v6[v42 / 0x10] = vsubq_f32(vaddq_f32(v4[v42 / 0x10], v43), vminq_f32(vminq_f32(vmulq_f32(v4[v42 / 0x10], v43), v43), v4[v42 / 0x10]));
            v42 += 16;
          }
          while (v41 != v42);
          ++v37;
          v4 = (float32x4_t *)((char *)v4 + v38);
          v5 = (float32x4_t *)((char *)v5 + v39);
          v6 = (float32x4_t *)((char *)v6 + v40);
        }
        while (v37 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = vmulq_f32(v5[v17], *a2);
          v26 = vmulq_f32(v5[v17 + 1], *a2);
          v27 = vmulq_f32(v5[v17 + 2], *a2);
          v28 = vmulq_f32(v5[v17 + 3], *a2);
          v29 = vsubq_f32(vaddq_f32(v4[v17 + 1], v26), vminq_f32(vminq_f32(vmulq_f32(v4[v17 + 1], v26), v26), v4[v17 + 1]));
          v30 = vsubq_f32(vaddq_f32(v4[v17 + 2], v27), vminq_f32(vminq_f32(vmulq_f32(v4[v17 + 2], v27), v27), v4[v17 + 2]));
          v31 = vsubq_f32(vaddq_f32(v4[v17 + 3], v28), vminq_f32(vminq_f32(vmulq_f32(v4[v17 + 3], v28), v28), v4[v17 + 3]));
          v32 = &v6[v17];
          *v32 = vsubq_f32(vaddq_f32(v4[v17], v25), vminq_f32(vminq_f32(vmulq_f32(v4[v17], v25), v25), v4[v17]));
          v32[1] = v29;
          v18 += 4;
          v17 += 4;
          v32[2] = v30;
          v32[3] = v31;
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            v33 = *v22++;
            v34 = v33;
            v35 = *v23++;
            v36 = vmulq_f32(v35, *a2);
            *v24++ = vsubq_f32(vaddq_f32(v34, v36), vminq_f32(vminq_f32(vmulq_f32(v34, v36), v36), v34));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        v5 = (float32x4_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (float32x4_t *)((char *)v4 + v13);
        v14 = (float32x4_t *)((char *)v14 + v13);
        v15 = (float32x4_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendDissolveTile(uint64_t a1, float32x4_t *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  float32x4_t *v16;
  unint64_t v17;
  unint64_t v18;
  float32x4_t *v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t *v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;

  v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    v4 = *(float32x4_t **)(a1 + 80);
    v5 = *(float32x4_t **)(a1 + 96);
    v6 = *(float32x4_t **)(a1 + 16);
    v7 = *(int *)(a1 + 24);
    v8 = *(int *)(a1 + 104);
    v9 = *(int *)(a1 + 88);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v32 = 0;
        v33 = 16 * v9;
        v34 = 16 * v8;
        v35 = 16 * v7;
        v36 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          v37 = 0;
          do
          {
            v6[v37 / 0x10] = vaddq_f32(v4[v37 / 0x10], vmulq_f32(*a2, vsubq_f32(v5[v37 / 0x10], v4[v37 / 0x10])));
            v37 += 16;
          }
          while (v36 != v37);
          ++v32;
          v4 = (float32x4_t *)((char *)v4 + v33);
          v5 = (float32x4_t *)((char *)v5 + v34);
          v6 = (float32x4_t *)((char *)v6 + v35);
        }
        while (v32 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = vaddq_f32(v4[v17 + 1], vmulq_f32(vsubq_f32(v5[v17 + 1], v4[v17 + 1]), *a2));
          v26 = vaddq_f32(v4[v17 + 2], vmulq_f32(vsubq_f32(v5[v17 + 2], v4[v17 + 2]), *a2));
          v27 = vaddq_f32(v4[v17 + 3], vmulq_f32(*a2, vsubq_f32(v5[v17 + 3], v4[v17 + 3])));
          v28 = &v6[v17];
          *v28 = vaddq_f32(v4[v17], vmulq_f32(vsubq_f32(v5[v17], v4[v17]), *a2));
          v28[1] = v25;
          v18 += 4;
          v17 += 4;
          v28[2] = v26;
          v28[3] = v27;
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            v29 = *v22++;
            v30 = v29;
            v31 = *v23++;
            *v24++ = vaddq_f32(v30, vmulq_f32(*a2, vsubq_f32(v31, v30)));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        v5 = (float32x4_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (float32x4_t *)((char *)v4 + v13);
        v14 = (float32x4_t *)((char *)v14 + v13);
        v15 = (float32x4_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

const char *GetHGBlendNormalProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000037c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = c0.xxxx - r1.wwww;\n"
             "    output.color0 = float4(r0)*float4(r2) + float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a17166cb:4ae482ef:781fc3b7:6143d1a9\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000352\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = c0.xxxx - r1.wwww;\n"
             "    output.color0 = r0*r2 + r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=72391b35:a8654f9f:aaa4f0df:bd71ee76\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000301\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = c0.xxxx - r1.wwww;\n"
           "    gl_FragColor = r0*r2 + r1;\n"
           "}\n"
           "//MD5=542a3d1f:8a8f31c6:53e2357c:1b7afc62\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendAddProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000328\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1 + r0;\n"
             "    r2.w = -r1.w*r0.w + r2.w;\n"
             "    output.color0 = float4(r2);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d59c4393:5faec818:b66c0166:a5b8df3a\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000030c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1 + r0;\n"
             "    r2.w = -r1.w*r0.w + r2.w;\n"
             "    output.color0 = r2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2ed547af:707bae93:26dfb645:16dfb2b5\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002b6\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1 + r0;\n"
           "    r2.w = -r1.w*r0.w + r2.w;\n"
           "    gl_FragColor = r2;\n"
           "}\n"
           "//MD5=c7321b02:0ada01d2:252b971a:900e277b\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendBehindProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000037c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = c0.xxxx - r0.wwww;\n"
             "    output.color0 = float4(r1)*float4(r2) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c58d73cf:5abaf669:0ed24989:47f4d1f7\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000352\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = c0.xxxx - r0.wwww;\n"
             "    output.color0 = r1*r2 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=02fd7083:75fd7153:81b391cd:51351952\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000301\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = c0.xxxx - r0.wwww;\n"
           "    gl_FragColor = r1*r2 + r0;\n"
           "}\n"
           "//MD5=82fdf0d8:1de86e49:9e296160:488420c6\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendDarkenProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000384\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = fmin(r2, r3);\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1 = r1 - r3;\n"
             "    output.color0 = float4(r1) + float4(r4);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c27f10d4:1c0c8ccb:86556908:22917918\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000360\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = fmin(r2, r3);\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1 = r1 - r3;\n"
             "    output.color0 = r1 + r4;\n"
             "    return output;\n"
             "}\n"
             "//MD5=fdd9d0ee:dddc8b61:10b27a4f:f7a7aa8e\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000309\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1*r0.wwww;\n"
           "    r3 = r0*r1.wwww;\n"
           "    r4 = min(r2, r3);\n"
           "    r1 = r1 + r0;\n"
           "    r1 = r1 - r2;\n"
           "    r1 = r1 - r3;\n"
           "    gl_FragColor = r1 + r4;\n"
           "}\n"
           "//MD5=c6b1e65f:1950bd8f:9345f58d:ea3a6afc\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendDifferenceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000038d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r1 = r1 + r0;\n"
             "    r0 = r2 - r3;\n"
             "    r1 = r1 - r2;\n"
             "    r1.xyz = r1.xyz - r3.xyz;\n"
             "    output.color0 = float4(r1) + float4(fabs(r0));\n"
             "    return output;\n"
             "}\n"
             "//MD5=28640d6b:a7f4cbd7:1398d5ad:4f2b97e5\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000369\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r1 = r1 + r0;\n"
             "    r0 = r2 - r3;\n"
             "    r1 = r1 - r2;\n"
             "    r1.xyz = r1.xyz - r3.xyz;\n"
             "    output.color0 = r1 + fabs(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=78eeb002:cd99131f:366f4560:2b2f0811\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000312\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1*r0.wwww;\n"
           "    r3 = r0*r1.wwww;\n"
           "    r1 = r1 + r0;\n"
           "    r0 = r2 - r3;\n"
           "    r1 = r1 - r2;\n"
           "    r1.xyz = r1.xyz - r3.xyz;\n"
           "    gl_FragColor = r1 + abs(r0);\n"
           "}\n"
           "//MD5=167e3881:cda035d5:2b7bb7d9:07a634d1\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendLightenProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000384\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = fmax(r2, r3);\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1 = r1 - r3;\n"
             "    output.color0 = float4(r1) + float4(r4);\n"
             "    return output;\n"
             "}\n"
             "//MD5=255abd10:393d4261:149de1f9:66e2ba1d\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000360\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = fmax(r2, r3);\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1 = r1 - r3;\n"
             "    output.color0 = r1 + r4;\n"
             "    return output;\n"
             "}\n"
             "//MD5=a08d3b39:c090c511:0017968a:c922b48e\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000309\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1*r0.wwww;\n"
           "    r3 = r0*r1.wwww;\n"
           "    r4 = max(r2, r3);\n"
           "    r1 = r1 + r0;\n"
           "    r1 = r1 - r2;\n"
           "    r1 = r1 - r3;\n"
           "    gl_FragColor = r1 + r4;\n"
           "}\n"
           "//MD5=10f025ae:65373697:69030409:e5173d3b\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendMultiplyProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000354\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = -r1*r0.wwww + r1;\n"
             "    r3 = -r0*r1.wwww + r0;\n"
             "    r1 = r1*r0 + r2;\n"
             "    output.color0 = float4(r1) + float4(r3);\n"
             "    return output;\n"
             "}\n"
             "//MD5=7ab80faf:802a2960:6882b435:6d1cc9dc\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000330\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = -r1*r0.wwww + r1;\n"
             "    r3 = -r0*r1.wwww + r0;\n"
             "    r1 = r1*r0 + r2;\n"
             "    output.color0 = r1 + r3;\n"
             "    return output;\n"
             "}\n"
             "//MD5=d348d950:6657c859:55f8ae41:7b9824a8\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002da\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = -r1*r0.wwww + r1;\n"
           "    r3 = -r0*r1.wwww + r0;\n"
           "    r1 = r1*r0 + r2;\n"
           "    gl_FragColor = r1 + r3;\n"
           "}\n"
           "//MD5=f723a021:2cc26bfb:5b7402aa:6e437a60\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendScreenProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000355\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1*r0;\n"
             "    r2 = fmin(r2, r1);\n"
             "    r2 = fmin(r2, r0);\n"
             "    r1 = r1 + r0;\n"
             "    output.color0 = float4(r1) - float4(r2);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9771d01d:626a2747:a548b6f1:28e1d417\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000331\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1*r0;\n"
             "    r2 = fmin(r2, r1);\n"
             "    r2 = fmin(r2, r0);\n"
             "    r1 = r1 + r0;\n"
             "    output.color0 = r1 - r2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=31490d41:d9f1dc14:0dca0a9a:b384361c\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002d9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1*r0;\n"
           "    r2 = min(r2, r1);\n"
           "    r2 = min(r2, r0);\n"
           "    r1 = r1 + r0;\n"
           "    gl_FragColor = r1 - r2;\n"
           "}\n"
           "//MD5=8190ca66:f656822d:4e06b98f:6e1ba269\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendDissolveProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002f2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    output.color0 = mix(float4(r0), float4(r1), hg_Params[0]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=71e089ca:82dc604d:921d323b:8c63d522\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002d5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    output.color0 = mix(r0, r1, hg_Params[0]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=19049a07:c1b7d36e:88d051c2:edb06ce9\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000027f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    gl_FragColor = mix(r0, r1, hg_ProgramLocal0);\n"
           "}\n"
           "//MD5=e59d54b8:dcfffceb:e9177f14:9c43910d\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void InitHGBlendNormalProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendNormal_hgc_visible", "//Metal1.0     \n//LEN=00000001ae\n[[ visible ]] FragmentOut HGBlendNormal_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = c0.xxxx - r1.wwww;\n"
    "    output.color0 = r0*r2 + r1;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B1AC68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B1AC9C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B1AC94);
}

void InitHGBlendAddProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendAdd_hgc_visible", "//Metal1.0     \n//LEN=0000000165\n[[ visible ]] FragmentOut HGBlendAdd_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1 + r0;\n"
    "    r2.w = -r1.w*r0.w + r2.w;\n"
    "    output.color0 = r2;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B1AF3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B1AF70(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B1AF68);
}

void InitHGBlendBehindProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendBehind_hgc_visible", "//Metal1.0     \n//LEN=00000001ae\n[[ visible ]] FragmentOut HGBlendBehind_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = c0.xxxx - r0.wwww;\n"
    "    output.color0 = r1*r2 + r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B1B210(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B1B244(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B1B23CLL);
}

void InitHGBlendDarkenProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendDarken_hgc_visible", "//Metal1.0     \n//LEN=00000001bc\n[[ visible ]] FragmentOut HGBlendDarken_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1*r0.wwww;\n"
    "    r3 = r0*r1.wwww;\n"
    "    r4 = fmin(r2, r3);\n"
    "    r1 = r1 + r0;\n"
    "    r1 = r1 - r2;\n"
    "    r1 = r1 - r3;\n"
    "    output.color0 = r1 + r4;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B1B4E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B1B518(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B1B510);
}

void InitHGBlendDifferenceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendDifference_hgc_visible", "//Metal1.0     \n//LEN=00000001c9\n[[ visible ]] FragmentOut HGBlendDifference_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1*r0.wwww;\n"
    "    r3 = r0*r1.wwww;\n"
    "    r1 = r1 + r0;\n"
    "    r0 = r2 - r3;\n"
    "    r1 = r1 - r2;\n"
    "    r1.xyz = r1.xyz - r3.xyz;\n"
    "    output.color0 = r1 + fabs(r0);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B1B7B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B1B7EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B1B7E4);
}

void InitHGBlendLightenProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendLighten_hgc_visible", "//Metal1.0     \n//LEN=00000001bd\n[[ visible ]] FragmentOut HGBlendLighten_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1*r0.wwww;\n"
    "    r3 = r0*r1.wwww;\n"
    "    r4 = fmax(r2, r3);\n"
    "    r1 = r1 + r0;\n"
    "    r1 = r1 - r2;\n"
    "    r1 = r1 - r3;\n"
    "    output.color0 = r1 + r4;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B1BA8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B1BAC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B1BAB8);
}

void InitHGBlendMultiplyProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendMultiply_hgc_visible", "//Metal1.0     \n//LEN=000000018e\n[[ visible ]] FragmentOut HGBlendMultiply_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = -r1*r0.wwww + r1;\n"
    "    r3 = -r0*r1.wwww + r0;\n"
    "    r1 = r1*r0 + r2;\n"
    "    output.color0 = r1 + r3;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B1BD60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B1BD94(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B1BD8CLL);
}

void InitHGBlendScreenProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendScreen_hgc_visible", "//Metal1.0     \n//LEN=000000018d\n[[ visible ]] FragmentOut HGBlendScreen_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1*r0;\n"
    "    r2 = fmin(r2, r1);\n"
    "    r2 = fmin(r2, r0);\n"
    "    r1 = r1 + r0;\n"
    "    output.color0 = r1 - r2;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B1C034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B1C068(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B1C060);
}

void InitHGBlendDissolveProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendDissolve_hgc_visible", "//Metal1.0     \n//LEN=0000000133\n[[ visible ]] FragmentOut HGBlendDissolve_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    output.color0 = mix(r0, r1, hg_Params[0]);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B1C308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B1C33C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B1C334);
}

uint64_t HGColorMatrix::RenderTile(HGColorMatrix *this, HGTile *a2)
{
  uint64_t v4;
  int v6;
  float32x4_t *v7;
  unint64_t v8;
  float32x4_t *v9;
  float32x4_t *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  float32x4_t *v19;
  float32x4_t *v20;
  uint64_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t *v33;
  float32x4_t *v34;
  float32x4_t *v35;
  float32x4_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;

  v4 = HGGetTBC();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(*((_QWORD *)a2 + 42) + 152) + 128))(*(_QWORD *)(*((_QWORD *)a2 + 42) + 152), 28))
  {
    v6 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
    if (v6 >= 1)
    {
      v7 = (float32x4_t *)*((_QWORD *)this + 52);
      v8 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
      v9 = (float32x4_t *)*((_QWORD *)a2 + 10);
      v10 = (float32x4_t *)*((_QWORD *)a2 + 2);
      v11 = *((int *)a2 + 6);
      v12 = *((int *)a2 + 22);
      if ((int)v8 < 4)
      {
        if ((int)v8 >= 1)
        {
          v37 = 0;
          v38 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
          v39 = 16 * v11;
          v40 = 16 * v12;
          do
          {
            v41 = 0;
            do
            {
              v10[v41 / 0x10] = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(*v7, COERCE_FLOAT(*(_OWORD *)&v9[v41 / 0x10])), vmulq_lane_f32(v7[1], *(float32x2_t *)v9[v41 / 0x10].f32, 1)), vmulq_laneq_f32(v7[2], v9[v41 / 0x10], 2)), vmulq_laneq_f32(v7[3], v9[v41 / 0x10], 3));
              v41 += 16;
            }
            while (v38 != v41);
            ++v37;
            v10 = (float32x4_t *)((char *)v10 + v39);
            v9 = (float32x4_t *)((char *)v9 + v40);
          }
          while (v37 != v6);
        }
      }
      else
      {
        v13 = 0;
        v14 = 16 * v12;
        v15 = 16 * v11;
        v16 = v10 + 4;
        v17 = v9 + 4;
        do
        {
          v18 = 0;
          v19 = v17;
          v20 = v16;
          v21 = 3;
          do
          {
            v22 = v9[v21 - 3];
            v23 = v9[v21 - 2];
            v24 = v9[v21 - 1];
            v25 = v9[v21];
            v26 = v7[1];
            v27 = vaddq_f32(vmulq_n_f32(*v7, v22.f32[0]), vmulq_lane_f32(v26, *(float32x2_t *)v22.f32, 1));
            v28 = vaddq_f32(vmulq_n_f32(*v7, v23.f32[0]), vmulq_lane_f32(v26, *(float32x2_t *)v23.f32, 1));
            v29 = vaddq_f32(vmulq_n_f32(*v7, v24.f32[0]), vmulq_lane_f32(v26, *(float32x2_t *)v24.f32, 1));
            v30 = vaddq_f32(vmulq_n_f32(*v7, v25.f32[0]), vmulq_lane_f32(v26, *(float32x2_t *)v25.f32, 1));
            v31 = v7[2];
            v32 = v7[3];
            v33 = v20;
            v34 = v19;
            v35 = &v10[v21];
            v35[-3] = vaddq_f32(vaddq_f32(v27, vmulq_laneq_f32(v31, v22, 2)), vmulq_laneq_f32(v32, v22, 3));
            v35[-2] = vaddq_f32(vaddq_f32(v28, vmulq_laneq_f32(v31, v23, 2)), vmulq_laneq_f32(v32, v23, 3));
            v18 += 4;
            v35[-1] = vaddq_f32(vaddq_f32(v29, vmulq_laneq_f32(v31, v24, 2)), vmulq_laneq_f32(v32, v24, 3));
            *v35 = vaddq_f32(vaddq_f32(v30, vmulq_laneq_f32(v31, v25, 2)), vmulq_laneq_f32(v32, v25, 3));
            v21 += 4;
            v20 = v33 + 4;
            v19 += 4;
          }
          while ((uint64_t)v18 < (uint64_t)(v8 - 3));
          if ((int)v8 > (int)v18)
          {
            do
            {
              v36 = *v34++;
              *v33++ = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(*v7, v36.f32[0]), vmulq_lane_f32(v7[1], *(float32x2_t *)v36.f32, 1)), vmulq_laneq_f32(v7[2], v36, 2)), vmulq_laneq_f32(v7[3], v36, 3));
              ++v18;
            }
            while (v18 < v8);
          }
          ++v13;
          v9 = (float32x4_t *)((char *)v9 + v14);
          v10 = (float32x4_t *)((char *)v10 + v15);
          v16 = (float32x4_t *)((char *)v16 + v15);
          v17 = (float32x4_t *)((char *)v17 + v14);
        }
        while (v13 != v6);
      }
    }
  }
  *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a2 + 42) + 416) + 80) += HGGetTBC() - v4;
  return 0;
}

const char *HGColorMatrix::GetProgram(HGColorMatrix *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002dd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0.x = dot(hg_Params[0], float4(r0));\n"
             "    output.color0.y = dot(hg_Params[1], float4(r0));\n"
             "    output.color0.z = dot(hg_Params[2], float4(r0));\n"
             "    output.color0.w = dot(hg_Params[3], float4(r0));\n"
             "    return output;\n"
             "}\n"
             "//MD5=72217420:491e0715:a85d6da8:94aef8d2\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0004:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002b7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0.x = dot(hg_Params[0], r0);\n"
             "    output.color0.y = dot(hg_Params[1], r0);\n"
             "    output.color0.z = dot(hg_Params[2], r0);\n"
             "    output.color0.w = dot(hg_Params[3], r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=f59a11f6:3c3dcb91:f1061cc0:3190f271\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0004:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000306\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "uniform defaultp vec4 hg_ProgramLocal2;\n"
           "uniform defaultp vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor.x = dot(hg_ProgramLocal0, r0);\n"
           "    gl_FragColor.y = dot(hg_ProgramLocal1, r0);\n"
           "    gl_FragColor.z = dot(hg_ProgramLocal2, r0);\n"
           "    gl_FragColor.w = dot(hg_ProgramLocal3, r0);\n"
           "}\n"
           "//MD5=8fc18786:e8a829e3:4774e200:4d62edae\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0004:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HGColorMatrix::InitProgramDescriptor(HGColorMatrix *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HGColorMatrix_hgc_visible", "//Metal1.0     \n//LEN=000000018e\n[[ visible ]] FragmentOut HGColorMatrix_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0.x = dot(hg_Params[0], r0);\n"
    "    output.color0.y = dot(hg_Params[1], r0);\n"
    "    output.color0.z = dot(hg_Params[2], r0);\n"
    "    output.color0.w = dot(hg_Params[3], r0);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B1C84C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void **a21,void **a22)
{
  void **v23;
  void **v24;

  if (a18 < 0)
    operator delete(__p);
  if (a21)
  {
    v23 = a22;
    v24 = a21;
    if (a22 != a21)
    {
      do
      {
        if (*((char *)v23 - 17) < 0)
          operator delete(*(v23 - 5));
        v23 -= 6;
      }
      while (v23 != a21);
      v24 = a21;
    }
    operator delete(v24);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGColorMatrix::RenderFragment(float32x4_t *a1, float32x4_t *a2, HGTile *this)
{
  uint64_t v6;
  int v7;
  float32x4_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  int32x4_t v12;
  float32x2_t v13;
  float32x4_t *v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int32x4_t v19;

  v6 = HGTile::Renderer(this);
  v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 128))(v6, 23);
  *(float32x2_t *)v8.f32 = vadd_f32(vcvt_f32_s32(*(int32x2_t *)this), (float32x2_t)0x3F0000003F000000);
  v8.i64[1] = 0x3F80000000000000;
  v9 = *((_QWORD *)this + 10);
  v10 = *((int *)this + 22);
  v11 = vsubq_f32(a2[1], v8);
  if (v7)
  {
    v12 = vaddq_s32(vcvtq_s32_f32(v11), vcltzq_f32(v11));
    v13 = (float32x2_t)vsubq_f32(v11, vcvtq_f32_s32(v12)).u64[0];
    v14 = (float32x4_t *)(v9 + 16 * (v12.i32[0] + v12.i32[1] * (int)v10));
    v15 = vaddq_f32(*v14, vmulq_n_f32(vsubq_f32(v14[1], *v14), v13.f32[0]));
    v16 = vaddq_f32(v15, vmulq_lane_f32(vsubq_f32(vaddq_f32(v14[v10], vmulq_n_f32(vsubq_f32(v14[(int)v10 + 1], v14[v10]), v13.f32[0])), v15), v13, 1));
  }
  else
  {
    v17.i64[0] = 0x3F0000003F000000;
    v17.i64[1] = 0x3F0000003F000000;
    v18 = vaddq_f32(v11, v17);
    v19 = vcvtq_s32_f32(v18);
    v18.i64[0] = vaddq_s32(v19, vcgtq_f32(vcvtq_f32_s32(v19), v18)).u64[0];
    v16 = *(float32x4_t *)(v9 + 16 * (v18.i32[0] + v18.i32[1] * (int)v10));
  }
  *(float32x4_t *)*((_QWORD *)this + 2) = vaddq_f32(vmulq_laneq_f32(a1[30], v16, 3), vaddq_f32(vmulq_laneq_f32(a1[29], v16, 2), vaddq_f32(vmulq_n_f32(a1[27], v16.f32[0]), vmulq_lane_f32(a1[28], *(float32x2_t *)v16.f32, 1))));
  return 0;
}

uint64_t HGColorMatrix::Bind(HGColorMatrix *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 0, *((float *)this + 108), *((float *)this + 112), *((float *)this + 116), *((float *)this + 120));
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 1, *((float *)this + 109), *((float *)this + 113), *((float *)this + 117), *((float *)this + 121));
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 2, *((float *)this + 110), *((float *)this + 114), *((float *)this + 118), *((float *)this + 122));
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 3, *((float *)this + 111), *((float *)this + 115), *((float *)this + 119), *((float *)this + 123));
  return 0;
}

uint64_t HGColorMatrix::BindTexture(HGColorMatrix *this, HGHandler *a2, int a3)
{
  HGHandler::TexCoord(a2, a3, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  return 0;
}

void HGColorMatrix::HGColorMatrix(HGColorMatrix *this)
{
  _QWORD *v2;
  _OWORD *v3;
  int v4;

  HGNode3D::HGNode3D(this);
  *v2 = off_1E6532420;
  v3 = (_OWORD *)operator new();
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  *((_QWORD *)this + 51) = 0;
  *((_QWORD *)this + 52) = v3;
  *((_OWORD *)this + 27) = xmmword_1B304F230;
  *((_OWORD *)this + 28) = xmmword_1B304F240;
  *((_OWORD *)this + 29) = xmmword_1B304F250;
  *((_OWORD *)this + 30) = xmmword_1B304EFF0;
  v4 = *((_DWORD *)this + 4) | 0x600;
  *((_DWORD *)this + 3) = -735746939;
  *((_DWORD *)this + 4) = v4;
}

{
  _QWORD *v2;
  _OWORD *v3;
  int v4;

  HGNode3D::HGNode3D(this);
  *v2 = off_1E6532420;
  v3 = (_OWORD *)operator new();
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  *((_QWORD *)this + 51) = 0;
  *((_QWORD *)this + 52) = v3;
  *((_OWORD *)this + 27) = xmmword_1B304F230;
  *((_OWORD *)this + 28) = xmmword_1B304F240;
  *((_OWORD *)this + 29) = xmmword_1B304F250;
  *((_OWORD *)this + 30) = xmmword_1B304EFF0;
  v4 = *((_DWORD *)this + 4) | 0x600;
  *((_DWORD *)this + 3) = -735746939;
  *((_DWORD *)this + 4) = v4;
}

void sub_1B2B1CBB0(_Unwind_Exception *a1)
{
  HGMipmapLevel *v1;

  HGMipmapLevel::~HGMipmapLevel(v1);
  _Unwind_Resume(a1);
}

void sub_1B2B1CC58(_Unwind_Exception *a1)
{
  HGMipmapLevel *v1;

  HGMipmapLevel::~HGMipmapLevel(v1);
  _Unwind_Resume(a1);
}

void HGColorMatrix::~HGColorMatrix(HGColorMatrix *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E6532420;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 52);
  if (v3)
    MEMORY[0x1B5E29170](v3, 0x1000C40FA0F61DDLL);
  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E6532420;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 52);
  if (v3)
    MEMORY[0x1B5E29170](v3, 0x1000C40FA0F61DDLL);
  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_1E6532420;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 52);
  if (v3)
    MEMORY[0x1B5E29170](v3, 0x1000C40FA0F61DDLL);
  HGMipmapLevel::~HGMipmapLevel(this);
  HGObject::operator delete(v4);
}

__n128 HGColorMatrix::ParameterizeMatrix(__n128 *this, HGRenderer *a2)
{
  __n128 result;

  *(__n128 *)this[26].n128_u64[0] = this[27];
  *(__n128 *)(this[26].n128_u64[0] + 16) = this[28];
  *(__n128 *)(this[26].n128_u64[0] + 32) = this[29];
  result = this[30];
  *(__n128 *)(this[26].n128_u64[0] + 48) = result;
  return result;
}

const char *HgcCropShaderBlend::GetProgram(HgcCropShaderBlend *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000037c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0;\n"
             "    float4 s0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    s0.xy = frag._texCoord1.xy - hg_Params[0].xy;\n"
             "    s0.zw = hg_Params[0].zw - frag._texCoord1.xy;\n"
             "    s0 = float4(s0 < float4(c0.xxxx));\n"
             "    s0 = float4(dot(s0, 1.00000f));\n"
             "    s0 = float4(s0 <= float4(c0.xxxx));\n"
             "    s0 = float4(r0)*s0;\n"
             "    output.color0 = s0*hg_Params[1];\n"
             "    return output;\n"
             "}\n"
             "//MD5=f9b56c77:153e25ee:692c907c:ff332280\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000355\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = frag._texCoord1.xy - hg_Params[0].xy;\n"
             "    r1.zw = hg_Params[0].zw - frag._texCoord1.xy;\n"
             "    r1 = float4(r1 < c0.xxxx);\n"
             "    r1 = float4(dot(r1, 1.00000f));\n"
             "    r1 = float4(r1 <= c0.xxxx);\n"
             "    r0 = r0*r1;\n"
             "    output.color0 = r0*hg_Params[1];\n"
             "    return output;\n"
             "}\n"
             "//MD5=71c0cb25:36879384:725a4797:f8967426\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000037c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xy = hg_TexCoord1.xy - hg_ProgramLocal0.xy;\n"
           "    r1.zw = hg_ProgramLocal0.zw - hg_TexCoord1.xy;\n"
           "    r1 = vec4(lessThan(r1, c0.xxxx));\n"
           "    r1 = vec4(dot(r1, vec4(1.00000)));\n"
           "    r1 = vec4(lessThanEqual(r1, c0.xxxx));\n"
           "    r0 = r0*r1;\n"
           "    gl_FragColor = r0*hg_ProgramLocal1;\n"
           "}\n"
           "//MD5=87b4563c:a08283dd:e21ff672:445d5bf6\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcCropShaderBlend::InitProgramDescriptor(HgcCropShaderBlend *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcCropShaderBlend_hgc_visible", "//Metal1.0     \n//LEN=000000023b\n[[ visible ]] FragmentOut HgcCropShaderBlend_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xy = texCoord1.xy - hg_Params[0].xy;\n"
    "    r1.zw = hg_Params[0].zw - texCoord1.xy;\n"
    "    r1 = float4(r1 < c0.xxxx);\n"
    "    r1 = float4(dot(r1, 1.00000f));\n"
    "    r1 = float4(r1 <= c0.xxxx);\n"
    "    r0 = r0*r1;\n"
    "    output.color0 = r0*hg_Params[1];\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B1D0F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B1D12C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B1D124);
}

double HgcCropShaderBlend::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcCropShaderBlend [hgc1]");
  return *(double *)"aderBlend [hgc1]";
}

uint64_t HgcCropShaderBlend::BindTexture(HgcCropShaderBlend *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcCropShaderBlend::Bind(HgcCropShaderBlend *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcCropShaderBlend *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcCropShaderBlend::GetDOD(HgcCropShaderBlend *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcCropShaderBlend::GetROI(HgcCropShaderBlend *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcCropShaderBlend::~HgcCropShaderBlend(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6532698;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6532698;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcCropShaderBlend::SetParameter(HgcCropShaderBlend *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcCropShaderBlend::GetParameter(HgcCropShaderBlend *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

uint64_t HGCropNode::SupportsInplaceHardwareBlending(HGCropNode *this, float a2)
{
  return 1;
}

uint64_t HGCropNode::SetParameter@<X0>(HGCropNode *this@<X0>, float a2@<S0>, float a3@<S1>, float a4@<S2>, float a5@<S3>, int a6@<W1>, uint64_t a7@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;

  if (a6)
    return 0xFFFFFFFFLL;
  v9 = HGRectMake4f(a7, a2, a3, a4, a5);
  v11 = v10;
  if (HGRectIsEqual(v9, v10, *((_QWORD *)this + 52), *((_QWORD *)this + 53)))
    return 0;
  *((_QWORD *)this + 52) = v9;
  *((_QWORD *)this + 53) = v11;
  HGNode::ClearBits((HGNode *)this, v12, v13);
  return 1;
}

uint64_t HGCropNode::BindTexture(HGCropNode *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HGCropNode::Bind(HGCropNode *this, HGHandler *a2)
{
  double v4;

  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 0, (float)*((int *)this + 104), (float)*((int *)this + 105), (float)*((int *)this + 106), (float)*((int *)this + 107));
  v4 = (*(double (**)(HGCropNode *))(*(_QWORD *)this + 288))(this);
  (*(void (**)(HGHandler *, uint64_t, double, float, float, float))(*(_QWORD *)a2 + 136))(a2, 1, v4, *(float *)&v4, *(float *)&v4, *(float *)&v4);
  return 0;
}

uint64_t HGCropNode::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;
  uint64_t DOD;
  uint64_t v9;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  DOD = HGRenderer::GetDOD(a2, Input);
  return HGRectIntersection(DOD, v9, *((_QWORD *)this + 52), *((_QWORD *)this + 53));
}

HGNode *HGCropNode::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGNode *v3;
  HGNode *Input;
  uint64_t DOD;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = this;
  Input = HGRenderer::GetInput(a2, this, 0);
  DOD = HGRenderer::GetDOD(a2, Input);
  v7 = v6;
  v8 = HGRectIntersection(DOD, v6, *((_QWORD *)v3 + 52), *((_QWORD *)v3 + 53));
  if (Input && HGRectIsEqual(DOD, v7, v8, v9))
  {
    (*(void (**)(HGNode *, uint64_t, uint64_t))(*(_QWORD *)Input + 136))(Input, 0xFFFFFFFFLL, 32);
    return Input;
  }
  return v3;
}

uint64_t HGCropNode::RenderPage(HGNode *this, HGPage *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  HGPage *v8;

  v4 = (*(uint64_t (**)(HGNode *, uint64_t, _QWORD))(*(_QWORD *)this + 168))(this, 23, 0);
  HGPagePullTexturesGuard::HGPagePullTexturesGuard((HGPagePullTexturesGuard *)&v8, this, a2);
  v5 = *((_QWORD *)a2 + 21);
  if (!v5
    || !HGRectIsEqual(*(_QWORD *)(v5 + 20), *(_QWORD *)(v5 + 28), *((_QWORD *)a2 + 2), *((_QWORD *)a2 + 3))
    || *((_QWORD *)a2 + 1)
    || v4)
  {
    v6 = HGNode::RenderPage(this, (HGRect *)a2);
  }
  else
  {
    (*(void (**)(_QWORD))(**((_QWORD **)a2 + 21) + 16))(*((_QWORD *)a2 + 21));
    v6 = *((_QWORD *)a2 + 21);
  }
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard(&v8);
  return v6;
}

void sub_1B2B1D7D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard((HGPage **)va);
  _Unwind_Resume(a1);
}

uint64_t HGCropNode::RenderPageMetal(HGNode *this, HGPage *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  HGPage *v8;

  v4 = (*(uint64_t (**)(HGNode *, uint64_t, _QWORD))(*(_QWORD *)this + 168))(this, 23, 0);
  HGPagePullMetalTexturesGuard::HGPagePullMetalTexturesGuard((HGPagePullMetalTexturesGuard *)&v8, this, a2);
  v5 = *((_QWORD *)a2 + 21);
  if (!v5
    || !HGRectIsEqual(*(_QWORD *)(v5 + 20), *(_QWORD *)(v5 + 28), *((_QWORD *)a2 + 2), *((_QWORD *)a2 + 3))
    || *((_QWORD *)a2 + 1)
    || v4)
  {
    v6 = HGNode::RenderPageMetal(this, a2);
  }
  else
  {
    (*(void (**)(_QWORD))(**((_QWORD **)a2 + 21) + 16))(*((_QWORD *)a2 + 21));
    v6 = *((_QWORD *)a2 + 21);
  }
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard(&v8);
  return v6;
}

void sub_1B2B1D898(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard((HGPage **)va);
  _Unwind_Resume(a1);
}

const char *HGCropNode::GetProgram(HGCropNode *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000037c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0;\n"
             "    float4 s0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    s0.xy = frag._texCoord1.xy - hg_Params[0].xy;\n"
             "    s0.zw = hg_Params[0].zw - frag._texCoord1.xy;\n"
             "    s0 = float4(s0 < float4(c0.xxxx));\n"
             "    s0 = float4(dot(s0, 1.00000f));\n"
             "    s0 = float4(s0 <= float4(c0.xxxx));\n"
             "    s0 = float4(r0)*s0;\n"
             "    output.color0 = s0*hg_Params[1];\n"
             "    return output;\n"
             "}\n"
             "//MD5=f9b56c77:153e25ee:692c907c:ff332280\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000355\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = frag._texCoord1.xy - hg_Params[0].xy;\n"
             "    r1.zw = hg_Params[0].zw - frag._texCoord1.xy;\n"
             "    r1 = float4(r1 < c0.xxxx);\n"
             "    r1 = float4(dot(r1, 1.00000f));\n"
             "    r1 = float4(r1 <= c0.xxxx);\n"
             "    r0 = r0*r1;\n"
             "    output.color0 = r0*hg_Params[1];\n"
             "    return output;\n"
             "}\n"
             "//MD5=71c0cb25:36879384:725a4797:f8967426\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000037c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xy = hg_TexCoord1.xy - hg_ProgramLocal0.xy;\n"
           "    r1.zw = hg_ProgramLocal0.zw - hg_TexCoord1.xy;\n"
           "    r1 = vec4(lessThan(r1, c0.xxxx));\n"
           "    r1 = vec4(dot(r1, vec4(1.00000)));\n"
           "    r1 = vec4(lessThanEqual(r1, c0.xxxx));\n"
           "    r0 = r0*r1;\n"
           "    gl_FragColor = r0*hg_ProgramLocal1;\n"
           "}\n"
           "//MD5=87b4563c:a08283dd:e21ff672:445d5bf6\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HGCrop::HGCrop(HGCrop *this)
{
  _QWORD *v2;
  HGNode *v3;
  _OWORD *v4;
  int v5;
  HGNode *v6;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65328E8;
  v2[51] = 0;
  v3 = (HGNode *)HGObject::operator new(0x1B0uLL);
  HGNode::HGNode(v3);
  *(_QWORD *)v3 = off_1E6532698;
  v4 = (_OWORD *)operator new();
  *v4 = 0u;
  v4[1] = 0u;
  *((_QWORD *)v3 + 51) = v4;
  v5 = *((_DWORD *)v3 + 4) | 0x600;
  *(_QWORD *)v3 = off_1E6532B68;
  *((_OWORD *)v3 + 26) = HGRectInfinite;
  *((_DWORD *)v3 + 3) = 1663829387;
  *((_DWORD *)v3 + 4) = v5;
  v6 = (HGNode *)*((_QWORD *)this + 51);
  if (v6 == v3)
  {
    HGObject::Release((unsigned int *)v3);
    v3 = (HGNode *)*((_QWORD *)this + 51);
  }
  else
  {
    if (v6)
      (*(void (**)(HGNode *))(*(_QWORD *)v6 + 24))(v6);
    *((_QWORD *)this + 51) = v3;
  }
  *((_DWORD *)this + 3) = *((_DWORD *)v3 + 3);
}

void sub_1B2B1DA40(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v4 = *(_QWORD *)(v1 + 408);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

uint64_t HGCrop::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  v5 = *((_QWORD *)this + 51);
  v6 = (*(uint64_t (**)(HGNode *, _QWORD))(*(_QWORD *)this + 152))(this, 0);
  (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v5 + 136))(v5, 0, v6);
  v7 = *((_QWORD *)this + 51);
  v8 = (*(uint64_t (**)(HGNode *, uint64_t))(*(_QWORD *)this + 152))(this, 0xFFFFFFFFLL);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 136))(v7, 0xFFFFFFFFLL, v8);
  return *((_QWORD *)this + 51);
}

uint64_t HGCrop::SetParameter(HGCrop *this, float a2, float a3, float a4, float a5)
{
  return (*(uint64_t (**)(_QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), a2, a3, a4, a5);
}

void HGCrop::~HGCrop(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65328E8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65328E8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

void HGCropNode::~HGCropNode(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6532698;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6532698;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

const char *HGFlipAndOffset::GetProgram(HGFlipAndOffset *this, HGRenderer *a2)
{
  unsigned int Target;
  BOOL v4;
  unsigned int v5;

  Target = HGRenderer::GetTarget(a2, 393216);
  v4 = Target != 396048 && Target > 0x6060F;
  if (v4
    && !(*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46)
    && !(*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 21))
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003a8\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r1.xy = hg_TexCoord0.xy + hg_ProgramLocal1.xy;\n"
           "    r1.xy = r1.xy*hg_ProgramLocal1.zw;\n"
           "    r2.xy = r1.xy - c0.xy;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal2.zw;\n"
           "    r2.xy = clamp(hg_ProgramLocal2.xy - abs(r2.xy), vec2(0.00000), vec2(1.00000));\n"
           "    r2.x = r2.x*r2.y;\n"
           "    r1 = texture2D(hg_Texture0, r1.xy);\n"
           "    r0 = r1*r2.xxxx;\n"
           "    gl_FragColor = r0*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=42327dac:13de7175:fffb9b2f:8f6d6d8c\n"
           "//SIG=00000000:00000000:00000000:00000000:000c:0003:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
  v5 = HGRenderer::GetTarget(a2, 393216);
  if (v5 == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000236\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0)*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=5499c239:9891868e:bd9ea6d3:bd30d467\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000228\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=6eae314a:ee581af3:fdfce447:74b07bd6\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (v5 <= 0x6060F || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001f6\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=78149511:5c47b7fc:9d3dfb0a:c601ba4b\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HGFlipAndOffset::InitProgramDescriptor(HGFlipAndOffset *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HGFlipAndOffset_hgc_visible", "//Metal1.0     \n//LEN=0000000101\n[[ visible ]] FragmentOut HGFlipAndOffset_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0*hg_Params[0];\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B1DF9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void **a21,void **a22)
{
  void **v23;
  void **v24;

  if (a18 < 0)
    operator delete(__p);
  if (a21)
  {
    v23 = a22;
    v24 = a21;
    if (a22 != a21)
    {
      do
      {
        if (*((char *)v23 - 17) < 0)
          operator delete(*(v23 - 5));
        v23 -= 6;
      }
      while (v23 != a21);
      v24 = a21;
    }
    operator delete(v24);
  }
  _Unwind_Resume(exception_object);
}

void HGToneCurve::HGToneCurve(HGToneCurve *this)
{
  uint64_t v2;
  HGToneCurve::State *v8;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v2 = off_1E6532DD0;
  *(_DWORD *)(v2 + 16) |= 0x400u;
  *(_QWORD *)(v2 + 408) = 0;
  *(_BYTE *)(v2 + 416) = 1;
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(v2 + 440) = _D0;
  *(_DWORD *)(v2 + 424) = 0;
  *(_QWORD *)(v2 + 448) = 0;
  *(_QWORD *)(v2 + 456) = 0;
  *(_DWORD *)(v2 + 464) = 0;
  v8 = (HGToneCurve::State *)operator new();
  HGToneCurve::State::State(v8);
  *((_QWORD *)this + 54) = v8;
}

void sub_1B2B1E0A0(_Unwind_Exception *a1)
{
  HGNode *v1;
  uint64_t v2;
  uint64_t v3;

  v3 = v2;
  MEMORY[0x1B5E29170](v3, 0x1000C40BF75E1D5);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2B1E0D0(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGToneCurve::~HGToneCurve(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6532DD0;
  v2 = *((_QWORD *)this + 54);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40BF75E1D5);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6532DD0;
  v2 = *((_QWORD *)this + 54);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40BF75E1D5);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGToneCurve::GetDOD(HGToneCurve *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HGToneCurve::GetROI(HGToneCurve *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HGToneCurve::SetParameter(HGNode *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  BOOL v8;
  unsigned int v9;
  float v10;
  unsigned int v11;
  float v12;

  switch((_DWORD)a2)
  {
    case 2:
      *((float *)this + 114) = a3;
      *((float *)this + 115) = a4;
      *((float *)this + 116) = a5;
LABEL_20:
      HGNode::ClearBits(this, a2, a7);
      *((_DWORD *)this + 106) = HGToneCurve::AcceleratedState(*((_DWORD *)this + 102), *((float *)this + 110), *((float *)this + 111), *((float *)this + 112), *((float *)this + 113), *((float *)this + 114), *((float *)this + 115), *((float *)this + 116));
      return 1;
    case 1:
      *((float *)this + 110) = a3;
      *((float *)this + 111) = a4;
      *((float *)this + 112) = a5;
      *((float *)this + 113) = a6;
      goto LABEL_20;
    case 0:
      v8 = a3 > 4.0 || a3 < 0.0;
      v9 = a3;
      if (v8)
        v9 = 0;
      v10 = 7.0;
      if (a4 <= 7.0)
        v10 = a4;
      if (a4 < 0.0)
        v10 = 0.0;
      v11 = v10;
      v12 = 1.0;
      if (a5 <= 1.0)
        v12 = a5;
      if (a5 < 0.0)
        v12 = 0.0;
      *((_DWORD *)this + 102) = v9;
      *((_DWORD *)this + 103) = v11;
      *((_BYTE *)this + 416) = (int)v12 != 0;
      goto LABEL_20;
  }
  return 0xFFFFFFFFLL;
}

uint64_t HGToneCurve::AcceleratedState(int a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  uint64_t result;
  float v9;
  BOOL v10;
  float v11;
  BOOL v12;
  float v13;
  BOOL v14;
  BOOL v15;
  unsigned int v16;
  float v17;
  BOOL v18;
  float v19;
  BOOL v20;
  float v21;
  BOOL v22;

  if (a1 != 4)
  {
    if (a1 != 3)
    {
      if (!a1)
      {
        if (a8 == 0.0 && a7 == 0.0 && a6 == 0.0 && a5 == 0.0 && a4 == 0.0 && a3 == 0.0 && fabsf(a2 + -1.956) < 0.01)
          return 7;
        v15 = fabsf(a2 + -0.51125) < 0.01 && a3 == 0.0 && a4 == 0.0 && a5 == 0.0 && a6 == 0.0 && a7 == 0.0 && a8 == 0.0;
        v16 = 8;
        goto LABEL_73;
      }
      return 0;
    }
    v17 = fabsf(a3 + -0.909);
    v18 = fabsf(a2 + -2.22) < 0.01 && v17 < 0.001;
    v19 = fabsf(a4 + -0.09);
    v20 = v18 && v19 < 0.01;
    v21 = fabsf(a5 + -0.222);
    v22 = v20 && v21 < 0.001;
    if (v22 && a8 == 0.0 && a7 == 0.0 && fabsf(a6 + -0.0809) < 0.001)
      return 1;
    if (fabsf(a2 + -2.4) >= 0.01
      || fabsf(a3 + -0.94787) >= 0.001
      || fabsf(a4 + -0.052133) >= 0.001
      || fabsf(a5 + -0.077399) >= 0.0001)
    {
      return 0;
    }
    v15 = fabsf(a6 + -0.04045) < 0.0001 && a7 == 0.0 && a8 == 0.0;
    v16 = 5;
LABEL_73:
    if (v15)
      return v16;
    else
      return 0;
  }
  if (fabsf(a2 + -0.45) < 0.01)
  {
    v9 = fabsf(a3 + -1.23);
    v10 = a4 == 0.0 && v9 < 0.01;
    v11 = fabsf(a5 + -4.5);
    v12 = v10 && v11 < 0.1;
    v13 = fabsf(a6 + -0.018);
    v14 = v12 && v13 < 0.001;
    if (v14 && a8 == 0.0 && fabsf(a7 + 0.099) < 0.001)
      return 2;
  }
  result = 0;
  if (fabsf(a2 + -0.41667) < 0.01 && a4 == 0.0 && fabsf(a3 + -1.1371) < 0.01)
  {
    if (fabsf(a5 + -12.92) >= 0.1 || fabsf(a6 + -0.0031308) >= 0.0001)
      return 0;
    v15 = fabsf(a7 + 0.055) < 0.0005 && a8 == 0.0;
    v16 = 6;
    goto LABEL_73;
  }
  return result;
}

uint64_t HGToneCurve::GetParameter(HGToneCurve *this, int a2, float *a3)
{
  float v3;
  float v4;
  uint64_t result;
  int v6;
  int v7;

  if (a2 == 2)
  {
    *a3 = *((float *)this + 114);
    a3[1] = *((float *)this + 115);
    v6 = *((_DWORD *)this + 116);
    result = 0;
    *((_DWORD *)a3 + 2) = v6;
    a3[3] = 0.0;
  }
  else if (a2 == 1)
  {
    *a3 = *((float *)this + 110);
    a3[1] = *((float *)this + 111);
    a3[2] = *((float *)this + 112);
    v7 = *((_DWORD *)this + 113);
    result = 0;
    *((_DWORD *)a3 + 3) = v7;
  }
  else if (a2)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    *(float32x2_t *)a3 = vcvt_f32_u32(*(uint32x2_t *)((char *)this + 408));
    v3 = 0.0;
    if (*((_BYTE *)this + 416))
      v3 = 1.0;
    a3[2] = v3;
    v4 = (float)*((unsigned int *)this + 106);
    result = 0;
    a3[3] = v4;
  }
  return result;
}

double HGToneCurve::SetShaderParams(HGToneCurve *this, double result)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  float v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;

  v3 = *((_QWORD *)this + 54);
  switch(*((_DWORD *)this + 102))
  {
    case 0:
      *(_DWORD *)v3 = *((_DWORD *)this + 110);
      v4 = *((_DWORD *)this + 105) - 4;
      *(_OWORD *)(v3 + 4) = xmmword_1B304F250;
      *(_DWORD *)(v3 + 20) = 0;
      if (v4 > 2)
      {
        result = 0.0078125;
        *(_QWORD *)(v3 + 24) = 0x3F80000000000000;
      }
      else
      {
        result = 2.00000047;
        *(_QWORD *)(v3 + 24) = 0x400000003F800000;
      }
      return result;
    case 1:
      *(_DWORD *)v3 = *((_DWORD *)this + 110);
      *(float *)(v3 + 4) = *((float *)this + 112) / *((float *)this + 111);
      *(_DWORD *)(v3 + 8) = 0;
      *(float *)(v3 + 12) = powf(*((float *)this + 111), *((float *)this + 110));
      v8 = *((_DWORD *)this + 105) - 11;
      *(_DWORD *)(v3 + 16) = 0;
      *(float *)&result = (float)-*((float *)this + 112) / *((float *)this + 111);
      *(_DWORD *)(v3 + 20) = LODWORD(result);
      *(_DWORD *)(v3 + 24) = 0;
      if (v8 <= 2)
        goto LABEL_15;
      goto LABEL_13;
    case 2:
      *(_DWORD *)v3 = *((_DWORD *)this + 110);
      *(float *)(v3 + 4) = *((float *)this + 112) / *((float *)this + 111);
      *(_DWORD *)(v3 + 8) = 0;
      *(float *)(v3 + 12) = powf(*((float *)this + 111), *((float *)this + 110));
      v5 = *((_DWORD *)this + 105);
      if (v5 > 0x1B || (LODWORD(result) = 2.0, ((1 << v5) & 0x80C0000) == 0))
        LODWORD(result) = 1.0;
      *(_DWORD *)(v3 + 16) = 0;
      v6 = (float)-*((float *)this + 112) / *((float *)this + 111);
      goto LABEL_11;
    case 3:
      *(_DWORD *)v3 = *((_DWORD *)this + 110);
      *(float *)(v3 + 4) = *((float *)this + 112) / *((float *)this + 111);
      *(_DWORD *)(v3 + 8) = 0;
      *(float *)(v3 + 12) = powf(*((float *)this + 111), *((float *)this + 110));
      v9 = *((_DWORD *)this + 105) - 25;
      *(_DWORD *)(v3 + 16) = *((_DWORD *)this + 113);
      LODWORD(result) = *((_DWORD *)this + 114);
      *(_DWORD *)(v3 + 20) = LODWORD(result);
      *(_DWORD *)(v3 + 24) = 0;
      if (v9 > 2)
LABEL_13:
        *(_DWORD *)(v3 + 28) = 1065353216;
      else
LABEL_15:
        *(_DWORD *)(v3 + 28) = 0x40000000;
      return result;
    case 4:
      *(_DWORD *)v3 = *((_DWORD *)this + 110);
      *(float *)(v3 + 4) = *((float *)this + 112) / *((float *)this + 111);
      *(float *)(v3 + 8) = *((float *)this + 115) - *((float *)this + 116);
      *(float *)(v3 + 12) = powf(*((float *)this + 111), *((float *)this + 110));
      v7 = *((_DWORD *)this + 105) - 32;
      *(_DWORD *)(v3 + 16) = *((_DWORD *)this + 113);
      LODWORD(result) = 1.0;
      if (v7 < 3)
        *(float *)&result = 2.0;
      v6 = *((float *)this + 114);
LABEL_11:
      *(float *)(v3 + 20) = v6;
      *(_DWORD *)(v3 + 24) = 0;
      *(_DWORD *)(v3 + 28) = LODWORD(result);
      *(_DWORD *)(v3 + 32) = 0;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t HGToneCurve::BindTexture(HGToneCurve *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HGToneCurve::Bind(HGToneCurve *this, HGHandler *a2)
{
  if (*((_DWORD *)this + 106))
    return 0;
  switch(*((_DWORD *)this + 102))
  {
    case 1:
    case 3:
      goto LABEL_5;
    case 2:
    case 4:
      (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 54) + 32, 1);
LABEL_5:
      (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 54) + 16, 1);
      break;
    default:
      break;
  }
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 54), 1);
  return 0;
}

uint64_t HGToneCurve::GetProgram(HGToneCurve *this, HGRenderer *a2)
{
  uint64_t (**v2)(HGRenderer *);

  if (*((_BYTE *)this + 416))
    v2 = hgtonecurve_getprogram;
  else
    v2 = hgtonecurve_getprogram_unpremult;
  return v2[*((unsigned int *)this + 105)](a2);
}

uint64_t HGToneCurve::InitProgramDescriptor(HGToneCurve *this, HGProgramDescriptor *a2)
{
  uint64_t (**v2)(HGProgramDescriptor *);

  if (*((_BYTE *)this + 416))
    v2 = hgtonecurve_initprogramdesc;
  else
    v2 = hgtonecurve_initprogramdesc_unpremult;
  return v2[*((unsigned int *)this + 105)](a2);
}

uint64_t HGToneCurve::RenderTile(HGToneCurve *this, HGTile *a2)
{
  uint64_t (**v2)(HGTile *, HGToneCurve::State *, HGNode *);

  if (*((_BYTE *)this + 416))
    v2 = hgtonecurve_rendertile;
  else
    v2 = hgtonecurve_rendertile_unpremult;
  return v2[*((unsigned int *)this + 105)](a2, *((HGToneCurve::State **)this + 54), (HGNode *)this);
}

uint64_t HGToneCurve::SetToneCurveParams(uint64_t a1, uint64_t a2, char *a3, float a4, float a5, float a6, float a7, float a8, float a9, float a10)
{
  int v17;
  int v19;
  uint64_t result;

  v17 = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  if ((v17 & ~(v17 >> 31)) >= 4)
    v19 = 4;
  else
    v19 = v17 & ~(v17 >> 31);
  *(_DWORD *)(a1 + 408) = v19;
  *(float *)(a1 + 440) = a4;
  *(float *)(a1 + 444) = a5;
  *(float *)(a1 + 448) = a6;
  *(float *)(a1 + 452) = a7;
  *(float *)(a1 + 456) = a8;
  *(float *)(a1 + 460) = a9;
  *(float *)(a1 + 464) = a10;
  result = HGToneCurve::AcceleratedState(v19, a4, a5, a6, a7, a8, a9, a10);
  *(_DWORD *)(a1 + 424) = result;
  return result;
}

HGNode *HGToneCurve::SetToneCurveQuality(uint64_t a1, uint64_t a2, char *a3)
{
  int v3;
  HGNode *result;
  unsigned int v6;

  v3 = a2;
  result = HGNode::ClearBits((HGNode *)a1, a2, a3);
  v6 = v3 & ~(v3 >> 31);
  if (v6 >= 7)
    v6 = 7;
  *(_DWORD *)(a1 + 412) = v6;
  return result;
}

HGNode *HGToneCurve::SetPremultiplyState(HGNode *this, uint64_t a2, char *a3)
{
  char v3;
  HGNode *result;

  v3 = a2;
  result = HGNode::ClearBits(this, a2, a3);
  *((_BYTE *)this + 416) = v3;
  return result;
}

BOOL HGToneCurve::CanProcess(HGToneCurve *this)
{
  _BOOL8 v1;
  int v2;
  _BOOL8 result;

  switch(*((_DWORD *)this + 106))
  {
    case 1:
      v1 = 1;
      v2 = 41;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          goto LABEL_107;
        case 1:
          v2 = 42;
          goto LABEL_107;
        case 2:
          v2 = 44;
          goto LABEL_107;
        case 3:
        case 4:
          v2 = 43;
          goto LABEL_107;
        case 5:
          v2 = 45;
          goto LABEL_107;
        case 6:
        case 7:
          v2 = 46;
          goto LABEL_107;
        default:
          goto LABEL_18;
      }
    case 2:
      v1 = 1;
      v2 = 35;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          goto LABEL_107;
        case 1:
          v2 = 36;
          goto LABEL_107;
        case 2:
          v2 = 38;
          goto LABEL_107;
        case 3:
        case 4:
          v2 = 37;
          goto LABEL_107;
        case 5:
          v2 = 39;
          goto LABEL_107;
        case 6:
        case 7:
          v2 = 40;
          goto LABEL_107;
        default:
          goto LABEL_18;
      }
    case 3:
      v1 = 1;
      v2 = 53;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          goto LABEL_107;
        case 1:
          v2 = 54;
          goto LABEL_107;
        case 2:
          v2 = 56;
          goto LABEL_107;
        case 3:
        case 4:
          v2 = 55;
          goto LABEL_107;
        case 5:
          v2 = 57;
          goto LABEL_107;
        case 6:
        case 7:
          v2 = 58;
          goto LABEL_107;
        default:
          goto LABEL_18;
      }
    case 4:
      v1 = 1;
      v2 = 47;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          goto LABEL_107;
        case 1:
          v2 = 48;
          goto LABEL_107;
        case 2:
          v2 = 50;
          goto LABEL_107;
        case 3:
        case 4:
          v2 = 49;
          goto LABEL_107;
        case 5:
          v2 = 51;
          goto LABEL_107;
        case 6:
        case 7:
          v2 = 52;
          goto LABEL_107;
        default:
          goto LABEL_18;
      }
    case 5:
      v1 = 1;
      v2 = 65;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          goto LABEL_107;
        case 1:
          v2 = 66;
          goto LABEL_107;
        case 2:
          v2 = 68;
          goto LABEL_107;
        case 3:
        case 4:
          v2 = 67;
          goto LABEL_107;
        case 5:
          v2 = 69;
          goto LABEL_107;
        case 6:
        case 7:
          v2 = 70;
          goto LABEL_107;
        default:
          goto LABEL_18;
      }
    case 6:
      v1 = 1;
      v2 = 59;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          goto LABEL_107;
        case 1:
          v2 = 60;
          goto LABEL_107;
        case 2:
          v2 = 62;
          goto LABEL_107;
        case 3:
        case 4:
          v2 = 61;
          goto LABEL_107;
        case 5:
          v2 = 63;
          goto LABEL_107;
        case 6:
        case 7:
          v2 = 64;
          goto LABEL_107;
        default:
          goto LABEL_18;
      }
    case 7:
      v1 = 1;
      v2 = 77;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          goto LABEL_107;
        case 1:
          v2 = 78;
          goto LABEL_107;
        case 2:
          v2 = 80;
          goto LABEL_107;
        case 3:
        case 4:
          v2 = 79;
          goto LABEL_107;
        case 5:
          v2 = 81;
          goto LABEL_107;
        case 6:
        case 7:
          v2 = 82;
          goto LABEL_107;
        default:
          goto LABEL_18;
      }
    case 8:
      v1 = 1;
      v2 = 71;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          break;
        case 1:
          v2 = 72;
          break;
        case 2:
          v2 = 74;
          break;
        case 3:
        case 4:
          v2 = 73;
          break;
        case 5:
          v2 = 75;
          break;
        case 6:
        case 7:
          v2 = 76;
          break;
        default:
          goto LABEL_18;
      }
LABEL_107:
      *((_DWORD *)this + 105) = v2;
LABEL_108:
      result = v1;
      break;
    default:
LABEL_18:
      switch(*((_DWORD *)this + 102))
      {
        case 0:
          v1 = *((float *)this + 110) != 1.0;
          v2 = *((_DWORD *)this + 103);
          switch(v2)
          {
            case 0:
              goto LABEL_107;
            case 1:
              v2 = 1;
              goto LABEL_107;
            case 2:
              v2 = 3;
              goto LABEL_107;
            case 3:
            case 4:
              v2 = 2;
              goto LABEL_107;
            case 5:
              v2 = 4;
              goto LABEL_107;
            case 6:
              v2 = 5;
              goto LABEL_107;
            case 7:
              v2 = 6;
              goto LABEL_107;
            default:
              goto LABEL_108;
          }
          goto LABEL_108;
        case 1:
          v1 = *((float *)this + 110) != 1.0 || *((float *)this + 112) != 0.0 || *((float *)this + 111) != 1.0;
          v2 = 7;
          switch(*((_DWORD *)this + 103))
          {
            case 0:
              goto LABEL_107;
            case 1:
              v2 = 8;
              goto LABEL_107;
            case 2:
              v2 = 10;
              goto LABEL_107;
            case 3:
            case 4:
              v2 = 9;
              goto LABEL_107;
            case 5:
              v2 = 11;
              goto LABEL_107;
            case 6:
              v2 = 12;
              goto LABEL_107;
            case 7:
              v2 = 13;
              goto LABEL_107;
            default:
              goto LABEL_108;
          }
          goto LABEL_108;
        case 2:
          v1 = *((float *)this + 110) != 1.0
            || *((float *)this + 112) != 0.0
            || *((float *)this + 111) != 1.0
            || *((float *)this + 113) != 0.0;
          v2 = 14;
          switch(*((_DWORD *)this + 103))
          {
            case 0:
              goto LABEL_107;
            case 1:
              v2 = 15;
              goto LABEL_107;
            case 2:
              v2 = 17;
              goto LABEL_107;
            case 3:
            case 4:
              v2 = 16;
              goto LABEL_107;
            case 5:
              v2 = 18;
              goto LABEL_107;
            case 6:
              v2 = 19;
              goto LABEL_107;
            case 7:
              v2 = 20;
              goto LABEL_107;
            default:
              goto LABEL_108;
          }
          goto LABEL_108;
        case 3:
          v1 = *((float *)this + 110) != 1.0
            || *((float *)this + 112) != 0.0
            || *((float *)this + 111) != 1.0
            || *((float *)this + 113) != 1.0;
          v2 = 21;
          switch(*((_DWORD *)this + 103))
          {
            case 0:
              goto LABEL_107;
            case 1:
              v2 = 22;
              goto LABEL_107;
            case 2:
              v2 = 24;
              goto LABEL_107;
            case 3:
            case 4:
              v2 = 23;
              goto LABEL_107;
            case 5:
              v2 = 25;
              goto LABEL_107;
            case 6:
              v2 = 26;
              goto LABEL_107;
            case 7:
              v2 = 27;
              goto LABEL_107;
            default:
              goto LABEL_108;
          }
          goto LABEL_108;
        case 4:
          v1 = *((float *)this + 110) != 1.0
            || *((float *)this + 111) != 1.0
            || (float)(*((float *)this + 112) + *((float *)this + 115)) != 0.0
            || *((float *)this + 113) != 1.0
            || *((float *)this + 116) != 0.0;
          v2 = 28;
          switch(*((_DWORD *)this + 103))
          {
            case 0:
              goto LABEL_107;
            case 1:
              v2 = 29;
              goto LABEL_107;
            case 2:
              v2 = 31;
              goto LABEL_107;
            case 3:
            case 4:
              v2 = 30;
              goto LABEL_107;
            case 5:
              v2 = 32;
              goto LABEL_107;
            case 6:
              v2 = 33;
              goto LABEL_107;
            case 7:
              v2 = 34;
              goto LABEL_107;
            default:
              goto LABEL_108;
          }
          goto LABEL_108;
        default:
          result = 1;
          break;
      }
      break;
  }
  return result;
}

HGNode *HGToneCurve::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGNode *Input;
  HGToneCurve *v5;
  HGNode *v6;
  double v7;

  if (HGRenderer::IsMergeable(a2, this, 0, 0))
  {
    Input = HGRenderer::GetInput(a2, this, 0);
    if (Input)
    {
      if (v5)
      {
        v6 = (HGNode *)v5;
        if (HGToneCurve::CanBypass((HGToneCurve *)this, v5))
          return HGRenderer::GetInput(a2, v6, 0);
      }
    }
  }
  if (!HGToneCurve::CanProcess((HGToneCurve *)this))
    return HGRenderer::GetInput(a2, this, 0);
  HGToneCurve::SetShaderParams((HGToneCurve *)this, v7);
  return this;
}

BOOL HGToneCurve::CanBypass(HGToneCurve *this, HGToneCurve *a2)
{
  __n128 v4;
  _BOOL8 result;
  int v6;
  BOOL v8;
  float v9[3];
  float v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  (*(void (**)(HGToneCurve *, _QWORD, float *))(*(_QWORD *)a2 + 104))(a2, 0, v9);
  result = 0;
  if (v9[1] == (float)*((int *)this + 103))
  {
    v4.n128_f32[0] = v10;
    v6 = *((_DWORD *)this + 106);
    if (v6 == 2 && v10 == 1.0)
      return 1;
    v8 = v6 == 1 && v10 == 2.0;
    if (v8
      || v6 == 4 && v10 == 3.0
      || v6 == 3 && v10 == 4.0
      || v6 == 6 && v10 == 5.0
      || v6 == 5 && v10 == 6.0
      || v6 == 8 && v10 == 7.0
      || v6 == 7 && v10 == 8.0)
    {
      return 1;
    }
    else
    {
      (*(void (**)(HGToneCurve *, uint64_t, float *, __n128))(*(_QWORD *)a2 + 104))(a2, 1, v9, v4);
      return !*((_DWORD *)this + 102) && fabsf((float)(v9[0] * *((float *)this + 110)) + -1.0) < 0.000001;
    }
  }
  return result;
}

char *HGToneCurve::label_B(HGToneCurve *this)
{
  char **v1;

  if (*((_BYTE *)this + 416))
    v1 = hgtonecurve_read_label;
  else
    v1 = hgtonecurve_unpremult_read_label;
  return v1[*((unsigned int *)this + 105)];
}

double HGToneCurve::State::State(HGToneCurve::State *this)
{
  __int128 v1;
  double result;

  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = xmmword_1B304EFF0;
  *((_OWORD *)this + 4) = xmmword_1B3050E20;
  *((_OWORD *)this + 5) = xmmword_1B3051560;
  *((_OWORD *)this + 6) = xmmword_1B35257E0;
  *((_OWORD *)this + 7) = xmmword_1B35257F0;
  *((_OWORD *)this + 8) = xmmword_1B3525800;
  *((_OWORD *)this + 9) = xmmword_1B3525810;
  *((_OWORD *)this + 10) = xmmword_1B3525820;
  *((_OWORD *)this + 11) = xmmword_1B3525830;
  *((_OWORD *)this + 12) = xmmword_1B3525840;
  *((_OWORD *)this + 13) = xmmword_1B3524BB0;
  *((_OWORD *)this + 14) = xmmword_1B3525850;
  *((_OWORD *)this + 15) = xmmword_1B3050F70;
  *((int32x4_t *)this + 16) = vdupq_n_s32(0x358637BDu);
  *((_OWORD *)this + 17) = xmmword_1B30514E0;
  *((int32x4_t *)this + 18) = vdupq_n_s32(0x3F804020u);
  *((_OWORD *)this + 19) = xmmword_1B3051600;
  *((_OWORD *)this + 20) = xmmword_1B3051610;
  *((int32x4_t *)this + 21) = vdupq_n_s32(0x7F800000u);
  *((_OWORD *)this + 22) = xmmword_1B3051630;
  *((_OWORD *)this + 23) = xmmword_1B3051640;
  *((_OWORD *)this + 24) = xmmword_1B3051510;
  *((_OWORD *)this + 25) = xmmword_1B3051650;
  *((_OWORD *)this + 26) = xmmword_1B3051660;
  *((_OWORD *)this + 27) = xmmword_1B3051670;
  *((_OWORD *)this + 28) = xmmword_1B3051680;
  *((_OWORD *)this + 29) = xmmword_1B3051690;
  *((_OWORD *)this + 30) = xmmword_1B30516A0;
  *((_OWORD *)this + 31) = xmmword_1B30516B0;
  *((_OWORD *)this + 32) = xmmword_1B30516C0;
  *((_OWORD *)this + 33) = xmmword_1B30516D0;
  *((_OWORD *)this + 34) = xmmword_1B3052130;
  *((_OWORD *)this + 35) = xmmword_1B3051520;
  *((_OWORD *)this + 36) = xmmword_1B3053570;
  *((_OWORD *)this + 37) = xmmword_1B3525860;
  *((_OWORD *)this + 38) = xmmword_1B3525870;
  *((_OWORD *)this + 39) = xmmword_1B3525880;
  *((_OWORD *)this + 40) = xmmword_1B3525890;
  *((_OWORD *)this + 41) = xmmword_1B35258A0;
  *((_OWORD *)this + 42) = xmmword_1B35258B0;
  *((_OWORD *)this + 43) = xmmword_1B35258C0;
  *((_OWORD *)this + 44) = xmmword_1B35258D0;
  *((_OWORD *)this + 45) = xmmword_1B35258E0;
  *((_OWORD *)this + 46) = xmmword_1B35258F0;
  *((_OWORD *)this + 47) = xmmword_1B3525900;
  *((_OWORD *)this + 48) = xmmword_1B3525910;
  *((_OWORD *)this + 49) = xmmword_1B3525920;
  *(_QWORD *)&v1 = 0x3F0000003FLL;
  *((_QWORD *)&v1 + 1) = 0x3F0000003FLL;
  *((_OWORD *)this + 50) = 0u;
  *((_OWORD *)this + 51) = v1;
  *((_OWORD *)this + 52) = xmmword_1B3525930;
  *((_OWORD *)this + 53) = xmmword_1B3525940;
  *((_OWORD *)this + 54) = xmmword_1B3525950;
  *((_OWORD *)this + 55) = xmmword_1B3525960;
  *((_OWORD *)this + 56) = xmmword_1B3525970;
  *((_OWORD *)this + 57) = xmmword_1B3525980;
  *((_OWORD *)this + 58) = xmmword_1B3525990;
  *((_OWORD *)this + 59) = xmmword_1B35259A0;
  *((_OWORD *)this + 60) = xmmword_1B35259B0;
  *((_OWORD *)this + 61) = xmmword_1B35259C0;
  *((_OWORD *)this + 62) = xmmword_1B35259D0;
  *((_OWORD *)this + 63) = xmmword_1B35259E0;
  *((_OWORD *)this + 64) = xmmword_1B35259F0;
  *((_OWORD *)this + 65) = xmmword_1B3525A00;
  *((_OWORD *)this + 66) = xmmword_1B3525A10;
  *((_OWORD *)this + 67) = xmmword_1B3525A20;
  *((_OWORD *)this + 68) = xmmword_1B3525A30;
  *((_OWORD *)this + 69) = xmmword_1B3525A40;
  *((_OWORD *)this + 70) = xmmword_1B3525A50;
  *((_OWORD *)this + 71) = xmmword_1B3525A60;
  *((_OWORD *)this + 72) = xmmword_1B3525A70;
  *((int32x4_t *)this + 73) = vdupq_n_s32(0x7F7FFFFFu);
  *((_OWORD *)this + 74) = xmmword_1B3050FF0;
  *((_OWORD *)this + 75) = xmmword_1B304EF70;
  *((_OWORD *)this + 76) = xmmword_1B3050F80;
  *((_OWORD *)this + 77) = xmmword_1B3525A80;
  *((_OWORD *)this + 78) = xmmword_1B3525A90;
  *((_OWORD *)this + 79) = xmmword_1B3525AA0;
  *((_OWORD *)this + 80) = xmmword_1B3525AB0;
  *((_OWORD *)this + 81) = xmmword_1B3525AC0;
  *((_OWORD *)this + 82) = xmmword_1B3525AD0;
  *((_OWORD *)this + 83) = xmmword_1B3525AE0;
  *((_OWORD *)this + 84) = xmmword_1B3525AF0;
  *((_OWORD *)this + 85) = xmmword_1B3525B00;
  *((_OWORD *)this + 86) = xmmword_1B3525B10;
  *((_OWORD *)this + 87) = xmmword_1B3525B20;
  *((_OWORD *)this + 88) = xmmword_1B3525B30;
  *((_OWORD *)this + 89) = xmmword_1B3525B40;
  *((_OWORD *)this + 90) = xmmword_1B3525B50;
  *((_OWORD *)this + 91) = xmmword_1B3525B60;
  *((_OWORD *)this + 92) = xmmword_1B3525B70;
  *((_OWORD *)this + 93) = xmmword_1B3052960;
  *((_OWORD *)this + 94) = xmmword_1B3525B80;
  *((_OWORD *)this + 95) = xmmword_1B3525B90;
  *((_OWORD *)this + 96) = xmmword_1B3525BA0;
  *((_OWORD *)this + 97) = xmmword_1B3525BB0;
  *((_OWORD *)this + 98) = xmmword_1B3525BC0;
  *((_OWORD *)this + 99) = xmmword_1B3525BD0;
  *((_OWORD *)this + 100) = xmmword_1B3525BE0;
  *((_OWORD *)this + 101) = xmmword_1B309E310;
  *((_OWORD *)this + 102) = xmmword_1B3525BF0;
  *((_OWORD *)this + 103) = xmmword_1B309E2F0;
  *((_OWORD *)this + 104) = xmmword_1B309E300;
  *((_OWORD *)this + 105) = xmmword_1B3525C00;
  *((_OWORD *)this + 106) = xmmword_1B3525C10;
  *((_OWORD *)this + 107) = xmmword_1B3525C20;
  *((_OWORD *)this + 108) = xmmword_1B3525C30;
  *((_OWORD *)this + 109) = xmmword_1B3058F60;
  *((_OWORD *)this + 110) = xmmword_1B3525C40;
  *((_OWORD *)this + 111) = xmmword_1B3525C50;
  *((_OWORD *)this + 112) = xmmword_1B309E2C0;
  *((_OWORD *)this + 113) = xmmword_1B3525C60;
  *((_OWORD *)this + 114) = xmmword_1B3525C70;
  *((_OWORD *)this + 115) = xmmword_1B3525C80;
  result = 1.648;
  *((_OWORD *)this + 116) = xmmword_1B3058FA0;
  return result;
}

const char *Gettype0_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000035c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=20f42ccd:177bb552:78dd23af:883d5aab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000034a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4e9a049b:521821a9:74d35da9:00427891\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000312\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=182b38ea:7b2646c3:313af2b3:04cb7251\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000035c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=20f42ccd:177bb552:78dd23af:883d5aab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000034a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4e9a049b:521821a9:74d35da9:00427891\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000312\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=182b38ea:7b2646c3:313af2b3:04cb7251\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000035c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=20f42ccd:177bb552:78dd23af:883d5aab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000034a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4e9a049b:521821a9:74d35da9:00427891\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000030b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f0461501:6e89cdbc:ed292272:68967d2e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_half_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000035c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=20f42ccd:177bb552:78dd23af:883d5aab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000034a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4e9a049b:521821a9:74d35da9:00427891\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000314\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=de1f5717:17783782:771374af:c557d8f4\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_halfProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003b2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8c2fbc56:4cc55537:fad67de0:f0bc16ab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003a0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=dd3502b5:2cd7db74:213aeca0:faa23b85\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? -c0.w : c0.w, r0.y < 0.00000 ? -c0.w : c0.w, r0.z < 0.00000 ? -c0.w : c0.w"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=59f9aeda:d6ff3300:fea98945:87997e82\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_niceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003b2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8c2fbc56:4cc55537:fad67de0:f0bc16ab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003a0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=dd3502b5:2cd7db74:213aeca0:faa23b85\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? -c0.w : c0.w, r0.y < 0.00000 ? -c0.w : c0.w, r0.z < 0.00000 ? -c0.w : c0.w"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=5d43e82d:f82cb0c1:2fc25041:d7c8c18e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_floatProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003b2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8c2fbc56:4cc55537:fad67de0:f0bc16ab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003a0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=dd3502b5:2cd7db74:213aeca0:faa23b85\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? -c0.w : c0.w, r0.y < 0.00000 ? -c0.w : c0.w, r0.z < 0.00000 ? -c0.w : c0.w"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=5d43e82d:f82cb0c1:2fc25041:d7c8c18e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000453\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=08bef2cc:3b362180:b8b760c8:d704e1c6\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000042c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=65455e26:aae30178:80df69f1:b13cc037\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000466\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=aa7fe365:857e3a79:b6d0a374:223504aa\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000453\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=08bef2cc:3b362180:b8b760c8:d704e1c6\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000042c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=65455e26:aae30178:80df69f1:b13cc037\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000466\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=aa7fe365:857e3a79:b6d0a374:223504aa\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000453\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=08bef2cc:3b362180:b8b760c8:d704e1c6\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000042c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=65455e26:aae30178:80df69f1:b13cc037\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000045d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f91b4dd8:c404bfa1:760fd8af:74430a58\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_half_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000453\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=08bef2cc:3b362180:b8b760c8:d704e1c6\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000042c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=65455e26:aae30178:80df69f1:b13cc037\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000468\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=3c23f051:eaf48604:aa8f339c:ce73b350\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_halfProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000043a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0a959b1e:d3ecfb63:3d2c0792:3dbf9f3f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000413\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=7903a5a3:029dca7a:2f3f8e86:e6cc37c7\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000445\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f560df30:4974ef6f:2fcd2fb5:ff40bbe7\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_niceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000043a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0a959b1e:d3ecfb63:3d2c0792:3dbf9f3f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000413\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=7903a5a3:029dca7a:2f3f8e86:e6cc37c7\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000043a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=8f80d0db:676786df:896dbbd8:ca818ca5\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_floatProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000043a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0a959b1e:d3ecfb63:3d2c0792:3dbf9f3f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000413\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=7903a5a3:029dca7a:2f3f8e86:e6cc37c7\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000043a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=8f80d0db:676786df:896dbbd8:ca818ca5\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000049d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=92fb4533:04bac7c8:6cb1b762:ee971088\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=87250ca9:031b0571:234dcae3:a5c89a4d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004de\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=ffd33e53:70c1c4af:3f0c646d:9681734f\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000049d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=92fb4533:04bac7c8:6cb1b762:ee971088\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=87250ca9:031b0571:234dcae3:a5c89a4d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004de\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=ffd33e53:70c1c4af:3f0c646d:9681734f\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000049d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=92fb4533:04bac7c8:6cb1b762:ee971088\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=87250ca9:031b0571:234dcae3:a5c89a4d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004d3\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=749828b3:4f049c36:34a00297:da68786b\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_half_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000049d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=92fb4533:04bac7c8:6cb1b762:ee971088\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=87250ca9:031b0571:234dcae3:a5c89a4d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004e0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=a9f5d177:5f5d6b08:dc77a778:411aa2c8\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_halfProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000469\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1b4311bc:39a0fa86:9605b790:112f1020\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000043b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=32abf88e:f2b51ba2:fd50cf48:61df2131\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000498\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=174a2ca1:24a9601e:20dabf3d:efeb373c\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_niceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000469\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1b4311bc:39a0fa86:9605b790:112f1020\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000043b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=32abf88e:f2b51ba2:fd50cf48:61df2131\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000048b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c914f1c4:1280ed09:be9bcd06:19f12018\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_floatProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000469\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1b4311bc:39a0fa86:9605b790:112f1020\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000043b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=32abf88e:f2b51ba2:fd50cf48:61df2131\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000048b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c914f1c4:1280ed09:be9bcd06:19f12018\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=de17ce8a:72a40e6a:fdb14397:674a3b9e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000441\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4224cc02:5b0987c8:78bb097e:49047380\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000047f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=80099d45:b30fce8c:8e93ad4a:38bd9a40\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=de17ce8a:72a40e6a:fdb14397:674a3b9e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000441\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4224cc02:5b0987c8:78bb097e:49047380\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000047f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=80099d45:b30fce8c:8e93ad4a:38bd9a40\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=de17ce8a:72a40e6a:fdb14397:674a3b9e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000441\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4224cc02:5b0987c8:78bb097e:49047380\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000476\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=682ccd8d:64d8c659:5538c6fb:cf213a17\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_half_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=de17ce8a:72a40e6a:fdb14397:674a3b9e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000441\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4224cc02:5b0987c8:78bb097e:49047380\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000481\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=3e26abbf:b51e934a:0eaea483:a61051d9\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_halfProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000465\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0b5d8c63:af3d6b84:d7956f5f:4dac39cc\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000437\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f39de0cd:9e76e5bc:5803465d:9943c9ca\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000046d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.w = c0.x;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=7e1f0376:dccb70f7:f4141705:8081beb7\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_niceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000465\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0b5d8c63:af3d6b84:d7956f5f:4dac39cc\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000437\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f39de0cd:9e76e5bc:5803465d:9943c9ca\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000462\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.w = c0.x;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=81f81d5d:db456118:feabd803:f7c376a4\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_floatProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000465\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0b5d8c63:af3d6b84:d7956f5f:4dac39cc\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000437\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f39de0cd:9e76e5bc:5803465d:9943c9ca\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000462\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.w = c0.x;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=81f81d5d:db456118:feabd803:f7c376a4\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000050e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0b3015a:c4c77f90:f8e66018:3a2a1487\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000497\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=91df01b2:ab4291da:8ec16055:5c19d880\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000050e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=20859c2d:6233ef7a:90bde4e6:3bf84cdb\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000050e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0b3015a:c4c77f90:f8e66018:3a2a1487\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000497\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=91df01b2:ab4291da:8ec16055:5c19d880\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000050e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=20859c2d:6233ef7a:90bde4e6:3bf84cdb\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000050e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0b3015a:c4c77f90:f8e66018:3a2a1487\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000497\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=91df01b2:ab4291da:8ec16055:5c19d880\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000503\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f5b63af9:48536670:cfb336fb:139fd5b1\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_half_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000050e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0b3015a:c4c77f90:f8e66018:3a2a1487\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000497\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=91df01b2:ab4291da:8ec16055:5c19d880\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000510\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=70dcc2bc:d1658f7f:081f4c58:d4fbcac9\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_halfProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004d8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r2.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a2c3c908:016206be:67d56c9c:9c001e7d\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000472\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.w = c0.w;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=16aeb384:4247f51a:d777a509:76109a61\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004d7\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.w = c0.w;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=97daefca:65fccb97:c63a820c:f94ab701\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_niceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004d8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r2.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a2c3c908:016206be:67d56c9c:9c001e7d\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000472\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.w = c0.w;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=16aeb384:4247f51a:d777a509:76109a61\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004ca\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.w = c0.w;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=95311b7e:8028d7fe:9fcf7f0c:7737fcfe\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_floatProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004d8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r2.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a2c3c908:016206be:67d56c9c:9c001e7d\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000472\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.w = c0.w;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=16aeb384:4247f51a:d777a509:76109a61\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004ca\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.w = c0.w;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=95311b7e:8028d7fe:9fcf7f0c:7737fcfe\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000032f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=7dc0dfbc:c836a038:13cdd6d9:c60d7e3e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000324\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bdfaf4f0:4a68472f:e4ce4c4c:69bdede1\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = sqrt(r1.xyz);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=28efafef:fde41fd4:7dc2b893:64d224c6\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000440\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const half4 c1 = half4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=880f0614:cc8cb34f:d8f516f4:2fef1ed2\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000437\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const float4 c1 = float4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f18124a9:bf474d14:474143e7:2c5831a1\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000040d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
           "    const mediump vec4 c1 = vec4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=3919ff3c:0a650753:cfe62bc5:50f25c9b\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000440\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const half4 c1 = half4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=880f0614:cc8cb34f:d8f516f4:2fef1ed2\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000437\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const float4 c1 = float4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f18124a9:bf474d14:474143e7:2c5831a1\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000406\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
           "    const highp vec4 c1 = vec4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=0a584153:9bd953c5:863c9b66:c29b89c1\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_half_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000440\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const half4 c1 = half4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=880f0614:cc8cb34f:d8f516f4:2fef1ed2\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000437\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const float4 c1 = float4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f18124a9:bf474d14:474143e7:2c5831a1\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000040f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
           "    const mediump vec4 c1 = vec4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=4e704514:44ec5fc8:a83e7283:d1311c23\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_halfProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000542\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const half4 c1 = half4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
             "    const half4 c2 = half4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b9cc7239:53c07d97:6516f562:857552eb\n"
             "//SIG=00400000:00000001:00000001:00000001:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000053b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const float4 c1 = float4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
             "    const float4 c2 = float4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=615b58db:20b8ac2f:c4df9b5f:d051b98f\n"
             "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000581\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
           "    const mediump vec4 c1 = vec4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
           "    const mediump vec4 c2 = vec4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.www;\n"
           "    r1.xyz = r1.xyz - c2.xxx;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=532ea0ea:1b8a64cc:6df0891e:5451cc3a\n"
           "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_niceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000542\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const half4 c1 = half4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
             "    const half4 c2 = half4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b9cc7239:53c07d97:6516f562:857552eb\n"
             "//SIG=00400000:00000001:00000001:00000001:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000053b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const float4 c1 = float4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
             "    const float4 c2 = float4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=615b58db:20b8ac2f:c4df9b5f:d051b98f\n"
             "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000576\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
           "    const highp vec4 c1 = vec4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
           "    const highp vec4 c2 = vec4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.www;\n"
           "    r1.xyz = r1.xyz - c2.xxx;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=5436f98d:da033e02:e56c36e4:4d4486b6\n"
           "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000330\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=aa266737:ced8974d:678b2327:1590d25a\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000325\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5c2db76f:f3872933:3b70ed57:2d3f143f\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = r1.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=fdba60fd:9f8e713f:a1e88db5:b74ecef0\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000455\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const half4 c1 = half4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9c547199:95409cef:755c552e:ad150c39\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000044c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const float4 c1 = float4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e31de786:5e047bee:e7a2bde8:154760dd\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000422\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
           "    const mediump vec4 c1 = vec4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=622dff9d:420f8d79:759459b7:9d82fc32\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000455\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const half4 c1 = half4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9c547199:95409cef:755c552e:ad150c39\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000044c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const float4 c1 = float4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e31de786:5e047bee:e7a2bde8:154760dd\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000041b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
           "    const highp vec4 c1 = vec4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=7ed9badc:f8fd08b3:59cc3168:821c417c\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_half_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000455\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const half4 c1 = half4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9c547199:95409cef:755c552e:ad150c39\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000044c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const float4 c1 = float4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e31de786:5e047bee:e7a2bde8:154760dd\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000424\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
           "    const mediump vec4 c1 = vec4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=44a6b46f:44bdd250:cb929530:c15d0619\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_halfProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000557\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const half4 c1 = half4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
             "    const half4 c2 = half4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c5ec1c4f:dfe08d64:ee57c69c:a27502b1\n"
             "//SIG=00400000:00000001:00000001:00000001:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000550\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const float4 c1 = float4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
             "    const float4 c2 = float4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6ca877ba:5f861024:45a23c29:a6357148\n"
             "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000596\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
           "    const mediump vec4 c1 = vec4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
           "    const mediump vec4 c2 = vec4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz + c1.xxx;\n"
           "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
           "    r2.xyz = r2.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.www;\n"
           "    r1.xyz = r1.xyz - c2.xxx;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c5df66d8:fd0ad819:9e10e85c:e9f2f9ed\n"
           "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_niceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000557\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const half4 c1 = half4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
             "    const half4 c2 = half4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c5ec1c4f:dfe08d64:ee57c69c:a27502b1\n"
             "//SIG=00400000:00000001:00000001:00000001:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000550\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const float4 c1 = float4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
             "    const float4 c2 = float4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6ca877ba:5f861024:45a23c29:a6357148\n"
             "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000058b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
           "    const highp vec4 c1 = vec4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
           "    const highp vec4 c2 = vec4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz + c1.xxx;\n"
           "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
           "    r2.xyz = r2.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.www;\n"
           "    r1.xyz = r1.xyz - c2.xxx;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=24afdb36:4e250bda:6c16f24c:0c8880bc\n"
           "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000032f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=7dc0dfbc:c836a038:13cdd6d9:c60d7e3e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000324\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bdfaf4f0:4a68472f:e4ce4c4c:69bdede1\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = sqrt(r1.xyz);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=28efafef:fde41fd4:7dc2b893:64d224c6\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000043f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const half4 c1 = half4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ded8d455:606b3774:cf46c232:f7f8dd1f\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000436\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const float4 c1 = float4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=13c96d46:6c5686ac:da7b737c:3948a744\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000040c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
           "    const mediump vec4 c1 = vec4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=2d0114da:730d4c56:a024c116:44fda0bb\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000043f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const half4 c1 = half4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ded8d455:606b3774:cf46c232:f7f8dd1f\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000436\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const float4 c1 = float4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=13c96d46:6c5686ac:da7b737c:3948a744\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000405\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
           "    const highp vec4 c1 = vec4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=fce4fe11:ffecb27c:df22a65c:797977c8\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_half_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000043f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const half4 c1 = half4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ded8d455:606b3774:cf46c232:f7f8dd1f\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000436\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const float4 c1 = float4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=13c96d46:6c5686ac:da7b737c:3948a744\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000040e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
           "    const mediump vec4 c1 = vec4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=8678ec2f:24669b7f:e182efb9:7f6972b5\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_halfProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004f2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const half4 c1 = half4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.yyy;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=f7e4207f:da26c069:1cfb1c75:e27e6221\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const float4 c1 = float4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.yyy;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=98092e7c:08315962:ca7a98d8:a90c2dc3\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000052b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
           "    const mediump vec4 c1 = vec4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*-c0.yyy;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=210dfebd:abe83807:6c7bd68f:5e48b109\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_niceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004f2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const half4 c1 = half4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.yyy;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=f7e4207f:da26c069:1cfb1c75:e27e6221\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const float4 c1 = float4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.yyy;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=98092e7c:08315962:ca7a98d8:a90c2dc3\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000522\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
           "    const highp vec4 c1 = vec4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*-c0.yyy;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f9786a5a:b9f8a78e:99cf8eb9:bb98dc64\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000330\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=aa266737:ced8974d:678b2327:1590d25a\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000325\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5c2db76f:f3872933:3b70ed57:2d3f143f\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = r1.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=fdba60fd:9f8e713f:a1e88db5:b74ecef0\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000454\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const half4 c1 = half4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a6aa203c:cce763d8:235b7d77:c93b9aff\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000044b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const float4 c1 = float4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bc23966e:14be2697:71ada8fa:a9af29fd\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000421\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
           "    const mediump vec4 c1 = vec4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=cb3c7562:84299991:09fbdc07:2ec2d025\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000454\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const half4 c1 = half4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a6aa203c:cce763d8:235b7d77:c93b9aff\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000044b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const float4 c1 = float4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bc23966e:14be2697:71ada8fa:a9af29fd\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000041a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
           "    const highp vec4 c1 = vec4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=7dc09eea:0930a865:2a70a43d:67ba2dca\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_half_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000454\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const half4 c1 = half4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a6aa203c:cce763d8:235b7d77:c93b9aff\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000044b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const float4 c1 = float4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bc23966e:14be2697:71ada8fa:a9af29fd\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000423\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
           "    const mediump vec4 c1 = vec4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=67d90621:f4dc58de:8e6454fb:a7c0c93b\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_halfProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000506\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const half4 c1 = half4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.xxx;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d582d28b:3fc6a911:6b763ef9:6ae7cb33\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004fd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const float4 c1 = float4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.xxx;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5a07b771:f2b95122:2bf87a50:0dc832df\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000053f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
           "    const mediump vec4 c1 = vec4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz + c1.xxx;\n"
           "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
           "    r2.xyz = r2.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*-c0.xxx;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c4b6b6d2:9c9c7d5d:24dbd61e:e21dbd00\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_niceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000506\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const half4 c1 = half4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.xxx;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d582d28b:3fc6a911:6b763ef9:6ae7cb33\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004fd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const float4 c1 = float4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.xxx;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5a07b771:f2b95122:2bf87a50:0dc832df\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000536\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
           "    const highp vec4 c1 = vec4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz + c1.xxx;\n"
           "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
           "    r2.xyz = r2.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*-c0.xxx;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=05733f29:0676d724:10f32f1c:eabc05d1\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000379\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 1.200000048, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz*c0.zzz;\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
             "    r0.xyz = sqrt(r2.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=338d6991:bb8c35f4:c24065b6:e2ddd0bf\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000036e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 1.200000048, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz*c0.zzz;\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
             "    r0.xyz = sqrt(r2.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=8ca817c7:ae13bb8c:2ccf5dfd:18976027\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000030b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 1.200000048, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz*c0.zzz;\n"
           "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
           "    r0.xyz = sqrt(r2.xyz);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=0beefa58:f2d5d814:e230ba8a:c1014acf\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000441\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const half4 c1 = half4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d3b643c1:058374be:1a7b730c:64a7f017\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000438\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const float4 c1 = float4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bf3fc1c7:5a610b84:ee2623c1:37dbc3f1\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000040e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
           "    const mediump vec4 c1 = vec4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=04dc4171:e48201e2:5b166dbe:11bf1513\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000441\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const half4 c1 = half4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d3b643c1:058374be:1a7b730c:64a7f017\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000438\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const float4 c1 = float4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bf3fc1c7:5a610b84:ee2623c1:37dbc3f1\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000407\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
           "    const highp vec4 c1 = vec4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=bd46d998:a485ec56:c2e9088e:c10d0cd5\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_half_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000441\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const half4 c1 = half4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d3b643c1:058374be:1a7b730c:64a7f017\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000438\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const float4 c1 = float4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bf3fc1c7:5a610b84:ee2623c1:37dbc3f1\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000410\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
           "    const mediump vec4 c1 = vec4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=a177af96:6455671a:a5ff5333:2ae7cf93\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_halfProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004d9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
             "    const half4 c1 = half4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e2f46501:6eaf47b9:17674bda:304195a8\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004d0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
             "    const float4 c1 = float4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2c805bad:1968a6b1:420de9b1:d3d0cefa\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000516\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
           "    const mediump vec4 c1 = vec4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.zzz);\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r2.x : r2.x, r0.y < 0.00000 ? -r2.y : r2.y, r0.z < 0.00000 ? -r2.z : r2.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=52ffc3ca:de6717e7:9ced0b9c:d6e81a3b\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_niceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004d9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
             "    const half4 c1 = half4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e2f46501:6eaf47b9:17674bda:304195a8\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004d0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
             "    const float4 c1 = float4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2c805bad:1968a6b1:420de9b1:d3d0cefa\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000050d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
           "    const highp vec4 c1 = vec4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.zzz);\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r2.x : r2.x, r0.y < 0.00000 ? -r2.y : r2.y, r0.z < 0.00000 ? -r2.z : r2.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=0b24d80b:1241119b:9bc872ae:27374f1e\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000037b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.8600000143, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz*c0.zzz;\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
             "    r0.xyz = r2.xyz*r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cff72616:949f2683:7b17f44a:3ba0ce15\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000370\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.8600000143, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz*c0.zzz;\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
             "    r0.xyz = r2.xyz*r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=de2ecf3a:ce74014d:1a29904c:4cc7a8ce\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000030d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.8600000143, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz*c0.zzz;\n"
           "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
           "    r0.xyz = r2.xyz*r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=bb90a585:c52419c2:c07b9004:5b6745c0\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000456\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const half4 c1 = half4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ce7d29de:9f899a0d:f3fde93a:57d945e7\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000044d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const float4 c1 = float4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=177e913d:55f303a1:e1f32632:f0623a5f\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000423\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
           "    const mediump vec4 c1 = vec4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=4af6312b:82e53e55:f354a5e6:3ba91fd2\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000456\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const half4 c1 = half4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ce7d29de:9f899a0d:f3fde93a:57d945e7\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000044d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const float4 c1 = float4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=177e913d:55f303a1:e1f32632:f0623a5f\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000041c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
           "    const highp vec4 c1 = vec4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=b4eb37d1:a0806a0e:93ab5e34:02169094\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_half_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000456\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const half4 c1 = half4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ce7d29de:9f899a0d:f3fde93a:57d945e7\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000044d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const float4 c1 = float4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=177e913d:55f303a1:e1f32632:f0623a5f\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000425\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
           "    const mediump vec4 c1 = vec4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f39927a8:61485a10:77aa981d:cfbbc277\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_halfProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004ee\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
             "    const half4 c1 = half4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz + c0.www;\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=55a7b763:ef436294:d41e9d72:fef2dc04\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
             "    const float4 c1 = float4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz + c0.www;\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=57b92c9c:5efdf1ca:047b5786:039d0b00\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000052b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
           "    const mediump vec4 c1 = vec4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz + c0.www;\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r2.x : r2.x, r0.y < 0.00000 ? -r2.y : r2.y, r0.z < 0.00000 ? -r2.z : r2.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=8b50fb71:31f2eb5b:279044cd:79fc7ef6\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_niceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004ee\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
             "    const half4 c1 = half4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz + c0.www;\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=55a7b763:ef436294:d41e9d72:fef2dc04\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
             "    const float4 c1 = float4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz + c0.www;\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=57b92c9c:5efdf1ca:047b5786:039d0b00\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000522\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
           "    const highp vec4 c1 = vec4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz + c0.www;\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r2.x : r2.x, r0.y < 0.00000 ? -r2.y : r2.y, r0.z < 0.00000 ? -r2.z : r2.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=9d48d462:3dda019d:3f5f5e4d:a4a4071a\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000032f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=7dc0dfbc:c836a038:13cdd6d9:c60d7e3e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000324\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bdfaf4f0:4a68472f:e4ce4c4c:69bdede1\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = sqrt(r1.xyz);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=28efafef:fde41fd4:7dc2b893:64d224c6\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000034c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=fd9779b0:d5481997:6b539481:f13c6247\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000341\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=248d6794:088dc7a4:fdccd0f2:7e6548ba\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002de\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=1b02cad7:918f5fdd:c7dcec0f:03dcbb10\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000034c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=fd9779b0:d5481997:6b539481:f13c6247\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000341\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=248d6794:088dc7a4:fdccd0f2:7e6548ba\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002d9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=8351c2f2:f318a08e:679a221c:79c8467d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_half_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000034c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=fd9779b0:d5481997:6b539481:f13c6247\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000341\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=248d6794:088dc7a4:fdccd0f2:7e6548ba\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002e0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=3eda5271:afae211d:2169fd04:426d0611\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_halfProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003c8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a8311cfb:0d23b169:af678cc5:257482af\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003bd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=199c1d45:cf63353c:dd5f426e:fd0991df\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003ca\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.zzz);\n"
           "    r1.xyz = pow(r1.xyz, c0.www);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=9608204f:1cc57ea4:ff41515d:d7512eef\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_niceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003c8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a8311cfb:0d23b169:af678cc5:257482af\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003bd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=199c1d45:cf63353c:dd5f426e:fd0991df\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003c3\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.zzz);\n"
           "    r1.xyz = pow(r1.xyz, c0.www);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=2c4024ce:67153cca:87b9a761:7ffe77da\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000330\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=aa266737:ced8974d:678b2327:1590d25a\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000325\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5c2db76f:f3872933:3b70ed57:2d3f143f\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = r1.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=fdba60fd:9f8e713f:a1e88db5:b74ecef0\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000034b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=dd40d21d:dab71443:51d03ff0:e52c3982\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000340\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=527ccfe4:b046ff73:8804104e:07e80862\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002dd\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=5ad6b64c:affe4652:e992c066:f99ad317\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000034b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=dd40d21d:dab71443:51d03ff0:e52c3982\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000340\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=527ccfe4:b046ff73:8804104e:07e80862\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002d8\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=9e854b3b:85ccb2c9:213ad91f:b1d9d3f7\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_half_satProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000034b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=dd40d21d:dab71443:51d03ff0:e52c3982\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000340\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=527ccfe4:b046ff73:8804104e:07e80862\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002df\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=7ec4e723:27ed6654:3da6727a:724fddba\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_halfProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003c7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=83c2463f:fa694f71:8ff44add:0192f495\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003bc\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=03b68525:edecc26f:4d549a48:c381d609\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003c9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.zzz);\n"
           "    r1.xyz = pow(r1.xyz, c0.www);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=bf273443:85988f7a:19b07f24:0301cc15\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_niceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003c7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=83c2463f:fa694f71:8ff44add:0192f495\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003bc\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=03b68525:edecc26f:4d549a48:c381d609\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.zzz);\n"
           "    r1.xyz = pow(r1.xyz, c0.www);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=86f46bb1:e801a3df:b0549fd7:b4cd404d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000030b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ecb5a4d8:6d113e3b:887319ce:2b54e8c9\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002f8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=717fe78e:89a0702a:b5e17bb3:7157bcda\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=e2288d14:dc4b95f4:fcf12f2e:579df0f1\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000030b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ecb5a4d8:6d113e3b:887319ce:2b54e8c9\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002f8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=717fe78e:89a0702a:b5e17bb3:7157bcda\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=e2288d14:dc4b95f4:fcf12f2e:579df0f1\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000039c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r0.xyz = clamp(r1.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c9ce60be:37897859:81914f65:4df56f2a\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000374\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r0.xyz = clamp(r1.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=dc32e146:6db579ac:9035a6cb:ec835062\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000034f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r0.xyz = clamp(r1.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c8823dc8:62aa0672:c3a00abc:4de48ee3\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000030b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ecb5a4d8:6d113e3b:887319ce:2b54e8c9\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002f8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=717fe78e:89a0702a:b5e17bb3:7157bcda\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c6\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=011ce114:9bbfbc57:d68136d7:ba86e401\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000361\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=bd6cb7db:0b59aed5:92893bd5:f825a780\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000034e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0d0f87f:883a4f14:52f52ed2:8913ba88\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000038b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? -c0.w : c0.w, r0.y < 0.00000 ? -c0.w : c0.w, r0.z < 0.00000 ? -c0.w : c0.w"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=b01d9920:fa7ac92f:4716ea80:29eb1b7c\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000361\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=bd6cb7db:0b59aed5:92893bd5:f825a780\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000034e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0d0f87f:883a4f14:52f52ed2:8913ba88\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000382\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? -c0.w : c0.w, r0.y < 0.00000 ? -c0.w : c0.w, r0.z < 0.00000 ? -c0.w : c0.w"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=d984d409:03d5ce14:47226e6c:ea97b670\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_float_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000361\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=bd6cb7db:0b59aed5:92893bd5:f825a780\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000034e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0d0f87f:883a4f14:52f52ed2:8913ba88\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000382\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? -c0.w : c0.w, r0.y < 0.00000 ? -c0.w : c0.w, r0.z < 0.00000 ? -c0.w : c0.w"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=d984d409:03d5ce14:47226e6c:ea97b670\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000402\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9ff8c4d8:3d404847:33a9945a:e75086f8\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003da\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2870cdbc:eb23a8aa:8cdd93e8:994b02dc\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000418\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=48f9e48c:460bd827:86d7dbf2:fc50cc9c\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000402\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9ff8c4d8:3d404847:33a9945a:e75086f8\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003da\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2870cdbc:eb23a8aa:8cdd93e8:994b02dc\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000418\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=48f9e48c:460bd827:86d7dbf2:fc50cc9c\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000402\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9ff8c4d8:3d404847:33a9945a:e75086f8\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003da\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2870cdbc:eb23a8aa:8cdd93e8:994b02dc\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000040f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=a34d64de:9e3622d9:55b8e806:bc930502\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000402\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9ff8c4d8:3d404847:33a9945a:e75086f8\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003da\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2870cdbc:eb23a8aa:8cdd93e8:994b02dc\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000041a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=77401a0b:de98840e:9e1bad14:0cab13ab\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=54b7fecc:600d8d5c:eacce70e:72781265\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003c1\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=39ea7276:db4cd5bc:f0f9b1c5:f49422ee\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f7\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=3214c698:18a61d1f:775e57af:ef012fc7\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=54b7fecc:600d8d5c:eacce70e:72781265\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003c1\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=39ea7276:db4cd5bc:f0f9b1c5:f49422ee\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003ec\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=0303ed48:c8358667:5495ed57:fa121da3\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_float_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=54b7fecc:600d8d5c:eacce70e:72781265\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003c1\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=39ea7276:db4cd5bc:f0f9b1c5:f49422ee\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003ec\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=0303ed48:c8358667:5495ed57:fa121da3\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000044c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b581bd41:54e6f9c8:e1ede332:875c59b4\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000041d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b4173fac:44680a48:870cd096:fdc9532d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000490\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=3e2dbb18:684ec807:9d15a9eb:1614305e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000044c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b581bd41:54e6f9c8:e1ede332:875c59b4\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000041d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b4173fac:44680a48:870cd096:fdc9532d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000490\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=3e2dbb18:684ec807:9d15a9eb:1614305e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000044c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b581bd41:54e6f9c8:e1ede332:875c59b4\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000041d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b4173fac:44680a48:870cd096:fdc9532d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000485\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=9ce8dddd:3d077154:86cfe60a:39d7e855\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000044c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b581bd41:54e6f9c8:e1ede332:875c59b4\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000041d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b4173fac:44680a48:870cd096:fdc9532d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000492\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=622d4d1a:a7f48af3:efe2021a:bb14221d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000418\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=60b986cb:2fee582f:7e05d15d:628c4b59\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=521478db:3e1f61f9:f01db1b9:77e3589d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000044a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=541b9209:5f74838a:ec435af4:b838fbe5\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000418\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=60b986cb:2fee582f:7e05d15d:628c4b59\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=521478db:3e1f61f9:f01db1b9:77e3589d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000043d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=01b3d752:40bcd325:f774cf1d:a16e8652\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_float_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000418\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=60b986cb:2fee582f:7e05d15d:628c4b59\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=521478db:3e1f61f9:f01db1b9:77e3589d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000043d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=01b3d752:40bcd325:f774cf1d:a16e8652\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000041e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=56118e12:e38b95a3:d687869e:291134db\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ab45c72e:2f5e0967:e1912c31:64a08ba6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000431\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f238f58b:9bad5cb9:febff045:ccc83075\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000041e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=56118e12:e38b95a3:d687869e:291134db\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ab45c72e:2f5e0967:e1912c31:64a08ba6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000431\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f238f58b:9bad5cb9:febff045:ccc83075\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000041e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=56118e12:e38b95a3:d687869e:291134db\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ab45c72e:2f5e0967:e1912c31:64a08ba6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000428\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=bf6b9381:6a7e9595:993d8c0c:939fa7d9\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000041e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=56118e12:e38b95a3:d687869e:291134db\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ab45c72e:2f5e0967:e1912c31:64a08ba6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000433\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=1b1522ad:d240fa36:56c2b10c:5af9114d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000414\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c020226d:07c2fa1c:0f843aa7:96573d96\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b9b7eb5d:231d6b87:b0cbc1f3:077ea789\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000041f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.w = c0.x;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=5bc35c6f:5f483a78:e4ac0130:5872675f\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000414\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c020226d:07c2fa1c:0f843aa7:96573d96\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b9b7eb5d:231d6b87:b0cbc1f3:077ea789\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000414\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.w = c0.x;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=e30a931e:9daacbf9:a2d71229:2a8b9bfa\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_float_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000414\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c020226d:07c2fa1c:0f843aa7:96573d96\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b9b7eb5d:231d6b87:b0cbc1f3:077ea789\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000414\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.w = c0.x;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=e30a931e:9daacbf9:a2d71229:2a8b9bfa\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004bd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e60093f7:17e4e59c:044c6dd4:0dd6e9ce\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000445\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=10153cf1:e229017a:404233ac:ad355c06\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004c0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c92b533d:2946e6ca:1ffa015a:10d26966\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004bd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e60093f7:17e4e59c:044c6dd4:0dd6e9ce\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000445\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=10153cf1:e229017a:404233ac:ad355c06\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004c0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c92b533d:2946e6ca:1ffa015a:10d26966\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004bd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e60093f7:17e4e59c:044c6dd4:0dd6e9ce\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000445\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=10153cf1:e229017a:404233ac:ad355c06\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004b5\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=aef7f055:834bb867:7b1b3ff8:8e3614e9\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004bd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e60093f7:17e4e59c:044c6dd4:0dd6e9ce\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000445\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=10153cf1:e229017a:404233ac:ad355c06\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=9a3b51bd:4960a7f2:6719ad26:91d186ea\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000487\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r2.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=62c5fdab:7fc3593f:783cebb6:5506e6ba\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000420\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.w;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=95965de2:ec2450ed:740ba24d:a0be43a6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000489\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.w = c0.w;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=baa41f52:35394ac5:31a0fd40:ee61628f\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000487\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r2.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=62c5fdab:7fc3593f:783cebb6:5506e6ba\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000420\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.w;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=95965de2:ec2450ed:740ba24d:a0be43a6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000047c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.w = c0.w;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=2bdf62e0:beb95f57:b2bb1cfc:ecf85b8d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_float_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000487\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r2.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=62c5fdab:7fc3593f:783cebb6:5506e6ba\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000420\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.w;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=95965de2:ec2450ed:740ba24d:a0be43a6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000047c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.w = c0.w;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=2bdf62e0:beb95f57:b2bb1cfc:ecf85b8d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002de\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=71371cbe:526a992c:7aa37843:1294333d\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002d2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=d6a33776:ea9d46d1:7b701ce4:2b02f2f0\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000273\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = sqrt(r1.xyz);\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=366ef5c6:9018d21a:09aca884:96379d9d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const half4 c1 = half4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=596deb76:9164d0a8:2f3e089d:582cf7bf\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const float4 c1 = float4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=7e4f848a:2cb60a58:1e95b028:52cd143e\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003bf\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
           "    const mediump vec4 c1 = vec4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=9d8bc3ce:ba133db6:ac894ecf:201a875d\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const half4 c1 = half4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=596deb76:9164d0a8:2f3e089d:582cf7bf\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const float4 c1 = float4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=7e4f848a:2cb60a58:1e95b028:52cd143e\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003b8\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
           "    const highp vec4 c1 = vec4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=5ca60ddb:9e6b7047:f8e5d9d8:b8b75fb0\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const half4 c1 = half4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=596deb76:9164d0a8:2f3e089d:582cf7bf\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const float4 c1 = float4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=7e4f848a:2cb60a58:1e95b028:52cd143e\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003c1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
           "    const mediump vec4 c1 = vec4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=3aa98d3f:c4638eae:63ae3b60:dd9955f6\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004f1\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const half4 c1 = half4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
             "    const half4 c2 = half4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6aab1881:29f77204:f1b685a8:61116330\n"
             "//SIG=00400000:00000001:00000001:00000001:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const float4 c1 = float4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
             "    const float4 c2 = float4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=dc7a742f:53a3e169:5f36b38d:56ae6c74\n"
             "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000533\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
           "    const mediump vec4 c1 = vec4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
           "    const mediump vec4 c2 = vec4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.www;\n"
           "    r1.xyz = r1.xyz - c2.xxx;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=2a49f7b8:cd3037fd:e1ea1b48:caf698d9\n"
           "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004f1\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const half4 c1 = half4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
             "    const half4 c2 = half4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6aab1881:29f77204:f1b685a8:61116330\n"
             "//SIG=00400000:00000001:00000001:00000001:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const float4 c1 = float4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
             "    const float4 c2 = float4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=dc7a742f:53a3e169:5f36b38d:56ae6c74\n"
             "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000528\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
           "    const highp vec4 c1 = vec4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
           "    const highp vec4 c2 = vec4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.www;\n"
           "    r1.xyz = r1.xyz - c2.xxx;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=8236f966:82710f38:6ac9571a:80f55067\n"
           "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002df\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=79fbc4d4:3000f291:f4e8ca38:00f5497f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002d3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=64865123:71308dc6:6f589b45:024bcb37\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000026e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const lowp vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    lowp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = r1.xyz*r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f55ad575:d6e4a08d:c419384d:6702d386\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000404\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const half4 c1 = half4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c88b9c32:b270bb6c:61f28474:3eae048f\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003fa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const float4 c1 = float4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ab1e5c77:80702e68:d7a02002:c3f3bd86\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
           "    const mediump vec4 c1 = vec4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c25197b6:d7275bee:d47c1785:36c049a6\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000404\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const half4 c1 = half4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c88b9c32:b270bb6c:61f28474:3eae048f\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003fa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const float4 c1 = float4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ab1e5c77:80702e68:d7a02002:c3f3bd86\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003cd\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
           "    const highp vec4 c1 = vec4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=0028a9f8:5f19df0d:6c2b2f26:e062f7ac\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000404\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const half4 c1 = half4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c88b9c32:b270bb6c:61f28474:3eae048f\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003fa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const float4 c1 = float4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ab1e5c77:80702e68:d7a02002:c3f3bd86\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d6\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
           "    const mediump vec4 c1 = vec4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=b3973609:7b3f330a:954f2d12:2d8a6069\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000506\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const half4 c1 = half4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
             "    const half4 c2 = half4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=fa4f7f81:31a3eb5d:0e3af884:72b21e79\n"
             "//SIG=00400000:00000001:00000001:00000001:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004fe\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const float4 c1 = float4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
             "    const float4 c2 = float4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=852efa7c:0e34cb02:774102e7:8ed7d417\n"
             "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000548\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
           "    const mediump vec4 c1 = vec4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
           "    const mediump vec4 c2 = vec4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz + c1.xxx;\n"
           "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
           "    r2.xyz = r2.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.www;\n"
           "    r1.xyz = r1.xyz - c2.xxx;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=4813d1cd:56899d9d:03f3d94f:9d4c7064\n"
           "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000506\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const half4 c1 = half4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
             "    const half4 c2 = half4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=fa4f7f81:31a3eb5d:0e3af884:72b21e79\n"
             "//SIG=00400000:00000001:00000001:00000001:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004fe\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const float4 c1 = float4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
             "    const float4 c2 = float4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=852efa7c:0e34cb02:774102e7:8ed7d417\n"
             "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000053d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
           "    const highp vec4 c1 = vec4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
           "    const highp vec4 c2 = vec4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz + c1.xxx;\n"
           "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
           "    r2.xyz = r2.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.www;\n"
           "    r1.xyz = r1.xyz - c2.xxx;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=72b3ec65:d0158182:14cc14f1:da364b12\n"
           "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002de\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=71371cbe:526a992c:7aa37843:1294333d\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002d2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=d6a33776:ea9d46d1:7b701ce4:2b02f2f0\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000273\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = sqrt(r1.xyz);\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=366ef5c6:9018d21a:09aca884:96379d9d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003ee\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const half4 c1 = half4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=db453a6f:a444ef71:2866b30e:6aac7219\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const float4 c1 = float4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=15a28e7a:79c07734:f177076f:5fe81d05\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003be\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
           "    const mediump vec4 c1 = vec4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=a9a40871:0e0e0f0a:f4187270:12acff8d\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003ee\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const half4 c1 = half4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=db453a6f:a444ef71:2866b30e:6aac7219\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const float4 c1 = float4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=15a28e7a:79c07734:f177076f:5fe81d05\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003b7\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
           "    const highp vec4 c1 = vec4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=4d9361bc:170de0f7:0b31a991:275e089a\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003ee\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const half4 c1 = half4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=db453a6f:a444ef71:2866b30e:6aac7219\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const float4 c1 = float4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=15a28e7a:79c07734:f177076f:5fe81d05\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003c0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
           "    const mediump vec4 c1 = vec4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=36373057:7825bc00:61a895a4:bb953c61\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004a1\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const half4 c1 = half4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.yyy;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1ee6f629:03660d51:273f8305:e1d73d59\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000497\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const float4 c1 = float4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.yyy;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ee1fc169:6bca4dbb:e14a0e2a:0c373c5c\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004dd\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
           "    const mediump vec4 c1 = vec4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*-c0.yyy;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=22760808:b0121326:154c3e20:4d6403b5\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004a1\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const half4 c1 = half4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.yyy;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1ee6f629:03660d51:273f8305:e1d73d59\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000497\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const float4 c1 = float4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.yyy;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ee1fc169:6bca4dbb:e14a0e2a:0c373c5c\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004d4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
           "    const highp vec4 c1 = vec4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*-c0.yyy;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=7d925446:286db01f:d2c0c230:f4f6e683\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002df\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=79fbc4d4:3000f291:f4e8ca38:00f5497f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002d3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=64865123:71308dc6:6f589b45:024bcb37\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000026e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const lowp vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    lowp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = r1.xyz*r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f55ad575:d6e4a08d:c419384d:6702d386\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000403\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const half4 c1 = half4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a44fc0b7:ea328a33:cf4a9db3:4bd6b6dd\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003f9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const float4 c1 = float4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=d8185069:3af0b32a:4fe1d9b1:829cf334\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d3\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
           "    const mediump vec4 c1 = vec4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=256671af:933a634c:c4e8abd9:c32315fa\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000403\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const half4 c1 = half4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a44fc0b7:ea328a33:cf4a9db3:4bd6b6dd\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003f9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const float4 c1 = float4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=d8185069:3af0b32a:4fe1d9b1:829cf334\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003cc\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
           "    const highp vec4 c1 = vec4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=1c2425c4:5b28bf97:affb265b:71b50146\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000403\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const half4 c1 = half4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a44fc0b7:ea328a33:cf4a9db3:4bd6b6dd\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003f9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const float4 c1 = float4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=d8185069:3af0b32a:4fe1d9b1:829cf334\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d5\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
           "    const mediump vec4 c1 = vec4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=446de1ea:6f10c75f:8184103c:b4f68d5a\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004b5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const half4 c1 = half4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.xxx;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=316ddc5b:0affc1f7:1f1d5328:c24e9963\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004ab\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const float4 c1 = float4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.xxx;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=34e08d69:0b18bc5f:7e701567:ce89af42\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004f1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
           "    const mediump vec4 c1 = vec4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz + c1.xxx;\n"
           "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
           "    r2.xyz = r2.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*-c0.xxx;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=9fc1cd11:dd7aec9f:5ffae8d6:30ffe3ff\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004b5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const half4 c1 = half4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.xxx;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=316ddc5b:0affc1f7:1f1d5328:c24e9963\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004ab\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const float4 c1 = float4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.xxx;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=34e08d69:0b18bc5f:7e701567:ce89af42\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004e8\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
           "    const highp vec4 c1 = vec4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz + c1.xxx;\n"
           "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
           "    r2.xyz = r2.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*-c0.xxx;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=5fe13b13:05915c49:459d1234:50462cd6\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000328\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 1.200000048, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz*c0.zzz;\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
             "    r0.xyz = sqrt(r2.xyz);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d2eda416:bd402552:ac770787:37d9c71e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000031c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 1.200000048, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz*c0.zzz;\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
             "    r0.xyz = sqrt(r2.xyz);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=961474ec:b4189c15:289b1cb2:8eee082b\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002bd\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 1.200000048, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz*c0.zzz;\n"
           "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
           "    r0.xyz = sqrt(r2.xyz);\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=5bb900e4:bbd57169:51eec8b3:8c45d843\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003f0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const half4 c1 = half4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=67ea82e5:d8d4d03f:005f5db3:df7ef241\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e6\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const float4 c1 = float4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=fe5592fa:c679203d:75fdd5d7:4852933e\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003c0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
           "    const mediump vec4 c1 = vec4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f4f49178:9ac2d53b:8513dad5:2ecb27f1\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003f0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const half4 c1 = half4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=67ea82e5:d8d4d03f:005f5db3:df7ef241\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e6\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const float4 c1 = float4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=fe5592fa:c679203d:75fdd5d7:4852933e\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003b9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
           "    const highp vec4 c1 = vec4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=270746a4:889949e0:e0f01346:90962527\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003f0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const half4 c1 = half4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=67ea82e5:d8d4d03f:005f5db3:df7ef241\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e6\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const float4 c1 = float4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=fe5592fa:c679203d:75fdd5d7:4852933e\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
           "    const mediump vec4 c1 = vec4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=42250c82:0fede816:5327b276:cd676e5b\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000488\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
             "    const half4 c1 = half4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=add5a51f:0abea880:ca4bf929:e553a4b0\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000047e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
             "    const float4 c1 = float4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=56b3d24b:4d3b2603:66eaa036:ff760bcf\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004c8\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
           "    const mediump vec4 c1 = vec4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.zzz);\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r2.x : r2.x, r0.y < 0.00000 ? -r2.y : r2.y, r0.z < 0.00000 ? -r2.z : r2.z"
           ");\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=74457ba2:761def36:20a0914a:92023896\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000488\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
             "    const half4 c1 = half4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=add5a51f:0abea880:ca4bf929:e553a4b0\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000047e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
             "    const float4 c1 = float4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=56b3d24b:4d3b2603:66eaa036:ff760bcf\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004bf\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
           "    const highp vec4 c1 = vec4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.zzz);\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r2.x : r2.x, r0.y < 0.00000 ? -r2.y : r2.y, r0.z < 0.00000 ? -r2.z : r2.z"
           ");\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f708cbc1:705d1338:9da8cb64:4a35ae28\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000032a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.8600000143, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz*c0.zzz;\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
             "    r0.xyz = r2.xyz*r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=fef801fc:065b21af:97d6bea1:750cfbd7\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000031e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.8600000143, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz*c0.zzz;\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
             "    r0.xyz = r2.xyz*r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4d5faa0d:df2a1278:84bcfdbe:e32e0991\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002b9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const lowp vec4 c0 = vec4(0.000000000, 1.000000000, 0.8600000143, 0.000000000);\n"
           "    lowp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz*c0.zzz;\n"
           "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
           "    r0.xyz = r2.xyz*r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=de27b81a:55a16102:0abe5b0f:dcabf045\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000405\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const half4 c1 = half4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=309170bb:e0ac4821:a673360c:bad45e77\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003fb\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const float4 c1 = float4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9e74fc88:710456d9:84af040a:1a03bf93\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d5\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
           "    const mediump vec4 c1 = vec4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f9be4ebe:3f53fafc:c8fc0842:99e12788\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000405\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const half4 c1 = half4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=309170bb:e0ac4821:a673360c:bad45e77\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003fb\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const float4 c1 = float4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9e74fc88:710456d9:84af040a:1a03bf93\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003ce\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
           "    const highp vec4 c1 = vec4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=0945d6b6:a9c32d34:ec75fcd7:04a6b9d5\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000405\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const half4 c1 = half4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=309170bb:e0ac4821:a673360c:bad45e77\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003fb\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const float4 c1 = float4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9e74fc88:710456d9:84af040a:1a03bf93\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d7\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
           "    const mediump vec4 c1 = vec4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=bd16cf6b:adfe6607:a9981257:5e3f8b0c\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000049d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
             "    const half4 c1 = half4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz + c0.www;\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=94e4126c:912bd7d3:18975cf6:90abe4dd\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000493\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
             "    const float4 c1 = float4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz + c0.www;\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=87cfd56b:8f2725b7:a29eb854:c8e353be\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004dd\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
           "    const mediump vec4 c1 = vec4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz + c0.www;\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r2.x : r2.x, r0.y < 0.00000 ? -r2.y : r2.y, r0.z < 0.00000 ? -r2.z : r2.z"
           ");\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=a249e16d:662fadca:69da4b2e:b5c48b75\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000049d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
             "    const half4 c1 = half4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz + c0.www;\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=94e4126c:912bd7d3:18975cf6:90abe4dd\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000493\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
             "    const float4 c1 = float4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz + c0.www;\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=87cfd56b:8f2725b7:a29eb854:c8e353be\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004d4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
           "    const highp vec4 c1 = vec4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz + c0.www;\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r2.x : r2.x, r0.y < 0.00000 ? -r2.y : r2.y, r0.z < 0.00000 ? -r2.z : r2.z"
           ");\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c0dc8aa3:f61b8cf0:f53695f9:9eb99125\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002de\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=71371cbe:526a992c:7aa37843:1294333d\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002d2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=d6a33776:ea9d46d1:7b701ce4:2b02f2f0\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000273\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = sqrt(r1.xyz);\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=366ef5c6:9018d21a:09aca884:96379d9d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002fb\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6c87b179:931a7f82:2e7d93b9:6b7e838f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9a27762e:e48ffb09:7625bd98:1087a6a4\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000290\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=256d38f7:d8a55347:9de06529:49ce2800\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002fb\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6c87b179:931a7f82:2e7d93b9:6b7e838f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9a27762e:e48ffb09:7625bd98:1087a6a4\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000028b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=e5f2ac3f:98b9a102:02813f98:70ef968a\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002fb\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6c87b179:931a7f82:2e7d93b9:6b7e838f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9a27762e:e48ffb09:7625bd98:1087a6a4\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000292\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=4e475cbc:5a55909e:9bd0936c:5f882794\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000377\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=493a7313:1f860720:3cbff05e:044e50ab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000036b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=65cb7d50:6b4deded:b009e9aa:332eb294\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000037c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.zzz);\n"
           "    r1.xyz = pow(r1.xyz, c0.www);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=e4e6fb8a:78a157d4:087b3095:98f8a653\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000377\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=493a7313:1f860720:3cbff05e:044e50ab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000036b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=65cb7d50:6b4deded:b009e9aa:332eb294\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000375\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.zzz);\n"
           "    r1.xyz = pow(r1.xyz, c0.www);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=4caa96c5:80eab27c:24257f6b:03530b0d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002df\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=79fbc4d4:3000f291:f4e8ca38:00f5497f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002d3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=64865123:71308dc6:6f589b45:024bcb37\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000026e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const lowp vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    lowp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = r1.xyz*r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f55ad575:d6e4a08d:c419384d:6702d386\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002fa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b94e5a6d:a57d1749:ab36e45c:e1699a4f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002ee\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e29c192e:d60afaaa:96bfb94b:c6295363\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000028f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=731b047d:567e4b62:b8616393:f8c0d1ab\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002fa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b94e5a6d:a57d1749:ab36e45c:e1699a4f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002ee\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e29c192e:d60afaaa:96bfb94b:c6295363\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000028a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=625c3c87:60b34443:dc7f6036:8e0bdc42\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002fa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b94e5a6d:a57d1749:ab36e45c:e1699a4f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002ee\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e29c192e:d60afaaa:96bfb94b:c6295363\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000291\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=90d4bf0f:6ecf2069:2e0a9113:b447053f\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000376\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=19bd766f:80d76f2e:a4240bb7:64de5c0d\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000036a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b48d2ef7:b3a26fa4:aeddfc2d:626e715c\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000037b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.zzz);\n"
           "    r1.xyz = pow(r1.xyz, c0.www);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=0e382641:74972844:02f4fa3b:b4115f62\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000376\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=19bd766f:80d76f2e:a4240bb7:64de5c0d\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000036a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b48d2ef7:b3a26fa4:aeddfc2d:626e715c\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000374\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.zzz);\n"
           "    r1.xyz = pow(r1.xyz, c0.www);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=d4976673:e7ba6629:3824413f:09fec661\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void Inittype0_fast_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type0_fast_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000222\n[[ visible ]] FragmentOut type0_fast_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
    "    r1.xyz = fmin(r1.xyz, c0.www);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B268C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B268F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B268F0);
}

void Inittype0_fixed_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type0_fixed_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000223\n[[ visible ]] FragmentOut type0_fixed_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
    "    r1.xyz = fmin(r1.xyz, c0.www);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B26B00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B26B30(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B26B28);
}

void Inittype0_nice_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type0_nice_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000222\n[[ visible ]] FragmentOut type0_nice_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
    "    r1.xyz = fmin(r1.xyz, c0.www);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B26D38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B26D68(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B26D60);
}

void Inittype0_half_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type0_half_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000222\n[[ visible ]] FragmentOut type0_half_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
    "    r1.xyz = fmin(r1.xyz, c0.www);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B26F70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B26FA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B26F98);
}

void Inittype0_halfProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type0_half_hgc_visible", "//Metal1.0     \n//LEN=0000000274\n[[ visible ]] FragmentOut type0_half_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B271A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B271D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B271D0);
}

void Inittype0_niceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type0_nice_hgc_visible", "//Metal1.0     \n//LEN=0000000274\n[[ visible ]] FragmentOut type0_nice_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B273E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B27410(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B27408);
}

void Inittype0_floatProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type0_float_hgc_visible", "//Metal1.0     \n//LEN=0000000275\n[[ visible ]] FragmentOut type0_float_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B27618(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B27648(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B27640);
}

void Inittype1_fast_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type1_fast_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000304\n[[ visible ]] FragmentOut type1_fast_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B27850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B27880(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B27878);
}

void Inittype1_fixed_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type1_fixed_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000305\n[[ visible ]] FragmentOut type1_fixed_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B27A88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B27AB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B27AB0);
}

void Inittype1_nice_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type1_nice_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000304\n[[ visible ]] FragmentOut type1_nice_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B27CC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B27CF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B27CE8);
}

void Inittype1_half_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type1_half_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000304\n[[ visible ]] FragmentOut type1_half_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B27EF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B27F28(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B27F20);
}

void Inittype1_halfProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type1_half_hgc_visible", "//Metal1.0     \n//LEN=00000002e7\n[[ visible ]] FragmentOut type1_half_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xw = c0.zx;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r3.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B28130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B28160(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B28158);
}

void Inittype1_niceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type1_nice_hgc_visible", "//Metal1.0     \n//LEN=00000002e7\n[[ visible ]] FragmentOut type1_nice_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xw = c0.zx;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r3.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B28368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B28398(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B28390);
}

void Inittype1_floatProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type1_float_hgc_visible", "//Metal1.0     \n//LEN=00000002e8\n[[ visible ]] FragmentOut type1_float_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xw = c0.zx;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r3.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B285A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B285D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B285C8);
}

void Inittype2_fast_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type2_fast_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000347\n[[ visible ]] FragmentOut type2_fast_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B287D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B28808(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B28800);
}

void Inittype2_fixed_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type2_fixed_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000348\n[[ visible ]] FragmentOut type2_fixed_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B28A10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B28A40(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B28A38);
}

void Inittype2_nice_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type2_nice_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000347\n[[ visible ]] FragmentOut type2_nice_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B28C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B28C78(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B28C70);
}

void Inittype2_half_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type2_half_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000347\n[[ visible ]] FragmentOut type2_half_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B28E80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B28EB0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B28EA8);
}

void Inittype2_halfProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type2_half_hgc_visible", "//Metal1.0     \n//LEN=000000030f\n[[ visible ]] FragmentOut type2_half_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xw = c0.zx;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r3.xyz;\n"
    "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B290B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B290E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B290E0);
}

void Inittype2_niceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type2_nice_hgc_visible", "//Metal1.0     \n//LEN=000000030f\n[[ visible ]] FragmentOut type2_nice_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xw = c0.zx;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r3.xyz;\n"
    "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B292F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B29320(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B29318);
}

void Inittype2_floatProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type2_float_hgc_visible", "//Metal1.0     \n//LEN=0000000310\n[[ visible ]] FragmentOut type2_float_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xw = c0.zx;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r3.xyz;\n"
    "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B29528(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B29558(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B29550);
}

void Inittype3_fast_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type3_fast_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000319\n[[ visible ]] FragmentOut type3_fast_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B29760(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B29790(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B29788);
}

void Inittype3_fixed_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type3_fixed_sat_hgc_visible", "//Metal1.0     \n//LEN=000000031a\n[[ visible ]] FragmentOut type3_fixed_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B29998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B299C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B299C0);
}

void Inittype3_nice_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type3_nice_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000319\n[[ visible ]] FragmentOut type3_nice_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B29BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B29C00(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B29BF8);
}

void Inittype3_half_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type3_half_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000319\n[[ visible ]] FragmentOut type3_half_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B29E08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B29E38(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B29E30);
}

void Inittype3_halfProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type3_half_hgc_visible", "//Metal1.0     \n//LEN=000000030b\n[[ visible ]] FragmentOut type3_half_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.w = c0.x;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
    "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2A040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2A070(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2A068);
}

void Inittype3_niceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type3_nice_hgc_visible", "//Metal1.0     \n//LEN=000000030b\n[[ visible ]] FragmentOut type3_nice_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.w = c0.x;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
    "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2A278(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2A2A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2A2A0);
}

void Inittype3_floatProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type3_float_hgc_visible", "//Metal1.0     \n//LEN=000000030c\n[[ visible ]] FragmentOut type3_float_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.w = c0.x;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
    "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2A4B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2A4E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2A4D8);
}

void Inittype4_fast_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type4_fast_sat_hgc_visible", "//Metal1.0     \n//LEN=000000036f\n[[ visible ]] FragmentOut type4_fast_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.www);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2A6E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2A718(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2A710);
}

void Inittype4_fixed_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type4_fixed_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000370\n[[ visible ]] FragmentOut type4_fixed_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.www);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2A920(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2A950(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2A948);
}

void Inittype4_nice_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type4_nice_sat_hgc_visible", "//Metal1.0     \n//LEN=000000036f\n[[ visible ]] FragmentOut type4_nice_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.www);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2AB58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2AB88(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2AB80);
}

void Inittype4_half_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type4_half_sat_hgc_visible", "//Metal1.0     \n//LEN=000000036f\n[[ visible ]] FragmentOut type4_half_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.www);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2AD90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2ADC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2ADB8);
}

void Inittype4_halfProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type4_half_hgc_visible", "//Metal1.0     \n//LEN=0000000346\n[[ visible ]] FragmentOut type4_half_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.w = c0.w;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
    "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2AFC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2AFF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2AFF0);
}

void Inittype4_niceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type4_nice_hgc_visible", "//Metal1.0     \n//LEN=0000000346\n[[ visible ]] FragmentOut type4_nice_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.w = c0.w;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
    "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2B200(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2B230(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2B228);
}

void Inittype4_floatProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type4_float_hgc_visible", "//Metal1.0     \n//LEN=0000000347\n[[ visible ]] FragmentOut type4_float_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.w = c0.w;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
    "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2B438(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2B468(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2B460);
}

void Initrec709_fast_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec709_fast_sat_hgc_visible", "//Metal1.0     \n//LEN=00000001fd\n[[ visible ]] FragmentOut rec709_fast_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r0.xyz = sqrt(r1.xyz);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2B670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2B6A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2B698);
}

void Initrec709_fixed_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec709_fixed_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000311\n[[ visible ]] FragmentOut rec709_fixed_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
    "    const float4 c1 = float4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2B8A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2B8D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2B8D0);
}

void Initrec709_nice_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec709_nice_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000310\n[[ visible ]] FragmentOut rec709_nice_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
    "    const float4 c1 = float4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2BAE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2BB10(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2BB08);
}

void Initrec709_half_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec709_half_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000310\n[[ visible ]] FragmentOut rec709_half_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
    "    const float4 c1 = float4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2BD18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2BD48(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2BD40);
}

void Initrec709_halfProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec709_half_hgc_visible", "//Metal1.0     \n//LEN=0000000410\n[[ visible ]] FragmentOut rec709_half_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
    "    const float4 c1 = float4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
    "    const float4 c2 = float4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
    "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.www;\n"
    "    r1.xyz = r1.xyz - c2.xxx;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2BF50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2BF80(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2BF78);
}

void Initrec709_niceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec709_nice_hgc_visible", "//Metal1.0     \n//LEN=0000000410\n[[ visible ]] FragmentOut rec709_nice_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
    "    const float4 c1 = float4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
    "    const float4 c2 = float4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
    "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.www;\n"
    "    r1.xyz = r1.xyz - c2.xxx;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2C188(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2C1B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2C1B0);
}

void Initinv_rec709_fast_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec709_fast_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000202\n[[ visible ]] FragmentOut inv_rec709_fast_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r0.xyz = r1.xyz*r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2C3C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2C3F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2C3E8);
}

void Initinv_rec709_fixed_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec709_fixed_sat_hgc_visible", "//Metal1.0     \n//LEN=000000032a\n[[ visible ]] FragmentOut inv_rec709_fixed_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
    "    const float4 c1 = float4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2C5F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2C628(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2C620);
}

void Initinv_rec709_nice_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec709_nice_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000329\n[[ visible ]] FragmentOut inv_rec709_nice_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
    "    const float4 c1 = float4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2C830(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2C860(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2C858);
}

void Initinv_rec709_half_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec709_half_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000329\n[[ visible ]] FragmentOut inv_rec709_half_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
    "    const float4 c1 = float4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2CA68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2CA98(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2CA90);
}

void Initinv_rec709_halfProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec709_half_hgc_visible", "//Metal1.0     \n//LEN=0000000429\n[[ visible ]] FragmentOut inv_rec709_half_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
    "    const float4 c1 = float4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
    "    const float4 c2 = float4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz + c1.xxx;\n"
    "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
    "    r2.xyz = r2.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.www;\n"
    "    r1.xyz = r1.xyz - c2.xxx;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2CCA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2CCD0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2CCC8);
}

void Initinv_rec709_niceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec709_nice_hgc_visible", "//Metal1.0     \n//LEN=0000000429\n[[ visible ]] FragmentOut inv_rec709_nice_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
    "    const float4 c1 = float4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
    "    const float4 c2 = float4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz + c1.xxx;\n"
    "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
    "    r2.xyz = r2.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.www;\n"
    "    r1.xyz = r1.xyz - c2.xxx;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2CED8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2CF08(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2CF00);
}

void Initrec601_fast_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec601_fast_sat_hgc_visible", "//Metal1.0     \n//LEN=00000001fd\n[[ visible ]] FragmentOut rec601_fast_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r0.xyz = sqrt(r1.xyz);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2D110(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2D140(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2D138);
}

void Initrec601_fixed_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec601_fixed_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000310\n[[ visible ]] FragmentOut rec601_fixed_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
    "    const float4 c1 = float4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2D348(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2D378(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2D370);
}

void Initrec601_nice_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec601_nice_sat_hgc_visible", "//Metal1.0     \n//LEN=000000030f\n[[ visible ]] FragmentOut rec601_nice_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
    "    const float4 c1 = float4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2D580(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2D5B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2D5A8);
}

void Initrec601_half_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec601_half_sat_hgc_visible", "//Metal1.0     \n//LEN=000000030f\n[[ visible ]] FragmentOut rec601_half_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
    "    const float4 c1 = float4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2D7B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2D7E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2D7E0);
}

void Initrec601_halfProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec601_half_hgc_visible", "//Metal1.0     \n//LEN=00000003be\n[[ visible ]] FragmentOut rec601_half_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
    "    const float4 c1 = float4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
    "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*-c0.yyy;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2D9F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2DA20(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2DA18);
}

void Initrec601_niceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec601_nice_hgc_visible", "//Metal1.0     \n//LEN=00000003be\n[[ visible ]] FragmentOut rec601_nice_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
    "    const float4 c1 = float4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
    "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*-c0.yyy;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2DC28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2DC58(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2DC50);
}

void Initinv_rec601_fast_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec601_fast_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000202\n[[ visible ]] FragmentOut inv_rec601_fast_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r0.xyz = r1.xyz*r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2DE60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2DE90(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2DE88);
}

void Initinv_rec601_fixed_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec601_fixed_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000329\n[[ visible ]] FragmentOut inv_rec601_fixed_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
    "    const float4 c1 = float4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2E098(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2E0C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2E0C0);
}

void Initinv_rec601_nice_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec601_nice_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000328\n[[ visible ]] FragmentOut inv_rec601_nice_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
    "    const float4 c1 = float4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2E2D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2E300(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2E2F8);
}

void Initinv_rec601_half_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec601_half_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000328\n[[ visible ]] FragmentOut inv_rec601_half_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
    "    const float4 c1 = float4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2E508(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2E538(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2E530);
}

void Initinv_rec601_halfProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec601_half_hgc_visible", "//Metal1.0     \n//LEN=00000003d6\n[[ visible ]] FragmentOut inv_rec601_half_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
    "    const float4 c1 = float4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz + c1.xxx;\n"
    "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
    "    r2.xyz = r2.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*-c0.xxx;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2E740(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2E770(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2E768);
}

void Initinv_rec601_niceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec601_nice_hgc_visible", "//Metal1.0     \n//LEN=00000003d6\n[[ visible ]] FragmentOut inv_rec601_nice_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
    "    const float4 c1 = float4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz + c1.xxx;\n"
    "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
    "    r2.xyz = r2.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*-c0.xxx;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2E978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2E9A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2E9A0);
}

void Initsrgb_fast_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "srgb_fast_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000245\n[[ visible ]] FragmentOut srgb_fast_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 1.200000048, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz*c0.zzz;\n"
    "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
    "    r0.xyz = sqrt(r2.xyz);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2EBB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2EBE0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2EBD8);
}

void Initsrgb_fixed_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "srgb_fixed_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000310\n[[ visible ]] FragmentOut srgb_fixed_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
    "    const float4 c1 = float4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2EDE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2EE18(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2EE10);
}

void Initsrgb_nice_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "srgb_nice_sat_hgc_visible", "//Metal1.0     \n//LEN=000000030f\n[[ visible ]] FragmentOut srgb_nice_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
    "    const float4 c1 = float4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2F020(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2F050(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2F048);
}

void Initsrgb_half_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "srgb_half_sat_hgc_visible", "//Metal1.0     \n//LEN=000000030f\n[[ visible ]] FragmentOut srgb_half_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
    "    const float4 c1 = float4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2F258(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2F288(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2F280);
}

void Initsrgb_halfProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "srgb_half_hgc_visible", "//Metal1.0     \n//LEN=00000003a3\n[[ visible ]] FragmentOut srgb_half_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
    "    const float4 c1 = float4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2F490(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2F4C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2F4B8);
}

void Initsrgb_niceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "srgb_nice_hgc_visible", "//Metal1.0     \n//LEN=00000003a3\n[[ visible ]] FragmentOut srgb_nice_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
    "    const float4 c1 = float4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2F6C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2F6F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2F6F0);
}

void Initinv_srgb_fast_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_srgb_fast_sat_hgc_visible", "//Metal1.0     \n//LEN=000000024b\n[[ visible ]] FragmentOut inv_srgb_fast_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.8600000143, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz*c0.zzz;\n"
    "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
    "    r0.xyz = r2.xyz*r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2F900(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2F930(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2F928);
}

void Initinv_srgb_fixed_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_srgb_fixed_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000329\n[[ visible ]] FragmentOut inv_srgb_fixed_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
    "    const float4 c1 = float4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2FB38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2FB68(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2FB60);
}

void Initinv_srgb_nice_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_srgb_nice_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000328\n[[ visible ]] FragmentOut inv_srgb_nice_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
    "    const float4 c1 = float4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2FD70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2FDA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2FD98);
}

void Initinv_srgb_half_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_srgb_half_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000328\n[[ visible ]] FragmentOut inv_srgb_half_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
    "    const float4 c1 = float4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B2FFA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B2FFD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B2FFD0);
}

void Initinv_srgb_halfProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_srgb_half_hgc_visible", "//Metal1.0     \n//LEN=00000003bc\n[[ visible ]] FragmentOut inv_srgb_half_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
    "    const float4 c1 = float4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz + c0.www;\n"
    "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
    "    r2.xyz = r2.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B301E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B30210(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B30208);
}

void Initinv_srgb_niceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_srgb_nice_hgc_visible", "//Metal1.0     \n//LEN=00000003bc\n[[ visible ]] FragmentOut inv_srgb_nice_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
    "    const float4 c1 = float4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz + c0.www;\n"
    "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
    "    r2.xyz = r2.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B30418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B30448(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B30440);
}

void Initquicktime_fast_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "quicktime_fast_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000200\n[[ visible ]] FragmentOut quicktime_fast_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r0.xyz = sqrt(r1.xyz);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B30650(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B30680(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B30678);
}

void Initquicktime_fixed_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "quicktime_fixed_sat_hgc_visible", "//Metal1.0     \n//LEN=000000021e\n[[ visible ]] FragmentOut quicktime_fixed_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B30888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B308B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B308B0);
}

void Initquicktime_nice_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "quicktime_nice_sat_hgc_visible", "//Metal1.0     \n//LEN=000000021d\n[[ visible ]] FragmentOut quicktime_nice_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B30AC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B30AF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B30AE8);
}

void Initquicktime_half_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "quicktime_half_sat_hgc_visible", "//Metal1.0     \n//LEN=000000021d\n[[ visible ]] FragmentOut quicktime_half_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B30CF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B30D28(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B30D20);
}

void Initquicktime_halfProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "quicktime_half_hgc_visible", "//Metal1.0     \n//LEN=0000000295\n[[ visible ]] FragmentOut quicktime_half_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
    "    r1.xyz = pow(r1.xyz, c0.www);\n"
    "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B30F30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B30F60(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B30F58);
}

void Initquicktime_niceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "quicktime_nice_hgc_visible", "//Metal1.0     \n//LEN=0000000295\n[[ visible ]] FragmentOut quicktime_nice_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
    "    r1.xyz = pow(r1.xyz, c0.www);\n"
    "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B31168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B31198(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B31190);
}

void Initinv_quicktime_fast_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_quicktime_fast_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000205\n[[ visible ]] FragmentOut inv_quicktime_fast_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r0.xyz = r1.xyz*r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B313A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B313D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B313C8);
}

void Initinv_quicktime_fixed_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_quicktime_fixed_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000221\n[[ visible ]] FragmentOut inv_quicktime_fixed_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B315D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B31608(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B31600);
}

void Initinv_quicktime_nice_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_quicktime_nice_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000220\n[[ visible ]] FragmentOut inv_quicktime_nice_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B31810(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B31840(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B31838);
}

void Initinv_quicktime_half_satProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_quicktime_half_sat_hgc_visible", "//Metal1.0     \n//LEN=0000000220\n[[ visible ]] FragmentOut inv_quicktime_half_sat_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B31A48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B31A78(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B31A70);
}

void Initinv_quicktime_halfProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_quicktime_half_hgc_visible", "//Metal1.0     \n//LEN=0000000298\n[[ visible ]] FragmentOut inv_quicktime_half_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
    "    r1.xyz = pow(r1.xyz, c0.www);\n"
    "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B31C80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B31CB0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B31CA8);
}

void Initinv_quicktime_niceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_quicktime_nice_hgc_visible", "//Metal1.0     \n//LEN=0000000298\n[[ visible ]] FragmentOut inv_quicktime_nice_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
    "    r1.xyz = pow(r1.xyz, c0.www);\n"
    "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B31EB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B31EE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B31EE0);
}

void Inittype0_fast_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type0_fast_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001da\n[[ visible ]] FragmentOut type0_fast_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
    "    r1.xyz = fmin(r1.xyz, c0.www);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B320F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B32120(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B32118);
}

void Inittype0_fixed_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type0_fixed_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001db\n[[ visible ]] FragmentOut type0_fixed_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
    "    r1.xyz = fmin(r1.xyz, c0.www);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B32328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B32358(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B32350);
}

void Inittype0_nice_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type0_nice_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=0000000256\n[[ visible ]] FragmentOut type0_nice_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
    "    r0.xyz = clamp(r1.xyz, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B32560(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B32590(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B32588);
}

void Inittype0_half_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type0_half_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001da\n[[ visible ]] FragmentOut type0_half_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
    "    r1.xyz = fmin(r1.xyz, c0.www);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B32798(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B327C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B327C0);
}

void Inittype0_half_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type0_half_unpremult_hgc_visible", "//Metal1.0     \n//LEN=000000022c\n[[ visible ]] FragmentOut type0_half_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B329D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B32A00(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B329F8);
}

void Inittype0_nice_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type0_nice_unpremult_hgc_visible", "//Metal1.0     \n//LEN=000000022c\n[[ visible ]] FragmentOut type0_nice_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B32C08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B32C38(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B32C30);
}

void Inittype0_float_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type0_float_unpremult_hgc_visible", "//Metal1.0     \n//LEN=000000022d\n[[ visible ]] FragmentOut type0_float_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B32E40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B32E70(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B32E68);
}

void Inittype1_fast_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type1_fast_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002bc\n[[ visible ]] FragmentOut type1_fast_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B33078(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B330A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B330A0);
}

void Inittype1_fixed_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type1_fixed_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002bd\n[[ visible ]] FragmentOut type1_fixed_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B332B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B332E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B332D8);
}

void Inittype1_nice_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type1_nice_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002bc\n[[ visible ]] FragmentOut type1_nice_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B334E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B33518(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B33510);
}

void Inittype1_half_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type1_half_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002bc\n[[ visible ]] FragmentOut type1_half_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B33720(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B33750(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B33748);
}

void Inittype1_half_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type1_half_unpremult_hgc_visible", "//Metal1.0     \n//LEN=000000029f\n[[ visible ]] FragmentOut type1_half_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xw = c0.zx;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r3.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B33958(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B33988(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B33980);
}

void Inittype1_nice_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type1_nice_unpremult_hgc_visible", "//Metal1.0     \n//LEN=000000029f\n[[ visible ]] FragmentOut type1_nice_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xw = c0.zx;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r3.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B33B90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B33BC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B33BB8);
}

void Inittype1_float_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type1_float_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002a0\n[[ visible ]] FragmentOut type1_float_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xw = c0.zx;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r3.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B33DC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B33DF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B33DF0);
}

void Inittype2_fast_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type2_fast_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002ff\n[[ visible ]] FragmentOut type2_fast_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B34000(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B34030(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B34028);
}

void Inittype2_fixed_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type2_fixed_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=0000000300\n[[ visible ]] FragmentOut type2_fixed_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B34238(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B34268(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B34260);
}

void Inittype2_nice_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type2_nice_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002ff\n[[ visible ]] FragmentOut type2_nice_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B34470(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B344A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B34498);
}

void Inittype2_half_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type2_half_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002ff\n[[ visible ]] FragmentOut type2_half_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = c0.z;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B346A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B346D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B346D0);
}

void Inittype2_half_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type2_half_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002c7\n[[ visible ]] FragmentOut type2_half_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xw = c0.zx;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r3.xyz;\n"
    "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B348E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B34910(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B34908);
}

void Inittype2_nice_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type2_nice_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002c7\n[[ visible ]] FragmentOut type2_nice_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xw = c0.zx;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r3.xyz;\n"
    "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B34B18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B34B48(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B34B40);
}

void Inittype2_float_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type2_float_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002c8\n[[ visible ]] FragmentOut type2_float_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xw = c0.zx;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
    "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r3.xyz;\n"
    "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B34D50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B34D80(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B34D78);
}

void Inittype3_fast_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type3_fast_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002d1\n[[ visible ]] FragmentOut type3_fast_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B34F88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B34FB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B34FB0);
}

void Inittype3_fixed_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type3_fixed_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002d2\n[[ visible ]] FragmentOut type3_fixed_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B351C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B351F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B351E8);
}

void Inittype3_nice_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type3_nice_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002d1\n[[ visible ]] FragmentOut type3_nice_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B353F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B35428(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B35420);
}

void Inittype3_half_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type3_half_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002d1\n[[ visible ]] FragmentOut type3_half_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B35630(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B35660(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B35658);
}

void Inittype3_half_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type3_half_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002c3\n[[ visible ]] FragmentOut type3_half_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.w = c0.x;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
    "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B35868(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B35898(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B35890);
}

void Inittype3_nice_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type3_nice_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002c3\n[[ visible ]] FragmentOut type3_nice_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.w = c0.x;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
    "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B35AA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B35AD0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B35AC8);
}

void Inittype3_float_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type3_float_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002c4\n[[ visible ]] FragmentOut type3_float_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.w = c0.x;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
    "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B35CD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B35D08(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B35D00);
}

void Inittype4_fast_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type4_fast_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=0000000327\n[[ visible ]] FragmentOut type4_fast_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.www);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B35F10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B35F40(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B35F38);
}

void Inittype4_fixed_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type4_fixed_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=0000000328\n[[ visible ]] FragmentOut type4_fixed_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.www);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B36148(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B36178(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B36170);
}

void Inittype4_nice_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type4_nice_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=0000000327\n[[ visible ]] FragmentOut type4_nice_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.www);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B36380(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B363B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B363A8);
}

void Inittype4_half_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type4_half_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=0000000327\n[[ visible ]] FragmentOut type4_half_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r1.xyz = fmin(r1.xyz, c0.www);\n"
    "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
    "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B365B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B365E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B365E0);
}

void Inittype4_half_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type4_half_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002fe\n[[ visible ]] FragmentOut type4_half_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.w = c0.w;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
    "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B367F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B36820(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B36818);
}

void Inittype4_nice_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type4_nice_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002fe\n[[ visible ]] FragmentOut type4_nice_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.w = c0.w;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
    "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B36A28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B36A58(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B36A50);
}

void Inittype4_float_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "type4_float_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002ff\n[[ visible ]] FragmentOut type4_float_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.w = c0.w;\n"
    "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
    "    r2.xyz = fmin(r2.xyz, r1.www);\n"
    "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
    "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
    "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
    "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz;\n"
    "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B36C60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B36C90(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B36C88);
}

void Initrec709_fast_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec709_fast_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001b5\n[[ visible ]] FragmentOut rec709_fast_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r0.xyz = sqrt(r1.xyz);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B36E98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B36EC8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B36EC0);
}

void Initrec709_fixed_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec709_fixed_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002c9\n[[ visible ]] FragmentOut rec709_fixed_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
    "    const float4 c1 = float4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B370D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B37100(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B370F8);
}

void Initrec709_nice_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec709_nice_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002c8\n[[ visible ]] FragmentOut rec709_nice_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
    "    const float4 c1 = float4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B37308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B37338(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B37330);
}

void Initrec709_half_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec709_half_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002c8\n[[ visible ]] FragmentOut rec709_half_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
    "    const float4 c1 = float4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B37540(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B37570(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B37568);
}

void Initrec709_half_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec709_half_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000003c8\n[[ visible ]] FragmentOut rec709_half_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
    "    const float4 c1 = float4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
    "    const float4 c2 = float4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
    "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.www;\n"
    "    r1.xyz = r1.xyz - c2.xxx;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B37778(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B377A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B377A0);
}

void Initrec709_nice_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec709_nice_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000003c8\n[[ visible ]] FragmentOut rec709_nice_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
    "    const float4 c1 = float4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
    "    const float4 c2 = float4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
    "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.www;\n"
    "    r1.xyz = r1.xyz - c2.xxx;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B379B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B379E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B379D8);
}

void Initinv_rec709_fast_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec709_fast_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001ba\n[[ visible ]] FragmentOut inv_rec709_fast_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r0.xyz = r1.xyz*r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B37BE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B37C18(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B37C10);
}

void Initinv_rec709_fixed_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec709_fixed_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002e2\n[[ visible ]] FragmentOut inv_rec709_fixed_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
    "    const float4 c1 = float4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B37E20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B37E50(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B37E48);
}

void Initinv_rec709_nice_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec709_nice_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002e1\n[[ visible ]] FragmentOut inv_rec709_nice_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
    "    const float4 c1 = float4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B38058(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B38088(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B38080);
}

void Initinv_rec709_half_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec709_half_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002e1\n[[ visible ]] FragmentOut inv_rec709_half_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
    "    const float4 c1 = float4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B38290(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B382C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B382B8);
}

void Initinv_rec709_half_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec709_half_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000003e1\n[[ visible ]] FragmentOut inv_rec709_half_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
    "    const float4 c1 = float4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
    "    const float4 c2 = float4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz + c1.xxx;\n"
    "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
    "    r2.xyz = r2.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.www;\n"
    "    r1.xyz = r1.xyz - c2.xxx;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B384C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B384F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B384F0);
}

void Initinv_rec709_nice_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec709_nice_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000003e1\n[[ visible ]] FragmentOut inv_rec709_nice_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
    "    const float4 c1 = float4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
    "    const float4 c2 = float4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz + c1.xxx;\n"
    "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
    "    r2.xyz = r2.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.www;\n"
    "    r1.xyz = r1.xyz - c2.xxx;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B38700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B38730(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B38728);
}

void Initrec601_fast_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec601_fast_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001b5\n[[ visible ]] FragmentOut rec601_fast_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r0.xyz = sqrt(r1.xyz);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B38938(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B38968(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B38960);
}

void Initrec601_fixed_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec601_fixed_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002c8\n[[ visible ]] FragmentOut rec601_fixed_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
    "    const float4 c1 = float4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B38B70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B38BA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B38B98);
}

void Initrec601_nice_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec601_nice_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002c7\n[[ visible ]] FragmentOut rec601_nice_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
    "    const float4 c1 = float4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B38DA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B38DD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B38DD0);
}

void Initrec601_half_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec601_half_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002c7\n[[ visible ]] FragmentOut rec601_half_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
    "    const float4 c1 = float4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B38FE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B39010(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B39008);
}

void Initrec601_half_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec601_half_unpremult_hgc_visible", "//Metal1.0     \n//LEN=0000000376\n[[ visible ]] FragmentOut rec601_half_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
    "    const float4 c1 = float4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
    "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*-c0.yyy;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B39218(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B39248(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B39240);
}

void Initrec601_nice_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "rec601_nice_unpremult_hgc_visible", "//Metal1.0     \n//LEN=0000000376\n[[ visible ]] FragmentOut rec601_nice_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
    "    const float4 c1 = float4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
    "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*-c0.yyy;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B39450(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B39480(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B39478);
}

void Initinv_rec601_fast_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec601_fast_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001ba\n[[ visible ]] FragmentOut inv_rec601_fast_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r0.xyz = r1.xyz*r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B39688(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B396B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B396B0);
}

void Initinv_rec601_fixed_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec601_fixed_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002e1\n[[ visible ]] FragmentOut inv_rec601_fixed_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
    "    const float4 c1 = float4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B398C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B398F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B398E8);
}

void Initinv_rec601_nice_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec601_nice_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002e0\n[[ visible ]] FragmentOut inv_rec601_nice_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
    "    const float4 c1 = float4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B39AF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B39B28(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B39B20);
}

void Initinv_rec601_half_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec601_half_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002e0\n[[ visible ]] FragmentOut inv_rec601_half_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
    "    const float4 c1 = float4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B39D30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B39D60(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B39D58);
}

void Initinv_rec601_half_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec601_half_unpremult_hgc_visible", "//Metal1.0     \n//LEN=000000038e\n[[ visible ]] FragmentOut inv_rec601_half_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
    "    const float4 c1 = float4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz + c1.xxx;\n"
    "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
    "    r2.xyz = r2.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*-c0.xxx;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B39F68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B39F98(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B39F90);
}

void Initinv_rec601_nice_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_rec601_nice_unpremult_hgc_visible", "//Metal1.0     \n//LEN=000000038e\n[[ visible ]] FragmentOut inv_rec601_nice_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
    "    const float4 c1 = float4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz + c1.xxx;\n"
    "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
    "    r2.xyz = r2.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*-c0.xxx;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz*r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3A1A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3A1D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3A1C8);
}

void Initsrgb_fast_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "srgb_fast_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001fd\n[[ visible ]] FragmentOut srgb_fast_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 1.200000048, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz*c0.zzz;\n"
    "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
    "    r0.xyz = sqrt(r2.xyz);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3A3D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3A408(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3A400);
}

void Initsrgb_fixed_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "srgb_fixed_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002c8\n[[ visible ]] FragmentOut srgb_fixed_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
    "    const float4 c1 = float4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3A610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3A640(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3A638);
}

void Initsrgb_nice_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "srgb_nice_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002c7\n[[ visible ]] FragmentOut srgb_nice_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
    "    const float4 c1 = float4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3A848(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3A878(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3A870);
}

void Initsrgb_half_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "srgb_half_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002c7\n[[ visible ]] FragmentOut srgb_half_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
    "    const float4 c1 = float4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3AA80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3AAB0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3AAA8);
}

void Initsrgb_half_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "srgb_half_unpremult_hgc_visible", "//Metal1.0     \n//LEN=000000035b\n[[ visible ]] FragmentOut srgb_half_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
    "    const float4 c1 = float4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3ACB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3ACE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3ACE0);
}

void Initsrgb_nice_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "srgb_nice_unpremult_hgc_visible", "//Metal1.0     \n//LEN=000000035b\n[[ visible ]] FragmentOut srgb_nice_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
    "    const float4 c1 = float4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3AEF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3AF20(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3AF18);
}

void Initinv_srgb_fast_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_srgb_fast_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=0000000203\n[[ visible ]] FragmentOut inv_srgb_fast_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.8600000143, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz*c0.zzz;\n"
    "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
    "    r0.xyz = r2.xyz*r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3B128(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3B158(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3B150);
}

void Initinv_srgb_fixed_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_srgb_fixed_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002e1\n[[ visible ]] FragmentOut inv_srgb_fixed_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
    "    const float4 c1 = float4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3B360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3B390(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3B388);
}

void Initinv_srgb_nice_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_srgb_nice_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002e0\n[[ visible ]] FragmentOut inv_srgb_nice_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
    "    const float4 c1 = float4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3B598(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3B5C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3B5C0);
}

void Initinv_srgb_half_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_srgb_half_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000002e0\n[[ visible ]] FragmentOut inv_srgb_half_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
    "    const float4 c1 = float4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r2.xyz = r1.xyz + c0.zzz;\n"
    "    r2.xyz = pow(r2.xyz, c0.www);\n"
    "    r2.xyz = r2.xyz*c1.xxx;\n"
    "    r3.xyz = r1.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz - c1.zzz;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = r2.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3B7D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3B800(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3B7F8);
}

void Initinv_srgb_half_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_srgb_half_unpremult_hgc_visible", "//Metal1.0     \n//LEN=0000000374\n[[ visible ]] FragmentOut inv_srgb_half_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
    "    const float4 c1 = float4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz + c0.www;\n"
    "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
    "    r2.xyz = r2.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3BA08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3BA38(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3BA30);
}

void Initinv_srgb_nice_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_srgb_nice_unpremult_hgc_visible", "//Metal1.0     \n//LEN=0000000374\n[[ visible ]] FragmentOut inv_srgb_nice_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
    "    const float4 c1 = float4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz*r0.xyz;\n"
    "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz + c0.www;\n"
    "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
    "    r2.xyz = r2.xyz*c1.yyy;\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r3.xyz = r1.xyz*c1.zzz;\n"
    "    r1.xyz = r1.xyz - c1.www;\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
    "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3BC40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3BC70(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3BC68);
}

void Initquicktime_fast_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "quicktime_fast_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001b8\n[[ visible ]] FragmentOut quicktime_fast_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r0.xyz = sqrt(r1.xyz);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3BE78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3BEA8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3BEA0);
}

void Initquicktime_fixed_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "quicktime_fixed_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001d6\n[[ visible ]] FragmentOut quicktime_fixed_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r0.xyz = r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3C0B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3C0E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3C0D8);
}

void Initquicktime_nice_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "quicktime_nice_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001d5\n[[ visible ]] FragmentOut quicktime_nice_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r0.xyz = r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3C2E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3C318(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3C310);
}

void Initquicktime_half_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "quicktime_half_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001d5\n[[ visible ]] FragmentOut quicktime_half_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r0.xyz = r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3C520(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3C550(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3C548);
}

void Initquicktime_half_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "quicktime_half_unpremult_hgc_visible", "//Metal1.0     \n//LEN=000000024d\n[[ visible ]] FragmentOut quicktime_half_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
    "    r1.xyz = pow(r1.xyz, c0.www);\n"
    "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3C758(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3C788(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3C780);
}

void Initquicktime_nice_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "quicktime_nice_unpremult_hgc_visible", "//Metal1.0     \n//LEN=000000024d\n[[ visible ]] FragmentOut quicktime_nice_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
    "    r1.xyz = pow(r1.xyz, c0.www);\n"
    "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3C990(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3C9C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3C9B8);
}

void Initinv_quicktime_fast_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_quicktime_fast_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001bd\n[[ visible ]] FragmentOut inv_quicktime_fast_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r0.xyz = r1.xyz*r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3CBC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3CBF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3CBF0);
}

void Initinv_quicktime_fixed_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_quicktime_fixed_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001d9\n[[ visible ]] FragmentOut inv_quicktime_fixed_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r0.xyz = r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3CE00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3CE30(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3CE28);
}

void Initinv_quicktime_nice_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_quicktime_nice_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001d8\n[[ visible ]] FragmentOut inv_quicktime_nice_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r0.xyz = r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3D038(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3D068(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3D060);
}

void Initinv_quicktime_half_sat_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_quicktime_half_sat_unpremult_hgc_visible", "//Metal1.0     \n//LEN=00000001d8\n[[ visible ]] FragmentOut inv_quicktime_half_sat_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r0.xyz = r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3D270(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3D2A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3D298);
}

void Initinv_quicktime_half_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_quicktime_half_unpremult_hgc_visible", "//Metal1.0     \n//LEN=0000000250\n[[ visible ]] FragmentOut inv_quicktime_half_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
    "    r1.xyz = pow(r1.xyz, c0.www);\n"
    "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3D4A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3D4D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3D4D0);
}

void Initinv_quicktime_nice_unpremultProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "inv_quicktime_nice_unpremult_hgc_visible", "//Metal1.0     \n//LEN=0000000250\n[[ visible ]] FragmentOut inv_quicktime_nice_unpremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz*r0.xyz;\n"
    "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
    "    r1.xyz = pow(r1.xyz, c0.www);\n"
    "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B3D6E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B3D710(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B3D708);
}

uint64_t Gettype0_fast_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int8x16_t *v78;
  uint64_t v79;
  int8x16_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 6);
    while (v5 < 4)
    {
      LODWORD(v79) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v7 += v8;
      v6 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 32;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 32);
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v14 = *(float32x4_t *)(v7 + v11);
      v15 = *(float32x4_t *)(v7 + v11 + 16);
      v17 = *((int8x16_t *)a2 + 15);
      v16 = *((float32x4_t *)a2 + 16);
      v18 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v16));
      v19 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v16));
      v20 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v16));
      v21 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16));
      v22 = *((int8x16_t *)a2 + 17);
      v23 = *((float32x4_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(vandq_s8(v22, v18), (int8x16_t)v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v22, v19), (int8x16_t)v23));
      v26 = vmulq_f32(v14, (float32x4_t)vorrq_s8(vandq_s8(v22, v20), (int8x16_t)v23));
      v27 = vmulq_f32(v15, (float32x4_t)vorrq_s8(vandq_s8(v22, v21), (int8x16_t)v23));
      v28 = *((float32x4_t *)a2 + 5);
      v29 = *((float32x4_t *)a2 + 6);
      v30 = vmulq_f32(v29, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v24, v23), v28)));
      v31 = vmulq_f32(v29, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v25, v23), v28)));
      v32 = vmulq_f32(v29, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v26, v23), v28)));
      v33 = vmulq_f32(v29, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v27, v23), v28)));
      v34 = vcvtq_f32_s32(vcvtq_s32_f32(v30));
      v35 = vcvtq_f32_s32(vcvtq_s32_f32(v31));
      v36 = vcvtq_f32_s32(vcvtq_s32_f32(v32));
      v37 = vcvtq_f32_s32(vcvtq_s32_f32(v33));
      v38 = *((float32x4_t *)a2 + 7);
      v39 = *((float32x4_t *)a2 + 8);
      v40 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v30, v34), v38));
      v41 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v31, v35), v38));
      v42 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v32, v36), v38));
      v43 = vrsqrteq_f32(vaddq_f32(v38, vsubq_f32(v33, v37)));
      v44 = vaddq_f32(v39, v34);
      v45 = vaddq_f32(v39, v35);
      v46 = vaddq_f32(v39, v36);
      v47 = vaddq_f32(v39, v37);
      v48 = *((float32x4_t *)a2 + 9);
      v49 = *((float32x4_t *)a2 + 10);
      v50 = vmulq_n_f32(vsubq_f32(v44, vmulq_f32(v40, v48)), COERCE_FLOAT(*(_OWORD *)a2));
      v51 = vmulq_n_f32(vsubq_f32(v45, vmulq_f32(v41, v48)), COERCE_FLOAT(*(_OWORD *)a2));
      v52 = vmulq_n_f32(vsubq_f32(v46, vmulq_f32(v42, v48)), COERCE_FLOAT(*(_OWORD *)a2));
      v53 = vmulq_n_f32(vsubq_f32(v47, vmulq_f32(v43, v48)), COERCE_FLOAT(*(_OWORD *)a2));
      v54 = vcvtq_f32_s32(vcvtq_s32_f32(v50));
      v55 = vcvtq_f32_s32(vcvtq_s32_f32(v51));
      v56 = vcvtq_f32_s32(vcvtq_s32_f32(v52));
      v57 = vcvtq_f32_s32(vcvtq_s32_f32(v53));
      v58 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v54, v50)));
      v59 = vsubq_f32(v55, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v55, v51)));
      v60 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v56, v52)));
      v61 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v57, v53)));
      v62 = *((float32x4_t *)a2 + 11);
      v63 = *((float32x4_t *)a2 + 12);
      v64 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v50, v58))), v63);
      v65 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v51, v59))), v63);
      v66 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v52, v60))), v63);
      v67 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v53, v61))), v63);
      v68 = vmaxq_f32(vaddq_f32(vaddq_f32(v58, v49), vmulq_f32(v64, v64)), v23);
      v69 = vmaxq_f32(vaddq_f32(vaddq_f32(v49, v59), vmulq_f32(v65, v65)), v23);
      v70 = vmaxq_f32(vaddq_f32(vaddq_f32(v49, v60), vmulq_f32(v66, v66)), v23);
      v71 = vmaxq_f32(vaddq_f32(vaddq_f32(v49, v61), vmulq_f32(v67, v67)), v23);
      v72 = *((float32x4_t *)a2 + 13);
      v73 = *((float32x4_t *)a2 + 14);
      v74 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v24, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v68, v72), v73)));
      v75 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v25, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v69, v72), v73)));
      v76 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v26, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v70, v72), v73)));
      v77 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v27, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v71, v72), v73)));
      v78 = (int8x16_t *)(v6 + v11);
      v78[-2] = vbslq_s8(v17, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v74, v74, 3));
      v78[-1] = vbslq_s8(v17, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v75, v75, 3));
      *v78 = vbslq_s8(v17, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v76, v76, 3));
      v78[1] = vbslq_s8(v17, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v77, v77, 3));
      v10 -= 4;
      v11 += 64;
    }
    while (v5 + v10 > 3);
    LODWORD(v79) = -v10;
    if ((int)v79 >= v5)
      goto LABEL_3;
LABEL_10:
    v79 = v79;
    do
    {
      v80 = *((int8x16_t *)a2 + 15);
      v81 = *((float32x4_t *)a2 + 3);
      v82 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v79), (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v7 + 16 * v79), 3), *((float32x4_t *)a2 + 16)))), (int8x16_t)v81));
      v83 = *((float32x4_t *)a2 + 5);
      v84 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v82, v81), v83)));
      v85 = vcvtq_f32_s32(vcvtq_s32_f32(v84));
      v86 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v85), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v84, v85))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
      v87 = vcvtq_f32_s32(vcvtq_s32_f32(v86));
      v88 = vsubq_f32(v87, (float32x4_t)vandq_s8((int8x16_t)v83, (int8x16_t)vcgtq_f32(v87, v86)));
      v89 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v86, v88))), *((float32x4_t *)a2 + 12));
      v90 = (float32x4_t)vbslq_s8(v80, (int8x16_t)v82, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v88), vmulq_f32(v89, v89)), v81), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))));
      *(int8x16_t *)(v6 + 16 * v79++) = vbslq_s8(v80, (int8x16_t)v82, (int8x16_t)vmulq_laneq_f32(v90, v90, 3));
    }
    while (v79 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype0_fixed_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int8x16_t *v83;
  uint64_t v84;
  int8x16_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 6);
    while (v5 < 4)
    {
      LODWORD(v84) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v7 += v8;
      v6 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 32;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 32);
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v14 = *(float32x4_t *)(v7 + v11);
      v15 = *(float32x4_t *)(v7 + v11 + 16);
      v17 = *((int8x16_t *)a2 + 15);
      v16 = *((float32x4_t *)a2 + 16);
      v18 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v16));
      v19 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v16));
      v20 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v16));
      v21 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16));
      v23 = *((int8x16_t *)a2 + 17);
      v22 = *((float32x4_t *)a2 + 18);
      v24 = (int8x16_t)vmulq_f32(v21, v22);
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v18, v22));
      v26 = vandq_s8(v23, (int8x16_t)vmulq_f32(v19, v22));
      v27 = vandq_s8(v23, (int8x16_t)vmulq_f32(v20, v22));
      v28 = *((float32x4_t *)a2 + 3);
      v29 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v25, (int8x16_t)v28));
      v30 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v26, (int8x16_t)v28));
      v31 = vmulq_f32(v14, (float32x4_t)vorrq_s8(v27, (int8x16_t)v28));
      v32 = vmulq_f32(v15, (float32x4_t)vorrq_s8(vandq_s8(v23, v24), (int8x16_t)v28));
      v33 = *((float32x4_t *)a2 + 5);
      v34 = *((float32x4_t *)a2 + 6);
      v35 = vmulq_f32(v34, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v29, v28), v33)));
      v36 = vmulq_f32(v34, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v30, v28), v33)));
      v37 = vmulq_f32(v34, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v31, v28), v33)));
      v38 = vmulq_f32(v34, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v32, v28), v33)));
      v39 = vcvtq_f32_s32(vcvtq_s32_f32(v35));
      v40 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
      v41 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
      v42 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
      v43 = *((float32x4_t *)a2 + 7);
      v44 = *((float32x4_t *)a2 + 8);
      v45 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v35, v39), v43));
      v46 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v36, v40), v43));
      v47 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v37, v41), v43));
      v48 = vrsqrteq_f32(vaddq_f32(v43, vsubq_f32(v38, v42)));
      v49 = vaddq_f32(v44, v39);
      v50 = vaddq_f32(v44, v40);
      v51 = vaddq_f32(v44, v41);
      v52 = vaddq_f32(v44, v42);
      v53 = *((float32x4_t *)a2 + 9);
      v54 = *((float32x4_t *)a2 + 10);
      v55 = vmulq_n_f32(vsubq_f32(v49, vmulq_f32(v45, v53)), COERCE_FLOAT(*(_OWORD *)a2));
      v56 = vmulq_n_f32(vsubq_f32(v50, vmulq_f32(v46, v53)), COERCE_FLOAT(*(_OWORD *)a2));
      v57 = vmulq_n_f32(vsubq_f32(v51, vmulq_f32(v47, v53)), COERCE_FLOAT(*(_OWORD *)a2));
      v58 = vmulq_n_f32(vsubq_f32(v52, vmulq_f32(v48, v53)), COERCE_FLOAT(*(_OWORD *)a2));
      v59 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      v60 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
      v61 = vcvtq_f32_s32(vcvtq_s32_f32(v57));
      v62 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v63 = vsubq_f32(v59, (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v59, v55)));
      v64 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v60, v56)));
      v65 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v61, v57)));
      v66 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v62, v58)));
      v67 = *((float32x4_t *)a2 + 11);
      v68 = *((float32x4_t *)a2 + 12);
      v69 = vmulq_f32(vrecpeq_f32(vsubq_f32(v67, vsubq_f32(v55, v63))), v68);
      v70 = vmulq_f32(vrecpeq_f32(vsubq_f32(v67, vsubq_f32(v56, v64))), v68);
      v71 = vmulq_f32(vrecpeq_f32(vsubq_f32(v67, vsubq_f32(v57, v65))), v68);
      v72 = vmulq_f32(vrecpeq_f32(vsubq_f32(v67, vsubq_f32(v58, v66))), v68);
      v73 = vmaxq_f32(vaddq_f32(vaddq_f32(v63, v54), vmulq_f32(v69, v69)), v28);
      v74 = vmaxq_f32(vaddq_f32(vaddq_f32(v54, v64), vmulq_f32(v70, v70)), v28);
      v75 = vmaxq_f32(vaddq_f32(vaddq_f32(v54, v65), vmulq_f32(v71, v71)), v28);
      v76 = vmaxq_f32(vaddq_f32(vaddq_f32(v54, v66), vmulq_f32(v72, v72)), v28);
      v77 = *((float32x4_t *)a2 + 13);
      v78 = *((float32x4_t *)a2 + 14);
      v79 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v29, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v73, v77), v78)));
      v80 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v30, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v74, v77), v78)));
      v81 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v31, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v75, v77), v78)));
      v82 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v32, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v76, v77), v78)));
      v83 = (int8x16_t *)(v6 + v11);
      v83[-2] = vbslq_s8(v17, (int8x16_t)v29, (int8x16_t)vmulq_laneq_f32(v79, v79, 3));
      v83[-1] = vbslq_s8(v17, (int8x16_t)v30, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      *v83 = vbslq_s8(v17, (int8x16_t)v31, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      v83[1] = vbslq_s8(v17, (int8x16_t)v32, (int8x16_t)vmulq_laneq_f32(v82, v82, 3));
      v10 -= 4;
      v11 += 64;
    }
    while (v5 + v10 > 3);
    LODWORD(v84) = -v10;
    if ((int)v84 >= v5)
      goto LABEL_3;
LABEL_10:
    v84 = v84;
    do
    {
      v85 = *((int8x16_t *)a2 + 15);
      v86 = *((float32x4_t *)a2 + 3);
      v87 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v84), (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v7 + 16 * v84), 3), *((float32x4_t *)a2 + 16))), *((float32x4_t *)a2 + 18))), (int8x16_t)v86));
      v88 = *((float32x4_t *)a2 + 5);
      v89 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v87, v86), v88)));
      v90 = vcvtq_f32_s32(vcvtq_s32_f32(v89));
      v91 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v90), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v89, v90))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
      v92 = vcvtq_f32_s32(vcvtq_s32_f32(v91));
      v93 = vsubq_f32(v92, (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v92, v91)));
      v94 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v91, v93))), *((float32x4_t *)a2 + 12));
      v95 = (float32x4_t)vbslq_s8(v85, (int8x16_t)v87, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v93), vmulq_f32(v94, v94)), v86), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))));
      *(int8x16_t *)(v6 + 16 * v84++) = vbslq_s8(v85, (int8x16_t)v87, (int8x16_t)vmulq_laneq_f32(v95, v95, 3));
    }
    while (v84 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype0_nice_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  int32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int8x16_t *v87;
  int v88;
  uint64_t v89;
  float32x4_t v90;
  int8x16_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v88 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17));
      v24 = *((int8x16_t *)a2 + 17);
      v25 = *((float32x4_t *)a2 + 3);
      v26 = vmulq_f32(v12, (float32x4_t)vorrq_s8(vandq_s8(v24, v22), (int8x16_t)v25));
      v27 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v24, v23), (int8x16_t)v25));
      v28 = *((float32x4_t *)a2 + 5);
      v29 = (int8x16_t)vminq_f32(vmaxq_f32(v26, v25), v28);
      v30 = (int8x16_t)vminq_f32(vmaxq_f32(v27, v25), v28);
      v31 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v25)), v25);
      v32 = (float32x4_t)vbslq_s8(v31, (int8x16_t)v28, v29);
      v33 = (float32x4_t)vbslq_s8(v31, (int8x16_t)v28, v30);
      v35 = *((int8x16_t *)a2 + 19);
      v34 = *((float32x4_t *)a2 + 20);
      v36 = (float32x4_t)vorrq_s8(vandq_s8(v35, (int8x16_t)v32), (int8x16_t)v28);
      v37 = (float32x4_t)vorrq_s8(vandq_s8(v35, (int8x16_t)v33), (int8x16_t)v28);
      v38 = *((int8x16_t *)a2 + 21);
      v39 = *((float32x4_t *)a2 + 22);
      v40 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v33, 0x17uLL)), (float32x4_t)vandq_s8(v38, (int8x16_t)vcgtq_f32(v34, v33)));
      v41 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v32, 0x17uLL)), (float32x4_t)vandq_s8(v38, (int8x16_t)vcgtq_f32(v34, v32))), v39);
      v42 = *((float32x4_t *)a2 + 23);
      v43 = *((float32x4_t *)a2 + 24);
      v44 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v36, v42));
      v45 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v37, v42));
      v46 = vaddq_f32(v41, v44);
      v47 = vaddq_f32(vsubq_f32(v40, v39), v45);
      v48 = vsubq_f32(vsubq_f32(v36, v28), vmulq_f32(vmulq_f32(v43, v44), v36));
      v49 = vsubq_f32(vsubq_f32(v37, v28), vmulq_f32(vmulq_f32(v43, v45), v37));
      v50 = vmulq_f32(v48, v48);
      v51 = *((float32x4_t *)a2 + 37);
      v52 = *((float32x4_t *)a2 + 38);
      v53 = *((float32x4_t *)a2 + 39);
      v54 = *((float32x4_t *)a2 + 40);
      v55 = vaddq_f32(v51, vmulq_f32(v52, v48));
      v56 = vaddq_f32(v53, vmulq_f32(v54, v48));
      v57 = vaddq_f32(v53, vmulq_f32(v54, v49));
      v58 = vaddq_f32(v51, vmulq_f32(v52, v49));
      v59 = *((float32x4_t *)a2 + 41);
      v60 = *((float32x4_t *)a2 + 42);
      v61 = vaddq_f32(v59, vmulq_f32(v60, v48));
      v62 = vaddq_f32(v59, vmulq_f32(v60, v49));
      v63 = vmulq_f32(v49, v49);
      v64 = vaddq_f32(v61, vmulq_f32(v50, vaddq_f32(v55, vmulq_f32(v50, v56))));
      v65 = vaddq_f32(v62, vmulq_f32(v63, vaddq_f32(v58, vmulq_f32(v63, v57))));
      v66 = *((float32x4_t *)a2 + 43);
      v67 = *((float32x4_t *)a2 + 44);
      v68 = vmulq_n_f32(vaddq_f32(v47, vmulq_f32(v49, vaddq_f32(v66, vmulq_f32(v49, v65)))), COERCE_FLOAT(*(_OWORD *)a2));
      v69 = *((float32x4_t *)a2 + 29);
      v70 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v46, vmulq_f32(v48, vaddq_f32(v66, vmulq_f32(v48, v64)))), COERCE_FLOAT(*(_OWORD *)a2)), v69);
      v71 = vmaxq_f32(v68, v69);
      v72 = vcvtq_f32_s32(vcvtq_s32_f32(v70));
      v73 = vcvtq_f32_s32(vcvtq_s32_f32(v71));
      v74 = vsubq_f32(v72, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v72, v70)));
      v75 = vsubq_f32(v73, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v73, v71)));
      v76 = vsubq_f32(v70, v74);
      v77 = vsubq_f32(v71, v75);
      v78 = *((float32x4_t *)a2 + 45);
      v79 = *((float32x4_t *)a2 + 46);
      v80 = vaddq_f32(v67, vmulq_f32(v78, v76));
      v81 = vaddq_f32(v67, vmulq_f32(v78, v77));
      v82 = *((float32x4_t *)a2 + 47);
      v83 = *((float32x4_t *)a2 + 48);
      v84 = *((int32x4_t *)a2 + 33);
      v85 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v26, (int8x16_t)vmulq_f32(vaddq_f32(v28, vmulq_f32(v76, vaddq_f32(v83, vmulq_f32(v76, vaddq_f32(vaddq_f32(v79, vmulq_f32(v76, v82)), vmulq_f32(vmulq_f32(v76, v76), v80)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v84, vcvtq_s32_f32(v74)), 0x17uLL)));
      v86 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_f32(vaddq_f32(v28, vmulq_f32(v77, vaddq_f32(v83, vmulq_f32(v77, vaddq_f32(vaddq_f32(v79, vmulq_f32(v82, v77)), vmulq_f32(vmulq_f32(v77, v77), v81)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v84, vcvtq_s32_f32(v75)), 0x17uLL)));
      v87 = (int8x16_t *)(v6 + v11);
      v87[-1] = vbslq_s8(v15, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v85, v85, 3));
      *v87 = vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v86, v86, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v88 = -v10;
    if (v88 >= v5)
      goto LABEL_3;
LABEL_10:
    v89 = 16 * v88;
    v90 = *(float32x4_t *)(v7 + v89);
    v91 = *((int8x16_t *)a2 + 15);
    v92 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v90, 3), *((float32x4_t *)a2 + 16));
    v93 = vrecpeq_f32(v92);
    v94 = vmulq_f32(v93, vrecpsq_f32(v93, v92));
    v95 = vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v94, vrecpsq_f32(v94, v92)));
    v96 = *((float32x4_t *)a2 + 3);
    v97 = vmulq_f32(v90, (float32x4_t)vorrq_s8(v95, (int8x16_t)v96));
    v98 = *((float32x4_t *)a2 + 5);
    v99 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v98, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v96)), v96), (int8x16_t)v98, (int8x16_t)vminq_f32(vmaxq_f32(v97, v96), v98));
    v100 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v99), (int8x16_t)v98);
    v101 = (float32x4_t)vandq_s8((int8x16_t)v98, (int8x16_t)vcgtq_f32(v100, *((float32x4_t *)a2 + 23)));
    v102 = vsubq_f32(vsubq_f32(v100, v98), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v101), v100));
    v103 = vmulq_f32(v102, v102);
    v104 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v99, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v99))), *((float32x4_t *)a2 + 22)), v101), vmulq_f32(v102, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v102, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v102)),
                         vmulq_f32(v103, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v102)), vmulq_f32(v103, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v102)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
    v105 = vcvtq_f32_s32(vcvtq_s32_f32(v104));
    v106 = vsubq_f32(v105, (float32x4_t)vandq_s8((int8x16_t)v98, (int8x16_t)vcgtq_f32(v105, v104)));
    v107 = vsubq_f32(v104, v106);
    v108 = (float32x4_t)vbslq_s8(v91, (int8x16_t)v97, (int8x16_t)vmulq_f32(vaddq_f32(v98, vmulq_f32(v107, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v107, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v107)), vmulq_f32(vmulq_f32(v107, v107), vaddq_f32(*((float32x4_t *)a2 + 44),
                                                     vmulq_f32(*((float32x4_t *)a2 + 45), v107)))))))),
                                       (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v106)), 0x17uLL)));
    *(int8x16_t *)(v6 + v89) = vbslq_s8(v91, (int8x16_t)v97, (int8x16_t)vmulq_laneq_f32(v108, v108, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype0_half_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  int32x4_t v68;
  int32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  int8x16_t *v72;
  int v73;
  uint64_t v74;
  float32x4_t v75;
  int8x16_t v76;
  float32x4_t v77;
  float32x4_t v78;
  int8x16_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v73 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((float32x4_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, (int8x16_t)v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), (int8x16_t)v23));
      v26 = vmaxq_f32(v24, v23);
      v27 = vmaxq_f32(v25, v23);
      v28 = *((float32x4_t *)a2 + 5);
      v29 = vminq_f32(v26, v28);
      v30 = vminq_f32(v27, v28);
      v31 = *((int8x16_t *)a2 + 19);
      v32 = *((float32x4_t *)a2 + 20);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v31, (int8x16_t)v29), (int8x16_t)v28);
      v34 = (float32x4_t)vorrq_s8(vandq_s8(v31, (int8x16_t)v30), (int8x16_t)v28);
      v35 = *((int8x16_t *)a2 + 21);
      v36 = *((float32x4_t *)a2 + 22);
      v37 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v32, v30)));
      v38 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v32, v29))), v36);
      v39 = *((float32x4_t *)a2 + 23);
      v40 = *((float32x4_t *)a2 + 24);
      v41 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v33, v39));
      v42 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v34, v39));
      v43 = vaddq_f32(v38, v41);
      v44 = vaddq_f32(vsubq_f32(v37, v36), v42);
      v45 = vsubq_f32(vsubq_f32(v33, v28), vmulq_f32(vmulq_f32(v40, v41), v33));
      v46 = vsubq_f32(vsubq_f32(v34, v28), vmulq_f32(vmulq_f32(v40, v42), v34));
      v47 = *((float32x4_t *)a2 + 25);
      v48 = *((float32x4_t *)a2 + 26);
      v49 = vaddq_f32(v47, vmulq_f32(v48, v45));
      v50 = vaddq_f32(v47, vmulq_f32(v48, v46));
      v51 = *((float32x4_t *)a2 + 27);
      v52 = *((float32x4_t *)a2 + 28);
      v53 = vmulq_n_f32(vaddq_f32(v44, vmulq_f32(v46, vaddq_f32(vaddq_f32(v51, vmulq_f32(v46, v52)), vmulq_f32(vmulq_f32(v46, v46), v50)))), COERCE_FLOAT(*(_OWORD *)a2));
      v54 = *((float32x4_t *)a2 + 29);
      v55 = *((float32x4_t *)a2 + 30);
      v56 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v43, vmulq_f32(v45, vaddq_f32(vaddq_f32(v51, vmulq_f32(v45, v52)), vmulq_f32(vmulq_f32(v45, v45), v49)))), COERCE_FLOAT(*(_OWORD *)a2)), v54);
      v57 = vmaxq_f32(v53, v54);
      v58 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
      v59 = vcvtq_f32_s32(vcvtq_s32_f32(v57));
      v60 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v58, v56)));
      v61 = vsubq_f32(v59, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v59, v57)));
      v62 = vsubq_f32(v56, v60);
      v63 = vsubq_f32(v57, v61);
      v64 = *((float32x4_t *)a2 + 31);
      v65 = *((float32x4_t *)a2 + 32);
      v66 = vmulq_f32(v63, vaddq_f32(v65, vmulq_f32(v63, vaddq_f32(v55, vmulq_f32(v64, v63)))));
      v67 = vaddq_f32(v28, vmulq_f32(v62, vaddq_f32(v65, vmulq_f32(v62, vaddq_f32(v55, vmulq_f32(v64, v62))))));
      v68 = vcvtq_s32_f32(v61);
      v69 = *((int32x4_t *)a2 + 33);
      v70 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_f32(v67, (float32x4_t)vshlq_n_s32(vaddq_s32(v69, vcvtq_s32_f32(v60)), 0x17uLL)));
      v71 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vmulq_f32(vaddq_f32(v28, v66), (float32x4_t)vshlq_n_s32(vaddq_s32(v69, v68), 0x17uLL)));
      v72 = (int8x16_t *)(v6 + v11);
      v72[-1] = vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v70, v70, 3));
      *v72 = vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v71, v71, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v73 = -v10;
    if (v73 >= v5)
      goto LABEL_3;
LABEL_10:
    v74 = 16 * v73;
    v75 = *(float32x4_t *)(v7 + v74);
    v76 = *((int8x16_t *)a2 + 15);
    v77 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v75, 3), *((float32x4_t *)a2 + 16));
    v78 = vmulq_f32(vrecpeq_f32(v77), *((float32x4_t *)a2 + 18));
    v79 = vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v78, vrecpsq_f32(v78, v77)));
    v80 = *((float32x4_t *)a2 + 3);
    v81 = vmulq_f32(v75, (float32x4_t)vorrq_s8(v79, (int8x16_t)v80));
    v82 = vmaxq_f32(v81, v80);
    v83 = *((float32x4_t *)a2 + 5);
    v84 = vminq_f32(v82, v83);
    v85 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v84), (int8x16_t)v83);
    v86 = (float32x4_t)vandq_s8((int8x16_t)v83, (int8x16_t)vcgtq_f32(v85, *((float32x4_t *)a2 + 23)));
    v87 = vsubq_f32(vsubq_f32(v85, v83), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v86), v85));
    v88 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v84, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v84))), *((float32x4_t *)a2 + 22)), v86), vmulq_f32(v87, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v87, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v87, v87), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v87)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v89 = vcvtq_f32_s32(vcvtq_s32_f32(v88));
    v90 = vsubq_f32(v89, (float32x4_t)vandq_s8((int8x16_t)v83, (int8x16_t)vcgtq_f32(v89, v88)));
    v91 = vsubq_f32(v88, v90);
    v92 = (float32x4_t)vbslq_s8(v76, (int8x16_t)v81, (int8x16_t)vmulq_f32(vaddq_f32(v83, vmulq_f32(v91, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v91, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v91)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v90)), 0x17uLL)));
    *(int8x16_t *)(v6 + v74) = vbslq_s8(v76, (int8x16_t)v81, (int8x16_t)vmulq_laneq_f32(v92, v92, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype0_halfTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  int32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  int8x16_t *v70;
  int v71;
  uint64_t v72;
  float32x4_t v73;
  int8x16_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int8x16_t v77;
  float32x4_t v78;
  float32x4_t v79;
  int8x16_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v71 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((float32x4_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, (int8x16_t)v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), (int8x16_t)v23));
      v26 = *((float32x4_t *)a2 + 5);
      v28 = *((int32x4_t *)a2 + 33);
      v27 = *((int8x16_t *)a2 + 34);
      v29 = vmulq_f32(v24, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v23, v24), v27, (int8x16_t)v26));
      v30 = vmulq_f32(v25, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v23, v25), v27, (int8x16_t)v26));
      v31 = *((float32x4_t *)a2 + 35);
      v32 = *((int8x16_t *)a2 + 36);
      v33 = vminq_f32(v29, v31);
      v34 = vminq_f32(v30, v31);
      v35 = *((int8x16_t *)a2 + 19);
      v36 = *((float32x4_t *)a2 + 20);
      v37 = (float32x4_t)vorrq_s8(vandq_s8(v35, (int8x16_t)v33), (int8x16_t)v26);
      v38 = (float32x4_t)vorrq_s8(vandq_s8(v35, (int8x16_t)v34), (int8x16_t)v26);
      v39 = *((int8x16_t *)a2 + 21);
      v40 = *((float32x4_t *)a2 + 22);
      v41 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v33, 0x17uLL)), (float32x4_t)vandq_s8(v39, (int8x16_t)vcgtq_f32(v36, v33)));
      v42 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v34, 0x17uLL)), (float32x4_t)vandq_s8(v39, (int8x16_t)vcgtq_f32(v36, v34)));
      v43 = *((float32x4_t *)a2 + 23);
      v44 = *((float32x4_t *)a2 + 24);
      v45 = (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v37, v43));
      v46 = (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v38, v43));
      v47 = vsubq_f32(v42, v40);
      v48 = vaddq_f32(vsubq_f32(v41, v40), v45);
      v49 = vsubq_f32(vsubq_f32(v37, v26), vmulq_f32(vmulq_f32(v44, v45), v37));
      v50 = vsubq_f32(vsubq_f32(v38, v26), vmulq_f32(vmulq_f32(v44, v46), v38));
      v51 = *((float32x4_t *)a2 + 25);
      v52 = *((float32x4_t *)a2 + 26);
      v53 = *((float32x4_t *)a2 + 27);
      v54 = *((float32x4_t *)a2 + 28);
      v55 = vmulq_n_f32(vaddq_f32(vaddq_f32(v47, v46), vmulq_f32(v50, vaddq_f32(vaddq_f32(v53, vmulq_f32(v50, v54)), vmulq_f32(vmulq_f32(v50, v50), vaddq_f32(v51, vmulq_f32(v52, v50)))))), COERCE_FLOAT(*(_OWORD *)a2));
      v57 = *((float32x4_t *)a2 + 29);
      v56 = *((float32x4_t *)a2 + 30);
      v58 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v48, vmulq_f32(v49, vaddq_f32(vaddq_f32(v53, vmulq_f32(v49, v54)), vmulq_f32(vmulq_f32(v49, v49), vaddq_f32(v51, vmulq_f32(v52, v49)))))), COERCE_FLOAT(*(_OWORD *)a2)), v57);
      v59 = vmaxq_f32(v55, v57);
      v60 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v61 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v62 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v60, v58)));
      v63 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v61, v59)));
      v64 = vsubq_f32(v58, v62);
      v65 = vsubq_f32(v59, v63);
      v66 = *((float32x4_t *)a2 + 31);
      v67 = *((float32x4_t *)a2 + 32);
      v68 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v24, veorq_s8(vandq_s8(v32, (int8x16_t)v24), (int8x16_t)vmulq_f32(vaddq_f32(v26, vmulq_f32(v64, vaddq_f32(v67, vmulq_f32(v64, vaddq_f32(v56, vmulq_f32(v66, v64)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v28, vcvtq_s32_f32(v62)), 0x17uLL))));
      v69 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v25, veorq_s8(vandq_s8(v32, (int8x16_t)v25), (int8x16_t)vmulq_f32(vaddq_f32(v26, vmulq_f32(v65, vaddq_f32(v67, vmulq_f32(v65, vaddq_f32(v56, vmulq_f32(v66, v65)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v28, vcvtq_s32_f32(v63)), 0x17uLL))));
      v70 = (int8x16_t *)(v6 + v11);
      v70[-1] = vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v68, v68, 3));
      *v70 = vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v69, v69, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v71 = -v10;
    if (v71 >= v5)
      goto LABEL_3;
LABEL_10:
    v72 = 16 * v71;
    v73 = *(float32x4_t *)(v7 + v72);
    v74 = *((int8x16_t *)a2 + 15);
    v75 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v73, 3), *((float32x4_t *)a2 + 16));
    v76 = vmulq_f32(vrecpeq_f32(v75), *((float32x4_t *)a2 + 18));
    v77 = vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v76, vrecpsq_f32(v76, v75)));
    v78 = *((float32x4_t *)a2 + 3);
    v79 = vmulq_f32(v73, (float32x4_t)vorrq_s8(v77, (int8x16_t)v78));
    v80 = (int8x16_t)vcgtq_f32(v78, v79);
    v81 = *((float32x4_t *)a2 + 5);
    v82 = vminq_f32(vmulq_f32(v79, (float32x4_t)vbslq_s8(v80, *((int8x16_t *)a2 + 34), (int8x16_t)v81)), *((float32x4_t *)a2 + 35));
    v83 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v82), (int8x16_t)v81);
    v84 = (float32x4_t)vandq_s8((int8x16_t)v81, (int8x16_t)vcgtq_f32(v83, *((float32x4_t *)a2 + 23)));
    v85 = vsubq_f32(vsubq_f32(v83, v81), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v84), v83));
    v86 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v82, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v82))), *((float32x4_t *)a2 + 22)), v84), vmulq_f32(v85, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v85, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v85, v85), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v85)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v87 = vcvtq_f32_s32(vcvtq_s32_f32(v86));
    v88 = vsubq_f32(v87, (float32x4_t)vandq_s8((int8x16_t)v81, (int8x16_t)vcgtq_f32(v87, v86)));
    v89 = vsubq_f32(v86, v88);
    v90 = (float32x4_t)vbslq_s8(v74, (int8x16_t)v79, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v79), (int8x16_t)vmulq_f32(vaddq_f32(v81, vmulq_f32(v89, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v89, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v89)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v88)), 0x17uLL))));
    *(int8x16_t *)(v6 + v72) = vbslq_s8(v74, (int8x16_t)v79, (int8x16_t)vmulq_laneq_f32(v90, v90, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype0_niceTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  int8x16_t v32;
  float32x4_t v33;
  int8x16_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int32x4_t v87;
  int8x16_t v88;
  float32x4_t v89;
  float32x4_t v90;
  int8x16_t *v91;
  int v92;
  uint64_t v93;
  float32x4_t v94;
  int8x16_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  int8x16_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v92 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = *((int8x16_t *)a2 + 17);
      v24 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v25 = *((float32x4_t *)a2 + 3);
      v26 = vmulq_f32(v12, (float32x4_t)vorrq_s8(vandq_s8(v23, v22), (int8x16_t)v25));
      v27 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v24, (int8x16_t)v25));
      v28 = *((float32x4_t *)a2 + 5);
      v29 = *((int32x4_t *)a2 + 33);
      v30 = *((int8x16_t *)a2 + 34);
      v31 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v25, v27), v30, (int8x16_t)v28);
      v33 = *((float32x4_t *)a2 + 35);
      v32 = *((int8x16_t *)a2 + 36);
      v34 = (int8x16_t)vminq_f32(vmulq_f32(v26, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v25, v26), v30, (int8x16_t)v28)), v33);
      v35 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v25)), v25);
      v36 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v28, v34);
      v37 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v28, (int8x16_t)vminq_f32(vmulq_f32(v27, v31), v33));
      v38 = *((int8x16_t *)a2 + 19);
      v39 = *((float32x4_t *)a2 + 20);
      v40 = (float32x4_t)vorrq_s8(vandq_s8(v38, (int8x16_t)v36), (int8x16_t)v28);
      v41 = *((int8x16_t *)a2 + 21);
      v42 = *((float32x4_t *)a2 + 22);
      v43 = (float32x4_t)vorrq_s8(vandq_s8(v38, (int8x16_t)v37), (int8x16_t)v28);
      v44 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x17uLL)), (float32x4_t)vandq_s8(v41, (int8x16_t)vcgtq_f32(v39, v37)));
      v45 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v36, 0x17uLL)), (float32x4_t)vandq_s8(v41, (int8x16_t)vcgtq_f32(v39, v36))), v42);
      v46 = *((float32x4_t *)a2 + 23);
      v47 = *((float32x4_t *)a2 + 24);
      v48 = vsubq_f32(v44, v42);
      v49 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v40, v46));
      v50 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v43, v46));
      v51 = vaddq_f32(v45, v49);
      v52 = vsubq_f32(vsubq_f32(v40, v28), vmulq_f32(vmulq_f32(v47, v49), v40));
      v53 = vsubq_f32(vsubq_f32(v43, v28), vmulq_f32(vmulq_f32(v47, v50), v43));
      v54 = vmulq_f32(v52, v52);
      v55 = *((float32x4_t *)a2 + 37);
      v56 = *((float32x4_t *)a2 + 38);
      v57 = vaddq_f32(v55, vmulq_f32(v56, v52));
      v58 = vaddq_f32(v55, vmulq_f32(v56, v53));
      v59 = *((float32x4_t *)a2 + 39);
      v60 = *((float32x4_t *)a2 + 40);
      v61 = vaddq_f32(v59, vmulq_f32(v60, v52));
      v62 = vaddq_f32(v59, vmulq_f32(v60, v53));
      v63 = *((float32x4_t *)a2 + 41);
      v64 = *((float32x4_t *)a2 + 42);
      v65 = vaddq_f32(v63, vmulq_f32(v64, v52));
      v66 = vaddq_f32(v63, vmulq_f32(v64, v53));
      v67 = vmulq_f32(v53, v53);
      v68 = vaddq_f32(v66, vmulq_f32(v67, vaddq_f32(v58, vmulq_f32(v67, v62))));
      v69 = vmulq_f32(v52, vaddq_f32(v65, vmulq_f32(v54, vaddq_f32(v57, vmulq_f32(v54, v61)))));
      v70 = *((float32x4_t *)a2 + 43);
      v71 = *((float32x4_t *)a2 + 44);
      v72 = vaddq_f32(vaddq_f32(v48, v50), vmulq_f32(v53, vaddq_f32(v70, vmulq_f32(v53, v68))));
      v73 = vmulq_n_f32(vaddq_f32(v51, vmulq_f32(v52, vaddq_f32(v70, v69))), COERCE_FLOAT(*(_OWORD *)a2));
      v74 = *((float32x4_t *)a2 + 29);
      v75 = vmaxq_f32(v73, v74);
      v76 = vmaxq_f32(vmulq_n_f32(v72, COERCE_FLOAT(*(_OWORD *)a2)), v74);
      v77 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v76));
      v79 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v77, v75)));
      v80 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v78, v76)));
      v81 = vsubq_f32(v75, v79);
      v82 = vsubq_f32(v76, v80);
      v83 = *((float32x4_t *)a2 + 45);
      v84 = *((float32x4_t *)a2 + 46);
      v85 = *((float32x4_t *)a2 + 47);
      v86 = *((float32x4_t *)a2 + 48);
      v87 = vaddq_s32(v29, vcvtq_s32_f32(v79));
      v88 = (int8x16_t)vmulq_f32(vaddq_f32(v28, vmulq_f32(v82, vaddq_f32(v86, vmulq_f32(v82, vaddq_f32(vaddq_f32(v84, vmulq_f32(v85, v82)), vmulq_f32(vmulq_f32(v82, v82), vaddq_f32(v71, vmulq_f32(v83, v82)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v29, vcvtq_s32_f32(v80)), 0x17uLL));
      v89 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v26, veorq_s8(vandq_s8(v32, (int8x16_t)v26), (int8x16_t)vmulq_f32(vaddq_f32(v28, vmulq_f32(v81, vaddq_f32(v86, vmulq_f32(v81, vaddq_f32(vaddq_f32(v84, vmulq_f32(v81, v85)), vmulq_f32(vmulq_f32(v81, v81), vaddq_f32(v71, vmulq_f32(v83, v81)))))))), (float32x4_t)vshlq_n_s32(v87, 0x17uLL))));
      v90 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, veorq_s8(vandq_s8(v32, (int8x16_t)v27), v88));
      v91 = (int8x16_t *)(v6 + v11);
      v91[-1] = vbslq_s8(v15, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v89, v89, 3));
      *v91 = vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v90, v90, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v92 = -v10;
    if (v92 >= v5)
      goto LABEL_3;
LABEL_10:
    v93 = 16 * v92;
    v94 = *(float32x4_t *)(v7 + v93);
    v95 = *((int8x16_t *)a2 + 15);
    v96 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 3), *((float32x4_t *)a2 + 16));
    v97 = vrecpeq_f32(v96);
    v98 = vmulq_f32(v97, vrecpsq_f32(v97, v96));
    v99 = vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v98, vrecpsq_f32(v98, v96)));
    v100 = *((float32x4_t *)a2 + 3);
    v101 = vmulq_f32(v94, (float32x4_t)vorrq_s8(v99, (int8x16_t)v100));
    v102 = *((float32x4_t *)a2 + 5);
    v103 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v102, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v100)), v100), (int8x16_t)v102, (int8x16_t)vminq_f32(vmulq_f32(v101, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v100, v101), *((int8x16_t *)a2 + 34), (int8x16_t)v102)), *((float32x4_t *)a2 + 35)));
    v104 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v103), (int8x16_t)v102);
    v105 = (float32x4_t)vandq_s8((int8x16_t)v102, (int8x16_t)vcgtq_f32(v104, *((float32x4_t *)a2 + 23)));
    v106 = vsubq_f32(vsubq_f32(v104, v102), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v105), v104));
    v107 = vmulq_f32(v106, v106);
    v108 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v103, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v103))), *((float32x4_t *)a2 + 22)), v105), vmulq_f32(v106, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v106, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v106)),
                         vmulq_f32(v107, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v106)), vmulq_f32(v107, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v106)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
    v109 = vcvtq_f32_s32(vcvtq_s32_f32(v108));
    v110 = vsubq_f32(v109, (float32x4_t)vandq_s8((int8x16_t)v102, (int8x16_t)vcgtq_f32(v109, v108)));
    v111 = vsubq_f32(v108, v110);
    v112 = (float32x4_t)vbslq_s8(v95, (int8x16_t)v101, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v101), (int8x16_t)vmulq_f32(vaddq_f32(v102, vmulq_f32(v111, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v111, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v111)), vmulq_f32(vmulq_f32(v111, v111),
                                                     vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v111)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v110)), 0x17uLL))));
    *(int8x16_t *)(v6 + v93) = vbslq_s8(v95, (int8x16_t)v101, (int8x16_t)vmulq_laneq_f32(v112, v112, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype0_floatTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  int8x16_t v39;
  int8x16_t v40;
  float32x4_t v41;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 2);
    v7 = 16 * *((int *)a1 + 22);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((float32x4_t *)a2 + 71);
        v13 = *((float32x4_t *)a2 + 72);
        v14 = *((float32x4_t *)a2 + 73);
        v15 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v11, v12), 3), v13), v14);
        v16 = vminq_f32(vmaxq_f32(vrecpeq_f32(v15), v13), v14);
        v17 = vminq_f32(vmaxq_f32(vmulq_f32(v16, vrecpsq_f32(v15, v16)), v13), v14);
        v18 = vmulq_f32(v17, vrecpsq_f32(v15, v17));
        v18.i32[3] = 1.0;
        v19 = vmulq_f32(v11, v18);
        v20 = *((float32x4_t *)a2 + 50);
        v21 = *((float32x4_t *)a2 + 5);
        v22 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v20)), v20), (int8x16_t)v21, (int8x16_t)vminq_f32(vmulq_f32(v19, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v20, v19), *((int8x16_t *)a2 + 34), (int8x16_t)v21)), *((float32x4_t *)a2 + 35)));
        v23 = *((int8x16_t *)a2 + 52);
        v24 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v22);
        v25 = (int8x16_t)vmulq_f32(v22, vaddq_f32(v21, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 49), v24)));
        v26 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), v25), (int8x16_t)v21);
        v27 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v22, *((float32x4_t *)a2 + 21))), vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v22, v20), *((int8x16_t *)a2 + 51)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v22, v20))), (float32x4_t)vandq_s8(v23, v24))), *((float32x4_t *)a2 + 22)), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v25, 0x17uLL)));
        v28 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v26, *((float32x4_t *)a2 + 23)));
        v29 = vaddq_f32(v27, v28);
        v30 = vsubq_f32(vsubq_f32(v26, v21), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v28), v26));
        v31 = vmulq_f32(v30, v30);
        v32 = vmulq_n_f32(vaddq_f32(v29, vmulq_f32(v30, vaddq_f32(*((float32x4_t *)a2 + 61), vmulq_f32(v30, vaddq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 59), vmulq_f32(*((float32x4_t *)a2 + 60), v30)), vmulq_f32(v31, vaddq_f32(*((float32x4_t *)a2 + 57), vmulq_f32(*((float32x4_t *)a2 + 58), v30)))), vmulq_f32(vmulq_f32(v31, v31), vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 55), vmulq_f32(*((float32x4_t *)a2 + 56), v30)), vmulq_f32(
                                v31,
                                vaddq_f32(*((float32x4_t *)a2 + 53), vmulq_f32(*((float32x4_t *)a2 + 54), v30)))))))))),
                COERCE_FLOAT(*(_OWORD *)a2));
        v33 = vminq_f32(vmaxq_f32(v32, *((float32x4_t *)a2 + 62)), *((float32x4_t *)a2 + 63));
        v34 = vcvtq_f32_s32(vcvtq_s32_f32(v33));
        v35 = vsubq_f32(v34, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v34, v33)));
        v36 = vsubq_f32(v33, v35);
        v37 = vmulq_f32(v36, v36);
        v38 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 70), v35);
        v39 = veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v19), vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, vorrq_s8((int8x16_t)vcltzq_f32(v32), (int8x16_t)vcgezq_f32(v32))), v20), (int8x16_t)vmulq_f32(vaddq_f32(v21, (float32x4_t)vandq_s8(v38, (int8x16_t)v12)), vmulq_f32(vaddq_f32(v21, vmulq_f32(v36, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 68), vmulq_f32(v36, *((float32x4_t *)a2 + 69))), vmulq_f32(v37, vaddq_f32(
                                           vaddq_f32(*((float32x4_t *)a2 + 66), vmulq_f32(*((float32x4_t *)a2 + 67), v36)), vmulq_f32(v37, vaddq_f32(*((float32x4_t *)a2 + 64), vmulq_f32(*((float32x4_t *)a2 + 65), v36)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(vaddq_f32(v35, (float32x4_t)vandq_s8(v23, v38)))), 0x17uLL))), (int8x16_t)v32));
        v40 = *((int8x16_t *)a2 + 15);
        v41 = (float32x4_t)vbslq_s8(v40, (int8x16_t)v19, v39);
        *(int8x16_t *)(v6 + v10) = vbslq_s8(v40, (int8x16_t)v19, (int8x16_t)vmulq_laneq_f32(v41, v41, 3));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v7;
      v6 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype1_fast_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x16_t *v64;
  int v65;
  uint64_t v66;
  float32x4_t v67;
  int8x16_t v68;
  int8x16_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v65 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14));
      v18 = *((int8x16_t *)a2 + 17);
      v19 = vandq_s8(v18, v17);
      v20 = vandq_s8(v18, (int8x16_t)vrecpeq_f32(v16));
      v21 = *((int8x16_t *)a2 + 3);
      v22 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v19, v21));
      v23 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v20, v21));
      v24 = *((float32x4_t *)a2 + 50);
      v25 = *((float32x4_t *)a2 + 5);
      v26 = *((float32x4_t *)a2 + 6);
      v27 = vminq_f32(vmaxq_f32(v22, v24), v25);
      v28 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v29 = vminq_f32(vmaxq_f32(v23, v24), v25);
      v30 = vmulq_f32(v26, vcvtq_f32_s32((int32x4_t)vaddq_f32(v27, v28)));
      v31 = vmulq_f32(v26, vcvtq_f32_s32((int32x4_t)vaddq_f32(v29, v28)));
      v32 = vcvtq_f32_s32(vcvtq_s32_f32(v30));
      v33 = vcvtq_f32_s32(vcvtq_s32_f32(v31));
      v34 = *((float32x4_t *)a2 + 7);
      v35 = *((float32x4_t *)a2 + 8);
      v36 = vaddq_f32(v34, vsubq_f32(v30, v32));
      v37 = vaddq_f32(v34, vsubq_f32(v31, v33));
      v38 = *((int8x16_t *)a2 + 74);
      v13.i64[0] = vbslq_s8(v38, (int8x16_t)v13, v21).u64[0];
      v39 = vaddq_f32(v35, v32);
      v40 = vaddq_f32(v35, v33);
      v12.i64[0] = vbslq_s8(v38, (int8x16_t)v12, v21).u64[0];
      v42 = *((float32x4_t *)a2 + 9);
      v41 = *((float32x4_t *)a2 + 10);
      v43 = vmulq_n_f32(vsubq_f32(v39, vmulq_f32(vrsqrteq_f32(v36), v42)), COERCE_FLOAT(*(_OWORD *)a2));
      v44 = vmulq_n_f32(vsubq_f32(v40, vmulq_f32(vrsqrteq_f32(v37), v42)), COERCE_FLOAT(*(_OWORD *)a2));
      v45 = vcvtq_f32_s32(vcvtq_s32_f32(v43));
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      v47 = vsubq_f32(v45, (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vcgtq_f32(v45, v43)));
      v48 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vcgtq_f32(v46, v44)));
      v49 = vsubq_f32(v43, v47);
      v50 = vsubq_f32(v44, v48);
      v51 = vaddq_f32(v41, v47);
      v52 = vaddq_f32(v41, v48);
      v53 = *((float32x4_t *)a2 + 11);
      v54 = *((float32x4_t *)a2 + 12);
      v55 = vmulq_f32(vrecpeq_f32(vsubq_f32(v53, v49)), v54);
      v56 = vmulq_f32(vrecpeq_f32(vsubq_f32(v53, v50)), v54);
      v57 = vaddq_f32(v52, vmulq_f32(v56, v56));
      v58 = vmaxq_f32(vaddq_f32(v51, vmulq_f32(v55, v55)), v24);
      v59 = *((float32x4_t *)a2 + 13);
      v60 = *((float32x4_t *)a2 + 14);
      v61 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v62 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v22, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v24, vsubq_f32(v27, v61)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 0), (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v58, v59), v60)), *(float32x4_t *)a2, 3)), v25));
      v63 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v23, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v24, vsubq_f32(v29, v61)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 0), (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v57, v24), v59), v60)), *(float32x4_t *)a2, 3)), v25));
      v64 = (int8x16_t *)(v6 + v11);
      v64[-1] = vbslq_s8(v15, (int8x16_t)v22, (int8x16_t)vmulq_laneq_f32(v62, v62, 3));
      *v64 = vbslq_s8(v15, (int8x16_t)v23, (int8x16_t)vmulq_laneq_f32(v63, v63, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v65 = -v10;
    if (v65 >= v5)
      goto LABEL_3;
LABEL_10:
    v66 = 16 * v65;
    v67 = *(float32x4_t *)(v7 + v66);
    v68 = *((int8x16_t *)a2 + 15);
    v69 = *((int8x16_t *)a2 + 3);
    v70 = vmulq_f32(v67, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v67, 3), *((float32x4_t *)a2 + 16)))), v69));
    v67.i64[0] = vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v67, v69).u64[0];
    v71 = *((float32x4_t *)a2 + 50);
    v72 = *((float32x4_t *)a2 + 5);
    v73 = vminq_f32(vmaxq_f32(v70, v71), v72);
    v74 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v73, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
    v75 = vcvtq_f32_s32(vcvtq_s32_f32(v74));
    v76 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v75), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v74, v75))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
    v77 = vcvtq_f32_s32(vcvtq_s32_f32(v76));
    v78 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v72, (int8x16_t)vcgtq_f32(v77, v76)));
    v79 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v76, v78))), *((float32x4_t *)a2 + 12));
    v80 = (float32x4_t)vbslq_s8(v68, (int8x16_t)v70, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v71, vsubq_f32(v73, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v67.f32, 0), (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v79, v79),
                                                                                         vaddq_f32(*((float32x4_t *)a2 + 10), v78)), v71), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))), *(float32x4_t *)a2, 3)), v72));
    *(int8x16_t *)(v6 + v66) = vbslq_s8(v68, (int8x16_t)v70, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype1_fixed_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int8x16_t *v65;
  int v66;
  uint64_t v67;
  float32x4_t v68;
  int8x16_t v69;
  int8x16_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v66 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14));
      v17 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14));
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vandq_s8(v19, (int8x16_t)vmulq_f32(v16, v18));
      v21 = vandq_s8(v19, (int8x16_t)vmulq_f32(v17, v18));
      v22 = *((int8x16_t *)a2 + 3);
      v23 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v20, v22));
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v21, v22));
      v25 = *((float32x4_t *)a2 + 50);
      v26 = *((float32x4_t *)a2 + 5);
      v27 = *((float32x4_t *)a2 + 6);
      v28 = vminq_f32(vmaxq_f32(v23, v25), v26);
      v29 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v30 = vminq_f32(vmaxq_f32(v24, v25), v26);
      v31 = vmulq_f32(v27, vcvtq_f32_s32((int32x4_t)vaddq_f32(v28, v29)));
      v32 = vmulq_f32(v27, vcvtq_f32_s32((int32x4_t)vaddq_f32(v30, v29)));
      v33 = vcvtq_f32_s32(vcvtq_s32_f32(v31));
      v34 = vcvtq_f32_s32(vcvtq_s32_f32(v32));
      v35 = *((float32x4_t *)a2 + 7);
      v36 = *((float32x4_t *)a2 + 8);
      v37 = vaddq_f32(v35, vsubq_f32(v31, v33));
      v38 = vaddq_f32(v35, vsubq_f32(v32, v34));
      v39 = *((int8x16_t *)a2 + 74);
      v13.i64[0] = vbslq_s8(v39, (int8x16_t)v13, v22).u64[0];
      v40 = vaddq_f32(v36, v33);
      v41 = vaddq_f32(v36, v34);
      v12.i64[0] = vbslq_s8(v39, (int8x16_t)v12, v22).u64[0];
      v43 = *((float32x4_t *)a2 + 9);
      v42 = *((float32x4_t *)a2 + 10);
      v44 = vmulq_n_f32(vsubq_f32(v40, vmulq_f32(vrsqrteq_f32(v37), v43)), COERCE_FLOAT(*(_OWORD *)a2));
      v45 = vmulq_n_f32(vsubq_f32(v41, vmulq_f32(vrsqrteq_f32(v38), v43)), COERCE_FLOAT(*(_OWORD *)a2));
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      v48 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v46, v44)));
      v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v47, v45)));
      v50 = vsubq_f32(v44, v48);
      v51 = vsubq_f32(v45, v49);
      v52 = vaddq_f32(v42, v48);
      v53 = vaddq_f32(v42, v49);
      v54 = *((float32x4_t *)a2 + 11);
      v55 = *((float32x4_t *)a2 + 12);
      v56 = vmulq_f32(vrecpeq_f32(vsubq_f32(v54, v50)), v55);
      v57 = vmulq_f32(vrecpeq_f32(vsubq_f32(v54, v51)), v55);
      v58 = vaddq_f32(v53, vmulq_f32(v57, v57));
      v59 = vmaxq_f32(vaddq_f32(v52, vmulq_f32(v56, v56)), v25);
      v60 = *((float32x4_t *)a2 + 13);
      v61 = *((float32x4_t *)a2 + 14);
      v62 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v63 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v23, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v25, vsubq_f32(v28, v62)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 0), (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v59, v60), v61)), *(float32x4_t *)a2, 3)), v26));
      v64 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v25, vsubq_f32(v30, v62)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 0), (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v58, v25), v60), v61)), *(float32x4_t *)a2, 3)), v26));
      v65 = (int8x16_t *)(v6 + v11);
      v65[-1] = vbslq_s8(v15, (int8x16_t)v23, (int8x16_t)vmulq_laneq_f32(v63, v63, 3));
      *v65 = vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v64, v64, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v66 = -v10;
    if (v66 >= v5)
      goto LABEL_3;
LABEL_10:
    v67 = 16 * v66;
    v68 = *(float32x4_t *)(v7 + v67);
    v69 = *((int8x16_t *)a2 + 15);
    v70 = *((int8x16_t *)a2 + 3);
    v71 = vmulq_f32(v68, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 3), *((float32x4_t *)a2 + 16))), *((float32x4_t *)a2 + 18))), v70));
    v68.i64[0] = vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v68, v70).u64[0];
    v72 = *((float32x4_t *)a2 + 50);
    v73 = *((float32x4_t *)a2 + 5);
    v74 = vminq_f32(vmaxq_f32(v71, v72), v73);
    v75 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v74, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
    v76 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
    v77 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v76), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v75, v76))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
    v78 = vcvtq_f32_s32(vcvtq_s32_f32(v77));
    v79 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v73, (int8x16_t)vcgtq_f32(v78, v77)));
    v80 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v77, v79))), *((float32x4_t *)a2 + 12));
    v81 = (float32x4_t)vbslq_s8(v69, (int8x16_t)v71, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v72, vsubq_f32(v74, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 0), (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v80, v80),
                                                                                         vaddq_f32(*((float32x4_t *)a2 + 10), v79)), v72), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))), *(float32x4_t *)a2, 3)), v73));
    *(int8x16_t *)(v6 + v67) = vbslq_s8(v69, (int8x16_t)v71, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype1_nice_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  int8x16_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = 16 * *((int *)a1 + 22);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((int8x16_t *)a2 + 15);
        v13 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3), *((float32x4_t *)a2 + 16));
        v14 = vrecpeq_f32(v13);
        v15 = vrecpsq_f32(v14, v13);
        v16 = vmulq_f32(v14, v15);
        v17 = vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v16, vrecpsq_f32(v16, v13)));
        v18 = *((int8x16_t *)a2 + 3);
        v19 = vmulq_f32(v11, (float32x4_t)vorrq_s8(v17, v18));
        v17.i64[0] = vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v15, v18).u64[0];
        v20 = *((float32x4_t *)a2 + 75);
        v21 = *((float32x4_t *)a2 + 5);
        v22 = vminq_f32(vmaxq_f32(v19, v20), v21);
        v23 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v20)), v20), (int8x16_t)v21, (int8x16_t)vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v24 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v23), (int8x16_t)v21);
        v25 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v24, *((float32x4_t *)a2 + 23)));
        v26 = vsubq_f32(vsubq_f32(v24, v21), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v25), v24));
        v27 = vmulq_f32(v26, v26);
        v28 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v23))), *((float32x4_t *)a2 + 22)), v25), vmulq_f32(v26, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v26, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v26)),
                            vmulq_f32(v27, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v26)), vmulq_f32(v27, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v26)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
        v29 = vcvtq_f32_s32(vcvtq_s32_f32(v28));
        v30 = vsubq_f32(v29, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v29, v28)));
        v31 = vsubq_f32(v28, v30);
        v32 = (float32x4_t)vbslq_s8(v12, (int8x16_t)v19, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v20, vsubq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v17.i8, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v21, vmulq_f32(v31, vaddq_f32(
                                                                              *((float32x4_t *)a2 + 48),
                                                                              vmulq_f32(v31, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v31)), vmulq_f32(vmulq_f32(v31, v31), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v31)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v30)), 0x17uLL)),
                                                                      *(float32x4_t *)a2,
                                                                      3)),
                                          v21));
        *(int8x16_t *)(v7 + v10) = vbslq_s8(v12, (int8x16_t)v19, (int8x16_t)vmulq_laneq_f32(v32, v32, 3));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v6;
      v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype1_half_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  int8x16_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  int8x16_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  int32x4_t v76;
  float32x4_t v77;
  int8x16_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  int8x16_t *v82;
  int v83;
  uint64_t v84;
  float32x4_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  int8x16_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v83 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vrecpsq_f32(v20, v16);
      v23 = vrecpsq_f32(v21, v17);
      v24 = (int8x16_t)vmulq_f32(v20, v22);
      v25 = vandq_s8(v19, (int8x16_t)vmulq_f32(v21, v23));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(vandq_s8(v19, v24), v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 50);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v32 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v33 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v34 = vaddq_f32(v31, v33);
      v35 = vaddq_f32(v32, v33);
      v36 = *((int8x16_t *)a2 + 19);
      v37 = *((float32x4_t *)a2 + 20);
      v38 = (float32x4_t)vorrq_s8(vandq_s8(v36, (int8x16_t)v34), (int8x16_t)v30);
      v39 = (float32x4_t)vorrq_s8(vandq_s8(v36, (int8x16_t)v35), (int8x16_t)v30);
      v40 = *((int8x16_t *)a2 + 21);
      v41 = *((float32x4_t *)a2 + 22);
      v42 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v35, 0x17uLL)), (float32x4_t)vandq_s8(v40, (int8x16_t)vcgtq_f32(v37, v35)));
      v43 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v34, 0x17uLL)), (float32x4_t)vandq_s8(v40, (int8x16_t)vcgtq_f32(v37, v34))), v41);
      v44 = *((float32x4_t *)a2 + 23);
      v45 = *((float32x4_t *)a2 + 24);
      v46 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v38, v44));
      v47 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v39, v44));
      v48 = vaddq_f32(v43, v46);
      v49 = vaddq_f32(vsubq_f32(v42, v41), v47);
      v50 = vsubq_f32(vsubq_f32(v38, v30), vmulq_f32(vmulq_f32(v45, v46), v38));
      v51 = vsubq_f32(vsubq_f32(v39, v30), vmulq_f32(vmulq_f32(v45, v47), v39));
      v52 = *((float32x4_t *)a2 + 25);
      v53 = *((float32x4_t *)a2 + 26);
      v54 = vaddq_f32(v52, vmulq_f32(v53, v50));
      v55 = vaddq_f32(v52, vmulq_f32(v53, v51));
      v56 = *((float32x4_t *)a2 + 27);
      v57 = *((float32x4_t *)a2 + 28);
      v58 = vaddq_f32(v56, vmulq_f32(v57, v50));
      v59 = vaddq_f32(v56, vmulq_f32(v57, v51));
      v60 = *((int8x16_t *)a2 + 74);
      v22.i64[0] = vbslq_s8(v60, (int8x16_t)v22, v26).u64[0];
      v61 = vmulq_n_f32(vaddq_f32(v49, vmulq_f32(v51, vaddq_f32(v59, vmulq_f32(vmulq_f32(v51, v51), v55)))), COERCE_FLOAT(*(_OWORD *)a2));
      v62 = *((float32x4_t *)a2 + 29);
      v63 = *((float32x4_t *)a2 + 30);
      v64 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v48, vmulq_f32(v50, vaddq_f32(v58, vmulq_f32(vmulq_f32(v50, v50), v54)))), COERCE_FLOAT(*(_OWORD *)a2)), v62);
      v65 = vmaxq_f32(v61, v62);
      v66 = vcvtq_f32_s32(vcvtq_s32_f32(v64));
      v67 = vcvtq_f32_s32(vcvtq_s32_f32(v65));
      v68 = vsubq_f32(v66, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v66, v64)));
      v69 = vsubq_f32(v67, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v67, v65)));
      v23.i64[0] = vbslq_s8(v60, (int8x16_t)v23, v26).u64[0];
      v70 = vsubq_f32(v64, v68);
      v71 = vsubq_f32(v65, v69);
      v72 = *((float32x4_t *)a2 + 31);
      v73 = *((float32x4_t *)a2 + 32);
      v74 = vmulq_f32(v71, vaddq_f32(v73, vmulq_f32(v71, vaddq_f32(v63, vmulq_f32(v72, v71)))));
      v75 = vaddq_f32(v30, vmulq_f32(v70, vaddq_f32(v73, vmulq_f32(v70, vaddq_f32(v63, vmulq_f32(v72, v70))))));
      v76 = *((int32x4_t *)a2 + 33);
      v77 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v78 = (int8x16_t)vcgtq_f32(v29, vsubq_f32(v31, v77));
      v79 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v77)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v30, v74), (float32x4_t)vshlq_n_s32(vaddq_s32(v76, vcvtq_s32_f32(v69)), 0x17uLL)), *(float32x4_t *)a2, 3));
      v80 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v78, (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(v75, (float32x4_t)vshlq_n_s32(vaddq_s32(v76, vcvtq_s32_f32(v68)), 0x17uLL)), *(float32x4_t *)a2, 3)), v30));
      v81 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vminq_f32(v79, v30));
      v82 = (int8x16_t *)(v6 + v11);
      v82[-1] = vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      *v82 = vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v83 = -v10;
    if (v83 >= v5)
      goto LABEL_3;
LABEL_10:
    v84 = 16 * v83;
    v85 = *(float32x4_t *)(v7 + v84);
    v86 = *((int8x16_t *)a2 + 15);
    v87 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v85, 3), *((float32x4_t *)a2 + 16));
    v88 = vmulq_f32(vrecpeq_f32(v87), *((float32x4_t *)a2 + 18));
    v89 = vrecpsq_f32(v88, v87);
    v90 = *((int8x16_t *)a2 + 3);
    v91 = vmulq_f32(v85, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v88, v89)), v90));
    v89.i64[0] = vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v89, v90).u64[0];
    v92 = *((float32x4_t *)a2 + 50);
    v93 = *((float32x4_t *)a2 + 5);
    v94 = vminq_f32(vmaxq_f32(v91, v92), v93);
    v95 = vaddq_f32(v94, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v96 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v95), (int8x16_t)v93);
    v97 = (float32x4_t)vandq_s8((int8x16_t)v93, (int8x16_t)vcgtq_f32(v96, *((float32x4_t *)a2 + 23)));
    v98 = vsubq_f32(vsubq_f32(v96, v93), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v97), v96));
    v99 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v95, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v95))), *((float32x4_t *)a2 + 22)), v97), vmulq_f32(v98, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(*((float32x4_t *)a2 + 28), v98)), vmulq_f32(vmulq_f32(v98, v98), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v98)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v100 = vcvtq_f32_s32(vcvtq_s32_f32(v99));
    v101 = vsubq_f32(v100, (float32x4_t)vandq_s8((int8x16_t)v93, (int8x16_t)vcgtq_f32(v100, v99)));
    v102 = vsubq_f32(v99, v101);
    v103 = (float32x4_t)vbslq_s8(v86, (int8x16_t)v91, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v92, vsubq_f32(v94, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v89.f32, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v93, vmulq_f32(v102, vaddq_f32(
                                                                           *((float32x4_t *)a2 + 32),
                                                                           vmulq_f32(v102, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v102)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v101)), 0x17uLL)), *(float32x4_t *)a2, 3)), v93));
    *(int8x16_t *)(v6 + v84) = vbslq_s8(v86, (int8x16_t)v91, (int8x16_t)vmulq_laneq_f32(v103, v103, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype1_halfTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int32x4_t v30;
  int32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int32x4_t v75;
  int32x4_t v76;
  float32x4_t v77;
  int8x16_t v78;
  int8x16_t v79;
  float32x4_t v80;
  float32x4_t v81;
  int8x16_t *v82;
  int v83;
  uint64_t v84;
  float32x4_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  int32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v83 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vrecpsq_f32(v20, v16);
      v23 = vrecpsq_f32(v21, v17);
      v24 = (int8x16_t)vmulq_f32(v20, v22);
      v25 = vandq_s8(v19, (int8x16_t)vmulq_f32(v21, v23));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(vandq_s8(v19, v24), v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = (int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v22, (int8x16_t)v29);
      v31 = (int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v23, (int8x16_t)v29);
      v32 = vminq_f32(vmaxq_f32(v27, v29), (float32x4_t)vdupq_laneq_s32(v30, 3));
      v33 = vminq_f32(vmaxq_f32(v28, v29), (float32x4_t)vdupq_laneq_s32(v31, 3));
      v34 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v35 = vaddq_f32(v32, v34);
      v36 = *((int8x16_t *)a2 + 19);
      v37 = *((float32x4_t *)a2 + 20);
      v38 = vaddq_f32(v33, v34);
      v39 = *((float32x4_t *)a2 + 5);
      v40 = (float32x4_t)vorrq_s8(vandq_s8(v36, (int8x16_t)v35), (int8x16_t)v39);
      v41 = (float32x4_t)vorrq_s8(vandq_s8(v36, (int8x16_t)v38), (int8x16_t)v39);
      v42 = *((int8x16_t *)a2 + 21);
      v43 = *((float32x4_t *)a2 + 22);
      v44 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v38, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v37, v38)));
      v45 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v35, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v37, v35))), v43);
      v46 = *((float32x4_t *)a2 + 23);
      v47 = *((float32x4_t *)a2 + 24);
      v48 = vsubq_f32(v44, v43);
      v49 = (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v40, v46));
      v50 = (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v41, v46));
      v51 = vaddq_f32(v45, v49);
      v52 = vsubq_f32(vsubq_f32(v40, v39), vmulq_f32(vmulq_f32(v47, v49), v40));
      v53 = vsubq_f32(vsubq_f32(v41, v39), vmulq_f32(vmulq_f32(v47, v50), v41));
      v54 = *((float32x4_t *)a2 + 25);
      v55 = *((float32x4_t *)a2 + 26);
      v56 = vaddq_f32(v54, vmulq_f32(v55, v52));
      v57 = vaddq_f32(v54, vmulq_f32(v55, v53));
      v58 = *((float32x4_t *)a2 + 27);
      v59 = *((float32x4_t *)a2 + 28);
      v60 = vmulq_n_f32(vaddq_f32(vaddq_f32(v48, v50), vmulq_f32(v53, vaddq_f32(vaddq_f32(v58, vmulq_f32(v53, v59)), vmulq_f32(vmulq_f32(v53, v53), v57)))), COERCE_FLOAT(*(_OWORD *)a2));
      v61 = *((float32x4_t *)a2 + 29);
      v62 = *((float32x4_t *)a2 + 30);
      v63 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v51, vmulq_f32(v52, vaddq_f32(vaddq_f32(v58, vmulq_f32(v52, v59)), vmulq_f32(vmulq_f32(v52, v52), v56)))), COERCE_FLOAT(*(_OWORD *)a2)), v61);
      v64 = vmaxq_f32(v60, v61);
      v65 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
      v66 = vcvtq_f32_s32(vcvtq_s32_f32(v64));
      v67 = vsubq_f32(v65, (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v65, v63)));
      v68 = vsubq_f32(v66, (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v66, v64)));
      v69 = vsubq_f32(v63, v67);
      v70 = vsubq_f32(v64, v68);
      v71 = *((float32x4_t *)a2 + 31);
      v72 = *((float32x4_t *)a2 + 32);
      v73 = vmulq_f32(v70, vaddq_f32(v72, vmulq_f32(v70, vaddq_f32(v62, vmulq_f32(v71, v70)))));
      v74 = vaddq_f32(v39, vmulq_f32(v69, vaddq_f32(v72, vmulq_f32(v69, vaddq_f32(v62, vmulq_f32(v71, v69))))));
      v75 = vcvtq_s32_f32(v68);
      v76 = *((int32x4_t *)a2 + 33);
      v77 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v78 = (int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v77));
      v79 = vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v33, v77)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v31.i8, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v39, v73), (float32x4_t)vshlq_n_s32(vaddq_s32(v76, v75), 0x17uLL)), *(float32x4_t *)a2, 3));
      v80 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, vbslq_s8(v78, (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v30.i8, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(v74, (float32x4_t)vshlq_n_s32(vaddq_s32(v76, vcvtq_s32_f32(v67)), 0x17uLL)), *(float32x4_t *)a2, 3)));
      v81 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, v79);
      v82 = (int8x16_t *)(v6 + v11);
      v82[-1] = vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      *v82 = vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v83 = -v10;
    if (v83 >= v5)
      goto LABEL_3;
LABEL_10:
    v84 = 16 * v83;
    v85 = *(float32x4_t *)(v7 + v84);
    v86 = *((int8x16_t *)a2 + 15);
    v87 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v85, 3), *((float32x4_t *)a2 + 16));
    v88 = vmulq_f32(vrecpeq_f32(v87), *((float32x4_t *)a2 + 18));
    v89 = vrecpsq_f32(v88, v87);
    v90 = vmulq_f32(v85, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v88, v89)), *((int8x16_t *)a2 + 3)));
    v91 = *((float32x4_t *)a2 + 75);
    v92 = (int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v89, (int8x16_t)v91);
    v93 = vminq_f32(vmaxq_f32(v90, v91), (float32x4_t)vdupq_laneq_s32(v92, 3));
    v94 = vaddq_f32(v93, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v95 = *((float32x4_t *)a2 + 5);
    v96 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v94), (int8x16_t)v95);
    v97 = (float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vcgtq_f32(v96, *((float32x4_t *)a2 + 23)));
    v98 = vsubq_f32(vsubq_f32(v96, v95), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v97), v96));
    v99 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v94, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v94))), *((float32x4_t *)a2 + 22)), v97), vmulq_f32(v98, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v98, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v98, v98), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v98)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v100 = vcvtq_f32_s32(vcvtq_s32_f32(v99));
    v101 = vsubq_f32(v100, (float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vcgtq_f32(v100, v99)));
    v102 = vsubq_f32(v99, v101);
    v103 = (float32x4_t)vbslq_s8(v86, (int8x16_t)v90, vbslq_s8((int8x16_t)vcgtq_f32(v91, vsubq_f32(v93, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v92.i8, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v95, vmulq_f32(v102, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v102, vaddq_f32(*((float32x4_t *)a2 + 30),
                                                     vmulq_f32(*((float32x4_t *)a2 + 31), v102)))))),
                                           (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v101)), 0x17uLL)), *(float32x4_t *)a2, 3)));
    *(int8x16_t *)(v6 + v84) = vbslq_s8(v86, (int8x16_t)v90, (int8x16_t)vmulq_laneq_f32(v103, v103, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype1_niceTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  int8x16_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = 16 * *((int *)a1 + 22);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((int8x16_t *)a2 + 15);
        v13 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3), *((float32x4_t *)a2 + 16));
        v14 = vrecpeq_f32(v13);
        v15 = vrecpsq_f32(v14, v13);
        v16 = vmulq_f32(v14, v15);
        v17 = vmulq_f32(v11, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v16, vrecpsq_f32(v16, v13))), *((int8x16_t *)a2 + 3)));
        v18 = *((float32x4_t *)a2 + 75);
        v19 = (int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v15, (int8x16_t)v18);
        v20 = vminq_f32(vmaxq_f32(v17, v18), (float32x4_t)vdupq_laneq_s32(v19, 3));
        v21 = *((float32x4_t *)a2 + 5);
        v22 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v18)), v18), (int8x16_t)v21, (int8x16_t)vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v23 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v22), (int8x16_t)v21);
        v24 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v23, *((float32x4_t *)a2 + 23)));
        v25 = vsubq_f32(vsubq_f32(v23, v21), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v24), v23));
        v26 = vmulq_f32(v25, v25);
        v27 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v22, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v22))), *((float32x4_t *)a2 + 22)), v24), vmulq_f32(v25, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v25, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v25)),
                            vmulq_f32(v26, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v25)), vmulq_f32(v26, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v25)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
        v28 = vcvtq_f32_s32(vcvtq_s32_f32(v27));
        v29 = vsubq_f32(v28, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v28, v27)));
        v30 = vsubq_f32(v27, v29);
        v31 = (float32x4_t)vbslq_s8(v12, (int8x16_t)v17, vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v19.i8, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v21, vmulq_f32(v30, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v30,
                                                      vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v30)), vmulq_f32(vmulq_f32(v30, v30), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v30)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v29)), 0x17uLL)), *(float32x4_t *)a2, 3)));
        *(int8x16_t *)(v7 + v10) = vbslq_s8(v12, (int8x16_t)v17, (int8x16_t)vmulq_laneq_f32(v31, v31, 3));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v6;
      v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype1_floatTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  int8x16_t v40;
  int8x16_t v41;
  int8x16_t v42;
  float32x4_t v43;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 2);
    v7 = 16 * *((int *)a1 + 22);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((float32x4_t *)a2 + 72);
        v13 = *((float32x4_t *)a2 + 73);
        v14 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v11, v12), 3), v12), v13);
        v15 = vminq_f32(vmaxq_f32(vrecpeq_f32(v14), v12), v13);
        v16 = vrecpsq_f32(v14, v15);
        v17 = vminq_f32(vmaxq_f32(vmulq_f32(v15, v16), v12), v13);
        v18 = vmulq_f32(v17, vrecpsq_f32(v14, v17));
        v18.i32[3] = 1.0;
        v19 = vmulq_f32(v11, v18);
        v20 = *((float32x4_t *)a2 + 75);
        v21 = (int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v16, (int8x16_t)v20);
        v22 = vminq_f32(vmaxq_f32(v19, v20), (float32x4_t)vdupq_laneq_s32(v21, 3));
        v23 = *((float32x4_t *)a2 + 5);
        v24 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v20)), v20), (int8x16_t)v23, (int8x16_t)vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v25 = *((int8x16_t *)a2 + 52);
        v26 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v24);
        v27 = (int8x16_t)vmulq_f32(v24, vaddq_f32(v23, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 49), v26)));
        v28 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), v27), (int8x16_t)v23);
        v29 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v24, *((float32x4_t *)a2 + 21))), vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v24, *((float32x4_t *)a2 + 50)), *((int8x16_t *)a2 + 51)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v24, *((float32x4_t *)a2 + 50)))), (float32x4_t)vandq_s8(v25, v26))), *((float32x4_t *)a2 + 22)), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)));
        v30 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v28, *((float32x4_t *)a2 + 23)));
        v31 = vaddq_f32(v29, v30);
        v32 = vsubq_f32(vsubq_f32(v28, v23), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v30), v28));
        v33 = vmulq_f32(v32, v32);
        v34 = vmulq_n_f32(vaddq_f32(v31, vmulq_f32(v32, vaddq_f32(*((float32x4_t *)a2 + 61), vmulq_f32(v32, vaddq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 59), vmulq_f32(*((float32x4_t *)a2 + 60), v32)), vmulq_f32(v33, vaddq_f32(*((float32x4_t *)a2 + 57), vmulq_f32(*((float32x4_t *)a2 + 58), v32)))), vmulq_f32(vmulq_f32(v33, v33), vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 55), vmulq_f32(*((float32x4_t *)a2 + 56), v32)), vmulq_f32(
                                v33,
                                vaddq_f32(*((float32x4_t *)a2 + 53), vmulq_f32(*((float32x4_t *)a2 + 54), v32)))))))))),
                COERCE_FLOAT(*(_OWORD *)a2));
        v35 = vminq_f32(vmaxq_f32(v34, *((float32x4_t *)a2 + 62)), *((float32x4_t *)a2 + 63));
        v36 = vcvtq_f32_s32(vcvtq_s32_f32(v35));
        v37 = vsubq_f32(v36, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v36, v35)));
        v38 = vsubq_f32(v35, v37);
        v39 = vmulq_f32(v38, v38);
        v40 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 70), v37);
        v41 = vbslq_s8((int8x16_t)vcgtq_f32(v20, vsubq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v21.i8, 0), (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v23, vorrq_s8((int8x16_t)vcltzq_f32(v34), (int8x16_t)vcgezq_f32(v34))), v20), (int8x16_t)vmulq_f32(vaddq_f32(v23, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 71), v40)), vmulq_f32(vaddq_f32(
                                                             v23,
                                                             vmulq_f32(v38, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 68), vmulq_f32(v38, *((float32x4_t *)a2 + 69))), vmulq_f32(v39, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 66), vmulq_f32(*((float32x4_t *)a2 + 67), v38)), vmulq_f32(v39, vaddq_f32(*((float32x4_t *)a2 + 64), vmulq_f32(*((float32x4_t *)a2 + 65), v38)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33),
                                                                            vcvtq_s32_f32(vaddq_f32(v37, (float32x4_t)vandq_s8(v25, v40)))), 0x17uLL))), (int8x16_t)v34), *(float32x4_t *)a2, 3));
        v42 = *((int8x16_t *)a2 + 15);
        v43 = (float32x4_t)vbslq_s8(v42, (int8x16_t)v19, v41);
        *(int8x16_t *)(v6 + v10) = vbslq_s8(v42, (int8x16_t)v19, (int8x16_t)vmulq_laneq_f32(v43, v43, 3));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v7;
      v6 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype2_fast_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  int8x16_t *v68;
  int v69;
  uint64_t v70;
  float32x4_t v71;
  int8x16_t v72;
  int8x16_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v69 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14));
      v17 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14));
      v18 = *((int8x16_t *)a2 + 17);
      v19 = vandq_s8(v18, v16);
      v20 = vandq_s8(v18, v17);
      v21 = *((int8x16_t *)a2 + 3);
      v22 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v19, v21));
      v23 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v20, v21));
      v24 = *((int8x16_t *)a2 + 74);
      v25 = *((float32x4_t *)a2 + 75);
      v26 = *((float32x4_t *)a2 + 5);
      v27 = *((float32x4_t *)a2 + 6);
      v28 = vminq_f32(vmaxq_f32(v22, v25), v26);
      v29 = vminq_f32(vmaxq_f32(v23, v25), v26);
      v30 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v31 = vmulq_f32(v27, vcvtq_f32_s32((int32x4_t)vaddq_f32(v28, v30)));
      v32 = vmulq_f32(v27, vcvtq_f32_s32((int32x4_t)vaddq_f32(v29, v30)));
      v13.i64[0] = vbslq_s8(v24, (int8x16_t)v13, v21).u64[0];
      v33 = vcvtq_f32_s32(vcvtq_s32_f32(v31));
      v34 = vcvtq_f32_s32(vcvtq_s32_f32(v32));
      v12.i64[0] = vbslq_s8(v24, (int8x16_t)v12, v21).u64[0];
      v36 = *((float32x4_t *)a2 + 7);
      v35 = *((float32x4_t *)a2 + 8);
      v37 = vrsqrteq_f32(vaddq_f32(v36, vsubq_f32(v31, v33)));
      v38 = vaddq_f32(v35, v33);
      v39 = vrsqrteq_f32(vaddq_f32(v36, vsubq_f32(v32, v34)));
      v40 = vaddq_f32(v35, v34);
      v41 = *((float32x4_t *)a2 + 9);
      v42 = *((float32x4_t *)a2 + 10);
      v43 = vmulq_n_f32(vsubq_f32(v38, vmulq_f32(v37, v41)), COERCE_FLOAT(*(_OWORD *)a2));
      v44 = vmulq_n_f32(vsubq_f32(v40, vmulq_f32(v39, v41)), COERCE_FLOAT(*(_OWORD *)a2));
      v45 = vcvtq_f32_s32(vcvtq_s32_f32(v43));
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      v47 = vsubq_f32(v45, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v45, v43)));
      v48 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v46, v44)));
      v49 = vsubq_f32(v43, v47);
      v50 = vsubq_f32(v44, v48);
      v51 = vaddq_f32(v42, v47);
      v52 = vaddq_f32(v42, v48);
      v53 = *((float32x4_t *)a2 + 11);
      v54 = *((float32x4_t *)a2 + 12);
      v55 = vmulq_f32(vrecpeq_f32(vsubq_f32(v53, v49)), v54);
      v56 = vmulq_f32(vrecpeq_f32(vsubq_f32(v53, v50)), v54);
      v57 = vmaxq_f32(vaddq_f32(v51, vmulq_f32(v55, v55)), v25);
      v58 = vmaxq_f32(vaddq_f32(v52, vmulq_f32(v56, v56)), v25);
      v59 = *((float32x4_t *)a2 + 13);
      v60 = *((float32x4_t *)a2 + 14);
      v61 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v57, v59), v60));
      v62 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v58, v59), v60));
      v63 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v64 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v23, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v25, vsubq_f32(v29, v63)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 0), (int8x16_t)vmulq_laneq_f32(v62, *(float32x4_t *)a2, 3)), v26));
      v65 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v66 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v22, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v65, (float32x4_t)vbslq_s8(v15, (int8x16_t)v22, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v25, vsubq_f32(v28, v63)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 0), (int8x16_t)vmulq_laneq_f32(v61,
                                                                                                    *(float32x4_t *)a2,
                                                                                                    3)),
                                                                        v26))),
                                          v25),
                                        v26));
      v67 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v23, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v65, v64), v25), v26));
      v68 = (int8x16_t *)(v6 + v11);
      v68[-1] = vbslq_s8(v15, (int8x16_t)v22, (int8x16_t)vmulq_laneq_f32(v66, v66, 3));
      *v68 = vbslq_s8(v15, (int8x16_t)v23, (int8x16_t)vmulq_laneq_f32(v67, v67, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v69 = -v10;
    if (v69 >= v5)
      goto LABEL_3;
LABEL_10:
    v70 = 16 * v69;
    v71 = *(float32x4_t *)(v7 + v70);
    v72 = *((int8x16_t *)a2 + 15);
    v73 = *((int8x16_t *)a2 + 3);
    v74 = vmulq_f32(v71, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 3), *((float32x4_t *)a2 + 16)))), v73));
    v71.i64[0] = vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v71, v73).u64[0];
    v75 = *((float32x4_t *)a2 + 75);
    v76 = *((float32x4_t *)a2 + 5);
    v77 = vminq_f32(vmaxq_f32(v74, v75), v76);
    v78 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v77, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
    v79 = vcvtq_f32_s32(vcvtq_s32_f32(v78));
    v80 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v79), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v78, v79))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
    v81 = vcvtq_f32_s32(vcvtq_s32_f32(v80));
    v82 = vsubq_f32(v81, (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v81, v80)));
    v83 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v80, v82))), *((float32x4_t *)a2 + 12));
    v84 = (float32x4_t)vbslq_s8(v72, (int8x16_t)v74, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(v72, (int8x16_t)v74, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v75, vsubq_f32(v77, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 0),
                                                                                     (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v83, v83), vaddq_f32(*((float32x4_t *)a2 + 10), v82)), v75), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))), *(float32x4_t *)a2, 3)), v76))), v75), v76));
    *(int8x16_t *)(v6 + v70) = vbslq_s8(v72, (int8x16_t)v74, (int8x16_t)vmulq_laneq_f32(v84, v84, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype2_fixed_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int8x16_t *v69;
  int v70;
  uint64_t v71;
  float32x4_t v72;
  int8x16_t v73;
  int8x16_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v70 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14));
      v17 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14));
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vandq_s8(v19, (int8x16_t)vmulq_f32(v16, v18));
      v21 = vandq_s8(v19, (int8x16_t)vmulq_f32(v17, v18));
      v22 = *((int8x16_t *)a2 + 3);
      v23 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v20, v22));
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v21, v22));
      v25 = *((int8x16_t *)a2 + 74);
      v26 = *((float32x4_t *)a2 + 75);
      v27 = *((float32x4_t *)a2 + 5);
      v28 = *((float32x4_t *)a2 + 6);
      v29 = vminq_f32(vmaxq_f32(v23, v26), v27);
      v30 = vminq_f32(vmaxq_f32(v24, v26), v27);
      v31 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v32 = vmulq_f32(v28, vcvtq_f32_s32((int32x4_t)vaddq_f32(v29, v31)));
      v33 = vmulq_f32(v28, vcvtq_f32_s32((int32x4_t)vaddq_f32(v30, v31)));
      v13.i64[0] = vbslq_s8(v25, (int8x16_t)v13, v22).u64[0];
      v34 = vcvtq_f32_s32(vcvtq_s32_f32(v32));
      v35 = vcvtq_f32_s32(vcvtq_s32_f32(v33));
      v12.i64[0] = vbslq_s8(v25, (int8x16_t)v12, v22).u64[0];
      v37 = *((float32x4_t *)a2 + 7);
      v36 = *((float32x4_t *)a2 + 8);
      v38 = vrsqrteq_f32(vaddq_f32(v37, vsubq_f32(v32, v34)));
      v39 = vaddq_f32(v36, v34);
      v40 = vrsqrteq_f32(vaddq_f32(v37, vsubq_f32(v33, v35)));
      v41 = vaddq_f32(v36, v35);
      v42 = *((float32x4_t *)a2 + 9);
      v43 = *((float32x4_t *)a2 + 10);
      v44 = vmulq_n_f32(vsubq_f32(v39, vmulq_f32(v38, v42)), COERCE_FLOAT(*(_OWORD *)a2));
      v45 = vmulq_n_f32(vsubq_f32(v41, vmulq_f32(v40, v42)), COERCE_FLOAT(*(_OWORD *)a2));
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      v48 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v46, v44)));
      v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v47, v45)));
      v50 = vsubq_f32(v44, v48);
      v51 = vsubq_f32(v45, v49);
      v52 = vaddq_f32(v43, v48);
      v53 = vaddq_f32(v43, v49);
      v54 = *((float32x4_t *)a2 + 11);
      v55 = *((float32x4_t *)a2 + 12);
      v56 = vmulq_f32(vrecpeq_f32(vsubq_f32(v54, v50)), v55);
      v57 = vmulq_f32(vrecpeq_f32(vsubq_f32(v54, v51)), v55);
      v58 = vmaxq_f32(vaddq_f32(v52, vmulq_f32(v56, v56)), v26);
      v59 = vmaxq_f32(vaddq_f32(v53, vmulq_f32(v57, v57)), v26);
      v60 = *((float32x4_t *)a2 + 13);
      v61 = *((float32x4_t *)a2 + 14);
      v62 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v58, v60), v61));
      v63 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v59, v60), v61));
      v64 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v65 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v30, v64)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 0), (int8x16_t)vmulq_laneq_f32(v63, *(float32x4_t *)a2, 3)), v27));
      v66 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v67 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v23, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v66, (float32x4_t)vbslq_s8(v15, (int8x16_t)v23, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v29, v64)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 0), (int8x16_t)vmulq_laneq_f32(v62,
                                                                                                    *(float32x4_t *)a2,
                                                                                                    3)),
                                                                        v27))),
                                          v26),
                                        v27));
      v68 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v66, v65), v26), v27));
      v69 = (int8x16_t *)(v6 + v11);
      v69[-1] = vbslq_s8(v15, (int8x16_t)v23, (int8x16_t)vmulq_laneq_f32(v67, v67, 3));
      *v69 = vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v68, v68, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v70 = -v10;
    if (v70 >= v5)
      goto LABEL_3;
LABEL_10:
    v71 = 16 * v70;
    v72 = *(float32x4_t *)(v7 + v71);
    v73 = *((int8x16_t *)a2 + 15);
    v74 = *((int8x16_t *)a2 + 3);
    v75 = vmulq_f32(v72, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v72, 3), *((float32x4_t *)a2 + 16))), *((float32x4_t *)a2 + 18))), v74));
    v72.i64[0] = vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v72, v74).u64[0];
    v76 = *((float32x4_t *)a2 + 75);
    v77 = *((float32x4_t *)a2 + 5);
    v78 = vminq_f32(vmaxq_f32(v75, v76), v77);
    v79 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v78, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
    v80 = vcvtq_f32_s32(vcvtq_s32_f32(v79));
    v81 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v80), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v79, v80))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
    v82 = vcvtq_f32_s32(vcvtq_s32_f32(v81));
    v83 = vsubq_f32(v82, (float32x4_t)vandq_s8((int8x16_t)v77, (int8x16_t)vcgtq_f32(v82, v81)));
    v84 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v81, v83))), *((float32x4_t *)a2 + 12));
    v85 = (float32x4_t)vbslq_s8(v73, (int8x16_t)v75, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(v73, (int8x16_t)v75, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v76, vsubq_f32(v78, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v72.f32, 0),
                                                                                     (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v84, v84), vaddq_f32(*((float32x4_t *)a2 + 10), v83)), v76), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))), *(float32x4_t *)a2, 3)), v77))), v76), v77));
    *(int8x16_t *)(v6 + v71) = vbslq_s8(v73, (int8x16_t)v75, (int8x16_t)vmulq_laneq_f32(v85, v85, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype2_nice_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  int8x16_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = 16 * *((int *)a1 + 22);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((int8x16_t *)a2 + 15);
        v13 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3), *((float32x4_t *)a2 + 16));
        v14 = vrecpeq_f32(v13);
        v15 = vrecpsq_f32(v14, v13);
        v16 = vmulq_f32(v14, v15);
        v17 = vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v16, vrecpsq_f32(v16, v13)));
        v18 = *((int8x16_t *)a2 + 3);
        v19 = vmulq_f32(v11, (float32x4_t)vorrq_s8(v17, v18));
        v17.i64[0] = vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v15, v18).u64[0];
        v20 = *((float32x4_t *)a2 + 75);
        v21 = *((float32x4_t *)a2 + 5);
        v22 = vminq_f32(vmaxq_f32(v19, v20), v21);
        v23 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v20)), v20), (int8x16_t)v21, (int8x16_t)vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v24 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v23), (int8x16_t)v21);
        v25 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v24, *((float32x4_t *)a2 + 23)));
        v26 = vsubq_f32(vsubq_f32(v24, v21), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v25), v24));
        v27 = vmulq_f32(v26, v26);
        v28 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v23))), *((float32x4_t *)a2 + 22)), v25), vmulq_f32(v26, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v26, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v26)),
                            vmulq_f32(v27, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v26)), vmulq_f32(v27, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v26)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
        v29 = vcvtq_f32_s32(vcvtq_s32_f32(v28));
        v30 = vsubq_f32(v29, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v29, v28)));
        v31 = vsubq_f32(v28, v30);
        v32 = (float32x4_t)vbslq_s8(v12, (int8x16_t)v19, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(v12, (int8x16_t)v19, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v20, vsubq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v17.i8, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v21, vmulq_f32(v31, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v31, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v31)), vmulq_f32(vmulq_f32(v31, v31), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v31)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v30)), 0x17uLL)), *(float32x4_t *)a2, 3)), v21))), v20), v21));
        *(int8x16_t *)(v7 + v10) = vbslq_s8(v12, (int8x16_t)v19, (int8x16_t)vmulq_laneq_f32(v32, v32, 3));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v6;
      v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype2_half_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int8x16_t *v87;
  int v88;
  uint64_t v89;
  float32x4_t v90;
  int8x16_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v88 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vrecpsq_f32(v20, v16);
      v23 = vrecpsq_f32(v21, v17);
      v24 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, v22));
      v25 = vandq_s8(v19, (int8x16_t)vmulq_f32(v21, v23));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v32 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v33 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v34 = vaddq_f32(v32, v31);
      v35 = vaddq_f32(v33, v31);
      v36 = *((int8x16_t *)a2 + 19);
      v37 = *((float32x4_t *)a2 + 20);
      v38 = (float32x4_t)vorrq_s8(vandq_s8(v36, (int8x16_t)v34), (int8x16_t)v30);
      v39 = *((int8x16_t *)a2 + 21);
      v40 = *((float32x4_t *)a2 + 22);
      v41 = (float32x4_t)vorrq_s8(vandq_s8(v36, (int8x16_t)v35), (int8x16_t)v30);
      v42 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v35, 0x17uLL)), (float32x4_t)vandq_s8(v39, (int8x16_t)vcgtq_f32(v37, v35)));
      v43 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v34, 0x17uLL)), (float32x4_t)vandq_s8(v39, (int8x16_t)vcgtq_f32(v37, v34))), v40);
      v44 = *((float32x4_t *)a2 + 23);
      v45 = *((float32x4_t *)a2 + 24);
      v46 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v38, v44));
      v47 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v41, v44));
      v48 = vaddq_f32(v43, v46);
      v49 = vmulq_f32(v45, v46);
      v50 = vmulq_f32(vmulq_f32(v45, v47), v41);
      v51 = vaddq_f32(vsubq_f32(v42, v40), v47);
      v52 = vsubq_f32(vsubq_f32(v38, v30), vmulq_f32(v49, v38));
      v53 = vsubq_f32(vsubq_f32(v41, v30), v50);
      v54 = *((float32x4_t *)a2 + 25);
      v55 = *((float32x4_t *)a2 + 26);
      v56 = vaddq_f32(v54, vmulq_f32(v55, v52));
      v57 = *((float32x4_t *)a2 + 27);
      v58 = *((float32x4_t *)a2 + 28);
      v59 = vaddq_f32(v54, vmulq_f32(v55, v53));
      v60 = vaddq_f32(vaddq_f32(v57, vmulq_f32(v58, v52)), vmulq_f32(vmulq_f32(v52, v52), v56));
      v61 = *((int8x16_t *)a2 + 74);
      v62 = vmulq_n_f32(vaddq_f32(v48, vmulq_f32(v52, v60)), COERCE_FLOAT(*(_OWORD *)a2));
      v63 = vmulq_n_f32(vaddq_f32(v51, vmulq_f32(v53, vaddq_f32(vaddq_f32(v57, vmulq_f32(v58, v53)), vmulq_f32(vmulq_f32(v53, v53), v59)))), COERCE_FLOAT(*(_OWORD *)a2));
      v64 = *((float32x4_t *)a2 + 29);
      v65 = *((float32x4_t *)a2 + 30);
      v22.i64[0] = vbslq_s8(v61, (int8x16_t)v22, v26).u64[0];
      v66 = vmaxq_f32(v62, v64);
      v67 = vmaxq_f32(v63, v64);
      v68 = vcvtq_f32_s32(vcvtq_s32_f32(v66));
      v69 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
      v70 = vsubq_f32(v68, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v68, v66)));
      v71 = vsubq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v69, v67)));
      v72 = vsubq_f32(v66, v70);
      v73 = vsubq_f32(v67, v71);
      v74 = *((float32x4_t *)a2 + 31);
      v75 = *((float32x4_t *)a2 + 32);
      v26.i64[0] = vbslq_s8(v61, (int8x16_t)v23, v26).u64[0];
      v76 = vaddq_f32(v65, vmulq_f32(v74, v72));
      v77 = vmulq_f32(v73, vaddq_f32(v75, vmulq_f32(v73, vaddq_f32(v65, vmulq_f32(v74, v73)))));
      v78 = *((int32x4_t *)a2 + 33);
      v79 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v80 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v81 = vaddq_f32(v80, (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v79)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v30, vmulq_f32(v72, vaddq_f32(v75, vmulq_f32(v72, v76)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v78, vcvtq_s32_f32(v70)),
                                                                                       0x17uLL)),
                                                                      *(float32x4_t *)a2,
                                                                      3)),
                                          v30)));
      v82 = vaddq_f32(v80, (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v33, v79)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v26.i8, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v30, v77), (float32x4_t)vshlq_n_s32(vaddq_s32(v78, vcvtq_s32_f32(v71)), 0x17uLL)), *(float32x4_t *)a2, 3)), v30)));
      v83 = vmaxq_f32(v81, v29);
      v84 = vmaxq_f32(v82, v29);
      v85 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vminq_f32(v83, v30));
      v86 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vminq_f32(v84, v30));
      v87 = (int8x16_t *)(v6 + v11);
      v87[-1] = vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v85, v85, 3));
      *v87 = vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v86, v86, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v88 = -v10;
    if (v88 >= v5)
      goto LABEL_3;
LABEL_10:
    v89 = 16 * v88;
    v90 = *(float32x4_t *)(v7 + v89);
    v91 = *((int8x16_t *)a2 + 15);
    v92 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v90, 3), *((float32x4_t *)a2 + 16));
    v93 = vmulq_f32(vrecpeq_f32(v92), *((float32x4_t *)a2 + 18));
    v94 = vrecpsq_f32(v93, v92);
    v95 = *((int8x16_t *)a2 + 3);
    v96 = vmulq_f32(v90, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v93, v94)), v95));
    v94.i64[0] = vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v94, v95).u64[0];
    v97 = *((float32x4_t *)a2 + 75);
    v98 = *((float32x4_t *)a2 + 5);
    v99 = vminq_f32(vmaxq_f32(v96, v97), v98);
    v100 = vaddq_f32(v99, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v101 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v100), (int8x16_t)v98);
    v102 = (float32x4_t)vandq_s8((int8x16_t)v98, (int8x16_t)vcgtq_f32(v101, *((float32x4_t *)a2 + 23)));
    v103 = vsubq_f32(vsubq_f32(v101, v98), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v102), v101));
    v104 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v100, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v100))), *((float32x4_t *)a2 + 22)), v102), vmulq_f32(v103, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(*((float32x4_t *)a2 + 28), v103)), vmulq_f32(vmulq_f32(v103, v103), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v103)))))), COERCE_FLOAT(*(_OWORD *)a2)),
             *((float32x4_t *)a2 + 29));
    v105 = vcvtq_f32_s32(vcvtq_s32_f32(v104));
    v106 = vsubq_f32(v105, (float32x4_t)vandq_s8((int8x16_t)v98, (int8x16_t)vcgtq_f32(v105, v104)));
    v107 = vsubq_f32(v104, v106);
    v108 = (float32x4_t)vbslq_s8(v91, (int8x16_t)v96, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(v91, (int8x16_t)v96, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v97, vsubq_f32(v99, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v94.f32, 0),
                                                                                      (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v98, vmulq_f32(v107, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v107, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v107)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v106)), 0x17uLL)), *(float32x4_t *)a2, 3)), v98))), v97), v98));
    *(int8x16_t *)(v6 + v89) = vbslq_s8(v91, (int8x16_t)v96, (int8x16_t)vmulq_laneq_f32(v108, v108, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype2_halfTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int32x4_t v29;
  int32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  int32x4_t v74;
  int32x4_t v75;
  float32x4_t v76;
  int8x16_t v77;
  float32x4_t v78;
  int8x16_t v79;
  float32x4_t v80;
  float32x4_t v81;
  int8x16_t *v82;
  int v83;
  uint64_t v84;
  float32x4_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  int32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v83 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vrecpsq_f32(v20, v16);
      v23 = vrecpsq_f32(v21, v17);
      v24 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, v22));
      v25 = *((int8x16_t *)a2 + 3);
      v26 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v25));
      v27 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, v23)), v25));
      v28 = *((float32x4_t *)a2 + 75);
      v29 = (int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v22, (int8x16_t)v28);
      v30 = (int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v23, (int8x16_t)v28);
      v31 = vminq_f32(vmaxq_f32(v26, v28), (float32x4_t)vdupq_laneq_s32(v29, 3));
      v32 = vminq_f32(vmaxq_f32(v27, v28), (float32x4_t)vdupq_laneq_s32(v30, 3));
      v33 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v34 = vaddq_f32(v31, v33);
      v35 = *((int8x16_t *)a2 + 19);
      v36 = *((float32x4_t *)a2 + 20);
      v37 = vaddq_f32(v32, v33);
      v38 = *((float32x4_t *)a2 + 5);
      v39 = (float32x4_t)vorrq_s8(vandq_s8(v35, (int8x16_t)v34), (int8x16_t)v38);
      v40 = (float32x4_t)vorrq_s8(vandq_s8(v35, (int8x16_t)v37), (int8x16_t)v38);
      v41 = *((int8x16_t *)a2 + 21);
      v42 = *((float32x4_t *)a2 + 22);
      v43 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x17uLL)), (float32x4_t)vandq_s8(v41, (int8x16_t)vcgtq_f32(v36, v37)));
      v44 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v34, 0x17uLL)), (float32x4_t)vandq_s8(v41, (int8x16_t)vcgtq_f32(v36, v34))), v42);
      v45 = *((float32x4_t *)a2 + 23);
      v46 = *((float32x4_t *)a2 + 24);
      v47 = vsubq_f32(v43, v42);
      v48 = (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v39, v45));
      v49 = (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v40, v45));
      v50 = vaddq_f32(v44, v48);
      v51 = vsubq_f32(vsubq_f32(v39, v38), vmulq_f32(vmulq_f32(v46, v48), v39));
      v52 = vsubq_f32(vsubq_f32(v40, v38), vmulq_f32(vmulq_f32(v46, v49), v40));
      v53 = *((float32x4_t *)a2 + 25);
      v54 = *((float32x4_t *)a2 + 26);
      v55 = vaddq_f32(v53, vmulq_f32(v54, v51));
      v56 = vaddq_f32(v53, vmulq_f32(v54, v52));
      v57 = *((float32x4_t *)a2 + 27);
      v58 = *((float32x4_t *)a2 + 28);
      v59 = vmulq_n_f32(vaddq_f32(vaddq_f32(v47, v49), vmulq_f32(v52, vaddq_f32(vaddq_f32(v57, vmulq_f32(v52, v58)), vmulq_f32(vmulq_f32(v52, v52), v56)))), COERCE_FLOAT(*(_OWORD *)a2));
      v60 = *((float32x4_t *)a2 + 29);
      v61 = *((float32x4_t *)a2 + 30);
      v62 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v50, vmulq_f32(v51, vaddq_f32(vaddq_f32(v57, vmulq_f32(v51, v58)), vmulq_f32(vmulq_f32(v51, v51), v55)))), COERCE_FLOAT(*(_OWORD *)a2)), v60);
      v63 = vmaxq_f32(v59, v60);
      v64 = vcvtq_f32_s32(vcvtq_s32_f32(v62));
      v65 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
      v66 = vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v64, v62)));
      v67 = vsubq_f32(v65, (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v65, v63)));
      v68 = vsubq_f32(v62, v66);
      v69 = vsubq_f32(v63, v67);
      v70 = *((float32x4_t *)a2 + 31);
      v71 = *((float32x4_t *)a2 + 32);
      v72 = vmulq_f32(v69, vaddq_f32(v71, vmulq_f32(v69, vaddq_f32(v61, vmulq_f32(v70, v69)))));
      v73 = vaddq_f32(v38, vmulq_f32(v68, vaddq_f32(v71, vmulq_f32(v68, vaddq_f32(v61, vmulq_f32(v70, v68))))));
      v74 = vcvtq_s32_f32(v67);
      v75 = *((int32x4_t *)a2 + 33);
      v76 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v77 = (int8x16_t)vcgtq_f32(v28, vsubq_f32(v31, v76));
      v78 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v79 = (int8x16_t)vaddq_f32(v78, (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, vbslq_s8((int8x16_t)vcgtq_f32(v28, vsubq_f32(v32, v76)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v30.i8, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v38, v72), (float32x4_t)vshlq_n_s32(vaddq_s32(v75, v74), 0x17uLL)), *(float32x4_t *)a2, 3))));
      v80 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v26, (int8x16_t)vaddq_f32(v78, (float32x4_t)vbslq_s8(v15, (int8x16_t)v26, vbslq_s8(v77, (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v29.i8, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(v73, (float32x4_t)vshlq_n_s32(vaddq_s32(v75, vcvtq_s32_f32(v66)), 0x17uLL)), *(float32x4_t *)a2,
                                                                      3)))));
      v81 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, v79);
      v82 = (int8x16_t *)(v6 + v11);
      v82[-1] = vbslq_s8(v15, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      *v82 = vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v83 = -v10;
    if (v83 >= v5)
      goto LABEL_3;
LABEL_10:
    v84 = 16 * v83;
    v85 = *(float32x4_t *)(v7 + v84);
    v86 = *((int8x16_t *)a2 + 15);
    v87 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v85, 3), *((float32x4_t *)a2 + 16));
    v88 = vmulq_f32(vrecpeq_f32(v87), *((float32x4_t *)a2 + 18));
    v89 = vrecpsq_f32(v88, v87);
    v90 = vmulq_f32(v85, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v88, v89)), *((int8x16_t *)a2 + 3)));
    v91 = *((float32x4_t *)a2 + 75);
    v92 = (int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v89, (int8x16_t)v91);
    v93 = vminq_f32(vmaxq_f32(v90, v91), (float32x4_t)vdupq_laneq_s32(v92, 3));
    v94 = vaddq_f32(v93, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v95 = *((float32x4_t *)a2 + 5);
    v96 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v94), (int8x16_t)v95);
    v97 = (float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vcgtq_f32(v96, *((float32x4_t *)a2 + 23)));
    v98 = vsubq_f32(vsubq_f32(v96, v95), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v97), v96));
    v99 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v94, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v94))), *((float32x4_t *)a2 + 22)), v97), vmulq_f32(v98, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v98, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v98, v98), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v98)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v100 = vcvtq_f32_s32(vcvtq_s32_f32(v99));
    v101 = vsubq_f32(v100, (float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vcgtq_f32(v100, v99)));
    v102 = vsubq_f32(v99, v101);
    v103 = (float32x4_t)vbslq_s8(v86, (int8x16_t)v90, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(v86, (int8x16_t)v90, vbslq_s8((int8x16_t)vcgtq_f32(v91, vsubq_f32(v93, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v92.i8, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(
                                                                         v95,
                                                                         vmulq_f32(v102, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v102, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v102)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v101)), 0x17uLL)), *(float32x4_t *)a2, 3)))));
    *(int8x16_t *)(v6 + v84) = vbslq_s8(v86, (int8x16_t)v90, (int8x16_t)vmulq_laneq_f32(v103, v103, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype2_niceTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  int8x16_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = 16 * *((int *)a1 + 22);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((int8x16_t *)a2 + 15);
        v13 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3), *((float32x4_t *)a2 + 16));
        v14 = vrecpeq_f32(v13);
        v15 = vrecpsq_f32(v14, v13);
        v16 = vmulq_f32(v14, v15);
        v17 = vmulq_f32(v11, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v16, vrecpsq_f32(v16, v13))), *((int8x16_t *)a2 + 3)));
        v18 = *((float32x4_t *)a2 + 75);
        v19 = (int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v15, (int8x16_t)v18);
        v20 = vminq_f32(vmaxq_f32(v17, v18), (float32x4_t)vdupq_laneq_s32(v19, 3));
        v21 = *((float32x4_t *)a2 + 5);
        v22 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v18)), v18), (int8x16_t)v21, (int8x16_t)vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v23 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v22), (int8x16_t)v21);
        v24 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v23, *((float32x4_t *)a2 + 23)));
        v25 = vsubq_f32(vsubq_f32(v23, v21), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v24), v23));
        v26 = vmulq_f32(v25, v25);
        v27 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v22, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v22))), *((float32x4_t *)a2 + 22)), v24), vmulq_f32(v25, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v25, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v25)),
                            vmulq_f32(v26, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v25)), vmulq_f32(v26, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v25)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
        v28 = vcvtq_f32_s32(vcvtq_s32_f32(v27));
        v29 = vsubq_f32(v28, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v28, v27)));
        v30 = vsubq_f32(v27, v29);
        v31 = (float32x4_t)vbslq_s8(v12, (int8x16_t)v17, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(v12, (int8x16_t)v17, vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v19.i8, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(
                                                                            v21,
                                                                            vmulq_f32(v30, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v30, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v30)), vmulq_f32(vmulq_f32(v30, v30), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v30)))))))), (float32x4_t)vshlq_n_s32(
                                                                                         vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v29)), 0x17uLL)), *(float32x4_t *)a2, 3)))));
        *(int8x16_t *)(v7 + v10) = vbslq_s8(v12, (int8x16_t)v17, (int8x16_t)vmulq_laneq_f32(v31, v31, 3));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v6;
      v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype2_floatTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  int8x16_t v40;
  int8x16_t v41;
  int8x16_t v42;
  float32x4_t v43;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 2);
    v7 = 16 * *((int *)a1 + 22);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((float32x4_t *)a2 + 72);
        v13 = *((float32x4_t *)a2 + 73);
        v14 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v11, v12), 3), v12), v13);
        v15 = vminq_f32(vmaxq_f32(vrecpeq_f32(v14), v12), v13);
        v16 = vrecpsq_f32(v14, v15);
        v17 = vminq_f32(vmaxq_f32(vmulq_f32(v15, v16), v12), v13);
        v18 = vmulq_f32(v17, vrecpsq_f32(v14, v17));
        v18.i32[3] = 1.0;
        v19 = vmulq_f32(v11, v18);
        v20 = *((float32x4_t *)a2 + 75);
        v21 = (int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 74), (int8x16_t)v16, (int8x16_t)v20);
        v22 = vminq_f32(vmaxq_f32(v19, v20), (float32x4_t)vdupq_laneq_s32(v21, 3));
        v23 = *((float32x4_t *)a2 + 5);
        v24 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v20)), v20), (int8x16_t)v23, (int8x16_t)vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v25 = *((int8x16_t *)a2 + 52);
        v26 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v24);
        v27 = (int8x16_t)vmulq_f32(v24, vaddq_f32(v23, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 49), v26)));
        v28 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), v27), (int8x16_t)v23);
        v29 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v24, *((float32x4_t *)a2 + 21))), vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v24, *((float32x4_t *)a2 + 50)), *((int8x16_t *)a2 + 51)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v24, *((float32x4_t *)a2 + 50)))), (float32x4_t)vandq_s8(v25, v26))), *((float32x4_t *)a2 + 22)), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)));
        v30 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v28, *((float32x4_t *)a2 + 23)));
        v31 = vaddq_f32(v29, v30);
        v32 = vsubq_f32(vsubq_f32(v28, v23), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v30), v28));
        v33 = vmulq_f32(v32, v32);
        v34 = vmulq_n_f32(vaddq_f32(v31, vmulq_f32(v32, vaddq_f32(*((float32x4_t *)a2 + 61), vmulq_f32(v32, vaddq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 59), vmulq_f32(*((float32x4_t *)a2 + 60), v32)), vmulq_f32(v33, vaddq_f32(*((float32x4_t *)a2 + 57), vmulq_f32(*((float32x4_t *)a2 + 58), v32)))), vmulq_f32(vmulq_f32(v33, v33), vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 55), vmulq_f32(*((float32x4_t *)a2 + 56), v32)), vmulq_f32(
                                v33,
                                vaddq_f32(*((float32x4_t *)a2 + 53), vmulq_f32(*((float32x4_t *)a2 + 54), v32)))))))))),
                COERCE_FLOAT(*(_OWORD *)a2));
        v35 = vminq_f32(vmaxq_f32(v34, *((float32x4_t *)a2 + 62)), *((float32x4_t *)a2 + 63));
        v36 = vcvtq_f32_s32(vcvtq_s32_f32(v35));
        v37 = vsubq_f32(v36, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v36, v35)));
        v38 = vsubq_f32(v35, v37);
        v39 = vmulq_f32(v38, v38);
        v40 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 70), v37);
        v41 = vbslq_s8((int8x16_t)vcgtq_f32(v20, vsubq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v21.i8, 0), (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v23, vorrq_s8((int8x16_t)vcltzq_f32(v34), (int8x16_t)vcgezq_f32(v34))), v20), (int8x16_t)vmulq_f32(vaddq_f32(v23, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 71), v40)), vmulq_f32(vaddq_f32(
                                                             v23,
                                                             vmulq_f32(v38, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 68), vmulq_f32(v38, *((float32x4_t *)a2 + 69))), vmulq_f32(v39, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 66), vmulq_f32(*((float32x4_t *)a2 + 67), v38)), vmulq_f32(v39, vaddq_f32(*((float32x4_t *)a2 + 64), vmulq_f32(*((float32x4_t *)a2 + 65), v38)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33),
                                                                            vcvtq_s32_f32(vaddq_f32(v37, (float32x4_t)vandq_s8(v25, v40)))), 0x17uLL))), (int8x16_t)v34), *(float32x4_t *)a2, 3));
        v42 = *((int8x16_t *)a2 + 15);
        v43 = (float32x4_t)vbslq_s8(v42, (int8x16_t)v19, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(v42, (int8x16_t)v19, v41)));
        *(int8x16_t *)(v6 + v10) = vbslq_s8(v42, (int8x16_t)v19, (int8x16_t)vmulq_laneq_f32(v43, v43, 3));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v7;
      v6 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype3_fast_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  __int128 v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  int8x16_t *v80;
  uint64_t v81;
  int8x16_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v81) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v17 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15));
      v18 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15));
      v19 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v15));
      v20 = *((int8x16_t *)a2 + 17);
      v21 = vandq_s8(v20, v17);
      v22 = vandq_s8(v20, v18);
      v23 = vandq_s8(v20, v19);
      v24 = *((int8x16_t *)a2 + 3);
      v25 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v21, v24));
      v26 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v22, v24));
      v27 = vmulq_f32(v14, (float32x4_t)vorrq_s8(v23, v24));
      v28 = *((float32x4_t *)a2 + 75);
      v29 = *((float32x4_t *)a2 + 5);
      v30 = *((float32x4_t *)a2 + 6);
      v31 = vminq_f32(vmaxq_f32(v25, v28), v29);
      v32 = vminq_f32(vmaxq_f32(v26, v28), v29);
      v33 = *((_OWORD *)a2 + 1);
      v34 = vminq_f32(vmaxq_f32(v27, v28), v29);
      v35 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v36 = vmulq_f32(v30, vcvtq_f32_s32((int32x4_t)vaddq_f32(v31, v35)));
      v37 = vmulq_f32(v30, vcvtq_f32_s32((int32x4_t)vaddq_f32(v32, v35)));
      v38 = vmulq_f32(v30, vcvtq_f32_s32((int32x4_t)vaddq_f32(v34, v35)));
      v39 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
      v40 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
      v41 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
      v42 = *((float32x4_t *)a2 + 7);
      v43 = *((float32x4_t *)a2 + 8);
      v44 = vrsqrteq_f32(vaddq_f32(v42, vsubq_f32(v36, v39)));
      v45 = vrsqrteq_f32(vaddq_f32(v42, vsubq_f32(v37, v40)));
      v46 = vaddq_f32(v43, v39);
      v47 = vrsqrteq_f32(vaddq_f32(v42, vsubq_f32(v38, v41)));
      v48 = vaddq_f32(v43, v40);
      v49 = vaddq_f32(v43, v41);
      v50 = *((float32x4_t *)a2 + 9);
      v51 = *((float32x4_t *)a2 + 10);
      v52 = vmulq_n_f32(vsubq_f32(v46, vmulq_f32(v44, v50)), COERCE_FLOAT(*(_OWORD *)a2));
      v53 = vmulq_n_f32(vsubq_f32(v48, vmulq_f32(v45, v50)), COERCE_FLOAT(*(_OWORD *)a2));
      v54 = vmulq_n_f32(vsubq_f32(v49, vmulq_f32(v47, v50)), COERCE_FLOAT(*(_OWORD *)a2));
      v55 = vcvtq_f32_s32(vcvtq_s32_f32(v52));
      v56 = vcvtq_f32_s32(vcvtq_s32_f32(v53));
      v57 = vcvtq_f32_s32(vcvtq_s32_f32(v54));
      v58 = vsubq_f32(v55, (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v55, v52)));
      v59 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v56, v53)));
      v60 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v57, v54)));
      v61 = *((float32x4_t *)a2 + 11);
      v62 = *((float32x4_t *)a2 + 12);
      v63 = vmulq_f32(vrecpeq_f32(vsubq_f32(v61, vsubq_f32(v52, v58))), v62);
      v64 = vmulq_f32(vrecpeq_f32(vsubq_f32(v61, vsubq_f32(v53, v59))), v62);
      v65 = vmulq_f32(vrecpeq_f32(vsubq_f32(v61, vsubq_f32(v54, v60))), v62);
      v66 = vmaxq_f32(vaddq_f32(vaddq_f32(v51, v58), vmulq_f32(v63, v63)), v28);
      v67 = vmaxq_f32(vaddq_f32(vaddq_f32(v51, v59), vmulq_f32(v64, v64)), v28);
      v68 = *((float32x4_t *)a2 + 13);
      v69 = *((float32x4_t *)a2 + 14);
      v70 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v67, v68), v69));
      v71 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(v51, v60), vmulq_f32(v65, v65)), v28), v68), v69));
      v72 = (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v66, v68), v69)), *(float32x4_t *)a2, 3);
      v73 = (int8x16_t)vmulq_n_f32(v31, *(float *)&v33);
      v74 = (int8x16_t)vmulq_n_f32(v32, *(float *)&v33);
      v75 = (int8x16_t)vmulq_n_f32(v34, *(float *)&v33);
      v76 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v33, 1);
      v77 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v25, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v28, vsubq_f32(v31, v76)), v73, v72), v29));
      v78 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v26, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v28, vsubq_f32(v32, v76)), v74, (int8x16_t)vmulq_laneq_f32(v70, *(float32x4_t *)a2, 3)), v29));
      v79 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v27, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v28, vsubq_f32(v34, v76)), v75, (int8x16_t)vmulq_laneq_f32(v71, *(float32x4_t *)a2, 3)), v29));
      v80 = (int8x16_t *)(v6 + v10);
      *v80 = vbslq_s8(v16, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v77, v77, 3));
      v80[1] = vbslq_s8(v16, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v78, v78, 3));
      v80[2] = vbslq_s8(v16, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v79, v79, 3));
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v81) = -v11;
    if ((int)v81 >= v5)
      goto LABEL_3;
LABEL_10:
    v81 = v81;
    do
    {
      v82 = *((int8x16_t *)a2 + 15);
      v83 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v81), (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v7 + 16 * v81), 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
      v84 = *((float32x4_t *)a2 + 75);
      v85 = *((float32x4_t *)a2 + 5);
      v86 = vminq_f32(vmaxq_f32(v83, v84), v85);
      v87 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v86, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
      v88 = vcvtq_f32_s32(vcvtq_s32_f32(v87));
      v89 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v88), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v87, v88))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
      v90 = vcvtq_f32_s32(vcvtq_s32_f32(v89));
      v91 = vsubq_f32(v90, (float32x4_t)vandq_s8((int8x16_t)v85, (int8x16_t)vcgtq_f32(v90, v89)));
      v92 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v89, v91))), *((float32x4_t *)a2 + 12));
      v93 = (float32x4_t)vbslq_s8(v82, (int8x16_t)v83, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v84, vsubq_f32(v86, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v86, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v92, v92),
                                                                                           vaddq_f32(*((float32x4_t *)a2 + 10), v91)), v84), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))), *(float32x4_t *)a2, 3)), v85));
      *(int8x16_t *)(v6 + 16 * v81++) = vbslq_s8(v82, (int8x16_t)v83, (int8x16_t)vmulq_laneq_f32(v93, v93, 3));
    }
    while (v81 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype3_fixed_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  __int128 v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t v75;
  int8x16_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  int8x16_t *v81;
  uint64_t v82;
  int8x16_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v82) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v15);
      v18 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15));
      v19 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15));
      v21 = *((int8x16_t *)a2 + 17);
      v20 = *((float32x4_t *)a2 + 18);
      v22 = vandq_s8(v21, (int8x16_t)vmulq_f32(v18, v20));
      v23 = vandq_s8(v21, (int8x16_t)vmulq_f32(v19, v20));
      v24 = vandq_s8(v21, (int8x16_t)vmulq_f32(vrecpeq_f32(v17), v20));
      v25 = *((int8x16_t *)a2 + 3);
      v26 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v25));
      v27 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v23, v25));
      v28 = vmulq_f32(v14, (float32x4_t)vorrq_s8(v24, v25));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = *((float32x4_t *)a2 + 6);
      v32 = vminq_f32(vmaxq_f32(v26, v29), v30);
      v33 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v34 = *((_OWORD *)a2 + 1);
      v35 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v36 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v37 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)vaddq_f32(v32, v36)));
      v38 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)vaddq_f32(v33, v36)));
      v39 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)vaddq_f32(v35, v36)));
      v40 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
      v41 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
      v42 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v43 = *((float32x4_t *)a2 + 7);
      v44 = *((float32x4_t *)a2 + 8);
      v45 = vrsqrteq_f32(vaddq_f32(v43, vsubq_f32(v37, v40)));
      v46 = vrsqrteq_f32(vaddq_f32(v43, vsubq_f32(v38, v41)));
      v47 = vaddq_f32(v44, v40);
      v48 = vrsqrteq_f32(vaddq_f32(v43, vsubq_f32(v39, v42)));
      v49 = vaddq_f32(v44, v41);
      v50 = vaddq_f32(v44, v42);
      v51 = *((float32x4_t *)a2 + 9);
      v52 = *((float32x4_t *)a2 + 10);
      v53 = vmulq_n_f32(vsubq_f32(v47, vmulq_f32(v45, v51)), COERCE_FLOAT(*(_OWORD *)a2));
      v54 = vmulq_n_f32(vsubq_f32(v49, vmulq_f32(v46, v51)), COERCE_FLOAT(*(_OWORD *)a2));
      v55 = vmulq_n_f32(vsubq_f32(v50, vmulq_f32(v48, v51)), COERCE_FLOAT(*(_OWORD *)a2));
      v56 = vcvtq_f32_s32(vcvtq_s32_f32(v53));
      v57 = vcvtq_f32_s32(vcvtq_s32_f32(v54));
      v58 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      v59 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v56, v53)));
      v60 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v57, v54)));
      v61 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v58, v55)));
      v62 = *((float32x4_t *)a2 + 11);
      v63 = *((float32x4_t *)a2 + 12);
      v64 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v53, v59))), v63);
      v65 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v54, v60))), v63);
      v66 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v55, v61))), v63);
      v67 = vmaxq_f32(vaddq_f32(vaddq_f32(v52, v59), vmulq_f32(v64, v64)), v29);
      v68 = vmaxq_f32(vaddq_f32(vaddq_f32(v52, v60), vmulq_f32(v65, v65)), v29);
      v69 = *((float32x4_t *)a2 + 13);
      v70 = *((float32x4_t *)a2 + 14);
      v71 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v68, v69), v70));
      v72 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(v52, v61), vmulq_f32(v66, v66)), v29), v69), v70));
      v73 = (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v67, v69), v70)), *(float32x4_t *)a2, 3);
      v74 = (int8x16_t)vmulq_n_f32(v32, *(float *)&v34);
      v75 = (int8x16_t)vmulq_n_f32(v33, *(float *)&v34);
      v76 = (int8x16_t)vmulq_n_f32(v35, *(float *)&v34);
      v77 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v34, 1);
      v78 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v26, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v77)), v74, v73), v30));
      v79 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v27, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v33, v77)), v75, (int8x16_t)vmulq_laneq_f32(v71, *(float32x4_t *)a2, 3)), v30));
      v80 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v28, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v35, v77)), v76, (int8x16_t)vmulq_laneq_f32(v72, *(float32x4_t *)a2, 3)), v30));
      v81 = (int8x16_t *)(v6 + v10);
      *v81 = vbslq_s8(v16, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v78, v78, 3));
      v81[1] = vbslq_s8(v16, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v79, v79, 3));
      v81[2] = vbslq_s8(v16, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v82) = -v11;
    if ((int)v82 >= v5)
      goto LABEL_3;
LABEL_10:
    v82 = v82;
    do
    {
      v83 = *((int8x16_t *)a2 + 15);
      v84 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v82), (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v7 + 16 * v82), 3), *((float32x4_t *)a2 + 16))), *((float32x4_t *)a2 + 18))), *((int8x16_t *)a2 + 3)));
      v85 = *((float32x4_t *)a2 + 75);
      v86 = *((float32x4_t *)a2 + 5);
      v87 = vminq_f32(vmaxq_f32(v84, v85), v86);
      v88 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v87, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
      v89 = vcvtq_f32_s32(vcvtq_s32_f32(v88));
      v90 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v89), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v88, v89))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
      v91 = vcvtq_f32_s32(vcvtq_s32_f32(v90));
      v92 = vsubq_f32(v91, (float32x4_t)vandq_s8((int8x16_t)v86, (int8x16_t)vcgtq_f32(v91, v90)));
      v93 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v90, v92))), *((float32x4_t *)a2 + 12));
      v94 = (float32x4_t)vbslq_s8(v83, (int8x16_t)v84, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v85, vsubq_f32(v87, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v87, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v93, v93),
                                                                                           vaddq_f32(*((float32x4_t *)a2 + 10), v92)), v85), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))), *(float32x4_t *)a2, 3)), v86));
      *(int8x16_t *)(v6 + 16 * v82++) = vbslq_s8(v83, (int8x16_t)v84, (int8x16_t)vmulq_laneq_f32(v94, v94, 3));
    }
    while (v82 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype3_nice_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  __int128 v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  int8x16_t v92;
  int8x16_t v93;
  float32x4_t v94;
  int8x16_t v95;
  int8x16_t v96;
  float32x4_t v97;
  float32x4_t v98;
  int8x16_t *v99;
  int v100;
  uint64_t v101;
  float32x4_t v102;
  int8x16_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v100 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = *((int8x16_t *)a2 + 17);
      v24 = vandq_s8(v23, v22);
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v32 = *((_OWORD *)a2 + 1);
      v33 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v34 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v35 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v29)), v29);
      v36 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v30, (int8x16_t)vaddq_f32(v31, v33));
      v37 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v30, (int8x16_t)vaddq_f32(v34, v33));
      v38 = *((int8x16_t *)a2 + 19);
      v39 = *((float32x4_t *)a2 + 20);
      v40 = (float32x4_t)vorrq_s8(vandq_s8(v38, (int8x16_t)v36), (int8x16_t)v30);
      v41 = *((int8x16_t *)a2 + 21);
      v42 = *((float32x4_t *)a2 + 22);
      v43 = (float32x4_t)vorrq_s8(vandq_s8(v38, (int8x16_t)v37), (int8x16_t)v30);
      v44 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x17uLL)), (float32x4_t)vandq_s8(v41, (int8x16_t)vcgtq_f32(v39, v37)));
      v45 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v36, 0x17uLL)), (float32x4_t)vandq_s8(v41, (int8x16_t)vcgtq_f32(v39, v36))), v42);
      v46 = *((float32x4_t *)a2 + 23);
      v47 = *((float32x4_t *)a2 + 24);
      v48 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v40, v46));
      v49 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v43, v46));
      v50 = vaddq_f32(v45, v48);
      v51 = vmulq_f32(v47, v48);
      v52 = vmulq_f32(vmulq_f32(v47, v49), v43);
      v53 = vaddq_f32(vsubq_f32(v44, v42), v49);
      v54 = vsubq_f32(vsubq_f32(v40, v30), vmulq_f32(v51, v40));
      v55 = vsubq_f32(vsubq_f32(v43, v30), v52);
      v56 = *((float32x4_t *)a2 + 37);
      v57 = *((float32x4_t *)a2 + 38);
      v58 = vmulq_f32(v54, v54);
      v59 = *((float32x4_t *)a2 + 39);
      v60 = *((float32x4_t *)a2 + 40);
      v61 = vaddq_f32(v56, vmulq_f32(v57, v54));
      v62 = vaddq_f32(v59, vmulq_f32(v60, v54));
      v63 = vaddq_f32(v59, vmulq_f32(v60, v55));
      v64 = *((float32x4_t *)a2 + 41);
      v65 = *((float32x4_t *)a2 + 42);
      v66 = vaddq_f32(v56, vmulq_f32(v57, v55));
      v67 = vaddq_f32(v64, vmulq_f32(v65, v54));
      v68 = vaddq_f32(v64, vmulq_f32(v65, v55));
      v69 = vmulq_f32(v55, v55);
      v70 = vmulq_f32(v54, vaddq_f32(v67, vmulq_f32(v58, vaddq_f32(v61, vmulq_f32(v58, v62)))));
      v71 = *((float32x4_t *)a2 + 43);
      v72 = *((float32x4_t *)a2 + 44);
      v73 = vmulq_n_f32(vaddq_f32(v53, vmulq_f32(v55, vaddq_f32(v71, vmulq_f32(v55, vaddq_f32(v68, vmulq_f32(v69, vaddq_f32(v66, vmulq_f32(v69, v63)))))))), COERCE_FLOAT(*(_OWORD *)a2));
      v74 = *((float32x4_t *)a2 + 29);
      v75 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v50, vmulq_f32(v54, vaddq_f32(v71, v70))), COERCE_FLOAT(*(_OWORD *)a2)), v74);
      v76 = vmaxq_f32(v73, v74);
      v77 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v76));
      v79 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v77, v75)));
      v80 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v78, v76)));
      v81 = vsubq_f32(v75, v79);
      v82 = vsubq_f32(v76, v80);
      v83 = *((float32x4_t *)a2 + 45);
      v84 = *((float32x4_t *)a2 + 46);
      v85 = vaddq_f32(v72, vmulq_f32(v83, v81));
      v86 = vaddq_f32(v72, vmulq_f32(v83, v82));
      v87 = *((float32x4_t *)a2 + 47);
      v88 = *((float32x4_t *)a2 + 48);
      v89 = *((int32x4_t *)a2 + 33);
      v90 = vmulq_f32(vaddq_f32(v30, vmulq_f32(v81, vaddq_f32(v88, vmulq_f32(v81, vaddq_f32(vaddq_f32(v84, vmulq_f32(v81, v87)), vmulq_f32(vmulq_f32(v81, v81), v85)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v89, vcvtq_s32_f32(v79)), 0x17uLL));
      v91 = vmulq_f32(vaddq_f32(v30, vmulq_f32(v82, vaddq_f32(v88, vmulq_f32(v82, vaddq_f32(vaddq_f32(v84, vmulq_f32(v87, v82)), vmulq_f32(vmulq_f32(v82, v82), v86)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v89, vcvtq_s32_f32(v80)), 0x17uLL));
      v92 = (int8x16_t)vmulq_n_f32(v31, *(float *)&v32);
      v93 = (int8x16_t)vmulq_n_f32(v34, *(float *)&v32);
      v94 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v32, 1);
      v95 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v31, v94)), v92, (int8x16_t)vmulq_laneq_f32(v90, *(float32x4_t *)a2, 3)), v30);
      v96 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v34, v94)), v93, (int8x16_t)vmulq_laneq_f32(v91, *(float32x4_t *)a2, 3)), v30);
      v97 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, v95);
      v98 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, v96);
      v99 = (int8x16_t *)(v6 + v11);
      v99[-1] = vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v97, v97, 3));
      *v99 = vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v98, v98, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v100 = -v10;
    if (v100 >= v5)
      goto LABEL_3;
LABEL_10:
    v101 = 16 * v100;
    v102 = *(float32x4_t *)(v7 + v101);
    v103 = *((int8x16_t *)a2 + 15);
    v104 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v102, 3), *((float32x4_t *)a2 + 16));
    v105 = vrecpeq_f32(v104);
    v106 = vmulq_f32(v105, vrecpsq_f32(v105, v104));
    v107 = vmulq_f32(v102, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v106, vrecpsq_f32(v106, v104))), *((int8x16_t *)a2 + 3)));
    v108 = *((float32x4_t *)a2 + 75);
    v109 = *((float32x4_t *)a2 + 5);
    v110 = vminq_f32(vmaxq_f32(v107, v108), v109);
    v111 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v109, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v108)), v108), (int8x16_t)v109, (int8x16_t)vaddq_f32(v110, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
    v112 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v111), (int8x16_t)v109);
    v113 = (float32x4_t)vandq_s8((int8x16_t)v109, (int8x16_t)vcgtq_f32(v112, *((float32x4_t *)a2 + 23)));
    v114 = vsubq_f32(vsubq_f32(v112, v109), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v113), v112));
    v115 = vmulq_f32(v114, v114);
    v116 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v111, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v111))), *((float32x4_t *)a2 + 22)), v113), vmulq_f32(v114, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v114, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v114)),
                         vmulq_f32(v115, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v114)), vmulq_f32(v115, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v114)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
    v117 = vcvtq_f32_s32(vcvtq_s32_f32(v116));
    v118 = vsubq_f32(v117, (float32x4_t)vandq_s8((int8x16_t)v109, (int8x16_t)vcgtq_f32(v117, v116)));
    v119 = vsubq_f32(v116, v118);
    v120 = (float32x4_t)vbslq_s8(v103, (int8x16_t)v107, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v108, vsubq_f32(v110, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v110, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v109, vmulq_f32(v119, vaddq_f32(
                                                                           *((float32x4_t *)a2 + 48),
                                                                           vmulq_f32(v119, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v119)), vmulq_f32(vmulq_f32(v119, v119), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v119)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v118)), 0x17uLL)),
                                                                   *(float32x4_t *)a2,
                                                                   3)),
                                       v109));
    *(int8x16_t *)(v6 + v101) = vbslq_s8(v103, (int8x16_t)v107, (int8x16_t)vmulq_laneq_f32(v120, v120, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype3_half_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  __int128 v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  int32x4_t v71;
  int32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int8x16_t v75;
  int8x16_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  int8x16_t *v80;
  int v81;
  uint64_t v82;
  float32x4_t v83;
  int8x16_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v81 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23));
      v26 = *((float32x4_t *)a2 + 75);
      v27 = *((float32x4_t *)a2 + 5);
      v28 = vminq_f32(vmaxq_f32(v24, v26), v27);
      v29 = vminq_f32(vmaxq_f32(v25, v26), v27);
      v30 = *((_OWORD *)a2 + 1);
      v31 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v32 = vaddq_f32(v28, v31);
      v33 = vaddq_f32(v29, v31);
      v34 = *((int8x16_t *)a2 + 19);
      v35 = *((float32x4_t *)a2 + 20);
      v36 = (float32x4_t)vorrq_s8(vandq_s8(v34, (int8x16_t)v32), (int8x16_t)v27);
      v37 = (float32x4_t)vorrq_s8(vandq_s8(v34, (int8x16_t)v33), (int8x16_t)v27);
      v38 = *((int8x16_t *)a2 + 21);
      v39 = *((float32x4_t *)a2 + 22);
      v40 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v33, 0x17uLL)), (float32x4_t)vandq_s8(v38, (int8x16_t)vcgtq_f32(v35, v33)));
      v41 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v32, 0x17uLL)), (float32x4_t)vandq_s8(v38, (int8x16_t)vcgtq_f32(v35, v32))), v39);
      v42 = *((float32x4_t *)a2 + 23);
      v43 = *((float32x4_t *)a2 + 24);
      v44 = vsubq_f32(v40, v39);
      v45 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v36, v42));
      v46 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v37, v42));
      v47 = vaddq_f32(v41, v45);
      v48 = vsubq_f32(vsubq_f32(v36, v27), vmulq_f32(vmulq_f32(v43, v45), v36));
      v49 = vsubq_f32(vsubq_f32(v37, v27), vmulq_f32(vmulq_f32(v43, v46), v37));
      v50 = *((float32x4_t *)a2 + 25);
      v51 = *((float32x4_t *)a2 + 26);
      v52 = vaddq_f32(v50, vmulq_f32(v51, v48));
      v53 = vaddq_f32(v50, vmulq_f32(v51, v49));
      v54 = *((float32x4_t *)a2 + 27);
      v55 = *((float32x4_t *)a2 + 28);
      v56 = vmulq_n_f32(vaddq_f32(vaddq_f32(v44, v46), vmulq_f32(v49, vaddq_f32(vaddq_f32(v54, vmulq_f32(v55, v49)), vmulq_f32(vmulq_f32(v49, v49), v53)))), COERCE_FLOAT(*(_OWORD *)a2));
      v57 = *((float32x4_t *)a2 + 29);
      v58 = *((float32x4_t *)a2 + 30);
      v59 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v47, vmulq_f32(v48, vaddq_f32(vaddq_f32(v54, vmulq_f32(v55, v48)), vmulq_f32(vmulq_f32(v48, v48), v52)))), COERCE_FLOAT(*(_OWORD *)a2)), v57);
      v60 = vmaxq_f32(v56, v57);
      v61 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v62 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v63 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v61, v59)));
      v64 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v62, v60)));
      v65 = vsubq_f32(v59, v63);
      v66 = vsubq_f32(v60, v64);
      v67 = *((float32x4_t *)a2 + 31);
      v68 = *((float32x4_t *)a2 + 32);
      v69 = vmulq_f32(v66, vaddq_f32(v68, vmulq_f32(v66, vaddq_f32(v58, vmulq_f32(v67, v66)))));
      v70 = vaddq_f32(v27, vmulq_f32(v65, vaddq_f32(v68, vmulq_f32(v65, vaddq_f32(v58, vmulq_f32(v67, v65))))));
      v71 = vcvtq_s32_f32(v64);
      v72 = *((int32x4_t *)a2 + 33);
      v73 = vmulq_f32(v70, (float32x4_t)vshlq_n_s32(vaddq_s32(v72, vcvtq_s32_f32(v63)), 0x17uLL));
      v74 = vmulq_f32(vaddq_f32(v27, v69), (float32x4_t)vshlq_n_s32(vaddq_s32(v72, v71), 0x17uLL));
      v75 = (int8x16_t)vmulq_n_f32(v28, *(float *)&v30);
      v76 = (int8x16_t)vmulq_n_f32(v29, *(float *)&v30);
      v77 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v30, 1);
      v78 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v28, v77)), v75, (int8x16_t)vmulq_laneq_f32(v73, *(float32x4_t *)a2, 3)), v27));
      v79 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v29, v77)), v76, (int8x16_t)vmulq_laneq_f32(v74, *(float32x4_t *)a2, 3)), v27));
      v80 = (int8x16_t *)(v6 + v11);
      v80[-1] = vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v78, v78, 3));
      *v80 = vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v79, v79, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v81 = -v10;
    if (v81 >= v5)
      goto LABEL_3;
LABEL_10:
    v82 = 16 * v81;
    v83 = *(float32x4_t *)(v7 + v82);
    v84 = *((int8x16_t *)a2 + 15);
    v85 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v83, 3), *((float32x4_t *)a2 + 16));
    v86 = vmulq_f32(vrecpeq_f32(v85), *((float32x4_t *)a2 + 18));
    v87 = vmulq_f32(v83, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v86, vrecpsq_f32(v86, v85))), *((int8x16_t *)a2 + 3)));
    v88 = *((float32x4_t *)a2 + 75);
    v89 = *((float32x4_t *)a2 + 5);
    v90 = vminq_f32(vmaxq_f32(v87, v88), v89);
    v91 = vaddq_f32(v90, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v92 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v91), (int8x16_t)v89);
    v93 = (float32x4_t)vandq_s8((int8x16_t)v89, (int8x16_t)vcgtq_f32(v92, *((float32x4_t *)a2 + 23)));
    v94 = vsubq_f32(vsubq_f32(v92, v89), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v93), v92));
    v95 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v91, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v91))), *((float32x4_t *)a2 + 22)), v93), vmulq_f32(v94, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(*((float32x4_t *)a2 + 28), v94)), vmulq_f32(vmulq_f32(v94, v94), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v94)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v96 = vcvtq_f32_s32(vcvtq_s32_f32(v95));
    v97 = vsubq_f32(v96, (float32x4_t)vandq_s8((int8x16_t)v89, (int8x16_t)vcgtq_f32(v96, v95)));
    v98 = vsubq_f32(v95, v97);
    v99 = (float32x4_t)vbslq_s8(v84, (int8x16_t)v87, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v88, vsubq_f32(v90, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v90, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v89, vmulq_f32(v98, vaddq_f32(
                                                                          *((float32x4_t *)a2 + 32),
                                                                          vmulq_f32(v98, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v98)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v97)), 0x17uLL)), *(float32x4_t *)a2, 3)), v89));
    *(int8x16_t *)(v6 + v82) = vbslq_s8(v84, (int8x16_t)v87, (int8x16_t)vmulq_laneq_f32(v99, v99, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype3_halfTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  __int128 v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  int32x4_t v79;
  int32x4_t v80;
  float32x4_t v81;
  int8x16_t v82;
  int8x16_t v83;
  int8x16_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  int8x16_t *v88;
  int v89;
  uint64_t v90;
  float32x4_t v91;
  int8x16_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v89 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vrecpsq_f32(v20, v16);
      v23 = vrecpsq_f32(v21, v17);
      v24 = (int8x16_t)vmulq_f32(v20, v22);
      v25 = vandq_s8(v19, (int8x16_t)vmulq_f32(v21, v23));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(vandq_s8(v19, v24), v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = (int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 76), (int8x16_t)v23, (int8x16_t)v29);
      v31 = vminq_f32(vmaxq_f32(v27, v29), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 76), (int8x16_t)v22, (int8x16_t)v29), 3));
      v32 = vminq_f32(vmaxq_f32(v28, v29), (float32x4_t)vdupq_laneq_s32(v30, 3));
      v33 = *((_OWORD *)a2 + 1);
      v34 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v35 = vaddq_f32(v31, v34);
      v36 = vaddq_f32(v32, v34);
      v37 = *((int8x16_t *)a2 + 19);
      v38 = *((float32x4_t *)a2 + 20);
      v39 = *((float32x4_t *)a2 + 5);
      v40 = (float32x4_t)vorrq_s8(vandq_s8(v37, (int8x16_t)v35), (int8x16_t)v39);
      v41 = *((int8x16_t *)a2 + 21);
      v42 = *((float32x4_t *)a2 + 22);
      v43 = (float32x4_t)vorrq_s8(vandq_s8(v37, (int8x16_t)v36), (int8x16_t)v39);
      v44 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v36, 0x17uLL)), (float32x4_t)vandq_s8(v41, (int8x16_t)vcgtq_f32(v38, v36)));
      v45 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v35, 0x17uLL)), (float32x4_t)vandq_s8(v41, (int8x16_t)vcgtq_f32(v38, v35))), v42);
      v46 = *((float32x4_t *)a2 + 23);
      v47 = *((float32x4_t *)a2 + 24);
      v48 = vsubq_f32(v44, v42);
      v49 = (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v40, v46));
      v50 = (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v43, v46));
      v51 = vmulq_f32(v47, v49);
      v52 = vaddq_f32(v45, v49);
      v53 = vmulq_f32(vmulq_f32(v47, v50), v43);
      v54 = vaddq_f32(v48, v50);
      v55 = vsubq_f32(vsubq_f32(v40, v39), vmulq_f32(v51, v40));
      v56 = vsubq_f32(vsubq_f32(v43, v39), v53);
      v57 = *((float32x4_t *)a2 + 25);
      v58 = *((float32x4_t *)a2 + 26);
      v59 = vaddq_f32(v57, vmulq_f32(v58, v55));
      v60 = vaddq_f32(v57, vmulq_f32(v58, v56));
      v61 = *((float32x4_t *)a2 + 27);
      v62 = *((float32x4_t *)a2 + 28);
      v63 = vmulq_n_f32(vaddq_f32(v52, vmulq_f32(v55, vaddq_f32(vaddq_f32(v61, vmulq_f32(v55, v62)), vmulq_f32(vmulq_f32(v55, v55), v59)))), COERCE_FLOAT(*(_OWORD *)a2));
      v64 = vmulq_n_f32(vaddq_f32(v54, vmulq_f32(v56, vaddq_f32(vaddq_f32(v61, vmulq_f32(v56, v62)), vmulq_f32(vmulq_f32(v56, v56), v60)))), COERCE_FLOAT(*(_OWORD *)a2));
      v65 = *((float32x4_t *)a2 + 29);
      v66 = *((float32x4_t *)a2 + 30);
      v67 = vmaxq_f32(v63, v65);
      v68 = vmaxq_f32(v64, v65);
      v69 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
      v70 = vcvtq_f32_s32(vcvtq_s32_f32(v68));
      v71 = vsubq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v69, v67)));
      v72 = vsubq_f32(v70, (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v70, v68)));
      v73 = vsubq_f32(v67, v71);
      v74 = vsubq_f32(v68, v72);
      v75 = *((float32x4_t *)a2 + 31);
      v76 = *((float32x4_t *)a2 + 32);
      v77 = vmulq_f32(v74, vaddq_f32(v76, vmulq_f32(v74, vaddq_f32(v66, vmulq_f32(v75, v74)))));
      v78 = vaddq_f32(v39, vmulq_f32(v73, vaddq_f32(v76, vmulq_f32(v73, vaddq_f32(v66, vmulq_f32(v75, v73))))));
      v79 = vcvtq_s32_f32(v72);
      v80 = *((int32x4_t *)a2 + 33);
      v81 = vmulq_f32(vaddq_f32(v39, v77), (float32x4_t)vshlq_n_s32(vaddq_s32(v80, v79), 0x17uLL));
      v82 = (int8x16_t)vmulq_laneq_f32(vmulq_f32(v78, (float32x4_t)vshlq_n_s32(vaddq_s32(v80, vcvtq_s32_f32(v71)), 0x17uLL)), *(float32x4_t *)a2, 3);
      v83 = (int8x16_t)vmulq_n_f32(v31, *(float *)&v33);
      v84 = (int8x16_t)vmulq_n_f32(v32, *(float *)&v33);
      v85 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v33, 1);
      v86 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v31, v85)), v83, v82));
      v87 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v85)), v84, (int8x16_t)vmulq_laneq_f32(v81, *(float32x4_t *)a2, 3)));
      v88 = (int8x16_t *)(v6 + v11);
      v88[-1] = vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v86, v86, 3));
      *v88 = vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v87, v87, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v89 = -v10;
    if (v89 >= v5)
      goto LABEL_3;
LABEL_10:
    v90 = 16 * v89;
    v91 = *(float32x4_t *)(v7 + v90);
    v92 = *((int8x16_t *)a2 + 15);
    v93 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v91, 3), *((float32x4_t *)a2 + 16));
    v94 = vmulq_f32(vrecpeq_f32(v93), *((float32x4_t *)a2 + 18));
    v95 = vrecpsq_f32(v94, v93);
    v96 = vmulq_f32(v91, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v94, v95)), *((int8x16_t *)a2 + 3)));
    v97 = *((float32x4_t *)a2 + 75);
    v98 = vminq_f32(vmaxq_f32(v96, v97), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 76), (int8x16_t)v95, (int8x16_t)v97), 3));
    v99 = vaddq_f32(v98, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v100 = *((float32x4_t *)a2 + 5);
    v101 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v99), (int8x16_t)v100);
    v102 = (float32x4_t)vandq_s8((int8x16_t)v100, (int8x16_t)vcgtq_f32(v101, *((float32x4_t *)a2 + 23)));
    v103 = vsubq_f32(vsubq_f32(v101, v100), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v102), v101));
    v104 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v99, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v99))), *((float32x4_t *)a2 + 22)), v102), vmulq_f32(v103, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v103, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v103, v103), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v103)))))), COERCE_FLOAT(*(_OWORD *)a2)),
             *((float32x4_t *)a2 + 29));
    v105 = vcvtq_f32_s32(vcvtq_s32_f32(v104));
    v106 = vsubq_f32(v105, (float32x4_t)vandq_s8((int8x16_t)v100, (int8x16_t)vcgtq_f32(v105, v104)));
    v107 = vsubq_f32(v104, v106);
    v108 = (float32x4_t)vbslq_s8(v92, (int8x16_t)v96, vbslq_s8((int8x16_t)vcgtq_f32(v97, vsubq_f32(v98, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v98, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v100, vmulq_f32(v107, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v107, vaddq_f32(*((float32x4_t *)a2 + 30),
                                                     vmulq_f32(*((float32x4_t *)a2 + 31), v107)))))),
                                           (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v106)), 0x17uLL)), *(float32x4_t *)a2, 3)));
    *(int8x16_t *)(v6 + v90) = vbslq_s8(v92, (int8x16_t)v96, (int8x16_t)vmulq_laneq_f32(v108, v108, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype3_niceTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  __int128 v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  int32x4_t v90;
  float32x4_t v91;
  int8x16_t v92;
  int8x16_t v93;
  int8x16_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  int8x16_t *v98;
  int v99;
  uint64_t v100;
  float32x4_t v101;
  int8x16_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v99 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vrecpsq_f32(v18, v16);
      v21 = vrecpsq_f32(v19, v17);
      v22 = vmulq_f32(v18, v20);
      v23 = vmulq_f32(v19, v21);
      v24 = (int8x16_t)vmulq_f32(v22, vrecpsq_f32(v22, v16));
      v25 = *((int8x16_t *)a2 + 17);
      v26 = vandq_s8(v25, v24);
      v27 = vandq_s8(v25, (int8x16_t)vmulq_f32(v23, vrecpsq_f32(v23, v17)));
      v28 = *((int8x16_t *)a2 + 3);
      v29 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v26, v28));
      v30 = *((float32x4_t *)a2 + 75);
      v31 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v27, v28));
      v32 = *((_OWORD *)a2 + 1);
      v33 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v34 = vminq_f32(vmaxq_f32(v29, v30), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 76), (int8x16_t)v20, (int8x16_t)v30), 3));
      v35 = vminq_f32(vmaxq_f32(v31, v30), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 76), (int8x16_t)v21, (int8x16_t)v30), 3));
      v36 = *((float32x4_t *)a2 + 5);
      v37 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v36, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v30)), v30);
      v38 = (float32x4_t)vbslq_s8(v37, (int8x16_t)v36, (int8x16_t)vaddq_f32(v34, v33));
      v39 = (float32x4_t)vbslq_s8(v37, (int8x16_t)v36, (int8x16_t)vaddq_f32(v35, v33));
      v41 = *((int8x16_t *)a2 + 19);
      v40 = *((float32x4_t *)a2 + 20);
      v42 = (float32x4_t)vorrq_s8(vandq_s8(v41, (int8x16_t)v38), (int8x16_t)v36);
      v43 = (float32x4_t)vorrq_s8(vandq_s8(v41, (int8x16_t)v39), (int8x16_t)v36);
      v44 = *((int8x16_t *)a2 + 21);
      v45 = *((float32x4_t *)a2 + 22);
      v46 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v39, 0x17uLL)), (float32x4_t)vandq_s8(v44, (int8x16_t)vcgtq_f32(v40, v39)));
      v47 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v38, 0x17uLL)), (float32x4_t)vandq_s8(v44, (int8x16_t)vcgtq_f32(v40, v38))), v45);
      v48 = *((float32x4_t *)a2 + 23);
      v49 = *((float32x4_t *)a2 + 24);
      v50 = (float32x4_t)vandq_s8((int8x16_t)v36, (int8x16_t)vcgtq_f32(v42, v48));
      v51 = (float32x4_t)vandq_s8((int8x16_t)v36, (int8x16_t)vcgtq_f32(v43, v48));
      v52 = vaddq_f32(v47, v50);
      v53 = vaddq_f32(vsubq_f32(v46, v45), v51);
      v54 = vsubq_f32(vsubq_f32(v42, v36), vmulq_f32(vmulq_f32(v49, v50), v42));
      v55 = vsubq_f32(vsubq_f32(v43, v36), vmulq_f32(vmulq_f32(v49, v51), v43));
      v56 = vmulq_f32(v54, v54);
      v57 = *((float32x4_t *)a2 + 37);
      v58 = *((float32x4_t *)a2 + 38);
      v59 = *((float32x4_t *)a2 + 39);
      v60 = *((float32x4_t *)a2 + 40);
      v61 = vaddq_f32(v57, vmulq_f32(v58, v54));
      v62 = vaddq_f32(v59, vmulq_f32(v60, v54));
      v63 = vaddq_f32(v59, vmulq_f32(v60, v55));
      v64 = vaddq_f32(v57, vmulq_f32(v58, v55));
      v65 = *((float32x4_t *)a2 + 41);
      v66 = *((float32x4_t *)a2 + 42);
      v67 = vaddq_f32(v65, vmulq_f32(v66, v54));
      v68 = vaddq_f32(v65, vmulq_f32(v66, v55));
      v69 = vmulq_f32(v55, v55);
      v70 = vaddq_f32(v67, vmulq_f32(v56, vaddq_f32(v61, vmulq_f32(v56, v62))));
      v71 = vaddq_f32(v68, vmulq_f32(v69, vaddq_f32(v64, vmulq_f32(v69, v63))));
      v72 = *((float32x4_t *)a2 + 43);
      v73 = *((float32x4_t *)a2 + 44);
      v74 = vmulq_n_f32(vaddq_f32(v53, vmulq_f32(v55, vaddq_f32(v72, vmulq_f32(v55, v71)))), COERCE_FLOAT(*(_OWORD *)a2));
      v75 = *((float32x4_t *)a2 + 29);
      v76 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v52, vmulq_f32(v54, vaddq_f32(v72, vmulq_f32(v54, v70)))), COERCE_FLOAT(*(_OWORD *)a2)), v75);
      v77 = vmaxq_f32(v74, v75);
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v76));
      v79 = vcvtq_f32_s32(vcvtq_s32_f32(v77));
      v80 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v36, (int8x16_t)vcgtq_f32(v78, v76)));
      v81 = vsubq_f32(v79, (float32x4_t)vandq_s8((int8x16_t)v36, (int8x16_t)vcgtq_f32(v79, v77)));
      v82 = vsubq_f32(v76, v80);
      v83 = vsubq_f32(v77, v81);
      v84 = *((float32x4_t *)a2 + 45);
      v85 = *((float32x4_t *)a2 + 46);
      v86 = vaddq_f32(v73, vmulq_f32(v84, v82));
      v87 = vaddq_f32(v73, vmulq_f32(v84, v83));
      v88 = *((float32x4_t *)a2 + 47);
      v89 = *((float32x4_t *)a2 + 48);
      v90 = *((int32x4_t *)a2 + 33);
      v91 = vmulq_f32(vaddq_f32(v36, vmulq_f32(v83, vaddq_f32(v89, vmulq_f32(v83, vaddq_f32(vaddq_f32(v85, vmulq_f32(v88, v83)), vmulq_f32(vmulq_f32(v83, v83), v87)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v90, vcvtq_s32_f32(v81)), 0x17uLL));
      v92 = (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v36, vmulq_f32(v82, vaddq_f32(v89, vmulq_f32(v82, vaddq_f32(vaddq_f32(v85, vmulq_f32(v82, v88)), vmulq_f32(vmulq_f32(v82, v82), v86)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v90, vcvtq_s32_f32(v80)), 0x17uLL)), *(float32x4_t *)a2, 3);
      v93 = (int8x16_t)vmulq_n_f32(v34, *(float *)&v32);
      v94 = (int8x16_t)vmulq_n_f32(v35, *(float *)&v32);
      v95 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v32, 1);
      v96 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v29, vbslq_s8((int8x16_t)vcgtq_f32(v30, vsubq_f32(v34, v95)), v93, v92));
      v97 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v31, vbslq_s8((int8x16_t)vcgtq_f32(v30, vsubq_f32(v35, v95)), v94, (int8x16_t)vmulq_laneq_f32(v91, *(float32x4_t *)a2, 3)));
      v98 = (int8x16_t *)(v6 + v11);
      v98[-1] = vbslq_s8(v15, (int8x16_t)v29, (int8x16_t)vmulq_laneq_f32(v96, v96, 3));
      *v98 = vbslq_s8(v15, (int8x16_t)v31, (int8x16_t)vmulq_laneq_f32(v97, v97, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v99 = -v10;
    if (v99 >= v5)
      goto LABEL_3;
LABEL_10:
    v100 = 16 * v99;
    v101 = *(float32x4_t *)(v7 + v100);
    v102 = *((int8x16_t *)a2 + 15);
    v103 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v101, 3), *((float32x4_t *)a2 + 16));
    v104 = vrecpeq_f32(v103);
    v105 = vrecpsq_f32(v104, v103);
    v106 = vmulq_f32(v104, v105);
    v107 = vmulq_f32(v101, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v106, vrecpsq_f32(v106, v103))), *((int8x16_t *)a2 + 3)));
    v108 = *((float32x4_t *)a2 + 75);
    v109 = vminq_f32(vmaxq_f32(v107, v108), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 76), (int8x16_t)v105, (int8x16_t)v108), 3));
    v110 = *((float32x4_t *)a2 + 5);
    v111 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v110, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v108)), v108), (int8x16_t)v110, (int8x16_t)vaddq_f32(v109, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
    v112 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v111), (int8x16_t)v110);
    v113 = (float32x4_t)vandq_s8((int8x16_t)v110, (int8x16_t)vcgtq_f32(v112, *((float32x4_t *)a2 + 23)));
    v114 = vsubq_f32(vsubq_f32(v112, v110), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v113), v112));
    v115 = vmulq_f32(v114, v114);
    v116 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v111, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v111))), *((float32x4_t *)a2 + 22)), v113), vmulq_f32(v114, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v114, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v114)),
                         vmulq_f32(v115, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v114)), vmulq_f32(v115, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v114)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
    v117 = vcvtq_f32_s32(vcvtq_s32_f32(v116));
    v118 = vsubq_f32(v117, (float32x4_t)vandq_s8((int8x16_t)v110, (int8x16_t)vcgtq_f32(v117, v116)));
    v119 = vsubq_f32(v116, v118);
    v120 = (float32x4_t)vbslq_s8(v102, (int8x16_t)v107, vbslq_s8((int8x16_t)vcgtq_f32(v108, vsubq_f32(v109, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v109, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v110, vmulq_f32(v119, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v119,
                                                   vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v119)), vmulq_f32(vmulq_f32(v119, v119), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v119)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v118)), 0x17uLL)), *(float32x4_t *)a2, 3)));
    *(int8x16_t *)(v6 + v100) = vbslq_s8(v102, (int8x16_t)v107, (int8x16_t)vmulq_laneq_f32(v120, v120, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype3_floatTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t v41;
  float32x4_t v42;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 2);
    v7 = 16 * *((int *)a1 + 22);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((float32x4_t *)a2 + 72);
        v13 = *((float32x4_t *)a2 + 73);
        v14 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v11, v12), 3), v12), v13);
        v15 = vminq_f32(vmaxq_f32(vrecpeq_f32(v14), v12), v13);
        v16 = vrecpsq_f32(v14, v15);
        v17 = vminq_f32(vmaxq_f32(vmulq_f32(v15, v16), v12), v13);
        v18 = vmulq_f32(v17, vrecpsq_f32(v14, v17));
        v18.i32[3] = 1.0;
        v19 = vmulq_f32(v11, v18);
        v20 = *((float32x4_t *)a2 + 75);
        v21 = vminq_f32(vmaxq_f32(v19, v20), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 76), (int8x16_t)v16, (int8x16_t)v20), 3));
        v22 = *((float32x4_t *)a2 + 5);
        v23 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v20)), v20), (int8x16_t)v22, (int8x16_t)vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v24 = *((int8x16_t *)a2 + 52);
        v25 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v23);
        v26 = (int8x16_t)vmulq_f32(v23, vaddq_f32(v22, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 49), v25)));
        v27 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), v26), (int8x16_t)v22);
        v28 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v23, *((float32x4_t *)a2 + 21))), vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v23, *((float32x4_t *)a2 + 50)), *((int8x16_t *)a2 + 51)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v23, *((float32x4_t *)a2 + 50)))), (float32x4_t)vandq_s8(v24, v25))), *((float32x4_t *)a2 + 22)), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x17uLL)));
        v29 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v27, *((float32x4_t *)a2 + 23)));
        v30 = vaddq_f32(v28, v29);
        v31 = vsubq_f32(vsubq_f32(v27, v22), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v29), v27));
        v32 = vmulq_f32(v31, v31);
        v33 = vmulq_n_f32(vaddq_f32(v30, vmulq_f32(v31, vaddq_f32(*((float32x4_t *)a2 + 61), vmulq_f32(v31, vaddq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 59), vmulq_f32(*((float32x4_t *)a2 + 60), v31)), vmulq_f32(v32, vaddq_f32(*((float32x4_t *)a2 + 57), vmulq_f32(*((float32x4_t *)a2 + 58), v31)))), vmulq_f32(vmulq_f32(v32, v32), vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 55), vmulq_f32(*((float32x4_t *)a2 + 56), v31)), vmulq_f32(
                                v32,
                                vaddq_f32(*((float32x4_t *)a2 + 53), vmulq_f32(*((float32x4_t *)a2 + 54), v31)))))))))),
                COERCE_FLOAT(*(_OWORD *)a2));
        v34 = vminq_f32(vmaxq_f32(v33, *((float32x4_t *)a2 + 62)), *((float32x4_t *)a2 + 63));
        v35 = vcvtq_f32_s32(vcvtq_s32_f32(v34));
        v36 = vsubq_f32(v35, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v35, v34)));
        v37 = vsubq_f32(v34, v36);
        v38 = vmulq_f32(v37, v37);
        v39 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 70), v36);
        v40 = vbslq_s8((int8x16_t)vcgtq_f32(v20, vsubq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v21, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v22, vorrq_s8((int8x16_t)vcltzq_f32(v33), (int8x16_t)vcgezq_f32(v33))), v20), (int8x16_t)vmulq_f32(vaddq_f32(v22, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 71), v39)), vmulq_f32(vaddq_f32(
                                                             v22,
                                                             vmulq_f32(v37, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 68), vmulq_f32(v37, *((float32x4_t *)a2 + 69))), vmulq_f32(v38, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 66), vmulq_f32(*((float32x4_t *)a2 + 67), v37)), vmulq_f32(v38, vaddq_f32(*((float32x4_t *)a2 + 64), vmulq_f32(*((float32x4_t *)a2 + 65), v37)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33),
                                                                            vcvtq_s32_f32(vaddq_f32(v36, (float32x4_t)vandq_s8(v24, v39)))), 0x17uLL))), (int8x16_t)v33), *(float32x4_t *)a2, 3));
        v41 = *((int8x16_t *)a2 + 15);
        v42 = (float32x4_t)vbslq_s8(v41, (int8x16_t)v19, v40);
        *(int8x16_t *)(v6 + v10) = vbslq_s8(v41, (int8x16_t)v19, (int8x16_t)vmulq_laneq_f32(v42, v42, 3));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v7;
      v6 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype4_fast_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  __int128 v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int8x16_t v77;
  int8x16_t v78;
  int8x16_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  int8x16_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  int8x16_t *v88;
  uint64_t v89;
  int8x16_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v89) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v17 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15));
      v18 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15));
      v19 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v15));
      v20 = *((int8x16_t *)a2 + 17);
      v21 = *((int8x16_t *)a2 + 3);
      v22 = vmulq_f32(v12, (float32x4_t)vorrq_s8(vandq_s8(v20, v17), v21));
      v23 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v20, v18), v21));
      v24 = vmulq_f32(v14, (float32x4_t)vorrq_s8(vandq_s8(v20, v19), v21));
      v25 = *((float32x4_t *)a2 + 75);
      v26 = *((float32x4_t *)a2 + 5);
      v27 = *((float32x4_t *)a2 + 6);
      v28 = vminq_f32(vmaxq_f32(v22, v25), v26);
      v29 = vminq_f32(vmaxq_f32(v23, v25), v26);
      v30 = *((_OWORD *)a2 + 1);
      v31 = vminq_f32(vmaxq_f32(v24, v25), v26);
      v32 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v33 = vmulq_f32(v27, vcvtq_f32_s32((int32x4_t)vaddq_f32(v28, v32)));
      v34 = vmulq_f32(v27, vcvtq_f32_s32((int32x4_t)vaddq_f32(v29, v32)));
      v35 = vmulq_f32(v27, vcvtq_f32_s32((int32x4_t)vaddq_f32(v31, v32)));
      v36 = vcvtq_f32_s32(vcvtq_s32_f32(v33));
      v37 = vcvtq_f32_s32(vcvtq_s32_f32(v34));
      v38 = vcvtq_f32_s32(vcvtq_s32_f32(v35));
      v39 = *((float32x4_t *)a2 + 7);
      v40 = *((float32x4_t *)a2 + 8);
      v41 = vrsqrteq_f32(vaddq_f32(v39, vsubq_f32(v33, v36)));
      v42 = vrsqrteq_f32(vaddq_f32(v39, vsubq_f32(v34, v37)));
      v43 = vaddq_f32(v40, v36);
      v44 = vaddq_f32(v40, v37);
      v45 = vrsqrteq_f32(vaddq_f32(v39, vsubq_f32(v35, v38)));
      v46 = vaddq_f32(v40, v38);
      v47 = *((float32x4_t *)a2 + 9);
      v48 = *((float32x4_t *)a2 + 10);
      v49 = vmulq_n_f32(vsubq_f32(v43, vmulq_f32(v41, v47)), COERCE_FLOAT(*(_OWORD *)a2));
      v50 = vmulq_n_f32(vsubq_f32(v44, vmulq_f32(v42, v47)), COERCE_FLOAT(*(_OWORD *)a2));
      v51 = vmulq_n_f32(vsubq_f32(v46, vmulq_f32(v45, v47)), COERCE_FLOAT(*(_OWORD *)a2));
      v52 = vcvtq_f32_s32(vcvtq_s32_f32(v49));
      v53 = vcvtq_f32_s32(vcvtq_s32_f32(v50));
      v54 = vcvtq_f32_s32(vcvtq_s32_f32(v51));
      v55 = vsubq_f32(v52, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v52, v49)));
      v56 = vsubq_f32(v53, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v53, v50)));
      v57 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v54, v51)));
      v58 = vsubq_f32(v49, v55);
      v59 = vsubq_f32(v50, v56);
      v60 = vsubq_f32(v51, v57);
      v61 = vaddq_f32(v48, v55);
      v62 = vaddq_f32(v48, v56);
      v63 = vaddq_f32(v48, v57);
      v64 = *((float32x4_t *)a2 + 11);
      v65 = *((float32x4_t *)a2 + 12);
      v66 = vmulq_f32(vrecpeq_f32(vsubq_f32(v64, v58)), v65);
      v67 = vmulq_f32(vrecpeq_f32(vsubq_f32(v64, v59)), v65);
      v68 = vmulq_f32(vrecpeq_f32(vsubq_f32(v64, v60)), v65);
      v69 = vmaxq_f32(vaddq_f32(v61, vmulq_f32(v66, v66)), v25);
      v70 = vmaxq_f32(vaddq_f32(v62, vmulq_f32(v67, v67)), v25);
      v71 = *((float32x4_t *)a2 + 13);
      v72 = *((float32x4_t *)a2 + 14);
      v73 = vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(v63, vmulq_f32(v68, v68)), v25), v71), v72);
      v74 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v69, v71), v72));
      v75 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v70, v71), v72));
      v76 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2);
      v77 = (int8x16_t)vmulq_n_f32(v28, *(float *)&v30);
      v78 = (int8x16_t)vmulq_n_f32(v29, *(float *)&v30);
      v79 = (int8x16_t)vmulq_n_f32(v31, *(float *)&v30);
      v80 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v30, 1);
      v81 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v82 = vaddq_f32(v81, (float32x4_t)vbslq_s8(v16, (int8x16_t)v22, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v25, vsubq_f32(v28, v80)), v77, (int8x16_t)vaddq_f32(v76, vmulq_laneq_f32(v74, *(float32x4_t *)a2, 3))), v26)));
      v83 = vmaxq_f32(vaddq_f32(v81, (float32x4_t)vbslq_s8(v16, (int8x16_t)v23, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v25, vsubq_f32(v29, v80)), v78, (int8x16_t)vaddq_f32(v76, vmulq_laneq_f32(v75, *(float32x4_t *)a2, 3))), v26))), v25);
      v84 = (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v81, (float32x4_t)vbslq_s8(v16, (int8x16_t)v24, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v25, vsubq_f32(v31, v80)), v79, (int8x16_t)vaddq_f32(v76, vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(v73), *(float32x4_t *)a2, 3))), v26))), v25), v26);
      v85 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v22, (int8x16_t)vminq_f32(vmaxq_f32(v82, v25), v26));
      v86 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v23, (int8x16_t)vminq_f32(v83, v26));
      v87 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v24, v84);
      v88 = (int8x16_t *)(v6 + v10);
      *v88 = vbslq_s8(v16, (int8x16_t)v22, (int8x16_t)vmulq_laneq_f32(v85, v85, 3));
      v88[1] = vbslq_s8(v16, (int8x16_t)v23, (int8x16_t)vmulq_laneq_f32(v86, v86, 3));
      v88[2] = vbslq_s8(v16, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v87, v87, 3));
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v89) = -v11;
    if ((int)v89 >= v5)
      goto LABEL_3;
LABEL_10:
    v89 = v89;
    do
    {
      v90 = *((int8x16_t *)a2 + 15);
      v91 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v89), (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v7 + 16 * v89), 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
      v92 = *((float32x4_t *)a2 + 75);
      v93 = *((float32x4_t *)a2 + 5);
      v94 = vminq_f32(vmaxq_f32(v91, v92), v93);
      v95 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v94, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
      v96 = vcvtq_f32_s32(vcvtq_s32_f32(v95));
      v97 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v96), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v95, v96))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
      v98 = vcvtq_f32_s32(vcvtq_s32_f32(v97));
      v99 = vsubq_f32(v98, (float32x4_t)vandq_s8((int8x16_t)v93, (int8x16_t)vcgtq_f32(v98, v97)));
      v100 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v97, v99))), *((float32x4_t *)a2 + 12));
      v101 = (float32x4_t)vbslq_s8(v90, (int8x16_t)v91, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(v90, (int8x16_t)v91, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v92, vsubq_f32(v94, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v94, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2),
                                                                                                     vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v100, v100), vaddq_f32(*((float32x4_t *)a2 + 10), v99)), v92), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))), *(float32x4_t *)a2, 3))),
                                                                         v93))),
                                           v92),
                                         v93));
      *(int8x16_t *)(v6 + 16 * v89++) = vbslq_s8(v90, (int8x16_t)v91, (int8x16_t)vmulq_laneq_f32(v101, v101, 3));
    }
    while (v89 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype4_fixed_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  __int128 v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  int8x16_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int8x16_t *v89;
  uint64_t v90;
  int8x16_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v90) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v17 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15));
      v18 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15));
      v19 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v15));
      v21 = *((int8x16_t *)a2 + 17);
      v20 = *((float32x4_t *)a2 + 18);
      v22 = *((int8x16_t *)a2 + 3);
      v23 = vmulq_f32(v12, (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)vmulq_f32(v17, v20)), v22));
      v24 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)vmulq_f32(v18, v20)), v22));
      v25 = vmulq_f32(v14, (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)vmulq_f32(v19, v20)), v22));
      v26 = *((float32x4_t *)a2 + 75);
      v27 = *((float32x4_t *)a2 + 5);
      v28 = *((float32x4_t *)a2 + 6);
      v29 = vminq_f32(vmaxq_f32(v23, v26), v27);
      v30 = vminq_f32(vmaxq_f32(v24, v26), v27);
      v31 = *((_OWORD *)a2 + 1);
      v32 = vminq_f32(vmaxq_f32(v25, v26), v27);
      v33 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v34 = vmulq_f32(v28, vcvtq_f32_s32((int32x4_t)vaddq_f32(v29, v33)));
      v35 = vmulq_f32(v28, vcvtq_f32_s32((int32x4_t)vaddq_f32(v30, v33)));
      v36 = vmulq_f32(v28, vcvtq_f32_s32((int32x4_t)vaddq_f32(v32, v33)));
      v37 = vcvtq_f32_s32(vcvtq_s32_f32(v34));
      v38 = vcvtq_f32_s32(vcvtq_s32_f32(v35));
      v39 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
      v40 = *((float32x4_t *)a2 + 7);
      v41 = *((float32x4_t *)a2 + 8);
      v42 = vrsqrteq_f32(vaddq_f32(v40, vsubq_f32(v34, v37)));
      v43 = vrsqrteq_f32(vaddq_f32(v40, vsubq_f32(v35, v38)));
      v44 = vaddq_f32(v41, v37);
      v45 = vaddq_f32(v41, v38);
      v46 = vrsqrteq_f32(vaddq_f32(v40, vsubq_f32(v36, v39)));
      v47 = vaddq_f32(v41, v39);
      v48 = *((float32x4_t *)a2 + 9);
      v49 = *((float32x4_t *)a2 + 10);
      v50 = vmulq_n_f32(vsubq_f32(v44, vmulq_f32(v42, v48)), COERCE_FLOAT(*(_OWORD *)a2));
      v51 = vmulq_n_f32(vsubq_f32(v45, vmulq_f32(v43, v48)), COERCE_FLOAT(*(_OWORD *)a2));
      v52 = vmulq_n_f32(vsubq_f32(v47, vmulq_f32(v46, v48)), COERCE_FLOAT(*(_OWORD *)a2));
      v53 = vcvtq_f32_s32(vcvtq_s32_f32(v50));
      v54 = vcvtq_f32_s32(vcvtq_s32_f32(v51));
      v55 = vcvtq_f32_s32(vcvtq_s32_f32(v52));
      v56 = vsubq_f32(v53, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v53, v50)));
      v57 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v54, v51)));
      v58 = vsubq_f32(v55, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v55, v52)));
      v59 = vsubq_f32(v50, v56);
      v60 = vsubq_f32(v51, v57);
      v61 = vsubq_f32(v52, v58);
      v62 = vaddq_f32(v49, v56);
      v63 = vaddq_f32(v49, v57);
      v64 = vaddq_f32(v49, v58);
      v65 = *((float32x4_t *)a2 + 11);
      v66 = *((float32x4_t *)a2 + 12);
      v67 = vmulq_f32(vrecpeq_f32(vsubq_f32(v65, v59)), v66);
      v68 = vmulq_f32(vrecpeq_f32(vsubq_f32(v65, v60)), v66);
      v69 = vmulq_f32(vrecpeq_f32(vsubq_f32(v65, v61)), v66);
      v70 = vmaxq_f32(vaddq_f32(v62, vmulq_f32(v67, v67)), v26);
      v71 = vmaxq_f32(vaddq_f32(v63, vmulq_f32(v68, v68)), v26);
      v72 = *((float32x4_t *)a2 + 13);
      v73 = *((float32x4_t *)a2 + 14);
      v74 = vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(v64, vmulq_f32(v69, v69)), v26), v72), v73);
      v75 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v70, v72), v73));
      v76 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v71, v72), v73));
      v77 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2);
      v78 = (int8x16_t)vmulq_n_f32(v29, *(float *)&v31);
      v79 = (int8x16_t)vmulq_n_f32(v30, *(float *)&v31);
      v80 = (int8x16_t)vmulq_n_f32(v32, *(float *)&v31);
      v81 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v31, 1);
      v82 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v83 = vaddq_f32(v82, (float32x4_t)vbslq_s8(v16, (int8x16_t)v23, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v29, v81)), v78, (int8x16_t)vaddq_f32(v77, vmulq_laneq_f32(v75, *(float32x4_t *)a2, 3))), v27)));
      v84 = vmaxq_f32(vaddq_f32(v82, (float32x4_t)vbslq_s8(v16, (int8x16_t)v24, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v30, v81)), v79, (int8x16_t)vaddq_f32(v77, vmulq_laneq_f32(v76, *(float32x4_t *)a2, 3))), v27))), v26);
      v85 = (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v82, (float32x4_t)vbslq_s8(v16, (int8x16_t)v25, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v32, v81)), v80, (int8x16_t)vaddq_f32(v77, vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(v74), *(float32x4_t *)a2, 3))), v27))), v26), v27);
      v86 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v23, (int8x16_t)vminq_f32(vmaxq_f32(v83, v26), v27));
      v87 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v24, (int8x16_t)vminq_f32(v84, v27));
      v88 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v25, v85);
      v89 = (int8x16_t *)(v6 + v10);
      *v89 = vbslq_s8(v16, (int8x16_t)v23, (int8x16_t)vmulq_laneq_f32(v86, v86, 3));
      v89[1] = vbslq_s8(v16, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v87, v87, 3));
      v89[2] = vbslq_s8(v16, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v88, v88, 3));
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v90) = -v11;
    if ((int)v90 >= v5)
      goto LABEL_3;
LABEL_10:
    v90 = v90;
    do
    {
      v91 = *((int8x16_t *)a2 + 15);
      v92 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v90), (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v7 + 16 * v90), 3), *((float32x4_t *)a2 + 16))), *((float32x4_t *)a2 + 18))), *((int8x16_t *)a2 + 3)));
      v93 = *((float32x4_t *)a2 + 75);
      v94 = *((float32x4_t *)a2 + 5);
      v95 = vminq_f32(vmaxq_f32(v92, v93), v94);
      v96 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v95, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
      v97 = vcvtq_f32_s32(vcvtq_s32_f32(v96));
      v98 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v97), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v96, v97))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
      v99 = vcvtq_f32_s32(vcvtq_s32_f32(v98));
      v100 = vsubq_f32(v99, (float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgtq_f32(v99, v98)));
      v101 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v98, v100))), *((float32x4_t *)a2 + 12));
      v102 = (float32x4_t)vbslq_s8(v91, (int8x16_t)v92, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(v91, (int8x16_t)v92, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v93, vsubq_f32(v95, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v95, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2),
                                                                                                     vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v101, v101), vaddq_f32(*((float32x4_t *)a2 + 10), v100)), v93), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))), *(float32x4_t *)a2, 3))),
                                                                         v94))),
                                           v93),
                                         v94));
      *(int8x16_t *)(v6 + 16 * v90++) = vbslq_s8(v91, (int8x16_t)v92, (int8x16_t)vmulq_laneq_f32(v102, v102, 3));
    }
    while (v90 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype4_nice_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  __int128 v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  int8x16_t v93;
  int8x16_t v94;
  int8x16_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  int8x16_t *v104;
  int v105;
  uint64_t v106;
  float32x4_t v107;
  int8x16_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v105 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = *((int8x16_t *)a2 + 17);
      v24 = vandq_s8(v23, v22);
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v32 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v33 = *((_OWORD *)a2 + 1);
      v34 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v35 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v29)), v29);
      v36 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v30, (int8x16_t)vaddq_f32(v31, v34));
      v37 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v30, (int8x16_t)vaddq_f32(v32, v34));
      v38 = *((int8x16_t *)a2 + 19);
      v39 = *((float32x4_t *)a2 + 20);
      v40 = (float32x4_t)vorrq_s8(vandq_s8(v38, (int8x16_t)v36), (int8x16_t)v30);
      v41 = (float32x4_t)vorrq_s8(vandq_s8(v38, (int8x16_t)v37), (int8x16_t)v30);
      v42 = *((int8x16_t *)a2 + 21);
      v43 = *((float32x4_t *)a2 + 22);
      v44 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v39, v37)));
      v45 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v36, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v39, v36))), v43);
      v46 = *((float32x4_t *)a2 + 23);
      v47 = *((float32x4_t *)a2 + 24);
      v48 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v40, v46));
      v49 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v41, v46));
      v50 = vaddq_f32(v45, v48);
      v51 = vaddq_f32(vsubq_f32(v44, v43), v49);
      v52 = vsubq_f32(vsubq_f32(v40, v30), vmulq_f32(vmulq_f32(v47, v48), v40));
      v53 = vsubq_f32(vsubq_f32(v41, v30), vmulq_f32(vmulq_f32(v47, v49), v41));
      v54 = vmulq_f32(v52, v52);
      v55 = *((float32x4_t *)a2 + 37);
      v56 = *((float32x4_t *)a2 + 38);
      v57 = vaddq_f32(v55, vmulq_f32(v56, v52));
      v58 = vaddq_f32(v55, vmulq_f32(v56, v53));
      v59 = *((float32x4_t *)a2 + 39);
      v60 = *((float32x4_t *)a2 + 40);
      v61 = vaddq_f32(v59, vmulq_f32(v60, v52));
      v62 = vaddq_f32(v59, vmulq_f32(v60, v53));
      v63 = *((float32x4_t *)a2 + 41);
      v64 = *((float32x4_t *)a2 + 42);
      v65 = vaddq_f32(v63, vmulq_f32(v64, v52));
      v66 = vaddq_f32(v63, vmulq_f32(v64, v53));
      v67 = vmulq_f32(v53, v53);
      v68 = vaddq_f32(v66, vmulq_f32(v67, vaddq_f32(v58, vmulq_f32(v67, v62))));
      v69 = vmulq_f32(v52, vaddq_f32(v65, vmulq_f32(v54, vaddq_f32(v57, vmulq_f32(v54, v61)))));
      v70 = *((float32x4_t *)a2 + 43);
      v71 = *((float32x4_t *)a2 + 44);
      v72 = vaddq_f32(v51, vmulq_f32(v53, vaddq_f32(v70, vmulq_f32(v53, v68))));
      v73 = *((float32x4_t *)a2 + 29);
      v74 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v50, vmulq_f32(v52, vaddq_f32(v70, v69))), COERCE_FLOAT(*(_OWORD *)a2)), v73);
      v75 = vmaxq_f32(vmulq_n_f32(v72, COERCE_FLOAT(*(_OWORD *)a2)), v73);
      v76 = vcvtq_f32_s32(vcvtq_s32_f32(v74));
      v77 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
      v78 = vsubq_f32(v76, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v76, v74)));
      v79 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v77, v75)));
      v80 = vsubq_f32(v74, v78);
      v81 = vsubq_f32(v75, v79);
      v82 = *((float32x4_t *)a2 + 45);
      v83 = *((float32x4_t *)a2 + 46);
      v84 = vaddq_f32(v71, vmulq_f32(v82, v80));
      v85 = vaddq_f32(v71, vmulq_f32(v82, v81));
      v86 = *((float32x4_t *)a2 + 47);
      v87 = *((float32x4_t *)a2 + 48);
      v88 = vaddq_f32(v30, vmulq_f32(v81, vaddq_f32(v87, vmulq_f32(v81, vaddq_f32(vaddq_f32(v83, vmulq_f32(v86, v81)), vmulq_f32(vmulq_f32(v81, v81), v85))))));
      v89 = *((int32x4_t *)a2 + 33);
      v90 = vmulq_f32(vaddq_f32(v30, vmulq_f32(v80, vaddq_f32(v87, vmulq_f32(v80, vaddq_f32(vaddq_f32(v83, vmulq_f32(v80, v86)), vmulq_f32(vmulq_f32(v80, v80), v84)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v89, vcvtq_s32_f32(v78)), 0x17uLL));
      v91 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2);
      v92 = vmulq_laneq_f32(vmulq_f32(v88, (float32x4_t)vshlq_n_s32(vaddq_s32(v89, vcvtq_s32_f32(v79)), 0x17uLL)), *(float32x4_t *)a2, 3);
      v93 = (int8x16_t)vaddq_f32(v91, vmulq_laneq_f32(v90, *(float32x4_t *)a2, 3));
      v94 = (int8x16_t)vmulq_n_f32(v31, *(float *)&v33);
      v95 = (int8x16_t)vmulq_n_f32(v32, *(float *)&v33);
      v96 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v33, 1);
      v97 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v98 = vaddq_f32(v97, (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v31, v96)), v94, v93), v30)));
      v99 = vaddq_f32(v97, (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v96)), v95, (int8x16_t)vaddq_f32(v91, v92)), v30)));
      v100 = vmaxq_f32(v98, v29);
      v101 = vmaxq_f32(v99, v29);
      v102 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vminq_f32(v100, v30));
      v103 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vminq_f32(v101, v30));
      v104 = (int8x16_t *)(v6 + v11);
      v104[-1] = vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v102, v102, 3));
      *v104 = vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v103, v103, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v105 = -v10;
    if (v105 >= v5)
      goto LABEL_3;
LABEL_10:
    v106 = 16 * v105;
    v107 = *(float32x4_t *)(v7 + v106);
    v108 = *((int8x16_t *)a2 + 15);
    v109 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3), *((float32x4_t *)a2 + 16));
    v110 = vrecpeq_f32(v109);
    v111 = vmulq_f32(v110, vrecpsq_f32(v110, v109));
    v112 = vmulq_f32(v107, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v111, vrecpsq_f32(v111, v109))), *((int8x16_t *)a2 + 3)));
    v113 = *((float32x4_t *)a2 + 75);
    v114 = *((float32x4_t *)a2 + 5);
    v115 = vminq_f32(vmaxq_f32(v112, v113), v114);
    v116 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v114, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v113)), v113), (int8x16_t)v114, (int8x16_t)vaddq_f32(v115, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
    v117 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v116), (int8x16_t)v114);
    v118 = (float32x4_t)vandq_s8((int8x16_t)v114, (int8x16_t)vcgtq_f32(v117, *((float32x4_t *)a2 + 23)));
    v119 = vsubq_f32(vsubq_f32(v117, v114), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v118), v117));
    v120 = vmulq_f32(v119, v119);
    v121 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v116, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v116))), *((float32x4_t *)a2 + 22)), v118), vmulq_f32(v119, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v119, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v119)),
                         vmulq_f32(v120, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v119)), vmulq_f32(v120, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v119)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
    v122 = vcvtq_f32_s32(vcvtq_s32_f32(v121));
    v123 = vsubq_f32(v122, (float32x4_t)vandq_s8((int8x16_t)v114, (int8x16_t)vcgtq_f32(v122, v121)));
    v124 = vsubq_f32(v121, v123);
    v125 = (float32x4_t)vbslq_s8(v108, (int8x16_t)v112, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(v108, (int8x16_t)v112, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v113, vsubq_f32(v115, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v115, COERCE_FLOAT(*((_OWORD *)a2 + 1))),
                                                                                      (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2), vmulq_laneq_f32(vmulq_f32(vaddq_f32(v114, vmulq_f32(v124, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v124, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v124)), vmulq_f32(vmulq_f32(v124, v124), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v124)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v123)), 0x17uLL)), *(float32x4_t *)a2, 3))), v114))), v113), v114));
    *(int8x16_t *)(v6 + v106) = vbslq_s8(v108, (int8x16_t)v112, (int8x16_t)vmulq_laneq_f32(v125, v125, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype4_half_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  __int128 v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  int32x4_t v70;
  int32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int8x16_t v75;
  int8x16_t v76;
  int8x16_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  int8x16_t *v84;
  int v85;
  uint64_t v86;
  float32x4_t v87;
  int8x16_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v85 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v24 = *((int8x16_t *)a2 + 3);
      v25 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v24));
      v26 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v23, v24));
      v27 = *((float32x4_t *)a2 + 75);
      v28 = *((float32x4_t *)a2 + 5);
      v29 = vminq_f32(vmaxq_f32(v25, v27), v28);
      v30 = *((_OWORD *)a2 + 1);
      v31 = vminq_f32(vmaxq_f32(v26, v27), v28);
      v32 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v33 = vaddq_f32(v29, v32);
      v34 = vaddq_f32(v31, v32);
      v35 = *((int8x16_t *)a2 + 19);
      v36 = *((float32x4_t *)a2 + 20);
      v37 = (float32x4_t)vorrq_s8(vandq_s8(v35, (int8x16_t)v33), (int8x16_t)v28);
      v38 = (float32x4_t)vorrq_s8(vandq_s8(v35, (int8x16_t)v34), (int8x16_t)v28);
      v39 = *((int8x16_t *)a2 + 21);
      v40 = *((float32x4_t *)a2 + 22);
      v41 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v33, 0x17uLL)), (float32x4_t)vandq_s8(v39, (int8x16_t)vcgtq_f32(v36, v33)));
      v42 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v34, 0x17uLL)), (float32x4_t)vandq_s8(v39, (int8x16_t)vcgtq_f32(v36, v34)));
      v43 = *((float32x4_t *)a2 + 23);
      v44 = *((float32x4_t *)a2 + 24);
      v45 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v37, v43));
      v46 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v38, v43));
      v47 = vsubq_f32(v42, v40);
      v48 = vaddq_f32(vsubq_f32(v41, v40), v45);
      v49 = vsubq_f32(vsubq_f32(v37, v28), vmulq_f32(vmulq_f32(v44, v45), v37));
      v50 = vsubq_f32(vsubq_f32(v38, v28), vmulq_f32(vmulq_f32(v44, v46), v38));
      v51 = *((float32x4_t *)a2 + 25);
      v52 = *((float32x4_t *)a2 + 26);
      v53 = *((float32x4_t *)a2 + 27);
      v54 = *((float32x4_t *)a2 + 28);
      v55 = vmulq_n_f32(vaddq_f32(vaddq_f32(v47, v46), vmulq_f32(v50, vaddq_f32(vaddq_f32(v53, vmulq_f32(v54, v50)), vmulq_f32(vmulq_f32(v50, v50), vaddq_f32(v51, vmulq_f32(v52, v50)))))), COERCE_FLOAT(*(_OWORD *)a2));
      v56 = *((float32x4_t *)a2 + 29);
      v57 = *((float32x4_t *)a2 + 30);
      v58 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v48, vmulq_f32(v49, vaddq_f32(vaddq_f32(v53, vmulq_f32(v54, v49)), vmulq_f32(vmulq_f32(v49, v49), vaddq_f32(v51, vmulq_f32(v52, v49)))))), COERCE_FLOAT(*(_OWORD *)a2)), v56);
      v59 = vmaxq_f32(v55, v56);
      v60 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v61 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v62 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v60, v58)));
      v63 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v61, v59)));
      v64 = vsubq_f32(v58, v62);
      v65 = vsubq_f32(v59, v63);
      v66 = *((float32x4_t *)a2 + 31);
      v67 = *((float32x4_t *)a2 + 32);
      v68 = vmulq_f32(v65, vaddq_f32(v67, vmulq_f32(v65, vaddq_f32(v57, vmulq_f32(v66, v65)))));
      v69 = vaddq_f32(v28, vmulq_f32(v64, vaddq_f32(v67, vmulq_f32(v64, vaddq_f32(v57, vmulq_f32(v66, v64))))));
      v70 = vcvtq_s32_f32(v63);
      v71 = *((int32x4_t *)a2 + 33);
      v72 = vmulq_f32(v69, (float32x4_t)vshlq_n_s32(vaddq_s32(v71, vcvtq_s32_f32(v62)), 0x17uLL));
      v73 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2);
      v74 = vmulq_laneq_f32(vmulq_f32(vaddq_f32(v28, v68), (float32x4_t)vshlq_n_s32(vaddq_s32(v71, v70), 0x17uLL)), *(float32x4_t *)a2, 3);
      v75 = (int8x16_t)vaddq_f32(v73, vmulq_laneq_f32(v72, *(float32x4_t *)a2, 3));
      v76 = (int8x16_t)vmulq_n_f32(v29, *(float *)&v30);
      v77 = (int8x16_t)vmulq_n_f32(v31, *(float *)&v30);
      v78 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v30, 1);
      v79 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v80 = vmaxq_f32(vaddq_f32(v79, (float32x4_t)vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v27, vsubq_f32(v29, v78)), v76, v75), v28))), v27);
      v81 = vmaxq_f32(vaddq_f32(v79, (float32x4_t)vbslq_s8(v15, (int8x16_t)v26, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v27, vsubq_f32(v31, v78)), v77, (int8x16_t)vaddq_f32(v73, v74)), v28))), v27);
      v82 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vminq_f32(v80, v28));
      v83 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v26, (int8x16_t)vminq_f32(v81, v28));
      v84 = (int8x16_t *)(v6 + v11);
      v84[-1] = vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v82, v82, 3));
      *v84 = vbslq_s8(v15, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v83, v83, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v85 = -v10;
    if (v85 >= v5)
      goto LABEL_3;
LABEL_10:
    v86 = 16 * v85;
    v87 = *(float32x4_t *)(v7 + v86);
    v88 = *((int8x16_t *)a2 + 15);
    v89 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v87, 3), *((float32x4_t *)a2 + 16));
    v90 = vmulq_f32(vrecpeq_f32(v89), *((float32x4_t *)a2 + 18));
    v91 = vmulq_f32(v87, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v90, vrecpsq_f32(v90, v89))), *((int8x16_t *)a2 + 3)));
    v92 = *((float32x4_t *)a2 + 75);
    v93 = *((float32x4_t *)a2 + 5);
    v94 = vminq_f32(vmaxq_f32(v91, v92), v93);
    v95 = vaddq_f32(v94, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v96 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v95), (int8x16_t)v93);
    v97 = (float32x4_t)vandq_s8((int8x16_t)v93, (int8x16_t)vcgtq_f32(v96, *((float32x4_t *)a2 + 23)));
    v98 = vsubq_f32(vsubq_f32(v96, v93), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v97), v96));
    v99 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v95, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v95))), *((float32x4_t *)a2 + 22)), v97), vmulq_f32(v98, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(*((float32x4_t *)a2 + 28), v98)), vmulq_f32(vmulq_f32(v98, v98), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v98)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v100 = vcvtq_f32_s32(vcvtq_s32_f32(v99));
    v101 = vsubq_f32(v100, (float32x4_t)vandq_s8((int8x16_t)v93, (int8x16_t)vcgtq_f32(v100, v99)));
    v102 = vsubq_f32(v99, v101);
    v103 = (float32x4_t)vbslq_s8(v88, (int8x16_t)v91, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(v88, (int8x16_t)v91, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v92, vsubq_f32(v94, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v94, COERCE_FLOAT(*((_OWORD *)a2 + 1))),
                                                                                      (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2), vmulq_laneq_f32(vmulq_f32(vaddq_f32(v93, vmulq_f32(v102, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v102, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v102)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v101)), 0x17uLL)), *(float32x4_t *)a2, 3))), v93))), v92), v93));
    *(int8x16_t *)(v6 + v86) = vbslq_s8(v88, (int8x16_t)v91, (int8x16_t)vmulq_laneq_f32(v103, v103, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype4_halfTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  __int128 v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  int8x16_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int8x16_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  int32x4_t v76;
  int32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  int8x16_t v81;
  int8x16_t v82;
  float32x4_t v83;
  float32x4_t v84;
  int8x16_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int8x16_t *v89;
  int v90;
  uint64_t v91;
  float32x4_t v92;
  int8x16_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v90 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vrecpsq_f32(v20, v16);
      v23 = vrecpsq_f32(v21, v17);
      v24 = (int8x16_t)vmulq_f32(v20, v22);
      v25 = (int8x16_t)vmulq_f32(v21, v23);
      v26 = vandq_s8(v19, v24);
      v27 = vandq_s8(v19, v25);
      v28 = *((int8x16_t *)a2 + 3);
      v29 = (float32x4_t)vorrq_s8(v27, v28);
      v30 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v26, v28));
      v31 = *((int8x16_t *)a2 + 76);
      v32 = *((float32x4_t *)a2 + 75);
      v33 = vmulq_f32(v12, v29);
      v34 = *((_OWORD *)a2 + 1);
      v35 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v36 = vminq_f32(vmaxq_f32(v30, v32), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbslq_s8(v31, (int8x16_t)v22, (int8x16_t)v32), 3));
      v37 = vminq_f32(vmaxq_f32(v33, v32), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbslq_s8(v31, (int8x16_t)v23, (int8x16_t)v32), 3));
      v38 = vaddq_f32(v36, v35);
      v39 = vaddq_f32(v37, v35);
      v40 = *((int8x16_t *)a2 + 19);
      v41 = *((float32x4_t *)a2 + 20);
      v42 = *((float32x4_t *)a2 + 5);
      v43 = (float32x4_t)vorrq_s8(vandq_s8(v40, (int8x16_t)v38), (int8x16_t)v42);
      v44 = (float32x4_t)vorrq_s8(vandq_s8(v40, (int8x16_t)v39), (int8x16_t)v42);
      v45 = *((int8x16_t *)a2 + 21);
      v46 = *((float32x4_t *)a2 + 22);
      v47 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v38, 0x17uLL)), (float32x4_t)vandq_s8(v45, (int8x16_t)vcgtq_f32(v41, v38)));
      v48 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v39, 0x17uLL)), (float32x4_t)vandq_s8(v45, (int8x16_t)vcgtq_f32(v41, v39)));
      v49 = *((float32x4_t *)a2 + 23);
      v50 = *((float32x4_t *)a2 + 24);
      v51 = (float32x4_t)vandq_s8((int8x16_t)v42, (int8x16_t)vcgtq_f32(v43, v49));
      v52 = (float32x4_t)vandq_s8((int8x16_t)v42, (int8x16_t)vcgtq_f32(v44, v49));
      v53 = vsubq_f32(v48, v46);
      v54 = vaddq_f32(vsubq_f32(v47, v46), v51);
      v55 = vsubq_f32(vsubq_f32(v43, v42), vmulq_f32(vmulq_f32(v50, v51), v43));
      v56 = vsubq_f32(vsubq_f32(v44, v42), vmulq_f32(vmulq_f32(v50, v52), v44));
      v57 = *((float32x4_t *)a2 + 25);
      v58 = *((float32x4_t *)a2 + 26);
      v59 = *((float32x4_t *)a2 + 27);
      v60 = *((float32x4_t *)a2 + 28);
      v61 = vmulq_n_f32(vaddq_f32(vaddq_f32(v53, v52), vmulq_f32(v56, vaddq_f32(vaddq_f32(v59, vmulq_f32(v56, v60)), vmulq_f32(vmulq_f32(v56, v56), vaddq_f32(v57, vmulq_f32(v58, v56)))))), COERCE_FLOAT(*(_OWORD *)a2));
      v62 = *((float32x4_t *)a2 + 29);
      v63 = *((float32x4_t *)a2 + 30);
      v64 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v54, vmulq_f32(v55, vaddq_f32(vaddq_f32(v59, vmulq_f32(v55, v60)), vmulq_f32(vmulq_f32(v55, v55), vaddq_f32(v57, vmulq_f32(v58, v55)))))), COERCE_FLOAT(*(_OWORD *)a2)), v62);
      v65 = vmaxq_f32(v61, v62);
      v66 = vcvtq_f32_s32(vcvtq_s32_f32(v64));
      v67 = vcvtq_f32_s32(vcvtq_s32_f32(v65));
      v68 = vsubq_f32(v66, (float32x4_t)vandq_s8((int8x16_t)v42, (int8x16_t)vcgtq_f32(v66, v64)));
      v69 = vsubq_f32(v67, (float32x4_t)vandq_s8((int8x16_t)v42, (int8x16_t)vcgtq_f32(v67, v65)));
      v70 = vsubq_f32(v64, v68);
      v71 = vsubq_f32(v65, v69);
      v72 = *((float32x4_t *)a2 + 31);
      v73 = *((float32x4_t *)a2 + 32);
      v74 = vmulq_f32(v71, vaddq_f32(v73, vmulq_f32(v71, vaddq_f32(v63, vmulq_f32(v72, v71)))));
      v75 = vaddq_f32(v42, vmulq_f32(v70, vaddq_f32(v73, vmulq_f32(v70, vaddq_f32(v63, vmulq_f32(v72, v70))))));
      v76 = vcvtq_s32_f32(v69);
      v77 = *((int32x4_t *)a2 + 33);
      v78 = vmulq_f32(v75, (float32x4_t)vshlq_n_s32(vaddq_s32(v77, vcvtq_s32_f32(v68)), 0x17uLL));
      v79 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2);
      v80 = vmulq_laneq_f32(vmulq_f32(vaddq_f32(v42, v74), (float32x4_t)vshlq_n_s32(vaddq_s32(v77, v76), 0x17uLL)), *(float32x4_t *)a2, 3);
      v81 = (int8x16_t)vmulq_n_f32(v36, *(float *)&v34);
      v82 = (int8x16_t)vmulq_n_f32(v37, *(float *)&v34);
      v83 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v34, 1);
      v84 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v85 = (int8x16_t)vaddq_f32(v84, (float32x4_t)vbslq_s8(v15, (int8x16_t)v30, vbslq_s8((int8x16_t)vcgtq_f32(v32, vsubq_f32(v36, v83)), v81, (int8x16_t)vaddq_f32(v79, vmulq_laneq_f32(v78, *(float32x4_t *)a2, 3)))));
      v86 = (int8x16_t)vaddq_f32(v84, (float32x4_t)vbslq_s8(v15, (int8x16_t)v33, vbslq_s8((int8x16_t)vcgtq_f32(v32, vsubq_f32(v37, v83)), v82, (int8x16_t)vaddq_f32(v79, v80))));
      v87 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v30, v85);
      v88 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v33, v86);
      v89 = (int8x16_t *)(v6 + v11);
      v89[-1] = vbslq_s8(v15, (int8x16_t)v30, (int8x16_t)vmulq_laneq_f32(v87, v87, 3));
      *v89 = vbslq_s8(v15, (int8x16_t)v33, (int8x16_t)vmulq_laneq_f32(v88, v88, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v90 = -v10;
    if (v90 >= v5)
      goto LABEL_3;
LABEL_10:
    v91 = 16 * v90;
    v92 = *(float32x4_t *)(v7 + v91);
    v93 = *((int8x16_t *)a2 + 15);
    v94 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v92, 3), *((float32x4_t *)a2 + 16));
    v95 = vmulq_f32(vrecpeq_f32(v94), *((float32x4_t *)a2 + 18));
    v96 = vrecpsq_f32(v95, v94);
    v97 = vmulq_f32(v92, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v95, v96)), *((int8x16_t *)a2 + 3)));
    v98 = *((float32x4_t *)a2 + 75);
    v99 = vminq_f32(vmaxq_f32(v97, v98), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 76), (int8x16_t)v96, (int8x16_t)v98), 3));
    v100 = vaddq_f32(v99, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v101 = *((float32x4_t *)a2 + 5);
    v102 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v100), (int8x16_t)v101);
    v103 = (float32x4_t)vandq_s8((int8x16_t)v101, (int8x16_t)vcgtq_f32(v102, *((float32x4_t *)a2 + 23)));
    v104 = vsubq_f32(vsubq_f32(v102, v101), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v103), v102));
    v105 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v100, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v100))), *((float32x4_t *)a2 + 22)), v103), vmulq_f32(v104, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v104, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v104, v104), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v104)))))), COERCE_FLOAT(*(_OWORD *)a2)),
             *((float32x4_t *)a2 + 29));
    v106 = vcvtq_f32_s32(vcvtq_s32_f32(v105));
    v107 = vsubq_f32(v106, (float32x4_t)vandq_s8((int8x16_t)v101, (int8x16_t)vcgtq_f32(v106, v105)));
    v108 = vsubq_f32(v105, v107);
    v109 = (float32x4_t)vbslq_s8(v93, (int8x16_t)v97, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(v93, (int8x16_t)v97, vbslq_s8((int8x16_t)vcgtq_f32(v98, vsubq_f32(v99, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v99, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2), vmulq_laneq_f32(
                                                                       vmulq_f32(vaddq_f32(v101, vmulq_f32(v108, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v108, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v108)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v107)), 0x17uLL)), *(float32x4_t *)a2,
                                                                       3))))));
    *(int8x16_t *)(v6 + v91) = vbslq_s8(v93, (int8x16_t)v97, (int8x16_t)vmulq_laneq_f32(v109, v109, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype4_niceTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  __int128 v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  int8x16_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  int32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  int8x16_t v97;
  int8x16_t v98;
  int8x16_t v99;
  float32x4_t v100;
  int8x16_t v101;
  float32x4_t v102;
  int8x16_t v103;
  float32x4_t v104;
  float32x4_t v105;
  int8x16_t *v106;
  int v107;
  uint64_t v108;
  float32x4_t v109;
  int8x16_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v107 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vrecpsq_f32(v18, v16);
      v21 = vrecpsq_f32(v19, v17);
      v22 = vmulq_f32(v18, v20);
      v23 = vmulq_f32(v19, v21);
      v24 = (int8x16_t)vmulq_f32(v22, vrecpsq_f32(v22, v16));
      v25 = *((int8x16_t *)a2 + 17);
      v26 = vandq_s8(v25, v24);
      v27 = vandq_s8(v25, (int8x16_t)vmulq_f32(v23, vrecpsq_f32(v23, v17)));
      v28 = *((int8x16_t *)a2 + 3);
      v29 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v26, v28));
      v30 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v27, v28));
      v31 = *((float32x4_t *)a2 + 75);
      v32 = vminq_f32(vmaxq_f32(v29, v31), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 76), (int8x16_t)v20, (int8x16_t)v31), 3));
      v33 = *((_OWORD *)a2 + 1);
      v34 = vminq_f32(vmaxq_f32(v30, v31), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 76), (int8x16_t)v21, (int8x16_t)v31), 3));
      v35 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v36 = *((float32x4_t *)a2 + 5);
      v37 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v36, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v31)), v31);
      v38 = (float32x4_t)vbslq_s8(v37, (int8x16_t)v36, (int8x16_t)vaddq_f32(v32, v35));
      v39 = (float32x4_t)vbslq_s8(v37, (int8x16_t)v36, (int8x16_t)vaddq_f32(v34, v35));
      v40 = *((int8x16_t *)a2 + 19);
      v41 = *((float32x4_t *)a2 + 20);
      v42 = (float32x4_t)vorrq_s8(vandq_s8(v40, (int8x16_t)v38), (int8x16_t)v36);
      v43 = (float32x4_t)vorrq_s8(vandq_s8(v40, (int8x16_t)v39), (int8x16_t)v36);
      v44 = *((int8x16_t *)a2 + 21);
      v45 = *((float32x4_t *)a2 + 22);
      v46 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v39, 0x17uLL)), (float32x4_t)vandq_s8(v44, (int8x16_t)vcgtq_f32(v41, v39)));
      v47 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v38, 0x17uLL)), (float32x4_t)vandq_s8(v44, (int8x16_t)vcgtq_f32(v41, v38))), v45);
      v48 = *((float32x4_t *)a2 + 23);
      v49 = *((float32x4_t *)a2 + 24);
      v50 = (float32x4_t)vandq_s8((int8x16_t)v36, (int8x16_t)vcgtq_f32(v42, v48));
      v51 = (float32x4_t)vandq_s8((int8x16_t)v36, (int8x16_t)vcgtq_f32(v43, v48));
      v52 = vaddq_f32(v47, v50);
      v53 = vaddq_f32(vsubq_f32(v46, v45), v51);
      v54 = vsubq_f32(vsubq_f32(v42, v36), vmulq_f32(vmulq_f32(v49, v50), v42));
      v55 = vsubq_f32(vsubq_f32(v43, v36), vmulq_f32(vmulq_f32(v49, v51), v43));
      v56 = vmulq_f32(v54, v54);
      v57 = *((float32x4_t *)a2 + 37);
      v58 = *((float32x4_t *)a2 + 38);
      v59 = vaddq_f32(v57, vmulq_f32(v58, v54));
      v60 = vaddq_f32(v57, vmulq_f32(v58, v55));
      v61 = *((float32x4_t *)a2 + 39);
      v62 = *((float32x4_t *)a2 + 40);
      v63 = vaddq_f32(v61, vmulq_f32(v62, v54));
      v64 = vaddq_f32(v61, vmulq_f32(v62, v55));
      v65 = *((float32x4_t *)a2 + 41);
      v66 = *((float32x4_t *)a2 + 42);
      v67 = vaddq_f32(v65, vmulq_f32(v66, v54));
      v68 = vaddq_f32(v65, vmulq_f32(v66, v55));
      v69 = vmulq_f32(v55, v55);
      v70 = vaddq_f32(v68, vmulq_f32(v69, vaddq_f32(v60, vmulq_f32(v69, v64))));
      v71 = vmulq_f32(v54, vaddq_f32(v67, vmulq_f32(v56, vaddq_f32(v59, vmulq_f32(v56, v63)))));
      v72 = *((float32x4_t *)a2 + 43);
      v73 = *((float32x4_t *)a2 + 44);
      v74 = vaddq_f32(v53, vmulq_f32(v55, vaddq_f32(v72, vmulq_f32(v55, v70))));
      v75 = vmulq_n_f32(vaddq_f32(v52, vmulq_f32(v54, vaddq_f32(v72, v71))), COERCE_FLOAT(*(_OWORD *)a2));
      v76 = *((float32x4_t *)a2 + 29);
      v77 = vmaxq_f32(v75, v76);
      v78 = vmaxq_f32(vmulq_n_f32(v74, COERCE_FLOAT(*(_OWORD *)a2)), v76);
      v79 = vcvtq_f32_s32(vcvtq_s32_f32(v77));
      v80 = vcvtq_f32_s32(vcvtq_s32_f32(v78));
      v81 = vsubq_f32(v79, (float32x4_t)vandq_s8((int8x16_t)v36, (int8x16_t)vcgtq_f32(v79, v77)));
      v82 = vsubq_f32(v80, (float32x4_t)vandq_s8((int8x16_t)v36, (int8x16_t)vcgtq_f32(v80, v78)));
      v83 = vsubq_f32(v77, v81);
      v84 = vsubq_f32(v78, v82);
      v85 = *((float32x4_t *)a2 + 45);
      v86 = *((float32x4_t *)a2 + 46);
      v87 = vaddq_f32(v73, vmulq_f32(v85, v83));
      v88 = vaddq_f32(v73, vmulq_f32(v85, v84));
      v89 = *((float32x4_t *)a2 + 47);
      v90 = *((float32x4_t *)a2 + 48);
      v91 = vaddq_f32(v36, vmulq_f32(v83, vaddq_f32(v90, vmulq_f32(v83, vaddq_f32(vaddq_f32(v86, vmulq_f32(v83, v89)), vmulq_f32(vmulq_f32(v83, v83), v87))))));
      v92 = vaddq_f32(v36, vmulq_f32(v84, vaddq_f32(v90, vmulq_f32(v84, vaddq_f32(vaddq_f32(v86, vmulq_f32(v89, v84)), vmulq_f32(vmulq_f32(v84, v84), v88))))));
      v93 = *((int32x4_t *)a2 + 33);
      v94 = vmulq_f32(v91, (float32x4_t)vshlq_n_s32(vaddq_s32(v93, vcvtq_s32_f32(v81)), 0x17uLL));
      v95 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2);
      v96 = vmulq_laneq_f32(vmulq_f32(v92, (float32x4_t)vshlq_n_s32(vaddq_s32(v93, vcvtq_s32_f32(v82)), 0x17uLL)), *(float32x4_t *)a2, 3);
      v97 = (int8x16_t)vaddq_f32(v95, vmulq_laneq_f32(v94, *(float32x4_t *)a2, 3));
      v98 = (int8x16_t)vmulq_n_f32(v32, *(float *)&v33);
      v99 = (int8x16_t)vmulq_n_f32(v34, *(float *)&v33);
      v100 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v33, 1);
      v101 = (int8x16_t)vcgtq_f32(v31, vsubq_f32(v32, v100));
      v102 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v103 = (int8x16_t)vaddq_f32(v102, (float32x4_t)vbslq_s8(v15, (int8x16_t)v30, vbslq_s8((int8x16_t)vcgtq_f32(v31, vsubq_f32(v34, v100)), v99, (int8x16_t)vaddq_f32(v95, v96))));
      v104 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v29, (int8x16_t)vaddq_f32(v102, (float32x4_t)vbslq_s8(v15, (int8x16_t)v29, vbslq_s8(v101, v98, v97))));
      v105 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v30, v103);
      v106 = (int8x16_t *)(v6 + v11);
      v106[-1] = vbslq_s8(v15, (int8x16_t)v29, (int8x16_t)vmulq_laneq_f32(v104, v104, 3));
      *v106 = vbslq_s8(v15, (int8x16_t)v30, (int8x16_t)vmulq_laneq_f32(v105, v105, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v107 = -v10;
    if (v107 >= v5)
      goto LABEL_3;
LABEL_10:
    v108 = 16 * v107;
    v109 = *(float32x4_t *)(v7 + v108);
    v110 = *((int8x16_t *)a2 + 15);
    v111 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v109, 3), *((float32x4_t *)a2 + 16));
    v112 = vrecpeq_f32(v111);
    v113 = vrecpsq_f32(v112, v111);
    v114 = vmulq_f32(v112, v113);
    v115 = vmulq_f32(v109, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v114, vrecpsq_f32(v114, v111))), *((int8x16_t *)a2 + 3)));
    v116 = *((float32x4_t *)a2 + 75);
    v117 = vminq_f32(vmaxq_f32(v115, v116), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 76), (int8x16_t)v113, (int8x16_t)v116), 3));
    v118 = *((float32x4_t *)a2 + 5);
    v119 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v118, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v116)), v116), (int8x16_t)v118, (int8x16_t)vaddq_f32(v117, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
    v120 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v119), (int8x16_t)v118);
    v121 = (float32x4_t)vandq_s8((int8x16_t)v118, (int8x16_t)vcgtq_f32(v120, *((float32x4_t *)a2 + 23)));
    v122 = vsubq_f32(vsubq_f32(v120, v118), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v121), v120));
    v123 = vmulq_f32(v122, v122);
    v124 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v119, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v119))), *((float32x4_t *)a2 + 22)), v121), vmulq_f32(v122, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v122, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v122)),
                         vmulq_f32(v123, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v122)), vmulq_f32(v123, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v122)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
    v125 = vcvtq_f32_s32(vcvtq_s32_f32(v124));
    v126 = vsubq_f32(v125, (float32x4_t)vandq_s8((int8x16_t)v118, (int8x16_t)vcgtq_f32(v125, v124)));
    v127 = vsubq_f32(v124, v126);
    v128 = (float32x4_t)vbslq_s8(v110, (int8x16_t)v115, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(v110, (int8x16_t)v115, vbslq_s8((int8x16_t)vcgtq_f32(v116, vsubq_f32(v117, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v117, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2), vmulq_laneq_f32(
                                                                       vmulq_f32(vaddq_f32(v118, vmulq_f32(v127, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v127, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v127)), vmulq_f32(vmulq_f32(v127, v127), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(
                                                                                         *((float32x4_t *)a2 + 45),
                                                                                         v127)))))))),
                                                                         (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v126)), 0x17uLL)), *(float32x4_t *)a2, 3))))));
    *(int8x16_t *)(v6 + v108) = vbslq_s8(v110, (int8x16_t)v115, (int8x16_t)vmulq_laneq_f32(v128, v128, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype4_floatTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t v41;
  float32x4_t v42;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 2);
    v7 = 16 * *((int *)a1 + 22);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((float32x4_t *)a2 + 72);
        v13 = *((float32x4_t *)a2 + 73);
        v14 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v11, v12), 3), v12), v13);
        v15 = vminq_f32(vmaxq_f32(vrecpeq_f32(v14), v12), v13);
        v16 = vrecpsq_f32(v14, v15);
        v17 = vminq_f32(vmaxq_f32(vmulq_f32(v15, v16), v12), v13);
        v18 = vmulq_f32(v17, vrecpsq_f32(v14, v17));
        v18.i32[3] = 1.0;
        v19 = vmulq_f32(v11, v18);
        v20 = *((float32x4_t *)a2 + 75);
        v21 = vminq_f32(vmaxq_f32(v19, v20), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbslq_s8(*((int8x16_t *)a2 + 76), (int8x16_t)v16, (int8x16_t)v20), 3));
        v22 = *((float32x4_t *)a2 + 5);
        v23 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v20)), v20), (int8x16_t)v22, (int8x16_t)vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v24 = *((int8x16_t *)a2 + 52);
        v25 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v23);
        v26 = (int8x16_t)vmulq_f32(v23, vaddq_f32(v22, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 49), v25)));
        v27 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), v26), (int8x16_t)v22);
        v28 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v23, *((float32x4_t *)a2 + 21))), vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v23, *((float32x4_t *)a2 + 50)), *((int8x16_t *)a2 + 51)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v23, *((float32x4_t *)a2 + 50)))), (float32x4_t)vandq_s8(v24, v25))), *((float32x4_t *)a2 + 22)), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x17uLL)));
        v29 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v27, *((float32x4_t *)a2 + 23)));
        v30 = vaddq_f32(v28, v29);
        v31 = vsubq_f32(vsubq_f32(v27, v22), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v29), v27));
        v32 = vmulq_f32(v31, v31);
        v33 = vmulq_n_f32(vaddq_f32(v30, vmulq_f32(v31, vaddq_f32(*((float32x4_t *)a2 + 61), vmulq_f32(v31, vaddq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 59), vmulq_f32(*((float32x4_t *)a2 + 60), v31)), vmulq_f32(v32, vaddq_f32(*((float32x4_t *)a2 + 57), vmulq_f32(*((float32x4_t *)a2 + 58), v31)))), vmulq_f32(vmulq_f32(v32, v32), vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 55), vmulq_f32(*((float32x4_t *)a2 + 56), v31)), vmulq_f32(
                                v32,
                                vaddq_f32(*((float32x4_t *)a2 + 53), vmulq_f32(*((float32x4_t *)a2 + 54), v31)))))))))),
                COERCE_FLOAT(*(_OWORD *)a2));
        v34 = vminq_f32(vmaxq_f32(v33, *((float32x4_t *)a2 + 62)), *((float32x4_t *)a2 + 63));
        v35 = vcvtq_f32_s32(vcvtq_s32_f32(v34));
        v36 = vsubq_f32(v35, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v35, v34)));
        v37 = vsubq_f32(v34, v36);
        v38 = vmulq_f32(v37, v37);
        v39 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 70), v36);
        v40 = vbslq_s8((int8x16_t)vcgtq_f32(v20, vsubq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v21, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2), vmulq_laneq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v22, vorrq_s8((int8x16_t)vcltzq_f32(v33), (int8x16_t)vcgezq_f32(v33))), v20), (int8x16_t)vmulq_f32(vaddq_f32(v22, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 71), v39)),
                                                           vmulq_f32(vaddq_f32(v22, vmulq_f32(v37, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 68), vmulq_f32(v37, *((float32x4_t *)a2 + 69))), vmulq_f32(v38, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 66), vmulq_f32(*((float32x4_t *)a2 + 67), v37)), vmulq_f32(v38, vaddq_f32(*((float32x4_t *)a2 + 64), vmulq_f32(*((float32x4_t *)a2 + 65), v37)))))))),
                                                             (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(vaddq_f32(v36, (float32x4_t)vandq_s8(v24, v39)))), 0x17uLL))), (int8x16_t)v33), *(float32x4_t *)a2, 3)));
        v41 = *((int8x16_t *)a2 + 15);
        v42 = (float32x4_t)vbslq_s8(v41, (int8x16_t)v19, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(v41, (int8x16_t)v19, v40)));
        *(int8x16_t *)(v6 + v10) = vbslq_s8(v41, (int8x16_t)v19, (int8x16_t)vmulq_laneq_f32(v42, v42, 3));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v7;
      v6 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Getrec709_fast_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  float32x4_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t *v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  int8x16_t *v50;
  int8x16_t *v51;
  float32x4_t v52;
  int8x16_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  int8x16_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v57 = 0;
        v58 = 16 * v8;
        v59 = 16 * v7;
        v60 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v61 = 0;
          do
          {
            v62 = *((int8x16_t *)a2 + 15);
            v63 = vmulq_f32(v5[v61 / 0x10], (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5[v61 / 0x10], 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v64 = vminq_f32(vmaxq_f32(v63, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v65 = (float32x4_t)vbslq_s8(v62, (int8x16_t)v63, (int8x16_t)vmulq_f32(v64, vminq_f32(vrsqrteq_f32(v64), *((float32x4_t *)a2 + 73))));
            v6[v61 / 0x10] = vbslq_s8(v62, (int8x16_t)v63, (int8x16_t)vmulq_laneq_f32(v65, v65, 3));
            v61 += 16;
          }
          while (v60 != v61);
          ++v57;
          v5 = (float32x4_t *)((char *)v5 + v58);
          v6 = (int8x16_t *)((char *)v6 + v59);
        }
        while (v57 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v5[v17 - 2];
          v19 = v5[v17 - 1];
          v20 = v5[v17];
          v21 = v5[v17 + 1];
          v23 = *((int8x16_t *)a2 + 15);
          v22 = *((float32x4_t *)a2 + 16);
          v24 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 3), v22);
          v25 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 3), v22));
          v26 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3), v22));
          v27 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 3), v22));
          v28 = *((int8x16_t *)a2 + 17);
          v29 = vandq_s8(v28, v25);
          v30 = vandq_s8(v28, v26);
          v31 = vandq_s8(v28, v27);
          v32 = vandq_s8(v28, (int8x16_t)vrecpeq_f32(v24));
          v33 = *((int8x16_t *)a2 + 3);
          v34 = vmulq_f32(v18, (float32x4_t)vorrq_s8(v29, v33));
          v35 = vmulq_f32(v19, (float32x4_t)vorrq_s8(v30, v33));
          v36 = vmulq_f32(v20, (float32x4_t)vorrq_s8(v31, v33));
          v37 = vmulq_f32(v21, (float32x4_t)vorrq_s8(v32, v33));
          v38 = *((float32x4_t *)a2 + 75);
          v39 = *((float32x4_t *)a2 + 5);
          v40 = vminq_f32(vmaxq_f32(v34, v38), v39);
          v41 = vminq_f32(vmaxq_f32(v35, v38), v39);
          v42 = vminq_f32(vmaxq_f32(v36, v38), v39);
          v43 = vminq_f32(vmaxq_f32(v37, v38), v39);
          v44 = *((float32x4_t *)a2 + 73);
          v45 = v16;
          v46 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v34, (int8x16_t)vmulq_f32(v40, vminq_f32(vrsqrteq_f32(v40), v44)));
          v47 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v35, (int8x16_t)vmulq_f32(v41, vminq_f32(vrsqrteq_f32(v41), v44)));
          v48 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v36, (int8x16_t)vmulq_f32(v42, vminq_f32(vrsqrteq_f32(v42), v44)));
          v49 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v37, (int8x16_t)vmulq_f32(v43, vminq_f32(vrsqrteq_f32(v43), v44)));
          v50 = v15;
          v51 = &v6[v17];
          v14 += 4;
          v51[-2] = vbslq_s8(v23, (int8x16_t)v34, (int8x16_t)vmulq_laneq_f32(v46, v46, 3));
          v51[-1] = vbslq_s8(v23, (int8x16_t)v35, (int8x16_t)vmulq_laneq_f32(v47, v47, 3));
          *v51 = vbslq_s8(v23, (int8x16_t)v36, (int8x16_t)vmulq_laneq_f32(v48, v48, 3));
          v51[1] = vbslq_s8(v23, (int8x16_t)v37, (int8x16_t)vmulq_laneq_f32(v49, v49, 3));
          v17 += 4;
          v16 += 4;
          v15 = v50 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v52 = *v45++;
            v53 = *((int8x16_t *)a2 + 15);
            v54 = vmulq_f32(v52, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v55 = vminq_f32(vmaxq_f32(v54, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v56 = (float32x4_t)vbslq_s8(v53, (int8x16_t)v54, (int8x16_t)vmulq_f32(v55, vminq_f32(vrsqrteq_f32(v55), *((float32x4_t *)a2 + 73))));
            *v50++ = vbslq_s8(v53, (int8x16_t)v54, (int8x16_t)vmulq_laneq_f32(v56, v56, 3));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getrec709_fixed_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int8x16_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  int8x16_t *v85;
  uint64_t v86;
  int8x16_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v86) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v17 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15));
      v18 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15));
      v19 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v15));
      v21 = *((int8x16_t *)a2 + 17);
      v20 = *((float32x4_t *)a2 + 18);
      v22 = (int8x16_t)vmulq_f32(v19, v20);
      v23 = vandq_s8(v21, (int8x16_t)vmulq_f32(v17, v20));
      v24 = vandq_s8(v21, (int8x16_t)vmulq_f32(v18, v20));
      v25 = *((int8x16_t *)a2 + 3);
      v26 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v23, v25));
      v27 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v24, v25));
      v28 = vmulq_f32(v14, (float32x4_t)vorrq_s8(vandq_s8(v21, v22), v25));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = *((float32x4_t *)a2 + 6);
      v32 = vminq_f32(vmaxq_f32(v26, v29), v30);
      v33 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v34 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v35 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)v32));
      v36 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)v33));
      v37 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)v34));
      v38 = vcvtq_f32_s32(vcvtq_s32_f32(v35));
      v39 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
      v40 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
      v41 = *((float32x4_t *)a2 + 7);
      v42 = *((float32x4_t *)a2 + 8);
      v43 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v35, v38), v41));
      v44 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v36, v39), v41));
      v45 = vrsqrteq_f32(vaddq_f32(v41, vsubq_f32(v37, v40)));
      v46 = vaddq_f32(v42, v38);
      v47 = vaddq_f32(v42, v39);
      v48 = vaddq_f32(v42, v40);
      v49 = *((float32x4_t *)a2 + 9);
      v50 = *((float32x4_t *)a2 + 10);
      v51 = vsubq_f32(v46, vmulq_f32(v43, v49));
      v52 = *((float32x4_t *)a2 + 77);
      v53 = vmulq_f32(v52, v51);
      v54 = vmulq_f32(v52, vsubq_f32(v47, vmulq_f32(v44, v49)));
      v55 = vmulq_f32(v52, vsubq_f32(v48, vmulq_f32(v45, v49)));
      v56 = vcvtq_f32_s32(vcvtq_s32_f32(v53));
      v57 = vcvtq_f32_s32(vcvtq_s32_f32(v54));
      v58 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      v59 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v56, v53)));
      v60 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v57, v54)));
      v61 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v58, v55)));
      v62 = *((float32x4_t *)a2 + 11);
      v63 = *((float32x4_t *)a2 + 12);
      v64 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v53, v59))), v63);
      v65 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v54, v60))), v63);
      v66 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v55, v61))), v63);
      v67 = vaddq_f32(vaddq_f32(v50, v61), vmulq_f32(v66, v66));
      v68 = vmaxq_f32(vaddq_f32(vaddq_f32(v50, v59), vmulq_f32(v64, v64)), v29);
      v69 = vmaxq_f32(vaddq_f32(vaddq_f32(v50, v60), vmulq_f32(v65, v65)), v29);
      v70 = *((float32x4_t *)a2 + 13);
      v71 = *((float32x4_t *)a2 + 14);
      v72 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v68, v70), v71));
      v73 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v69, v70), v71));
      v74 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v67, v29), v70), v71));
      v75 = *((float32x4_t *)a2 + 78);
      v76 = *((float32x4_t *)a2 + 79);
      v77 = (int8x16_t)vaddq_f32(v75, vmulq_f32(v76, v72));
      v78 = vmulq_f32(v76, v73);
      v79 = vmulq_f32(v76, v74);
      v80 = *((float32x4_t *)a2 + 80);
      v81 = *((float32x4_t *)a2 + 81);
      v82 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v26, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v81)), (int8x16_t)vmulq_f32(v32, v80), v77));
      v83 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v27, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v33, v81)), (int8x16_t)vmulq_f32(v33, v80), (int8x16_t)vaddq_f32(v75, v78)));
      v84 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v28, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v34, v81)), (int8x16_t)vmulq_f32(v34, v80), (int8x16_t)vaddq_f32(v75, v79)));
      v85 = (int8x16_t *)(v6 + v10);
      *v85 = vbslq_s8(v16, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v82, v82, 3));
      v85[1] = vbslq_s8(v16, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v83, v83, 3));
      v85[2] = vbslq_s8(v16, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v84, v84, 3));
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v86) = -v11;
    if ((int)v86 >= v5)
      goto LABEL_3;
LABEL_10:
    v86 = v86;
    do
    {
      v87 = *((int8x16_t *)a2 + 15);
      v88 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v86), (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v7 + 16 * v86), 3), *((float32x4_t *)a2 + 16))), *((float32x4_t *)a2 + 18))), *((int8x16_t *)a2 + 3)));
      v89 = *((float32x4_t *)a2 + 75);
      v90 = *((float32x4_t *)a2 + 5);
      v91 = vminq_f32(vmaxq_f32(v88, v89), v90);
      v92 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)v91));
      v93 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
      v94 = vmulq_f32(*((float32x4_t *)a2 + 77), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v93), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v92, v93))), *((float32x4_t *)a2 + 9))));
      v95 = vcvtq_f32_s32(vcvtq_s32_f32(v94));
      v96 = vsubq_f32(v95, (float32x4_t)vandq_s8((int8x16_t)v90, (int8x16_t)vcgtq_f32(v95, v94)));
      v97 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v94, v96))), *((float32x4_t *)a2 + 12));
      v98 = (float32x4_t)vbslq_s8(v87, (int8x16_t)v88, vbslq_s8((int8x16_t)vcgtq_f32(v89, vsubq_f32(v91, *((float32x4_t *)a2 + 81))), (int8x16_t)vmulq_f32(v91, *((float32x4_t *)a2 + 80)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 78), vmulq_f32(*((float32x4_t *)a2 + 79), (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v96), vmulq_f32(v97, v97)), v89), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14)))))));
      *(int8x16_t *)(v6 + 16 * v86++) = vbslq_s8(v87, (int8x16_t)v88, (int8x16_t)vmulq_laneq_f32(v98, v98, 3));
    }
    while (v86 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec709_nice_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t v95;
  float32x4_t v96;
  int8x16_t v97;
  int8x16_t v98;
  float32x4_t v99;
  int8x16_t v100;
  int8x16_t v101;
  float32x4_t v102;
  float32x4_t v103;
  int8x16_t *v104;
  int v105;
  uint64_t v106;
  float32x4_t v107;
  int8x16_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v105 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = *((int8x16_t *)a2 + 17);
      v24 = vandq_s8(v23, v22);
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v32 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v33 = *((float32x4_t *)a2 + 77);
      v34 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vceqq_f32(v33, v29)), v29);
      v35 = (float32x4_t)vbslq_s8(v34, (int8x16_t)v30, (int8x16_t)v31);
      v36 = (float32x4_t)vbslq_s8(v34, (int8x16_t)v30, (int8x16_t)v32);
      v37 = *((int8x16_t *)a2 + 19);
      v38 = *((float32x4_t *)a2 + 20);
      v39 = (float32x4_t)vorrq_s8(vandq_s8(v37, (int8x16_t)v35), (int8x16_t)v30);
      v40 = (float32x4_t)vorrq_s8(vandq_s8(v37, (int8x16_t)v36), (int8x16_t)v30);
      v41 = *((int8x16_t *)a2 + 21);
      v42 = *((float32x4_t *)a2 + 22);
      v43 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v36, 0x17uLL)), (float32x4_t)vandq_s8(v41, (int8x16_t)vcgtq_f32(v38, v36)));
      v44 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v35, 0x17uLL)), (float32x4_t)vandq_s8(v41, (int8x16_t)vcgtq_f32(v38, v35))), v42);
      v45 = *((float32x4_t *)a2 + 23);
      v46 = *((float32x4_t *)a2 + 24);
      v47 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v39, v45));
      v48 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v40, v45));
      v49 = vaddq_f32(v44, v47);
      v50 = vaddq_f32(vsubq_f32(v43, v42), v48);
      v51 = vsubq_f32(vsubq_f32(v39, v30), vmulq_f32(vmulq_f32(v46, v47), v39));
      v52 = vsubq_f32(vsubq_f32(v40, v30), vmulq_f32(vmulq_f32(v46, v48), v40));
      v53 = vmulq_f32(v51, v51);
      v54 = *((float32x4_t *)a2 + 37);
      v55 = *((float32x4_t *)a2 + 38);
      v56 = vaddq_f32(v54, vmulq_f32(v55, v51));
      v57 = vaddq_f32(v54, vmulq_f32(v55, v52));
      v58 = *((float32x4_t *)a2 + 39);
      v59 = *((float32x4_t *)a2 + 40);
      v60 = vaddq_f32(v58, vmulq_f32(v59, v51));
      v61 = vaddq_f32(v58, vmulq_f32(v59, v52));
      v62 = *((float32x4_t *)a2 + 41);
      v63 = *((float32x4_t *)a2 + 42);
      v64 = vaddq_f32(v62, vmulq_f32(v63, v51));
      v65 = vaddq_f32(v62, vmulq_f32(v63, v52));
      v66 = vmulq_f32(v52, v52);
      v67 = vaddq_f32(v65, vmulq_f32(v66, vaddq_f32(v57, vmulq_f32(v66, v61))));
      v68 = vmulq_f32(v51, vaddq_f32(v64, vmulq_f32(v53, vaddq_f32(v56, vmulq_f32(v53, v60)))));
      v69 = *((float32x4_t *)a2 + 43);
      v70 = *((float32x4_t *)a2 + 44);
      v71 = vaddq_f32(v50, vmulq_f32(v52, vaddq_f32(v69, vmulq_f32(v52, v67))));
      v72 = vmulq_f32(v33, vaddq_f32(v49, vmulq_f32(v51, vaddq_f32(v69, v68))));
      v73 = *((float32x4_t *)a2 + 29);
      v74 = vmulq_f32(v33, v71);
      v75 = vmaxq_f32(v72, v73);
      v76 = vmaxq_f32(v74, v73);
      v77 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v76));
      v79 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v77, v75)));
      v80 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v78, v76)));
      v81 = vsubq_f32(v75, v79);
      v82 = vsubq_f32(v76, v80);
      v83 = *((float32x4_t *)a2 + 45);
      v84 = *((float32x4_t *)a2 + 46);
      v85 = *((float32x4_t *)a2 + 47);
      v86 = *((float32x4_t *)a2 + 48);
      v87 = vaddq_f32(v30, vmulq_f32(v81, vaddq_f32(v86, vmulq_f32(v81, vaddq_f32(vaddq_f32(v84, vmulq_f32(v81, v85)), vmulq_f32(vmulq_f32(v81, v81), vaddq_f32(v70, vmulq_f32(v83, v81))))))));
      v88 = vaddq_f32(v30, vmulq_f32(v82, vaddq_f32(v86, vmulq_f32(v82, vaddq_f32(vaddq_f32(v84, vmulq_f32(v85, v82)), vmulq_f32(vmulq_f32(v82, v82), vaddq_f32(v70, vmulq_f32(v83, v82))))))));
      v89 = *((int32x4_t *)a2 + 33);
      v90 = vmulq_f32(v87, (float32x4_t)vshlq_n_s32(vaddq_s32(v89, vcvtq_s32_f32(v79)), 0x17uLL));
      v91 = vmulq_f32(v88, (float32x4_t)vshlq_n_s32(vaddq_s32(v89, vcvtq_s32_f32(v80)), 0x17uLL));
      v92 = *((float32x4_t *)a2 + 78);
      v93 = *((float32x4_t *)a2 + 79);
      v94 = vmulq_f32(v93, v91);
      v95 = (int8x16_t)vaddq_f32(v92, vmulq_f32(v93, v90));
      v96 = *((float32x4_t *)a2 + 80);
      v97 = (int8x16_t)vmulq_f32(v31, v96);
      v98 = (int8x16_t)vmulq_f32(v32, v96);
      v99 = *((float32x4_t *)a2 + 81);
      v100 = (int8x16_t)vcgtq_f32(v29, vsubq_f32(v31, v99));
      v101 = (int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v99));
      v102 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, vbslq_s8(v100, v97, v95));
      v103 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, vbslq_s8(v101, v98, (int8x16_t)vaddq_f32(v92, v94)));
      v104 = (int8x16_t *)(v6 + v11);
      v104[-1] = vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v102, v102, 3));
      *v104 = vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v103, v103, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v105 = -v10;
    if (v105 >= v5)
      goto LABEL_3;
LABEL_10:
    v106 = 16 * v105;
    v107 = *(float32x4_t *)(v7 + v106);
    v108 = *((int8x16_t *)a2 + 15);
    v109 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3), *((float32x4_t *)a2 + 16));
    v110 = vrecpeq_f32(v109);
    v111 = vmulq_f32(v110, vrecpsq_f32(v110, v109));
    v112 = vmulq_f32(v107, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v111, vrecpsq_f32(v111, v109))), *((int8x16_t *)a2 + 3)));
    v113 = *((float32x4_t *)a2 + 75);
    v114 = *((float32x4_t *)a2 + 5);
    v115 = vminq_f32(vmaxq_f32(v112, v113), v114);
    v116 = *((float32x4_t *)a2 + 77);
    v117 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v114, (int8x16_t)vceqq_f32(v116, v113)), v113), (int8x16_t)v114, (int8x16_t)v115);
    v118 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v117), (int8x16_t)v114);
    v119 = (float32x4_t)vandq_s8((int8x16_t)v114, (int8x16_t)vcgtq_f32(v118, *((float32x4_t *)a2 + 23)));
    v120 = vsubq_f32(vsubq_f32(v118, v114), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v119), v118));
    v121 = vmulq_f32(v120, v120);
    v122 = vmaxq_f32(vmulq_f32(v116, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v117, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v117))), *((float32x4_t *)a2 + 22)), v119), vmulq_f32(v120, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v120, vaddq_f32(
                         vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v120)),
                         vmulq_f32(v121, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v120)), vmulq_f32(v121, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v120))))))))))), *((float32x4_t *)a2 + 29));
    v123 = vcvtq_f32_s32(vcvtq_s32_f32(v122));
    v124 = vsubq_f32(v123, (float32x4_t)vandq_s8((int8x16_t)v114, (int8x16_t)vcgtq_f32(v123, v122)));
    v125 = vsubq_f32(v122, v124);
    v126 = (float32x4_t)vbslq_s8(v108, (int8x16_t)v112, vbslq_s8((int8x16_t)vcgtq_f32(v113, vsubq_f32(v115, *((float32x4_t *)a2 + 81))), (int8x16_t)vmulq_f32(v115, *((float32x4_t *)a2 + 80)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 78), vmulq_f32(*((float32x4_t *)a2 + 79), vmulq_f32(vaddq_f32(v114, vmulq_f32(v125, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v125, vaddq_f32(
                                                       vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v125)), vmulq_f32(vmulq_f32(v125, v125), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v125)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v124)), 0x17uLL))))));
    *(int8x16_t *)(v6 + v106) = vbslq_s8(v108, (int8x16_t)v112, (int8x16_t)vmulq_laneq_f32(v126, v126, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec709_half_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int8x16_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int8x16_t *v78;
  int v79;
  uint64_t v80;
  float32x4_t v81;
  int8x16_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v79 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23));
      v26 = *((float32x4_t *)a2 + 75);
      v27 = *((float32x4_t *)a2 + 5);
      v28 = vminq_f32(vmaxq_f32(v24, v26), v27);
      v29 = vminq_f32(vmaxq_f32(v25, v26), v27);
      v30 = *((int8x16_t *)a2 + 19);
      v31 = *((float32x4_t *)a2 + 20);
      v32 = (float32x4_t)vorrq_s8(vandq_s8(v30, (int8x16_t)v28), (int8x16_t)v27);
      v33 = *((int8x16_t *)a2 + 21);
      v34 = *((float32x4_t *)a2 + 22);
      v35 = (float32x4_t)vorrq_s8(vandq_s8(v30, (int8x16_t)v29), (int8x16_t)v27);
      v36 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x17uLL)), (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v31, v28))), v34);
      v37 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x17uLL)), (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v31, v29))), v34);
      v38 = *((float32x4_t *)a2 + 23);
      v39 = *((float32x4_t *)a2 + 24);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v32, v38));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v35, v38));
      v42 = vaddq_f32(v37, v41);
      v43 = vsubq_f32(vsubq_f32(v32, v27), vmulq_f32(vmulq_f32(v39, v40), v32));
      v44 = vsubq_f32(vsubq_f32(v35, v27), vmulq_f32(vmulq_f32(v39, v41), v35));
      v45 = *((float32x4_t *)a2 + 25);
      v46 = *((float32x4_t *)a2 + 26);
      v47 = *((float32x4_t *)a2 + 27);
      v48 = *((float32x4_t *)a2 + 28);
      v49 = vaddq_f32(v42, vmulq_f32(v44, vaddq_f32(vaddq_f32(v47, vmulq_f32(v44, v48)), vmulq_f32(vmulq_f32(v44, v44), vaddq_f32(v45, vmulq_f32(v46, v44))))));
      v50 = *((float32x4_t *)a2 + 77);
      v51 = vmulq_f32(v50, vaddq_f32(vaddq_f32(v36, v40), vmulq_f32(v43, vaddq_f32(vaddq_f32(v47, vmulq_f32(v43, v48)), vmulq_f32(vmulq_f32(v43, v43), vaddq_f32(v45, vmulq_f32(v46, v43)))))));
      v52 = vmulq_f32(v50, v49);
      v53 = *((float32x4_t *)a2 + 29);
      v54 = *((float32x4_t *)a2 + 30);
      v55 = vmaxq_f32(v51, v53);
      v56 = vmaxq_f32(v52, v53);
      v57 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      v58 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
      v59 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v57, v55)));
      v60 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v58, v56)));
      v61 = vsubq_f32(v55, v59);
      v62 = vsubq_f32(v56, v60);
      v63 = *((float32x4_t *)a2 + 31);
      v64 = *((float32x4_t *)a2 + 32);
      v65 = vaddq_f32(v27, vmulq_f32(v61, vaddq_f32(v64, vmulq_f32(v61, vaddq_f32(v54, vmulq_f32(v63, v61))))));
      v66 = vaddq_f32(v27, vmulq_f32(v62, vaddq_f32(v64, vmulq_f32(v62, vaddq_f32(v54, vmulq_f32(v63, v62))))));
      v67 = *((int32x4_t *)a2 + 33);
      v68 = vmulq_f32(v65, (float32x4_t)vshlq_n_s32(vaddq_s32(v67, vcvtq_s32_f32(v59)), 0x17uLL));
      v69 = vmulq_f32(v66, (float32x4_t)vshlq_n_s32(vaddq_s32(v67, vcvtq_s32_f32(v60)), 0x17uLL));
      v70 = *((float32x4_t *)a2 + 78);
      v71 = *((float32x4_t *)a2 + 79);
      v72 = vmulq_f32(v71, v69);
      v73 = (int8x16_t)vaddq_f32(v70, vmulq_f32(v71, v68));
      v74 = *((float32x4_t *)a2 + 80);
      v75 = *((float32x4_t *)a2 + 81);
      v76 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v24, vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v28, v75)), (int8x16_t)vmulq_f32(v28, v74), v73));
      v77 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v25, vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v29, v75)), (int8x16_t)vmulq_f32(v29, v74), (int8x16_t)vaddq_f32(v70, v72)));
      v78 = (int8x16_t *)(v6 + v11);
      v78[-1] = vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v76, v76, 3));
      *v78 = vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v77, v77, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v79 = -v10;
    if (v79 >= v5)
      goto LABEL_3;
LABEL_10:
    v80 = 16 * v79;
    v81 = *(float32x4_t *)(v7 + v80);
    v82 = *((int8x16_t *)a2 + 15);
    v83 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v81, 3), *((float32x4_t *)a2 + 16));
    v84 = vmulq_f32(vrecpeq_f32(v83), *((float32x4_t *)a2 + 18));
    v85 = vmulq_f32(v81, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v84, vrecpsq_f32(v84, v83))), *((int8x16_t *)a2 + 3)));
    v86 = *((float32x4_t *)a2 + 75);
    v87 = *((float32x4_t *)a2 + 5);
    v88 = vminq_f32(vmaxq_f32(v85, v86), v87);
    v89 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v88), (int8x16_t)v87);
    v90 = (float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vcgtq_f32(v89, *((float32x4_t *)a2 + 23)));
    v91 = vsubq_f32(vsubq_f32(v89, v87), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v90), v89));
    v92 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 77), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v88, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v88))), *((float32x4_t *)a2 + 22)), v90), vmulq_f32(v91, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v91, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v91, v91), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v91))))))),
            *((float32x4_t *)a2 + 29));
    v93 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
    v94 = vsubq_f32(v93, (float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vcgtq_f32(v93, v92)));
    v95 = vsubq_f32(v92, v94);
    v96 = (float32x4_t)vbslq_s8(v82, (int8x16_t)v85, vbslq_s8((int8x16_t)vcgtq_f32(v86, vsubq_f32(v88, *((float32x4_t *)a2 + 81))), (int8x16_t)vmulq_f32(v88, *((float32x4_t *)a2 + 80)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 78), vmulq_f32(*((float32x4_t *)a2 + 79), vmulq_f32(vaddq_f32(v87, vmulq_f32(v95, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v95, vaddq_f32(
                                                      *((float32x4_t *)a2 + 30),
                                                      vmulq_f32(*((float32x4_t *)a2 + 31), v95)))))),
                                            (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v94)), 0x17uLL))))));
    *(int8x16_t *)(v6 + v80) = vbslq_s8(v82, (int8x16_t)v85, (int8x16_t)vmulq_laneq_f32(v96, v96, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec709_halfTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  int32x4_t v80;
  int32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int8x16_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t *v95;
  int v96;
  uint64_t v97;
  float32x4_t v98;
  int8x16_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  int8x16_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v96 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23));
      v26 = *((float32x4_t *)a2 + 82);
      v27 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmaxq_f32(v24, v26));
      v28 = *((float32x4_t *)a2 + 75);
      v29 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmaxq_f32(v25, v26));
      v30 = (int8x16_t)vcgtq_f32(v28, v27);
      v31 = (int8x16_t)vcgtq_f32(v28, v29);
      v32 = *((int8x16_t *)a2 + 83);
      v33 = *((float32x4_t *)a2 + 5);
      v34 = (float32x4_t)vbslq_s8(v31, v32, (int8x16_t)v33);
      v35 = vmulq_f32(v27, (float32x4_t)vbslq_s8(v30, v32, (int8x16_t)v33));
      v36 = vmulq_f32(v29, v34);
      v37 = *((float32x4_t *)a2 + 84);
      v38 = vminq_f32(v35, v37);
      v39 = *((int8x16_t *)a2 + 19);
      v40 = *((float32x4_t *)a2 + 20);
      v41 = vminq_f32(v36, v37);
      v42 = (float32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)v38), (int8x16_t)v33);
      v43 = (float32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)v41), (int8x16_t)v33);
      v44 = *((int8x16_t *)a2 + 21);
      v45 = *((float32x4_t *)a2 + 22);
      v46 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v41, 0x17uLL)), (float32x4_t)vandq_s8(v44, (int8x16_t)vcgtq_f32(v40, v41)));
      v47 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v38, 0x17uLL)), (float32x4_t)vandq_s8(v44, (int8x16_t)vcgtq_f32(v40, v38))), v45);
      v48 = *((float32x4_t *)a2 + 23);
      v49 = *((float32x4_t *)a2 + 24);
      v50 = (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v42, v48));
      v51 = (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v43, v48));
      v52 = vaddq_f32(v47, v50);
      v53 = vaddq_f32(vsubq_f32(v46, v45), v51);
      v54 = vsubq_f32(vsubq_f32(v42, v33), vmulq_f32(vmulq_f32(v49, v50), v42));
      v55 = vsubq_f32(vsubq_f32(v43, v33), vmulq_f32(vmulq_f32(v49, v51), v43));
      v56 = *((float32x4_t *)a2 + 25);
      v57 = *((float32x4_t *)a2 + 26);
      v58 = vaddq_f32(v56, vmulq_f32(v57, v54));
      v59 = vaddq_f32(v56, vmulq_f32(v57, v55));
      v60 = *((float32x4_t *)a2 + 27);
      v61 = *((float32x4_t *)a2 + 28);
      v62 = vaddq_f32(v53, vmulq_f32(v55, vaddq_f32(vaddq_f32(v60, vmulq_f32(v55, v61)), vmulq_f32(vmulq_f32(v55, v55), v59))));
      v63 = *((float32x4_t *)a2 + 77);
      v64 = vmulq_f32(v63, vaddq_f32(v52, vmulq_f32(v54, vaddq_f32(vaddq_f32(v60, vmulq_f32(v54, v61)), vmulq_f32(vmulq_f32(v54, v54), v58)))));
      v65 = vmulq_f32(v63, v62);
      v66 = *((float32x4_t *)a2 + 29);
      v67 = *((float32x4_t *)a2 + 30);
      v68 = vmaxq_f32(v64, v66);
      v69 = vmaxq_f32(v65, v66);
      v70 = vcvtq_f32_s32(vcvtq_s32_f32(v68));
      v71 = vcvtq_f32_s32(vcvtq_s32_f32(v69));
      v72 = vsubq_f32(v70, (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v70, v68)));
      v73 = vsubq_f32(v71, (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v71, v69)));
      v74 = vsubq_f32(v68, v72);
      v75 = vsubq_f32(v69, v73);
      v76 = *((float32x4_t *)a2 + 31);
      v77 = *((float32x4_t *)a2 + 32);
      v78 = vaddq_f32(v33, vmulq_f32(v74, vaddq_f32(v77, vmulq_f32(v74, vaddq_f32(v67, vmulq_f32(v76, v74))))));
      v79 = vaddq_f32(v33, vmulq_f32(v75, vaddq_f32(v77, vmulq_f32(v75, vaddq_f32(v67, vmulq_f32(v76, v75))))));
      v80 = vcvtq_s32_f32(v73);
      v81 = *((int32x4_t *)a2 + 33);
      v82 = vmulq_f32(v78, (float32x4_t)vshlq_n_s32(vaddq_s32(v81, vcvtq_s32_f32(v72)), 0x17uLL));
      v83 = vmulq_f32(v79, (float32x4_t)vshlq_n_s32(vaddq_s32(v81, v80), 0x17uLL));
      v84 = *((float32x4_t *)a2 + 78);
      v85 = *((float32x4_t *)a2 + 79);
      v86 = (int8x16_t)vaddq_f32(v84, vmulq_f32(v85, v82));
      v87 = vmulq_f32(v85, v83);
      v88 = *((float32x4_t *)a2 + 80);
      v89 = (int8x16_t)vaddq_f32(v84, v87);
      v90 = *((float32x4_t *)a2 + 81);
      v91 = (float32x4_t)vbslq_s8(v30, (int8x16_t)v26, (int8x16_t)v33);
      v92 = (float32x4_t)vbslq_s8(v31, (int8x16_t)v26, (int8x16_t)v33);
      v93 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v28, vsubq_f32(v35, v90)), (int8x16_t)vmulq_f32(v35, v88), v86), v91));
      v94 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v28, vsubq_f32(v36, v90)), (int8x16_t)vmulq_f32(v36, v88), v89), v92));
      v95 = (int8x16_t *)(v6 + v11);
      v95[-1] = vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v93, v93, 3));
      *v95 = vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v94, v94, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v96 = -v10;
    if (v96 >= v5)
      goto LABEL_3;
LABEL_10:
    v97 = 16 * v96;
    v98 = *(float32x4_t *)(v7 + v97);
    v99 = *((int8x16_t *)a2 + 15);
    v100 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v98, 3), *((float32x4_t *)a2 + 16));
    v101 = vmulq_f32(vrecpeq_f32(v100), *((float32x4_t *)a2 + 18));
    v102 = vmulq_f32(v98, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v101, vrecpsq_f32(v101, v100))), *((int8x16_t *)a2 + 3)));
    v103 = *((float32x4_t *)a2 + 82);
    v104 = (float32x4_t)vbslq_s8(v99, (int8x16_t)v102, (int8x16_t)vmaxq_f32(v102, v103));
    v105 = *((float32x4_t *)a2 + 75);
    v106 = (int8x16_t)vcgtq_f32(v105, v104);
    v107 = *((float32x4_t *)a2 + 5);
    v108 = vmulq_f32(v104, (float32x4_t)vbslq_s8(v106, *((int8x16_t *)a2 + 83), (int8x16_t)v107));
    v109 = vminq_f32(v108, *((float32x4_t *)a2 + 84));
    v110 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v109), (int8x16_t)v107);
    v111 = (float32x4_t)vandq_s8((int8x16_t)v107, (int8x16_t)vcgtq_f32(v110, *((float32x4_t *)a2 + 23)));
    v112 = vsubq_f32(vsubq_f32(v110, v107), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v111), v110));
    v113 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 77), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v109, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v109))), *((float32x4_t *)a2 + 22)), v111), vmulq_f32(v112, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v112, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v112, v112), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v112))))))),
             *((float32x4_t *)a2 + 29));
    v114 = vcvtq_f32_s32(vcvtq_s32_f32(v113));
    v115 = vsubq_f32(v114, (float32x4_t)vandq_s8((int8x16_t)v107, (int8x16_t)vcgtq_f32(v114, v113)));
    v116 = vsubq_f32(v113, v115);
    v117 = (float32x4_t)vbslq_s8(v99, (int8x16_t)v102, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v105, vsubq_f32(v108, *((float32x4_t *)a2 + 81))), (int8x16_t)vmulq_f32(v108, *((float32x4_t *)a2 + 80)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 78), vmulq_f32(*((float32x4_t *)a2 + 79), vmulq_f32(vaddq_f32(v107, vmulq_f32(v116, vaddq_f32(*((float32x4_t *)a2 + 32),
                                                                             vmulq_f32(v116, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v116)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v115)), 0x17uLL))))), (float32x4_t)vbslq_s8(v106, (int8x16_t)v103, (int8x16_t)v107)));
    *(int8x16_t *)(v6 + v97) = vbslq_s8(v99, (int8x16_t)v102, (int8x16_t)vmulq_laneq_f32(v117, v117, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec709_niceTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  int8x16_t v100;
  float32x4_t v101;
  float32x4_t v102;
  int8x16_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  int8x16_t *v109;
  int v110;
  uint64_t v111;
  float32x4_t v112;
  int8x16_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  int8x16_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v110 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17));
      v24 = *((int8x16_t *)a2 + 17);
      v25 = *((int8x16_t *)a2 + 3);
      v26 = vmulq_f32(v12, (float32x4_t)vorrq_s8(vandq_s8(v24, v22), v25));
      v27 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v24, v23), v25));
      v28 = *((float32x4_t *)a2 + 82);
      v29 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v26, (int8x16_t)vmaxq_f32(v26, v28));
      v30 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmaxq_f32(v27, v28));
      v31 = *((float32x4_t *)a2 + 75);
      v32 = (int8x16_t)vcgtq_f32(v31, v29);
      v33 = (int8x16_t)vcgtq_f32(v31, v30);
      v34 = *((int8x16_t *)a2 + 83);
      v35 = *((float32x4_t *)a2 + 5);
      v36 = (float32x4_t)vbslq_s8(v33, v34, (int8x16_t)v35);
      v37 = vmulq_f32(v29, (float32x4_t)vbslq_s8(v32, v34, (int8x16_t)v35));
      v38 = vmulq_f32(v30, v36);
      v39 = *((float32x4_t *)a2 + 84);
      v40 = *((float32x4_t *)a2 + 77);
      v41 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vceqq_f32(v40, v31)), v31);
      v42 = (float32x4_t)vbslq_s8(v41, (int8x16_t)v35, (int8x16_t)vminq_f32(v37, v39));
      v43 = (float32x4_t)vbslq_s8(v41, (int8x16_t)v35, (int8x16_t)vminq_f32(v38, v39));
      v44 = *((int8x16_t *)a2 + 19);
      v45 = *((float32x4_t *)a2 + 20);
      v46 = (float32x4_t)vorrq_s8(vandq_s8(v44, (int8x16_t)v42), (int8x16_t)v35);
      v47 = *((int8x16_t *)a2 + 21);
      v48 = *((float32x4_t *)a2 + 22);
      v49 = (float32x4_t)vorrq_s8(vandq_s8(v44, (int8x16_t)v43), (int8x16_t)v35);
      v50 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v43, 0x17uLL)), (float32x4_t)vandq_s8(v47, (int8x16_t)vcgtq_f32(v45, v43)));
      v51 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v42, 0x17uLL)), (float32x4_t)vandq_s8(v47, (int8x16_t)vcgtq_f32(v45, v42))), v48);
      v52 = *((float32x4_t *)a2 + 23);
      v53 = *((float32x4_t *)a2 + 24);
      v54 = (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v46, v52));
      v55 = (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v49, v52));
      v56 = vaddq_f32(v51, v54);
      v57 = vmulq_f32(v53, v54);
      v58 = vmulq_f32(vmulq_f32(v53, v55), v49);
      v59 = vaddq_f32(vsubq_f32(v50, v48), v55);
      v60 = vsubq_f32(vsubq_f32(v46, v35), vmulq_f32(v57, v46));
      v61 = vsubq_f32(vsubq_f32(v49, v35), v58);
      v62 = vmulq_f32(v60, v60);
      v63 = *((float32x4_t *)a2 + 37);
      v64 = *((float32x4_t *)a2 + 38);
      v65 = vmulq_f32(v61, v61);
      v66 = *((float32x4_t *)a2 + 39);
      v67 = *((float32x4_t *)a2 + 40);
      v68 = vaddq_f32(v63, vmulq_f32(v64, v60));
      v69 = vaddq_f32(v66, vmulq_f32(v67, v60));
      v70 = vaddq_f32(v66, vmulq_f32(v67, v61));
      v71 = vaddq_f32(v63, vmulq_f32(v64, v61));
      v73 = *((float32x4_t *)a2 + 41);
      v72 = *((float32x4_t *)a2 + 42);
      v74 = vmulq_f32(v60, vaddq_f32(vaddq_f32(v73, vmulq_f32(v72, v60)), vmulq_f32(v62, vaddq_f32(v68, vmulq_f32(v62, v69)))));
      v75 = vmulq_f32(v61, vaddq_f32(vaddq_f32(v73, vmulq_f32(v72, v61)), vmulq_f32(v65, vaddq_f32(v71, vmulq_f32(v65, v70)))));
      v76 = *((float32x4_t *)a2 + 43);
      v77 = *((float32x4_t *)a2 + 44);
      v78 = vmulq_f32(v40, vaddq_f32(v56, vmulq_f32(v60, vaddq_f32(v76, v74))));
      v79 = vmulq_f32(v40, vaddq_f32(v59, vmulq_f32(v61, vaddq_f32(v76, v75))));
      v80 = *((float32x4_t *)a2 + 29);
      v81 = vmaxq_f32(v78, v80);
      v82 = vmaxq_f32(v79, v80);
      v83 = vcvtq_f32_s32(vcvtq_s32_f32(v81));
      v84 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
      v85 = vsubq_f32(v83, (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v83, v81)));
      v86 = vsubq_f32(v84, (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v84, v82)));
      v87 = vsubq_f32(v81, v85);
      v88 = vsubq_f32(v82, v86);
      v89 = *((float32x4_t *)a2 + 45);
      v90 = *((float32x4_t *)a2 + 46);
      v91 = vaddq_f32(v77, vmulq_f32(v89, v87));
      v92 = vaddq_f32(v77, vmulq_f32(v89, v88));
      v93 = *((float32x4_t *)a2 + 47);
      v94 = *((float32x4_t *)a2 + 48);
      v95 = *((int32x4_t *)a2 + 33);
      v96 = vmulq_f32(vaddq_f32(v35, vmulq_f32(v87, vaddq_f32(v94, vmulq_f32(v87, vaddq_f32(vaddq_f32(v90, vmulq_f32(v87, v93)), vmulq_f32(vmulq_f32(v87, v87), v91)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v95, vcvtq_s32_f32(v85)), 0x17uLL));
      v97 = vmulq_f32(vaddq_f32(v35, vmulq_f32(v88, vaddq_f32(v94, vmulq_f32(v88, vaddq_f32(vaddq_f32(v90, vmulq_f32(v93, v88)), vmulq_f32(vmulq_f32(v88, v88), v92)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v95, vcvtq_s32_f32(v86)), 0x17uLL));
      v98 = *((float32x4_t *)a2 + 78);
      v99 = *((float32x4_t *)a2 + 79);
      v100 = (int8x16_t)vaddq_f32(v98, vmulq_f32(v99, v96));
      v101 = vmulq_f32(v99, v97);
      v102 = *((float32x4_t *)a2 + 80);
      v103 = (int8x16_t)vaddq_f32(v98, v101);
      v104 = *((float32x4_t *)a2 + 81);
      v105 = (float32x4_t)vbslq_s8(v32, (int8x16_t)v28, (int8x16_t)v35);
      v106 = (float32x4_t)vbslq_s8(v33, (int8x16_t)v28, (int8x16_t)v35);
      v107 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v26, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v31, vsubq_f32(v37, v104)), (int8x16_t)vmulq_f32(v37, v102), v100), v105));
      v108 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v31, vsubq_f32(v38, v104)), (int8x16_t)vmulq_f32(v38, v102), v103), v106));
      v109 = (int8x16_t *)(v6 + v11);
      v109[-1] = vbslq_s8(v14, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v107, v107, 3));
      *v109 = vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v108, v108, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v110 = -v10;
    if (v110 >= v5)
      goto LABEL_3;
LABEL_10:
    v111 = 16 * v110;
    v112 = *(float32x4_t *)(v7 + v111);
    v113 = *((int8x16_t *)a2 + 15);
    v114 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v112, 3), *((float32x4_t *)a2 + 16));
    v115 = vrecpeq_f32(v114);
    v116 = vmulq_f32(v115, vrecpsq_f32(v115, v114));
    v117 = vmulq_f32(v112, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v116, vrecpsq_f32(v116, v114))), *((int8x16_t *)a2 + 3)));
    v118 = *((float32x4_t *)a2 + 82);
    v119 = (float32x4_t)vbslq_s8(v113, (int8x16_t)v117, (int8x16_t)vmaxq_f32(v117, v118));
    v120 = *((float32x4_t *)a2 + 75);
    v121 = (int8x16_t)vcgtq_f32(v120, v119);
    v122 = *((float32x4_t *)a2 + 5);
    v123 = vmulq_f32(v119, (float32x4_t)vbslq_s8(v121, *((int8x16_t *)a2 + 83), (int8x16_t)v122));
    v124 = *((float32x4_t *)a2 + 77);
    v125 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v122, (int8x16_t)vceqq_f32(v124, v120)), v120), (int8x16_t)v122, (int8x16_t)vminq_f32(v123, *((float32x4_t *)a2 + 84)));
    v126 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v125), (int8x16_t)v122);
    v127 = (float32x4_t)vandq_s8((int8x16_t)v122, (int8x16_t)vcgtq_f32(v126, *((float32x4_t *)a2 + 23)));
    v128 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v125, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v125))), *((float32x4_t *)a2 + 22)), v127);
    v129 = vsubq_f32(vsubq_f32(v126, v122), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v127), v126));
    v130 = vmulq_f32(v129, v129);
    v131 = vmaxq_f32(vmulq_f32(v124, vaddq_f32(v128, vmulq_f32(v129, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v129, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v129)), vmulq_f32(v130, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v129)), vmulq_f32(v130, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v129))))))))))),
             *((float32x4_t *)a2 + 29));
    v132 = vcvtq_f32_s32(vcvtq_s32_f32(v131));
    v133 = vsubq_f32(v132, (float32x4_t)vandq_s8((int8x16_t)v122, (int8x16_t)vcgtq_f32(v132, v131)));
    v134 = vsubq_f32(v131, v133);
    v135 = (float32x4_t)vbslq_s8(v113, (int8x16_t)v117, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v120, vsubq_f32(v123, *((float32x4_t *)a2 + 81))), (int8x16_t)vmulq_f32(v123, *((float32x4_t *)a2 + 80)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 78), vmulq_f32(*((float32x4_t *)a2 + 79), vmulq_f32(vaddq_f32(v122, vmulq_f32(v134, vaddq_f32(*((float32x4_t *)a2 + 48),
                                                                             vmulq_f32(v134, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v134)), vmulq_f32(vmulq_f32(v134, v134), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v134)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v133)), 0x17uLL))))),
                                       (float32x4_t)vbslq_s8(v121, (int8x16_t)v118, (int8x16_t)v122)));
    *(int8x16_t *)(v6 + v111) = vbslq_s8(v113, (int8x16_t)v117, (int8x16_t)vmulq_laneq_f32(v135, v135, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec709_fast_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t *v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  int8x16_t *v49;
  int8x16_t *v50;
  float32x4_t v51;
  int8x16_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v56 = 0;
        v57 = 16 * v8;
        v58 = 16 * v7;
        v59 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v60 = 0;
          do
          {
            v61 = *((int8x16_t *)a2 + 15);
            v62 = vmulq_f32(v5[v60 / 0x10], (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5[v60 / 0x10], 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v63 = vminq_f32(vmaxq_f32(v62, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v64 = (float32x4_t)vbslq_s8(v61, (int8x16_t)v62, (int8x16_t)vmulq_f32(v63, v63));
            v6[v60 / 0x10] = vbslq_s8(v61, (int8x16_t)v62, (int8x16_t)vmulq_laneq_f32(v64, v64, 3));
            v60 += 16;
          }
          while (v59 != v60);
          ++v56;
          v5 = (float32x4_t *)((char *)v5 + v57);
          v6 = (int8x16_t *)((char *)v6 + v58);
        }
        while (v56 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v5[v17 - 2];
          v19 = v5[v17 - 1];
          v20 = v5[v17];
          v21 = v5[v17 + 1];
          v23 = *((int8x16_t *)a2 + 15);
          v22 = *((float32x4_t *)a2 + 16);
          v24 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 3), v22));
          v25 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3), v22));
          v26 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 3), v22));
          v27 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 3), v22));
          v28 = *((int8x16_t *)a2 + 17);
          v29 = vandq_s8(v28, v24);
          v30 = vandq_s8(v28, v25);
          v31 = vandq_s8(v28, v26);
          v32 = vandq_s8(v28, v27);
          v33 = *((int8x16_t *)a2 + 3);
          v34 = vmulq_f32(v18, (float32x4_t)vorrq_s8(v29, v33));
          v35 = vmulq_f32(v19, (float32x4_t)vorrq_s8(v30, v33));
          v36 = vmulq_f32(v20, (float32x4_t)vorrq_s8(v31, v33));
          v37 = vmulq_f32(v21, (float32x4_t)vorrq_s8(v32, v33));
          v38 = *((float32x4_t *)a2 + 75);
          v39 = *((float32x4_t *)a2 + 5);
          v40 = vminq_f32(vmaxq_f32(v34, v38), v39);
          v41 = vminq_f32(vmaxq_f32(v35, v38), v39);
          v42 = vminq_f32(vmaxq_f32(v36, v38), v39);
          v43 = vminq_f32(vmaxq_f32(v37, v38), v39);
          v44 = v16;
          v45 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v34, (int8x16_t)vmulq_f32(v40, v40));
          v46 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v35, (int8x16_t)vmulq_f32(v41, v41));
          v47 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v36, (int8x16_t)vmulq_f32(v42, v42));
          v48 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v37, (int8x16_t)vmulq_f32(v43, v43));
          v49 = v15;
          v50 = &v6[v17];
          v14 += 4;
          v50[-2] = vbslq_s8(v23, (int8x16_t)v34, (int8x16_t)vmulq_laneq_f32(v45, v45, 3));
          v50[-1] = vbslq_s8(v23, (int8x16_t)v35, (int8x16_t)vmulq_laneq_f32(v46, v46, 3));
          *v50 = vbslq_s8(v23, (int8x16_t)v36, (int8x16_t)vmulq_laneq_f32(v47, v47, 3));
          v50[1] = vbslq_s8(v23, (int8x16_t)v37, (int8x16_t)vmulq_laneq_f32(v48, v48, 3));
          v17 += 4;
          v16 += 4;
          v15 = v49 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v51 = *v44++;
            v52 = *((int8x16_t *)a2 + 15);
            v53 = vmulq_f32(v51, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v54 = vminq_f32(vmaxq_f32(v53, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v55 = (float32x4_t)vbslq_s8(v52, (int8x16_t)v53, (int8x16_t)vmulq_f32(v54, v54));
            *v49++ = vbslq_s8(v52, (int8x16_t)v53, (int8x16_t)vmulq_laneq_f32(v55, v55, 3));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getinv_rec709_fixed_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int8x16_t *v83;
  uint64_t v84;
  int8x16_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v84) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v17 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15));
      v18 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15));
      v19 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v15));
      v21 = *((int8x16_t *)a2 + 17);
      v20 = *((float32x4_t *)a2 + 18);
      v22 = (int8x16_t)vmulq_f32(v19, v20);
      v23 = vandq_s8(v21, (int8x16_t)vmulq_f32(v17, v20));
      v24 = vandq_s8(v21, (int8x16_t)vmulq_f32(v18, v20));
      v25 = *((int8x16_t *)a2 + 3);
      v26 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v23, v25));
      v27 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v24, v25));
      v28 = vmulq_f32(v14, (float32x4_t)vorrq_s8(vandq_s8(v21, v22), v25));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = *((float32x4_t *)a2 + 6);
      v32 = vminq_f32(vmaxq_f32(v26, v29), v30);
      v33 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v34 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v35 = *((float32x4_t *)a2 + 85);
      v36 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)vaddq_f32(v32, v35)));
      v37 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)vaddq_f32(v33, v35)));
      v38 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)vaddq_f32(v34, v35)));
      v39 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
      v40 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
      v41 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
      v42 = *((float32x4_t *)a2 + 7);
      v43 = *((float32x4_t *)a2 + 8);
      v44 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v36, v39), v42));
      v45 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v37, v40), v42));
      v46 = vrsqrteq_f32(vaddq_f32(v42, vsubq_f32(v38, v41)));
      v47 = vaddq_f32(v43, v39);
      v48 = vaddq_f32(v43, v40);
      v49 = vaddq_f32(v43, v41);
      v50 = *((float32x4_t *)a2 + 9);
      v51 = *((float32x4_t *)a2 + 10);
      v52 = vsubq_f32(v47, vmulq_f32(v44, v50));
      v53 = vsubq_f32(v48, vmulq_f32(v45, v50));
      v54 = *((float32x4_t *)a2 + 86);
      v55 = vmulq_f32(v54, v52);
      v56 = vmulq_f32(v54, v53);
      v57 = vmulq_f32(v54, vsubq_f32(v49, vmulq_f32(v46, v50)));
      v58 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      v59 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
      v60 = vcvtq_f32_s32(vcvtq_s32_f32(v57));
      v61 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v58, v55)));
      v62 = vsubq_f32(v59, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v59, v56)));
      v63 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v60, v57)));
      v64 = *((float32x4_t *)a2 + 11);
      v65 = *((float32x4_t *)a2 + 12);
      v66 = vmulq_f32(vrecpeq_f32(vsubq_f32(v64, vsubq_f32(v55, v61))), v65);
      v67 = vmulq_f32(vrecpeq_f32(vsubq_f32(v64, vsubq_f32(v56, v62))), v65);
      v68 = vmulq_f32(vrecpeq_f32(vsubq_f32(v64, vsubq_f32(v57, v63))), v65);
      v69 = vaddq_f32(vaddq_f32(v51, v63), vmulq_f32(v68, v68));
      v70 = vmaxq_f32(vaddq_f32(vaddq_f32(v51, v61), vmulq_f32(v66, v66)), v29);
      v71 = vmaxq_f32(vaddq_f32(vaddq_f32(v51, v62), vmulq_f32(v67, v67)), v29);
      v72 = *((float32x4_t *)a2 + 13);
      v73 = *((float32x4_t *)a2 + 14);
      v74 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v70, v72), v73));
      v75 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v71, v72), v73));
      v76 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v69, v29), v72), v73));
      v77 = *((float32x4_t *)a2 + 87);
      v78 = *((float32x4_t *)a2 + 88);
      v79 = *((float32x4_t *)a2 + 89);
      v80 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v26, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v79)), (int8x16_t)vmulq_f32(v32, v78), (int8x16_t)vmulq_f32(v77, v74)));
      v81 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v27, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v33, v79)), (int8x16_t)vmulq_f32(v33, v78), (int8x16_t)vmulq_f32(v77, v75)));
      v82 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v28, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v34, v79)), (int8x16_t)vmulq_f32(v34, v78), (int8x16_t)vmulq_f32(v77, v76)));
      v83 = (int8x16_t *)(v6 + v10);
      *v83 = vbslq_s8(v16, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      v83[1] = vbslq_s8(v16, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      v83[2] = vbslq_s8(v16, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v82, v82, 3));
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v84) = -v11;
    if ((int)v84 >= v5)
      goto LABEL_3;
LABEL_10:
    v84 = v84;
    do
    {
      v85 = *((int8x16_t *)a2 + 15);
      v86 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v84), (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v7 + 16 * v84), 3), *((float32x4_t *)a2 + 16))), *((float32x4_t *)a2 + 18))), *((int8x16_t *)a2 + 3)));
      v87 = *((float32x4_t *)a2 + 75);
      v88 = *((float32x4_t *)a2 + 5);
      v89 = vminq_f32(vmaxq_f32(v86, v87), v88);
      v90 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v89, *((float32x4_t *)a2 + 85))));
      v91 = vcvtq_f32_s32(vcvtq_s32_f32(v90));
      v92 = vmulq_f32(*((float32x4_t *)a2 + 86), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v91), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v90, v91))), *((float32x4_t *)a2 + 9))));
      v93 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
      v94 = vsubq_f32(v93, (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v93, v92)));
      v95 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v92, v94))), *((float32x4_t *)a2 + 12));
      v96 = (float32x4_t)vbslq_s8(v85, (int8x16_t)v86, vbslq_s8((int8x16_t)vcgtq_f32(v87, vsubq_f32(v89, *((float32x4_t *)a2 + 89))), (int8x16_t)vmulq_f32(v89, *((float32x4_t *)a2 + 88)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 87), (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v94), vmulq_f32(v95, v95)), v87), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))))));
      *(int8x16_t *)(v6 + 16 * v84++) = vbslq_s8(v85, (int8x16_t)v86, (int8x16_t)vmulq_laneq_f32(v96, v96, 3));
    }
    while (v84 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec709_nice_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  int32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  int8x16_t v96;
  int8x16_t v97;
  float32x4_t v98;
  int8x16_t v99;
  int8x16_t v100;
  float32x4_t v101;
  float32x4_t v102;
  int8x16_t *v103;
  int v104;
  uint64_t v105;
  float32x4_t v106;
  int8x16_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v104 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = *((int8x16_t *)a2 + 17);
      v24 = vandq_s8(v23, v22);
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v32 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v33 = *((float32x4_t *)a2 + 85);
      v34 = *((float32x4_t *)a2 + 86);
      v35 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vceqq_f32(v34, v29)), v29);
      v36 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v30, (int8x16_t)vaddq_f32(v31, v33));
      v37 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v30, (int8x16_t)vaddq_f32(v32, v33));
      v38 = *((int8x16_t *)a2 + 19);
      v39 = *((float32x4_t *)a2 + 20);
      v40 = (float32x4_t)vorrq_s8(vandq_s8(v38, (int8x16_t)v36), (int8x16_t)v30);
      v41 = (float32x4_t)vorrq_s8(vandq_s8(v38, (int8x16_t)v37), (int8x16_t)v30);
      v42 = *((int8x16_t *)a2 + 21);
      v43 = *((float32x4_t *)a2 + 22);
      v44 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v36, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v39, v36)));
      v45 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v39, v37)));
      v46 = *((float32x4_t *)a2 + 23);
      v47 = *((float32x4_t *)a2 + 24);
      v48 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v40, v46));
      v49 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v41, v46));
      v50 = vaddq_f32(vsubq_f32(v44, v43), v48);
      v51 = vmulq_f32(v47, v48);
      v52 = vmulq_f32(vmulq_f32(v47, v49), v41);
      v53 = vaddq_f32(vsubq_f32(v45, v43), v49);
      v54 = vsubq_f32(vsubq_f32(v40, v30), vmulq_f32(v51, v40));
      v55 = vsubq_f32(vsubq_f32(v41, v30), v52);
      v56 = vmulq_f32(v54, v54);
      v57 = vmulq_f32(v55, v55);
      v58 = *((float32x4_t *)a2 + 37);
      v59 = *((float32x4_t *)a2 + 38);
      v60 = *((float32x4_t *)a2 + 39);
      v61 = *((float32x4_t *)a2 + 40);
      v62 = vaddq_f32(v58, vmulq_f32(v59, v54));
      v63 = vaddq_f32(v60, vmulq_f32(v61, v54));
      v64 = vaddq_f32(v60, vmulq_f32(v61, v55));
      v65 = vaddq_f32(v58, vmulq_f32(v59, v55));
      v66 = *((float32x4_t *)a2 + 41);
      v67 = *((float32x4_t *)a2 + 42);
      v68 = vaddq_f32(vaddq_f32(v66, vmulq_f32(v67, v55)), vmulq_f32(v57, vaddq_f32(v65, vmulq_f32(v57, v64))));
      v69 = vmulq_f32(v54, vaddq_f32(vaddq_f32(v66, vmulq_f32(v67, v54)), vmulq_f32(v56, vaddq_f32(v62, vmulq_f32(v56, v63)))));
      v70 = *((float32x4_t *)a2 + 43);
      v71 = *((float32x4_t *)a2 + 44);
      v72 = vmulq_f32(v34, vaddq_f32(v50, vmulq_f32(v54, vaddq_f32(v70, v69))));
      v73 = vmulq_f32(v34, vaddq_f32(v53, vmulq_f32(v55, vaddq_f32(v70, vmulq_f32(v55, v68)))));
      v74 = *((float32x4_t *)a2 + 29);
      v75 = vmaxq_f32(v72, v74);
      v76 = vmaxq_f32(v73, v74);
      v77 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v76));
      v79 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v77, v75)));
      v80 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v78, v76)));
      v81 = vsubq_f32(v75, v79);
      v82 = vsubq_f32(v76, v80);
      v83 = *((float32x4_t *)a2 + 45);
      v84 = *((float32x4_t *)a2 + 46);
      v85 = vaddq_f32(v71, vmulq_f32(v83, v81));
      v86 = vaddq_f32(v71, vmulq_f32(v83, v82));
      v87 = *((float32x4_t *)a2 + 47);
      v88 = *((float32x4_t *)a2 + 48);
      v89 = vaddq_f32(v30, vmulq_f32(v81, vaddq_f32(v88, vmulq_f32(v81, vaddq_f32(vaddq_f32(v84, vmulq_f32(v81, v87)), vmulq_f32(vmulq_f32(v81, v81), v85))))));
      v90 = *((int32x4_t *)a2 + 33);
      v91 = vaddq_f32(v30, vmulq_f32(v82, vaddq_f32(v88, vmulq_f32(v82, vaddq_f32(vaddq_f32(v84, vmulq_f32(v87, v82)), vmulq_f32(vmulq_f32(v82, v82), v86))))));
      v92 = vmulq_f32(v89, (float32x4_t)vshlq_n_s32(vaddq_s32(v90, vcvtq_s32_f32(v79)), 0x17uLL));
      v93 = vmulq_f32(v91, (float32x4_t)vshlq_n_s32(vaddq_s32(v90, vcvtq_s32_f32(v80)), 0x17uLL));
      v94 = *((float32x4_t *)a2 + 87);
      v95 = *((float32x4_t *)a2 + 88);
      v96 = (int8x16_t)vmulq_f32(v31, v95);
      v97 = (int8x16_t)vmulq_f32(v32, v95);
      v98 = *((float32x4_t *)a2 + 89);
      v99 = (int8x16_t)vcgtq_f32(v29, vsubq_f32(v31, v98));
      v100 = (int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v98));
      v101 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, vbslq_s8(v99, v96, (int8x16_t)vmulq_f32(v94, v92)));
      v102 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, vbslq_s8(v100, v97, (int8x16_t)vmulq_f32(v94, v93)));
      v103 = (int8x16_t *)(v6 + v11);
      v103[-1] = vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v101, v101, 3));
      *v103 = vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v102, v102, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v104 = -v10;
    if (v104 >= v5)
      goto LABEL_3;
LABEL_10:
    v105 = 16 * v104;
    v106 = *(float32x4_t *)(v7 + v105);
    v107 = *((int8x16_t *)a2 + 15);
    v108 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 3), *((float32x4_t *)a2 + 16));
    v109 = vrecpeq_f32(v108);
    v110 = vmulq_f32(v109, vrecpsq_f32(v109, v108));
    v111 = vmulq_f32(v106, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v110, vrecpsq_f32(v110, v108))), *((int8x16_t *)a2 + 3)));
    v112 = *((float32x4_t *)a2 + 75);
    v113 = *((float32x4_t *)a2 + 5);
    v114 = vminq_f32(vmaxq_f32(v111, v112), v113);
    v115 = *((float32x4_t *)a2 + 86);
    v116 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vceqq_f32(v115, v112)), v112), (int8x16_t)v113, (int8x16_t)vaddq_f32(v114, *((float32x4_t *)a2 + 85)));
    v117 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v116), (int8x16_t)v113);
    v118 = (float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v117, *((float32x4_t *)a2 + 23)));
    v119 = vsubq_f32(vsubq_f32(v117, v113), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v118), v117));
    v120 = vmulq_f32(v119, v119);
    v121 = vmaxq_f32(vmulq_f32(v115, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v116, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v116))), *((float32x4_t *)a2 + 22)), v118), vmulq_f32(v119, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v119, vaddq_f32(
                         vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v119)),
                         vmulq_f32(v120, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v119)), vmulq_f32(v120, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v119))))))))))), *((float32x4_t *)a2 + 29));
    v122 = vcvtq_f32_s32(vcvtq_s32_f32(v121));
    v123 = vsubq_f32(v122, (float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v122, v121)));
    v124 = vsubq_f32(v121, v123);
    v125 = (float32x4_t)vbslq_s8(v107, (int8x16_t)v111, vbslq_s8((int8x16_t)vcgtq_f32(v112, vsubq_f32(v114, *((float32x4_t *)a2 + 89))), (int8x16_t)vmulq_f32(v114, *((float32x4_t *)a2 + 88)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 87), vmulq_f32(vaddq_f32(v113, vmulq_f32(v124, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v124, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46),
                                                       vmulq_f32(*((float32x4_t *)a2 + 47), v124)),
                                                     vmulq_f32(vmulq_f32(v124, v124), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v124)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v123)), 0x17uLL)))));
    *(int8x16_t *)(v6 + v105) = vbslq_s8(v107, (int8x16_t)v111, (int8x16_t)vmulq_laneq_f32(v125, v125, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec709_half_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int32x4_t v73;
  int32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int8x16_t *v83;
  int v84;
  uint64_t v85;
  float32x4_t v86;
  int8x16_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v84 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23));
      v26 = *((float32x4_t *)a2 + 75);
      v27 = *((float32x4_t *)a2 + 5);
      v28 = vminq_f32(vmaxq_f32(v24, v26), v27);
      v29 = vminq_f32(vmaxq_f32(v25, v26), v27);
      v30 = *((float32x4_t *)a2 + 85);
      v31 = vaddq_f32(v28, v30);
      v32 = vaddq_f32(v29, v30);
      v33 = *((int8x16_t *)a2 + 19);
      v34 = *((float32x4_t *)a2 + 20);
      v35 = (float32x4_t)vorrq_s8(vandq_s8(v33, (int8x16_t)v31), (int8x16_t)v27);
      v36 = (float32x4_t)vorrq_s8(vandq_s8(v33, (int8x16_t)v32), (int8x16_t)v27);
      v37 = *((int8x16_t *)a2 + 21);
      v38 = *((float32x4_t *)a2 + 22);
      v39 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v32, 0x17uLL)), (float32x4_t)vandq_s8(v37, (int8x16_t)vcgtq_f32(v34, v32)));
      v40 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v31, 0x17uLL)), (float32x4_t)vandq_s8(v37, (int8x16_t)vcgtq_f32(v34, v31))), v38);
      v41 = *((float32x4_t *)a2 + 23);
      v42 = *((float32x4_t *)a2 + 24);
      v43 = vsubq_f32(v39, v38);
      v44 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v35, v41));
      v45 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v36, v41));
      v46 = vaddq_f32(v40, v44);
      v47 = vsubq_f32(vsubq_f32(v35, v27), vmulq_f32(vmulq_f32(v42, v44), v35));
      v48 = vsubq_f32(vsubq_f32(v36, v27), vmulq_f32(vmulq_f32(v42, v45), v36));
      v49 = *((float32x4_t *)a2 + 25);
      v50 = *((float32x4_t *)a2 + 26);
      v51 = vaddq_f32(v49, vmulq_f32(v50, v47));
      v52 = vaddq_f32(v49, vmulq_f32(v50, v48));
      v53 = *((float32x4_t *)a2 + 27);
      v54 = *((float32x4_t *)a2 + 28);
      v55 = vaddq_f32(vaddq_f32(v43, v45), vmulq_f32(v48, vaddq_f32(vaddq_f32(v53, vmulq_f32(v48, v54)), vmulq_f32(vmulq_f32(v48, v48), v52))));
      v56 = *((float32x4_t *)a2 + 86);
      v57 = vmulq_f32(v56, vaddq_f32(v46, vmulq_f32(v47, vaddq_f32(vaddq_f32(v53, vmulq_f32(v47, v54)), vmulq_f32(vmulq_f32(v47, v47), v51)))));
      v58 = vmulq_f32(v56, v55);
      v59 = *((float32x4_t *)a2 + 29);
      v60 = *((float32x4_t *)a2 + 30);
      v61 = vmaxq_f32(v57, v59);
      v62 = vmaxq_f32(v58, v59);
      v63 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v64 = vcvtq_f32_s32(vcvtq_s32_f32(v62));
      v65 = vsubq_f32(v63, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v63, v61)));
      v66 = vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v64, v62)));
      v67 = vsubq_f32(v61, v65);
      v68 = *((float32x4_t *)a2 + 31);
      v69 = *((float32x4_t *)a2 + 32);
      v70 = vsubq_f32(v62, v66);
      v71 = vmulq_f32(v70, vaddq_f32(v69, vmulq_f32(v70, vaddq_f32(v60, vmulq_f32(v68, v70)))));
      v72 = vaddq_f32(v27, vmulq_f32(v67, vaddq_f32(v69, vmulq_f32(v67, vaddq_f32(v60, vmulq_f32(v68, v67))))));
      v73 = vcvtq_s32_f32(v66);
      v74 = *((int32x4_t *)a2 + 33);
      v75 = vaddq_f32(v27, v71);
      v76 = vmulq_f32(v72, (float32x4_t)vshlq_n_s32(vaddq_s32(v74, vcvtq_s32_f32(v65)), 0x17uLL));
      v77 = vmulq_f32(v75, (float32x4_t)vshlq_n_s32(vaddq_s32(v74, v73), 0x17uLL));
      v78 = *((float32x4_t *)a2 + 87);
      v79 = *((float32x4_t *)a2 + 88);
      v80 = *((float32x4_t *)a2 + 89);
      v81 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v24, vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v28, v80)), (int8x16_t)vmulq_f32(v28, v79), (int8x16_t)vmulq_f32(v78, v76)));
      v82 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v25, vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v29, v80)), (int8x16_t)vmulq_f32(v29, v79), (int8x16_t)vmulq_f32(v78, v77)));
      v83 = (int8x16_t *)(v6 + v11);
      v83[-1] = vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      *v83 = vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v82, v82, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v84 = -v10;
    if (v84 >= v5)
      goto LABEL_3;
LABEL_10:
    v85 = 16 * v84;
    v86 = *(float32x4_t *)(v7 + v85);
    v87 = *((int8x16_t *)a2 + 15);
    v88 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v86, 3), *((float32x4_t *)a2 + 16));
    v89 = vmulq_f32(vrecpeq_f32(v88), *((float32x4_t *)a2 + 18));
    v90 = vmulq_f32(v86, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v89, vrecpsq_f32(v89, v88))), *((int8x16_t *)a2 + 3)));
    v91 = *((float32x4_t *)a2 + 75);
    v92 = *((float32x4_t *)a2 + 5);
    v93 = vminq_f32(vmaxq_f32(v90, v91), v92);
    v94 = vaddq_f32(v93, *((float32x4_t *)a2 + 85));
    v95 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v94), (int8x16_t)v92);
    v96 = (float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v95, *((float32x4_t *)a2 + 23)));
    v97 = vsubq_f32(vsubq_f32(v95, v92), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v96), v95));
    v98 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 86), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v94, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v94))), *((float32x4_t *)a2 + 22)), v96), vmulq_f32(v97, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v97, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v97, v97), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v97))))))),
            *((float32x4_t *)a2 + 29));
    v99 = vcvtq_f32_s32(vcvtq_s32_f32(v98));
    v100 = vsubq_f32(v99, (float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v99, v98)));
    v101 = vsubq_f32(v98, v100);
    v102 = (float32x4_t)vbslq_s8(v87, (int8x16_t)v90, vbslq_s8((int8x16_t)vcgtq_f32(v91, vsubq_f32(v93, *((float32x4_t *)a2 + 89))), (int8x16_t)vmulq_f32(v93, *((float32x4_t *)a2 + 88)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 87), vmulq_f32(vaddq_f32(v92, vmulq_f32(v101, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v101, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v101)))))),
                                           (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v100)), 0x17uLL)))));
    *(int8x16_t *)(v6 + v85) = vbslq_s8(v87, (int8x16_t)v90, (int8x16_t)vmulq_laneq_f32(v102, v102, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec709_halfTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  int32x4_t v82;
  int32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int8x16_t v87;
  float32x4_t v88;
  int8x16_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t *v95;
  int v96;
  uint64_t v97;
  float32x4_t v98;
  int8x16_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  int8x16_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v96 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23));
      v26 = *((float32x4_t *)a2 + 82);
      v27 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmaxq_f32(v24, v26));
      v28 = *((float32x4_t *)a2 + 75);
      v29 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmaxq_f32(v25, v26));
      v30 = (int8x16_t)vcgtq_f32(v28, v27);
      v31 = (int8x16_t)vcgtq_f32(v28, v29);
      v32 = *((int8x16_t *)a2 + 83);
      v33 = *((float32x4_t *)a2 + 5);
      v34 = (float32x4_t)vbslq_s8(v31, v32, (int8x16_t)v33);
      v35 = vmulq_f32(v27, (float32x4_t)vbslq_s8(v30, v32, (int8x16_t)v33));
      v36 = vmulq_f32(v29, v34);
      v37 = *((float32x4_t *)a2 + 90);
      v38 = *((float32x4_t *)a2 + 85);
      v39 = vaddq_f32(vminq_f32(v35, v37), v38);
      v40 = vaddq_f32(vminq_f32(v36, v37), v38);
      v41 = *((int8x16_t *)a2 + 19);
      v42 = *((float32x4_t *)a2 + 20);
      v43 = (float32x4_t)vorrq_s8(vandq_s8(v41, (int8x16_t)v39), (int8x16_t)v33);
      v44 = *((int8x16_t *)a2 + 21);
      v45 = *((float32x4_t *)a2 + 22);
      v46 = (float32x4_t)vorrq_s8(vandq_s8(v41, (int8x16_t)v40), (int8x16_t)v33);
      v47 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v40, 0x17uLL)), (float32x4_t)vandq_s8(v44, (int8x16_t)vcgtq_f32(v42, v40)));
      v48 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v39, 0x17uLL)), (float32x4_t)vandq_s8(v44, (int8x16_t)vcgtq_f32(v42, v39))), v45);
      v49 = *((float32x4_t *)a2 + 23);
      v50 = *((float32x4_t *)a2 + 24);
      v51 = vsubq_f32(v47, v45);
      v52 = (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v43, v49));
      v53 = (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v46, v49));
      v54 = vmulq_f32(v50, v52);
      v55 = vaddq_f32(v48, v52);
      v56 = vmulq_f32(vmulq_f32(v50, v53), v46);
      v57 = vaddq_f32(v51, v53);
      v58 = vsubq_f32(vsubq_f32(v43, v33), vmulq_f32(v54, v43));
      v59 = vsubq_f32(vsubq_f32(v46, v33), v56);
      v60 = *((float32x4_t *)a2 + 25);
      v61 = *((float32x4_t *)a2 + 26);
      v62 = *((float32x4_t *)a2 + 27);
      v63 = *((float32x4_t *)a2 + 28);
      v64 = vaddq_f32(v57, vmulq_f32(v59, vaddq_f32(vaddq_f32(v62, vmulq_f32(v59, v63)), vmulq_f32(vmulq_f32(v59, v59), vaddq_f32(v60, vmulq_f32(v61, v59))))));
      v65 = *((float32x4_t *)a2 + 86);
      v66 = vmulq_f32(v65, vaddq_f32(v55, vmulq_f32(v58, vaddq_f32(vaddq_f32(v62, vmulq_f32(v58, v63)), vmulq_f32(vmulq_f32(v58, v58), vaddq_f32(v60, vmulq_f32(v61, v58)))))));
      v67 = vmulq_f32(v65, v64);
      v68 = *((float32x4_t *)a2 + 29);
      v69 = *((float32x4_t *)a2 + 30);
      v70 = vmaxq_f32(v66, v68);
      v71 = vmaxq_f32(v67, v68);
      v72 = vcvtq_f32_s32(vcvtq_s32_f32(v70));
      v73 = vcvtq_f32_s32(vcvtq_s32_f32(v71));
      v74 = vsubq_f32(v72, (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v72, v70)));
      v75 = vsubq_f32(v73, (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v73, v71)));
      v76 = vsubq_f32(v70, v74);
      v77 = vsubq_f32(v71, v75);
      v78 = *((float32x4_t *)a2 + 31);
      v79 = *((float32x4_t *)a2 + 32);
      v80 = vmulq_f32(v77, vaddq_f32(v79, vmulq_f32(v77, vaddq_f32(v69, vmulq_f32(v78, v77)))));
      v81 = vaddq_f32(v33, vmulq_f32(v76, vaddq_f32(v79, vmulq_f32(v76, vaddq_f32(v69, vmulq_f32(v78, v76))))));
      v82 = vcvtq_s32_f32(v75);
      v83 = *((int32x4_t *)a2 + 33);
      v84 = vmulq_f32(v81, (float32x4_t)vshlq_n_s32(vaddq_s32(v83, vcvtq_s32_f32(v74)), 0x17uLL));
      v85 = vmulq_f32(vaddq_f32(v33, v80), (float32x4_t)vshlq_n_s32(vaddq_s32(v83, v82), 0x17uLL));
      v86 = *((float32x4_t *)a2 + 87);
      v87 = (int8x16_t)vmulq_f32(v86, v84);
      v88 = *((float32x4_t *)a2 + 88);
      v89 = (int8x16_t)vmulq_f32(v86, v85);
      v90 = *((float32x4_t *)a2 + 89);
      v91 = (float32x4_t)vbslq_s8(v30, (int8x16_t)v26, (int8x16_t)v33);
      v92 = (float32x4_t)vbslq_s8(v31, (int8x16_t)v26, (int8x16_t)v33);
      v93 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v28, vsubq_f32(v35, v90)), (int8x16_t)vmulq_f32(v35, v88), v87), v91));
      v94 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v28, vsubq_f32(v36, v90)), (int8x16_t)vmulq_f32(v36, v88), v89), v92));
      v95 = (int8x16_t *)(v6 + v11);
      v95[-1] = vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v93, v93, 3));
      *v95 = vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v94, v94, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v96 = -v10;
    if (v96 >= v5)
      goto LABEL_3;
LABEL_10:
    v97 = 16 * v96;
    v98 = *(float32x4_t *)(v7 + v97);
    v99 = *((int8x16_t *)a2 + 15);
    v100 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v98, 3), *((float32x4_t *)a2 + 16));
    v101 = vmulq_f32(vrecpeq_f32(v100), *((float32x4_t *)a2 + 18));
    v102 = vmulq_f32(v98, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v101, vrecpsq_f32(v101, v100))), *((int8x16_t *)a2 + 3)));
    v103 = *((float32x4_t *)a2 + 82);
    v104 = (float32x4_t)vbslq_s8(v99, (int8x16_t)v102, (int8x16_t)vmaxq_f32(v102, v103));
    v105 = *((float32x4_t *)a2 + 75);
    v106 = (int8x16_t)vcgtq_f32(v105, v104);
    v107 = *((float32x4_t *)a2 + 5);
    v108 = vmulq_f32(v104, (float32x4_t)vbslq_s8(v106, *((int8x16_t *)a2 + 83), (int8x16_t)v107));
    v109 = vaddq_f32(vminq_f32(v108, *((float32x4_t *)a2 + 90)), *((float32x4_t *)a2 + 85));
    v110 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v109), (int8x16_t)v107);
    v111 = (float32x4_t)vandq_s8((int8x16_t)v107, (int8x16_t)vcgtq_f32(v110, *((float32x4_t *)a2 + 23)));
    v112 = vsubq_f32(vsubq_f32(v110, v107), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v111), v110));
    v113 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 86), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v109, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v109))), *((float32x4_t *)a2 + 22)), v111), vmulq_f32(v112, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v112, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v112, v112), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v112))))))),
             *((float32x4_t *)a2 + 29));
    v114 = vcvtq_f32_s32(vcvtq_s32_f32(v113));
    v115 = vsubq_f32(v114, (float32x4_t)vandq_s8((int8x16_t)v107, (int8x16_t)vcgtq_f32(v114, v113)));
    v116 = vsubq_f32(v113, v115);
    v117 = (float32x4_t)vbslq_s8(v99, (int8x16_t)v102, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v105, vsubq_f32(v108, *((float32x4_t *)a2 + 89))), (int8x16_t)vmulq_f32(v108, *((float32x4_t *)a2 + 88)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 87), vmulq_f32(vaddq_f32(v107, vmulq_f32(v116, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v116,
                                                                             vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v116)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v115)), 0x17uLL)))), (float32x4_t)vbslq_s8(v106, (int8x16_t)v103, (int8x16_t)v107)));
    *(int8x16_t *)(v6 + v97) = vbslq_s8(v99, (int8x16_t)v102, (int8x16_t)vmulq_laneq_f32(v117, v117, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec709_niceTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  int8x16_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  int32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  int8x16_t v101;
  float32x4_t v102;
  int8x16_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  int8x16_t *v109;
  int v110;
  uint64_t v111;
  float32x4_t v112;
  int8x16_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  int8x16_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v110 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17));
      v24 = *((int8x16_t *)a2 + 17);
      v25 = *((int8x16_t *)a2 + 3);
      v26 = vmulq_f32(v12, (float32x4_t)vorrq_s8(vandq_s8(v24, v22), v25));
      v27 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v24, v23), v25));
      v28 = *((float32x4_t *)a2 + 82);
      v29 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v26, (int8x16_t)vmaxq_f32(v26, v28));
      v30 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmaxq_f32(v27, v28));
      v31 = *((float32x4_t *)a2 + 75);
      v32 = (int8x16_t)vcgtq_f32(v31, v29);
      v33 = (int8x16_t)vcgtq_f32(v31, v30);
      v34 = *((int8x16_t *)a2 + 83);
      v35 = *((float32x4_t *)a2 + 5);
      v36 = (float32x4_t)vbslq_s8(v33, v34, (int8x16_t)v35);
      v37 = vmulq_f32(v29, (float32x4_t)vbslq_s8(v32, v34, (int8x16_t)v35));
      v38 = vmulq_f32(v30, v36);
      v39 = *((float32x4_t *)a2 + 90);
      v40 = *((float32x4_t *)a2 + 85);
      v41 = (int8x16_t)vaddq_f32(vminq_f32(v37, v39), v40);
      v42 = (int8x16_t)vaddq_f32(vminq_f32(v38, v39), v40);
      v43 = *((float32x4_t *)a2 + 86);
      v44 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vceqq_f32(v43, v31)), v31);
      v45 = (float32x4_t)vbslq_s8(v44, (int8x16_t)v35, v41);
      v46 = (float32x4_t)vbslq_s8(v44, (int8x16_t)v35, v42);
      v47 = *((int8x16_t *)a2 + 19);
      v48 = *((float32x4_t *)a2 + 20);
      v49 = (float32x4_t)vorrq_s8(vandq_s8(v47, (int8x16_t)v45), (int8x16_t)v35);
      v50 = (float32x4_t)vorrq_s8(vandq_s8(v47, (int8x16_t)v46), (int8x16_t)v35);
      v51 = *((int8x16_t *)a2 + 21);
      v52 = *((float32x4_t *)a2 + 22);
      v53 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v46, 0x17uLL)), (float32x4_t)vandq_s8(v51, (int8x16_t)vcgtq_f32(v48, v46)));
      v54 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v45, 0x17uLL)), (float32x4_t)vandq_s8(v51, (int8x16_t)vcgtq_f32(v48, v45))), v52);
      v55 = *((float32x4_t *)a2 + 23);
      v56 = *((float32x4_t *)a2 + 24);
      v57 = vsubq_f32(v53, v52);
      v58 = (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v49, v55));
      v59 = (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v50, v55));
      v60 = vaddq_f32(v54, v58);
      v61 = vsubq_f32(vsubq_f32(v49, v35), vmulq_f32(vmulq_f32(v56, v58), v49));
      v62 = vsubq_f32(vsubq_f32(v50, v35), vmulq_f32(vmulq_f32(v56, v59), v50));
      v63 = vmulq_f32(v61, v61);
      v64 = *((float32x4_t *)a2 + 37);
      v65 = *((float32x4_t *)a2 + 38);
      v66 = *((float32x4_t *)a2 + 39);
      v67 = *((float32x4_t *)a2 + 40);
      v68 = vaddq_f32(v64, vmulq_f32(v65, v61));
      v69 = vaddq_f32(v66, vmulq_f32(v67, v61));
      v70 = vaddq_f32(v66, vmulq_f32(v67, v62));
      v71 = vaddq_f32(v64, vmulq_f32(v65, v62));
      v72 = *((float32x4_t *)a2 + 41);
      v73 = *((float32x4_t *)a2 + 42);
      v74 = vaddq_f32(v72, vmulq_f32(v73, v61));
      v75 = vaddq_f32(v72, vmulq_f32(v73, v62));
      v76 = vmulq_f32(v62, v62);
      v77 = vaddq_f32(v57, v59);
      v78 = vaddq_f32(v74, vmulq_f32(v63, vaddq_f32(v68, vmulq_f32(v63, v69))));
      v79 = vaddq_f32(v75, vmulq_f32(v76, vaddq_f32(v71, vmulq_f32(v76, v70))));
      v80 = *((float32x4_t *)a2 + 43);
      v81 = *((float32x4_t *)a2 + 44);
      v82 = vmulq_f32(v43, vaddq_f32(v60, vmulq_f32(v61, vaddq_f32(v80, vmulq_f32(v61, v78)))));
      v83 = vmulq_f32(v43, vaddq_f32(v77, vmulq_f32(v62, vaddq_f32(v80, vmulq_f32(v62, v79)))));
      v84 = *((float32x4_t *)a2 + 29);
      v85 = vmaxq_f32(v82, v84);
      v86 = vmaxq_f32(v83, v84);
      v87 = vcvtq_f32_s32(vcvtq_s32_f32(v85));
      v88 = vcvtq_f32_s32(vcvtq_s32_f32(v86));
      v89 = vsubq_f32(v87, (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v87, v85)));
      v90 = vsubq_f32(v88, (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v88, v86)));
      v91 = vsubq_f32(v85, v89);
      v92 = vsubq_f32(v86, v90);
      v93 = *((float32x4_t *)a2 + 45);
      v94 = *((float32x4_t *)a2 + 46);
      v95 = *((float32x4_t *)a2 + 47);
      v96 = *((float32x4_t *)a2 + 48);
      v97 = *((int32x4_t *)a2 + 33);
      v98 = vmulq_f32(vaddq_f32(v35, vmulq_f32(v91, vaddq_f32(v96, vmulq_f32(v91, vaddq_f32(vaddq_f32(v94, vmulq_f32(v91, v95)), vmulq_f32(vmulq_f32(v91, v91), vaddq_f32(v81, vmulq_f32(v93, v91)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v97, vcvtq_s32_f32(v89)), 0x17uLL));
      v99 = vmulq_f32(vaddq_f32(v35, vmulq_f32(v92, vaddq_f32(v96, vmulq_f32(v92, vaddq_f32(vaddq_f32(v94, vmulq_f32(v95, v92)), vmulq_f32(vmulq_f32(v92, v92), vaddq_f32(v81, vmulq_f32(v93, v92)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v97, vcvtq_s32_f32(v90)), 0x17uLL));
      v100 = *((float32x4_t *)a2 + 87);
      v101 = (int8x16_t)vmulq_f32(v100, v98);
      v102 = *((float32x4_t *)a2 + 88);
      v103 = (int8x16_t)vmulq_f32(v100, v99);
      v104 = *((float32x4_t *)a2 + 89);
      v105 = (float32x4_t)vbslq_s8(v32, (int8x16_t)v28, (int8x16_t)v35);
      v106 = (float32x4_t)vbslq_s8(v33, (int8x16_t)v28, (int8x16_t)v35);
      v107 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v26, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v31, vsubq_f32(v37, v104)), (int8x16_t)vmulq_f32(v37, v102), v101), v105));
      v108 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v31, vsubq_f32(v38, v104)), (int8x16_t)vmulq_f32(v38, v102), v103), v106));
      v109 = (int8x16_t *)(v6 + v11);
      v109[-1] = vbslq_s8(v14, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v107, v107, 3));
      *v109 = vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v108, v108, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v110 = -v10;
    if (v110 >= v5)
      goto LABEL_3;
LABEL_10:
    v111 = 16 * v110;
    v112 = *(float32x4_t *)(v7 + v111);
    v113 = *((int8x16_t *)a2 + 15);
    v114 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v112, 3), *((float32x4_t *)a2 + 16));
    v115 = vrecpeq_f32(v114);
    v116 = vmulq_f32(v115, vrecpsq_f32(v115, v114));
    v117 = vmulq_f32(v112, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v116, vrecpsq_f32(v116, v114))), *((int8x16_t *)a2 + 3)));
    v118 = *((float32x4_t *)a2 + 82);
    v119 = (float32x4_t)vbslq_s8(v113, (int8x16_t)v117, (int8x16_t)vmaxq_f32(v117, v118));
    v120 = *((float32x4_t *)a2 + 75);
    v121 = (int8x16_t)vcgtq_f32(v120, v119);
    v122 = *((float32x4_t *)a2 + 5);
    v123 = vmulq_f32(v119, (float32x4_t)vbslq_s8(v121, *((int8x16_t *)a2 + 83), (int8x16_t)v122));
    v124 = *((float32x4_t *)a2 + 86);
    v125 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v122, (int8x16_t)vceqq_f32(v124, v120)), v120), (int8x16_t)v122, (int8x16_t)vaddq_f32(vminq_f32(v123, *((float32x4_t *)a2 + 90)), *((float32x4_t *)a2 + 85)));
    v126 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v125), (int8x16_t)v122);
    v127 = (float32x4_t)vandq_s8((int8x16_t)v122, (int8x16_t)vcgtq_f32(v126, *((float32x4_t *)a2 + 23)));
    v128 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v125, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v125))), *((float32x4_t *)a2 + 22)), v127);
    v129 = vsubq_f32(vsubq_f32(v126, v122), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v127), v126));
    v130 = vmulq_f32(v129, v129);
    v131 = vmaxq_f32(vmulq_f32(v124, vaddq_f32(v128, vmulq_f32(v129, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v129, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v129)), vmulq_f32(v130, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v129)), vmulq_f32(v130, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v129))))))))))),
             *((float32x4_t *)a2 + 29));
    v132 = vcvtq_f32_s32(vcvtq_s32_f32(v131));
    v133 = vsubq_f32(v132, (float32x4_t)vandq_s8((int8x16_t)v122, (int8x16_t)vcgtq_f32(v132, v131)));
    v134 = vsubq_f32(v131, v133);
    v135 = (float32x4_t)vbslq_s8(v113, (int8x16_t)v117, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v120, vsubq_f32(v123, *((float32x4_t *)a2 + 89))), (int8x16_t)vmulq_f32(v123, *((float32x4_t *)a2 + 88)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 87), vmulq_f32(vaddq_f32(v122, vmulq_f32(v134, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v134,
                                                                             vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v134)), vmulq_f32(vmulq_f32(v134, v134), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v134)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v133)), 0x17uLL)))), (float32x4_t)vbslq_s8(v121, (int8x16_t)v118, (int8x16_t)v122)));
    *(int8x16_t *)(v6 + v111) = vbslq_s8(v113, (int8x16_t)v117, (int8x16_t)vmulq_laneq_f32(v135, v135, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec601_fast_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  float32x4_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t *v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  int8x16_t *v50;
  int8x16_t *v51;
  float32x4_t v52;
  int8x16_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  int8x16_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v57 = 0;
        v58 = 16 * v8;
        v59 = 16 * v7;
        v60 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v61 = 0;
          do
          {
            v62 = *((int8x16_t *)a2 + 15);
            v63 = vmulq_f32(v5[v61 / 0x10], (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5[v61 / 0x10], 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v64 = vminq_f32(vmaxq_f32(v63, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v65 = (float32x4_t)vbslq_s8(v62, (int8x16_t)v63, (int8x16_t)vmulq_f32(v64, vminq_f32(vrsqrteq_f32(v64), *((float32x4_t *)a2 + 73))));
            v6[v61 / 0x10] = vbslq_s8(v62, (int8x16_t)v63, (int8x16_t)vmulq_laneq_f32(v65, v65, 3));
            v61 += 16;
          }
          while (v60 != v61);
          ++v57;
          v5 = (float32x4_t *)((char *)v5 + v58);
          v6 = (int8x16_t *)((char *)v6 + v59);
        }
        while (v57 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v5[v17 - 2];
          v19 = v5[v17 - 1];
          v20 = v5[v17];
          v21 = v5[v17 + 1];
          v23 = *((int8x16_t *)a2 + 15);
          v22 = *((float32x4_t *)a2 + 16);
          v24 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 3), v22);
          v25 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 3), v22));
          v26 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3), v22));
          v27 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 3), v22));
          v28 = *((int8x16_t *)a2 + 17);
          v29 = vandq_s8(v28, v25);
          v30 = vandq_s8(v28, v26);
          v31 = vandq_s8(v28, v27);
          v32 = vandq_s8(v28, (int8x16_t)vrecpeq_f32(v24));
          v33 = *((int8x16_t *)a2 + 3);
          v34 = vmulq_f32(v18, (float32x4_t)vorrq_s8(v29, v33));
          v35 = vmulq_f32(v19, (float32x4_t)vorrq_s8(v30, v33));
          v36 = vmulq_f32(v20, (float32x4_t)vorrq_s8(v31, v33));
          v37 = vmulq_f32(v21, (float32x4_t)vorrq_s8(v32, v33));
          v38 = *((float32x4_t *)a2 + 75);
          v39 = *((float32x4_t *)a2 + 5);
          v40 = vminq_f32(vmaxq_f32(v34, v38), v39);
          v41 = vminq_f32(vmaxq_f32(v35, v38), v39);
          v42 = vminq_f32(vmaxq_f32(v36, v38), v39);
          v43 = vminq_f32(vmaxq_f32(v37, v38), v39);
          v44 = *((float32x4_t *)a2 + 73);
          v45 = v16;
          v46 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v34, (int8x16_t)vmulq_f32(v40, vminq_f32(vrsqrteq_f32(v40), v44)));
          v47 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v35, (int8x16_t)vmulq_f32(v41, vminq_f32(vrsqrteq_f32(v41), v44)));
          v48 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v36, (int8x16_t)vmulq_f32(v42, vminq_f32(vrsqrteq_f32(v42), v44)));
          v49 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v37, (int8x16_t)vmulq_f32(v43, vminq_f32(vrsqrteq_f32(v43), v44)));
          v50 = v15;
          v51 = &v6[v17];
          v14 += 4;
          v51[-2] = vbslq_s8(v23, (int8x16_t)v34, (int8x16_t)vmulq_laneq_f32(v46, v46, 3));
          v51[-1] = vbslq_s8(v23, (int8x16_t)v35, (int8x16_t)vmulq_laneq_f32(v47, v47, 3));
          *v51 = vbslq_s8(v23, (int8x16_t)v36, (int8x16_t)vmulq_laneq_f32(v48, v48, 3));
          v51[1] = vbslq_s8(v23, (int8x16_t)v37, (int8x16_t)vmulq_laneq_f32(v49, v49, 3));
          v17 += 4;
          v16 += 4;
          v15 = v50 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v52 = *v45++;
            v53 = *((int8x16_t *)a2 + 15);
            v54 = vmulq_f32(v52, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v55 = vminq_f32(vmaxq_f32(v54, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v56 = (float32x4_t)vbslq_s8(v53, (int8x16_t)v54, (int8x16_t)vmulq_f32(v55, vminq_f32(vrsqrteq_f32(v55), *((float32x4_t *)a2 + 73))));
            *v50++ = vbslq_s8(v53, (int8x16_t)v54, (int8x16_t)vmulq_laneq_f32(v56, v56, 3));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getrec601_fixed_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int8x16_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  int8x16_t *v85;
  uint64_t v86;
  int8x16_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v86) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v17 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15));
      v18 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15));
      v19 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v15));
      v21 = *((int8x16_t *)a2 + 17);
      v20 = *((float32x4_t *)a2 + 18);
      v22 = (int8x16_t)vmulq_f32(v19, v20);
      v23 = vandq_s8(v21, (int8x16_t)vmulq_f32(v17, v20));
      v24 = vandq_s8(v21, (int8x16_t)vmulq_f32(v18, v20));
      v25 = *((int8x16_t *)a2 + 3);
      v26 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v23, v25));
      v27 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v24, v25));
      v28 = vmulq_f32(v14, (float32x4_t)vorrq_s8(vandq_s8(v21, v22), v25));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = *((float32x4_t *)a2 + 6);
      v32 = vminq_f32(vmaxq_f32(v26, v29), v30);
      v33 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v34 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v35 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)v32));
      v36 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)v33));
      v37 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)v34));
      v38 = vcvtq_f32_s32(vcvtq_s32_f32(v35));
      v39 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
      v40 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
      v41 = *((float32x4_t *)a2 + 7);
      v42 = *((float32x4_t *)a2 + 8);
      v43 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v35, v38), v41));
      v44 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v36, v39), v41));
      v45 = vrsqrteq_f32(vaddq_f32(v41, vsubq_f32(v37, v40)));
      v46 = vaddq_f32(v42, v38);
      v47 = vaddq_f32(v42, v39);
      v48 = vaddq_f32(v42, v40);
      v49 = *((float32x4_t *)a2 + 9);
      v50 = *((float32x4_t *)a2 + 10);
      v51 = vsubq_f32(v46, vmulq_f32(v43, v49));
      v52 = *((float32x4_t *)a2 + 77);
      v53 = vmulq_f32(v52, v51);
      v54 = vmulq_f32(v52, vsubq_f32(v47, vmulq_f32(v44, v49)));
      v55 = vmulq_f32(v52, vsubq_f32(v48, vmulq_f32(v45, v49)));
      v56 = vcvtq_f32_s32(vcvtq_s32_f32(v53));
      v57 = vcvtq_f32_s32(vcvtq_s32_f32(v54));
      v58 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      v59 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v56, v53)));
      v60 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v57, v54)));
      v61 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v58, v55)));
      v62 = *((float32x4_t *)a2 + 11);
      v63 = *((float32x4_t *)a2 + 12);
      v64 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v53, v59))), v63);
      v65 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v54, v60))), v63);
      v66 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v55, v61))), v63);
      v67 = vaddq_f32(vaddq_f32(v50, v61), vmulq_f32(v66, v66));
      v68 = vmaxq_f32(vaddq_f32(vaddq_f32(v50, v59), vmulq_f32(v64, v64)), v29);
      v69 = vmaxq_f32(vaddq_f32(vaddq_f32(v50, v60), vmulq_f32(v65, v65)), v29);
      v70 = *((float32x4_t *)a2 + 13);
      v71 = *((float32x4_t *)a2 + 14);
      v72 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v68, v70), v71));
      v73 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v69, v70), v71));
      v74 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v67, v29), v70), v71));
      v75 = *((float32x4_t *)a2 + 91);
      v76 = *((float32x4_t *)a2 + 92);
      v77 = (int8x16_t)vaddq_f32(v75, vmulq_f32(v76, v72));
      v78 = vmulq_f32(v76, v73);
      v79 = vmulq_f32(v76, v74);
      v80 = *((float32x4_t *)a2 + 93);
      v81 = *((float32x4_t *)a2 + 94);
      v82 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v26, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v81)), (int8x16_t)vmulq_f32(v32, v80), v77));
      v83 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v27, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v33, v81)), (int8x16_t)vmulq_f32(v33, v80), (int8x16_t)vaddq_f32(v75, v78)));
      v84 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v28, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v34, v81)), (int8x16_t)vmulq_f32(v34, v80), (int8x16_t)vaddq_f32(v75, v79)));
      v85 = (int8x16_t *)(v6 + v10);
      *v85 = vbslq_s8(v16, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v82, v82, 3));
      v85[1] = vbslq_s8(v16, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v83, v83, 3));
      v85[2] = vbslq_s8(v16, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v84, v84, 3));
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v86) = -v11;
    if ((int)v86 >= v5)
      goto LABEL_3;
LABEL_10:
    v86 = v86;
    do
    {
      v87 = *((int8x16_t *)a2 + 15);
      v88 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v86), (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v7 + 16 * v86), 3), *((float32x4_t *)a2 + 16))), *((float32x4_t *)a2 + 18))), *((int8x16_t *)a2 + 3)));
      v89 = *((float32x4_t *)a2 + 75);
      v90 = *((float32x4_t *)a2 + 5);
      v91 = vminq_f32(vmaxq_f32(v88, v89), v90);
      v92 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)v91));
      v93 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
      v94 = vmulq_f32(*((float32x4_t *)a2 + 77), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v93), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v92, v93))), *((float32x4_t *)a2 + 9))));
      v95 = vcvtq_f32_s32(vcvtq_s32_f32(v94));
      v96 = vsubq_f32(v95, (float32x4_t)vandq_s8((int8x16_t)v90, (int8x16_t)vcgtq_f32(v95, v94)));
      v97 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v94, v96))), *((float32x4_t *)a2 + 12));
      v98 = (float32x4_t)vbslq_s8(v87, (int8x16_t)v88, vbslq_s8((int8x16_t)vcgtq_f32(v89, vsubq_f32(v91, *((float32x4_t *)a2 + 94))), (int8x16_t)vmulq_f32(v91, *((float32x4_t *)a2 + 93)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 91), vmulq_f32(*((float32x4_t *)a2 + 92), (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v96), vmulq_f32(v97, v97)), v89), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14)))))));
      *(int8x16_t *)(v6 + 16 * v86++) = vbslq_s8(v87, (int8x16_t)v88, (int8x16_t)vmulq_laneq_f32(v98, v98, 3));
    }
    while (v86 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec601_nice_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t v95;
  float32x4_t v96;
  int8x16_t v97;
  int8x16_t v98;
  float32x4_t v99;
  int8x16_t v100;
  int8x16_t v101;
  float32x4_t v102;
  float32x4_t v103;
  int8x16_t *v104;
  int v105;
  uint64_t v106;
  float32x4_t v107;
  int8x16_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v105 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = *((int8x16_t *)a2 + 17);
      v24 = vandq_s8(v23, v22);
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v32 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v33 = *((float32x4_t *)a2 + 77);
      v34 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vceqq_f32(v33, v29)), v29);
      v35 = (float32x4_t)vbslq_s8(v34, (int8x16_t)v30, (int8x16_t)v31);
      v36 = (float32x4_t)vbslq_s8(v34, (int8x16_t)v30, (int8x16_t)v32);
      v37 = *((int8x16_t *)a2 + 19);
      v38 = *((float32x4_t *)a2 + 20);
      v39 = (float32x4_t)vorrq_s8(vandq_s8(v37, (int8x16_t)v35), (int8x16_t)v30);
      v40 = (float32x4_t)vorrq_s8(vandq_s8(v37, (int8x16_t)v36), (int8x16_t)v30);
      v41 = *((int8x16_t *)a2 + 21);
      v42 = *((float32x4_t *)a2 + 22);
      v43 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v36, 0x17uLL)), (float32x4_t)vandq_s8(v41, (int8x16_t)vcgtq_f32(v38, v36)));
      v44 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v35, 0x17uLL)), (float32x4_t)vandq_s8(v41, (int8x16_t)vcgtq_f32(v38, v35))), v42);
      v45 = *((float32x4_t *)a2 + 23);
      v46 = *((float32x4_t *)a2 + 24);
      v47 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v39, v45));
      v48 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v40, v45));
      v49 = vaddq_f32(v44, v47);
      v50 = vaddq_f32(vsubq_f32(v43, v42), v48);
      v51 = vsubq_f32(vsubq_f32(v39, v30), vmulq_f32(vmulq_f32(v46, v47), v39));
      v52 = vsubq_f32(vsubq_f32(v40, v30), vmulq_f32(vmulq_f32(v46, v48), v40));
      v53 = vmulq_f32(v51, v51);
      v54 = *((float32x4_t *)a2 + 37);
      v55 = *((float32x4_t *)a2 + 38);
      v56 = vaddq_f32(v54, vmulq_f32(v55, v51));
      v57 = vaddq_f32(v54, vmulq_f32(v55, v52));
      v58 = *((float32x4_t *)a2 + 39);
      v59 = *((float32x4_t *)a2 + 40);
      v60 = vaddq_f32(v58, vmulq_f32(v59, v51));
      v61 = vaddq_f32(v58, vmulq_f32(v59, v52));
      v62 = *((float32x4_t *)a2 + 41);
      v63 = *((float32x4_t *)a2 + 42);
      v64 = vaddq_f32(v62, vmulq_f32(v63, v51));
      v65 = vaddq_f32(v62, vmulq_f32(v63, v52));
      v66 = vmulq_f32(v52, v52);
      v67 = vaddq_f32(v65, vmulq_f32(v66, vaddq_f32(v57, vmulq_f32(v66, v61))));
      v68 = vmulq_f32(v51, vaddq_f32(v64, vmulq_f32(v53, vaddq_f32(v56, vmulq_f32(v53, v60)))));
      v69 = *((float32x4_t *)a2 + 43);
      v70 = *((float32x4_t *)a2 + 44);
      v71 = vaddq_f32(v50, vmulq_f32(v52, vaddq_f32(v69, vmulq_f32(v52, v67))));
      v72 = vmulq_f32(v33, vaddq_f32(v49, vmulq_f32(v51, vaddq_f32(v69, v68))));
      v73 = *((float32x4_t *)a2 + 29);
      v74 = vmulq_f32(v33, v71);
      v75 = vmaxq_f32(v72, v73);
      v76 = vmaxq_f32(v74, v73);
      v77 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v76));
      v79 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v77, v75)));
      v80 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v78, v76)));
      v81 = vsubq_f32(v75, v79);
      v82 = vsubq_f32(v76, v80);
      v83 = *((float32x4_t *)a2 + 45);
      v84 = *((float32x4_t *)a2 + 46);
      v85 = *((float32x4_t *)a2 + 47);
      v86 = *((float32x4_t *)a2 + 48);
      v87 = vaddq_f32(v30, vmulq_f32(v81, vaddq_f32(v86, vmulq_f32(v81, vaddq_f32(vaddq_f32(v84, vmulq_f32(v81, v85)), vmulq_f32(vmulq_f32(v81, v81), vaddq_f32(v70, vmulq_f32(v83, v81))))))));
      v88 = vaddq_f32(v30, vmulq_f32(v82, vaddq_f32(v86, vmulq_f32(v82, vaddq_f32(vaddq_f32(v84, vmulq_f32(v85, v82)), vmulq_f32(vmulq_f32(v82, v82), vaddq_f32(v70, vmulq_f32(v83, v82))))))));
      v89 = *((int32x4_t *)a2 + 33);
      v90 = vmulq_f32(v87, (float32x4_t)vshlq_n_s32(vaddq_s32(v89, vcvtq_s32_f32(v79)), 0x17uLL));
      v91 = vmulq_f32(v88, (float32x4_t)vshlq_n_s32(vaddq_s32(v89, vcvtq_s32_f32(v80)), 0x17uLL));
      v92 = *((float32x4_t *)a2 + 91);
      v93 = *((float32x4_t *)a2 + 92);
      v94 = vmulq_f32(v93, v91);
      v95 = (int8x16_t)vaddq_f32(v92, vmulq_f32(v93, v90));
      v96 = *((float32x4_t *)a2 + 93);
      v97 = (int8x16_t)vmulq_f32(v31, v96);
      v98 = (int8x16_t)vmulq_f32(v32, v96);
      v99 = *((float32x4_t *)a2 + 94);
      v100 = (int8x16_t)vcgtq_f32(v29, vsubq_f32(v31, v99));
      v101 = (int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v99));
      v102 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, vbslq_s8(v100, v97, v95));
      v103 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, vbslq_s8(v101, v98, (int8x16_t)vaddq_f32(v92, v94)));
      v104 = (int8x16_t *)(v6 + v11);
      v104[-1] = vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v102, v102, 3));
      *v104 = vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v103, v103, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v105 = -v10;
    if (v105 >= v5)
      goto LABEL_3;
LABEL_10:
    v106 = 16 * v105;
    v107 = *(float32x4_t *)(v7 + v106);
    v108 = *((int8x16_t *)a2 + 15);
    v109 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3), *((float32x4_t *)a2 + 16));
    v110 = vrecpeq_f32(v109);
    v111 = vmulq_f32(v110, vrecpsq_f32(v110, v109));
    v112 = vmulq_f32(v107, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v111, vrecpsq_f32(v111, v109))), *((int8x16_t *)a2 + 3)));
    v113 = *((float32x4_t *)a2 + 75);
    v114 = *((float32x4_t *)a2 + 5);
    v115 = vminq_f32(vmaxq_f32(v112, v113), v114);
    v116 = *((float32x4_t *)a2 + 77);
    v117 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v114, (int8x16_t)vceqq_f32(v116, v113)), v113), (int8x16_t)v114, (int8x16_t)v115);
    v118 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v117), (int8x16_t)v114);
    v119 = (float32x4_t)vandq_s8((int8x16_t)v114, (int8x16_t)vcgtq_f32(v118, *((float32x4_t *)a2 + 23)));
    v120 = vsubq_f32(vsubq_f32(v118, v114), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v119), v118));
    v121 = vmulq_f32(v120, v120);
    v122 = vmaxq_f32(vmulq_f32(v116, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v117, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v117))), *((float32x4_t *)a2 + 22)), v119), vmulq_f32(v120, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v120, vaddq_f32(
                         vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v120)),
                         vmulq_f32(v121, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v120)), vmulq_f32(v121, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v120))))))))))), *((float32x4_t *)a2 + 29));
    v123 = vcvtq_f32_s32(vcvtq_s32_f32(v122));
    v124 = vsubq_f32(v123, (float32x4_t)vandq_s8((int8x16_t)v114, (int8x16_t)vcgtq_f32(v123, v122)));
    v125 = vsubq_f32(v122, v124);
    v126 = (float32x4_t)vbslq_s8(v108, (int8x16_t)v112, vbslq_s8((int8x16_t)vcgtq_f32(v113, vsubq_f32(v115, *((float32x4_t *)a2 + 94))), (int8x16_t)vmulq_f32(v115, *((float32x4_t *)a2 + 93)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 91), vmulq_f32(*((float32x4_t *)a2 + 92), vmulq_f32(vaddq_f32(v114, vmulq_f32(v125, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v125, vaddq_f32(
                                                       vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v125)), vmulq_f32(vmulq_f32(v125, v125), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v125)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v124)), 0x17uLL))))));
    *(int8x16_t *)(v6 + v106) = vbslq_s8(v108, (int8x16_t)v112, (int8x16_t)vmulq_laneq_f32(v126, v126, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec601_half_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int8x16_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int8x16_t *v78;
  int v79;
  uint64_t v80;
  float32x4_t v81;
  int8x16_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v79 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23));
      v26 = *((float32x4_t *)a2 + 75);
      v27 = *((float32x4_t *)a2 + 5);
      v28 = vminq_f32(vmaxq_f32(v24, v26), v27);
      v29 = vminq_f32(vmaxq_f32(v25, v26), v27);
      v30 = *((int8x16_t *)a2 + 19);
      v31 = *((float32x4_t *)a2 + 20);
      v32 = (float32x4_t)vorrq_s8(vandq_s8(v30, (int8x16_t)v28), (int8x16_t)v27);
      v33 = *((int8x16_t *)a2 + 21);
      v34 = *((float32x4_t *)a2 + 22);
      v35 = (float32x4_t)vorrq_s8(vandq_s8(v30, (int8x16_t)v29), (int8x16_t)v27);
      v36 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x17uLL)), (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v31, v28))), v34);
      v37 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x17uLL)), (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v31, v29))), v34);
      v38 = *((float32x4_t *)a2 + 23);
      v39 = *((float32x4_t *)a2 + 24);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v32, v38));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v35, v38));
      v42 = vaddq_f32(v37, v41);
      v43 = vsubq_f32(vsubq_f32(v32, v27), vmulq_f32(vmulq_f32(v39, v40), v32));
      v44 = vsubq_f32(vsubq_f32(v35, v27), vmulq_f32(vmulq_f32(v39, v41), v35));
      v45 = *((float32x4_t *)a2 + 25);
      v46 = *((float32x4_t *)a2 + 26);
      v47 = *((float32x4_t *)a2 + 27);
      v48 = *((float32x4_t *)a2 + 28);
      v49 = vaddq_f32(v42, vmulq_f32(v44, vaddq_f32(vaddq_f32(v47, vmulq_f32(v44, v48)), vmulq_f32(vmulq_f32(v44, v44), vaddq_f32(v45, vmulq_f32(v46, v44))))));
      v50 = *((float32x4_t *)a2 + 77);
      v51 = vmulq_f32(v50, vaddq_f32(vaddq_f32(v36, v40), vmulq_f32(v43, vaddq_f32(vaddq_f32(v47, vmulq_f32(v43, v48)), vmulq_f32(vmulq_f32(v43, v43), vaddq_f32(v45, vmulq_f32(v46, v43)))))));
      v52 = vmulq_f32(v50, v49);
      v53 = *((float32x4_t *)a2 + 29);
      v54 = *((float32x4_t *)a2 + 30);
      v55 = vmaxq_f32(v51, v53);
      v56 = vmaxq_f32(v52, v53);
      v57 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      v58 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
      v59 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v57, v55)));
      v60 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v58, v56)));
      v61 = vsubq_f32(v55, v59);
      v62 = vsubq_f32(v56, v60);
      v63 = *((float32x4_t *)a2 + 31);
      v64 = *((float32x4_t *)a2 + 32);
      v65 = vaddq_f32(v27, vmulq_f32(v61, vaddq_f32(v64, vmulq_f32(v61, vaddq_f32(v54, vmulq_f32(v63, v61))))));
      v66 = vaddq_f32(v27, vmulq_f32(v62, vaddq_f32(v64, vmulq_f32(v62, vaddq_f32(v54, vmulq_f32(v63, v62))))));
      v67 = *((int32x4_t *)a2 + 33);
      v68 = vmulq_f32(v65, (float32x4_t)vshlq_n_s32(vaddq_s32(v67, vcvtq_s32_f32(v59)), 0x17uLL));
      v69 = vmulq_f32(v66, (float32x4_t)vshlq_n_s32(vaddq_s32(v67, vcvtq_s32_f32(v60)), 0x17uLL));
      v70 = *((float32x4_t *)a2 + 91);
      v71 = *((float32x4_t *)a2 + 92);
      v72 = vmulq_f32(v71, v69);
      v73 = (int8x16_t)vaddq_f32(v70, vmulq_f32(v71, v68));
      v74 = *((float32x4_t *)a2 + 93);
      v75 = *((float32x4_t *)a2 + 94);
      v76 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v24, vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v28, v75)), (int8x16_t)vmulq_f32(v28, v74), v73));
      v77 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v25, vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v29, v75)), (int8x16_t)vmulq_f32(v29, v74), (int8x16_t)vaddq_f32(v70, v72)));
      v78 = (int8x16_t *)(v6 + v11);
      v78[-1] = vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v76, v76, 3));
      *v78 = vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v77, v77, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v79 = -v10;
    if (v79 >= v5)
      goto LABEL_3;
LABEL_10:
    v80 = 16 * v79;
    v81 = *(float32x4_t *)(v7 + v80);
    v82 = *((int8x16_t *)a2 + 15);
    v83 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v81, 3), *((float32x4_t *)a2 + 16));
    v84 = vmulq_f32(vrecpeq_f32(v83), *((float32x4_t *)a2 + 18));
    v85 = vmulq_f32(v81, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v84, vrecpsq_f32(v84, v83))), *((int8x16_t *)a2 + 3)));
    v86 = *((float32x4_t *)a2 + 75);
    v87 = *((float32x4_t *)a2 + 5);
    v88 = vminq_f32(vmaxq_f32(v85, v86), v87);
    v89 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v88), (int8x16_t)v87);
    v90 = (float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vcgtq_f32(v89, *((float32x4_t *)a2 + 23)));
    v91 = vsubq_f32(vsubq_f32(v89, v87), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v90), v89));
    v92 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 77), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v88, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v88))), *((float32x4_t *)a2 + 22)), v90), vmulq_f32(v91, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v91, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v91, v91), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v91))))))),
            *((float32x4_t *)a2 + 29));
    v93 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
    v94 = vsubq_f32(v93, (float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vcgtq_f32(v93, v92)));
    v95 = vsubq_f32(v92, v94);
    v96 = (float32x4_t)vbslq_s8(v82, (int8x16_t)v85, vbslq_s8((int8x16_t)vcgtq_f32(v86, vsubq_f32(v88, *((float32x4_t *)a2 + 94))), (int8x16_t)vmulq_f32(v88, *((float32x4_t *)a2 + 93)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 91), vmulq_f32(*((float32x4_t *)a2 + 92), vmulq_f32(vaddq_f32(v87, vmulq_f32(v95, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v95, vaddq_f32(
                                                      *((float32x4_t *)a2 + 30),
                                                      vmulq_f32(*((float32x4_t *)a2 + 31), v95)))))),
                                            (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v94)), 0x17uLL))))));
    *(int8x16_t *)(v6 + v80) = vbslq_s8(v82, (int8x16_t)v85, (int8x16_t)vmulq_laneq_f32(v96, v96, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec601_halfTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  int32x4_t v80;
  int32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int8x16_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t *v95;
  int v96;
  uint64_t v97;
  float32x4_t v98;
  int8x16_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  int8x16_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v96 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23));
      v26 = *((float32x4_t *)a2 + 82);
      v27 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmaxq_f32(v24, v26));
      v28 = *((float32x4_t *)a2 + 75);
      v29 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmaxq_f32(v25, v26));
      v30 = (int8x16_t)vcgtq_f32(v28, v27);
      v31 = (int8x16_t)vcgtq_f32(v28, v29);
      v32 = *((int8x16_t *)a2 + 83);
      v33 = *((float32x4_t *)a2 + 5);
      v34 = (float32x4_t)vbslq_s8(v31, v32, (int8x16_t)v33);
      v35 = vmulq_f32(v27, (float32x4_t)vbslq_s8(v30, v32, (int8x16_t)v33));
      v36 = vmulq_f32(v29, v34);
      v37 = *((float32x4_t *)a2 + 84);
      v38 = vminq_f32(v35, v37);
      v39 = *((int8x16_t *)a2 + 19);
      v40 = *((float32x4_t *)a2 + 20);
      v41 = vminq_f32(v36, v37);
      v42 = (float32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)v38), (int8x16_t)v33);
      v43 = (float32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)v41), (int8x16_t)v33);
      v44 = *((int8x16_t *)a2 + 21);
      v45 = *((float32x4_t *)a2 + 22);
      v46 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v41, 0x17uLL)), (float32x4_t)vandq_s8(v44, (int8x16_t)vcgtq_f32(v40, v41)));
      v47 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v38, 0x17uLL)), (float32x4_t)vandq_s8(v44, (int8x16_t)vcgtq_f32(v40, v38))), v45);
      v48 = *((float32x4_t *)a2 + 23);
      v49 = *((float32x4_t *)a2 + 24);
      v50 = (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v42, v48));
      v51 = (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v43, v48));
      v52 = vaddq_f32(v47, v50);
      v53 = vaddq_f32(vsubq_f32(v46, v45), v51);
      v54 = vsubq_f32(vsubq_f32(v42, v33), vmulq_f32(vmulq_f32(v49, v50), v42));
      v55 = vsubq_f32(vsubq_f32(v43, v33), vmulq_f32(vmulq_f32(v49, v51), v43));
      v56 = *((float32x4_t *)a2 + 25);
      v57 = *((float32x4_t *)a2 + 26);
      v58 = vaddq_f32(v56, vmulq_f32(v57, v54));
      v59 = vaddq_f32(v56, vmulq_f32(v57, v55));
      v60 = *((float32x4_t *)a2 + 27);
      v61 = *((float32x4_t *)a2 + 28);
      v62 = vaddq_f32(v53, vmulq_f32(v55, vaddq_f32(vaddq_f32(v60, vmulq_f32(v55, v61)), vmulq_f32(vmulq_f32(v55, v55), v59))));
      v63 = *((float32x4_t *)a2 + 77);
      v64 = vmulq_f32(v63, vaddq_f32(v52, vmulq_f32(v54, vaddq_f32(vaddq_f32(v60, vmulq_f32(v54, v61)), vmulq_f32(vmulq_f32(v54, v54), v58)))));
      v65 = vmulq_f32(v63, v62);
      v66 = *((float32x4_t *)a2 + 29);
      v67 = *((float32x4_t *)a2 + 30);
      v68 = vmaxq_f32(v64, v66);
      v69 = vmaxq_f32(v65, v66);
      v70 = vcvtq_f32_s32(vcvtq_s32_f32(v68));
      v71 = vcvtq_f32_s32(vcvtq_s32_f32(v69));
      v72 = vsubq_f32(v70, (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v70, v68)));
      v73 = vsubq_f32(v71, (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v71, v69)));
      v74 = vsubq_f32(v68, v72);
      v75 = vsubq_f32(v69, v73);
      v76 = *((float32x4_t *)a2 + 31);
      v77 = *((float32x4_t *)a2 + 32);
      v78 = vaddq_f32(v33, vmulq_f32(v74, vaddq_f32(v77, vmulq_f32(v74, vaddq_f32(v67, vmulq_f32(v76, v74))))));
      v79 = vaddq_f32(v33, vmulq_f32(v75, vaddq_f32(v77, vmulq_f32(v75, vaddq_f32(v67, vmulq_f32(v76, v75))))));
      v80 = vcvtq_s32_f32(v73);
      v81 = *((int32x4_t *)a2 + 33);
      v82 = vmulq_f32(v78, (float32x4_t)vshlq_n_s32(vaddq_s32(v81, vcvtq_s32_f32(v72)), 0x17uLL));
      v83 = vmulq_f32(v79, (float32x4_t)vshlq_n_s32(vaddq_s32(v81, v80), 0x17uLL));
      v84 = *((float32x4_t *)a2 + 91);
      v85 = *((float32x4_t *)a2 + 92);
      v86 = (int8x16_t)vaddq_f32(v84, vmulq_f32(v85, v82));
      v87 = vmulq_f32(v85, v83);
      v88 = *((float32x4_t *)a2 + 93);
      v89 = (int8x16_t)vaddq_f32(v84, v87);
      v90 = *((float32x4_t *)a2 + 94);
      v91 = (float32x4_t)vbslq_s8(v30, (int8x16_t)v26, (int8x16_t)v33);
      v92 = (float32x4_t)vbslq_s8(v31, (int8x16_t)v26, (int8x16_t)v33);
      v93 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v28, vsubq_f32(v35, v90)), (int8x16_t)vmulq_f32(v35, v88), v86), v91));
      v94 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v28, vsubq_f32(v36, v90)), (int8x16_t)vmulq_f32(v36, v88), v89), v92));
      v95 = (int8x16_t *)(v6 + v11);
      v95[-1] = vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v93, v93, 3));
      *v95 = vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v94, v94, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v96 = -v10;
    if (v96 >= v5)
      goto LABEL_3;
LABEL_10:
    v97 = 16 * v96;
    v98 = *(float32x4_t *)(v7 + v97);
    v99 = *((int8x16_t *)a2 + 15);
    v100 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v98, 3), *((float32x4_t *)a2 + 16));
    v101 = vmulq_f32(vrecpeq_f32(v100), *((float32x4_t *)a2 + 18));
    v102 = vmulq_f32(v98, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v101, vrecpsq_f32(v101, v100))), *((int8x16_t *)a2 + 3)));
    v103 = *((float32x4_t *)a2 + 82);
    v104 = (float32x4_t)vbslq_s8(v99, (int8x16_t)v102, (int8x16_t)vmaxq_f32(v102, v103));
    v105 = *((float32x4_t *)a2 + 75);
    v106 = (int8x16_t)vcgtq_f32(v105, v104);
    v107 = *((float32x4_t *)a2 + 5);
    v108 = vmulq_f32(v104, (float32x4_t)vbslq_s8(v106, *((int8x16_t *)a2 + 83), (int8x16_t)v107));
    v109 = vminq_f32(v108, *((float32x4_t *)a2 + 84));
    v110 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v109), (int8x16_t)v107);
    v111 = (float32x4_t)vandq_s8((int8x16_t)v107, (int8x16_t)vcgtq_f32(v110, *((float32x4_t *)a2 + 23)));
    v112 = vsubq_f32(vsubq_f32(v110, v107), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v111), v110));
    v113 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 77), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v109, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v109))), *((float32x4_t *)a2 + 22)), v111), vmulq_f32(v112, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v112, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v112, v112), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v112))))))),
             *((float32x4_t *)a2 + 29));
    v114 = vcvtq_f32_s32(vcvtq_s32_f32(v113));
    v115 = vsubq_f32(v114, (float32x4_t)vandq_s8((int8x16_t)v107, (int8x16_t)vcgtq_f32(v114, v113)));
    v116 = vsubq_f32(v113, v115);
    v117 = (float32x4_t)vbslq_s8(v99, (int8x16_t)v102, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v105, vsubq_f32(v108, *((float32x4_t *)a2 + 94))), (int8x16_t)vmulq_f32(v108, *((float32x4_t *)a2 + 93)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 91), vmulq_f32(*((float32x4_t *)a2 + 92), vmulq_f32(vaddq_f32(v107, vmulq_f32(v116, vaddq_f32(*((float32x4_t *)a2 + 32),
                                                                             vmulq_f32(v116, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v116)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v115)), 0x17uLL))))), (float32x4_t)vbslq_s8(v106, (int8x16_t)v103, (int8x16_t)v107)));
    *(int8x16_t *)(v6 + v97) = vbslq_s8(v99, (int8x16_t)v102, (int8x16_t)vmulq_laneq_f32(v117, v117, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec601_niceTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  int8x16_t v100;
  float32x4_t v101;
  float32x4_t v102;
  int8x16_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  int8x16_t *v109;
  int v110;
  uint64_t v111;
  float32x4_t v112;
  int8x16_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  int8x16_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v110 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17));
      v24 = *((int8x16_t *)a2 + 17);
      v25 = *((int8x16_t *)a2 + 3);
      v26 = vmulq_f32(v12, (float32x4_t)vorrq_s8(vandq_s8(v24, v22), v25));
      v27 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v24, v23), v25));
      v28 = *((float32x4_t *)a2 + 82);
      v29 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v26, (int8x16_t)vmaxq_f32(v26, v28));
      v30 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmaxq_f32(v27, v28));
      v31 = *((float32x4_t *)a2 + 75);
      v32 = (int8x16_t)vcgtq_f32(v31, v29);
      v33 = (int8x16_t)vcgtq_f32(v31, v30);
      v34 = *((int8x16_t *)a2 + 83);
      v35 = *((float32x4_t *)a2 + 5);
      v36 = (float32x4_t)vbslq_s8(v33, v34, (int8x16_t)v35);
      v37 = vmulq_f32(v29, (float32x4_t)vbslq_s8(v32, v34, (int8x16_t)v35));
      v38 = vmulq_f32(v30, v36);
      v39 = *((float32x4_t *)a2 + 84);
      v40 = *((float32x4_t *)a2 + 77);
      v41 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vceqq_f32(v40, v31)), v31);
      v42 = (float32x4_t)vbslq_s8(v41, (int8x16_t)v35, (int8x16_t)vminq_f32(v37, v39));
      v43 = (float32x4_t)vbslq_s8(v41, (int8x16_t)v35, (int8x16_t)vminq_f32(v38, v39));
      v44 = *((int8x16_t *)a2 + 19);
      v45 = *((float32x4_t *)a2 + 20);
      v46 = (float32x4_t)vorrq_s8(vandq_s8(v44, (int8x16_t)v42), (int8x16_t)v35);
      v47 = *((int8x16_t *)a2 + 21);
      v48 = *((float32x4_t *)a2 + 22);
      v49 = (float32x4_t)vorrq_s8(vandq_s8(v44, (int8x16_t)v43), (int8x16_t)v35);
      v50 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v43, 0x17uLL)), (float32x4_t)vandq_s8(v47, (int8x16_t)vcgtq_f32(v45, v43)));
      v51 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v42, 0x17uLL)), (float32x4_t)vandq_s8(v47, (int8x16_t)vcgtq_f32(v45, v42))), v48);
      v52 = *((float32x4_t *)a2 + 23);
      v53 = *((float32x4_t *)a2 + 24);
      v54 = (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v46, v52));
      v55 = (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v49, v52));
      v56 = vaddq_f32(v51, v54);
      v57 = vmulq_f32(v53, v54);
      v58 = vmulq_f32(vmulq_f32(v53, v55), v49);
      v59 = vaddq_f32(vsubq_f32(v50, v48), v55);
      v60 = vsubq_f32(vsubq_f32(v46, v35), vmulq_f32(v57, v46));
      v61 = vsubq_f32(vsubq_f32(v49, v35), v58);
      v62 = vmulq_f32(v60, v60);
      v63 = *((float32x4_t *)a2 + 37);
      v64 = *((float32x4_t *)a2 + 38);
      v65 = vmulq_f32(v61, v61);
      v66 = *((float32x4_t *)a2 + 39);
      v67 = *((float32x4_t *)a2 + 40);
      v68 = vaddq_f32(v63, vmulq_f32(v64, v60));
      v69 = vaddq_f32(v66, vmulq_f32(v67, v60));
      v70 = vaddq_f32(v66, vmulq_f32(v67, v61));
      v71 = vaddq_f32(v63, vmulq_f32(v64, v61));
      v73 = *((float32x4_t *)a2 + 41);
      v72 = *((float32x4_t *)a2 + 42);
      v74 = vmulq_f32(v60, vaddq_f32(vaddq_f32(v73, vmulq_f32(v72, v60)), vmulq_f32(v62, vaddq_f32(v68, vmulq_f32(v62, v69)))));
      v75 = vmulq_f32(v61, vaddq_f32(vaddq_f32(v73, vmulq_f32(v72, v61)), vmulq_f32(v65, vaddq_f32(v71, vmulq_f32(v65, v70)))));
      v76 = *((float32x4_t *)a2 + 43);
      v77 = *((float32x4_t *)a2 + 44);
      v78 = vmulq_f32(v40, vaddq_f32(v56, vmulq_f32(v60, vaddq_f32(v76, v74))));
      v79 = vmulq_f32(v40, vaddq_f32(v59, vmulq_f32(v61, vaddq_f32(v76, v75))));
      v80 = *((float32x4_t *)a2 + 29);
      v81 = vmaxq_f32(v78, v80);
      v82 = vmaxq_f32(v79, v80);
      v83 = vcvtq_f32_s32(vcvtq_s32_f32(v81));
      v84 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
      v85 = vsubq_f32(v83, (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v83, v81)));
      v86 = vsubq_f32(v84, (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v84, v82)));
      v87 = vsubq_f32(v81, v85);
      v88 = vsubq_f32(v82, v86);
      v89 = *((float32x4_t *)a2 + 45);
      v90 = *((float32x4_t *)a2 + 46);
      v91 = vaddq_f32(v77, vmulq_f32(v89, v87));
      v92 = vaddq_f32(v77, vmulq_f32(v89, v88));
      v93 = *((float32x4_t *)a2 + 47);
      v94 = *((float32x4_t *)a2 + 48);
      v95 = *((int32x4_t *)a2 + 33);
      v96 = vmulq_f32(vaddq_f32(v35, vmulq_f32(v87, vaddq_f32(v94, vmulq_f32(v87, vaddq_f32(vaddq_f32(v90, vmulq_f32(v87, v93)), vmulq_f32(vmulq_f32(v87, v87), v91)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v95, vcvtq_s32_f32(v85)), 0x17uLL));
      v97 = vmulq_f32(vaddq_f32(v35, vmulq_f32(v88, vaddq_f32(v94, vmulq_f32(v88, vaddq_f32(vaddq_f32(v90, vmulq_f32(v93, v88)), vmulq_f32(vmulq_f32(v88, v88), v92)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v95, vcvtq_s32_f32(v86)), 0x17uLL));
      v98 = *((float32x4_t *)a2 + 91);
      v99 = *((float32x4_t *)a2 + 92);
      v100 = (int8x16_t)vaddq_f32(v98, vmulq_f32(v99, v96));
      v101 = vmulq_f32(v99, v97);
      v102 = *((float32x4_t *)a2 + 93);
      v103 = (int8x16_t)vaddq_f32(v98, v101);
      v104 = *((float32x4_t *)a2 + 94);
      v105 = (float32x4_t)vbslq_s8(v32, (int8x16_t)v28, (int8x16_t)v35);
      v106 = (float32x4_t)vbslq_s8(v33, (int8x16_t)v28, (int8x16_t)v35);
      v107 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v26, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v31, vsubq_f32(v37, v104)), (int8x16_t)vmulq_f32(v37, v102), v100), v105));
      v108 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v31, vsubq_f32(v38, v104)), (int8x16_t)vmulq_f32(v38, v102), v103), v106));
      v109 = (int8x16_t *)(v6 + v11);
      v109[-1] = vbslq_s8(v14, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v107, v107, 3));
      *v109 = vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v108, v108, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v110 = -v10;
    if (v110 >= v5)
      goto LABEL_3;
LABEL_10:
    v111 = 16 * v110;
    v112 = *(float32x4_t *)(v7 + v111);
    v113 = *((int8x16_t *)a2 + 15);
    v114 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v112, 3), *((float32x4_t *)a2 + 16));
    v115 = vrecpeq_f32(v114);
    v116 = vmulq_f32(v115, vrecpsq_f32(v115, v114));
    v117 = vmulq_f32(v112, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v116, vrecpsq_f32(v116, v114))), *((int8x16_t *)a2 + 3)));
    v118 = *((float32x4_t *)a2 + 82);
    v119 = (float32x4_t)vbslq_s8(v113, (int8x16_t)v117, (int8x16_t)vmaxq_f32(v117, v118));
    v120 = *((float32x4_t *)a2 + 75);
    v121 = (int8x16_t)vcgtq_f32(v120, v119);
    v122 = *((float32x4_t *)a2 + 5);
    v123 = vmulq_f32(v119, (float32x4_t)vbslq_s8(v121, *((int8x16_t *)a2 + 83), (int8x16_t)v122));
    v124 = *((float32x4_t *)a2 + 77);
    v125 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v122, (int8x16_t)vceqq_f32(v124, v120)), v120), (int8x16_t)v122, (int8x16_t)vminq_f32(v123, *((float32x4_t *)a2 + 84)));
    v126 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v125), (int8x16_t)v122);
    v127 = (float32x4_t)vandq_s8((int8x16_t)v122, (int8x16_t)vcgtq_f32(v126, *((float32x4_t *)a2 + 23)));
    v128 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v125, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v125))), *((float32x4_t *)a2 + 22)), v127);
    v129 = vsubq_f32(vsubq_f32(v126, v122), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v127), v126));
    v130 = vmulq_f32(v129, v129);
    v131 = vmaxq_f32(vmulq_f32(v124, vaddq_f32(v128, vmulq_f32(v129, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v129, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v129)), vmulq_f32(v130, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v129)), vmulq_f32(v130, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v129))))))))))),
             *((float32x4_t *)a2 + 29));
    v132 = vcvtq_f32_s32(vcvtq_s32_f32(v131));
    v133 = vsubq_f32(v132, (float32x4_t)vandq_s8((int8x16_t)v122, (int8x16_t)vcgtq_f32(v132, v131)));
    v134 = vsubq_f32(v131, v133);
    v135 = (float32x4_t)vbslq_s8(v113, (int8x16_t)v117, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v120, vsubq_f32(v123, *((float32x4_t *)a2 + 94))), (int8x16_t)vmulq_f32(v123, *((float32x4_t *)a2 + 93)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 91), vmulq_f32(*((float32x4_t *)a2 + 92), vmulq_f32(vaddq_f32(v122, vmulq_f32(v134, vaddq_f32(*((float32x4_t *)a2 + 48),
                                                                             vmulq_f32(v134, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v134)), vmulq_f32(vmulq_f32(v134, v134), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v134)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v133)), 0x17uLL))))),
                                       (float32x4_t)vbslq_s8(v121, (int8x16_t)v118, (int8x16_t)v122)));
    *(int8x16_t *)(v6 + v111) = vbslq_s8(v113, (int8x16_t)v117, (int8x16_t)vmulq_laneq_f32(v135, v135, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec601_fast_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t *v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  int8x16_t *v49;
  int8x16_t *v50;
  float32x4_t v51;
  int8x16_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v56 = 0;
        v57 = 16 * v8;
        v58 = 16 * v7;
        v59 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v60 = 0;
          do
          {
            v61 = *((int8x16_t *)a2 + 15);
            v62 = vmulq_f32(v5[v60 / 0x10], (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5[v60 / 0x10], 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v63 = vminq_f32(vmaxq_f32(v62, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v64 = (float32x4_t)vbslq_s8(v61, (int8x16_t)v62, (int8x16_t)vmulq_f32(v63, v63));
            v6[v60 / 0x10] = vbslq_s8(v61, (int8x16_t)v62, (int8x16_t)vmulq_laneq_f32(v64, v64, 3));
            v60 += 16;
          }
          while (v59 != v60);
          ++v56;
          v5 = (float32x4_t *)((char *)v5 + v57);
          v6 = (int8x16_t *)((char *)v6 + v58);
        }
        while (v56 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v5[v17 - 2];
          v19 = v5[v17 - 1];
          v20 = v5[v17];
          v21 = v5[v17 + 1];
          v23 = *((int8x16_t *)a2 + 15);
          v22 = *((float32x4_t *)a2 + 16);
          v24 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 3), v22));
          v25 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3), v22));
          v26 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 3), v22));
          v27 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 3), v22));
          v28 = *((int8x16_t *)a2 + 17);
          v29 = vandq_s8(v28, v24);
          v30 = vandq_s8(v28, v25);
          v31 = vandq_s8(v28, v26);
          v32 = vandq_s8(v28, v27);
          v33 = *((int8x16_t *)a2 + 3);
          v34 = vmulq_f32(v18, (float32x4_t)vorrq_s8(v29, v33));
          v35 = vmulq_f32(v19, (float32x4_t)vorrq_s8(v30, v33));
          v36 = vmulq_f32(v20, (float32x4_t)vorrq_s8(v31, v33));
          v37 = vmulq_f32(v21, (float32x4_t)vorrq_s8(v32, v33));
          v38 = *((float32x4_t *)a2 + 75);
          v39 = *((float32x4_t *)a2 + 5);
          v40 = vminq_f32(vmaxq_f32(v34, v38), v39);
          v41 = vminq_f32(vmaxq_f32(v35, v38), v39);
          v42 = vminq_f32(vmaxq_f32(v36, v38), v39);
          v43 = vminq_f32(vmaxq_f32(v37, v38), v39);
          v44 = v16;
          v45 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v34, (int8x16_t)vmulq_f32(v40, v40));
          v46 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v35, (int8x16_t)vmulq_f32(v41, v41));
          v47 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v36, (int8x16_t)vmulq_f32(v42, v42));
          v48 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v37, (int8x16_t)vmulq_f32(v43, v43));
          v49 = v15;
          v50 = &v6[v17];
          v14 += 4;
          v50[-2] = vbslq_s8(v23, (int8x16_t)v34, (int8x16_t)vmulq_laneq_f32(v45, v45, 3));
          v50[-1] = vbslq_s8(v23, (int8x16_t)v35, (int8x16_t)vmulq_laneq_f32(v46, v46, 3));
          *v50 = vbslq_s8(v23, (int8x16_t)v36, (int8x16_t)vmulq_laneq_f32(v47, v47, 3));
          v50[1] = vbslq_s8(v23, (int8x16_t)v37, (int8x16_t)vmulq_laneq_f32(v48, v48, 3));
          v17 += 4;
          v16 += 4;
          v15 = v49 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v51 = *v44++;
            v52 = *((int8x16_t *)a2 + 15);
            v53 = vmulq_f32(v51, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v54 = vminq_f32(vmaxq_f32(v53, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v55 = (float32x4_t)vbslq_s8(v52, (int8x16_t)v53, (int8x16_t)vmulq_f32(v54, v54));
            *v49++ = vbslq_s8(v52, (int8x16_t)v53, (int8x16_t)vmulq_laneq_f32(v55, v55, 3));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getinv_rec601_fixed_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int8x16_t *v83;
  uint64_t v84;
  int8x16_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v84) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v17 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15));
      v18 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15));
      v19 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v15));
      v21 = *((int8x16_t *)a2 + 17);
      v20 = *((float32x4_t *)a2 + 18);
      v22 = (int8x16_t)vmulq_f32(v19, v20);
      v23 = vandq_s8(v21, (int8x16_t)vmulq_f32(v17, v20));
      v24 = vandq_s8(v21, (int8x16_t)vmulq_f32(v18, v20));
      v25 = *((int8x16_t *)a2 + 3);
      v26 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v23, v25));
      v27 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v24, v25));
      v28 = vmulq_f32(v14, (float32x4_t)vorrq_s8(vandq_s8(v21, v22), v25));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = *((float32x4_t *)a2 + 6);
      v32 = vminq_f32(vmaxq_f32(v26, v29), v30);
      v33 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v34 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v35 = *((float32x4_t *)a2 + 95);
      v36 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)vaddq_f32(v32, v35)));
      v37 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)vaddq_f32(v33, v35)));
      v38 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)vaddq_f32(v34, v35)));
      v39 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
      v40 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
      v41 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
      v42 = *((float32x4_t *)a2 + 7);
      v43 = *((float32x4_t *)a2 + 8);
      v44 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v36, v39), v42));
      v45 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v37, v40), v42));
      v46 = vrsqrteq_f32(vaddq_f32(v42, vsubq_f32(v38, v41)));
      v47 = vaddq_f32(v43, v39);
      v48 = vaddq_f32(v43, v40);
      v49 = vaddq_f32(v43, v41);
      v50 = *((float32x4_t *)a2 + 9);
      v51 = *((float32x4_t *)a2 + 10);
      v52 = vsubq_f32(v47, vmulq_f32(v44, v50));
      v53 = vsubq_f32(v48, vmulq_f32(v45, v50));
      v54 = *((float32x4_t *)a2 + 86);
      v55 = vmulq_f32(v54, v52);
      v56 = vmulq_f32(v54, v53);
      v57 = vmulq_f32(v54, vsubq_f32(v49, vmulq_f32(v46, v50)));
      v58 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      v59 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
      v60 = vcvtq_f32_s32(vcvtq_s32_f32(v57));
      v61 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v58, v55)));
      v62 = vsubq_f32(v59, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v59, v56)));
      v63 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v60, v57)));
      v64 = *((float32x4_t *)a2 + 11);
      v65 = *((float32x4_t *)a2 + 12);
      v66 = vmulq_f32(vrecpeq_f32(vsubq_f32(v64, vsubq_f32(v55, v61))), v65);
      v67 = vmulq_f32(vrecpeq_f32(vsubq_f32(v64, vsubq_f32(v56, v62))), v65);
      v68 = vmulq_f32(vrecpeq_f32(vsubq_f32(v64, vsubq_f32(v57, v63))), v65);
      v69 = vaddq_f32(vaddq_f32(v51, v63), vmulq_f32(v68, v68));
      v70 = vmaxq_f32(vaddq_f32(vaddq_f32(v51, v61), vmulq_f32(v66, v66)), v29);
      v71 = vmaxq_f32(vaddq_f32(vaddq_f32(v51, v62), vmulq_f32(v67, v67)), v29);
      v72 = *((float32x4_t *)a2 + 13);
      v73 = *((float32x4_t *)a2 + 14);
      v74 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v70, v72), v73));
      v75 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v71, v72), v73));
      v76 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v69, v29), v72), v73));
      v77 = *((float32x4_t *)a2 + 96);
      v78 = *((float32x4_t *)a2 + 97);
      v79 = *((float32x4_t *)a2 + 98);
      v80 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v26, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v79)), (int8x16_t)vmulq_f32(v32, v78), (int8x16_t)vmulq_f32(v77, v74)));
      v81 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v27, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v33, v79)), (int8x16_t)vmulq_f32(v33, v78), (int8x16_t)vmulq_f32(v77, v75)));
      v82 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v28, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v34, v79)), (int8x16_t)vmulq_f32(v34, v78), (int8x16_t)vmulq_f32(v77, v76)));
      v83 = (int8x16_t *)(v6 + v10);
      *v83 = vbslq_s8(v16, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      v83[1] = vbslq_s8(v16, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      v83[2] = vbslq_s8(v16, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v82, v82, 3));
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v84) = -v11;
    if ((int)v84 >= v5)
      goto LABEL_3;
LABEL_10:
    v84 = v84;
    do
    {
      v85 = *((int8x16_t *)a2 + 15);
      v86 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v84), (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v7 + 16 * v84), 3), *((float32x4_t *)a2 + 16))), *((float32x4_t *)a2 + 18))), *((int8x16_t *)a2 + 3)));
      v87 = *((float32x4_t *)a2 + 75);
      v88 = *((float32x4_t *)a2 + 5);
      v89 = vminq_f32(vmaxq_f32(v86, v87), v88);
      v90 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v89, *((float32x4_t *)a2 + 95))));
      v91 = vcvtq_f32_s32(vcvtq_s32_f32(v90));
      v92 = vmulq_f32(*((float32x4_t *)a2 + 86), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v91), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v90, v91))), *((float32x4_t *)a2 + 9))));
      v93 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
      v94 = vsubq_f32(v93, (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v93, v92)));
      v95 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v92, v94))), *((float32x4_t *)a2 + 12));
      v96 = (float32x4_t)vbslq_s8(v85, (int8x16_t)v86, vbslq_s8((int8x16_t)vcgtq_f32(v87, vsubq_f32(v89, *((float32x4_t *)a2 + 98))), (int8x16_t)vmulq_f32(v89, *((float32x4_t *)a2 + 97)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 96), (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v94), vmulq_f32(v95, v95)), v87), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))))));
      *(int8x16_t *)(v6 + 16 * v84++) = vbslq_s8(v85, (int8x16_t)v86, (int8x16_t)vmulq_laneq_f32(v96, v96, 3));
    }
    while (v84 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec601_nice_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  int32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  int8x16_t v96;
  int8x16_t v97;
  float32x4_t v98;
  int8x16_t v99;
  int8x16_t v100;
  float32x4_t v101;
  float32x4_t v102;
  int8x16_t *v103;
  int v104;
  uint64_t v105;
  float32x4_t v106;
  int8x16_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v104 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = *((int8x16_t *)a2 + 17);
      v24 = vandq_s8(v23, v22);
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v32 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v33 = *((float32x4_t *)a2 + 95);
      v34 = *((float32x4_t *)a2 + 86);
      v35 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vceqq_f32(v34, v29)), v29);
      v36 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v30, (int8x16_t)vaddq_f32(v31, v33));
      v37 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v30, (int8x16_t)vaddq_f32(v32, v33));
      v38 = *((int8x16_t *)a2 + 19);
      v39 = *((float32x4_t *)a2 + 20);
      v40 = (float32x4_t)vorrq_s8(vandq_s8(v38, (int8x16_t)v36), (int8x16_t)v30);
      v41 = (float32x4_t)vorrq_s8(vandq_s8(v38, (int8x16_t)v37), (int8x16_t)v30);
      v42 = *((int8x16_t *)a2 + 21);
      v43 = *((float32x4_t *)a2 + 22);
      v44 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v36, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v39, v36)));
      v45 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v39, v37)));
      v46 = *((float32x4_t *)a2 + 23);
      v47 = *((float32x4_t *)a2 + 24);
      v48 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v40, v46));
      v49 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v41, v46));
      v50 = vaddq_f32(vsubq_f32(v44, v43), v48);
      v51 = vmulq_f32(v47, v48);
      v52 = vmulq_f32(vmulq_f32(v47, v49), v41);
      v53 = vaddq_f32(vsubq_f32(v45, v43), v49);
      v54 = vsubq_f32(vsubq_f32(v40, v30), vmulq_f32(v51, v40));
      v55 = vsubq_f32(vsubq_f32(v41, v30), v52);
      v56 = vmulq_f32(v54, v54);
      v57 = vmulq_f32(v55, v55);
      v58 = *((float32x4_t *)a2 + 37);
      v59 = *((float32x4_t *)a2 + 38);
      v60 = *((float32x4_t *)a2 + 39);
      v61 = *((float32x4_t *)a2 + 40);
      v62 = vaddq_f32(v58, vmulq_f32(v59, v54));
      v63 = vaddq_f32(v60, vmulq_f32(v61, v54));
      v64 = vaddq_f32(v60, vmulq_f32(v61, v55));
      v65 = vaddq_f32(v58, vmulq_f32(v59, v55));
      v66 = *((float32x4_t *)a2 + 41);
      v67 = *((float32x4_t *)a2 + 42);
      v68 = vaddq_f32(vaddq_f32(v66, vmulq_f32(v67, v55)), vmulq_f32(v57, vaddq_f32(v65, vmulq_f32(v57, v64))));
      v69 = vmulq_f32(v54, vaddq_f32(vaddq_f32(v66, vmulq_f32(v67, v54)), vmulq_f32(v56, vaddq_f32(v62, vmulq_f32(v56, v63)))));
      v70 = *((float32x4_t *)a2 + 43);
      v71 = *((float32x4_t *)a2 + 44);
      v72 = vmulq_f32(v34, vaddq_f32(v50, vmulq_f32(v54, vaddq_f32(v70, v69))));
      v73 = vmulq_f32(v34, vaddq_f32(v53, vmulq_f32(v55, vaddq_f32(v70, vmulq_f32(v55, v68)))));
      v74 = *((float32x4_t *)a2 + 29);
      v75 = vmaxq_f32(v72, v74);
      v76 = vmaxq_f32(v73, v74);
      v77 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v76));
      v79 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v77, v75)));
      v80 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v78, v76)));
      v81 = vsubq_f32(v75, v79);
      v82 = vsubq_f32(v76, v80);
      v83 = *((float32x4_t *)a2 + 45);
      v84 = *((float32x4_t *)a2 + 46);
      v85 = vaddq_f32(v71, vmulq_f32(v83, v81));
      v86 = vaddq_f32(v71, vmulq_f32(v83, v82));
      v87 = *((float32x4_t *)a2 + 47);
      v88 = *((float32x4_t *)a2 + 48);
      v89 = vaddq_f32(v30, vmulq_f32(v81, vaddq_f32(v88, vmulq_f32(v81, vaddq_f32(vaddq_f32(v84, vmulq_f32(v81, v87)), vmulq_f32(vmulq_f32(v81, v81), v85))))));
      v90 = *((int32x4_t *)a2 + 33);
      v91 = vaddq_f32(v30, vmulq_f32(v82, vaddq_f32(v88, vmulq_f32(v82, vaddq_f32(vaddq_f32(v84, vmulq_f32(v87, v82)), vmulq_f32(vmulq_f32(v82, v82), v86))))));
      v92 = vmulq_f32(v89, (float32x4_t)vshlq_n_s32(vaddq_s32(v90, vcvtq_s32_f32(v79)), 0x17uLL));
      v93 = vmulq_f32(v91, (float32x4_t)vshlq_n_s32(vaddq_s32(v90, vcvtq_s32_f32(v80)), 0x17uLL));
      v94 = *((float32x4_t *)a2 + 96);
      v95 = *((float32x4_t *)a2 + 97);
      v96 = (int8x16_t)vmulq_f32(v31, v95);
      v97 = (int8x16_t)vmulq_f32(v32, v95);
      v98 = *((float32x4_t *)a2 + 98);
      v99 = (int8x16_t)vcgtq_f32(v29, vsubq_f32(v31, v98));
      v100 = (int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v98));
      v101 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, vbslq_s8(v99, v96, (int8x16_t)vmulq_f32(v94, v92)));
      v102 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, vbslq_s8(v100, v97, (int8x16_t)vmulq_f32(v94, v93)));
      v103 = (int8x16_t *)(v6 + v11);
      v103[-1] = vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v101, v101, 3));
      *v103 = vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v102, v102, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v104 = -v10;
    if (v104 >= v5)
      goto LABEL_3;
LABEL_10:
    v105 = 16 * v104;
    v106 = *(float32x4_t *)(v7 + v105);
    v107 = *((int8x16_t *)a2 + 15);
    v108 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 3), *((float32x4_t *)a2 + 16));
    v109 = vrecpeq_f32(v108);
    v110 = vmulq_f32(v109, vrecpsq_f32(v109, v108));
    v111 = vmulq_f32(v106, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v110, vrecpsq_f32(v110, v108))), *((int8x16_t *)a2 + 3)));
    v112 = *((float32x4_t *)a2 + 75);
    v113 = *((float32x4_t *)a2 + 5);
    v114 = vminq_f32(vmaxq_f32(v111, v112), v113);
    v115 = *((float32x4_t *)a2 + 86);
    v116 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vceqq_f32(v115, v112)), v112), (int8x16_t)v113, (int8x16_t)vaddq_f32(v114, *((float32x4_t *)a2 + 95)));
    v117 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v116), (int8x16_t)v113);
    v118 = (float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v117, *((float32x4_t *)a2 + 23)));
    v119 = vsubq_f32(vsubq_f32(v117, v113), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v118), v117));
    v120 = vmulq_f32(v119, v119);
    v121 = vmaxq_f32(vmulq_f32(v115, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v116, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v116))), *((float32x4_t *)a2 + 22)), v118), vmulq_f32(v119, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v119, vaddq_f32(
                         vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v119)),
                         vmulq_f32(v120, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v119)), vmulq_f32(v120, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v119))))))))))), *((float32x4_t *)a2 + 29));
    v122 = vcvtq_f32_s32(vcvtq_s32_f32(v121));
    v123 = vsubq_f32(v122, (float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v122, v121)));
    v124 = vsubq_f32(v121, v123);
    v125 = (float32x4_t)vbslq_s8(v107, (int8x16_t)v111, vbslq_s8((int8x16_t)vcgtq_f32(v112, vsubq_f32(v114, *((float32x4_t *)a2 + 98))), (int8x16_t)vmulq_f32(v114, *((float32x4_t *)a2 + 97)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 96), vmulq_f32(vaddq_f32(v113, vmulq_f32(v124, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v124, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46),
                                                       vmulq_f32(*((float32x4_t *)a2 + 47), v124)),
                                                     vmulq_f32(vmulq_f32(v124, v124), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v124)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v123)), 0x17uLL)))));
    *(int8x16_t *)(v6 + v105) = vbslq_s8(v107, (int8x16_t)v111, (int8x16_t)vmulq_laneq_f32(v125, v125, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec601_half_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int32x4_t v73;
  int32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int8x16_t *v83;
  int v84;
  uint64_t v85;
  float32x4_t v86;
  int8x16_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v84 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23));
      v26 = *((float32x4_t *)a2 + 75);
      v27 = *((float32x4_t *)a2 + 5);
      v28 = vminq_f32(vmaxq_f32(v24, v26), v27);
      v29 = vminq_f32(vmaxq_f32(v25, v26), v27);
      v30 = *((float32x4_t *)a2 + 95);
      v31 = vaddq_f32(v28, v30);
      v32 = vaddq_f32(v29, v30);
      v33 = *((int8x16_t *)a2 + 19);
      v34 = *((float32x4_t *)a2 + 20);
      v35 = (float32x4_t)vorrq_s8(vandq_s8(v33, (int8x16_t)v31), (int8x16_t)v27);
      v36 = (float32x4_t)vorrq_s8(vandq_s8(v33, (int8x16_t)v32), (int8x16_t)v27);
      v37 = *((int8x16_t *)a2 + 21);
      v38 = *((float32x4_t *)a2 + 22);
      v39 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v32, 0x17uLL)), (float32x4_t)vandq_s8(v37, (int8x16_t)vcgtq_f32(v34, v32)));
      v40 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v31, 0x17uLL)), (float32x4_t)vandq_s8(v37, (int8x16_t)vcgtq_f32(v34, v31))), v38);
      v41 = *((float32x4_t *)a2 + 23);
      v42 = *((float32x4_t *)a2 + 24);
      v43 = vsubq_f32(v39, v38);
      v44 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v35, v41));
      v45 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v36, v41));
      v46 = vaddq_f32(v40, v44);
      v47 = vsubq_f32(vsubq_f32(v35, v27), vmulq_f32(vmulq_f32(v42, v44), v35));
      v48 = vsubq_f32(vsubq_f32(v36, v27), vmulq_f32(vmulq_f32(v42, v45), v36));
      v49 = *((float32x4_t *)a2 + 25);
      v50 = *((float32x4_t *)a2 + 26);
      v51 = vaddq_f32(v49, vmulq_f32(v50, v47));
      v52 = vaddq_f32(v49, vmulq_f32(v50, v48));
      v53 = *((float32x4_t *)a2 + 27);
      v54 = *((float32x4_t *)a2 + 28);
      v55 = vaddq_f32(vaddq_f32(v43, v45), vmulq_f32(v48, vaddq_f32(vaddq_f32(v53, vmulq_f32(v48, v54)), vmulq_f32(vmulq_f32(v48, v48), v52))));
      v56 = *((float32x4_t *)a2 + 86);
      v57 = vmulq_f32(v56, vaddq_f32(v46, vmulq_f32(v47, vaddq_f32(vaddq_f32(v53, vmulq_f32(v47, v54)), vmulq_f32(vmulq_f32(v47, v47), v51)))));
      v58 = vmulq_f32(v56, v55);
      v59 = *((float32x4_t *)a2 + 29);
      v60 = *((float32x4_t *)a2 + 30);
      v61 = vmaxq_f32(v57, v59);
      v62 = vmaxq_f32(v58, v59);
      v63 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v64 = vcvtq_f32_s32(vcvtq_s32_f32(v62));
      v65 = vsubq_f32(v63, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v63, v61)));
      v66 = vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v64, v62)));
      v67 = vsubq_f32(v61, v65);
      v68 = *((float32x4_t *)a2 + 31);
      v69 = *((float32x4_t *)a2 + 32);
      v70 = vsubq_f32(v62, v66);
      v71 = vmulq_f32(v70, vaddq_f32(v69, vmulq_f32(v70, vaddq_f32(v60, vmulq_f32(v68, v70)))));
      v72 = vaddq_f32(v27, vmulq_f32(v67, vaddq_f32(v69, vmulq_f32(v67, vaddq_f32(v60, vmulq_f32(v68, v67))))));
      v73 = vcvtq_s32_f32(v66);
      v74 = *((int32x4_t *)a2 + 33);
      v75 = vaddq_f32(v27, v71);
      v76 = vmulq_f32(v72, (float32x4_t)vshlq_n_s32(vaddq_s32(v74, vcvtq_s32_f32(v65)), 0x17uLL));
      v77 = vmulq_f32(v75, (float32x4_t)vshlq_n_s32(vaddq_s32(v74, v73), 0x17uLL));
      v78 = *((float32x4_t *)a2 + 96);
      v79 = *((float32x4_t *)a2 + 97);
      v80 = *((float32x4_t *)a2 + 98);
      v81 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v24, vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v28, v80)), (int8x16_t)vmulq_f32(v28, v79), (int8x16_t)vmulq_f32(v78, v76)));
      v82 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v25, vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v29, v80)), (int8x16_t)vmulq_f32(v29, v79), (int8x16_t)vmulq_f32(v78, v77)));
      v83 = (int8x16_t *)(v6 + v11);
      v83[-1] = vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      *v83 = vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v82, v82, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v84 = -v10;
    if (v84 >= v5)
      goto LABEL_3;
LABEL_10:
    v85 = 16 * v84;
    v86 = *(float32x4_t *)(v7 + v85);
    v87 = *((int8x16_t *)a2 + 15);
    v88 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v86, 3), *((float32x4_t *)a2 + 16));
    v89 = vmulq_f32(vrecpeq_f32(v88), *((float32x4_t *)a2 + 18));
    v90 = vmulq_f32(v86, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v89, vrecpsq_f32(v89, v88))), *((int8x16_t *)a2 + 3)));
    v91 = *((float32x4_t *)a2 + 75);
    v92 = *((float32x4_t *)a2 + 5);
    v93 = vminq_f32(vmaxq_f32(v90, v91), v92);
    v94 = vaddq_f32(v93, *((float32x4_t *)a2 + 95));
    v95 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v94), (int8x16_t)v92);
    v96 = (float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v95, *((float32x4_t *)a2 + 23)));
    v97 = vsubq_f32(vsubq_f32(v95, v92), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v96), v95));
    v98 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 86), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v94, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v94))), *((float32x4_t *)a2 + 22)), v96), vmulq_f32(v97, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v97, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v97, v97), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v97))))))),
            *((float32x4_t *)a2 + 29));
    v99 = vcvtq_f32_s32(vcvtq_s32_f32(v98));
    v100 = vsubq_f32(v99, (float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v99, v98)));
    v101 = vsubq_f32(v98, v100);
    v102 = (float32x4_t)vbslq_s8(v87, (int8x16_t)v90, vbslq_s8((int8x16_t)vcgtq_f32(v91, vsubq_f32(v93, *((float32x4_t *)a2 + 98))), (int8x16_t)vmulq_f32(v93, *((float32x4_t *)a2 + 97)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 96), vmulq_f32(vaddq_f32(v92, vmulq_f32(v101, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v101, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v101)))))),
                                           (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v100)), 0x17uLL)))));
    *(int8x16_t *)(v6 + v85) = vbslq_s8(v87, (int8x16_t)v90, (int8x16_t)vmulq_laneq_f32(v102, v102, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec601_halfTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  int32x4_t v82;
  int32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int8x16_t v87;
  float32x4_t v88;
  int8x16_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t *v95;
  int v96;
  uint64_t v97;
  float32x4_t v98;
  int8x16_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  int8x16_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v96 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23));
      v26 = *((float32x4_t *)a2 + 82);
      v27 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmaxq_f32(v24, v26));
      v28 = *((float32x4_t *)a2 + 75);
      v29 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmaxq_f32(v25, v26));
      v30 = (int8x16_t)vcgtq_f32(v28, v27);
      v31 = (int8x16_t)vcgtq_f32(v28, v29);
      v32 = *((int8x16_t *)a2 + 83);
      v33 = *((float32x4_t *)a2 + 5);
      v34 = (float32x4_t)vbslq_s8(v31, v32, (int8x16_t)v33);
      v35 = vmulq_f32(v27, (float32x4_t)vbslq_s8(v30, v32, (int8x16_t)v33));
      v36 = vmulq_f32(v29, v34);
      v37 = *((float32x4_t *)a2 + 90);
      v38 = *((float32x4_t *)a2 + 95);
      v39 = vaddq_f32(vminq_f32(v35, v37), v38);
      v40 = vaddq_f32(vminq_f32(v36, v37), v38);
      v41 = *((int8x16_t *)a2 + 19);
      v42 = *((float32x4_t *)a2 + 20);
      v43 = (float32x4_t)vorrq_s8(vandq_s8(v41, (int8x16_t)v39), (int8x16_t)v33);
      v44 = *((int8x16_t *)a2 + 21);
      v45 = *((float32x4_t *)a2 + 22);
      v46 = (float32x4_t)vorrq_s8(vandq_s8(v41, (int8x16_t)v40), (int8x16_t)v33);
      v47 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v40, 0x17uLL)), (float32x4_t)vandq_s8(v44, (int8x16_t)vcgtq_f32(v42, v40)));
      v48 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v39, 0x17uLL)), (float32x4_t)vandq_s8(v44, (int8x16_t)vcgtq_f32(v42, v39))), v45);
      v49 = *((float32x4_t *)a2 + 23);
      v50 = *((float32x4_t *)a2 + 24);
      v51 = vsubq_f32(v47, v45);
      v52 = (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v43, v49));
      v53 = (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v46, v49));
      v54 = vmulq_f32(v50, v52);
      v55 = vaddq_f32(v48, v52);
      v56 = vmulq_f32(vmulq_f32(v50, v53), v46);
      v57 = vaddq_f32(v51, v53);
      v58 = vsubq_f32(vsubq_f32(v43, v33), vmulq_f32(v54, v43));
      v59 = vsubq_f32(vsubq_f32(v46, v33), v56);
      v60 = *((float32x4_t *)a2 + 25);
      v61 = *((float32x4_t *)a2 + 26);
      v62 = *((float32x4_t *)a2 + 27);
      v63 = *((float32x4_t *)a2 + 28);
      v64 = vaddq_f32(v57, vmulq_f32(v59, vaddq_f32(vaddq_f32(v62, vmulq_f32(v59, v63)), vmulq_f32(vmulq_f32(v59, v59), vaddq_f32(v60, vmulq_f32(v61, v59))))));
      v65 = *((float32x4_t *)a2 + 86);
      v66 = vmulq_f32(v65, vaddq_f32(v55, vmulq_f32(v58, vaddq_f32(vaddq_f32(v62, vmulq_f32(v58, v63)), vmulq_f32(vmulq_f32(v58, v58), vaddq_f32(v60, vmulq_f32(v61, v58)))))));
      v67 = vmulq_f32(v65, v64);
      v68 = *((float32x4_t *)a2 + 29);
      v69 = *((float32x4_t *)a2 + 30);
      v70 = vmaxq_f32(v66, v68);
      v71 = vmaxq_f32(v67, v68);
      v72 = vcvtq_f32_s32(vcvtq_s32_f32(v70));
      v73 = vcvtq_f32_s32(vcvtq_s32_f32(v71));
      v74 = vsubq_f32(v72, (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v72, v70)));
      v75 = vsubq_f32(v73, (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v73, v71)));
      v76 = vsubq_f32(v70, v74);
      v77 = vsubq_f32(v71, v75);
      v78 = *((float32x4_t *)a2 + 31);
      v79 = *((float32x4_t *)a2 + 32);
      v80 = vmulq_f32(v77, vaddq_f32(v79, vmulq_f32(v77, vaddq_f32(v69, vmulq_f32(v78, v77)))));
      v81 = vaddq_f32(v33, vmulq_f32(v76, vaddq_f32(v79, vmulq_f32(v76, vaddq_f32(v69, vmulq_f32(v78, v76))))));
      v82 = vcvtq_s32_f32(v75);
      v83 = *((int32x4_t *)a2 + 33);
      v84 = vmulq_f32(v81, (float32x4_t)vshlq_n_s32(vaddq_s32(v83, vcvtq_s32_f32(v74)), 0x17uLL));
      v85 = vmulq_f32(vaddq_f32(v33, v80), (float32x4_t)vshlq_n_s32(vaddq_s32(v83, v82), 0x17uLL));
      v86 = *((float32x4_t *)a2 + 96);
      v87 = (int8x16_t)vmulq_f32(v86, v84);
      v88 = *((float32x4_t *)a2 + 97);
      v89 = (int8x16_t)vmulq_f32(v86, v85);
      v90 = *((float32x4_t *)a2 + 98);
      v91 = (float32x4_t)vbslq_s8(v30, (int8x16_t)v26, (int8x16_t)v33);
      v92 = (float32x4_t)vbslq_s8(v31, (int8x16_t)v26, (int8x16_t)v33);
      v93 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v28, vsubq_f32(v35, v90)), (int8x16_t)vmulq_f32(v35, v88), v87), v91));
      v94 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v28, vsubq_f32(v36, v90)), (int8x16_t)vmulq_f32(v36, v88), v89), v92));
      v95 = (int8x16_t *)(v6 + v11);
      v95[-1] = vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v93, v93, 3));
      *v95 = vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v94, v94, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v96 = -v10;
    if (v96 >= v5)
      goto LABEL_3;
LABEL_10:
    v97 = 16 * v96;
    v98 = *(float32x4_t *)(v7 + v97);
    v99 = *((int8x16_t *)a2 + 15);
    v100 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v98, 3), *((float32x4_t *)a2 + 16));
    v101 = vmulq_f32(vrecpeq_f32(v100), *((float32x4_t *)a2 + 18));
    v102 = vmulq_f32(v98, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v101, vrecpsq_f32(v101, v100))), *((int8x16_t *)a2 + 3)));
    v103 = *((float32x4_t *)a2 + 82);
    v104 = (float32x4_t)vbslq_s8(v99, (int8x16_t)v102, (int8x16_t)vmaxq_f32(v102, v103));
    v105 = *((float32x4_t *)a2 + 75);
    v106 = (int8x16_t)vcgtq_f32(v105, v104);
    v107 = *((float32x4_t *)a2 + 5);
    v108 = vmulq_f32(v104, (float32x4_t)vbslq_s8(v106, *((int8x16_t *)a2 + 83), (int8x16_t)v107));
    v109 = vaddq_f32(vminq_f32(v108, *((float32x4_t *)a2 + 90)), *((float32x4_t *)a2 + 95));
    v110 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v109), (int8x16_t)v107);
    v111 = (float32x4_t)vandq_s8((int8x16_t)v107, (int8x16_t)vcgtq_f32(v110, *((float32x4_t *)a2 + 23)));
    v112 = vsubq_f32(vsubq_f32(v110, v107), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v111), v110));
    v113 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 86), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v109, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v109))), *((float32x4_t *)a2 + 22)), v111), vmulq_f32(v112, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v112, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v112, v112), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v112))))))),
             *((float32x4_t *)a2 + 29));
    v114 = vcvtq_f32_s32(vcvtq_s32_f32(v113));
    v115 = vsubq_f32(v114, (float32x4_t)vandq_s8((int8x16_t)v107, (int8x16_t)vcgtq_f32(v114, v113)));
    v116 = vsubq_f32(v113, v115);
    v117 = (float32x4_t)vbslq_s8(v99, (int8x16_t)v102, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v105, vsubq_f32(v108, *((float32x4_t *)a2 + 98))), (int8x16_t)vmulq_f32(v108, *((float32x4_t *)a2 + 97)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 96), vmulq_f32(vaddq_f32(v107, vmulq_f32(v116, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v116,
                                                                             vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v116)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v115)), 0x17uLL)))), (float32x4_t)vbslq_s8(v106, (int8x16_t)v103, (int8x16_t)v107)));
    *(int8x16_t *)(v6 + v97) = vbslq_s8(v99, (int8x16_t)v102, (int8x16_t)vmulq_laneq_f32(v117, v117, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec601_niceTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  int8x16_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  int32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  int8x16_t v101;
  float32x4_t v102;
  int8x16_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  int8x16_t *v109;
  int v110;
  uint64_t v111;
  float32x4_t v112;
  int8x16_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  int8x16_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v110 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17));
      v24 = *((int8x16_t *)a2 + 17);
      v25 = *((int8x16_t *)a2 + 3);
      v26 = vmulq_f32(v12, (float32x4_t)vorrq_s8(vandq_s8(v24, v22), v25));
      v27 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v24, v23), v25));
      v28 = *((float32x4_t *)a2 + 82);
      v29 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v26, (int8x16_t)vmaxq_f32(v26, v28));
      v30 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmaxq_f32(v27, v28));
      v31 = *((float32x4_t *)a2 + 75);
      v32 = (int8x16_t)vcgtq_f32(v31, v29);
      v33 = (int8x16_t)vcgtq_f32(v31, v30);
      v34 = *((int8x16_t *)a2 + 83);
      v35 = *((float32x4_t *)a2 + 5);
      v36 = (float32x4_t)vbslq_s8(v33, v34, (int8x16_t)v35);
      v37 = vmulq_f32(v29, (float32x4_t)vbslq_s8(v32, v34, (int8x16_t)v35));
      v38 = vmulq_f32(v30, v36);
      v39 = *((float32x4_t *)a2 + 90);
      v40 = *((float32x4_t *)a2 + 95);
      v41 = (int8x16_t)vaddq_f32(vminq_f32(v37, v39), v40);
      v42 = (int8x16_t)vaddq_f32(vminq_f32(v38, v39), v40);
      v43 = *((float32x4_t *)a2 + 86);
      v44 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vceqq_f32(v43, v31)), v31);
      v45 = (float32x4_t)vbslq_s8(v44, (int8x16_t)v35, v41);
      v46 = (float32x4_t)vbslq_s8(v44, (int8x16_t)v35, v42);
      v47 = *((int8x16_t *)a2 + 19);
      v48 = *((float32x4_t *)a2 + 20);
      v49 = (float32x4_t)vorrq_s8(vandq_s8(v47, (int8x16_t)v45), (int8x16_t)v35);
      v50 = (float32x4_t)vorrq_s8(vandq_s8(v47, (int8x16_t)v46), (int8x16_t)v35);
      v51 = *((int8x16_t *)a2 + 21);
      v52 = *((float32x4_t *)a2 + 22);
      v53 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v46, 0x17uLL)), (float32x4_t)vandq_s8(v51, (int8x16_t)vcgtq_f32(v48, v46)));
      v54 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v45, 0x17uLL)), (float32x4_t)vandq_s8(v51, (int8x16_t)vcgtq_f32(v48, v45))), v52);
      v55 = *((float32x4_t *)a2 + 23);
      v56 = *((float32x4_t *)a2 + 24);
      v57 = vsubq_f32(v53, v52);
      v58 = (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v49, v55));
      v59 = (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v50, v55));
      v60 = vaddq_f32(v54, v58);
      v61 = vsubq_f32(vsubq_f32(v49, v35), vmulq_f32(vmulq_f32(v56, v58), v49));
      v62 = vsubq_f32(vsubq_f32(v50, v35), vmulq_f32(vmulq_f32(v56, v59), v50));
      v63 = vmulq_f32(v61, v61);
      v64 = *((float32x4_t *)a2 + 37);
      v65 = *((float32x4_t *)a2 + 38);
      v66 = *((float32x4_t *)a2 + 39);
      v67 = *((float32x4_t *)a2 + 40);
      v68 = vaddq_f32(v64, vmulq_f32(v65, v61));
      v69 = vaddq_f32(v66, vmulq_f32(v67, v61));
      v70 = vaddq_f32(v66, vmulq_f32(v67, v62));
      v71 = vaddq_f32(v64, vmulq_f32(v65, v62));
      v72 = *((float32x4_t *)a2 + 41);
      v73 = *((float32x4_t *)a2 + 42);
      v74 = vaddq_f32(v72, vmulq_f32(v73, v61));
      v75 = vaddq_f32(v72, vmulq_f32(v73, v62));
      v76 = vmulq_f32(v62, v62);
      v77 = vaddq_f32(v57, v59);
      v78 = vaddq_f32(v74, vmulq_f32(v63, vaddq_f32(v68, vmulq_f32(v63, v69))));
      v79 = vaddq_f32(v75, vmulq_f32(v76, vaddq_f32(v71, vmulq_f32(v76, v70))));
      v80 = *((float32x4_t *)a2 + 43);
      v81 = *((float32x4_t *)a2 + 44);
      v82 = vmulq_f32(v43, vaddq_f32(v60, vmulq_f32(v61, vaddq_f32(v80, vmulq_f32(v61, v78)))));
      v83 = vmulq_f32(v43, vaddq_f32(v77, vmulq_f32(v62, vaddq_f32(v80, vmulq_f32(v62, v79)))));
      v84 = *((float32x4_t *)a2 + 29);
      v85 = vmaxq_f32(v82, v84);
      v86 = vmaxq_f32(v83, v84);
      v87 = vcvtq_f32_s32(vcvtq_s32_f32(v85));
      v88 = vcvtq_f32_s32(vcvtq_s32_f32(v86));
      v89 = vsubq_f32(v87, (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v87, v85)));
      v90 = vsubq_f32(v88, (float32x4_t)vandq_s8((int8x16_t)v35, (int8x16_t)vcgtq_f32(v88, v86)));
      v91 = vsubq_f32(v85, v89);
      v92 = vsubq_f32(v86, v90);
      v93 = *((float32x4_t *)a2 + 45);
      v94 = *((float32x4_t *)a2 + 46);
      v95 = *((float32x4_t *)a2 + 47);
      v96 = *((float32x4_t *)a2 + 48);
      v97 = *((int32x4_t *)a2 + 33);
      v98 = vmulq_f32(vaddq_f32(v35, vmulq_f32(v91, vaddq_f32(v96, vmulq_f32(v91, vaddq_f32(vaddq_f32(v94, vmulq_f32(v91, v95)), vmulq_f32(vmulq_f32(v91, v91), vaddq_f32(v81, vmulq_f32(v93, v91)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v97, vcvtq_s32_f32(v89)), 0x17uLL));
      v99 = vmulq_f32(vaddq_f32(v35, vmulq_f32(v92, vaddq_f32(v96, vmulq_f32(v92, vaddq_f32(vaddq_f32(v94, vmulq_f32(v95, v92)), vmulq_f32(vmulq_f32(v92, v92), vaddq_f32(v81, vmulq_f32(v93, v92)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v97, vcvtq_s32_f32(v90)), 0x17uLL));
      v100 = *((float32x4_t *)a2 + 96);
      v101 = (int8x16_t)vmulq_f32(v100, v98);
      v102 = *((float32x4_t *)a2 + 97);
      v103 = (int8x16_t)vmulq_f32(v100, v99);
      v104 = *((float32x4_t *)a2 + 98);
      v105 = (float32x4_t)vbslq_s8(v32, (int8x16_t)v28, (int8x16_t)v35);
      v106 = (float32x4_t)vbslq_s8(v33, (int8x16_t)v28, (int8x16_t)v35);
      v107 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v26, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v31, vsubq_f32(v37, v104)), (int8x16_t)vmulq_f32(v37, v102), v101), v105));
      v108 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v31, vsubq_f32(v38, v104)), (int8x16_t)vmulq_f32(v38, v102), v103), v106));
      v109 = (int8x16_t *)(v6 + v11);
      v109[-1] = vbslq_s8(v14, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v107, v107, 3));
      *v109 = vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v108, v108, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v110 = -v10;
    if (v110 >= v5)
      goto LABEL_3;
LABEL_10:
    v111 = 16 * v110;
    v112 = *(float32x4_t *)(v7 + v111);
    v113 = *((int8x16_t *)a2 + 15);
    v114 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v112, 3), *((float32x4_t *)a2 + 16));
    v115 = vrecpeq_f32(v114);
    v116 = vmulq_f32(v115, vrecpsq_f32(v115, v114));
    v117 = vmulq_f32(v112, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v116, vrecpsq_f32(v116, v114))), *((int8x16_t *)a2 + 3)));
    v118 = *((float32x4_t *)a2 + 82);
    v119 = (float32x4_t)vbslq_s8(v113, (int8x16_t)v117, (int8x16_t)vmaxq_f32(v117, v118));
    v120 = *((float32x4_t *)a2 + 75);
    v121 = (int8x16_t)vcgtq_f32(v120, v119);
    v122 = *((float32x4_t *)a2 + 5);
    v123 = vmulq_f32(v119, (float32x4_t)vbslq_s8(v121, *((int8x16_t *)a2 + 83), (int8x16_t)v122));
    v124 = *((float32x4_t *)a2 + 86);
    v125 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v122, (int8x16_t)vceqq_f32(v124, v120)), v120), (int8x16_t)v122, (int8x16_t)vaddq_f32(vminq_f32(v123, *((float32x4_t *)a2 + 90)), *((float32x4_t *)a2 + 95)));
    v126 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v125), (int8x16_t)v122);
    v127 = (float32x4_t)vandq_s8((int8x16_t)v122, (int8x16_t)vcgtq_f32(v126, *((float32x4_t *)a2 + 23)));
    v128 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v125, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v125))), *((float32x4_t *)a2 + 22)), v127);
    v129 = vsubq_f32(vsubq_f32(v126, v122), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v127), v126));
    v130 = vmulq_f32(v129, v129);
    v131 = vmaxq_f32(vmulq_f32(v124, vaddq_f32(v128, vmulq_f32(v129, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v129, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v129)), vmulq_f32(v130, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v129)), vmulq_f32(v130, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v129))))))))))),
             *((float32x4_t *)a2 + 29));
    v132 = vcvtq_f32_s32(vcvtq_s32_f32(v131));
    v133 = vsubq_f32(v132, (float32x4_t)vandq_s8((int8x16_t)v122, (int8x16_t)vcgtq_f32(v132, v131)));
    v134 = vsubq_f32(v131, v133);
    v135 = (float32x4_t)vbslq_s8(v113, (int8x16_t)v117, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v120, vsubq_f32(v123, *((float32x4_t *)a2 + 98))), (int8x16_t)vmulq_f32(v123, *((float32x4_t *)a2 + 97)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 96), vmulq_f32(vaddq_f32(v122, vmulq_f32(v134, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v134,
                                                                             vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v134)), vmulq_f32(vmulq_f32(v134, v134), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v134)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v133)), 0x17uLL)))), (float32x4_t)vbslq_s8(v121, (int8x16_t)v118, (int8x16_t)v122)));
    *(int8x16_t *)(v6 + v111) = vbslq_s8(v113, (int8x16_t)v117, (int8x16_t)vmulq_laneq_f32(v135, v135, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getsrgb_fast_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t *v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  int8x16_t *v55;
  int8x16_t *v56;
  float32x4_t v57;
  int8x16_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  int8x16_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v64 = 0;
        v65 = 16 * v8;
        v66 = 16 * v7;
        v67 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v68 = 0;
          do
          {
            v69 = *((int8x16_t *)a2 + 15);
            v70 = vmulq_f32(v5[v68 / 0x10], (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5[v68 / 0x10], 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v71 = vminq_f32(vmaxq_f32(v70, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v72 = vmulq_f32(v71, *((float32x4_t *)a2 + 99));
            v73 = vaddq_f32(v72, vmulq_f32(v71, vsubq_f32(v71, v72)));
            v74 = (float32x4_t)vbslq_s8(v69, (int8x16_t)v70, (int8x16_t)vmulq_f32(vminq_f32(vrsqrteq_f32(v73), *((float32x4_t *)a2 + 73)), v73));
            v6[v68 / 0x10] = vbslq_s8(v69, (int8x16_t)v70, (int8x16_t)vmulq_laneq_f32(v74, v74, 3));
            v68 += 16;
          }
          while (v67 != v68);
          ++v64;
          v5 = (float32x4_t *)((char *)v5 + v65);
          v6 = (int8x16_t *)((char *)v6 + v66);
        }
        while (v64 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v5[v17 - 2];
          v19 = v5[v17 - 1];
          v20 = v5[v17];
          v21 = v5[v17 + 1];
          v23 = *((int8x16_t *)a2 + 15);
          v22 = *((float32x4_t *)a2 + 16);
          v24 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 3), v22));
          v25 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3), v22));
          v26 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 3), v22));
          v27 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 3), v22));
          v28 = *((int8x16_t *)a2 + 17);
          v29 = *((int8x16_t *)a2 + 3);
          v30 = vmulq_f32(v18, (float32x4_t)vorrq_s8(vandq_s8(v28, v24), v29));
          v31 = vmulq_f32(v19, (float32x4_t)vorrq_s8(vandq_s8(v28, v25), v29));
          v32 = vmulq_f32(v20, (float32x4_t)vorrq_s8(vandq_s8(v28, v26), v29));
          v33 = vmulq_f32(v21, (float32x4_t)vorrq_s8(vandq_s8(v28, v27), v29));
          v34 = *((float32x4_t *)a2 + 75);
          v35 = *((float32x4_t *)a2 + 5);
          v36 = vminq_f32(vmaxq_f32(v30, v34), v35);
          v37 = vminq_f32(vmaxq_f32(v31, v34), v35);
          v38 = vminq_f32(vmaxq_f32(v32, v34), v35);
          v39 = vminq_f32(vmaxq_f32(v33, v34), v35);
          v40 = *((float32x4_t *)a2 + 99);
          v41 = vmulq_f32(v36, v40);
          v42 = vmulq_f32(v37, v40);
          v43 = vmulq_f32(v38, v40);
          v44 = vmulq_f32(v39, v40);
          v45 = vaddq_f32(v41, vmulq_f32(v36, vsubq_f32(v36, v41)));
          v46 = vaddq_f32(v42, vmulq_f32(v37, vsubq_f32(v37, v42)));
          v47 = vaddq_f32(v43, vmulq_f32(v38, vsubq_f32(v38, v43)));
          v48 = vaddq_f32(v44, vmulq_f32(v39, vsubq_f32(v39, v44)));
          v49 = v16;
          v50 = *((float32x4_t *)a2 + 73);
          v51 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v30, (int8x16_t)vmulq_f32(v45, vminq_f32(vrsqrteq_f32(v45), v50)));
          v52 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v31, (int8x16_t)vmulq_f32(v46, vminq_f32(vrsqrteq_f32(v46), v50)));
          v53 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v32, (int8x16_t)vmulq_f32(v47, vminq_f32(vrsqrteq_f32(v47), v50)));
          v54 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v33, (int8x16_t)vmulq_f32(v48, vminq_f32(vrsqrteq_f32(v48), v50)));
          v55 = v15;
          v56 = &v6[v17];
          v14 += 4;
          v56[-2] = vbslq_s8(v23, (int8x16_t)v30, (int8x16_t)vmulq_laneq_f32(v51, v51, 3));
          v56[-1] = vbslq_s8(v23, (int8x16_t)v31, (int8x16_t)vmulq_laneq_f32(v52, v52, 3));
          *v56 = vbslq_s8(v23, (int8x16_t)v32, (int8x16_t)vmulq_laneq_f32(v53, v53, 3));
          v56[1] = vbslq_s8(v23, (int8x16_t)v33, (int8x16_t)vmulq_laneq_f32(v54, v54, 3));
          v17 += 4;
          v16 += 4;
          v15 = v55 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v57 = *v49++;
            v58 = *((int8x16_t *)a2 + 15);
            v59 = vmulq_f32(v57, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v60 = vminq_f32(vmaxq_f32(v59, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v61 = vmulq_f32(v60, *((float32x4_t *)a2 + 99));
            v62 = vaddq_f32(v61, vmulq_f32(v60, vsubq_f32(v60, v61)));
            v63 = (float32x4_t)vbslq_s8(v58, (int8x16_t)v59, (int8x16_t)vmulq_f32(vminq_f32(vrsqrteq_f32(v62), *((float32x4_t *)a2 + 73)), v62));
            *v55++ = vbslq_s8(v58, (int8x16_t)v59, (int8x16_t)vmulq_laneq_f32(v63, v63, 3));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getsrgb_fixed_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int8x16_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  int8x16_t *v85;
  uint64_t v86;
  int8x16_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v86) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v17 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15));
      v18 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15));
      v19 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v15));
      v21 = *((int8x16_t *)a2 + 17);
      v20 = *((float32x4_t *)a2 + 18);
      v22 = (int8x16_t)vmulq_f32(v19, v20);
      v23 = vandq_s8(v21, (int8x16_t)vmulq_f32(v17, v20));
      v24 = vandq_s8(v21, (int8x16_t)vmulq_f32(v18, v20));
      v25 = *((int8x16_t *)a2 + 3);
      v26 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v23, v25));
      v27 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v24, v25));
      v28 = vmulq_f32(v14, (float32x4_t)vorrq_s8(vandq_s8(v21, v22), v25));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = *((float32x4_t *)a2 + 6);
      v32 = vminq_f32(vmaxq_f32(v26, v29), v30);
      v33 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v34 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v35 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)v32));
      v36 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)v33));
      v37 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)v34));
      v38 = vcvtq_f32_s32(vcvtq_s32_f32(v35));
      v39 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
      v40 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
      v41 = *((float32x4_t *)a2 + 7);
      v42 = *((float32x4_t *)a2 + 8);
      v43 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v35, v38), v41));
      v44 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v36, v39), v41));
      v45 = vrsqrteq_f32(vaddq_f32(v41, vsubq_f32(v37, v40)));
      v46 = vaddq_f32(v42, v38);
      v47 = vaddq_f32(v42, v39);
      v48 = vaddq_f32(v42, v40);
      v49 = *((float32x4_t *)a2 + 9);
      v50 = *((float32x4_t *)a2 + 10);
      v51 = vsubq_f32(v46, vmulq_f32(v43, v49));
      v52 = *((float32x4_t *)a2 + 100);
      v53 = vmulq_f32(v52, v51);
      v54 = vmulq_f32(v52, vsubq_f32(v47, vmulq_f32(v44, v49)));
      v55 = vmulq_f32(v52, vsubq_f32(v48, vmulq_f32(v45, v49)));
      v56 = vcvtq_f32_s32(vcvtq_s32_f32(v53));
      v57 = vcvtq_f32_s32(vcvtq_s32_f32(v54));
      v58 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      v59 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v56, v53)));
      v60 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v57, v54)));
      v61 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v58, v55)));
      v62 = *((float32x4_t *)a2 + 11);
      v63 = *((float32x4_t *)a2 + 12);
      v64 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v53, v59))), v63);
      v65 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v54, v60))), v63);
      v66 = vmulq_f32(vrecpeq_f32(vsubq_f32(v62, vsubq_f32(v55, v61))), v63);
      v67 = vaddq_f32(vaddq_f32(v50, v61), vmulq_f32(v66, v66));
      v68 = vmaxq_f32(vaddq_f32(vaddq_f32(v50, v59), vmulq_f32(v64, v64)), v29);
      v69 = vmaxq_f32(vaddq_f32(vaddq_f32(v50, v60), vmulq_f32(v65, v65)), v29);
      v70 = *((float32x4_t *)a2 + 13);
      v71 = *((float32x4_t *)a2 + 14);
      v72 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v68, v70), v71));
      v73 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v69, v70), v71));
      v74 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v67, v29), v70), v71));
      v75 = *((float32x4_t *)a2 + 101);
      v76 = *((float32x4_t *)a2 + 102);
      v77 = (int8x16_t)vaddq_f32(v75, vmulq_f32(v76, v72));
      v78 = vmulq_f32(v76, v73);
      v79 = vmulq_f32(v76, v74);
      v80 = *((float32x4_t *)a2 + 103);
      v81 = *((float32x4_t *)a2 + 104);
      v82 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v26, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v81)), (int8x16_t)vmulq_f32(v32, v80), v77));
      v83 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v27, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v33, v81)), (int8x16_t)vmulq_f32(v33, v80), (int8x16_t)vaddq_f32(v75, v78)));
      v84 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v28, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v34, v81)), (int8x16_t)vmulq_f32(v34, v80), (int8x16_t)vaddq_f32(v75, v79)));
      v85 = (int8x16_t *)(v6 + v10);
      *v85 = vbslq_s8(v16, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v82, v82, 3));
      v85[1] = vbslq_s8(v16, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v83, v83, 3));
      v85[2] = vbslq_s8(v16, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v84, v84, 3));
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v86) = -v11;
    if ((int)v86 >= v5)
      goto LABEL_3;
LABEL_10:
    v86 = v86;
    do
    {
      v87 = *((int8x16_t *)a2 + 15);
      v88 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v86), (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v7 + 16 * v86), 3), *((float32x4_t *)a2 + 16))), *((float32x4_t *)a2 + 18))), *((int8x16_t *)a2 + 3)));
      v89 = *((float32x4_t *)a2 + 75);
      v90 = *((float32x4_t *)a2 + 5);
      v91 = vminq_f32(vmaxq_f32(v88, v89), v90);
      v92 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)v91));
      v93 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
      v94 = vmulq_f32(*((float32x4_t *)a2 + 100), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v93), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v92, v93))), *((float32x4_t *)a2 + 9))));
      v95 = vcvtq_f32_s32(vcvtq_s32_f32(v94));
      v96 = vsubq_f32(v95, (float32x4_t)vandq_s8((int8x16_t)v90, (int8x16_t)vcgtq_f32(v95, v94)));
      v97 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v94, v96))), *((float32x4_t *)a2 + 12));
      v98 = (float32x4_t)vbslq_s8(v87, (int8x16_t)v88, vbslq_s8((int8x16_t)vcgtq_f32(v89, vsubq_f32(v91, *((float32x4_t *)a2 + 104))), (int8x16_t)vmulq_f32(v91, *((float32x4_t *)a2 + 103)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 101), vmulq_f32(*((float32x4_t *)a2 + 102), (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v96), vmulq_f32(v97, v97)), v89), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14)))))));
      *(int8x16_t *)(v6 + 16 * v86++) = vbslq_s8(v87, (int8x16_t)v88, (int8x16_t)vmulq_laneq_f32(v98, v98, 3));
    }
    while (v86 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getsrgb_nice_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t v95;
  float32x4_t v96;
  int8x16_t v97;
  int8x16_t v98;
  float32x4_t v99;
  int8x16_t v100;
  int8x16_t v101;
  float32x4_t v102;
  float32x4_t v103;
  int8x16_t *v104;
  int v105;
  uint64_t v106;
  float32x4_t v107;
  int8x16_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v105 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = *((int8x16_t *)a2 + 17);
      v24 = vandq_s8(v23, v22);
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v32 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v33 = *((float32x4_t *)a2 + 100);
      v34 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vceqq_f32(v33, v29)), v29);
      v35 = (float32x4_t)vbslq_s8(v34, (int8x16_t)v30, (int8x16_t)v31);
      v36 = (float32x4_t)vbslq_s8(v34, (int8x16_t)v30, (int8x16_t)v32);
      v37 = *((int8x16_t *)a2 + 19);
      v38 = *((float32x4_t *)a2 + 20);
      v39 = (float32x4_t)vorrq_s8(vandq_s8(v37, (int8x16_t)v35), (int8x16_t)v30);
      v40 = (float32x4_t)vorrq_s8(vandq_s8(v37, (int8x16_t)v36), (int8x16_t)v30);
      v41 = *((int8x16_t *)a2 + 21);
      v42 = *((float32x4_t *)a2 + 22);
      v43 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v36, 0x17uLL)), (float32x4_t)vandq_s8(v41, (int8x16_t)vcgtq_f32(v38, v36)));
      v44 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v35, 0x17uLL)), (float32x4_t)vandq_s8(v41, (int8x16_t)vcgtq_f32(v38, v35))), v42);
      v45 = *((float32x4_t *)a2 + 23);
      v46 = *((float32x4_t *)a2 + 24);
      v47 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v39, v45));
      v48 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v40, v45));
      v49 = vaddq_f32(v44, v47);
      v50 = vaddq_f32(vsubq_f32(v43, v42), v48);
      v51 = vsubq_f32(vsubq_f32(v39, v30), vmulq_f32(vmulq_f32(v46, v47), v39));
      v52 = vsubq_f32(vsubq_f32(v40, v30), vmulq_f32(vmulq_f32(v46, v48), v40));
      v53 = vmulq_f32(v51, v51);
      v54 = *((float32x4_t *)a2 + 37);
      v55 = *((float32x4_t *)a2 + 38);
      v56 = vaddq_f32(v54, vmulq_f32(v55, v51));
      v57 = vaddq_f32(v54, vmulq_f32(v55, v52));
      v58 = *((float32x4_t *)a2 + 39);
      v59 = *((float32x4_t *)a2 + 40);
      v60 = vaddq_f32(v58, vmulq_f32(v59, v51));
      v61 = vaddq_f32(v58, vmulq_f32(v59, v52));
      v62 = *((float32x4_t *)a2 + 41);
      v63 = *((float32x4_t *)a2 + 42);
      v64 = vaddq_f32(v62, vmulq_f32(v63, v51));
      v65 = vaddq_f32(v62, vmulq_f32(v63, v52));
      v66 = vmulq_f32(v52, v52);
      v67 = vaddq_f32(v65, vmulq_f32(v66, vaddq_f32(v57, vmulq_f32(v66, v61))));
      v68 = vmulq_f32(v51, vaddq_f32(v64, vmulq_f32(v53, vaddq_f32(v56, vmulq_f32(v53, v60)))));
      v69 = *((float32x4_t *)a2 + 43);
      v70 = *((float32x4_t *)a2 + 44);
      v71 = vaddq_f32(v50, vmulq_f32(v52, vaddq_f32(v69, vmulq_f32(v52, v67))));
      v72 = vmulq_f32(v33, vaddq_f32(v49, vmulq_f32(v51, vaddq_f32(v69, v68))));
      v73 = *((float32x4_t *)a2 + 29);
      v74 = vmulq_f32(v33, v71);
      v75 = vmaxq_f32(v72, v73);
      v76 = vmaxq_f32(v74, v73);
      v77 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v76));
      v79 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v77, v75)));
      v80 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v78, v76)));
      v81 = vsubq_f32(v75, v79);
      v82 = vsubq_f32(v76, v80);
      v83 = *((float32x4_t *)a2 + 45);
      v84 = *((float32x4_t *)a2 + 46);
      v85 = *((float32x4_t *)a2 + 47);
      v86 = *((float32x4_t *)a2 + 48);
      v87 = vaddq_f32(v30, vmulq_f32(v81, vaddq_f32(v86, vmulq_f32(v81, vaddq_f32(vaddq_f32(v84, vmulq_f32(v81, v85)), vmulq_f32(vmulq_f32(v81, v81), vaddq_f32(v70, vmulq_f32(v83, v81))))))));
      v88 = vaddq_f32(v30, vmulq_f32(v82, vaddq_f32(v86, vmulq_f32(v82, vaddq_f32(vaddq_f32(v84, vmulq_f32(v85, v82)), vmulq_f32(vmulq_f32(v82, v82), vaddq_f32(v70, vmulq_f32(v83, v82))))))));
      v89 = *((int32x4_t *)a2 + 33);
      v90 = vmulq_f32(v87, (float32x4_t)vshlq_n_s32(vaddq_s32(v89, vcvtq_s32_f32(v79)), 0x17uLL));
      v91 = vmulq_f32(v88, (float32x4_t)vshlq_n_s32(vaddq_s32(v89, vcvtq_s32_f32(v80)), 0x17uLL));
      v92 = *((float32x4_t *)a2 + 101);
      v93 = *((float32x4_t *)a2 + 102);
      v94 = vmulq_f32(v93, v91);
      v95 = (int8x16_t)vaddq_f32(v92, vmulq_f32(v93, v90));
      v96 = *((float32x4_t *)a2 + 103);
      v97 = (int8x16_t)vmulq_f32(v31, v96);
      v98 = (int8x16_t)vmulq_f32(v32, v96);
      v99 = *((float32x4_t *)a2 + 104);
      v100 = (int8x16_t)vcgtq_f32(v29, vsubq_f32(v31, v99));
      v101 = (int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v99));
      v102 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, vbslq_s8(v100, v97, v95));
      v103 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, vbslq_s8(v101, v98, (int8x16_t)vaddq_f32(v92, v94)));
      v104 = (int8x16_t *)(v6 + v11);
      v104[-1] = vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v102, v102, 3));
      *v104 = vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v103, v103, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v105 = -v10;
    if (v105 >= v5)
      goto LABEL_3;
LABEL_10:
    v106 = 16 * v105;
    v107 = *(float32x4_t *)(v7 + v106);
    v108 = *((int8x16_t *)a2 + 15);
    v109 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3), *((float32x4_t *)a2 + 16));
    v110 = vrecpeq_f32(v109);
    v111 = vmulq_f32(v110, vrecpsq_f32(v110, v109));
    v112 = vmulq_f32(v107, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v111, vrecpsq_f32(v111, v109))), *((int8x16_t *)a2 + 3)));
    v113 = *((float32x4_t *)a2 + 75);
    v114 = *((float32x4_t *)a2 + 5);
    v115 = vminq_f32(vmaxq_f32(v112, v113), v114);
    v116 = *((float32x4_t *)a2 + 100);
    v117 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v114, (int8x16_t)vceqq_f32(v116, v113)), v113), (int8x16_t)v114, (int8x16_t)v115);
    v118 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v117), (int8x16_t)v114);
    v119 = (float32x4_t)vandq_s8((int8x16_t)v114, (int8x16_t)vcgtq_f32(v118, *((float32x4_t *)a2 + 23)));
    v120 = vsubq_f32(vsubq_f32(v118, v114), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v119), v118));
    v121 = vmulq_f32(v120, v120);
    v122 = vmaxq_f32(vmulq_f32(v116, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v117, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v117))), *((float32x4_t *)a2 + 22)), v119), vmulq_f32(v120, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v120, vaddq_f32(
                         vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v120)),
                         vmulq_f32(v121, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v120)), vmulq_f32(v121, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v120))))))))))), *((float32x4_t *)a2 + 29));
    v123 = vcvtq_f32_s32(vcvtq_s32_f32(v122));
    v124 = vsubq_f32(v123, (float32x4_t)vandq_s8((int8x16_t)v114, (int8x16_t)vcgtq_f32(v123, v122)));
    v125 = vsubq_f32(v122, v124);
    v126 = (float32x4_t)vbslq_s8(v108, (int8x16_t)v112, vbslq_s8((int8x16_t)vcgtq_f32(v113, vsubq_f32(v115, *((float32x4_t *)a2 + 104))), (int8x16_t)vmulq_f32(v115, *((float32x4_t *)a2 + 103)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 101), vmulq_f32(*((float32x4_t *)a2 + 102), vmulq_f32(vaddq_f32(v114, vmulq_f32(v125, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v125, vaddq_f32(
                                                       vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v125)), vmulq_f32(vmulq_f32(v125, v125), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v125)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v124)), 0x17uLL))))));
    *(int8x16_t *)(v6 + v106) = vbslq_s8(v108, (int8x16_t)v112, (int8x16_t)vmulq_laneq_f32(v126, v126, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getsrgb_half_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int8x16_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int8x16_t *v78;
  int v79;
  uint64_t v80;
  float32x4_t v81;
  int8x16_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v79 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23));
      v26 = *((float32x4_t *)a2 + 75);
      v27 = *((float32x4_t *)a2 + 5);
      v28 = vminq_f32(vmaxq_f32(v24, v26), v27);
      v29 = vminq_f32(vmaxq_f32(v25, v26), v27);
      v30 = *((int8x16_t *)a2 + 19);
      v31 = *((float32x4_t *)a2 + 20);
      v32 = (float32x4_t)vorrq_s8(vandq_s8(v30, (int8x16_t)v28), (int8x16_t)v27);
      v33 = *((int8x16_t *)a2 + 21);
      v34 = *((float32x4_t *)a2 + 22);
      v35 = (float32x4_t)vorrq_s8(vandq_s8(v30, (int8x16_t)v29), (int8x16_t)v27);
      v36 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x17uLL)), (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v31, v28))), v34);
      v37 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x17uLL)), (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v31, v29))), v34);
      v38 = *((float32x4_t *)a2 + 23);
      v39 = *((float32x4_t *)a2 + 24);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v32, v38));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v35, v38));
      v42 = vaddq_f32(v37, v41);
      v43 = vsubq_f32(vsubq_f32(v32, v27), vmulq_f32(vmulq_f32(v39, v40), v32));
      v44 = vsubq_f32(vsubq_f32(v35, v27), vmulq_f32(vmulq_f32(v39, v41), v35));
      v45 = *((float32x4_t *)a2 + 25);
      v46 = *((float32x4_t *)a2 + 26);
      v47 = *((float32x4_t *)a2 + 27);
      v48 = *((float32x4_t *)a2 + 28);
      v49 = vaddq_f32(v42, vmulq_f32(v44, vaddq_f32(vaddq_f32(v47, vmulq_f32(v44, v48)), vmulq_f32(vmulq_f32(v44, v44), vaddq_f32(v45, vmulq_f32(v46, v44))))));
      v50 = *((float32x4_t *)a2 + 100);
      v51 = vmulq_f32(v50, vaddq_f32(vaddq_f32(v36, v40), vmulq_f32(v43, vaddq_f32(vaddq_f32(v47, vmulq_f32(v43, v48)), vmulq_f32(vmulq_f32(v43, v43), vaddq_f32(v45, vmulq_f32(v46, v43)))))));
      v52 = vmulq_f32(v50, v49);
      v53 = *((float32x4_t *)a2 + 29);
      v54 = *((float32x4_t *)a2 + 30);
      v55 = vmaxq_f32(v51, v53);
      v56 = vmaxq_f32(v52, v53);
      v57 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      v58 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
      v59 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v57, v55)));
      v60 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v58, v56)));
      v61 = vsubq_f32(v55, v59);
      v62 = vsubq_f32(v56, v60);
      v63 = *((float32x4_t *)a2 + 31);
      v64 = *((float32x4_t *)a2 + 32);
      v65 = vaddq_f32(v27, vmulq_f32(v61, vaddq_f32(v64, vmulq_f32(v61, vaddq_f32(v54, vmulq_f32(v63, v61))))));
      v66 = vaddq_f32(v27, vmulq_f32(v62, vaddq_f32(v64, vmulq_f32(v62, vaddq_f32(v54, vmulq_f32(v63, v62))))));
      v67 = *((int32x4_t *)a2 + 33);
      v68 = vmulq_f32(v65, (float32x4_t)vshlq_n_s32(vaddq_s32(v67, vcvtq_s32_f32(v59)), 0x17uLL));
      v69 = vmulq_f32(v66, (float32x4_t)vshlq_n_s32(vaddq_s32(v67, vcvtq_s32_f32(v60)), 0x17uLL));
      v70 = *((float32x4_t *)a2 + 101);
      v71 = *((float32x4_t *)a2 + 102);
      v72 = vmulq_f32(v71, v69);
      v73 = (int8x16_t)vaddq_f32(v70, vmulq_f32(v71, v68));
      v74 = *((float32x4_t *)a2 + 103);
      v75 = *((float32x4_t *)a2 + 104);
      v76 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v24, vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v28, v75)), (int8x16_t)vmulq_f32(v28, v74), v73));
      v77 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v25, vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v29, v75)), (int8x16_t)vmulq_f32(v29, v74), (int8x16_t)vaddq_f32(v70, v72)));
      v78 = (int8x16_t *)(v6 + v11);
      v78[-1] = vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v76, v76, 3));
      *v78 = vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v77, v77, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v79 = -v10;
    if (v79 >= v5)
      goto LABEL_3;
LABEL_10:
    v80 = 16 * v79;
    v81 = *(float32x4_t *)(v7 + v80);
    v82 = *((int8x16_t *)a2 + 15);
    v83 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v81, 3), *((float32x4_t *)a2 + 16));
    v84 = vmulq_f32(vrecpeq_f32(v83), *((float32x4_t *)a2 + 18));
    v85 = vmulq_f32(v81, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v84, vrecpsq_f32(v84, v83))), *((int8x16_t *)a2 + 3)));
    v86 = *((float32x4_t *)a2 + 75);
    v87 = *((float32x4_t *)a2 + 5);
    v88 = vminq_f32(vmaxq_f32(v85, v86), v87);
    v89 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v88), (int8x16_t)v87);
    v90 = (float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vcgtq_f32(v89, *((float32x4_t *)a2 + 23)));
    v91 = vsubq_f32(vsubq_f32(v89, v87), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v90), v89));
    v92 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 100), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v88, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v88))), *((float32x4_t *)a2 + 22)), v90), vmulq_f32(v91, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v91, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v91, v91), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v91))))))),
            *((float32x4_t *)a2 + 29));
    v93 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
    v94 = vsubq_f32(v93, (float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vcgtq_f32(v93, v92)));
    v95 = vsubq_f32(v92, v94);
    v96 = (float32x4_t)vbslq_s8(v82, (int8x16_t)v85, vbslq_s8((int8x16_t)vcgtq_f32(v86, vsubq_f32(v88, *((float32x4_t *)a2 + 104))), (int8x16_t)vmulq_f32(v88, *((float32x4_t *)a2 + 103)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 101), vmulq_f32(*((float32x4_t *)a2 + 102), vmulq_f32(vaddq_f32(v87, vmulq_f32(v95, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v95, vaddq_f32(
                                                      *((float32x4_t *)a2 + 30),
                                                      vmulq_f32(*((float32x4_t *)a2 + 31), v95)))))),
                                            (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v94)), 0x17uLL))))));
    *(int8x16_t *)(v6 + v80) = vbslq_s8(v82, (int8x16_t)v85, (int8x16_t)vmulq_laneq_f32(v96, v96, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getsrgb_halfTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  int32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  int8x16_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int8x16_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int8x16_t v86;
  float32x4_t v87;
  int8x16_t v88;
  int8x16_t v89;
  int8x16_t v90;
  float32x4_t v91;
  float32x4_t v92;
  int8x16_t *v93;
  int v94;
  uint64_t v95;
  float32x4_t v96;
  int8x16_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v94 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23);
      v25 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v26 = *((float32x4_t *)a2 + 105);
      v27 = vmulq_f32(v13, v24);
      v28 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmaxq_f32(v25, v26));
      v29 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmaxq_f32(v27, v26));
      v30 = *((float32x4_t *)a2 + 75);
      v31 = *((float32x4_t *)a2 + 5);
      v33 = *((int32x4_t *)a2 + 33);
      v32 = *((int8x16_t *)a2 + 34);
      v34 = vmulq_f32(v28, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v30, v28), v32, (int8x16_t)v31));
      v35 = vmulq_f32(v29, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v30, v29), v32, (int8x16_t)v31));
      v36 = *((float32x4_t *)a2 + 106);
      v37 = vminq_f32(v34, v36);
      v38 = *((int8x16_t *)a2 + 19);
      v39 = *((float32x4_t *)a2 + 20);
      v40 = vminq_f32(v35, v36);
      v41 = (float32x4_t)vorrq_s8(vandq_s8(v38, (int8x16_t)v37), (int8x16_t)v31);
      v42 = (float32x4_t)vorrq_s8(vandq_s8(v38, (int8x16_t)v40), (int8x16_t)v31);
      v43 = *((int8x16_t *)a2 + 21);
      v44 = *((float32x4_t *)a2 + 22);
      v45 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v40, 0x17uLL)), (float32x4_t)vandq_s8(v43, (int8x16_t)vcgtq_f32(v39, v40)));
      v46 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x17uLL)), (float32x4_t)vandq_s8(v43, (int8x16_t)vcgtq_f32(v39, v37))), v44);
      v47 = *((float32x4_t *)a2 + 23);
      v48 = *((float32x4_t *)a2 + 24);
      v49 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v41, v47));
      v50 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v42, v47));
      v51 = vaddq_f32(v46, v49);
      v52 = vaddq_f32(vsubq_f32(v45, v44), v50);
      v53 = vsubq_f32(vsubq_f32(v41, v31), vmulq_f32(vmulq_f32(v48, v49), v41));
      v54 = vsubq_f32(vsubq_f32(v42, v31), vmulq_f32(vmulq_f32(v48, v50), v42));
      v55 = *((float32x4_t *)a2 + 25);
      v56 = *((float32x4_t *)a2 + 26);
      v57 = vaddq_f32(v55, vmulq_f32(v56, v53));
      v58 = vaddq_f32(v55, vmulq_f32(v56, v54));
      v59 = *((float32x4_t *)a2 + 27);
      v60 = *((float32x4_t *)a2 + 28);
      v61 = vaddq_f32(v52, vmulq_f32(v54, vaddq_f32(vaddq_f32(v59, vmulq_f32(v54, v60)), vmulq_f32(vmulq_f32(v54, v54), v58))));
      v62 = *((float32x4_t *)a2 + 100);
      v63 = vmulq_f32(v62, vaddq_f32(v51, vmulq_f32(v53, vaddq_f32(vaddq_f32(v59, vmulq_f32(v53, v60)), vmulq_f32(vmulq_f32(v53, v53), v57)))));
      v64 = vmulq_f32(v62, v61);
      v65 = *((float32x4_t *)a2 + 29);
      v66 = *((float32x4_t *)a2 + 30);
      v67 = vmaxq_f32(v63, v65);
      v68 = vmaxq_f32(v64, v65);
      v69 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
      v70 = vcvtq_f32_s32(vcvtq_s32_f32(v68));
      v71 = vsubq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v69, v67)));
      v72 = vsubq_f32(v70, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v70, v68)));
      v73 = vsubq_f32(v67, v71);
      v74 = vsubq_f32(v68, v72);
      v75 = *((float32x4_t *)a2 + 31);
      v76 = *((float32x4_t *)a2 + 32);
      v77 = vaddq_f32(v31, vmulq_f32(v73, vaddq_f32(v76, vmulq_f32(v73, vaddq_f32(v66, vmulq_f32(v75, v73))))));
      v78 = vaddq_f32(v31, vmulq_f32(v74, vaddq_f32(v76, vmulq_f32(v74, vaddq_f32(v66, vmulq_f32(v75, v74))))));
      v79 = vmulq_f32(v77, (float32x4_t)vshlq_n_s32(vaddq_s32(v33, vcvtq_s32_f32(v71)), 0x17uLL));
      v80 = vmulq_f32(v78, (float32x4_t)vshlq_n_s32(vaddq_s32(v33, vcvtq_s32_f32(v72)), 0x17uLL));
      v81 = *((float32x4_t *)a2 + 101);
      v82 = *((float32x4_t *)a2 + 102);
      v83 = (int8x16_t)vaddq_f32(v81, vmulq_f32(v82, v79));
      v84 = vmulq_f32(v82, v80);
      v85 = *((float32x4_t *)a2 + 103);
      v86 = (int8x16_t)vmulq_f32(v34, v85);
      v87 = *((float32x4_t *)a2 + 104);
      v88 = (int8x16_t)vcgtq_f32(v30, vsubq_f32(v34, v87));
      v89 = vbslq_s8((int8x16_t)vcgtq_f32(v30, vsubq_f32(v35, v87)), (int8x16_t)vmulq_f32(v35, v85), (int8x16_t)vaddq_f32(v81, v84));
      v90 = *((int8x16_t *)a2 + 36);
      v91 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, veorq_s8(vandq_s8(v90, (int8x16_t)v28), vbslq_s8(v88, v86, v83)));
      v92 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, veorq_s8(vandq_s8(v90, (int8x16_t)v29), v89));
      v93 = (int8x16_t *)(v6 + v11);
      v93[-1] = vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v91, v91, 3));
      *v93 = vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v92, v92, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v94 = -v10;
    if (v94 >= v5)
      goto LABEL_3;
LABEL_10:
    v95 = 16 * v94;
    v96 = *(float32x4_t *)(v7 + v95);
    v97 = *((int8x16_t *)a2 + 15);
    v98 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v96, 3), *((float32x4_t *)a2 + 16));
    v99 = vmulq_f32(vrecpeq_f32(v98), *((float32x4_t *)a2 + 18));
    v100 = vmulq_f32(v96, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v99, vrecpsq_f32(v99, v98))), *((int8x16_t *)a2 + 3)));
    v101 = (float32x4_t)vbslq_s8(v97, (int8x16_t)v100, (int8x16_t)vmaxq_f32(v100, *((float32x4_t *)a2 + 105)));
    v102 = *((float32x4_t *)a2 + 75);
    v103 = *((float32x4_t *)a2 + 5);
    v104 = vmulq_f32(v101, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v102, v101), *((int8x16_t *)a2 + 34), (int8x16_t)v103));
    v105 = vminq_f32(v104, *((float32x4_t *)a2 + 106));
    v106 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v105), (int8x16_t)v103);
    v107 = (float32x4_t)vandq_s8((int8x16_t)v103, (int8x16_t)vcgtq_f32(v106, *((float32x4_t *)a2 + 23)));
    v108 = vsubq_f32(vsubq_f32(v106, v103), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v107), v106));
    v109 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 100), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v105, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v105))), *((float32x4_t *)a2 + 22)), v107), vmulq_f32(v108, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v108, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v108, v108), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v108))))))),
             *((float32x4_t *)a2 + 29));
    v110 = vcvtq_f32_s32(vcvtq_s32_f32(v109));
    v111 = vsubq_f32(v110, (float32x4_t)vandq_s8((int8x16_t)v103, (int8x16_t)vcgtq_f32(v110, v109)));
    v112 = vsubq_f32(v109, v111);
    v113 = (float32x4_t)vbslq_s8(v97, (int8x16_t)v100, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v101), vbslq_s8((int8x16_t)vcgtq_f32(v102, vsubq_f32(v104, *((float32x4_t *)a2 + 104))), (int8x16_t)vmulq_f32(v104, *((float32x4_t *)a2 + 103)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 101), vmulq_f32(*((float32x4_t *)a2 + 102), vmulq_f32(vaddq_f32(v103, vmulq_f32(v112, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(
                                                       v112,
                                                       vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v112)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v111)), 0x17uLL)))))));
    *(int8x16_t *)(v6 + v95) = vbslq_s8(v97, (int8x16_t)v100, (int8x16_t)vmulq_laneq_f32(v113, v113, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getsrgb_niceTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  int32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int8x16_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  int8x16_t v103;
  float32x4_t v104;
  float32x4_t v105;
  int8x16_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  int8x16_t *v110;
  int v111;
  uint64_t v112;
  float32x4_t v113;
  int8x16_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v111 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = *((int8x16_t *)a2 + 17);
      v24 = vandq_s8(v23, v22);
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 105);
      v30 = (int8x16_t)vmaxq_f32(v28, v29);
      v31 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmaxq_f32(v27, v29));
      v32 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v28, v30);
      v33 = *((float32x4_t *)a2 + 75);
      v34 = *((float32x4_t *)a2 + 5);
      v36 = *((int32x4_t *)a2 + 33);
      v35 = *((int8x16_t *)a2 + 34);
      v37 = vmulq_f32(v31, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v33, v31), v35, (int8x16_t)v34));
      v38 = vmulq_f32(v32, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v33, v32), v35, (int8x16_t)v34));
      v39 = *((float32x4_t *)a2 + 106);
      v40 = *((float32x4_t *)a2 + 100);
      v41 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vceqq_f32(v40, v33)), v33);
      v42 = (float32x4_t)vbslq_s8(v41, (int8x16_t)v34, (int8x16_t)vminq_f32(v37, v39));
      v43 = (float32x4_t)vbslq_s8(v41, (int8x16_t)v34, (int8x16_t)vminq_f32(v38, v39));
      v44 = *((int8x16_t *)a2 + 19);
      v45 = *((float32x4_t *)a2 + 20);
      v46 = (float32x4_t)vorrq_s8(vandq_s8(v44, (int8x16_t)v42), (int8x16_t)v34);
      v47 = *((int8x16_t *)a2 + 21);
      v48 = *((float32x4_t *)a2 + 22);
      v49 = (float32x4_t)vorrq_s8(vandq_s8(v44, (int8x16_t)v43), (int8x16_t)v34);
      v50 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v43, 0x17uLL)), (float32x4_t)vandq_s8(v47, (int8x16_t)vcgtq_f32(v45, v43)));
      v51 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v42, 0x17uLL)), (float32x4_t)vandq_s8(v47, (int8x16_t)vcgtq_f32(v45, v42))), v48);
      v52 = *((float32x4_t *)a2 + 23);
      v53 = *((float32x4_t *)a2 + 24);
      v54 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v46, v52));
      v55 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v49, v52));
      v56 = vaddq_f32(v51, v54);
      v57 = vmulq_f32(v53, v54);
      v58 = vmulq_f32(vmulq_f32(v53, v55), v49);
      v59 = vaddq_f32(vsubq_f32(v50, v48), v55);
      v60 = vsubq_f32(vsubq_f32(v46, v34), vmulq_f32(v57, v46));
      v61 = vsubq_f32(vsubq_f32(v49, v34), v58);
      v62 = *((float32x4_t *)a2 + 38);
      v63 = *((float32x4_t *)a2 + 39);
      v64 = vmulq_f32(v60, v60);
      v66 = *((int8x16_t *)a2 + 36);
      v65 = *((float32x4_t *)a2 + 37);
      v67 = *((float32x4_t *)a2 + 40);
      v68 = *((float32x4_t *)a2 + 41);
      v69 = vaddq_f32(v65, vmulq_f32(v62, v60));
      v70 = vaddq_f32(v63, vmulq_f32(v67, v60));
      v71 = vaddq_f32(v63, vmulq_f32(v67, v61));
      v72 = vaddq_f32(v65, vmulq_f32(v62, v61));
      v73 = *((float32x4_t *)a2 + 42);
      v74 = *((float32x4_t *)a2 + 43);
      v75 = vaddq_f32(v68, vmulq_f32(v73, v60));
      v76 = vaddq_f32(v68, vmulq_f32(v73, v61));
      v77 = vmulq_f32(v61, v61);
      v78 = vmulq_f32(v40, vaddq_f32(v56, vmulq_f32(v60, vaddq_f32(v74, vmulq_f32(v60, vaddq_f32(v75, vmulq_f32(v64, vaddq_f32(v69, vmulq_f32(v64, v70)))))))));
      v79 = vmulq_f32(v40, vaddq_f32(v59, vmulq_f32(v61, vaddq_f32(v74, vmulq_f32(v61, vaddq_f32(v76, vmulq_f32(v77, vaddq_f32(v72, vmulq_f32(v77, v71)))))))));
      v80 = *((float32x4_t *)a2 + 29);
      v81 = vmaxq_f32(v78, v80);
      v82 = vmaxq_f32(v79, v80);
      v83 = vcvtq_f32_s32(vcvtq_s32_f32(v81));
      v84 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
      v85 = vsubq_f32(v83, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v83, v81)));
      v86 = vsubq_f32(v84, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v84, v82)));
      v87 = vsubq_f32(v81, v85);
      v88 = vsubq_f32(v82, v86);
      v89 = *((float32x4_t *)a2 + 44);
      v90 = *((float32x4_t *)a2 + 45);
      v91 = vaddq_f32(v89, vmulq_f32(v90, v87));
      v92 = vaddq_f32(v89, vmulq_f32(v90, v88));
      v93 = *((float32x4_t *)a2 + 46);
      v94 = *((float32x4_t *)a2 + 47);
      v95 = vaddq_f32(vaddq_f32(v93, vmulq_f32(v94, v88)), vmulq_f32(vmulq_f32(v88, v88), v92));
      v96 = *((float32x4_t *)a2 + 48);
      v97 = vaddq_f32(v34, vmulq_f32(v87, vaddq_f32(v96, vmulq_f32(v87, vaddq_f32(vaddq_f32(v93, vmulq_f32(v87, v94)), vmulq_f32(vmulq_f32(v87, v87), v91))))));
      v98 = vaddq_f32(v34, vmulq_f32(v88, vaddq_f32(v96, vmulq_f32(v88, v95))));
      v99 = vmulq_f32(v97, (float32x4_t)vshlq_n_s32(vaddq_s32(v36, vcvtq_s32_f32(v85)), 0x17uLL));
      v100 = vmulq_f32(v98, (float32x4_t)vshlq_n_s32(vaddq_s32(v36, vcvtq_s32_f32(v86)), 0x17uLL));
      v101 = *((float32x4_t *)a2 + 101);
      v102 = *((float32x4_t *)a2 + 102);
      v103 = (int8x16_t)vaddq_f32(v101, vmulq_f32(v102, v99));
      v104 = vmulq_f32(v102, v100);
      v105 = *((float32x4_t *)a2 + 103);
      v106 = (int8x16_t)vaddq_f32(v101, v104);
      v107 = *((float32x4_t *)a2 + 104);
      v108 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, veorq_s8(vandq_s8(v66, (int8x16_t)v31), vbslq_s8((int8x16_t)vcgtq_f32(v33, vsubq_f32(v37, v107)), (int8x16_t)vmulq_f32(v37, v105), v103)));
      v109 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v28, veorq_s8(vandq_s8(v66, (int8x16_t)v32), vbslq_s8((int8x16_t)vcgtq_f32(v33, vsubq_f32(v38, v107)), (int8x16_t)vmulq_f32(v38, v105), v106)));
      v110 = (int8x16_t *)(v6 + v11);
      v110[-1] = vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v108, v108, 3));
      *v110 = vbslq_s8(v14, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v109, v109, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v111 = -v10;
    if (v111 >= v5)
      goto LABEL_3;
LABEL_10:
    v112 = 16 * v111;
    v113 = *(float32x4_t *)(v7 + v112);
    v114 = *((int8x16_t *)a2 + 15);
    v115 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v113, 3), *((float32x4_t *)a2 + 16));
    v116 = vrecpeq_f32(v115);
    v117 = vmulq_f32(v116, vrecpsq_f32(v116, v115));
    v118 = vmulq_f32(v113, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v117, vrecpsq_f32(v117, v115))), *((int8x16_t *)a2 + 3)));
    v119 = (float32x4_t)vbslq_s8(v114, (int8x16_t)v118, (int8x16_t)vmaxq_f32(v118, *((float32x4_t *)a2 + 105)));
    v120 = *((float32x4_t *)a2 + 75);
    v121 = *((float32x4_t *)a2 + 5);
    v122 = vmulq_f32(v119, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v120, v119), *((int8x16_t *)a2 + 34), (int8x16_t)v121));
    v123 = *((float32x4_t *)a2 + 100);
    v124 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v121, (int8x16_t)vceqq_f32(v123, v120)), v120), (int8x16_t)v121, (int8x16_t)vminq_f32(v122, *((float32x4_t *)a2 + 106)));
    v125 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v124), (int8x16_t)v121);
    v126 = (float32x4_t)vandq_s8((int8x16_t)v121, (int8x16_t)vcgtq_f32(v125, *((float32x4_t *)a2 + 23)));
    v127 = vsubq_f32(vsubq_f32(v125, v121), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v126), v125));
    v128 = vmulq_f32(v127, v127);
    v129 = vmaxq_f32(vmulq_f32(v123, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v124, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v124))), *((float32x4_t *)a2 + 22)), v126), vmulq_f32(v127, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v127, vaddq_f32(
                         vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v127)),
                         vmulq_f32(v128, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v127)), vmulq_f32(v128, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v127))))))))))), *((float32x4_t *)a2 + 29));
    v130 = vcvtq_f32_s32(vcvtq_s32_f32(v129));
    v131 = vsubq_f32(v130, (float32x4_t)vandq_s8((int8x16_t)v121, (int8x16_t)vcgtq_f32(v130, v129)));
    v132 = vsubq_f32(v129, v131);
    v133 = (float32x4_t)vbslq_s8(v114, (int8x16_t)v118, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v119), vbslq_s8((int8x16_t)vcgtq_f32(v120, vsubq_f32(v122, *((float32x4_t *)a2 + 104))), (int8x16_t)vmulq_f32(v122, *((float32x4_t *)a2 + 103)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 101), vmulq_f32(*((float32x4_t *)a2 + 102), vmulq_f32(vaddq_f32(v121, vmulq_f32(v132, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(
                                                       v132,
                                                       vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v132)), vmulq_f32(vmulq_f32(v132, v132), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v132)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v131)), 0x17uLL)))))));
    *(int8x16_t *)(v6 + v112) = vbslq_s8(v114, (int8x16_t)v118, (int8x16_t)vmulq_laneq_f32(v133, v133, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_srgb_fast_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t *v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int8x16_t *v58;
  int8x16_t *v59;
  float32x4_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  int8x16_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v67 = 0;
        v68 = 16 * v8;
        v69 = 16 * v7;
        v70 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v71 = 0;
          do
          {
            v72 = *((int8x16_t *)a2 + 15);
            v73 = vmulq_f32(v5[v71 / 0x10], (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5[v71 / 0x10], 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v74 = vminq_f32(vmaxq_f32(v73, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v75 = vmulq_f32(v74, *((float32x4_t *)a2 + 107));
            v76 = vaddq_f32(v75, vmulq_f32(v74, vsubq_f32(v74, v75)));
            v77 = (float32x4_t)vbslq_s8(v72, (int8x16_t)v73, (int8x16_t)vmulq_f32(v76, v76));
            v6[v71 / 0x10] = vbslq_s8(v72, (int8x16_t)v73, (int8x16_t)vmulq_laneq_f32(v77, v77, 3));
            v71 += 16;
          }
          while (v70 != v71);
          ++v67;
          v5 = (float32x4_t *)((char *)v5 + v68);
          v6 = (int8x16_t *)((char *)v6 + v69);
        }
        while (v67 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v5[v17 - 2];
          v19 = v5[v17 - 1];
          v20 = v5[v17];
          v21 = v5[v17 + 1];
          v23 = *((int8x16_t *)a2 + 15);
          v22 = *((float32x4_t *)a2 + 16);
          v24 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 3), v22));
          v25 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3), v22));
          v26 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 3), v22));
          v27 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 3), v22));
          v28 = *((int8x16_t *)a2 + 17);
          v29 = vandq_s8(v28, v24);
          v30 = vandq_s8(v28, v25);
          v31 = vandq_s8(v28, v26);
          v32 = vandq_s8(v28, v27);
          v33 = *((int8x16_t *)a2 + 3);
          v34 = vmulq_f32(v18, (float32x4_t)vorrq_s8(v29, v33));
          v35 = vmulq_f32(v19, (float32x4_t)vorrq_s8(v30, v33));
          v36 = vmulq_f32(v20, (float32x4_t)vorrq_s8(v31, v33));
          v37 = *((float32x4_t *)a2 + 75);
          v38 = vmulq_f32(v21, (float32x4_t)vorrq_s8(v32, v33));
          v39 = *((float32x4_t *)a2 + 5);
          v40 = v16;
          v41 = vminq_f32(vmaxq_f32(v34, v37), v39);
          v42 = vminq_f32(vmaxq_f32(v35, v37), v39);
          v43 = vminq_f32(vmaxq_f32(v36, v37), v39);
          v44 = vminq_f32(vmaxq_f32(v38, v37), v39);
          v45 = *((float32x4_t *)a2 + 107);
          v46 = vmulq_f32(v41, v45);
          v47 = vmulq_f32(v42, v45);
          v48 = vmulq_f32(v43, v45);
          v49 = vmulq_f32(v44, v45);
          v50 = vaddq_f32(v46, vmulq_f32(v41, vsubq_f32(v41, v46)));
          v51 = vaddq_f32(v47, vmulq_f32(v42, vsubq_f32(v42, v47)));
          v52 = vaddq_f32(v48, vmulq_f32(v43, vsubq_f32(v43, v48)));
          v53 = vaddq_f32(v49, vmulq_f32(v44, vsubq_f32(v44, v49)));
          v54 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v34, (int8x16_t)vmulq_f32(v50, v50));
          v55 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v35, (int8x16_t)vmulq_f32(v51, v51));
          v56 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v36, (int8x16_t)vmulq_f32(v52, v52));
          v57 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v38, (int8x16_t)vmulq_f32(v53, v53));
          v58 = v15;
          v59 = &v6[v17];
          v14 += 4;
          v59[-2] = vbslq_s8(v23, (int8x16_t)v34, (int8x16_t)vmulq_laneq_f32(v54, v54, 3));
          v59[-1] = vbslq_s8(v23, (int8x16_t)v35, (int8x16_t)vmulq_laneq_f32(v55, v55, 3));
          *v59 = vbslq_s8(v23, (int8x16_t)v36, (int8x16_t)vmulq_laneq_f32(v56, v56, 3));
          v59[1] = vbslq_s8(v23, (int8x16_t)v38, (int8x16_t)vmulq_laneq_f32(v57, v57, 3));
          v17 += 4;
          v16 += 4;
          v15 = v58 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v60 = *v40++;
            v61 = *((int8x16_t *)a2 + 15);
            v62 = vmulq_f32(v60, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v60, 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v63 = vminq_f32(vmaxq_f32(v62, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v64 = vmulq_f32(v63, *((float32x4_t *)a2 + 107));
            v65 = vaddq_f32(v64, vmulq_f32(v63, vsubq_f32(v63, v64)));
            v66 = (float32x4_t)vbslq_s8(v61, (int8x16_t)v62, (int8x16_t)vmulq_f32(v65, v65));
            *v58++ = vbslq_s8(v61, (int8x16_t)v62, (int8x16_t)vmulq_laneq_f32(v66, v66, 3));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getinv_srgb_fixed_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int8x16_t *v83;
  uint64_t v84;
  int8x16_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v84) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v17 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15));
      v18 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15));
      v19 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v15));
      v21 = *((int8x16_t *)a2 + 17);
      v20 = *((float32x4_t *)a2 + 18);
      v22 = (int8x16_t)vmulq_f32(v19, v20);
      v23 = vandq_s8(v21, (int8x16_t)vmulq_f32(v17, v20));
      v24 = vandq_s8(v21, (int8x16_t)vmulq_f32(v18, v20));
      v25 = *((int8x16_t *)a2 + 3);
      v26 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v23, v25));
      v27 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v24, v25));
      v28 = vmulq_f32(v14, (float32x4_t)vorrq_s8(vandq_s8(v21, v22), v25));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = *((float32x4_t *)a2 + 6);
      v32 = vminq_f32(vmaxq_f32(v26, v29), v30);
      v33 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v34 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v35 = *((float32x4_t *)a2 + 108);
      v36 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)vaddq_f32(v32, v35)));
      v37 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)vaddq_f32(v33, v35)));
      v38 = vmulq_f32(v31, vcvtq_f32_s32((int32x4_t)vaddq_f32(v34, v35)));
      v39 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
      v40 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
      v41 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
      v42 = *((float32x4_t *)a2 + 7);
      v43 = *((float32x4_t *)a2 + 8);
      v44 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v36, v39), v42));
      v45 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v37, v40), v42));
      v46 = vrsqrteq_f32(vaddq_f32(v42, vsubq_f32(v38, v41)));
      v47 = vaddq_f32(v43, v39);
      v48 = vaddq_f32(v43, v40);
      v49 = vaddq_f32(v43, v41);
      v50 = *((float32x4_t *)a2 + 9);
      v51 = *((float32x4_t *)a2 + 10);
      v52 = vsubq_f32(v47, vmulq_f32(v44, v50));
      v53 = vsubq_f32(v48, vmulq_f32(v45, v50));
      v54 = *((float32x4_t *)a2 + 109);
      v55 = vmulq_f32(v54, v52);
      v56 = vmulq_f32(v54, v53);
      v57 = vmulq_f32(v54, vsubq_f32(v49, vmulq_f32(v46, v50)));
      v58 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      v59 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
      v60 = vcvtq_f32_s32(vcvtq_s32_f32(v57));
      v61 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v58, v55)));
      v62 = vsubq_f32(v59, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v59, v56)));
      v63 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v60, v57)));
      v64 = *((float32x4_t *)a2 + 11);
      v65 = *((float32x4_t *)a2 + 12);
      v66 = vmulq_f32(vrecpeq_f32(vsubq_f32(v64, vsubq_f32(v55, v61))), v65);
      v67 = vmulq_f32(vrecpeq_f32(vsubq_f32(v64, vsubq_f32(v56, v62))), v65);
      v68 = vmulq_f32(vrecpeq_f32(vsubq_f32(v64, vsubq_f32(v57, v63))), v65);
      v69 = vaddq_f32(vaddq_f32(v51, v63), vmulq_f32(v68, v68));
      v70 = vmaxq_f32(vaddq_f32(vaddq_f32(v51, v61), vmulq_f32(v66, v66)), v29);
      v71 = vmaxq_f32(vaddq_f32(vaddq_f32(v51, v62), vmulq_f32(v67, v67)), v29);
      v72 = *((float32x4_t *)a2 + 13);
      v73 = *((float32x4_t *)a2 + 14);
      v74 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v70, v72), v73));
      v75 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v71, v72), v73));
      v76 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v69, v29), v72), v73));
      v77 = *((float32x4_t *)a2 + 110);
      v78 = *((float32x4_t *)a2 + 111);
      v79 = *((float32x4_t *)a2 + 112);
      v80 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v26, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v79)), (int8x16_t)vmulq_f32(v32, v78), (int8x16_t)vmulq_f32(v77, v74)));
      v81 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v27, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v33, v79)), (int8x16_t)vmulq_f32(v33, v78), (int8x16_t)vmulq_f32(v77, v75)));
      v82 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v28, vbslq_s8((int8x16_t)vcgtq_f32(v29, vsubq_f32(v34, v79)), (int8x16_t)vmulq_f32(v34, v78), (int8x16_t)vmulq_f32(v77, v76)));
      v83 = (int8x16_t *)(v6 + v10);
      *v83 = vbslq_s8(v16, (int8x16_t)v26, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      v83[1] = vbslq_s8(v16, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      v83[2] = vbslq_s8(v16, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v82, v82, 3));
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v84) = -v11;
    if ((int)v84 >= v5)
      goto LABEL_3;
LABEL_10:
    v84 = v84;
    do
    {
      v85 = *((int8x16_t *)a2 + 15);
      v86 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v84), (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v7 + 16 * v84), 3), *((float32x4_t *)a2 + 16))), *((float32x4_t *)a2 + 18))), *((int8x16_t *)a2 + 3)));
      v87 = *((float32x4_t *)a2 + 75);
      v88 = *((float32x4_t *)a2 + 5);
      v89 = vminq_f32(vmaxq_f32(v86, v87), v88);
      v90 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v89, *((float32x4_t *)a2 + 108))));
      v91 = vcvtq_f32_s32(vcvtq_s32_f32(v90));
      v92 = vmulq_f32(*((float32x4_t *)a2 + 109), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v91), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v90, v91))), *((float32x4_t *)a2 + 9))));
      v93 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
      v94 = vsubq_f32(v93, (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v93, v92)));
      v95 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v92, v94))), *((float32x4_t *)a2 + 12));
      v96 = (float32x4_t)vbslq_s8(v85, (int8x16_t)v86, vbslq_s8((int8x16_t)vcgtq_f32(v87, vsubq_f32(v89, *((float32x4_t *)a2 + 112))), (int8x16_t)vmulq_f32(v89, *((float32x4_t *)a2 + 111)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 110), (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v94), vmulq_f32(v95, v95)), v87), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))))));
      *(int8x16_t *)(v6 + 16 * v84++) = vbslq_s8(v85, (int8x16_t)v86, (int8x16_t)vmulq_laneq_f32(v96, v96, 3));
    }
    while (v84 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_srgb_nice_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  int32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  int8x16_t v96;
  int8x16_t v97;
  float32x4_t v98;
  int8x16_t v99;
  int8x16_t v100;
  float32x4_t v101;
  float32x4_t v102;
  int8x16_t *v103;
  int v104;
  uint64_t v105;
  float32x4_t v106;
  int8x16_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v104 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = *((int8x16_t *)a2 + 17);
      v24 = vandq_s8(v23, v22);
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = *((float32x4_t *)a2 + 5);
      v31 = vminq_f32(vmaxq_f32(v27, v29), v30);
      v32 = vminq_f32(vmaxq_f32(v28, v29), v30);
      v33 = *((float32x4_t *)a2 + 108);
      v34 = *((float32x4_t *)a2 + 109);
      v35 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vceqq_f32(v34, v29)), v29);
      v36 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v30, (int8x16_t)vaddq_f32(v31, v33));
      v37 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v30, (int8x16_t)vaddq_f32(v32, v33));
      v38 = *((int8x16_t *)a2 + 19);
      v39 = *((float32x4_t *)a2 + 20);
      v40 = (float32x4_t)vorrq_s8(vandq_s8(v38, (int8x16_t)v36), (int8x16_t)v30);
      v41 = (float32x4_t)vorrq_s8(vandq_s8(v38, (int8x16_t)v37), (int8x16_t)v30);
      v42 = *((int8x16_t *)a2 + 21);
      v43 = *((float32x4_t *)a2 + 22);
      v44 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v36, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v39, v36)));
      v45 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v39, v37)));
      v46 = *((float32x4_t *)a2 + 23);
      v47 = *((float32x4_t *)a2 + 24);
      v48 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v40, v46));
      v49 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v41, v46));
      v50 = vaddq_f32(vsubq_f32(v44, v43), v48);
      v51 = vmulq_f32(v47, v48);
      v52 = vmulq_f32(vmulq_f32(v47, v49), v41);
      v53 = vaddq_f32(vsubq_f32(v45, v43), v49);
      v54 = vsubq_f32(vsubq_f32(v40, v30), vmulq_f32(v51, v40));
      v55 = vsubq_f32(vsubq_f32(v41, v30), v52);
      v56 = vmulq_f32(v54, v54);
      v57 = vmulq_f32(v55, v55);
      v58 = *((float32x4_t *)a2 + 37);
      v59 = *((float32x4_t *)a2 + 38);
      v60 = *((float32x4_t *)a2 + 39);
      v61 = *((float32x4_t *)a2 + 40);
      v62 = vaddq_f32(v58, vmulq_f32(v59, v54));
      v63 = vaddq_f32(v60, vmulq_f32(v61, v54));
      v64 = vaddq_f32(v60, vmulq_f32(v61, v55));
      v65 = vaddq_f32(v58, vmulq_f32(v59, v55));
      v66 = *((float32x4_t *)a2 + 41);
      v67 = *((float32x4_t *)a2 + 42);
      v68 = vaddq_f32(vaddq_f32(v66, vmulq_f32(v67, v55)), vmulq_f32(v57, vaddq_f32(v65, vmulq_f32(v57, v64))));
      v69 = vmulq_f32(v54, vaddq_f32(vaddq_f32(v66, vmulq_f32(v67, v54)), vmulq_f32(v56, vaddq_f32(v62, vmulq_f32(v56, v63)))));
      v70 = *((float32x4_t *)a2 + 43);
      v71 = *((float32x4_t *)a2 + 44);
      v72 = vmulq_f32(v34, vaddq_f32(v50, vmulq_f32(v54, vaddq_f32(v70, v69))));
      v73 = vmulq_f32(v34, vaddq_f32(v53, vmulq_f32(v55, vaddq_f32(v70, vmulq_f32(v55, v68)))));
      v74 = *((float32x4_t *)a2 + 29);
      v75 = vmaxq_f32(v72, v74);
      v76 = vmaxq_f32(v73, v74);
      v77 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v76));
      v79 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v77, v75)));
      v80 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v78, v76)));
      v81 = vsubq_f32(v75, v79);
      v82 = vsubq_f32(v76, v80);
      v83 = *((float32x4_t *)a2 + 45);
      v84 = *((float32x4_t *)a2 + 46);
      v85 = vaddq_f32(v71, vmulq_f32(v83, v81));
      v86 = vaddq_f32(v71, vmulq_f32(v83, v82));
      v87 = *((float32x4_t *)a2 + 47);
      v88 = *((float32x4_t *)a2 + 48);
      v89 = vaddq_f32(v30, vmulq_f32(v81, vaddq_f32(v88, vmulq_f32(v81, vaddq_f32(vaddq_f32(v84, vmulq_f32(v81, v87)), vmulq_f32(vmulq_f32(v81, v81), v85))))));
      v90 = *((int32x4_t *)a2 + 33);
      v91 = vaddq_f32(v30, vmulq_f32(v82, vaddq_f32(v88, vmulq_f32(v82, vaddq_f32(vaddq_f32(v84, vmulq_f32(v87, v82)), vmulq_f32(vmulq_f32(v82, v82), v86))))));
      v92 = vmulq_f32(v89, (float32x4_t)vshlq_n_s32(vaddq_s32(v90, vcvtq_s32_f32(v79)), 0x17uLL));
      v93 = vmulq_f32(v91, (float32x4_t)vshlq_n_s32(vaddq_s32(v90, vcvtq_s32_f32(v80)), 0x17uLL));
      v94 = *((float32x4_t *)a2 + 110);
      v95 = *((float32x4_t *)a2 + 111);
      v96 = (int8x16_t)vmulq_f32(v31, v95);
      v97 = (int8x16_t)vmulq_f32(v32, v95);
      v98 = *((float32x4_t *)a2 + 112);
      v99 = (int8x16_t)vcgtq_f32(v29, vsubq_f32(v31, v98));
      v100 = (int8x16_t)vcgtq_f32(v29, vsubq_f32(v32, v98));
      v101 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v27, vbslq_s8(v99, v96, (int8x16_t)vmulq_f32(v94, v92)));
      v102 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, vbslq_s8(v100, v97, (int8x16_t)vmulq_f32(v94, v93)));
      v103 = (int8x16_t *)(v6 + v11);
      v103[-1] = vbslq_s8(v15, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v101, v101, 3));
      *v103 = vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v102, v102, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v104 = -v10;
    if (v104 >= v5)
      goto LABEL_3;
LABEL_10:
    v105 = 16 * v104;
    v106 = *(float32x4_t *)(v7 + v105);
    v107 = *((int8x16_t *)a2 + 15);
    v108 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 3), *((float32x4_t *)a2 + 16));
    v109 = vrecpeq_f32(v108);
    v110 = vmulq_f32(v109, vrecpsq_f32(v109, v108));
    v111 = vmulq_f32(v106, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v110, vrecpsq_f32(v110, v108))), *((int8x16_t *)a2 + 3)));
    v112 = *((float32x4_t *)a2 + 75);
    v113 = *((float32x4_t *)a2 + 5);
    v114 = vminq_f32(vmaxq_f32(v111, v112), v113);
    v115 = *((float32x4_t *)a2 + 109);
    v116 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vceqq_f32(v115, v112)), v112), (int8x16_t)v113, (int8x16_t)vaddq_f32(v114, *((float32x4_t *)a2 + 108)));
    v117 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v116), (int8x16_t)v113);
    v118 = (float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v117, *((float32x4_t *)a2 + 23)));
    v119 = vsubq_f32(vsubq_f32(v117, v113), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v118), v117));
    v120 = vmulq_f32(v119, v119);
    v121 = vmaxq_f32(vmulq_f32(v115, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v116, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v116))), *((float32x4_t *)a2 + 22)), v118), vmulq_f32(v119, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v119, vaddq_f32(
                         vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v119)),
                         vmulq_f32(v120, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v119)), vmulq_f32(v120, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v119))))))))))), *((float32x4_t *)a2 + 29));
    v122 = vcvtq_f32_s32(vcvtq_s32_f32(v121));
    v123 = vsubq_f32(v122, (float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v122, v121)));
    v124 = vsubq_f32(v121, v123);
    v125 = (float32x4_t)vbslq_s8(v107, (int8x16_t)v111, vbslq_s8((int8x16_t)vcgtq_f32(v112, vsubq_f32(v114, *((float32x4_t *)a2 + 112))), (int8x16_t)vmulq_f32(v114, *((float32x4_t *)a2 + 111)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 110), vmulq_f32(vaddq_f32(v113, vmulq_f32(v124, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v124, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46),
                                                       vmulq_f32(*((float32x4_t *)a2 + 47), v124)),
                                                     vmulq_f32(vmulq_f32(v124, v124), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v124)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v123)), 0x17uLL)))));
    *(int8x16_t *)(v6 + v105) = vbslq_s8(v107, (int8x16_t)v111, (int8x16_t)vmulq_laneq_f32(v125, v125, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_srgb_half_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int32x4_t v73;
  int32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int8x16_t *v83;
  int v84;
  uint64_t v85;
  float32x4_t v86;
  int8x16_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v84 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23));
      v26 = *((float32x4_t *)a2 + 75);
      v27 = *((float32x4_t *)a2 + 5);
      v28 = vminq_f32(vmaxq_f32(v24, v26), v27);
      v29 = vminq_f32(vmaxq_f32(v25, v26), v27);
      v30 = *((float32x4_t *)a2 + 108);
      v31 = vaddq_f32(v28, v30);
      v32 = vaddq_f32(v29, v30);
      v33 = *((int8x16_t *)a2 + 19);
      v34 = *((float32x4_t *)a2 + 20);
      v35 = (float32x4_t)vorrq_s8(vandq_s8(v33, (int8x16_t)v31), (int8x16_t)v27);
      v36 = (float32x4_t)vorrq_s8(vandq_s8(v33, (int8x16_t)v32), (int8x16_t)v27);
      v37 = *((int8x16_t *)a2 + 21);
      v38 = *((float32x4_t *)a2 + 22);
      v39 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v32, 0x17uLL)), (float32x4_t)vandq_s8(v37, (int8x16_t)vcgtq_f32(v34, v32)));
      v40 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v31, 0x17uLL)), (float32x4_t)vandq_s8(v37, (int8x16_t)vcgtq_f32(v34, v31))), v38);
      v41 = *((float32x4_t *)a2 + 23);
      v42 = *((float32x4_t *)a2 + 24);
      v43 = vsubq_f32(v39, v38);
      v44 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v35, v41));
      v45 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v36, v41));
      v46 = vaddq_f32(v40, v44);
      v47 = vsubq_f32(vsubq_f32(v35, v27), vmulq_f32(vmulq_f32(v42, v44), v35));
      v48 = vsubq_f32(vsubq_f32(v36, v27), vmulq_f32(vmulq_f32(v42, v45), v36));
      v49 = *((float32x4_t *)a2 + 25);
      v50 = *((float32x4_t *)a2 + 26);
      v51 = vaddq_f32(v49, vmulq_f32(v50, v47));
      v52 = vaddq_f32(v49, vmulq_f32(v50, v48));
      v53 = *((float32x4_t *)a2 + 27);
      v54 = *((float32x4_t *)a2 + 28);
      v55 = vaddq_f32(vaddq_f32(v43, v45), vmulq_f32(v48, vaddq_f32(vaddq_f32(v53, vmulq_f32(v48, v54)), vmulq_f32(vmulq_f32(v48, v48), v52))));
      v56 = *((float32x4_t *)a2 + 109);
      v57 = vmulq_f32(v56, vaddq_f32(v46, vmulq_f32(v47, vaddq_f32(vaddq_f32(v53, vmulq_f32(v47, v54)), vmulq_f32(vmulq_f32(v47, v47), v51)))));
      v58 = vmulq_f32(v56, v55);
      v59 = *((float32x4_t *)a2 + 29);
      v60 = *((float32x4_t *)a2 + 30);
      v61 = vmaxq_f32(v57, v59);
      v62 = vmaxq_f32(v58, v59);
      v63 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v64 = vcvtq_f32_s32(vcvtq_s32_f32(v62));
      v65 = vsubq_f32(v63, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v63, v61)));
      v66 = vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v64, v62)));
      v67 = vsubq_f32(v61, v65);
      v68 = *((float32x4_t *)a2 + 31);
      v69 = *((float32x4_t *)a2 + 32);
      v70 = vsubq_f32(v62, v66);
      v71 = vmulq_f32(v70, vaddq_f32(v69, vmulq_f32(v70, vaddq_f32(v60, vmulq_f32(v68, v70)))));
      v72 = vaddq_f32(v27, vmulq_f32(v67, vaddq_f32(v69, vmulq_f32(v67, vaddq_f32(v60, vmulq_f32(v68, v67))))));
      v73 = vcvtq_s32_f32(v66);
      v74 = *((int32x4_t *)a2 + 33);
      v75 = vaddq_f32(v27, v71);
      v76 = vmulq_f32(v72, (float32x4_t)vshlq_n_s32(vaddq_s32(v74, vcvtq_s32_f32(v65)), 0x17uLL));
      v77 = vmulq_f32(v75, (float32x4_t)vshlq_n_s32(vaddq_s32(v74, v73), 0x17uLL));
      v78 = *((float32x4_t *)a2 + 110);
      v79 = *((float32x4_t *)a2 + 111);
      v80 = *((float32x4_t *)a2 + 112);
      v81 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v24, vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v28, v80)), (int8x16_t)vmulq_f32(v28, v79), (int8x16_t)vmulq_f32(v78, v76)));
      v82 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v25, vbslq_s8((int8x16_t)vcgtq_f32(v26, vsubq_f32(v29, v80)), (int8x16_t)vmulq_f32(v29, v79), (int8x16_t)vmulq_f32(v78, v77)));
      v83 = (int8x16_t *)(v6 + v11);
      v83[-1] = vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      *v83 = vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v82, v82, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v84 = -v10;
    if (v84 >= v5)
      goto LABEL_3;
LABEL_10:
    v85 = 16 * v84;
    v86 = *(float32x4_t *)(v7 + v85);
    v87 = *((int8x16_t *)a2 + 15);
    v88 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v86, 3), *((float32x4_t *)a2 + 16));
    v89 = vmulq_f32(vrecpeq_f32(v88), *((float32x4_t *)a2 + 18));
    v90 = vmulq_f32(v86, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v89, vrecpsq_f32(v89, v88))), *((int8x16_t *)a2 + 3)));
    v91 = *((float32x4_t *)a2 + 75);
    v92 = *((float32x4_t *)a2 + 5);
    v93 = vminq_f32(vmaxq_f32(v90, v91), v92);
    v94 = vaddq_f32(v93, *((float32x4_t *)a2 + 108));
    v95 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v94), (int8x16_t)v92);
    v96 = (float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v95, *((float32x4_t *)a2 + 23)));
    v97 = vsubq_f32(vsubq_f32(v95, v92), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v96), v95));
    v98 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 109), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v94, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v94))), *((float32x4_t *)a2 + 22)), v96), vmulq_f32(v97, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v97, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v97, v97), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v97))))))),
            *((float32x4_t *)a2 + 29));
    v99 = vcvtq_f32_s32(vcvtq_s32_f32(v98));
    v100 = vsubq_f32(v99, (float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v99, v98)));
    v101 = vsubq_f32(v98, v100);
    v102 = (float32x4_t)vbslq_s8(v87, (int8x16_t)v90, vbslq_s8((int8x16_t)vcgtq_f32(v91, vsubq_f32(v93, *((float32x4_t *)a2 + 112))), (int8x16_t)vmulq_f32(v93, *((float32x4_t *)a2 + 111)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 110), vmulq_f32(vaddq_f32(v92, vmulq_f32(v101, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v101, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v101)))))),
                                           (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v100)), 0x17uLL)))));
    *(int8x16_t *)(v6 + v85) = vbslq_s8(v87, (int8x16_t)v90, (int8x16_t)vmulq_laneq_f32(v102, v102, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_srgb_halfTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  int32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  int8x16_t v40;
  float32x4_t v41;
  float32x4_t v42;
  int8x16_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  int32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  int8x16_t v85;
  float32x4_t v86;
  int8x16_t v87;
  float32x4_t v88;
  int8x16_t v89;
  int8x16_t v90;
  int8x16_t v91;
  float32x4_t v92;
  float32x4_t v93;
  int8x16_t *v94;
  int v95;
  uint64_t v96;
  float32x4_t v97;
  int8x16_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v95 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23);
      v25 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v26 = *((float32x4_t *)a2 + 113);
      v27 = vmulq_f32(v13, v24);
      v28 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmaxq_f32(v25, v26));
      v29 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmaxq_f32(v27, v26));
      v30 = *((float32x4_t *)a2 + 75);
      v31 = *((float32x4_t *)a2 + 5);
      v33 = *((int32x4_t *)a2 + 33);
      v32 = *((int8x16_t *)a2 + 34);
      v34 = vmulq_f32(v28, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v30, v28), v32, (int8x16_t)v31));
      v35 = vmulq_f32(v29, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v30, v29), v32, (int8x16_t)v31));
      v36 = *((float32x4_t *)a2 + 114);
      v37 = *((float32x4_t *)a2 + 108);
      v38 = vaddq_f32(vminq_f32(v34, v36), v37);
      v39 = vaddq_f32(vminq_f32(v35, v36), v37);
      v40 = *((int8x16_t *)a2 + 19);
      v41 = *((float32x4_t *)a2 + 20);
      v42 = (float32x4_t)vorrq_s8(vandq_s8(v40, (int8x16_t)v38), (int8x16_t)v31);
      v43 = *((int8x16_t *)a2 + 21);
      v44 = *((float32x4_t *)a2 + 22);
      v45 = (float32x4_t)vorrq_s8(vandq_s8(v40, (int8x16_t)v39), (int8x16_t)v31);
      v46 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v39, 0x17uLL)), (float32x4_t)vandq_s8(v43, (int8x16_t)vcgtq_f32(v41, v39)));
      v47 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v38, 0x17uLL)), (float32x4_t)vandq_s8(v43, (int8x16_t)vcgtq_f32(v41, v38))), v44);
      v48 = *((float32x4_t *)a2 + 23);
      v49 = *((float32x4_t *)a2 + 24);
      v50 = vsubq_f32(v46, v44);
      v51 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v42, v48));
      v52 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v45, v48));
      v53 = vmulq_f32(v49, v51);
      v54 = vaddq_f32(v47, v51);
      v55 = vmulq_f32(vmulq_f32(v49, v52), v45);
      v56 = vaddq_f32(v50, v52);
      v57 = vsubq_f32(vsubq_f32(v42, v31), vmulq_f32(v53, v42));
      v58 = vsubq_f32(vsubq_f32(v45, v31), v55);
      v59 = *((float32x4_t *)a2 + 25);
      v60 = *((float32x4_t *)a2 + 26);
      v61 = *((float32x4_t *)a2 + 27);
      v62 = *((float32x4_t *)a2 + 28);
      v63 = vaddq_f32(v56, vmulq_f32(v58, vaddq_f32(vaddq_f32(v61, vmulq_f32(v58, v62)), vmulq_f32(vmulq_f32(v58, v58), vaddq_f32(v59, vmulq_f32(v60, v58))))));
      v64 = *((float32x4_t *)a2 + 109);
      v65 = vmulq_f32(v64, vaddq_f32(v54, vmulq_f32(v57, vaddq_f32(vaddq_f32(v61, vmulq_f32(v57, v62)), vmulq_f32(vmulq_f32(v57, v57), vaddq_f32(v59, vmulq_f32(v60, v57)))))));
      v66 = vmulq_f32(v64, v63);
      v67 = *((float32x4_t *)a2 + 29);
      v68 = *((float32x4_t *)a2 + 30);
      v69 = vmaxq_f32(v65, v67);
      v70 = vmaxq_f32(v66, v67);
      v71 = vcvtq_f32_s32(vcvtq_s32_f32(v69));
      v72 = vcvtq_f32_s32(vcvtq_s32_f32(v70));
      v73 = vsubq_f32(v71, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v71, v69)));
      v74 = vsubq_f32(v72, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v72, v70)));
      v75 = vsubq_f32(v69, v73);
      v76 = vsubq_f32(v70, v74);
      v77 = *((float32x4_t *)a2 + 31);
      v78 = *((float32x4_t *)a2 + 32);
      v79 = vaddq_f32(v31, vmulq_f32(v75, vaddq_f32(v78, vmulq_f32(v75, vaddq_f32(v68, vmulq_f32(v77, v75))))));
      v80 = vaddq_f32(v31, vmulq_f32(v76, vaddq_f32(v78, vmulq_f32(v76, vaddq_f32(v68, vmulq_f32(v77, v76))))));
      v81 = vaddq_s32(v33, vcvtq_s32_f32(v74));
      v82 = vmulq_f32(v79, (float32x4_t)vshlq_n_s32(vaddq_s32(v33, vcvtq_s32_f32(v73)), 0x17uLL));
      v83 = *((float32x4_t *)a2 + 110);
      v84 = vmulq_f32(v80, (float32x4_t)vshlq_n_s32(v81, 0x17uLL));
      v85 = (int8x16_t)vmulq_f32(v83, v82);
      v86 = *((float32x4_t *)a2 + 111);
      v87 = (int8x16_t)vmulq_f32(v34, v86);
      v88 = *((float32x4_t *)a2 + 112);
      v89 = (int8x16_t)vcgtq_f32(v30, vsubq_f32(v34, v88));
      v90 = vbslq_s8((int8x16_t)vcgtq_f32(v30, vsubq_f32(v35, v88)), (int8x16_t)vmulq_f32(v35, v86), (int8x16_t)vmulq_f32(v83, v84));
      v91 = *((int8x16_t *)a2 + 36);
      v92 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, veorq_s8(vandq_s8(v91, (int8x16_t)v28), vbslq_s8(v89, v87, v85)));
      v93 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, veorq_s8(vandq_s8(v91, (int8x16_t)v29), v90));
      v94 = (int8x16_t *)(v6 + v11);
      v94[-1] = vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v92, v92, 3));
      *v94 = vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v93, v93, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v95 = -v10;
    if (v95 >= v5)
      goto LABEL_3;
LABEL_10:
    v96 = 16 * v95;
    v97 = *(float32x4_t *)(v7 + v96);
    v98 = *((int8x16_t *)a2 + 15);
    v99 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v97, 3), *((float32x4_t *)a2 + 16));
    v100 = vmulq_f32(vrecpeq_f32(v99), *((float32x4_t *)a2 + 18));
    v101 = vmulq_f32(v97, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v100, vrecpsq_f32(v100, v99))), *((int8x16_t *)a2 + 3)));
    v102 = (float32x4_t)vbslq_s8(v98, (int8x16_t)v101, (int8x16_t)vmaxq_f32(v101, *((float32x4_t *)a2 + 113)));
    v103 = *((float32x4_t *)a2 + 75);
    v104 = *((float32x4_t *)a2 + 5);
    v105 = vmulq_f32(v102, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v103, v102), *((int8x16_t *)a2 + 34), (int8x16_t)v104));
    v106 = vaddq_f32(vminq_f32(v105, *((float32x4_t *)a2 + 114)), *((float32x4_t *)a2 + 108));
    v107 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v106), (int8x16_t)v104);
    v108 = (float32x4_t)vandq_s8((int8x16_t)v104, (int8x16_t)vcgtq_f32(v107, *((float32x4_t *)a2 + 23)));
    v109 = vsubq_f32(vsubq_f32(v107, v104), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v108), v107));
    v110 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 109), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v106, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v106))), *((float32x4_t *)a2 + 22)), v108), vmulq_f32(v109, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v109, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v109, v109), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v109))))))),
             *((float32x4_t *)a2 + 29));
    v111 = vcvtq_f32_s32(vcvtq_s32_f32(v110));
    v112 = vsubq_f32(v111, (float32x4_t)vandq_s8((int8x16_t)v104, (int8x16_t)vcgtq_f32(v111, v110)));
    v113 = vsubq_f32(v110, v112);
    v114 = (float32x4_t)vbslq_s8(v98, (int8x16_t)v101, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v102), vbslq_s8((int8x16_t)vcgtq_f32(v103, vsubq_f32(v105, *((float32x4_t *)a2 + 112))), (int8x16_t)vmulq_f32(v105, *((float32x4_t *)a2 + 111)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 110), vmulq_f32(vaddq_f32(v104, vmulq_f32(v113, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v113, vaddq_f32(
                                                       *((float32x4_t *)a2 + 30),
                                                       vmulq_f32(*((float32x4_t *)a2 + 31), v113)))))),
                                             (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v112)), 0x17uLL))))));
    *(int8x16_t *)(v6 + v96) = vbslq_s8(v98, (int8x16_t)v101, (int8x16_t)vmulq_laneq_f32(v114, v114, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_srgb_niceTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  int32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  int8x16_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int8x16_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  int32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  int8x16_t v102;
  float32x4_t v103;
  int8x16_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  int8x16_t *v108;
  int v109;
  uint64_t v110;
  float32x4_t v111;
  int8x16_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v109 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = *((int8x16_t *)a2 + 17);
      v24 = vandq_s8(v23, v22);
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 113);
      v30 = (int8x16_t)vmaxq_f32(v28, v29);
      v31 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmaxq_f32(v27, v29));
      v32 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v28, v30);
      v33 = *((float32x4_t *)a2 + 75);
      v34 = *((float32x4_t *)a2 + 5);
      v36 = *((int32x4_t *)a2 + 33);
      v35 = *((int8x16_t *)a2 + 34);
      v37 = vmulq_f32(v31, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v33, v31), v35, (int8x16_t)v34));
      v38 = vmulq_f32(v32, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v33, v32), v35, (int8x16_t)v34));
      v39 = *((float32x4_t *)a2 + 114);
      v40 = *((float32x4_t *)a2 + 108);
      v41 = (int8x16_t)vaddq_f32(vminq_f32(v37, v39), v40);
      v42 = (int8x16_t)vaddq_f32(vminq_f32(v38, v39), v40);
      v43 = *((float32x4_t *)a2 + 109);
      v44 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vceqq_f32(v43, v33)), v33);
      v45 = (float32x4_t)vbslq_s8(v44, (int8x16_t)v34, v41);
      v46 = (float32x4_t)vbslq_s8(v44, (int8x16_t)v34, v42);
      v47 = *((int8x16_t *)a2 + 19);
      v48 = *((float32x4_t *)a2 + 20);
      v49 = (float32x4_t)vorrq_s8(vandq_s8(v47, (int8x16_t)v45), (int8x16_t)v34);
      v50 = (float32x4_t)vorrq_s8(vandq_s8(v47, (int8x16_t)v46), (int8x16_t)v34);
      v51 = *((int8x16_t *)a2 + 21);
      v52 = *((float32x4_t *)a2 + 22);
      v53 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v46, 0x17uLL)), (float32x4_t)vandq_s8(v51, (int8x16_t)vcgtq_f32(v48, v46)));
      v54 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v45, 0x17uLL)), (float32x4_t)vandq_s8(v51, (int8x16_t)vcgtq_f32(v48, v45))), v52);
      v55 = *((float32x4_t *)a2 + 23);
      v56 = *((float32x4_t *)a2 + 24);
      v57 = vsubq_f32(v53, v52);
      v58 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v49, v55));
      v59 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v50, v55));
      v60 = vaddq_f32(v54, v58);
      v61 = vsubq_f32(vsubq_f32(v49, v34), vmulq_f32(vmulq_f32(v56, v58), v49));
      v62 = vsubq_f32(vsubq_f32(v50, v34), vmulq_f32(vmulq_f32(v56, v59), v50));
      v63 = vmulq_f32(v61, v61);
      v64 = *((float32x4_t *)a2 + 38);
      v65 = *((float32x4_t *)a2 + 39);
      v67 = *((int8x16_t *)a2 + 36);
      v66 = *((float32x4_t *)a2 + 37);
      v68 = vaddq_f32(v66, vmulq_f32(v64, v61));
      v69 = vaddq_f32(v66, vmulq_f32(v64, v62));
      v70 = *((float32x4_t *)a2 + 40);
      v71 = *((float32x4_t *)a2 + 41);
      v72 = vaddq_f32(v65, vmulq_f32(v70, v61));
      v73 = vaddq_f32(v65, vmulq_f32(v70, v62));
      v75 = *((float32x4_t *)a2 + 42);
      v74 = *((float32x4_t *)a2 + 43);
      v76 = vaddq_f32(v71, vmulq_f32(v75, v61));
      v77 = vaddq_f32(v71, vmulq_f32(v75, v62));
      v78 = vmulq_f32(v62, v62);
      v79 = vmulq_f32(v43, vaddq_f32(v60, vmulq_f32(v61, vaddq_f32(v74, vmulq_f32(v61, vaddq_f32(v76, vmulq_f32(v63, vaddq_f32(v68, vmulq_f32(v63, v72)))))))));
      v80 = vmulq_f32(v43, vaddq_f32(vaddq_f32(v57, v59), vmulq_f32(v62, vaddq_f32(v74, vmulq_f32(v62, vaddq_f32(v77, vmulq_f32(v78, vaddq_f32(v69, vmulq_f32(v78, v73)))))))));
      v81 = *((float32x4_t *)a2 + 29);
      v82 = vmaxq_f32(v79, v81);
      v83 = vmaxq_f32(v80, v81);
      v84 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
      v85 = vcvtq_f32_s32(vcvtq_s32_f32(v83));
      v86 = vsubq_f32(v84, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v84, v82)));
      v87 = vsubq_f32(v85, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v85, v83)));
      v88 = vsubq_f32(v82, v86);
      v89 = vsubq_f32(v83, v87);
      v90 = *((float32x4_t *)a2 + 44);
      v91 = *((float32x4_t *)a2 + 45);
      v92 = vaddq_f32(v90, vmulq_f32(v91, v88));
      v93 = *((float32x4_t *)a2 + 46);
      v94 = *((float32x4_t *)a2 + 47);
      v95 = vaddq_f32(vaddq_f32(v93, vmulq_f32(v94, v89)), vmulq_f32(vmulq_f32(v89, v89), vaddq_f32(v90, vmulq_f32(v91, v89))));
      v96 = *((float32x4_t *)a2 + 48);
      v97 = vaddq_f32(v34, vmulq_f32(v88, vaddq_f32(v96, vmulq_f32(v88, vaddq_f32(vaddq_f32(v93, vmulq_f32(v88, v94)), vmulq_f32(vmulq_f32(v88, v88), v92))))));
      v98 = vaddq_f32(v34, vmulq_f32(v89, vaddq_f32(v96, vmulq_f32(v89, v95))));
      v99 = vaddq_s32(v36, vcvtq_s32_f32(v86));
      v100 = vmulq_f32(v98, (float32x4_t)vshlq_n_s32(vaddq_s32(v36, vcvtq_s32_f32(v87)), 0x17uLL));
      v101 = *((float32x4_t *)a2 + 110);
      v102 = (int8x16_t)vmulq_f32(v101, vmulq_f32(v97, (float32x4_t)vshlq_n_s32(v99, 0x17uLL)));
      v103 = *((float32x4_t *)a2 + 111);
      v104 = (int8x16_t)vmulq_f32(v101, v100);
      v105 = *((float32x4_t *)a2 + 112);
      v106 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, veorq_s8(vandq_s8(v67, (int8x16_t)v31), vbslq_s8((int8x16_t)vcgtq_f32(v33, vsubq_f32(v37, v105)), (int8x16_t)vmulq_f32(v37, v103), v102)));
      v107 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v28, veorq_s8(vandq_s8(v67, (int8x16_t)v32), vbslq_s8((int8x16_t)vcgtq_f32(v33, vsubq_f32(v38, v105)), (int8x16_t)vmulq_f32(v38, v103), v104)));
      v108 = (int8x16_t *)(v6 + v11);
      v108[-1] = vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v106, v106, 3));
      *v108 = vbslq_s8(v14, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v107, v107, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v109 = -v10;
    if (v109 >= v5)
      goto LABEL_3;
LABEL_10:
    v110 = 16 * v109;
    v111 = *(float32x4_t *)(v7 + v110);
    v112 = *((int8x16_t *)a2 + 15);
    v113 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v111, 3), *((float32x4_t *)a2 + 16));
    v114 = vrecpeq_f32(v113);
    v115 = vmulq_f32(v114, vrecpsq_f32(v114, v113));
    v116 = vmulq_f32(v111, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v115, vrecpsq_f32(v115, v113))), *((int8x16_t *)a2 + 3)));
    v117 = (float32x4_t)vbslq_s8(v112, (int8x16_t)v116, (int8x16_t)vmaxq_f32(v116, *((float32x4_t *)a2 + 113)));
    v118 = *((float32x4_t *)a2 + 75);
    v119 = *((float32x4_t *)a2 + 5);
    v120 = vmulq_f32(v117, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v118, v117), *((int8x16_t *)a2 + 34), (int8x16_t)v119));
    v121 = *((float32x4_t *)a2 + 109);
    v122 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v119, (int8x16_t)vceqq_f32(v121, v118)), v118), (int8x16_t)v119, (int8x16_t)vaddq_f32(vminq_f32(v120, *((float32x4_t *)a2 + 114)), *((float32x4_t *)a2 + 108)));
    v123 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v122), (int8x16_t)v119);
    v124 = (float32x4_t)vandq_s8((int8x16_t)v119, (int8x16_t)vcgtq_f32(v123, *((float32x4_t *)a2 + 23)));
    v125 = vsubq_f32(vsubq_f32(v123, v119), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v124), v123));
    v126 = vmulq_f32(v125, v125);
    v127 = vmaxq_f32(vmulq_f32(v121, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v122, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v122))), *((float32x4_t *)a2 + 22)), v124), vmulq_f32(v125, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v125, vaddq_f32(
                         vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v125)),
                         vmulq_f32(v126, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v125)), vmulq_f32(v126, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v125))))))))))), *((float32x4_t *)a2 + 29));
    v128 = vcvtq_f32_s32(vcvtq_s32_f32(v127));
    v129 = vsubq_f32(v128, (float32x4_t)vandq_s8((int8x16_t)v119, (int8x16_t)vcgtq_f32(v128, v127)));
    v130 = vsubq_f32(v127, v129);
    v131 = (float32x4_t)vbslq_s8(v112, (int8x16_t)v116, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v117), vbslq_s8((int8x16_t)vcgtq_f32(v118, vsubq_f32(v120, *((float32x4_t *)a2 + 112))), (int8x16_t)vmulq_f32(v120, *((float32x4_t *)a2 + 111)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 110), vmulq_f32(vaddq_f32(v119, vmulq_f32(v130, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v130, vaddq_f32(
                                                       vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v130)), vmulq_f32(vmulq_f32(v130, v130), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v130)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v129)), 0x17uLL))))));
    *(int8x16_t *)(v6 + v110) = vbslq_s8(v112, (int8x16_t)v116, (int8x16_t)vmulq_laneq_f32(v131, v131, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getquicktime_fast_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  float32x4_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t *v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  int8x16_t *v50;
  int8x16_t *v51;
  float32x4_t v52;
  int8x16_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  int8x16_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v57 = 0;
        v58 = 16 * v8;
        v59 = 16 * v7;
        v60 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v61 = 0;
          do
          {
            v62 = *((int8x16_t *)a2 + 15);
            v63 = vmulq_f32(v5[v61 / 0x10], (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5[v61 / 0x10], 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v64 = vminq_f32(vmaxq_f32(v63, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v65 = (float32x4_t)vbslq_s8(v62, (int8x16_t)v63, (int8x16_t)vmulq_f32(v64, vminq_f32(vrsqrteq_f32(v64), *((float32x4_t *)a2 + 73))));
            v6[v61 / 0x10] = vbslq_s8(v62, (int8x16_t)v63, (int8x16_t)vmulq_laneq_f32(v65, v65, 3));
            v61 += 16;
          }
          while (v60 != v61);
          ++v57;
          v5 = (float32x4_t *)((char *)v5 + v58);
          v6 = (int8x16_t *)((char *)v6 + v59);
        }
        while (v57 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v5[v17 - 2];
          v19 = v5[v17 - 1];
          v20 = v5[v17];
          v21 = v5[v17 + 1];
          v23 = *((int8x16_t *)a2 + 15);
          v22 = *((float32x4_t *)a2 + 16);
          v24 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 3), v22);
          v25 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 3), v22));
          v26 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3), v22));
          v27 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 3), v22));
          v28 = *((int8x16_t *)a2 + 17);
          v29 = vandq_s8(v28, v25);
          v30 = vandq_s8(v28, v26);
          v31 = vandq_s8(v28, v27);
          v32 = vandq_s8(v28, (int8x16_t)vrecpeq_f32(v24));
          v33 = *((int8x16_t *)a2 + 3);
          v34 = vmulq_f32(v18, (float32x4_t)vorrq_s8(v29, v33));
          v35 = vmulq_f32(v19, (float32x4_t)vorrq_s8(v30, v33));
          v36 = vmulq_f32(v20, (float32x4_t)vorrq_s8(v31, v33));
          v37 = vmulq_f32(v21, (float32x4_t)vorrq_s8(v32, v33));
          v38 = *((float32x4_t *)a2 + 75);
          v39 = *((float32x4_t *)a2 + 5);
          v40 = vminq_f32(vmaxq_f32(v34, v38), v39);
          v41 = vminq_f32(vmaxq_f32(v35, v38), v39);
          v42 = vminq_f32(vmaxq_f32(v36, v38), v39);
          v43 = vminq_f32(vmaxq_f32(v37, v38), v39);
          v44 = *((float32x4_t *)a2 + 73);
          v45 = v16;
          v46 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v34, (int8x16_t)vmulq_f32(v40, vminq_f32(vrsqrteq_f32(v40), v44)));
          v47 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v35, (int8x16_t)vmulq_f32(v41, vminq_f32(vrsqrteq_f32(v41), v44)));
          v48 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v36, (int8x16_t)vmulq_f32(v42, vminq_f32(vrsqrteq_f32(v42), v44)));
          v49 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v37, (int8x16_t)vmulq_f32(v43, vminq_f32(vrsqrteq_f32(v43), v44)));
          v50 = v15;
          v51 = &v6[v17];
          v14 += 4;
          v51[-2] = vbslq_s8(v23, (int8x16_t)v34, (int8x16_t)vmulq_laneq_f32(v46, v46, 3));
          v51[-1] = vbslq_s8(v23, (int8x16_t)v35, (int8x16_t)vmulq_laneq_f32(v47, v47, 3));
          *v51 = vbslq_s8(v23, (int8x16_t)v36, (int8x16_t)vmulq_laneq_f32(v48, v48, 3));
          v51[1] = vbslq_s8(v23, (int8x16_t)v37, (int8x16_t)vmulq_laneq_f32(v49, v49, 3));
          v17 += 4;
          v16 += 4;
          v15 = v50 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v52 = *v45++;
            v53 = *((int8x16_t *)a2 + 15);
            v54 = vmulq_f32(v52, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v55 = vminq_f32(vmaxq_f32(v54, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v56 = (float32x4_t)vbslq_s8(v53, (int8x16_t)v54, (int8x16_t)vmulq_f32(v55, vminq_f32(vrsqrteq_f32(v55), *((float32x4_t *)a2 + 73))));
            *v50++ = vbslq_s8(v53, (int8x16_t)v54, (int8x16_t)vmulq_laneq_f32(v56, v56, 3));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getquicktime_fixed_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int8x16_t *v86;
  uint64_t v87;
  int8x16_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 6);
    while (v5 < 4)
    {
      LODWORD(v87) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v7 += v8;
      v6 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 32;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 32);
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v14 = *(float32x4_t *)(v7 + v11);
      v15 = *(float32x4_t *)(v7 + v11 + 16);
      v17 = *((int8x16_t *)a2 + 15);
      v16 = *((float32x4_t *)a2 + 16);
      v18 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v16));
      v19 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v16));
      v20 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v16));
      v21 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16));
      v23 = *((int8x16_t *)a2 + 17);
      v22 = *((float32x4_t *)a2 + 18);
      v24 = vandq_s8(v23, (int8x16_t)vmulq_f32(v18, v22));
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v19, v22));
      v26 = vandq_s8(v23, (int8x16_t)vmulq_f32(v20, v22));
      v27 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, v22));
      v28 = *((int8x16_t *)a2 + 3);
      v29 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v28));
      v30 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v28));
      v31 = vmulq_f32(v14, (float32x4_t)vorrq_s8(v26, v28));
      v32 = vmulq_f32(v15, (float32x4_t)vorrq_s8(v27, v28));
      v33 = *((float32x4_t *)a2 + 75);
      v34 = *((float32x4_t *)a2 + 5);
      v35 = *((float32x4_t *)a2 + 6);
      v36 = vmulq_f32(v35, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v29, v33), v34)));
      v37 = vmulq_f32(v35, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v30, v33), v34)));
      v38 = vmulq_f32(v35, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v31, v33), v34)));
      v39 = vmulq_f32(v35, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v32, v33), v34)));
      v40 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
      v41 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
      v42 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
      v43 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v44 = *((float32x4_t *)a2 + 7);
      v45 = *((float32x4_t *)a2 + 8);
      v46 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v36, v40), v44));
      v47 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v37, v41), v44));
      v48 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v38, v42), v44));
      v49 = vrsqrteq_f32(vaddq_f32(v44, vsubq_f32(v39, v43)));
      v50 = vaddq_f32(v45, v40);
      v51 = vaddq_f32(v45, v41);
      v52 = vaddq_f32(v45, v42);
      v53 = vaddq_f32(v45, v43);
      v54 = *((float32x4_t *)a2 + 9);
      v55 = *((float32x4_t *)a2 + 10);
      v56 = vsubq_f32(v50, vmulq_f32(v46, v54));
      v57 = *((float32x4_t *)a2 + 115);
      v58 = vmulq_f32(v57, v56);
      v59 = vmulq_f32(v57, vsubq_f32(v51, vmulq_f32(v47, v54)));
      v60 = vmulq_f32(v57, vsubq_f32(v52, vmulq_f32(v48, v54)));
      v61 = vmulq_f32(v57, vsubq_f32(v53, vmulq_f32(v49, v54)));
      v62 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v63 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v64 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v65 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v66 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v62, v58)));
      v67 = vsubq_f32(v63, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v63, v59)));
      v68 = vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v64, v60)));
      v69 = vsubq_f32(v65, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v65, v61)));
      v70 = *((float32x4_t *)a2 + 11);
      v71 = *((float32x4_t *)a2 + 12);
      v72 = vmulq_f32(vrecpeq_f32(vsubq_f32(v70, vsubq_f32(v58, v66))), v71);
      v73 = vmulq_f32(vrecpeq_f32(vsubq_f32(v70, vsubq_f32(v59, v67))), v71);
      v74 = vmulq_f32(vrecpeq_f32(vsubq_f32(v70, vsubq_f32(v60, v68))), v71);
      v75 = vmulq_f32(vrecpeq_f32(vsubq_f32(v70, vsubq_f32(v61, v69))), v71);
      v76 = vmaxq_f32(vaddq_f32(vaddq_f32(v66, v55), vmulq_f32(v72, v72)), v33);
      v77 = vmaxq_f32(vaddq_f32(vaddq_f32(v55, v67), vmulq_f32(v73, v73)), v33);
      v78 = vmaxq_f32(vaddq_f32(vaddq_f32(v55, v68), vmulq_f32(v74, v74)), v33);
      v79 = vmaxq_f32(vaddq_f32(vaddq_f32(v55, v69), vmulq_f32(v75, v75)), v33);
      v80 = *((float32x4_t *)a2 + 13);
      v81 = *((float32x4_t *)a2 + 14);
      v82 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v29, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v76, v80), v81)));
      v83 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v30, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v77, v80), v81)));
      v84 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v31, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v78, v80), v81)));
      v85 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v32, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v79, v80), v81)));
      v86 = (int8x16_t *)(v6 + v11);
      v86[-2] = vbslq_s8(v17, (int8x16_t)v29, (int8x16_t)vmulq_laneq_f32(v82, v82, 3));
      v86[-1] = vbslq_s8(v17, (int8x16_t)v30, (int8x16_t)vmulq_laneq_f32(v83, v83, 3));
      *v86 = vbslq_s8(v17, (int8x16_t)v31, (int8x16_t)vmulq_laneq_f32(v84, v84, 3));
      v86[1] = vbslq_s8(v17, (int8x16_t)v32, (int8x16_t)vmulq_laneq_f32(v85, v85, 3));
      v10 -= 4;
      v11 += 64;
    }
    while (v5 + v10 > 3);
    LODWORD(v87) = -v10;
    if ((int)v87 >= v5)
      goto LABEL_3;
LABEL_10:
    v87 = v87;
    do
    {
      v88 = *((int8x16_t *)a2 + 15);
      v89 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v87), (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v7 + 16 * v87), 3), *((float32x4_t *)a2 + 16))), *((float32x4_t *)a2 + 18))), *((int8x16_t *)a2 + 3)));
      v90 = *((float32x4_t *)a2 + 75);
      v91 = *((float32x4_t *)a2 + 5);
      v92 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v89, v90), v91)));
      v93 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
      v94 = vmulq_f32(*((float32x4_t *)a2 + 115), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v93), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v92, v93))), *((float32x4_t *)a2 + 9))));
      v95 = vcvtq_f32_s32(vcvtq_s32_f32(v94));
      v96 = vsubq_f32(v95, (float32x4_t)vandq_s8((int8x16_t)v91, (int8x16_t)vcgtq_f32(v95, v94)));
      v97 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v94, v96))), *((float32x4_t *)a2 + 12));
      v98 = (float32x4_t)vbslq_s8(v88, (int8x16_t)v89, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v96), vmulq_f32(v97, v97)), v90), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))));
      *(int8x16_t *)(v6 + 16 * v87++) = vbslq_s8(v88, (int8x16_t)v89, (int8x16_t)vmulq_laneq_f32(v98, v98, 3));
    }
    while (v87 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getquicktime_nice_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  float32x4_t v33;
  int8x16_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  int32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  int8x16_t *v91;
  int v92;
  uint64_t v93;
  float32x4_t v94;
  int8x16_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v92 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = *((int8x16_t *)a2 + 17);
      v24 = vandq_s8(v23, v22);
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = (float32x4_t)vorrq_s8(v25, v26);
      v28 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v26));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = vmulq_f32(v13, v27);
      v31 = *((float32x4_t *)a2 + 5);
      v32 = (int8x16_t)vminq_f32(vmaxq_f32(v28, v29), v31);
      v33 = *((float32x4_t *)a2 + 115);
      v34 = (int8x16_t)vminq_f32(vmaxq_f32(v30, v29), v31);
      v35 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vceqq_f32(v33, v29)), v29);
      v36 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v31, v32);
      v37 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v31, v34);
      v39 = *((int8x16_t *)a2 + 19);
      v38 = *((float32x4_t *)a2 + 20);
      v40 = (float32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)v36), (int8x16_t)v31);
      v41 = (float32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)v37), (int8x16_t)v31);
      v42 = *((int8x16_t *)a2 + 21);
      v43 = *((float32x4_t *)a2 + 22);
      v44 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v38, v37)));
      v45 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v36, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v38, v36))), v43);
      v46 = *((float32x4_t *)a2 + 23);
      v47 = *((float32x4_t *)a2 + 24);
      v48 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v40, v46));
      v49 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v41, v46));
      v50 = vaddq_f32(v45, v48);
      v51 = vaddq_f32(vsubq_f32(v44, v43), v49);
      v52 = vsubq_f32(vsubq_f32(v40, v31), vmulq_f32(vmulq_f32(v47, v48), v40));
      v53 = vsubq_f32(vsubq_f32(v41, v31), vmulq_f32(vmulq_f32(v47, v49), v41));
      v54 = vmulq_f32(v52, v52);
      v55 = *((float32x4_t *)a2 + 37);
      v56 = *((float32x4_t *)a2 + 38);
      v57 = *((float32x4_t *)a2 + 39);
      v58 = *((float32x4_t *)a2 + 40);
      v59 = vaddq_f32(v55, vmulq_f32(v56, v52));
      v60 = vaddq_f32(v57, vmulq_f32(v58, v52));
      v61 = vaddq_f32(v57, vmulq_f32(v58, v53));
      v62 = vaddq_f32(v55, vmulq_f32(v56, v53));
      v63 = *((float32x4_t *)a2 + 41);
      v64 = *((float32x4_t *)a2 + 42);
      v65 = vaddq_f32(v63, vmulq_f32(v64, v52));
      v66 = vaddq_f32(v63, vmulq_f32(v64, v53));
      v67 = vmulq_f32(v53, v53);
      v68 = vaddq_f32(v65, vmulq_f32(v54, vaddq_f32(v59, vmulq_f32(v54, v60))));
      v69 = vaddq_f32(v66, vmulq_f32(v67, vaddq_f32(v62, vmulq_f32(v67, v61))));
      v70 = *((float32x4_t *)a2 + 43);
      v71 = *((float32x4_t *)a2 + 44);
      v72 = vmulq_f32(v33, vaddq_f32(v51, vmulq_f32(v53, vaddq_f32(v70, vmulq_f32(v53, v69)))));
      v73 = *((float32x4_t *)a2 + 29);
      v74 = vmaxq_f32(vmulq_f32(v33, vaddq_f32(v50, vmulq_f32(v52, vaddq_f32(v70, vmulq_f32(v52, v68))))), v73);
      v75 = vmaxq_f32(v72, v73);
      v76 = vcvtq_f32_s32(vcvtq_s32_f32(v74));
      v77 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
      v78 = vsubq_f32(v76, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v76, v74)));
      v79 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v77, v75)));
      v80 = vsubq_f32(v74, v78);
      v81 = vsubq_f32(v75, v79);
      v82 = *((float32x4_t *)a2 + 45);
      v83 = *((float32x4_t *)a2 + 46);
      v84 = vaddq_f32(v71, vmulq_f32(v82, v80));
      v85 = vaddq_f32(v71, vmulq_f32(v82, v81));
      v86 = *((float32x4_t *)a2 + 47);
      v87 = *((float32x4_t *)a2 + 48);
      v88 = *((int32x4_t *)a2 + 33);
      v89 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_f32(vaddq_f32(v31, vmulq_f32(v80, vaddq_f32(v87, vmulq_f32(v80, vaddq_f32(vaddq_f32(v83, vmulq_f32(v80, v86)), vmulq_f32(vmulq_f32(v80, v80), v84)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v88, vcvtq_s32_f32(v78)), 0x17uLL)));
      v90 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v30, (int8x16_t)vmulq_f32(vaddq_f32(v31, vmulq_f32(v81, vaddq_f32(v87, vmulq_f32(v81, vaddq_f32(vaddq_f32(v83, vmulq_f32(v86, v81)), vmulq_f32(vmulq_f32(v81, v81), v85)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v88, vcvtq_s32_f32(v79)), 0x17uLL)));
      v91 = (int8x16_t *)(v6 + v11);
      v91[-1] = vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v89, v89, 3));
      *v91 = vbslq_s8(v15, (int8x16_t)v30, (int8x16_t)vmulq_laneq_f32(v90, v90, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v92 = -v10;
    if (v92 >= v5)
      goto LABEL_3;
LABEL_10:
    v93 = 16 * v92;
    v94 = *(float32x4_t *)(v7 + v93);
    v95 = *((int8x16_t *)a2 + 15);
    v96 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 3), *((float32x4_t *)a2 + 16));
    v97 = vrecpeq_f32(v96);
    v98 = vmulq_f32(v97, vrecpsq_f32(v97, v96));
    v99 = vmulq_f32(v94, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v98, vrecpsq_f32(v98, v96))), *((int8x16_t *)a2 + 3)));
    v100 = *((float32x4_t *)a2 + 5);
    v101 = *((float32x4_t *)a2 + 115);
    v102 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v100, (int8x16_t)vceqq_f32(v101, *((float32x4_t *)a2 + 75))), *((float32x4_t *)a2 + 75)), (int8x16_t)v100, (int8x16_t)vminq_f32(vmaxq_f32(v99, *((float32x4_t *)a2 + 75)), v100));
    v103 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v102), (int8x16_t)v100);
    v104 = (float32x4_t)vandq_s8((int8x16_t)v100, (int8x16_t)vcgtq_f32(v103, *((float32x4_t *)a2 + 23)));
    v105 = vsubq_f32(vsubq_f32(v103, v100), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v104), v103));
    v106 = vmulq_f32(v105, v105);
    v107 = vmaxq_f32(vmulq_f32(v101, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v102, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v102))), *((float32x4_t *)a2 + 22)), v104), vmulq_f32(v105, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v105, vaddq_f32(
                         vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v105)),
                         vmulq_f32(v106, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v105)), vmulq_f32(v106, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v105))))))))))), *((float32x4_t *)a2 + 29));
    v108 = vcvtq_f32_s32(vcvtq_s32_f32(v107));
    v109 = vsubq_f32(v108, (float32x4_t)vandq_s8((int8x16_t)v100, (int8x16_t)vcgtq_f32(v108, v107)));
    v110 = vsubq_f32(v107, v109);
    v111 = (float32x4_t)vbslq_s8(v95, (int8x16_t)v99, (int8x16_t)vmulq_f32(vaddq_f32(v100, vmulq_f32(v110, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v110, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v110)), vmulq_f32(vmulq_f32(v110, v110), vaddq_f32(*((float32x4_t *)a2 + 44),
                                                     vmulq_f32(*((float32x4_t *)a2 + 45), v110)))))))),
                                       (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v109)), 0x17uLL)));
    *(int8x16_t *)(v6 + v93) = vbslq_s8(v95, (int8x16_t)v99, (int8x16_t)vmulq_laneq_f32(v111, v111, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getquicktime_half_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int32x4_t v69;
  int32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int8x16_t *v73;
  int v74;
  uint64_t v75;
  float32x4_t v76;
  int8x16_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v74 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23));
      v26 = *((float32x4_t *)a2 + 75);
      v27 = *((float32x4_t *)a2 + 5);
      v28 = vminq_f32(vmaxq_f32(v24, v26), v27);
      v29 = vminq_f32(vmaxq_f32(v25, v26), v27);
      v30 = *((int8x16_t *)a2 + 19);
      v31 = *((float32x4_t *)a2 + 20);
      v32 = (float32x4_t)vorrq_s8(vandq_s8(v30, (int8x16_t)v28), (int8x16_t)v27);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v30, (int8x16_t)v29), (int8x16_t)v27);
      v34 = *((int8x16_t *)a2 + 21);
      v35 = *((float32x4_t *)a2 + 22);
      v36 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v31, v29)));
      v37 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v31, v28))), v35);
      v38 = *((float32x4_t *)a2 + 23);
      v39 = *((float32x4_t *)a2 + 24);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v32, v38));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v33, v38));
      v42 = vaddq_f32(v37, v40);
      v43 = vaddq_f32(vsubq_f32(v36, v35), v41);
      v44 = vsubq_f32(vsubq_f32(v32, v27), vmulq_f32(vmulq_f32(v39, v40), v32));
      v45 = vsubq_f32(vsubq_f32(v33, v27), vmulq_f32(vmulq_f32(v39, v41), v33));
      v46 = *((float32x4_t *)a2 + 25);
      v47 = *((float32x4_t *)a2 + 26);
      v48 = vaddq_f32(v46, vmulq_f32(v47, v44));
      v49 = vaddq_f32(v46, vmulq_f32(v47, v45));
      v50 = *((float32x4_t *)a2 + 27);
      v51 = *((float32x4_t *)a2 + 28);
      v52 = *((float32x4_t *)a2 + 115);
      v53 = vmulq_f32(v52, vaddq_f32(v42, vmulq_f32(v44, vaddq_f32(vaddq_f32(v50, vmulq_f32(v44, v51)), vmulq_f32(vmulq_f32(v44, v44), v48)))));
      v54 = vmulq_f32(v52, vaddq_f32(v43, vmulq_f32(v45, vaddq_f32(vaddq_f32(v50, vmulq_f32(v45, v51)), vmulq_f32(vmulq_f32(v45, v45), v49)))));
      v55 = *((float32x4_t *)a2 + 29);
      v56 = *((float32x4_t *)a2 + 30);
      v57 = vmaxq_f32(v53, v55);
      v58 = vmaxq_f32(v54, v55);
      v59 = vcvtq_f32_s32(vcvtq_s32_f32(v57));
      v60 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v61 = vsubq_f32(v59, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v59, v57)));
      v62 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v60, v58)));
      v63 = vsubq_f32(v57, v61);
      v64 = vsubq_f32(v58, v62);
      v65 = *((float32x4_t *)a2 + 31);
      v66 = *((float32x4_t *)a2 + 32);
      v67 = vmulq_f32(v64, vaddq_f32(v66, vmulq_f32(v64, vaddq_f32(v56, vmulq_f32(v65, v64)))));
      v68 = vaddq_f32(v27, vmulq_f32(v63, vaddq_f32(v66, vmulq_f32(v63, vaddq_f32(v56, vmulq_f32(v65, v63))))));
      v69 = vcvtq_s32_f32(v62);
      v70 = *((int32x4_t *)a2 + 33);
      v71 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_f32(v68, (float32x4_t)vshlq_n_s32(vaddq_s32(v70, vcvtq_s32_f32(v61)), 0x17uLL)));
      v72 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vmulq_f32(vaddq_f32(v27, v67), (float32x4_t)vshlq_n_s32(vaddq_s32(v70, v69), 0x17uLL)));
      v73 = (int8x16_t *)(v6 + v11);
      v73[-1] = vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v71, v71, 3));
      *v73 = vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v72, v72, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v74 = -v10;
    if (v74 >= v5)
      goto LABEL_3;
LABEL_10:
    v75 = 16 * v74;
    v76 = *(float32x4_t *)(v7 + v75);
    v77 = *((int8x16_t *)a2 + 15);
    v78 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 3), *((float32x4_t *)a2 + 16));
    v79 = vmulq_f32(vrecpeq_f32(v78), *((float32x4_t *)a2 + 18));
    v80 = vmulq_f32(v76, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v79, vrecpsq_f32(v79, v78))), *((int8x16_t *)a2 + 3)));
    v81 = *((float32x4_t *)a2 + 5);
    v82 = vminq_f32(vmaxq_f32(v80, *((float32x4_t *)a2 + 75)), v81);
    v83 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v82), (int8x16_t)v81);
    v84 = (float32x4_t)vandq_s8((int8x16_t)v81, (int8x16_t)vcgtq_f32(v83, *((float32x4_t *)a2 + 23)));
    v85 = vsubq_f32(vsubq_f32(v83, v81), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v84), v83));
    v86 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 115), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v82, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v82))), *((float32x4_t *)a2 + 22)), v84), vmulq_f32(v85, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v85, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v85, v85), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v85))))))),
            *((float32x4_t *)a2 + 29));
    v87 = vcvtq_f32_s32(vcvtq_s32_f32(v86));
    v88 = vsubq_f32(v87, (float32x4_t)vandq_s8((int8x16_t)v81, (int8x16_t)vcgtq_f32(v87, v86)));
    v89 = vsubq_f32(v86, v88);
    v90 = (float32x4_t)vbslq_s8(v77, (int8x16_t)v80, (int8x16_t)vmulq_f32(vaddq_f32(v81, vmulq_f32(v89, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v89, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v89)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v88)), 0x17uLL)));
    *(int8x16_t *)(v6 + v75) = vbslq_s8(v77, (int8x16_t)v80, (int8x16_t)vmulq_laneq_f32(v90, v90, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getquicktime_halfTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  int32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  int8x16_t v79;
  float32x4_t v80;
  float32x4_t v81;
  int8x16_t *v82;
  int v83;
  uint64_t v84;
  float32x4_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v83 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23));
      v26 = *((float32x4_t *)a2 + 82);
      v27 = (int8x16_t)vmaxq_f32(v25, v26);
      v28 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmaxq_f32(v24, v26));
      v29 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, v27);
      v30 = *((float32x4_t *)a2 + 75);
      v31 = *((float32x4_t *)a2 + 5);
      v33 = *((int32x4_t *)a2 + 33);
      v32 = *((int8x16_t *)a2 + 34);
      v34 = vmulq_f32(v28, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v30, v28), v32, (int8x16_t)v31));
      v35 = vmulq_f32(v29, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v30, v29), v32, (int8x16_t)v31));
      v36 = *((float32x4_t *)a2 + 84);
      v37 = vminq_f32(v34, v36);
      v38 = vminq_f32(v35, v36);
      v39 = *((int8x16_t *)a2 + 19);
      v40 = *((float32x4_t *)a2 + 20);
      v41 = (float32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)v37), (int8x16_t)v31);
      v42 = *((int8x16_t *)a2 + 21);
      v43 = *((float32x4_t *)a2 + 22);
      v44 = (float32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)v38), (int8x16_t)v31);
      v45 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v38, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v40, v38)));
      v46 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v40, v37))), v43);
      v47 = *((float32x4_t *)a2 + 23);
      v48 = *((float32x4_t *)a2 + 24);
      v49 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v41, v47));
      v50 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v44, v47));
      v51 = vaddq_f32(v46, v49);
      v52 = vmulq_f32(v48, v49);
      v53 = vmulq_f32(vmulq_f32(v48, v50), v44);
      v54 = vaddq_f32(vsubq_f32(v45, v43), v50);
      v55 = vsubq_f32(vsubq_f32(v41, v31), vmulq_f32(v52, v41));
      v56 = vsubq_f32(vsubq_f32(v44, v31), v53);
      v57 = *((float32x4_t *)a2 + 25);
      v58 = *((float32x4_t *)a2 + 26);
      v59 = *((float32x4_t *)a2 + 27);
      v60 = *((float32x4_t *)a2 + 28);
      v61 = vaddq_f32(v54, vmulq_f32(v56, vaddq_f32(vaddq_f32(v59, vmulq_f32(v56, v60)), vmulq_f32(vmulq_f32(v56, v56), vaddq_f32(v57, vmulq_f32(v58, v56))))));
      v62 = *((float32x4_t *)a2 + 115);
      v63 = vmulq_f32(v62, vaddq_f32(v51, vmulq_f32(v55, vaddq_f32(vaddq_f32(v59, vmulq_f32(v55, v60)), vmulq_f32(vmulq_f32(v55, v55), vaddq_f32(v57, vmulq_f32(v58, v55)))))));
      v64 = vmulq_f32(v62, v61);
      v65 = *((float32x4_t *)a2 + 29);
      v66 = *((float32x4_t *)a2 + 30);
      v67 = vmaxq_f32(v63, v65);
      v68 = vmaxq_f32(v64, v65);
      v69 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
      v70 = vcvtq_f32_s32(vcvtq_s32_f32(v68));
      v71 = vsubq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v69, v67)));
      v72 = vsubq_f32(v70, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v70, v68)));
      v73 = vsubq_f32(v67, v71);
      v74 = vsubq_f32(v68, v72);
      v75 = *((float32x4_t *)a2 + 31);
      v76 = *((float32x4_t *)a2 + 32);
      v77 = vaddq_f32(v31, vmulq_f32(v73, vaddq_f32(v76, vmulq_f32(v73, vaddq_f32(v66, vmulq_f32(v75, v73))))));
      v78 = vaddq_f32(v31, vmulq_f32(v74, vaddq_f32(v76, vmulq_f32(v74, vaddq_f32(v66, vmulq_f32(v75, v74))))));
      v79 = *((int8x16_t *)a2 + 36);
      v80 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v24, veorq_s8(vandq_s8(v79, (int8x16_t)v28), (int8x16_t)vmulq_f32(v77, (float32x4_t)vshlq_n_s32(vaddq_s32(v33, vcvtq_s32_f32(v71)), 0x17uLL))));
      v81 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, veorq_s8(vandq_s8(v79, (int8x16_t)v29), (int8x16_t)vmulq_f32(v78, (float32x4_t)vshlq_n_s32(vaddq_s32(v33, vcvtq_s32_f32(v72)), 0x17uLL))));
      v82 = (int8x16_t *)(v6 + v11);
      v82[-1] = vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      *v82 = vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v83 = -v10;
    if (v83 >= v5)
      goto LABEL_3;
LABEL_10:
    v84 = 16 * v83;
    v85 = *(float32x4_t *)(v7 + v84);
    v86 = *((int8x16_t *)a2 + 15);
    v87 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v85, 3), *((float32x4_t *)a2 + 16));
    v88 = vmulq_f32(vrecpeq_f32(v87), *((float32x4_t *)a2 + 18));
    v89 = vmulq_f32(v85, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v88, vrecpsq_f32(v88, v87))), *((int8x16_t *)a2 + 3)));
    v90 = (float32x4_t)vbslq_s8(v86, (int8x16_t)v89, (int8x16_t)vmaxq_f32(v89, *((float32x4_t *)a2 + 82)));
    v91 = *((float32x4_t *)a2 + 5);
    v92 = vminq_f32(vmulq_f32(v90, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 75), v90), *((int8x16_t *)a2 + 34), (int8x16_t)v91)), *((float32x4_t *)a2 + 84));
    v93 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v92), (int8x16_t)v91);
    v94 = (float32x4_t)vandq_s8((int8x16_t)v91, (int8x16_t)vcgtq_f32(v93, *((float32x4_t *)a2 + 23)));
    v95 = vsubq_f32(vsubq_f32(v93, v91), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v94), v93));
    v96 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 115), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v92, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v92))), *((float32x4_t *)a2 + 22)), v94), vmulq_f32(v95, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v95, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v95, v95), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v95))))))),
            *((float32x4_t *)a2 + 29));
    v97 = vcvtq_f32_s32(vcvtq_s32_f32(v96));
    v98 = vsubq_f32(v97, (float32x4_t)vandq_s8((int8x16_t)v91, (int8x16_t)vcgtq_f32(v97, v96)));
    v99 = vsubq_f32(v96, v98);
    v100 = (float32x4_t)vbslq_s8(v86, (int8x16_t)v89, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v90), (int8x16_t)vmulq_f32(vaddq_f32(v91, vmulq_f32(v99, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v99, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v99)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v98)), 0x17uLL))));
    *(int8x16_t *)(v6 + v84) = vbslq_s8(v86, (int8x16_t)v89, (int8x16_t)vmulq_laneq_f32(v100, v100, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getquicktime_niceTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  int32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  int8x16_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  int8x16_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int8x16_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  int8x16_t *v96;
  int v97;
  uint64_t v98;
  float32x4_t v99;
  int8x16_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v97 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = *((int8x16_t *)a2 + 17);
      v24 = vandq_s8(v23, v22);
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 82);
      v30 = (int8x16_t)vmaxq_f32(v28, v29);
      v31 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmaxq_f32(v27, v29));
      v32 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v28, v30);
      v33 = *((float32x4_t *)a2 + 75);
      v34 = *((float32x4_t *)a2 + 5);
      v36 = *((int32x4_t *)a2 + 33);
      v35 = *((int8x16_t *)a2 + 34);
      v37 = *((float32x4_t *)a2 + 84);
      v38 = (int8x16_t)vminq_f32(vmulq_f32(v31, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v33, v31), v35, (int8x16_t)v34)), v37);
      v39 = (int8x16_t)vminq_f32(vmulq_f32(v32, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v33, v32), v35, (int8x16_t)v34)), v37);
      v40 = *((float32x4_t *)a2 + 115);
      v41 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vceqq_f32(v40, v33)), v33);
      v42 = (float32x4_t)vbslq_s8(v41, (int8x16_t)v34, v38);
      v43 = (float32x4_t)vbslq_s8(v41, (int8x16_t)v34, v39);
      v44 = *((int8x16_t *)a2 + 19);
      v45 = *((float32x4_t *)a2 + 20);
      v46 = (float32x4_t)vorrq_s8(vandq_s8(v44, (int8x16_t)v42), (int8x16_t)v34);
      v47 = (float32x4_t)vorrq_s8(vandq_s8(v44, (int8x16_t)v43), (int8x16_t)v34);
      v48 = *((int8x16_t *)a2 + 21);
      v49 = *((float32x4_t *)a2 + 22);
      v50 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v43, 0x17uLL)), (float32x4_t)vandq_s8(v48, (int8x16_t)vcgtq_f32(v45, v43)));
      v51 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v42, 0x17uLL)), (float32x4_t)vandq_s8(v48, (int8x16_t)vcgtq_f32(v45, v42))), v49);
      v52 = *((float32x4_t *)a2 + 23);
      v53 = *((float32x4_t *)a2 + 24);
      v54 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v46, v52));
      v55 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v47, v52));
      v56 = vaddq_f32(v51, v54);
      v57 = vaddq_f32(vsubq_f32(v50, v49), v55);
      v58 = vsubq_f32(vsubq_f32(v46, v34), vmulq_f32(vmulq_f32(v53, v54), v46));
      v59 = vsubq_f32(vsubq_f32(v47, v34), vmulq_f32(vmulq_f32(v53, v55), v47));
      v60 = *((float32x4_t *)a2 + 38);
      v61 = *((float32x4_t *)a2 + 39);
      v63 = *((int8x16_t *)a2 + 36);
      v62 = *((float32x4_t *)a2 + 37);
      v64 = vaddq_f32(v62, vmulq_f32(v60, v58));
      v65 = *((float32x4_t *)a2 + 40);
      v66 = *((float32x4_t *)a2 + 41);
      v67 = vaddq_f32(v61, vmulq_f32(v65, v58));
      v68 = vaddq_f32(v61, vmulq_f32(v65, v59));
      v69 = *((float32x4_t *)a2 + 42);
      v70 = *((float32x4_t *)a2 + 43);
      v71 = vaddq_f32(v62, vmulq_f32(v60, v59));
      v72 = vaddq_f32(v66, vmulq_f32(v69, v58));
      v73 = vaddq_f32(v66, vmulq_f32(v69, v59));
      v74 = vmulq_f32(v58, v58);
      v75 = vaddq_f32(v64, vmulq_f32(v74, v67));
      v76 = vmulq_f32(v59, v59);
      v77 = vaddq_f32(v57, vmulq_f32(v59, vaddq_f32(v70, vmulq_f32(v59, vaddq_f32(v73, vmulq_f32(v76, vaddq_f32(v71, vmulq_f32(v76, v68))))))));
      v78 = *((float32x4_t *)a2 + 29);
      v79 = vmaxq_f32(vmulq_f32(v40, vaddq_f32(v56, vmulq_f32(v58, vaddq_f32(v70, vmulq_f32(v58, vaddq_f32(v72, vmulq_f32(v74, v75))))))), v78);
      v80 = vmaxq_f32(vmulq_f32(v40, v77), v78);
      v81 = vcvtq_f32_s32(vcvtq_s32_f32(v79));
      v82 = vcvtq_f32_s32(vcvtq_s32_f32(v80));
      v83 = vsubq_f32(v81, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v81, v79)));
      v84 = vsubq_f32(v82, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v82, v80)));
      v85 = vsubq_f32(v79, v83);
      v86 = vsubq_f32(v80, v84);
      v87 = *((float32x4_t *)a2 + 44);
      v88 = *((float32x4_t *)a2 + 45);
      v89 = vaddq_f32(v87, vmulq_f32(v88, v85));
      v90 = *((float32x4_t *)a2 + 46);
      v91 = *((float32x4_t *)a2 + 47);
      v92 = vaddq_f32(v87, vmulq_f32(v88, v86));
      v93 = *((float32x4_t *)a2 + 48);
      v94 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, veorq_s8(vandq_s8(v63, (int8x16_t)v31), (int8x16_t)vmulq_f32(vaddq_f32(v34, vmulq_f32(v85, vaddq_f32(v93, vmulq_f32(v85, vaddq_f32(vaddq_f32(v90, vmulq_f32(v85, v91)), vmulq_f32(vmulq_f32(v85, v85), v89)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v36, vcvtq_s32_f32(v83)), 0x17uLL))));
      v95 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v28, veorq_s8(vandq_s8(v63, (int8x16_t)v32), (int8x16_t)vmulq_f32(vaddq_f32(v34, vmulq_f32(v86, vaddq_f32(v93, vmulq_f32(v86, vaddq_f32(vaddq_f32(v90, vmulq_f32(v91, v86)), vmulq_f32(vmulq_f32(v86, v86), v92)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v36, vcvtq_s32_f32(v84)), 0x17uLL))));
      v96 = (int8x16_t *)(v6 + v11);
      v96[-1] = vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v94, v94, 3));
      *v96 = vbslq_s8(v14, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v95, v95, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v97 = -v10;
    if (v97 >= v5)
      goto LABEL_3;
LABEL_10:
    v98 = 16 * v97;
    v99 = *(float32x4_t *)(v7 + v98);
    v100 = *((int8x16_t *)a2 + 15);
    v101 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v99, 3), *((float32x4_t *)a2 + 16));
    v102 = vrecpeq_f32(v101);
    v103 = vmulq_f32(v102, vrecpsq_f32(v102, v101));
    v104 = vmulq_f32(v99, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v103, vrecpsq_f32(v103, v101))), *((int8x16_t *)a2 + 3)));
    v105 = (float32x4_t)vbslq_s8(v100, (int8x16_t)v104, (int8x16_t)vmaxq_f32(v104, *((float32x4_t *)a2 + 82)));
    v106 = *((float32x4_t *)a2 + 5);
    v107 = *((float32x4_t *)a2 + 115);
    v108 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v106, (int8x16_t)vceqq_f32(v107, *((float32x4_t *)a2 + 75))), *((float32x4_t *)a2 + 75)), (int8x16_t)v106, (int8x16_t)vminq_f32(vmulq_f32(v105, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 75), v105), *((int8x16_t *)a2 + 34), (int8x16_t)v106)), *((float32x4_t *)a2 + 84)));
    v109 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v108), (int8x16_t)v106);
    v110 = (float32x4_t)vandq_s8((int8x16_t)v106, (int8x16_t)vcgtq_f32(v109, *((float32x4_t *)a2 + 23)));
    v111 = vsubq_f32(vsubq_f32(v109, v106), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v110), v109));
    v112 = vmulq_f32(v111, v111);
    v113 = vmaxq_f32(vmulq_f32(v107, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v108, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v108))), *((float32x4_t *)a2 + 22)), v110), vmulq_f32(v111, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v111, vaddq_f32(
                         vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v111)),
                         vmulq_f32(v112, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v111)), vmulq_f32(v112, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v111))))))))))), *((float32x4_t *)a2 + 29));
    v114 = vcvtq_f32_s32(vcvtq_s32_f32(v113));
    v115 = vsubq_f32(v114, (float32x4_t)vandq_s8((int8x16_t)v106, (int8x16_t)vcgtq_f32(v114, v113)));
    v116 = vsubq_f32(v113, v115);
    v117 = (float32x4_t)vbslq_s8(v100, (int8x16_t)v104, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v105), (int8x16_t)vmulq_f32(vaddq_f32(v106, vmulq_f32(v116, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v116, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v116)), vmulq_f32(vmulq_f32(v116, v116),
                                                     vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v116)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v115)), 0x17uLL))));
    *(int8x16_t *)(v6 + v98) = vbslq_s8(v100, (int8x16_t)v104, (int8x16_t)vmulq_laneq_f32(v117, v117, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_quicktime_fast_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t *v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  int8x16_t *v49;
  int8x16_t *v50;
  float32x4_t v51;
  int8x16_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v56 = 0;
        v57 = 16 * v8;
        v58 = 16 * v7;
        v59 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v60 = 0;
          do
          {
            v61 = *((int8x16_t *)a2 + 15);
            v62 = vmulq_f32(v5[v60 / 0x10], (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5[v60 / 0x10], 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v63 = vminq_f32(vmaxq_f32(v62, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v64 = (float32x4_t)vbslq_s8(v61, (int8x16_t)v62, (int8x16_t)vmulq_f32(v63, v63));
            v6[v60 / 0x10] = vbslq_s8(v61, (int8x16_t)v62, (int8x16_t)vmulq_laneq_f32(v64, v64, 3));
            v60 += 16;
          }
          while (v59 != v60);
          ++v56;
          v5 = (float32x4_t *)((char *)v5 + v57);
          v6 = (int8x16_t *)((char *)v6 + v58);
        }
        while (v56 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v5[v17 - 2];
          v19 = v5[v17 - 1];
          v20 = v5[v17];
          v21 = v5[v17 + 1];
          v23 = *((int8x16_t *)a2 + 15);
          v22 = *((float32x4_t *)a2 + 16);
          v24 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 3), v22));
          v25 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3), v22));
          v26 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 3), v22));
          v27 = (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 3), v22));
          v28 = *((int8x16_t *)a2 + 17);
          v29 = vandq_s8(v28, v24);
          v30 = vandq_s8(v28, v25);
          v31 = vandq_s8(v28, v26);
          v32 = vandq_s8(v28, v27);
          v33 = *((int8x16_t *)a2 + 3);
          v34 = vmulq_f32(v18, (float32x4_t)vorrq_s8(v29, v33));
          v35 = vmulq_f32(v19, (float32x4_t)vorrq_s8(v30, v33));
          v36 = vmulq_f32(v20, (float32x4_t)vorrq_s8(v31, v33));
          v37 = vmulq_f32(v21, (float32x4_t)vorrq_s8(v32, v33));
          v38 = *((float32x4_t *)a2 + 75);
          v39 = *((float32x4_t *)a2 + 5);
          v40 = vminq_f32(vmaxq_f32(v34, v38), v39);
          v41 = vminq_f32(vmaxq_f32(v35, v38), v39);
          v42 = vminq_f32(vmaxq_f32(v36, v38), v39);
          v43 = vminq_f32(vmaxq_f32(v37, v38), v39);
          v44 = v16;
          v45 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v34, (int8x16_t)vmulq_f32(v40, v40));
          v46 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v35, (int8x16_t)vmulq_f32(v41, v41));
          v47 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v36, (int8x16_t)vmulq_f32(v42, v42));
          v48 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v37, (int8x16_t)vmulq_f32(v43, v43));
          v49 = v15;
          v50 = &v6[v17];
          v14 += 4;
          v50[-2] = vbslq_s8(v23, (int8x16_t)v34, (int8x16_t)vmulq_laneq_f32(v45, v45, 3));
          v50[-1] = vbslq_s8(v23, (int8x16_t)v35, (int8x16_t)vmulq_laneq_f32(v46, v46, 3));
          *v50 = vbslq_s8(v23, (int8x16_t)v36, (int8x16_t)vmulq_laneq_f32(v47, v47, 3));
          v50[1] = vbslq_s8(v23, (int8x16_t)v37, (int8x16_t)vmulq_laneq_f32(v48, v48, 3));
          v17 += 4;
          v16 += 4;
          v15 = v49 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v51 = *v44++;
            v52 = *((int8x16_t *)a2 + 15);
            v53 = vmulq_f32(v51, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3), *((float32x4_t *)a2 + 16)))), *((int8x16_t *)a2 + 3)));
            v54 = vminq_f32(vmaxq_f32(v53, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v55 = (float32x4_t)vbslq_s8(v52, (int8x16_t)v53, (int8x16_t)vmulq_f32(v54, v54));
            *v49++ = vbslq_s8(v52, (int8x16_t)v53, (int8x16_t)vmulq_laneq_f32(v55, v55, 3));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getinv_quicktime_fixed_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int8x16_t *v86;
  uint64_t v87;
  int8x16_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 6);
    while (v5 < 4)
    {
      LODWORD(v87) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v7 += v8;
      v6 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 32;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 32);
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v14 = *(float32x4_t *)(v7 + v11);
      v15 = *(float32x4_t *)(v7 + v11 + 16);
      v17 = *((int8x16_t *)a2 + 15);
      v16 = *((float32x4_t *)a2 + 16);
      v18 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v16));
      v19 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v16));
      v20 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v16));
      v21 = vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16));
      v23 = *((int8x16_t *)a2 + 17);
      v22 = *((float32x4_t *)a2 + 18);
      v24 = vandq_s8(v23, (int8x16_t)vmulq_f32(v18, v22));
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v19, v22));
      v26 = vandq_s8(v23, (int8x16_t)vmulq_f32(v20, v22));
      v27 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, v22));
      v28 = *((int8x16_t *)a2 + 3);
      v29 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v28));
      v30 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v28));
      v31 = vmulq_f32(v14, (float32x4_t)vorrq_s8(v26, v28));
      v32 = vmulq_f32(v15, (float32x4_t)vorrq_s8(v27, v28));
      v33 = *((float32x4_t *)a2 + 75);
      v34 = *((float32x4_t *)a2 + 5);
      v35 = *((float32x4_t *)a2 + 6);
      v36 = vmulq_f32(v35, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v29, v33), v34)));
      v37 = vmulq_f32(v35, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v30, v33), v34)));
      v38 = vmulq_f32(v35, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v31, v33), v34)));
      v39 = vmulq_f32(v35, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v32, v33), v34)));
      v40 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
      v41 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
      v42 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
      v43 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v44 = *((float32x4_t *)a2 + 7);
      v45 = *((float32x4_t *)a2 + 8);
      v46 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v36, v40), v44));
      v47 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v37, v41), v44));
      v48 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v38, v42), v44));
      v49 = vrsqrteq_f32(vaddq_f32(v44, vsubq_f32(v39, v43)));
      v50 = vaddq_f32(v45, v40);
      v51 = vaddq_f32(v45, v41);
      v52 = vaddq_f32(v45, v42);
      v53 = vaddq_f32(v45, v43);
      v54 = *((float32x4_t *)a2 + 9);
      v55 = *((float32x4_t *)a2 + 10);
      v56 = vsubq_f32(v50, vmulq_f32(v46, v54));
      v57 = *((float32x4_t *)a2 + 116);
      v58 = vmulq_f32(v57, v56);
      v59 = vmulq_f32(v57, vsubq_f32(v51, vmulq_f32(v47, v54)));
      v60 = vmulq_f32(v57, vsubq_f32(v52, vmulq_f32(v48, v54)));
      v61 = vmulq_f32(v57, vsubq_f32(v53, vmulq_f32(v49, v54)));
      v62 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v63 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v64 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v65 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v66 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v62, v58)));
      v67 = vsubq_f32(v63, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v63, v59)));
      v68 = vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v64, v60)));
      v69 = vsubq_f32(v65, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v65, v61)));
      v70 = *((float32x4_t *)a2 + 11);
      v71 = *((float32x4_t *)a2 + 12);
      v72 = vmulq_f32(vrecpeq_f32(vsubq_f32(v70, vsubq_f32(v58, v66))), v71);
      v73 = vmulq_f32(vrecpeq_f32(vsubq_f32(v70, vsubq_f32(v59, v67))), v71);
      v74 = vmulq_f32(vrecpeq_f32(vsubq_f32(v70, vsubq_f32(v60, v68))), v71);
      v75 = vmulq_f32(vrecpeq_f32(vsubq_f32(v70, vsubq_f32(v61, v69))), v71);
      v76 = vmaxq_f32(vaddq_f32(vaddq_f32(v66, v55), vmulq_f32(v72, v72)), v33);
      v77 = vmaxq_f32(vaddq_f32(vaddq_f32(v55, v67), vmulq_f32(v73, v73)), v33);
      v78 = vmaxq_f32(vaddq_f32(vaddq_f32(v55, v68), vmulq_f32(v74, v74)), v33);
      v79 = vmaxq_f32(vaddq_f32(vaddq_f32(v55, v69), vmulq_f32(v75, v75)), v33);
      v80 = *((float32x4_t *)a2 + 13);
      v81 = *((float32x4_t *)a2 + 14);
      v82 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v29, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v76, v80), v81)));
      v83 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v30, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v77, v80), v81)));
      v84 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v31, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v78, v80), v81)));
      v85 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v32, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v79, v80), v81)));
      v86 = (int8x16_t *)(v6 + v11);
      v86[-2] = vbslq_s8(v17, (int8x16_t)v29, (int8x16_t)vmulq_laneq_f32(v82, v82, 3));
      v86[-1] = vbslq_s8(v17, (int8x16_t)v30, (int8x16_t)vmulq_laneq_f32(v83, v83, 3));
      *v86 = vbslq_s8(v17, (int8x16_t)v31, (int8x16_t)vmulq_laneq_f32(v84, v84, 3));
      v86[1] = vbslq_s8(v17, (int8x16_t)v32, (int8x16_t)vmulq_laneq_f32(v85, v85, 3));
      v10 -= 4;
      v11 += 64;
    }
    while (v5 + v10 > 3);
    LODWORD(v87) = -v10;
    if ((int)v87 >= v5)
      goto LABEL_3;
LABEL_10:
    v87 = v87;
    do
    {
      v88 = *((int8x16_t *)a2 + 15);
      v89 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v87), (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(vrecpeq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v7 + 16 * v87), 3), *((float32x4_t *)a2 + 16))), *((float32x4_t *)a2 + 18))), *((int8x16_t *)a2 + 3)));
      v90 = *((float32x4_t *)a2 + 75);
      v91 = *((float32x4_t *)a2 + 5);
      v92 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v89, v90), v91)));
      v93 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
      v94 = vmulq_f32(*((float32x4_t *)a2 + 116), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v93), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v92, v93))), *((float32x4_t *)a2 + 9))));
      v95 = vcvtq_f32_s32(vcvtq_s32_f32(v94));
      v96 = vsubq_f32(v95, (float32x4_t)vandq_s8((int8x16_t)v91, (int8x16_t)vcgtq_f32(v95, v94)));
      v97 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v94, v96))), *((float32x4_t *)a2 + 12));
      v98 = (float32x4_t)vbslq_s8(v88, (int8x16_t)v89, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v96), vmulq_f32(v97, v97)), v90), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))));
      *(int8x16_t *)(v6 + 16 * v87++) = vbslq_s8(v88, (int8x16_t)v89, (int8x16_t)vmulq_laneq_f32(v98, v98, 3));
    }
    while (v87 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_quicktime_nice_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  float32x4_t v33;
  int8x16_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  int32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  int8x16_t *v91;
  int v92;
  uint64_t v93;
  float32x4_t v94;
  int8x16_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v92 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = *((int8x16_t *)a2 + 17);
      v24 = vandq_s8(v23, v22);
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = (float32x4_t)vorrq_s8(v25, v26);
      v28 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v26));
      v29 = *((float32x4_t *)a2 + 75);
      v30 = vmulq_f32(v13, v27);
      v31 = *((float32x4_t *)a2 + 5);
      v32 = (int8x16_t)vminq_f32(vmaxq_f32(v28, v29), v31);
      v33 = *((float32x4_t *)a2 + 116);
      v34 = (int8x16_t)vminq_f32(vmaxq_f32(v30, v29), v31);
      v35 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vceqq_f32(v33, v29)), v29);
      v36 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v31, v32);
      v37 = (float32x4_t)vbslq_s8(v35, (int8x16_t)v31, v34);
      v39 = *((int8x16_t *)a2 + 19);
      v38 = *((float32x4_t *)a2 + 20);
      v40 = (float32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)v36), (int8x16_t)v31);
      v41 = (float32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)v37), (int8x16_t)v31);
      v42 = *((int8x16_t *)a2 + 21);
      v43 = *((float32x4_t *)a2 + 22);
      v44 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v38, v37)));
      v45 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v36, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v38, v36))), v43);
      v46 = *((float32x4_t *)a2 + 23);
      v47 = *((float32x4_t *)a2 + 24);
      v48 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v40, v46));
      v49 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v41, v46));
      v50 = vaddq_f32(v45, v48);
      v51 = vaddq_f32(vsubq_f32(v44, v43), v49);
      v52 = vsubq_f32(vsubq_f32(v40, v31), vmulq_f32(vmulq_f32(v47, v48), v40));
      v53 = vsubq_f32(vsubq_f32(v41, v31), vmulq_f32(vmulq_f32(v47, v49), v41));
      v54 = vmulq_f32(v52, v52);
      v55 = *((float32x4_t *)a2 + 37);
      v56 = *((float32x4_t *)a2 + 38);
      v57 = *((float32x4_t *)a2 + 39);
      v58 = *((float32x4_t *)a2 + 40);
      v59 = vaddq_f32(v55, vmulq_f32(v56, v52));
      v60 = vaddq_f32(v57, vmulq_f32(v58, v52));
      v61 = vaddq_f32(v57, vmulq_f32(v58, v53));
      v62 = vaddq_f32(v55, vmulq_f32(v56, v53));
      v63 = *((float32x4_t *)a2 + 41);
      v64 = *((float32x4_t *)a2 + 42);
      v65 = vaddq_f32(v63, vmulq_f32(v64, v52));
      v66 = vaddq_f32(v63, vmulq_f32(v64, v53));
      v67 = vmulq_f32(v53, v53);
      v68 = vaddq_f32(v65, vmulq_f32(v54, vaddq_f32(v59, vmulq_f32(v54, v60))));
      v69 = vaddq_f32(v66, vmulq_f32(v67, vaddq_f32(v62, vmulq_f32(v67, v61))));
      v70 = *((float32x4_t *)a2 + 43);
      v71 = *((float32x4_t *)a2 + 44);
      v72 = vmulq_f32(v33, vaddq_f32(v51, vmulq_f32(v53, vaddq_f32(v70, vmulq_f32(v53, v69)))));
      v73 = *((float32x4_t *)a2 + 29);
      v74 = vmaxq_f32(vmulq_f32(v33, vaddq_f32(v50, vmulq_f32(v52, vaddq_f32(v70, vmulq_f32(v52, v68))))), v73);
      v75 = vmaxq_f32(v72, v73);
      v76 = vcvtq_f32_s32(vcvtq_s32_f32(v74));
      v77 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
      v78 = vsubq_f32(v76, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v76, v74)));
      v79 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v77, v75)));
      v80 = vsubq_f32(v74, v78);
      v81 = vsubq_f32(v75, v79);
      v82 = *((float32x4_t *)a2 + 45);
      v83 = *((float32x4_t *)a2 + 46);
      v84 = vaddq_f32(v71, vmulq_f32(v82, v80));
      v85 = vaddq_f32(v71, vmulq_f32(v82, v81));
      v86 = *((float32x4_t *)a2 + 47);
      v87 = *((float32x4_t *)a2 + 48);
      v88 = *((int32x4_t *)a2 + 33);
      v89 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_f32(vaddq_f32(v31, vmulq_f32(v80, vaddq_f32(v87, vmulq_f32(v80, vaddq_f32(vaddq_f32(v83, vmulq_f32(v80, v86)), vmulq_f32(vmulq_f32(v80, v80), v84)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v88, vcvtq_s32_f32(v78)), 0x17uLL)));
      v90 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v30, (int8x16_t)vmulq_f32(vaddq_f32(v31, vmulq_f32(v81, vaddq_f32(v87, vmulq_f32(v81, vaddq_f32(vaddq_f32(v83, vmulq_f32(v86, v81)), vmulq_f32(vmulq_f32(v81, v81), v85)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v88, vcvtq_s32_f32(v79)), 0x17uLL)));
      v91 = (int8x16_t *)(v6 + v11);
      v91[-1] = vbslq_s8(v15, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v89, v89, 3));
      *v91 = vbslq_s8(v15, (int8x16_t)v30, (int8x16_t)vmulq_laneq_f32(v90, v90, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v92 = -v10;
    if (v92 >= v5)
      goto LABEL_3;
LABEL_10:
    v93 = 16 * v92;
    v94 = *(float32x4_t *)(v7 + v93);
    v95 = *((int8x16_t *)a2 + 15);
    v96 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 3), *((float32x4_t *)a2 + 16));
    v97 = vrecpeq_f32(v96);
    v98 = vmulq_f32(v97, vrecpsq_f32(v97, v96));
    v99 = vmulq_f32(v94, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v98, vrecpsq_f32(v98, v96))), *((int8x16_t *)a2 + 3)));
    v100 = *((float32x4_t *)a2 + 5);
    v101 = *((float32x4_t *)a2 + 116);
    v102 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v100, (int8x16_t)vceqq_f32(v101, *((float32x4_t *)a2 + 75))), *((float32x4_t *)a2 + 75)), (int8x16_t)v100, (int8x16_t)vminq_f32(vmaxq_f32(v99, *((float32x4_t *)a2 + 75)), v100));
    v103 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v102), (int8x16_t)v100);
    v104 = (float32x4_t)vandq_s8((int8x16_t)v100, (int8x16_t)vcgtq_f32(v103, *((float32x4_t *)a2 + 23)));
    v105 = vsubq_f32(vsubq_f32(v103, v100), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v104), v103));
    v106 = vmulq_f32(v105, v105);
    v107 = vmaxq_f32(vmulq_f32(v101, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v102, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v102))), *((float32x4_t *)a2 + 22)), v104), vmulq_f32(v105, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v105, vaddq_f32(
                         vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v105)),
                         vmulq_f32(v106, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v105)), vmulq_f32(v106, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v105))))))))))), *((float32x4_t *)a2 + 29));
    v108 = vcvtq_f32_s32(vcvtq_s32_f32(v107));
    v109 = vsubq_f32(v108, (float32x4_t)vandq_s8((int8x16_t)v100, (int8x16_t)vcgtq_f32(v108, v107)));
    v110 = vsubq_f32(v107, v109);
    v111 = (float32x4_t)vbslq_s8(v95, (int8x16_t)v99, (int8x16_t)vmulq_f32(vaddq_f32(v100, vmulq_f32(v110, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v110, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v110)), vmulq_f32(vmulq_f32(v110, v110), vaddq_f32(*((float32x4_t *)a2 + 44),
                                                     vmulq_f32(*((float32x4_t *)a2 + 45), v110)))))))),
                                       (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v109)), 0x17uLL)));
    *(int8x16_t *)(v6 + v93) = vbslq_s8(v95, (int8x16_t)v99, (int8x16_t)vmulq_laneq_f32(v111, v111, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_quicktime_half_satTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int32x4_t v69;
  int32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int8x16_t *v73;
  int v74;
  uint64_t v75;
  float32x4_t v76;
  int8x16_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v74 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v15 = *((int8x16_t *)a2 + 15);
      v14 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v14);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23));
      v26 = *((float32x4_t *)a2 + 75);
      v27 = *((float32x4_t *)a2 + 5);
      v28 = vminq_f32(vmaxq_f32(v24, v26), v27);
      v29 = vminq_f32(vmaxq_f32(v25, v26), v27);
      v30 = *((int8x16_t *)a2 + 19);
      v31 = *((float32x4_t *)a2 + 20);
      v32 = (float32x4_t)vorrq_s8(vandq_s8(v30, (int8x16_t)v28), (int8x16_t)v27);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v30, (int8x16_t)v29), (int8x16_t)v27);
      v34 = *((int8x16_t *)a2 + 21);
      v35 = *((float32x4_t *)a2 + 22);
      v36 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v31, v29)));
      v37 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v31, v28))), v35);
      v38 = *((float32x4_t *)a2 + 23);
      v39 = *((float32x4_t *)a2 + 24);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v32, v38));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v33, v38));
      v42 = vaddq_f32(v37, v40);
      v43 = vaddq_f32(vsubq_f32(v36, v35), v41);
      v44 = vsubq_f32(vsubq_f32(v32, v27), vmulq_f32(vmulq_f32(v39, v40), v32));
      v45 = vsubq_f32(vsubq_f32(v33, v27), vmulq_f32(vmulq_f32(v39, v41), v33));
      v46 = *((float32x4_t *)a2 + 25);
      v47 = *((float32x4_t *)a2 + 26);
      v48 = vaddq_f32(v46, vmulq_f32(v47, v44));
      v49 = vaddq_f32(v46, vmulq_f32(v47, v45));
      v50 = *((float32x4_t *)a2 + 27);
      v51 = *((float32x4_t *)a2 + 28);
      v52 = *((float32x4_t *)a2 + 116);
      v53 = vmulq_f32(v52, vaddq_f32(v42, vmulq_f32(v44, vaddq_f32(vaddq_f32(v50, vmulq_f32(v44, v51)), vmulq_f32(vmulq_f32(v44, v44), v48)))));
      v54 = vmulq_f32(v52, vaddq_f32(v43, vmulq_f32(v45, vaddq_f32(vaddq_f32(v50, vmulq_f32(v45, v51)), vmulq_f32(vmulq_f32(v45, v45), v49)))));
      v55 = *((float32x4_t *)a2 + 29);
      v56 = *((float32x4_t *)a2 + 30);
      v57 = vmaxq_f32(v53, v55);
      v58 = vmaxq_f32(v54, v55);
      v59 = vcvtq_f32_s32(vcvtq_s32_f32(v57));
      v60 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v61 = vsubq_f32(v59, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v59, v57)));
      v62 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v60, v58)));
      v63 = vsubq_f32(v57, v61);
      v64 = vsubq_f32(v58, v62);
      v65 = *((float32x4_t *)a2 + 31);
      v66 = *((float32x4_t *)a2 + 32);
      v67 = vmulq_f32(v64, vaddq_f32(v66, vmulq_f32(v64, vaddq_f32(v56, vmulq_f32(v65, v64)))));
      v68 = vaddq_f32(v27, vmulq_f32(v63, vaddq_f32(v66, vmulq_f32(v63, vaddq_f32(v56, vmulq_f32(v65, v63))))));
      v69 = vcvtq_s32_f32(v62);
      v70 = *((int32x4_t *)a2 + 33);
      v71 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_f32(v68, (float32x4_t)vshlq_n_s32(vaddq_s32(v70, vcvtq_s32_f32(v61)), 0x17uLL)));
      v72 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vmulq_f32(vaddq_f32(v27, v67), (float32x4_t)vshlq_n_s32(vaddq_s32(v70, v69), 0x17uLL)));
      v73 = (int8x16_t *)(v6 + v11);
      v73[-1] = vbslq_s8(v15, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v71, v71, 3));
      *v73 = vbslq_s8(v15, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v72, v72, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v74 = -v10;
    if (v74 >= v5)
      goto LABEL_3;
LABEL_10:
    v75 = 16 * v74;
    v76 = *(float32x4_t *)(v7 + v75);
    v77 = *((int8x16_t *)a2 + 15);
    v78 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 3), *((float32x4_t *)a2 + 16));
    v79 = vmulq_f32(vrecpeq_f32(v78), *((float32x4_t *)a2 + 18));
    v80 = vmulq_f32(v76, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v79, vrecpsq_f32(v79, v78))), *((int8x16_t *)a2 + 3)));
    v81 = *((float32x4_t *)a2 + 5);
    v82 = vminq_f32(vmaxq_f32(v80, *((float32x4_t *)a2 + 75)), v81);
    v83 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v82), (int8x16_t)v81);
    v84 = (float32x4_t)vandq_s8((int8x16_t)v81, (int8x16_t)vcgtq_f32(v83, *((float32x4_t *)a2 + 23)));
    v85 = vsubq_f32(vsubq_f32(v83, v81), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v84), v83));
    v86 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 116), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v82, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v82))), *((float32x4_t *)a2 + 22)), v84), vmulq_f32(v85, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v85, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v85, v85), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v85))))))),
            *((float32x4_t *)a2 + 29));
    v87 = vcvtq_f32_s32(vcvtq_s32_f32(v86));
    v88 = vsubq_f32(v87, (float32x4_t)vandq_s8((int8x16_t)v81, (int8x16_t)vcgtq_f32(v87, v86)));
    v89 = vsubq_f32(v86, v88);
    v90 = (float32x4_t)vbslq_s8(v77, (int8x16_t)v80, (int8x16_t)vmulq_f32(vaddq_f32(v81, vmulq_f32(v89, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v89, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v89)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v88)), 0x17uLL)));
    *(int8x16_t *)(v6 + v75) = vbslq_s8(v77, (int8x16_t)v80, (int8x16_t)vmulq_laneq_f32(v90, v90, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_quicktime_halfTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  int32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  int8x16_t v79;
  float32x4_t v80;
  float32x4_t v81;
  int8x16_t *v82;
  int v83;
  uint64_t v84;
  float32x4_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v83 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v19 = *((int8x16_t *)a2 + 17);
      v18 = *((float32x4_t *)a2 + 18);
      v20 = vmulq_f32(vrecpeq_f32(v16), v18);
      v21 = vmulq_f32(vrecpeq_f32(v17), v18);
      v22 = vandq_s8(v19, (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16)));
      v23 = *((int8x16_t *)a2 + 3);
      v24 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v22, v23));
      v25 = vmulq_f32(v13, (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17))), v23));
      v26 = *((float32x4_t *)a2 + 82);
      v27 = (int8x16_t)vmaxq_f32(v25, v26);
      v28 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmaxq_f32(v24, v26));
      v29 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, v27);
      v30 = *((float32x4_t *)a2 + 75);
      v31 = *((float32x4_t *)a2 + 5);
      v33 = *((int32x4_t *)a2 + 33);
      v32 = *((int8x16_t *)a2 + 34);
      v34 = vmulq_f32(v28, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v30, v28), v32, (int8x16_t)v31));
      v35 = vmulq_f32(v29, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v30, v29), v32, (int8x16_t)v31));
      v36 = *((float32x4_t *)a2 + 90);
      v37 = vminq_f32(v34, v36);
      v38 = vminq_f32(v35, v36);
      v39 = *((int8x16_t *)a2 + 19);
      v40 = *((float32x4_t *)a2 + 20);
      v41 = (float32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)v37), (int8x16_t)v31);
      v42 = *((int8x16_t *)a2 + 21);
      v43 = *((float32x4_t *)a2 + 22);
      v44 = (float32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)v38), (int8x16_t)v31);
      v45 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v38, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v40, v38)));
      v46 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x17uLL)), (float32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_f32(v40, v37))), v43);
      v47 = *((float32x4_t *)a2 + 23);
      v48 = *((float32x4_t *)a2 + 24);
      v49 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v41, v47));
      v50 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v44, v47));
      v51 = vaddq_f32(v46, v49);
      v52 = vmulq_f32(v48, v49);
      v53 = vmulq_f32(vmulq_f32(v48, v50), v44);
      v54 = vaddq_f32(vsubq_f32(v45, v43), v50);
      v55 = vsubq_f32(vsubq_f32(v41, v31), vmulq_f32(v52, v41));
      v56 = vsubq_f32(vsubq_f32(v44, v31), v53);
      v57 = *((float32x4_t *)a2 + 25);
      v58 = *((float32x4_t *)a2 + 26);
      v59 = *((float32x4_t *)a2 + 27);
      v60 = *((float32x4_t *)a2 + 28);
      v61 = vaddq_f32(v54, vmulq_f32(v56, vaddq_f32(vaddq_f32(v59, vmulq_f32(v56, v60)), vmulq_f32(vmulq_f32(v56, v56), vaddq_f32(v57, vmulq_f32(v58, v56))))));
      v62 = *((float32x4_t *)a2 + 116);
      v63 = vmulq_f32(v62, vaddq_f32(v51, vmulq_f32(v55, vaddq_f32(vaddq_f32(v59, vmulq_f32(v55, v60)), vmulq_f32(vmulq_f32(v55, v55), vaddq_f32(v57, vmulq_f32(v58, v55)))))));
      v64 = vmulq_f32(v62, v61);
      v65 = *((float32x4_t *)a2 + 29);
      v66 = *((float32x4_t *)a2 + 30);
      v67 = vmaxq_f32(v63, v65);
      v68 = vmaxq_f32(v64, v65);
      v69 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
      v70 = vcvtq_f32_s32(vcvtq_s32_f32(v68));
      v71 = vsubq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v69, v67)));
      v72 = vsubq_f32(v70, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v70, v68)));
      v73 = vsubq_f32(v67, v71);
      v74 = vsubq_f32(v68, v72);
      v75 = *((float32x4_t *)a2 + 31);
      v76 = *((float32x4_t *)a2 + 32);
      v77 = vaddq_f32(v31, vmulq_f32(v73, vaddq_f32(v76, vmulq_f32(v73, vaddq_f32(v66, vmulq_f32(v75, v73))))));
      v78 = vaddq_f32(v31, vmulq_f32(v74, vaddq_f32(v76, vmulq_f32(v74, vaddq_f32(v66, vmulq_f32(v75, v74))))));
      v79 = *((int8x16_t *)a2 + 36);
      v80 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v24, veorq_s8(vandq_s8(v79, (int8x16_t)v28), (int8x16_t)vmulq_f32(v77, (float32x4_t)vshlq_n_s32(vaddq_s32(v33, vcvtq_s32_f32(v71)), 0x17uLL))));
      v81 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v25, veorq_s8(vandq_s8(v79, (int8x16_t)v29), (int8x16_t)vmulq_f32(v78, (float32x4_t)vshlq_n_s32(vaddq_s32(v33, vcvtq_s32_f32(v72)), 0x17uLL))));
      v82 = (int8x16_t *)(v6 + v11);
      v82[-1] = vbslq_s8(v14, (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      *v82 = vbslq_s8(v14, (int8x16_t)v25, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v83 = -v10;
    if (v83 >= v5)
      goto LABEL_3;
LABEL_10:
    v84 = 16 * v83;
    v85 = *(float32x4_t *)(v7 + v84);
    v86 = *((int8x16_t *)a2 + 15);
    v87 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v85, 3), *((float32x4_t *)a2 + 16));
    v88 = vmulq_f32(vrecpeq_f32(v87), *((float32x4_t *)a2 + 18));
    v89 = vmulq_f32(v85, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v88, vrecpsq_f32(v88, v87))), *((int8x16_t *)a2 + 3)));
    v90 = (float32x4_t)vbslq_s8(v86, (int8x16_t)v89, (int8x16_t)vmaxq_f32(v89, *((float32x4_t *)a2 + 82)));
    v91 = *((float32x4_t *)a2 + 5);
    v92 = vminq_f32(vmulq_f32(v90, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 75), v90), *((int8x16_t *)a2 + 34), (int8x16_t)v91)), *((float32x4_t *)a2 + 90));
    v93 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v92), (int8x16_t)v91);
    v94 = (float32x4_t)vandq_s8((int8x16_t)v91, (int8x16_t)vcgtq_f32(v93, *((float32x4_t *)a2 + 23)));
    v95 = vsubq_f32(vsubq_f32(v93, v91), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v94), v93));
    v96 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 116), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v92, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v92))), *((float32x4_t *)a2 + 22)), v94), vmulq_f32(v95, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v95, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v95, v95), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v95))))))),
            *((float32x4_t *)a2 + 29));
    v97 = vcvtq_f32_s32(vcvtq_s32_f32(v96));
    v98 = vsubq_f32(v97, (float32x4_t)vandq_s8((int8x16_t)v91, (int8x16_t)vcgtq_f32(v97, v96)));
    v99 = vsubq_f32(v96, v98);
    v100 = (float32x4_t)vbslq_s8(v86, (int8x16_t)v89, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v90), (int8x16_t)vmulq_f32(vaddq_f32(v91, vmulq_f32(v99, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v99, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v99)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v98)), 0x17uLL))));
    *(int8x16_t *)(v6 + v84) = vbslq_s8(v86, (int8x16_t)v89, (int8x16_t)vmulq_laneq_f32(v100, v100, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_quicktime_niceTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  int32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  int8x16_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  int8x16_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int8x16_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  int8x16_t *v96;
  int v97;
  uint64_t v98;
  float32x4_t v99;
  int8x16_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v97 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((int8x16_t *)a2 + 15);
      v15 = *((float32x4_t *)a2 + 16);
      v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
      v18 = vrecpeq_f32(v16);
      v19 = vrecpeq_f32(v17);
      v20 = vmulq_f32(v18, vrecpsq_f32(v18, v16));
      v21 = vmulq_f32(v19, vrecpsq_f32(v19, v17));
      v22 = (int8x16_t)vmulq_f32(v20, vrecpsq_f32(v20, v16));
      v23 = *((int8x16_t *)a2 + 17);
      v24 = vandq_s8(v23, v22);
      v25 = vandq_s8(v23, (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v26 = *((int8x16_t *)a2 + 3);
      v27 = vmulq_f32(v12, (float32x4_t)vorrq_s8(v24, v26));
      v28 = vmulq_f32(v13, (float32x4_t)vorrq_s8(v25, v26));
      v29 = *((float32x4_t *)a2 + 82);
      v30 = (int8x16_t)vmaxq_f32(v28, v29);
      v31 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmaxq_f32(v27, v29));
      v32 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v28, v30);
      v33 = *((float32x4_t *)a2 + 75);
      v34 = *((float32x4_t *)a2 + 5);
      v36 = *((int32x4_t *)a2 + 33);
      v35 = *((int8x16_t *)a2 + 34);
      v37 = *((float32x4_t *)a2 + 90);
      v38 = (int8x16_t)vminq_f32(vmulq_f32(v31, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v33, v31), v35, (int8x16_t)v34)), v37);
      v39 = (int8x16_t)vminq_f32(vmulq_f32(v32, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v33, v32), v35, (int8x16_t)v34)), v37);
      v40 = *((float32x4_t *)a2 + 116);
      v41 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vceqq_f32(v40, v33)), v33);
      v42 = (float32x4_t)vbslq_s8(v41, (int8x16_t)v34, v38);
      v43 = (float32x4_t)vbslq_s8(v41, (int8x16_t)v34, v39);
      v44 = *((int8x16_t *)a2 + 19);
      v45 = *((float32x4_t *)a2 + 20);
      v46 = (float32x4_t)vorrq_s8(vandq_s8(v44, (int8x16_t)v42), (int8x16_t)v34);
      v47 = (float32x4_t)vorrq_s8(vandq_s8(v44, (int8x16_t)v43), (int8x16_t)v34);
      v48 = *((int8x16_t *)a2 + 21);
      v49 = *((float32x4_t *)a2 + 22);
      v50 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v43, 0x17uLL)), (float32x4_t)vandq_s8(v48, (int8x16_t)vcgtq_f32(v45, v43)));
      v51 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v42, 0x17uLL)), (float32x4_t)vandq_s8(v48, (int8x16_t)vcgtq_f32(v45, v42))), v49);
      v52 = *((float32x4_t *)a2 + 23);
      v53 = *((float32x4_t *)a2 + 24);
      v54 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v46, v52));
      v55 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v47, v52));
      v56 = vaddq_f32(v51, v54);
      v57 = vaddq_f32(vsubq_f32(v50, v49), v55);
      v58 = vsubq_f32(vsubq_f32(v46, v34), vmulq_f32(vmulq_f32(v53, v54), v46));
      v59 = vsubq_f32(vsubq_f32(v47, v34), vmulq_f32(vmulq_f32(v53, v55), v47));
      v60 = *((float32x4_t *)a2 + 38);
      v61 = *((float32x4_t *)a2 + 39);
      v63 = *((int8x16_t *)a2 + 36);
      v62 = *((float32x4_t *)a2 + 37);
      v64 = vaddq_f32(v62, vmulq_f32(v60, v58));
      v65 = *((float32x4_t *)a2 + 40);
      v66 = *((float32x4_t *)a2 + 41);
      v67 = vaddq_f32(v61, vmulq_f32(v65, v58));
      v68 = vaddq_f32(v61, vmulq_f32(v65, v59));
      v69 = *((float32x4_t *)a2 + 42);
      v70 = *((float32x4_t *)a2 + 43);
      v71 = vaddq_f32(v62, vmulq_f32(v60, v59));
      v72 = vaddq_f32(v66, vmulq_f32(v69, v58));
      v73 = vaddq_f32(v66, vmulq_f32(v69, v59));
      v74 = vmulq_f32(v58, v58);
      v75 = vaddq_f32(v64, vmulq_f32(v74, v67));
      v76 = vmulq_f32(v59, v59);
      v77 = vaddq_f32(v57, vmulq_f32(v59, vaddq_f32(v70, vmulq_f32(v59, vaddq_f32(v73, vmulq_f32(v76, vaddq_f32(v71, vmulq_f32(v76, v68))))))));
      v78 = *((float32x4_t *)a2 + 29);
      v79 = vmaxq_f32(vmulq_f32(v40, vaddq_f32(v56, vmulq_f32(v58, vaddq_f32(v70, vmulq_f32(v58, vaddq_f32(v72, vmulq_f32(v74, v75))))))), v78);
      v80 = vmaxq_f32(vmulq_f32(v40, v77), v78);
      v81 = vcvtq_f32_s32(vcvtq_s32_f32(v79));
      v82 = vcvtq_f32_s32(vcvtq_s32_f32(v80));
      v83 = vsubq_f32(v81, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v81, v79)));
      v84 = vsubq_f32(v82, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v82, v80)));
      v85 = vsubq_f32(v79, v83);
      v86 = vsubq_f32(v80, v84);
      v87 = *((float32x4_t *)a2 + 44);
      v88 = *((float32x4_t *)a2 + 45);
      v89 = vaddq_f32(v87, vmulq_f32(v88, v85));
      v90 = *((float32x4_t *)a2 + 46);
      v91 = *((float32x4_t *)a2 + 47);
      v92 = vaddq_f32(v87, vmulq_f32(v88, v86));
      v93 = *((float32x4_t *)a2 + 48);
      v94 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v27, veorq_s8(vandq_s8(v63, (int8x16_t)v31), (int8x16_t)vmulq_f32(vaddq_f32(v34, vmulq_f32(v85, vaddq_f32(v93, vmulq_f32(v85, vaddq_f32(vaddq_f32(v90, vmulq_f32(v85, v91)), vmulq_f32(vmulq_f32(v85, v85), v89)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v36, vcvtq_s32_f32(v83)), 0x17uLL))));
      v95 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v28, veorq_s8(vandq_s8(v63, (int8x16_t)v32), (int8x16_t)vmulq_f32(vaddq_f32(v34, vmulq_f32(v86, vaddq_f32(v93, vmulq_f32(v86, vaddq_f32(vaddq_f32(v90, vmulq_f32(v91, v86)), vmulq_f32(vmulq_f32(v86, v86), v92)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v36, vcvtq_s32_f32(v84)), 0x17uLL))));
      v96 = (int8x16_t *)(v6 + v11);
      v96[-1] = vbslq_s8(v14, (int8x16_t)v27, (int8x16_t)vmulq_laneq_f32(v94, v94, 3));
      *v96 = vbslq_s8(v14, (int8x16_t)v28, (int8x16_t)vmulq_laneq_f32(v95, v95, 3));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v97 = -v10;
    if (v97 >= v5)
      goto LABEL_3;
LABEL_10:
    v98 = 16 * v97;
    v99 = *(float32x4_t *)(v7 + v98);
    v100 = *((int8x16_t *)a2 + 15);
    v101 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v99, 3), *((float32x4_t *)a2 + 16));
    v102 = vrecpeq_f32(v101);
    v103 = vmulq_f32(v102, vrecpsq_f32(v102, v101));
    v104 = vmulq_f32(v99, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 17), (int8x16_t)vmulq_f32(v103, vrecpsq_f32(v103, v101))), *((int8x16_t *)a2 + 3)));
    v105 = (float32x4_t)vbslq_s8(v100, (int8x16_t)v104, (int8x16_t)vmaxq_f32(v104, *((float32x4_t *)a2 + 82)));
    v106 = *((float32x4_t *)a2 + 5);
    v107 = *((float32x4_t *)a2 + 116);
    v108 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v106, (int8x16_t)vceqq_f32(v107, *((float32x4_t *)a2 + 75))), *((float32x4_t *)a2 + 75)), (int8x16_t)v106, (int8x16_t)vminq_f32(vmulq_f32(v105, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 75), v105), *((int8x16_t *)a2 + 34), (int8x16_t)v106)), *((float32x4_t *)a2 + 90)));
    v109 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v108), (int8x16_t)v106);
    v110 = (float32x4_t)vandq_s8((int8x16_t)v106, (int8x16_t)vcgtq_f32(v109, *((float32x4_t *)a2 + 23)));
    v111 = vsubq_f32(vsubq_f32(v109, v106), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v110), v109));
    v112 = vmulq_f32(v111, v111);
    v113 = vmaxq_f32(vmulq_f32(v107, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v108, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v108))), *((float32x4_t *)a2 + 22)), v110), vmulq_f32(v111, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v111, vaddq_f32(
                         vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v111)),
                         vmulq_f32(v112, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v111)), vmulq_f32(v112, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v111))))))))))), *((float32x4_t *)a2 + 29));
    v114 = vcvtq_f32_s32(vcvtq_s32_f32(v113));
    v115 = vsubq_f32(v114, (float32x4_t)vandq_s8((int8x16_t)v106, (int8x16_t)vcgtq_f32(v114, v113)));
    v116 = vsubq_f32(v113, v115);
    v117 = (float32x4_t)vbslq_s8(v100, (int8x16_t)v104, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v105), (int8x16_t)vmulq_f32(vaddq_f32(v106, vmulq_f32(v116, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v116, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v116)), vmulq_f32(vmulq_f32(v116, v116),
                                                     vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v116)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v115)), 0x17uLL))));
    *(int8x16_t *)(v6 + v98) = vbslq_s8(v100, (int8x16_t)v104, (int8x16_t)vmulq_laneq_f32(v117, v117, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype0_fast_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  int8x16_t v68;
  int8x16_t v69;
  int8x16_t *v70;
  uint64_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 6);
    while (v5 < 4)
    {
      LODWORD(v71) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v7 += v8;
      v6 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 32;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 32);
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v14 = *(float32x4_t *)(v7 + v11);
      v15 = *(float32x4_t *)(v7 + v11 + 16);
      v16 = *((float32x4_t *)a2 + 3);
      v17 = *((float32x4_t *)a2 + 5);
      v18 = *((float32x4_t *)a2 + 6);
      v19 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v12, v16), v17)));
      v20 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v13, v16), v17)));
      v21 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v14, v16), v17)));
      v22 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v15, v16), v17)));
      v23 = vcvtq_f32_s32(vcvtq_s32_f32(v19));
      v24 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
      v25 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
      v26 = vcvtq_f32_s32(vcvtq_s32_f32(v22));
      v27 = *((float32x4_t *)a2 + 7);
      v28 = *((float32x4_t *)a2 + 8);
      v29 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v19, v23), v27));
      v30 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v20, v24), v27));
      v31 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v21, v25), v27));
      v32 = vrsqrteq_f32(vaddq_f32(v27, vsubq_f32(v22, v26)));
      v33 = vaddq_f32(v28, v23);
      v34 = vaddq_f32(v28, v24);
      v35 = vaddq_f32(v28, v25);
      v36 = vaddq_f32(v28, v26);
      v37 = *((float32x4_t *)a2 + 9);
      v38 = *((float32x4_t *)a2 + 10);
      v39 = vmulq_n_f32(vsubq_f32(v33, vmulq_f32(v29, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v40 = vmulq_n_f32(vsubq_f32(v34, vmulq_f32(v30, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v41 = vmulq_n_f32(vsubq_f32(v35, vmulq_f32(v31, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v42 = vmulq_n_f32(vsubq_f32(v36, vmulq_f32(v32, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v43 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
      v45 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
      v47 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v43, v39)));
      v48 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v44, v40)));
      v49 = vsubq_f32(v45, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v45, v41)));
      v50 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v46, v42)));
      v51 = *((float32x4_t *)a2 + 11);
      v52 = *((float32x4_t *)a2 + 12);
      v53 = vmulq_f32(vrecpeq_f32(vsubq_f32(v51, vsubq_f32(v39, v47))), v52);
      v54 = vmulq_f32(vrecpeq_f32(vsubq_f32(v51, vsubq_f32(v40, v48))), v52);
      v55 = vmulq_f32(vrecpeq_f32(vsubq_f32(v51, vsubq_f32(v41, v49))), v52);
      v56 = vmulq_f32(vrecpeq_f32(vsubq_f32(v51, vsubq_f32(v42, v50))), v52);
      v57 = vmaxq_f32(vaddq_f32(vaddq_f32(v47, v38), vmulq_f32(v53, v53)), v16);
      v58 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v48), vmulq_f32(v54, v54)), v16);
      v59 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v49), vmulq_f32(v55, v55)), v16);
      v60 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v50), vmulq_f32(v56, v56)), v16);
      v61 = *((float32x4_t *)a2 + 13);
      v62 = *((float32x4_t *)a2 + 14);
      v63 = vminq_f32(v58, v61);
      v64 = vminq_f32(v59, v61);
      v65 = vminq_f32(v60, v61);
      v66 = vmulq_f32(vminq_f32(v57, v61), v62);
      v67 = vmulq_f32(v63, v62);
      v68 = (int8x16_t)vcvtq_s32_f32(vmulq_f32(v64, v62));
      v69 = *((int8x16_t *)a2 + 15);
      v70 = (int8x16_t *)(v6 + v11);
      v70[-2] = vbslq_s8(v69, (int8x16_t)v12, (int8x16_t)vcvtq_s32_f32(v66));
      v70[-1] = vbslq_s8(v69, (int8x16_t)v13, (int8x16_t)vcvtq_s32_f32(v67));
      *v70 = vbslq_s8(v69, (int8x16_t)v14, v68);
      v70[1] = vbslq_s8(v69, (int8x16_t)v15, (int8x16_t)vcvtq_s32_f32(vmulq_f32(v65, v62)));
      v10 -= 4;
      v11 += 64;
    }
    while (v5 + v10 > 3);
    LODWORD(v71) = -v10;
    if ((int)v71 >= v5)
      goto LABEL_3;
LABEL_10:
    v71 = v71;
    do
    {
      v72 = *(float32x4_t *)(v7 + 16 * v71);
      v73 = *((float32x4_t *)a2 + 3);
      v74 = *((float32x4_t *)a2 + 5);
      v75 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v72, v73), v74)));
      v76 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
      v77 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v76), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v75, v76))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v77));
      v79 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v74, (int8x16_t)vcgtq_f32(v78, v77)));
      v80 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v77, v79))), *((float32x4_t *)a2 + 12));
      *(int8x16_t *)(v6 + 16 * v71++) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v72, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v79), vmulq_f32(v80, v80)), v73), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))));
    }
    while (v71 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype0_fixed_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  int8x16_t v68;
  int8x16_t v69;
  int8x16_t *v70;
  uint64_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 6);
    while (v5 < 4)
    {
      LODWORD(v71) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v7 += v8;
      v6 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 32;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 32);
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v14 = *(float32x4_t *)(v7 + v11);
      v15 = *(float32x4_t *)(v7 + v11 + 16);
      v16 = *((float32x4_t *)a2 + 3);
      v17 = *((float32x4_t *)a2 + 5);
      v18 = *((float32x4_t *)a2 + 6);
      v19 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v12, v16), v17)));
      v20 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v13, v16), v17)));
      v21 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v14, v16), v17)));
      v22 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v15, v16), v17)));
      v23 = vcvtq_f32_s32(vcvtq_s32_f32(v19));
      v24 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
      v25 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
      v26 = vcvtq_f32_s32(vcvtq_s32_f32(v22));
      v27 = *((float32x4_t *)a2 + 7);
      v28 = *((float32x4_t *)a2 + 8);
      v29 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v19, v23), v27));
      v30 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v20, v24), v27));
      v31 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v21, v25), v27));
      v32 = vrsqrteq_f32(vaddq_f32(v27, vsubq_f32(v22, v26)));
      v33 = vaddq_f32(v28, v23);
      v34 = vaddq_f32(v28, v24);
      v35 = vaddq_f32(v28, v25);
      v36 = vaddq_f32(v28, v26);
      v37 = *((float32x4_t *)a2 + 9);
      v38 = *((float32x4_t *)a2 + 10);
      v39 = vmulq_n_f32(vsubq_f32(v33, vmulq_f32(v29, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v40 = vmulq_n_f32(vsubq_f32(v34, vmulq_f32(v30, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v41 = vmulq_n_f32(vsubq_f32(v35, vmulq_f32(v31, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v42 = vmulq_n_f32(vsubq_f32(v36, vmulq_f32(v32, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v43 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
      v45 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
      v47 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v43, v39)));
      v48 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v44, v40)));
      v49 = vsubq_f32(v45, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v45, v41)));
      v50 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v46, v42)));
      v51 = *((float32x4_t *)a2 + 11);
      v52 = *((float32x4_t *)a2 + 12);
      v53 = vmulq_f32(vrecpeq_f32(vsubq_f32(v51, vsubq_f32(v39, v47))), v52);
      v54 = vmulq_f32(vrecpeq_f32(vsubq_f32(v51, vsubq_f32(v40, v48))), v52);
      v55 = vmulq_f32(vrecpeq_f32(vsubq_f32(v51, vsubq_f32(v41, v49))), v52);
      v56 = vmulq_f32(vrecpeq_f32(vsubq_f32(v51, vsubq_f32(v42, v50))), v52);
      v57 = vmaxq_f32(vaddq_f32(vaddq_f32(v47, v38), vmulq_f32(v53, v53)), v16);
      v58 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v48), vmulq_f32(v54, v54)), v16);
      v59 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v49), vmulq_f32(v55, v55)), v16);
      v60 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v50), vmulq_f32(v56, v56)), v16);
      v61 = *((float32x4_t *)a2 + 13);
      v62 = *((float32x4_t *)a2 + 14);
      v63 = vminq_f32(v58, v61);
      v64 = vminq_f32(v59, v61);
      v65 = vminq_f32(v60, v61);
      v66 = vmulq_f32(vminq_f32(v57, v61), v62);
      v67 = vmulq_f32(v63, v62);
      v68 = (int8x16_t)vcvtq_s32_f32(vmulq_f32(v64, v62));
      v69 = *((int8x16_t *)a2 + 15);
      v70 = (int8x16_t *)(v6 + v11);
      v70[-2] = vbslq_s8(v69, (int8x16_t)v12, (int8x16_t)vcvtq_s32_f32(v66));
      v70[-1] = vbslq_s8(v69, (int8x16_t)v13, (int8x16_t)vcvtq_s32_f32(v67));
      *v70 = vbslq_s8(v69, (int8x16_t)v14, v68);
      v70[1] = vbslq_s8(v69, (int8x16_t)v15, (int8x16_t)vcvtq_s32_f32(vmulq_f32(v65, v62)));
      v10 -= 4;
      v11 += 64;
    }
    while (v5 + v10 > 3);
    LODWORD(v71) = -v10;
    if ((int)v71 >= v5)
      goto LABEL_3;
LABEL_10:
    v71 = v71;
    do
    {
      v72 = *(float32x4_t *)(v7 + 16 * v71);
      v73 = *((float32x4_t *)a2 + 3);
      v74 = *((float32x4_t *)a2 + 5);
      v75 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v72, v73), v74)));
      v76 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
      v77 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v76), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v75, v76))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v77));
      v79 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v74, (int8x16_t)vcgtq_f32(v78, v77)));
      v80 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v77, v79))), *((float32x4_t *)a2 + 12));
      *(int8x16_t *)(v6 + 16 * v71++) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v72, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v79), vmulq_f32(v80, v80)), v73), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))));
    }
    while (v71 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype0_nice_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  int32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  int8x16_t v76;
  int8x16_t v77;
  int8x16_t v78;
  int8x16_t *v79;
  int v80;
  uint64_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v80 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 3);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v17 = (int8x16_t)vaddq_f32(vminq_f32(vmaxq_f32(v13, v14), v15), v16);
      v18 = (int8x16_t)vaddq_f32(vminq_f32(vmaxq_f32(v12, v14), v15), v16);
      v19 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v14)), v14);
      v20 = (float32x4_t)vbslq_s8(v19, (int8x16_t)v15, v17);
      v21 = (float32x4_t)vbslq_s8(v19, (int8x16_t)v15, v18);
      v22 = *((int8x16_t *)a2 + 19);
      v23 = *((float32x4_t *)a2 + 20);
      v24 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v20), (int8x16_t)v15);
      v25 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v21), (int8x16_t)v15);
      v26 = *((int8x16_t *)a2 + 21);
      v27 = *((float32x4_t *)a2 + 22);
      v28 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v23, v21)));
      v29 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v23, v20))), v27);
      v30 = *((float32x4_t *)a2 + 23);
      v31 = *((float32x4_t *)a2 + 24);
      v32 = vsubq_f32(v28, v27);
      v33 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v24, v30));
      v34 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v25, v30));
      v35 = vaddq_f32(v29, v33);
      v36 = vsubq_f32(vsubq_f32(v24, v15), vmulq_f32(vmulq_f32(v31, v33), v24));
      v37 = vsubq_f32(vsubq_f32(v25, v15), vmulq_f32(vmulq_f32(v31, v34), v25));
      v38 = vmulq_f32(v36, v36);
      v39 = *((float32x4_t *)a2 + 37);
      v40 = *((float32x4_t *)a2 + 38);
      v41 = *((float32x4_t *)a2 + 39);
      v42 = *((float32x4_t *)a2 + 40);
      v43 = vaddq_f32(v39, vmulq_f32(v40, v36));
      v44 = vaddq_f32(v41, vmulq_f32(v42, v36));
      v45 = vaddq_f32(v41, vmulq_f32(v42, v37));
      v46 = vaddq_f32(v39, vmulq_f32(v40, v37));
      v47 = *((float32x4_t *)a2 + 41);
      v48 = *((float32x4_t *)a2 + 42);
      v49 = vaddq_f32(v47, vmulq_f32(v48, v36));
      v50 = vaddq_f32(v47, vmulq_f32(v48, v37));
      v51 = vmulq_f32(v37, v37);
      v52 = vaddq_f32(v32, v34);
      v53 = vaddq_f32(v49, vmulq_f32(v38, vaddq_f32(v43, vmulq_f32(v38, v44))));
      v54 = vaddq_f32(v50, vmulq_f32(v51, vaddq_f32(v46, vmulq_f32(v51, v45))));
      v55 = *((float32x4_t *)a2 + 43);
      v56 = *((float32x4_t *)a2 + 44);
      v57 = vaddq_f32(v52, vmulq_f32(v37, vaddq_f32(v55, vmulq_f32(v37, v54))));
      v58 = vmulq_n_f32(vaddq_f32(v35, vmulq_f32(v36, vaddq_f32(v55, vmulq_f32(v36, v53)))), COERCE_FLOAT(*(_OWORD *)a2));
      v59 = *((float32x4_t *)a2 + 29);
      v60 = vmaxq_f32(v58, v59);
      v61 = vmaxq_f32(vmulq_n_f32(v57, COERCE_FLOAT(*(_OWORD *)a2)), v59);
      v62 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v63 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v64 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v62, v60)));
      v65 = vsubq_f32(v63, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v63, v61)));
      v66 = vsubq_f32(v60, v64);
      v67 = vsubq_f32(v61, v65);
      v68 = *((float32x4_t *)a2 + 45);
      v69 = *((float32x4_t *)a2 + 46);
      v70 = *((float32x4_t *)a2 + 47);
      v71 = *((float32x4_t *)a2 + 48);
      v72 = *((int32x4_t *)a2 + 33);
      v73 = vmulq_f32(vaddq_f32(v15, vmulq_f32(v66, vaddq_f32(v71, vmulq_f32(v66, vaddq_f32(vaddq_f32(v69, vmulq_f32(v66, v70)), vmulq_f32(vmulq_f32(v66, v66), vaddq_f32(v56, vmulq_f32(v68, v66)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v72, vcvtq_s32_f32(v64)), 0x17uLL));
      v74 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2);
      v75 = vaddq_f32(v74, vmulq_laneq_f32(vmulq_f32(vaddq_f32(v15, vmulq_f32(v67, vaddq_f32(v71, vmulq_f32(v67, vaddq_f32(vaddq_f32(v69, vmulq_f32(v70, v67)), vmulq_f32(vmulq_f32(v67, v67), vaddq_f32(v56, vmulq_f32(v68, v67)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v72, vcvtq_s32_f32(v65)), 0x17uLL)), *(float32x4_t *)a2, 3));
      v76 = (int8x16_t)vminq_f32(vaddq_f32(v74, vmulq_laneq_f32(v73, *(float32x4_t *)a2, 3)), v15);
      v77 = (int8x16_t)vminq_f32(v75, v15);
      v78 = *((int8x16_t *)a2 + 15);
      v79 = (int8x16_t *)(v6 + v11);
      v79[-1] = vbslq_s8(v78, (int8x16_t)v13, v76);
      *v79 = vbslq_s8(v78, (int8x16_t)v12, v77);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v80 = -v10;
    if (v80 >= v5)
      goto LABEL_3;
LABEL_10:
    v81 = 16 * v80;
    v82 = *(float32x4_t *)(v7 + v81);
    v83 = *((float32x4_t *)a2 + 5);
    v84 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v83, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), *((float32x4_t *)a2 + 3))), *((float32x4_t *)a2 + 3)), (int8x16_t)v83, (int8x16_t)vaddq_f32(vminq_f32(vmaxq_f32(v82, *((float32x4_t *)a2 + 3)), v83), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
    v85 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v84), (int8x16_t)v83);
    v86 = (float32x4_t)vandq_s8((int8x16_t)v83, (int8x16_t)vcgtq_f32(v85, *((float32x4_t *)a2 + 23)));
    v87 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v84, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v84))), *((float32x4_t *)a2 + 22)), v86);
    v88 = vsubq_f32(vsubq_f32(v85, v83), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v86), v85));
    v89 = vmulq_f32(v88, v88);
    v90 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v87, vmulq_f32(v88, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v88, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v88)), vmulq_f32(v89, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v88)), vmulq_f32(v89, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v88)))))))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v91 = vcvtq_f32_s32(vcvtq_s32_f32(v90));
    v92 = vsubq_f32(v91, (float32x4_t)vandq_s8((int8x16_t)v83, (int8x16_t)vcgtq_f32(v91, v90)));
    v93 = vsubq_f32(v90, v92);
    *(int8x16_t *)(v6 + v81) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v82, (int8x16_t)vminq_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2), vmulq_laneq_f32(vmulq_f32(vaddq_f32(v83, vmulq_f32(v93, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v93, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v93)),
                                                              vmulq_f32(vmulq_f32(v93, v93), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v93)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v92)), 0x17uLL)), *(float32x4_t *)a2, 3)), v83));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype0_half_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int32x4_t v54;
  int32x4_t v55;
  int8x16_t v56;
  int8x16_t v57;
  int8x16_t *v58;
  int v59;
  uint64_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v59 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 3);
      v15 = vmaxq_f32(v13, v14);
      v16 = vmaxq_f32(v12, v14);
      v17 = *((float32x4_t *)a2 + 5);
      v18 = vminq_f32(v15, v17);
      v19 = vminq_f32(v16, v17);
      v20 = *((int8x16_t *)a2 + 19);
      v21 = *((float32x4_t *)a2 + 20);
      v22 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v18), (int8x16_t)v17);
      v23 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v19), (int8x16_t)v17);
      v24 = *((int8x16_t *)a2 + 21);
      v25 = *((float32x4_t *)a2 + 22);
      v26 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v18)));
      v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v19)));
      v28 = *((float32x4_t *)a2 + 23);
      v29 = *((float32x4_t *)a2 + 24);
      v30 = (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v22, v28));
      v31 = (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v23, v28));
      v32 = vaddq_f32(vsubq_f32(v26, v25), v30);
      v33 = vsubq_f32(vsubq_f32(v22, v17), vmulq_f32(vmulq_f32(v29, v30), v22));
      v34 = vsubq_f32(vsubq_f32(v23, v17), vmulq_f32(vmulq_f32(v29, v31), v23));
      v35 = *((float32x4_t *)a2 + 25);
      v36 = *((float32x4_t *)a2 + 26);
      v37 = *((float32x4_t *)a2 + 27);
      v38 = *((float32x4_t *)a2 + 28);
      v39 = vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(v27, v25), v31), vmulq_f32(v34, vaddq_f32(vaddq_f32(v37, vmulq_f32(v34, v38)), vmulq_f32(vmulq_f32(v34, v34), vaddq_f32(v35, vmulq_f32(v36, v34)))))), COERCE_FLOAT(*(_OWORD *)a2));
      v41 = *((float32x4_t *)a2 + 29);
      v40 = *((float32x4_t *)a2 + 30);
      v42 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v32, vmulq_f32(v33, vaddq_f32(vaddq_f32(v37, vmulq_f32(v33, v38)), vmulq_f32(vmulq_f32(v33, v33), vaddq_f32(v35, vmulq_f32(v36, v33)))))), COERCE_FLOAT(*(_OWORD *)a2)), v41);
      v43 = vmaxq_f32(v39, v41);
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
      v45 = vcvtq_f32_s32(vcvtq_s32_f32(v43));
      v46 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v44, v42)));
      v47 = vsubq_f32(v45, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v45, v43)));
      v48 = vsubq_f32(v42, v46);
      v49 = vsubq_f32(v43, v47);
      v50 = *((float32x4_t *)a2 + 31);
      v51 = *((float32x4_t *)a2 + 32);
      v52 = vmulq_f32(v49, vaddq_f32(v51, vmulq_f32(v49, vaddq_f32(v40, vmulq_f32(v50, v49)))));
      v53 = vaddq_f32(v17, vmulq_f32(v48, vaddq_f32(v51, vmulq_f32(v48, vaddq_f32(v40, vmulq_f32(v50, v48))))));
      v54 = vcvtq_s32_f32(v46);
      v55 = *((int32x4_t *)a2 + 33);
      v56 = (int8x16_t)vmulq_f32(vaddq_f32(v17, v52), (float32x4_t)vshlq_n_s32(vaddq_s32(v55, vcvtq_s32_f32(v47)), 0x17uLL));
      v57 = *((int8x16_t *)a2 + 15);
      v58 = (int8x16_t *)(v6 + v11);
      v58[-1] = vbslq_s8(v57, (int8x16_t)v13, (int8x16_t)vmulq_f32(v53, (float32x4_t)vshlq_n_s32(vaddq_s32(v55, v54), 0x17uLL)));
      *v58 = vbslq_s8(v57, (int8x16_t)v12, v56);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v59 = -v10;
    if (v59 >= v5)
      goto LABEL_3;
LABEL_10:
    v60 = 16 * v59;
    v61 = *(float32x4_t *)(v7 + v60);
    v62 = *((float32x4_t *)a2 + 5);
    v63 = vminq_f32(vmaxq_f32(v61, *((float32x4_t *)a2 + 3)), v62);
    v64 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v63), (int8x16_t)v62);
    v65 = (float32x4_t)vandq_s8((int8x16_t)v62, (int8x16_t)vcgtq_f32(v64, *((float32x4_t *)a2 + 23)));
    v66 = vsubq_f32(vsubq_f32(v64, v62), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v65), v64));
    v67 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v63, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v63))), *((float32x4_t *)a2 + 22)), v65), vmulq_f32(v66, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v66, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v66, v66), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v66)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v68 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
    v69 = vsubq_f32(v68, (float32x4_t)vandq_s8((int8x16_t)v62, (int8x16_t)vcgtq_f32(v68, v67)));
    v70 = vsubq_f32(v67, v69);
    *(int8x16_t *)(v6 + v60) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v61, (int8x16_t)vmulq_f32(vaddq_f32(v62, vmulq_f32(v70, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v70, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v70)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v69)), 0x17uLL)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype0_half_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  int8x16_t v16;
  float32x4_t v17;
  int8x16_t v18;
  int32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int8x16_t v63;
  int8x16_t *v64;
  int v65;
  uint64_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v65 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 3);
      v15 = (int8x16_t)vcgtq_f32(v14, v12);
      v16 = (int8x16_t)vcgtq_f32(v14, v13);
      v17 = *((float32x4_t *)a2 + 5);
      v19 = *((int32x4_t *)a2 + 33);
      v18 = *((int8x16_t *)a2 + 34);
      v20 = vmulq_f32(v12, (float32x4_t)vbslq_s8(v15, v18, (int8x16_t)v17));
      v21 = vmulq_f32(v13, (float32x4_t)vbslq_s8(v16, v18, (int8x16_t)v17));
      v22 = *((float32x4_t *)a2 + 35);
      v23 = *((int8x16_t *)a2 + 36);
      v24 = vminq_f32(v20, v22);
      v25 = vminq_f32(v21, v22);
      v26 = *((int8x16_t *)a2 + 19);
      v27 = *((float32x4_t *)a2 + 20);
      v28 = (float32x4_t)vorrq_s8(vandq_s8(v26, (int8x16_t)v24), (int8x16_t)v17);
      v29 = (float32x4_t)vorrq_s8(vandq_s8(v26, (int8x16_t)v25), (int8x16_t)v17);
      v30 = *((int8x16_t *)a2 + 21);
      v31 = *((float32x4_t *)a2 + 22);
      v32 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v25, 0x17uLL)), (float32x4_t)vandq_s8(v30, (int8x16_t)vcgtq_f32(v27, v25)));
      v33 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x17uLL)), (float32x4_t)vandq_s8(v30, (int8x16_t)vcgtq_f32(v27, v24))), v31);
      v34 = *((float32x4_t *)a2 + 23);
      v35 = *((float32x4_t *)a2 + 24);
      v36 = (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v28, v34));
      v37 = (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v29, v34));
      v38 = vaddq_f32(v33, v36);
      v39 = vaddq_f32(vsubq_f32(v32, v31), v37);
      v40 = vsubq_f32(vsubq_f32(v28, v17), vmulq_f32(vmulq_f32(v35, v36), v28));
      v41 = vsubq_f32(vsubq_f32(v29, v17), vmulq_f32(vmulq_f32(v35, v37), v29));
      v42 = *((float32x4_t *)a2 + 25);
      v43 = *((float32x4_t *)a2 + 26);
      v44 = vaddq_f32(v42, vmulq_f32(v43, v40));
      v45 = vaddq_f32(v42, vmulq_f32(v43, v41));
      v46 = *((float32x4_t *)a2 + 27);
      v47 = *((float32x4_t *)a2 + 28);
      v48 = vmulq_n_f32(vaddq_f32(v39, vmulq_f32(v41, vaddq_f32(vaddq_f32(v46, vmulq_f32(v41, v47)), vmulq_f32(vmulq_f32(v41, v41), v45)))), COERCE_FLOAT(*(_OWORD *)a2));
      v49 = *((float32x4_t *)a2 + 29);
      v50 = *((float32x4_t *)a2 + 30);
      v51 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v38, vmulq_f32(v40, vaddq_f32(vaddq_f32(v46, vmulq_f32(v40, v47)), vmulq_f32(vmulq_f32(v40, v40), v44)))), COERCE_FLOAT(*(_OWORD *)a2)), v49);
      v52 = vmaxq_f32(v48, v49);
      v53 = vcvtq_f32_s32(vcvtq_s32_f32(v51));
      v54 = vcvtq_f32_s32(vcvtq_s32_f32(v52));
      v55 = vsubq_f32(v53, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v53, v51)));
      v56 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v54, v52)));
      v57 = vsubq_f32(v51, v55);
      v58 = vsubq_f32(v52, v56);
      v59 = *((float32x4_t *)a2 + 31);
      v60 = *((float32x4_t *)a2 + 32);
      v61 = vaddq_f32(v17, vmulq_f32(v57, vaddq_f32(v60, vmulq_f32(v57, vaddq_f32(v50, vmulq_f32(v59, v57))))));
      v62 = vaddq_f32(v17, vmulq_f32(v58, vaddq_f32(v60, vmulq_f32(v58, vaddq_f32(v50, vmulq_f32(v59, v58))))));
      v63 = *((int8x16_t *)a2 + 15);
      v64 = (int8x16_t *)(v6 + v11);
      v64[-1] = vbslq_s8(v63, (int8x16_t)v12, veorq_s8(vandq_s8(v23, (int8x16_t)v12), (int8x16_t)vmulq_f32(v61, (float32x4_t)vshlq_n_s32(vaddq_s32(v19, vcvtq_s32_f32(v55)), 0x17uLL))));
      *v64 = vbslq_s8(v63, (int8x16_t)v13, veorq_s8(vandq_s8(v23, (int8x16_t)v13), (int8x16_t)vmulq_f32(v62, (float32x4_t)vshlq_n_s32(vaddq_s32(v19, vcvtq_s32_f32(v56)), 0x17uLL))));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v65 = -v10;
    if (v65 >= v5)
      goto LABEL_3;
LABEL_10:
    v66 = 16 * v65;
    v67 = *(float32x4_t *)(v7 + v66);
    v68 = *((float32x4_t *)a2 + 5);
    v69 = vminq_f32(vmulq_f32(v67, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 3), v67), *((int8x16_t *)a2 + 34), (int8x16_t)v68)), *((float32x4_t *)a2 + 35));
    v70 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v69), (int8x16_t)v68);
    v71 = (float32x4_t)vandq_s8((int8x16_t)v68, (int8x16_t)vcgtq_f32(v70, *((float32x4_t *)a2 + 23)));
    v72 = vsubq_f32(vsubq_f32(v70, v68), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v71), v70));
    v73 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v69, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v69))), *((float32x4_t *)a2 + 22)), v71), vmulq_f32(v72, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v72, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v72, v72), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v72)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v74 = vcvtq_f32_s32(vcvtq_s32_f32(v73));
    v75 = vsubq_f32(v74, (float32x4_t)vandq_s8((int8x16_t)v68, (int8x16_t)vcgtq_f32(v74, v73)));
    v76 = vsubq_f32(v73, v75);
    *(int8x16_t *)(v6 + v66) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v67, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v67), (int8x16_t)vmulq_f32(vaddq_f32(v68, vmulq_f32(v76, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v76, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v76)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v75)), 0x17uLL))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype0_nice_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  int32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int8x16_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t v80;
  int8x16_t *v81;
  int v82;
  uint64_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v82 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 3);
      v15 = *((float32x4_t *)a2 + 5);
      v17 = *((int32x4_t *)a2 + 33);
      v16 = *((int8x16_t *)a2 + 34);
      v18 = vmulq_f32(v13, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, v13), v16, (int8x16_t)v15));
      v20 = *((float32x4_t *)a2 + 35);
      v19 = *((int8x16_t *)a2 + 36);
      v21 = (int8x16_t)vminq_f32(vmulq_f32(v12, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, v12), v16, (int8x16_t)v15)), v20);
      v22 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v14)), v14);
      v23 = (float32x4_t)vbslq_s8(v22, (int8x16_t)v15, (int8x16_t)vminq_f32(v18, v20));
      v24 = (float32x4_t)vbslq_s8(v22, (int8x16_t)v15, v21);
      v26 = *((int8x16_t *)a2 + 19);
      v25 = *((float32x4_t *)a2 + 20);
      v27 = (float32x4_t)vorrq_s8(vandq_s8(v26, (int8x16_t)v23), (int8x16_t)v15);
      v28 = (float32x4_t)vorrq_s8(vandq_s8(v26, (int8x16_t)v24), (int8x16_t)v15);
      v29 = *((int8x16_t *)a2 + 21);
      v30 = *((float32x4_t *)a2 + 22);
      v31 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v25, v24)));
      v32 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v25, v23))), v30);
      v33 = *((float32x4_t *)a2 + 23);
      v34 = *((float32x4_t *)a2 + 24);
      v35 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v27, v33));
      v36 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v28, v33));
      v37 = vaddq_f32(v32, v35);
      v38 = vaddq_f32(vsubq_f32(v31, v30), v36);
      v39 = vsubq_f32(vsubq_f32(v27, v15), vmulq_f32(vmulq_f32(v34, v35), v27));
      v40 = vsubq_f32(vsubq_f32(v28, v15), vmulq_f32(vmulq_f32(v34, v36), v28));
      v41 = vmulq_f32(v39, v39);
      v42 = *((float32x4_t *)a2 + 37);
      v43 = *((float32x4_t *)a2 + 38);
      v44 = *((float32x4_t *)a2 + 39);
      v45 = *((float32x4_t *)a2 + 40);
      v46 = vaddq_f32(v42, vmulq_f32(v43, v39));
      v47 = vaddq_f32(v44, vmulq_f32(v45, v39));
      v48 = vaddq_f32(v44, vmulq_f32(v45, v40));
      v49 = vaddq_f32(v42, vmulq_f32(v43, v40));
      v50 = *((float32x4_t *)a2 + 41);
      v51 = *((float32x4_t *)a2 + 42);
      v52 = vaddq_f32(v50, vmulq_f32(v51, v39));
      v53 = vaddq_f32(v50, vmulq_f32(v51, v40));
      v54 = vmulq_f32(v40, v40);
      v55 = vaddq_f32(v52, vmulq_f32(v41, vaddq_f32(v46, vmulq_f32(v41, v47))));
      v56 = vaddq_f32(v53, vmulq_f32(v54, vaddq_f32(v49, vmulq_f32(v54, v48))));
      v57 = *((float32x4_t *)a2 + 43);
      v58 = *((float32x4_t *)a2 + 44);
      v59 = vmulq_n_f32(vaddq_f32(v38, vmulq_f32(v40, vaddq_f32(v57, vmulq_f32(v40, v56)))), COERCE_FLOAT(*(_OWORD *)a2));
      v60 = *((float32x4_t *)a2 + 29);
      v61 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v37, vmulq_f32(v39, vaddq_f32(v57, vmulq_f32(v39, v55)))), COERCE_FLOAT(*(_OWORD *)a2)), v60);
      v62 = vmaxq_f32(v59, v60);
      v63 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v64 = vcvtq_f32_s32(vcvtq_s32_f32(v62));
      v65 = vsubq_f32(v63, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v63, v61)));
      v66 = vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v64, v62)));
      v67 = vsubq_f32(v61, v65);
      v68 = vsubq_f32(v62, v66);
      v69 = *((float32x4_t *)a2 + 45);
      v70 = *((float32x4_t *)a2 + 46);
      v71 = vaddq_f32(v58, vmulq_f32(v69, v67));
      v72 = vaddq_f32(v58, vmulq_f32(v69, v68));
      v73 = *((float32x4_t *)a2 + 47);
      v74 = *((float32x4_t *)a2 + 48);
      v75 = vaddq_f32(v15, vmulq_f32(v67, vaddq_f32(v74, vmulq_f32(v67, vaddq_f32(vaddq_f32(v70, vmulq_f32(v67, v73)), vmulq_f32(vmulq_f32(v67, v67), v71))))));
      v76 = vaddq_f32(v15, vmulq_f32(v68, vaddq_f32(v74, vmulq_f32(v68, vaddq_f32(vaddq_f32(v70, vmulq_f32(v73, v68)), vmulq_f32(vmulq_f32(v68, v68), v72))))));
      v77 = (int8x16_t)vmulq_f32(v75, (float32x4_t)vshlq_n_s32(vaddq_s32(v17, vcvtq_s32_f32(v65)), 0x17uLL));
      v78 = vandq_s8(v19, (int8x16_t)v13);
      v79 = veorq_s8(vandq_s8(v19, (int8x16_t)v12), (int8x16_t)vmulq_f32(v76, (float32x4_t)vshlq_n_s32(vaddq_s32(v17, vcvtq_s32_f32(v66)), 0x17uLL)));
      v80 = *((int8x16_t *)a2 + 15);
      v81 = (int8x16_t *)(v6 + v11);
      v81[-1] = vbslq_s8(v80, (int8x16_t)v13, veorq_s8(v78, v77));
      *v81 = vbslq_s8(v80, (int8x16_t)v12, v79);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v82 = -v10;
    if (v82 >= v5)
      goto LABEL_3;
LABEL_10:
    v83 = 16 * v82;
    v84 = *(float32x4_t *)(v7 + v83);
    v85 = *((float32x4_t *)a2 + 5);
    v86 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v85, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), *((float32x4_t *)a2 + 3))), *((float32x4_t *)a2 + 3)), (int8x16_t)v85, (int8x16_t)vminq_f32(vmulq_f32(v84, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 3), v84), *((int8x16_t *)a2 + 34), (int8x16_t)v85)), *((float32x4_t *)a2 + 35)));
    v87 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v86), (int8x16_t)v85);
    v88 = (float32x4_t)vandq_s8((int8x16_t)v85, (int8x16_t)vcgtq_f32(v87, *((float32x4_t *)a2 + 23)));
    v89 = vsubq_f32(vsubq_f32(v87, v85), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v88), v87));
    v90 = vmulq_f32(v89, v89);
    v91 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v86, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v86))), *((float32x4_t *)a2 + 22)), v88), vmulq_f32(v89, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v89, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v89)),
                        vmulq_f32(v90, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v89)), vmulq_f32(v90, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v89)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
    v92 = vcvtq_f32_s32(vcvtq_s32_f32(v91));
    v93 = vsubq_f32(v92, (float32x4_t)vandq_s8((int8x16_t)v85, (int8x16_t)vcgtq_f32(v92, v91)));
    v94 = vsubq_f32(v91, v93);
    *(int8x16_t *)(v6 + v83) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v84, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v84), (int8x16_t)vmulq_f32(vaddq_f32(v85, vmulq_f32(v94, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v94, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v94)), vmulq_f32(vmulq_f32(v94, v94),
                                                            vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v94)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v93)), 0x17uLL))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype0_float_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = 16 * *((int *)a1 + 22);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((float32x4_t *)a2 + 5);
        v13 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), *((float32x4_t *)a2 + 3))), *((float32x4_t *)a2 + 3)), (int8x16_t)v12, (int8x16_t)vminq_f32(vmulq_f32(v11, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 3), v11), *((int8x16_t *)a2 + 34), (int8x16_t)v12)), *((float32x4_t *)a2 + 35)));
        v14 = *((float32x4_t *)a2 + 50);
        v15 = *((int8x16_t *)a2 + 52);
        v16 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v13);
        v17 = (int8x16_t)vmulq_f32(v13, vaddq_f32(v12, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 49), v16)));
        v18 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), v17), (int8x16_t)v12);
        v19 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v13, *((float32x4_t *)a2 + 21))), vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v13, v14), *((int8x16_t *)a2 + 51)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v13, v14))), (float32x4_t)vandq_s8(v15, v16))), *((float32x4_t *)a2 + 22)), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)));
        v20 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v18, *((float32x4_t *)a2 + 23)));
        v21 = vaddq_f32(v19, v20);
        v22 = vsubq_f32(vsubq_f32(v18, v12), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v20), v18));
        v23 = vmulq_f32(v22, v22);
        v24 = vmulq_n_f32(vaddq_f32(v21, vmulq_f32(v22, vaddq_f32(*((float32x4_t *)a2 + 61), vmulq_f32(v22, vaddq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 59), vmulq_f32(*((float32x4_t *)a2 + 60), v22)), vmulq_f32(v23, vaddq_f32(*((float32x4_t *)a2 + 57), vmulq_f32(*((float32x4_t *)a2 + 58), v22)))), vmulq_f32(vmulq_f32(v23, v23), vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 55), vmulq_f32(*((float32x4_t *)a2 + 56), v22)), vmulq_f32(
                                v23,
                                vaddq_f32(*((float32x4_t *)a2 + 53), vmulq_f32(*((float32x4_t *)a2 + 54), v22)))))))))),
                COERCE_FLOAT(*(_OWORD *)a2));
        v25 = vminq_f32(vmaxq_f32(v24, *((float32x4_t *)a2 + 62)), *((float32x4_t *)a2 + 63));
        v26 = vcvtq_f32_s32(vcvtq_s32_f32(v25));
        v27 = vsubq_f32(v26, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v26, v25)));
        v28 = vsubq_f32(v25, v27);
        v29 = vmulq_f32(v28, v28);
        v30 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 70), v27);
        *(int8x16_t *)(v7 + v10) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v11, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v11), vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v12, vorrq_s8((int8x16_t)vcltzq_f32(v24), (int8x16_t)vcgezq_f32(v24))), v14), (int8x16_t)vmulq_f32(vaddq_f32(v12, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 71), v30)), vmulq_f32(vaddq_f32(v12,
                                                          vmulq_f32(v28, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 68), vmulq_f32(v28, *((float32x4_t *)a2 + 69))), vmulq_f32(v29, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 66), vmulq_f32(*((float32x4_t *)a2 + 67), v28)), vmulq_f32(v29, vaddq_f32(*((float32x4_t *)a2 + 64), vmulq_f32(*((float32x4_t *)a2 + 65), v28)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33),
                                                                         vcvtq_s32_f32(vaddq_f32(v27, (float32x4_t)vandq_s8(v15, v30)))), 0x17uLL))), (int8x16_t)v24)));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v6;
      v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype1_fast_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int8x16_t v47;
  int8x16_t v48;
  int8x16_t v49;
  int8x16_t v50;
  int8x16_t *v51;
  int v52;
  uint64_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v52 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 50);
      v15 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v16 = *((float32x4_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vminq_f32(vmaxq_f32(v13, v14), v16);
      v19 = vminq_f32(vmaxq_f32(v12, v14), v16);
      v20 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v18, v15)));
      v21 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v19, v15)));
      v22 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
      v23 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
      v24 = *((float32x4_t *)a2 + 7);
      v25 = *((float32x4_t *)a2 + 8);
      v26 = vrsqrteq_f32(vaddq_f32(v24, vsubq_f32(v20, v22)));
      v27 = vrsqrteq_f32(vaddq_f32(v24, vsubq_f32(v21, v23)));
      v28 = vaddq_f32(v25, v22);
      v29 = vaddq_f32(v25, v23);
      v30 = *((float32x4_t *)a2 + 9);
      v31 = *((float32x4_t *)a2 + 10);
      v32 = vmulq_n_f32(vsubq_f32(v28, vmulq_f32(v26, v30)), COERCE_FLOAT(*(_OWORD *)a2));
      v33 = vmulq_n_f32(vsubq_f32(v29, vmulq_f32(v27, v30)), COERCE_FLOAT(*(_OWORD *)a2));
      v34 = vcvtq_f32_s32(vcvtq_s32_f32(v32));
      v35 = vcvtq_f32_s32(vcvtq_s32_f32(v33));
      v36 = vsubq_f32(v34, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v34, v32)));
      v37 = vsubq_f32(v35, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v35, v33)));
      v38 = *((float32x4_t *)a2 + 11);
      v39 = *((float32x4_t *)a2 + 12);
      v40 = vmulq_f32(vrecpeq_f32(vsubq_f32(v38, vsubq_f32(v32, v36))), v39);
      v41 = vmulq_f32(vrecpeq_f32(vsubq_f32(v38, vsubq_f32(v33, v37))), v39);
      v42 = vaddq_f32(vaddq_f32(v31, v37), vmulq_f32(v41, v41));
      v43 = vmaxq_f32(vaddq_f32(vaddq_f32(v31, v36), vmulq_f32(v40, v40)), v14);
      v44 = *((float32x4_t *)a2 + 13);
      v45 = *((float32x4_t *)a2 + 14);
      v46 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v47 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vbicq_s8(*((int8x16_t *)a2 + 3), *((int8x16_t *)a2 + 74)), 0);
      v48 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v46)), v47, (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v43, v44), v45)), *(float32x4_t *)a2, 3)), v16);
      v49 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v19, v46)), v47, (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v42, v14), v44), v45)), *(float32x4_t *)a2, 3)), v16);
      v50 = *((int8x16_t *)a2 + 15);
      v51 = (int8x16_t *)(v6 + v11);
      v51[-1] = vbslq_s8(v50, (int8x16_t)v13, v48);
      *v51 = vbslq_s8(v50, (int8x16_t)v12, v49);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v52 = -v10;
    if (v52 >= v5)
      goto LABEL_3;
LABEL_10:
    v53 = 16 * v52;
    v54 = *(float32x4_t *)(v7 + v53);
    v55 = *((float32x4_t *)a2 + 50);
    v56 = *((float32x4_t *)a2 + 5);
    v57 = vminq_f32(vmaxq_f32(v54, v55), v56);
    v58 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v57, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
    v59 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
    v60 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v59), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v58, v59))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
    v61 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
    v62 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v56, (int8x16_t)vcgtq_f32(v61, v60)));
    v63 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v60, v62))), *((float32x4_t *)a2 + 12));
    *(int8x16_t *)(v6 + v53) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v54, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v55, vsubq_f32(v57, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vbicq_s8(*((int8x16_t *)a2 + 3), *((int8x16_t *)a2 + 74)), 0), (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(
                                                                                           vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v63, v63), vaddq_f32(*((float32x4_t *)a2 + 10), v62)), v55), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))), *(float32x4_t *)a2, 3)), v56));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype1_fixed_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int8x16_t v47;
  int8x16_t v48;
  int8x16_t v49;
  int8x16_t v50;
  int8x16_t *v51;
  int v52;
  uint64_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v52 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 50);
      v15 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v16 = *((float32x4_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vminq_f32(vmaxq_f32(v13, v14), v16);
      v19 = vminq_f32(vmaxq_f32(v12, v14), v16);
      v20 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v18, v15)));
      v21 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v19, v15)));
      v22 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
      v23 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
      v24 = *((float32x4_t *)a2 + 7);
      v25 = *((float32x4_t *)a2 + 8);
      v26 = vrsqrteq_f32(vaddq_f32(v24, vsubq_f32(v20, v22)));
      v27 = vrsqrteq_f32(vaddq_f32(v24, vsubq_f32(v21, v23)));
      v28 = vaddq_f32(v25, v22);
      v29 = vaddq_f32(v25, v23);
      v30 = *((float32x4_t *)a2 + 9);
      v31 = *((float32x4_t *)a2 + 10);
      v32 = vmulq_n_f32(vsubq_f32(v28, vmulq_f32(v26, v30)), COERCE_FLOAT(*(_OWORD *)a2));
      v33 = vmulq_n_f32(vsubq_f32(v29, vmulq_f32(v27, v30)), COERCE_FLOAT(*(_OWORD *)a2));
      v34 = vcvtq_f32_s32(vcvtq_s32_f32(v32));
      v35 = vcvtq_f32_s32(vcvtq_s32_f32(v33));
      v36 = vsubq_f32(v34, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v34, v32)));
      v37 = vsubq_f32(v35, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v35, v33)));
      v38 = *((float32x4_t *)a2 + 11);
      v39 = *((float32x4_t *)a2 + 12);
      v40 = vmulq_f32(vrecpeq_f32(vsubq_f32(v38, vsubq_f32(v32, v36))), v39);
      v41 = vmulq_f32(vrecpeq_f32(vsubq_f32(v38, vsubq_f32(v33, v37))), v39);
      v42 = vaddq_f32(vaddq_f32(v31, v37), vmulq_f32(v41, v41));
      v43 = vmaxq_f32(vaddq_f32(vaddq_f32(v31, v36), vmulq_f32(v40, v40)), v14);
      v44 = *((float32x4_t *)a2 + 13);
      v45 = *((float32x4_t *)a2 + 14);
      v46 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v47 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vbicq_s8(*((int8x16_t *)a2 + 3), *((int8x16_t *)a2 + 74)), 0);
      v48 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v46)), v47, (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v43, v44), v45)), *(float32x4_t *)a2, 3)), v16);
      v49 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v19, v46)), v47, (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v42, v14), v44), v45)), *(float32x4_t *)a2, 3)), v16);
      v50 = *((int8x16_t *)a2 + 15);
      v51 = (int8x16_t *)(v6 + v11);
      v51[-1] = vbslq_s8(v50, (int8x16_t)v13, v48);
      *v51 = vbslq_s8(v50, (int8x16_t)v12, v49);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v52 = -v10;
    if (v52 >= v5)
      goto LABEL_3;
LABEL_10:
    v53 = 16 * v52;
    v54 = *(float32x4_t *)(v7 + v53);
    v55 = *((float32x4_t *)a2 + 50);
    v56 = *((float32x4_t *)a2 + 5);
    v57 = vminq_f32(vmaxq_f32(v54, v55), v56);
    v58 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v57, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
    v59 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
    v60 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v59), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v58, v59))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
    v61 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
    v62 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v56, (int8x16_t)vcgtq_f32(v61, v60)));
    v63 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v60, v62))), *((float32x4_t *)a2 + 12));
    *(int8x16_t *)(v6 + v53) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v54, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v55, vsubq_f32(v57, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vbicq_s8(*((int8x16_t *)a2 + 3), *((int8x16_t *)a2 + 74)), 0), (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(
                                                                                           vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v63, v63), vaddq_f32(*((float32x4_t *)a2 + 10), v62)), v55), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))), *(float32x4_t *)a2, 3)), v56));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype1_nice_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = 16 * *((int *)a1 + 22);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((float32x4_t *)a2 + 75);
        v13 = *((float32x4_t *)a2 + 5);
        v14 = vminq_f32(vmaxq_f32(v11, v12), v13);
        v15 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v13, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v12)), v12), (int8x16_t)v13, (int8x16_t)vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v16 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v15), (int8x16_t)v13);
        v17 = (float32x4_t)vandq_s8((int8x16_t)v13, (int8x16_t)vcgtq_f32(v16, *((float32x4_t *)a2 + 23)));
        v18 = vsubq_f32(vsubq_f32(v16, v13), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v17), v16));
        v19 = vmulq_f32(v18, v18);
        v20 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v15, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v15))), *((float32x4_t *)a2 + 22)), v17), vmulq_f32(v18, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v18, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v18)),
                            vmulq_f32(v19, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v18)), vmulq_f32(v19, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v18)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
        v21 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
        v22 = vsubq_f32(v21, (float32x4_t)vandq_s8((int8x16_t)v13, (int8x16_t)vcgtq_f32(v21, v20)));
        v23 = vsubq_f32(v20, v22);
        *(int8x16_t *)(v7 + v10) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v11, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v12, vsubq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vbicq_s8(*((int8x16_t *)a2 + 3), *((int8x16_t *)a2 + 74)), 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v13, vmulq_f32(
                                                                                    v23,
                                                                                    vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v23, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v23)), vmulq_f32(vmulq_f32(v23, v23), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v23)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33),
                                                                                                 vcvtq_s32_f32(v22)),
                                                                                               0x17uLL)),
                                                                              *(float32x4_t *)a2,
                                                                              3)),
                                                  v13));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v6;
      v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype1_half_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int32x4_t v59;
  int32x4_t v60;
  float32x4_t v61;
  int8x16_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int8x16_t v65;
  int8x16_t v66;
  int8x16_t v67;
  int8x16_t *v68;
  int v69;
  uint64_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v69 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 50);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v17 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v18 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v19 = vaddq_f32(v17, v16);
      v20 = vaddq_f32(v18, v16);
      v21 = *((int8x16_t *)a2 + 19);
      v22 = *((float32x4_t *)a2 + 20);
      v23 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v19), (int8x16_t)v15);
      v24 = *((int8x16_t *)a2 + 21);
      v25 = *((float32x4_t *)a2 + 22);
      v26 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v20), (int8x16_t)v15);
      v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v20)));
      v28 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v19))), v25);
      v29 = *((float32x4_t *)a2 + 23);
      v30 = *((float32x4_t *)a2 + 24);
      v31 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v23, v29));
      v32 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v26, v29));
      v33 = vaddq_f32(v28, v31);
      v34 = vmulq_f32(v30, v31);
      v35 = vmulq_f32(vmulq_f32(v30, v32), v26);
      v36 = vaddq_f32(vsubq_f32(v27, v25), v32);
      v37 = vsubq_f32(vsubq_f32(v23, v15), vmulq_f32(v34, v23));
      v38 = vsubq_f32(vsubq_f32(v26, v15), v35);
      v39 = *((float32x4_t *)a2 + 25);
      v40 = *((float32x4_t *)a2 + 26);
      v41 = *((float32x4_t *)a2 + 27);
      v42 = *((float32x4_t *)a2 + 28);
      v43 = vmulq_n_f32(vaddq_f32(v33, vmulq_f32(v37, vaddq_f32(vaddq_f32(v41, vmulq_f32(v42, v37)), vmulq_f32(vmulq_f32(v37, v37), vaddq_f32(v39, vmulq_f32(v40, v37)))))), COERCE_FLOAT(*(_OWORD *)a2));
      v44 = vmulq_n_f32(vaddq_f32(v36, vmulq_f32(v38, vaddq_f32(vaddq_f32(v41, vmulq_f32(v42, v38)), vmulq_f32(vmulq_f32(v38, v38), vaddq_f32(v39, vmulq_f32(v40, v38)))))), COERCE_FLOAT(*(_OWORD *)a2));
      v45 = *((float32x4_t *)a2 + 29);
      v46 = *((float32x4_t *)a2 + 30);
      v47 = vmaxq_f32(v43, v45);
      v48 = vmaxq_f32(v44, v45);
      v49 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      v50 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
      v51 = vsubq_f32(v49, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v49, v47)));
      v52 = vsubq_f32(v50, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v50, v48)));
      v53 = vsubq_f32(v47, v51);
      v54 = vsubq_f32(v48, v52);
      v55 = *((float32x4_t *)a2 + 31);
      v56 = *((float32x4_t *)a2 + 32);
      v57 = vmulq_f32(v54, vaddq_f32(v56, vmulq_f32(v54, vaddq_f32(v46, vmulq_f32(v55, v54)))));
      v58 = vaddq_f32(v15, vmulq_f32(v53, vaddq_f32(v56, vmulq_f32(v53, vaddq_f32(v46, vmulq_f32(v55, v53))))));
      v59 = vcvtq_s32_f32(v52);
      v60 = *((int32x4_t *)a2 + 33);
      v61 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v62 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vbicq_s8(*((int8x16_t *)a2 + 3), *((int8x16_t *)a2 + 74)), 0);
      v63 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v61)), v62, (int8x16_t)vmulq_laneq_f32(vmulq_f32(v58, (float32x4_t)vshlq_n_s32(vaddq_s32(v60, vcvtq_s32_f32(v51)), 0x17uLL)), *(float32x4_t *)a2, 3));
      v64 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v61)), v62, (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v15, v57), (float32x4_t)vshlq_n_s32(vaddq_s32(v60, v59), 0x17uLL)), *(float32x4_t *)a2, 3));
      v65 = (int8x16_t)vminq_f32(v63, v15);
      v66 = (int8x16_t)vminq_f32(v64, v15);
      v67 = *((int8x16_t *)a2 + 15);
      v68 = (int8x16_t *)(v6 + v11);
      v68[-1] = vbslq_s8(v67, (int8x16_t)v13, v65);
      *v68 = vbslq_s8(v67, (int8x16_t)v12, v66);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v69 = -v10;
    if (v69 >= v5)
      goto LABEL_3;
LABEL_10:
    v70 = 16 * v69;
    v71 = *(float32x4_t *)(v7 + v70);
    v72 = *((float32x4_t *)a2 + 50);
    v73 = *((float32x4_t *)a2 + 5);
    v74 = vminq_f32(vmaxq_f32(v71, v72), v73);
    v75 = vaddq_f32(v74, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v76 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v75), (int8x16_t)v73);
    v77 = (float32x4_t)vandq_s8((int8x16_t)v73, (int8x16_t)vcgtq_f32(v76, *((float32x4_t *)a2 + 23)));
    v78 = vsubq_f32(vsubq_f32(v76, v73), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v77), v76));
    v79 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v75, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v75))), *((float32x4_t *)a2 + 22)), v77), vmulq_f32(v78, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(*((float32x4_t *)a2 + 28), v78)), vmulq_f32(vmulq_f32(v78, v78), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v78)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v80 = vcvtq_f32_s32(vcvtq_s32_f32(v79));
    v81 = vsubq_f32(v80, (float32x4_t)vandq_s8((int8x16_t)v73, (int8x16_t)vcgtq_f32(v80, v79)));
    v82 = vsubq_f32(v79, v81);
    *(int8x16_t *)(v6 + v70) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v71, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v72, vsubq_f32(v74, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vbicq_s8(*((int8x16_t *)a2 + 3), *((int8x16_t *)a2 + 74)), 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(
                                                                              v73,
                                                                              vmulq_f32(v82, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v82, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v82)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v81)), 0x17uLL)), *(float32x4_t *)a2, 3)), v73));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype1_half_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  int32x4_t v60;
  int32x4_t v61;
  float32x4_t v62;
  int8x16_t v63;
  int8x16_t v64;
  int8x16_t v65;
  int8x16_t v66;
  int8x16_t *v67;
  int v68;
  uint64_t v69;
  float32x4_t v70;
  float32x4_t v71;
  int32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v68 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = (int32x4_t)vbicq_s8((int8x16_t)v14, *((int8x16_t *)a2 + 74));
      v16 = (float32x4_t)vdupq_laneq_s32(v15, 3);
      v17 = vminq_f32(vmaxq_f32(v13, v14), v16);
      v18 = vminq_f32(vmaxq_f32(v12, v14), v16);
      v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v20 = vaddq_f32(v17, v19);
      v21 = vaddq_f32(v18, v19);
      v22 = *((int8x16_t *)a2 + 19);
      v23 = *((float32x4_t *)a2 + 20);
      v24 = *((float32x4_t *)a2 + 5);
      v25 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v20), (int8x16_t)v24);
      v26 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v21), (int8x16_t)v24);
      v27 = *((int8x16_t *)a2 + 21);
      v28 = *((float32x4_t *)a2 + 22);
      v29 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v23, v21)));
      v30 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v23, v20))), v28);
      v31 = *((float32x4_t *)a2 + 23);
      v32 = *((float32x4_t *)a2 + 24);
      v33 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v25, v31));
      v34 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v26, v31));
      v35 = vaddq_f32(v30, v33);
      v36 = vaddq_f32(vsubq_f32(v29, v28), v34);
      v37 = vsubq_f32(vsubq_f32(v25, v24), vmulq_f32(vmulq_f32(v32, v33), v25));
      v38 = vsubq_f32(vsubq_f32(v26, v24), vmulq_f32(vmulq_f32(v32, v34), v26));
      v39 = *((float32x4_t *)a2 + 25);
      v40 = *((float32x4_t *)a2 + 26);
      v41 = vaddq_f32(v39, vmulq_f32(v40, v37));
      v42 = vaddq_f32(v39, vmulq_f32(v40, v38));
      v43 = *((float32x4_t *)a2 + 27);
      v44 = *((float32x4_t *)a2 + 28);
      v45 = vaddq_f32(v36, vmulq_f32(v38, vaddq_f32(vaddq_f32(v43, vmulq_f32(v38, v44)), vmulq_f32(vmulq_f32(v38, v38), v42))));
      v46 = *((float32x4_t *)a2 + 29);
      v47 = *((float32x4_t *)a2 + 30);
      v48 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v35, vmulq_f32(v37, vaddq_f32(vaddq_f32(v43, vmulq_f32(v37, v44)), vmulq_f32(vmulq_f32(v37, v37), v41)))), COERCE_FLOAT(*(_OWORD *)a2)), v46);
      v49 = vmaxq_f32(vmulq_n_f32(v45, COERCE_FLOAT(*(_OWORD *)a2)), v46);
      v50 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
      v51 = vcvtq_f32_s32(vcvtq_s32_f32(v49));
      v52 = vsubq_f32(v50, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v50, v48)));
      v53 = vsubq_f32(v51, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v51, v49)));
      v54 = vsubq_f32(v48, v52);
      v55 = vsubq_f32(v49, v53);
      v56 = *((float32x4_t *)a2 + 31);
      v57 = *((float32x4_t *)a2 + 32);
      v58 = vaddq_f32(v47, vmulq_f32(v56, v54));
      v59 = vmulq_f32(v55, vaddq_f32(v57, vmulq_f32(v55, vaddq_f32(v47, vmulq_f32(v56, v55)))));
      v60 = vcvtq_s32_f32(v53);
      v61 = *((int32x4_t *)a2 + 33);
      v62 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v63 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 0);
      v64 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v62)), v63, (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v24, vmulq_f32(v54, vaddq_f32(v57, vmulq_f32(v54, v58)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v61, vcvtq_s32_f32(v52)), 0x17uLL)), *(float32x4_t *)a2, 3));
      v65 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v62)), v63, (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v24, v59), (float32x4_t)vshlq_n_s32(vaddq_s32(v61, v60), 0x17uLL)), *(float32x4_t *)a2, 3));
      v66 = *((int8x16_t *)a2 + 15);
      v67 = (int8x16_t *)(v6 + v11);
      v67[-1] = vbslq_s8(v66, (int8x16_t)v13, v64);
      *v67 = vbslq_s8(v66, (int8x16_t)v12, v65);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v68 = -v10;
    if (v68 >= v5)
      goto LABEL_3;
LABEL_10:
    v69 = 16 * v68;
    v70 = *(float32x4_t *)(v7 + v69);
    v71 = *((float32x4_t *)a2 + 75);
    v72 = (int32x4_t)vbicq_s8((int8x16_t)v71, *((int8x16_t *)a2 + 74));
    v73 = vminq_f32(vmaxq_f32(v70, v71), (float32x4_t)vdupq_laneq_s32(v72, 3));
    v74 = vaddq_f32(v73, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v75 = *((float32x4_t *)a2 + 5);
    v76 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v74), (int8x16_t)v75);
    v77 = (float32x4_t)vandq_s8((int8x16_t)v75, (int8x16_t)vcgtq_f32(v76, *((float32x4_t *)a2 + 23)));
    v78 = vsubq_f32(vsubq_f32(v76, v75), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v77), v76));
    v79 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v74, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v74))), *((float32x4_t *)a2 + 22)), v77), vmulq_f32(v78, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v78, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v78, v78), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v78)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v80 = vcvtq_f32_s32(vcvtq_s32_f32(v79));
    v81 = vsubq_f32(v80, (float32x4_t)vandq_s8((int8x16_t)v75, (int8x16_t)vcgtq_f32(v80, v79)));
    v82 = vsubq_f32(v79, v81);
    *(int8x16_t *)(v6 + v69) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v70, vbslq_s8((int8x16_t)vcgtq_f32(v71, vsubq_f32(v73, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v72.i8, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v75, vmulq_f32(v82, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v82,
                                                          vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v82)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v81)), 0x17uLL)), *(float32x4_t *)a2, 3)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype1_nice_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  int32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = 16 * *((int *)a1 + 22);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((float32x4_t *)a2 + 75);
        v13 = (int32x4_t)vbicq_s8((int8x16_t)v12, *((int8x16_t *)a2 + 74));
        v14 = vminq_f32(vmaxq_f32(v11, v12), (float32x4_t)vdupq_laneq_s32(v13, 3));
        v15 = *((float32x4_t *)a2 + 5);
        v16 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v12)), v12), (int8x16_t)v15, (int8x16_t)vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v17 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v16), (int8x16_t)v15);
        v18 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v17, *((float32x4_t *)a2 + 23)));
        v19 = vsubq_f32(vsubq_f32(v17, v15), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v18), v17));
        v20 = vmulq_f32(v19, v19);
        v21 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v16))), *((float32x4_t *)a2 + 22)), v18), vmulq_f32(v19, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v19, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v19)),
                            vmulq_f32(v20, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v19)), vmulq_f32(v20, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v19)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
        v22 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
        v23 = vsubq_f32(v22, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v22, v21)));
        v24 = vsubq_f32(v21, v23);
        *(int8x16_t *)(v7 + v10) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32(v12, vsubq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v13.i8, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v15, vmulq_f32(v24, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v24,
                                                              vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v24)), vmulq_f32(vmulq_f32(v24, v24), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v24)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v23)), 0x17uLL)), *(float32x4_t *)a2, 3)));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v6;
      v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype1_float_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  int32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = 16 * *((int *)a1 + 22);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((float32x4_t *)a2 + 75);
        v13 = (int32x4_t)vbicq_s8((int8x16_t)v12, *((int8x16_t *)a2 + 74));
        v14 = vminq_f32(vmaxq_f32(v11, v12), (float32x4_t)vdupq_laneq_s32(v13, 3));
        v15 = *((float32x4_t *)a2 + 5);
        v16 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v12)), v12), (int8x16_t)v15, (int8x16_t)vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v17 = *((int8x16_t *)a2 + 52);
        v18 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v16);
        v19 = (int8x16_t)vmulq_f32(v16, vaddq_f32(v15, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 49), v18)));
        v20 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), v19), (int8x16_t)v15);
        v21 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v16, *((float32x4_t *)a2 + 21))), vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v16, *((float32x4_t *)a2 + 50)), *((int8x16_t *)a2 + 51)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v16, *((float32x4_t *)a2 + 50)))), (float32x4_t)vandq_s8(v17, v18))), *((float32x4_t *)a2 + 22)), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)));
        v22 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v20, *((float32x4_t *)a2 + 23)));
        v23 = vaddq_f32(v21, v22);
        v24 = vsubq_f32(vsubq_f32(v20, v15), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v22), v20));
        v25 = vmulq_f32(v24, v24);
        v26 = vmulq_n_f32(vaddq_f32(v23, vmulq_f32(v24, vaddq_f32(*((float32x4_t *)a2 + 61), vmulq_f32(v24, vaddq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 59), vmulq_f32(*((float32x4_t *)a2 + 60), v24)), vmulq_f32(v25, vaddq_f32(*((float32x4_t *)a2 + 57), vmulq_f32(*((float32x4_t *)a2 + 58), v24)))), vmulq_f32(vmulq_f32(v25, v25), vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 55), vmulq_f32(*((float32x4_t *)a2 + 56), v24)), vmulq_f32(
                                v25,
                                vaddq_f32(*((float32x4_t *)a2 + 53), vmulq_f32(*((float32x4_t *)a2 + 54), v24)))))))))),
                COERCE_FLOAT(*(_OWORD *)a2));
        v27 = vminq_f32(vmaxq_f32(v26, *((float32x4_t *)a2 + 62)), *((float32x4_t *)a2 + 63));
        v28 = vcvtq_f32_s32(vcvtq_s32_f32(v27));
        v29 = vsubq_f32(v28, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v28, v27)));
        v30 = vsubq_f32(v27, v29);
        v31 = vmulq_f32(v30, v30);
        v32 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 70), v29);
        *(int8x16_t *)(v7 + v10) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32(v12, vsubq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v13.i8, 0), (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, vorrq_s8((int8x16_t)vcltzq_f32(v26), (int8x16_t)vcgezq_f32(v26))), v12), (int8x16_t)vmulq_f32(
                                                                                vaddq_f32(v15, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 71), v32)), vmulq_f32(vaddq_f32(v15, vmulq_f32(v30, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 68), vmulq_f32(v30, *((float32x4_t *)a2 + 69))), vmulq_f32(v31, vaddq_f32(vaddq_f32(
                                                                                              *((float32x4_t *)a2 + 66),
                                                                                              vmulq_f32(*((float32x4_t *)a2 + 67), v30)), vmulq_f32(v31, vaddq_f32(*((float32x4_t *)a2 + 64), vmulq_f32(*((float32x4_t *)a2+ 65), v30)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(vaddq_f32(v29, (float32x4_t)vandq_s8(v17, v32)))), 0x17uLL))), (int8x16_t)v26), *(float32x4_t *)a2, 3)));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v6;
      v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype2_fast_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  int8x16_t v51;
  float32x4_t v52;
  int8x16_t v53;
  int8x16_t v54;
  float32x4_t v55;
  int8x16_t *v56;
  int v57;
  uint64_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v57 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v16 = *((float32x4_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vminq_f32(vmaxq_f32(v13, v14), v16);
      v19 = vminq_f32(vmaxq_f32(v12, v14), v16);
      v20 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v18, v15)));
      v21 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v19, v15)));
      v22 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
      v23 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
      v24 = *((float32x4_t *)a2 + 7);
      v25 = *((float32x4_t *)a2 + 8);
      v26 = vrsqrteq_f32(vaddq_f32(v24, vsubq_f32(v20, v22)));
      v27 = vrsqrteq_f32(vaddq_f32(v24, vsubq_f32(v21, v23)));
      v28 = vaddq_f32(v25, v22);
      v29 = vaddq_f32(v25, v23);
      v30 = *((float32x4_t *)a2 + 9);
      v31 = *((float32x4_t *)a2 + 10);
      v32 = vmulq_n_f32(vsubq_f32(v28, vmulq_f32(v26, v30)), COERCE_FLOAT(*(_OWORD *)a2));
      v33 = vmulq_n_f32(vsubq_f32(v29, vmulq_f32(v27, v30)), COERCE_FLOAT(*(_OWORD *)a2));
      v34 = vcvtq_f32_s32(vcvtq_s32_f32(v32));
      v35 = vcvtq_f32_s32(vcvtq_s32_f32(v33));
      v36 = vsubq_f32(v34, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v34, v32)));
      v37 = vsubq_f32(v35, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v35, v33)));
      v38 = vsubq_f32(v32, v36);
      v39 = vsubq_f32(v33, v37);
      v40 = vaddq_f32(v31, v36);
      v41 = vaddq_f32(v31, v37);
      v42 = *((float32x4_t *)a2 + 11);
      v43 = *((float32x4_t *)a2 + 12);
      v44 = vmulq_f32(vrecpeq_f32(vsubq_f32(v42, v38)), v43);
      v45 = vmulq_f32(vrecpeq_f32(vsubq_f32(v42, v39)), v43);
      v46 = vmaxq_f32(vaddq_f32(v40, vmulq_f32(v44, v44)), v14);
      v47 = vmaxq_f32(vaddq_f32(v41, vmulq_f32(v45, v45)), v14);
      v48 = *((float32x4_t *)a2 + 13);
      v49 = *((float32x4_t *)a2 + 14);
      v50 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v51 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vbicq_s8(*((int8x16_t *)a2 + 3), *((int8x16_t *)a2 + 74)), 0);
      v52 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v19, v50)), v51, (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v47, v48), v49)), *(float32x4_t *)a2, 3));
      v53 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v50)), v51, (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v46, v48), v49)), *(float32x4_t *)a2, 3)), v16);
      v54 = *((int8x16_t *)a2 + 15);
      v55 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v56 = (int8x16_t *)(v6 + v11);
      v56[-1] = vbslq_s8(v54, (int8x16_t)v13, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v55, (float32x4_t)vbslq_s8(v54, (int8x16_t)v13, v53)), v14), v16));
      *v56 = vbslq_s8(v54, (int8x16_t)v12, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v55, (float32x4_t)vbslq_s8(v54, (int8x16_t)v12, (int8x16_t)vminq_f32(v52, v16))), v14), v16));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v57 = -v10;
    if (v57 >= v5)
      goto LABEL_3;
LABEL_10:
    v58 = 16 * v57;
    v59 = *(float32x4_t *)(v7 + v58);
    v60 = *((float32x4_t *)a2 + 75);
    v61 = *((float32x4_t *)a2 + 5);
    v62 = vminq_f32(vmaxq_f32(v59, v60), v61);
    v63 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v62, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
    v64 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
    v65 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v64), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v63, v64))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
    v66 = vcvtq_f32_s32(vcvtq_s32_f32(v65));
    v67 = vsubq_f32(v66, (float32x4_t)vandq_s8((int8x16_t)v61, (int8x16_t)vcgtq_f32(v66, v65)));
    v68 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v65, v67))), *((float32x4_t *)a2 + 12));
    *(int8x16_t *)(v6 + v58) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v59, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v59, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v60, vsubq_f32(v62, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vbicq_s8(*((int8x16_t *)a2 + 3), *((int8x16_t *)a2 + 74)), 0), (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v68, v68), vaddq_f32(*((float32x4_t *)a2 + 10), v67)), v60), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))), *(float32x4_t *)a2, 3)), v61))), v60), v61));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype2_fixed_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  int8x16_t v51;
  float32x4_t v52;
  int8x16_t v53;
  int8x16_t v54;
  float32x4_t v55;
  int8x16_t *v56;
  int v57;
  uint64_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v57 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v16 = *((float32x4_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vminq_f32(vmaxq_f32(v13, v14), v16);
      v19 = vminq_f32(vmaxq_f32(v12, v14), v16);
      v20 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v18, v15)));
      v21 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v19, v15)));
      v22 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
      v23 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
      v24 = *((float32x4_t *)a2 + 7);
      v25 = *((float32x4_t *)a2 + 8);
      v26 = vrsqrteq_f32(vaddq_f32(v24, vsubq_f32(v20, v22)));
      v27 = vrsqrteq_f32(vaddq_f32(v24, vsubq_f32(v21, v23)));
      v28 = vaddq_f32(v25, v22);
      v29 = vaddq_f32(v25, v23);
      v30 = *((float32x4_t *)a2 + 9);
      v31 = *((float32x4_t *)a2 + 10);
      v32 = vmulq_n_f32(vsubq_f32(v28, vmulq_f32(v26, v30)), COERCE_FLOAT(*(_OWORD *)a2));
      v33 = vmulq_n_f32(vsubq_f32(v29, vmulq_f32(v27, v30)), COERCE_FLOAT(*(_OWORD *)a2));
      v34 = vcvtq_f32_s32(vcvtq_s32_f32(v32));
      v35 = vcvtq_f32_s32(vcvtq_s32_f32(v33));
      v36 = vsubq_f32(v34, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v34, v32)));
      v37 = vsubq_f32(v35, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v35, v33)));
      v38 = vsubq_f32(v32, v36);
      v39 = vsubq_f32(v33, v37);
      v40 = vaddq_f32(v31, v36);
      v41 = vaddq_f32(v31, v37);
      v42 = *((float32x4_t *)a2 + 11);
      v43 = *((float32x4_t *)a2 + 12);
      v44 = vmulq_f32(vrecpeq_f32(vsubq_f32(v42, v38)), v43);
      v45 = vmulq_f32(vrecpeq_f32(vsubq_f32(v42, v39)), v43);
      v46 = vmaxq_f32(vaddq_f32(v40, vmulq_f32(v44, v44)), v14);
      v47 = vmaxq_f32(vaddq_f32(v41, vmulq_f32(v45, v45)), v14);
      v48 = *((float32x4_t *)a2 + 13);
      v49 = *((float32x4_t *)a2 + 14);
      v50 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v51 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vbicq_s8(*((int8x16_t *)a2 + 3), *((int8x16_t *)a2 + 74)), 0);
      v52 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v19, v50)), v51, (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v47, v48), v49)), *(float32x4_t *)a2, 3));
      v53 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v50)), v51, (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v46, v48), v49)), *(float32x4_t *)a2, 3)), v16);
      v54 = *((int8x16_t *)a2 + 15);
      v55 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v56 = (int8x16_t *)(v6 + v11);
      v56[-1] = vbslq_s8(v54, (int8x16_t)v13, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v55, (float32x4_t)vbslq_s8(v54, (int8x16_t)v13, v53)), v14), v16));
      *v56 = vbslq_s8(v54, (int8x16_t)v12, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v55, (float32x4_t)vbslq_s8(v54, (int8x16_t)v12, (int8x16_t)vminq_f32(v52, v16))), v14), v16));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v57 = -v10;
    if (v57 >= v5)
      goto LABEL_3;
LABEL_10:
    v58 = 16 * v57;
    v59 = *(float32x4_t *)(v7 + v58);
    v60 = *((float32x4_t *)a2 + 75);
    v61 = *((float32x4_t *)a2 + 5);
    v62 = vminq_f32(vmaxq_f32(v59, v60), v61);
    v63 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v62, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
    v64 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
    v65 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v64), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v63, v64))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
    v66 = vcvtq_f32_s32(vcvtq_s32_f32(v65));
    v67 = vsubq_f32(v66, (float32x4_t)vandq_s8((int8x16_t)v61, (int8x16_t)vcgtq_f32(v66, v65)));
    v68 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v65, v67))), *((float32x4_t *)a2 + 12));
    *(int8x16_t *)(v6 + v58) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v59, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v59, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v60, vsubq_f32(v62, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vbicq_s8(*((int8x16_t *)a2 + 3), *((int8x16_t *)a2 + 74)), 0), (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v68, v68), vaddq_f32(*((float32x4_t *)a2 + 10), v67)), v60), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))), *(float32x4_t *)a2, 3)), v61))), v60), v61));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype2_nice_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = 16 * *((int *)a1 + 22);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((float32x4_t *)a2 + 75);
        v13 = *((float32x4_t *)a2 + 5);
        v14 = vminq_f32(vmaxq_f32(v11, v12), v13);
        v15 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v13, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v12)), v12), (int8x16_t)v13, (int8x16_t)vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v16 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v15), (int8x16_t)v13);
        v17 = (float32x4_t)vandq_s8((int8x16_t)v13, (int8x16_t)vcgtq_f32(v16, *((float32x4_t *)a2 + 23)));
        v18 = vsubq_f32(vsubq_f32(v16, v13), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v17), v16));
        v19 = vmulq_f32(v18, v18);
        v20 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v15, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v15))), *((float32x4_t *)a2 + 22)), v17), vmulq_f32(v18, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v18, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v18)),
                            vmulq_f32(v19, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v18)), vmulq_f32(v19, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v18)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
        v21 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
        v22 = vsubq_f32(v21, (float32x4_t)vandq_s8((int8x16_t)v13, (int8x16_t)vcgtq_f32(v21, v20)));
        v23 = vsubq_f32(v20, v22);
        *(int8x16_t *)(v7 + v10) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v11, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v11, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v12, vsubq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vbicq_s8(*((int8x16_t *)a2 + 3), *((int8x16_t *)a2 + 74)), 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v13, vmulq_f32(v23, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v23, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v23)), vmulq_f32(vmulq_f32(v23, v23), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v23)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v22)), 0x17uLL)), *(float32x4_t *)a2, 3)), v13))), v12), v13));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v6;
      v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype2_half_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  int32x4_t v55;
  int32x4_t v56;
  int32x4_t v57;
  float32x4_t v58;
  int8x16_t v59;
  int8x16_t v60;
  int8x16_t v61;
  int8x16_t v62;
  int8x16_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int8x16_t *v66;
  int v67;
  uint64_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v67 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v18 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v19 = vaddq_f32(v16, v18);
      v20 = vaddq_f32(v17, v18);
      v21 = *((int8x16_t *)a2 + 19);
      v22 = *((float32x4_t *)a2 + 20);
      v23 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v19), (int8x16_t)v15);
      v24 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v20), (int8x16_t)v15);
      v25 = *((int8x16_t *)a2 + 21);
      v26 = *((float32x4_t *)a2 + 22);
      v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v22, v20)));
      v28 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v22, v19))), v26);
      v29 = *((float32x4_t *)a2 + 23);
      v30 = *((float32x4_t *)a2 + 24);
      v31 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v23, v29));
      v32 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v24, v29));
      v33 = vaddq_f32(v28, v31);
      v34 = vaddq_f32(vsubq_f32(v27, v26), v32);
      v35 = vsubq_f32(vsubq_f32(v23, v15), vmulq_f32(vmulq_f32(v30, v31), v23));
      v36 = vsubq_f32(vsubq_f32(v24, v15), vmulq_f32(vmulq_f32(v30, v32), v24));
      v37 = *((float32x4_t *)a2 + 25);
      v38 = *((float32x4_t *)a2 + 26);
      v39 = *((float32x4_t *)a2 + 27);
      v40 = *((float32x4_t *)a2 + 28);
      v42 = *((float32x4_t *)a2 + 29);
      v41 = *((float32x4_t *)a2 + 30);
      v43 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v33, vmulq_f32(v35, vaddq_f32(vaddq_f32(v39, vmulq_f32(v40, v35)), vmulq_f32(vmulq_f32(v35, v35), vaddq_f32(v37, vmulq_f32(v38, v35)))))), COERCE_FLOAT(*(_OWORD *)a2)), v42);
      v44 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v34, vmulq_f32(v36, vaddq_f32(vaddq_f32(v39, vmulq_f32(v40, v36)), vmulq_f32(vmulq_f32(v36, v36), vaddq_f32(v37, vmulq_f32(v38, v36)))))), COERCE_FLOAT(*(_OWORD *)a2)), v42);
      v45 = vcvtq_f32_s32(vcvtq_s32_f32(v43));
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      v47 = vsubq_f32(v45, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v45, v43)));
      v48 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v46, v44)));
      v49 = vsubq_f32(v43, v47);
      v50 = vsubq_f32(v44, v48);
      v51 = *((float32x4_t *)a2 + 31);
      v52 = *((float32x4_t *)a2 + 32);
      v53 = vaddq_f32(v41, vmulq_f32(v51, v49));
      v54 = vmulq_f32(v50, vaddq_f32(v52, vmulq_f32(v50, vaddq_f32(v41, vmulq_f32(v51, v50)))));
      v55 = vcvtq_s32_f32(v47);
      v56 = vcvtq_s32_f32(v48);
      v57 = *((int32x4_t *)a2 + 33);
      v58 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v59 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v58));
      v60 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v58));
      v61 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vbicq_s8(*((int8x16_t *)a2 + 3), *((int8x16_t *)a2 + 74)), 0);
      v62 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v60, v61, (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v15, v54), (float32x4_t)vshlq_n_s32(vaddq_s32(v57, v56), 0x17uLL)), *(float32x4_t *)a2, 3)), v15);
      v63 = *((int8x16_t *)a2 + 15);
      v64 = (float32x4_t)vbslq_s8(v63, (int8x16_t)v13, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v59, v61, (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v15, vmulq_f32(v49, vaddq_f32(v52, vmulq_f32(v49, v53)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v57, v55), 0x17uLL)), *(float32x4_t *)a2, 3)), v15));
      v65 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v66 = (int8x16_t *)(v6 + v11);
      v66[-1] = vbslq_s8(v63, (int8x16_t)v13, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v65, v64), v14), v15));
      *v66 = vbslq_s8(v63, (int8x16_t)v12, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v65, (float32x4_t)vbslq_s8(v63, (int8x16_t)v12, v62)), v14), v15));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v67 = -v10;
    if (v67 >= v5)
      goto LABEL_3;
LABEL_10:
    v68 = 16 * v67;
    v69 = *(float32x4_t *)(v7 + v68);
    v70 = *((float32x4_t *)a2 + 75);
    v71 = *((float32x4_t *)a2 + 5);
    v72 = vminq_f32(vmaxq_f32(v69, v70), v71);
    v73 = vaddq_f32(v72, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v74 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v73), (int8x16_t)v71);
    v75 = (float32x4_t)vandq_s8((int8x16_t)v71, (int8x16_t)vcgtq_f32(v74, *((float32x4_t *)a2 + 23)));
    v76 = vsubq_f32(vsubq_f32(v74, v71), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v75), v74));
    v77 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v73, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v73))), *((float32x4_t *)a2 + 22)), v75), vmulq_f32(v76, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(*((float32x4_t *)a2 + 28), v76)), vmulq_f32(vmulq_f32(v76, v76), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v76)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v78 = vcvtq_f32_s32(vcvtq_s32_f32(v77));
    v79 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v71, (int8x16_t)vcgtq_f32(v78, v77)));
    v80 = vsubq_f32(v77, v79);
    *(int8x16_t *)(v6 + v68) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v69, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v69, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v70, vsubq_f32(v72, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vbicq_s8(*((int8x16_t *)a2 + 3), *((int8x16_t *)a2 + 74)), 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v71, vmulq_f32(v80, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v80, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v80)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v79)), 0x17uLL)), *(float32x4_t *)a2, 3)), v71))), v70), v71));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype2_half_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int32x4_t v57;
  int32x4_t v58;
  float32x4_t v59;
  int8x16_t v60;
  int8x16_t v61;
  int8x16_t v62;
  int8x16_t v63;
  float32x4_t v64;
  int8x16_t *v65;
  int v66;
  uint64_t v67;
  float32x4_t v68;
  float32x4_t v69;
  int32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v66 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = (int32x4_t)vbicq_s8((int8x16_t)v14, *((int8x16_t *)a2 + 74));
      v16 = (float32x4_t)vdupq_laneq_s32(v15, 3);
      v17 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v18 = vminq_f32(vmaxq_f32(v13, v14), v16);
      v19 = vminq_f32(vmaxq_f32(v12, v14), v16);
      v20 = vaddq_f32(v18, v17);
      v21 = vaddq_f32(v19, v17);
      v22 = *((int8x16_t *)a2 + 19);
      v23 = *((float32x4_t *)a2 + 20);
      v24 = *((float32x4_t *)a2 + 5);
      v25 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v20), (int8x16_t)v24);
      v26 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v21), (int8x16_t)v24);
      v27 = *((int8x16_t *)a2 + 21);
      v28 = *((float32x4_t *)a2 + 22);
      v29 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v23, v20)));
      v30 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v23, v21)));
      v31 = *((float32x4_t *)a2 + 23);
      v32 = *((float32x4_t *)a2 + 24);
      v33 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v25, v31));
      v34 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v26, v31));
      v35 = vaddq_f32(vsubq_f32(v29, v28), v33);
      v36 = vsubq_f32(vsubq_f32(v25, v24), vmulq_f32(vmulq_f32(v32, v33), v25));
      v37 = vsubq_f32(vsubq_f32(v26, v24), vmulq_f32(vmulq_f32(v32, v34), v26));
      v38 = *((float32x4_t *)a2 + 25);
      v39 = *((float32x4_t *)a2 + 26);
      v40 = *((float32x4_t *)a2 + 27);
      v41 = *((float32x4_t *)a2 + 28);
      v42 = vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(v30, v28), v34), vmulq_f32(v37, vaddq_f32(vaddq_f32(v40, vmulq_f32(v37, v41)), vmulq_f32(vmulq_f32(v37, v37), vaddq_f32(v38, vmulq_f32(v39, v37)))))), COERCE_FLOAT(*(_OWORD *)a2));
      v43 = *((float32x4_t *)a2 + 29);
      v44 = *((float32x4_t *)a2 + 30);
      v45 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v35, vmulq_f32(v36, vaddq_f32(vaddq_f32(v40, vmulq_f32(v36, v41)), vmulq_f32(vmulq_f32(v36, v36), vaddq_f32(v38, vmulq_f32(v39, v36)))))), COERCE_FLOAT(*(_OWORD *)a2)), v43);
      v46 = vmaxq_f32(v42, v43);
      v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      v48 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
      v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v47, v45)));
      v50 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v48, v46)));
      v51 = vsubq_f32(v45, v49);
      v52 = vsubq_f32(v46, v50);
      v53 = *((float32x4_t *)a2 + 31);
      v54 = *((float32x4_t *)a2 + 32);
      v55 = vmulq_f32(v52, vaddq_f32(v54, vmulq_f32(v52, vaddq_f32(v44, vmulq_f32(v53, v52)))));
      v56 = vaddq_f32(v24, vmulq_f32(v51, vaddq_f32(v54, vmulq_f32(v51, vaddq_f32(v44, vmulq_f32(v53, v51))))));
      v57 = vcvtq_s32_f32(v50);
      v58 = *((int32x4_t *)a2 + 33);
      v59 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1);
      v60 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 0);
      v61 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v59)), v60, (int8x16_t)vmulq_laneq_f32(vmulq_f32(v56, (float32x4_t)vshlq_n_s32(vaddq_s32(v58, vcvtq_s32_f32(v49)), 0x17uLL)), *(float32x4_t *)a2, 3));
      v62 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v19, v59)), v60, (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v24, v55), (float32x4_t)vshlq_n_s32(vaddq_s32(v58, v57), 0x17uLL)), *(float32x4_t *)a2, 3));
      v63 = *((int8x16_t *)a2 + 15);
      v64 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v65 = (int8x16_t *)(v6 + v11);
      v65[-1] = vbslq_s8(v63, (int8x16_t)v13, (int8x16_t)vaddq_f32(v64, (float32x4_t)vbslq_s8(v63, (int8x16_t)v13, v61)));
      *v65 = vbslq_s8(v63, (int8x16_t)v12, (int8x16_t)vaddq_f32(v64, (float32x4_t)vbslq_s8(v63, (int8x16_t)v12, v62)));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v66 = -v10;
    if (v66 >= v5)
      goto LABEL_3;
LABEL_10:
    v67 = 16 * v66;
    v68 = *(float32x4_t *)(v7 + v67);
    v69 = *((float32x4_t *)a2 + 75);
    v70 = (int32x4_t)vbicq_s8((int8x16_t)v69, *((int8x16_t *)a2 + 74));
    v71 = vminq_f32(vmaxq_f32(v68, v69), (float32x4_t)vdupq_laneq_s32(v70, 3));
    v72 = vaddq_f32(v71, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v73 = *((float32x4_t *)a2 + 5);
    v74 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v72), (int8x16_t)v73);
    v75 = (float32x4_t)vandq_s8((int8x16_t)v73, (int8x16_t)vcgtq_f32(v74, *((float32x4_t *)a2 + 23)));
    v76 = vsubq_f32(vsubq_f32(v74, v73), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v75), v74));
    v77 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v72, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v72))), *((float32x4_t *)a2 + 22)), v75), vmulq_f32(v76, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v76, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v76, v76), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v76)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v78 = vcvtq_f32_s32(vcvtq_s32_f32(v77));
    v79 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v73, (int8x16_t)vcgtq_f32(v78, v77)));
    v80 = vsubq_f32(v77, v79);
    *(int8x16_t *)(v6 + v67) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v68, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v68, vbslq_s8((int8x16_t)vcgtq_f32(v69, vsubq_f32(v71, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v70.i8, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(
                                                                                v73,
                                                                                vmulq_f32(v80, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v80, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v80)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v79)), 0x17uLL)), *(float32x4_t *)a2, 3)))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype2_nice_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  int32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = 16 * *((int *)a1 + 22);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((float32x4_t *)a2 + 75);
        v13 = (int32x4_t)vbicq_s8((int8x16_t)v12, *((int8x16_t *)a2 + 74));
        v14 = vminq_f32(vmaxq_f32(v11, v12), (float32x4_t)vdupq_laneq_s32(v13, 3));
        v15 = *((float32x4_t *)a2 + 5);
        v16 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v12)), v12), (int8x16_t)v15, (int8x16_t)vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v17 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v16), (int8x16_t)v15);
        v18 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v17, *((float32x4_t *)a2 + 23)));
        v19 = vsubq_f32(vsubq_f32(v17, v15), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v18), v17));
        v20 = vmulq_f32(v19, v19);
        v21 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v16))), *((float32x4_t *)a2 + 22)), v18), vmulq_f32(v19, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v19, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v19)),
                            vmulq_f32(v20, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v19)), vmulq_f32(v20, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v19)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
        v22 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
        v23 = vsubq_f32(v22, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v22, v21)));
        v24 = vsubq_f32(v21, v23);
        *(int8x16_t *)(v7 + v10) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v11, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32(v12, vsubq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v13.i8, 0), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(
                                                                                    v15,
                                                                                    vmulq_f32(v24, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v24, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v24)), vmulq_f32(vmulq_f32(v24, v24), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2+ 45), v24)))))))),
                                                                                  (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v23)), 0x17uLL)), *(float32x4_t *)a2, 3)))));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v6;
      v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype2_float_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  int32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = 16 * *((int *)a1 + 22);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((float32x4_t *)a2 + 75);
        v13 = (int32x4_t)vbicq_s8((int8x16_t)v12, *((int8x16_t *)a2 + 74));
        v14 = vminq_f32(vmaxq_f32(v11, v12), (float32x4_t)vdupq_laneq_s32(v13, 3));
        v15 = *((float32x4_t *)a2 + 5);
        v16 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v12)), v12), (int8x16_t)v15, (int8x16_t)vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v17 = *((int8x16_t *)a2 + 52);
        v18 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v16);
        v19 = (int8x16_t)vmulq_f32(v16, vaddq_f32(v15, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 49), v18)));
        v20 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), v19), (int8x16_t)v15);
        v21 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v16, *((float32x4_t *)a2 + 21))), vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v16, *((float32x4_t *)a2 + 50)), *((int8x16_t *)a2 + 51)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v16, *((float32x4_t *)a2 + 50)))), (float32x4_t)vandq_s8(v17, v18))), *((float32x4_t *)a2 + 22)), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)));
        v22 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v20, *((float32x4_t *)a2 + 23)));
        v23 = vaddq_f32(v21, v22);
        v24 = vsubq_f32(vsubq_f32(v20, v15), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v22), v20));
        v25 = vmulq_f32(v24, v24);
        v26 = vmulq_n_f32(vaddq_f32(v23, vmulq_f32(v24, vaddq_f32(*((float32x4_t *)a2 + 61), vmulq_f32(v24, vaddq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 59), vmulq_f32(*((float32x4_t *)a2 + 60), v24)), vmulq_f32(v25, vaddq_f32(*((float32x4_t *)a2 + 57), vmulq_f32(*((float32x4_t *)a2 + 58), v24)))), vmulq_f32(vmulq_f32(v25, v25), vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 55), vmulq_f32(*((float32x4_t *)a2 + 56), v24)), vmulq_f32(
                                v25,
                                vaddq_f32(*((float32x4_t *)a2 + 53), vmulq_f32(*((float32x4_t *)a2 + 54), v24)))))))))),
                COERCE_FLOAT(*(_OWORD *)a2));
        v27 = vminq_f32(vmaxq_f32(v26, *((float32x4_t *)a2 + 62)), *((float32x4_t *)a2 + 63));
        v28 = vcvtq_f32_s32(vcvtq_s32_f32(v27));
        v29 = vsubq_f32(v28, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v28, v27)));
        v30 = vsubq_f32(v27, v29);
        v31 = vmulq_f32(v30, v30);
        v32 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 70), v29);
        *(int8x16_t *)(v7 + v10) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v11, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32(v12, vsubq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v13.i8, 0), (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, vorrq_s8((int8x16_t)vcltzq_f32(v26), (int8x16_t)vcgezq_f32(v26))), v12),
                                                                                               (int8x16_t)vmulq_f32(vaddq_f32(v15, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 71), v32)), vmulq_f32(vaddq_f32(v15, vmulq_f32(v30, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 68), vmulq_f32(v30, *((float32x4_t *)a2 + 69))), vmulq_f32(v31, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 66), vmulq_f32(*((float32x4_t *)a2 + 67), v30)), vmulq_f32(v31, vaddq_f32(*((float32x4_t *)a2 + 64), vmulq_f32(*((float32x4_t *)a2 + 65), v30)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(vaddq_f32(v29, (float32x4_t)vandq_s8(v17, v32)))), 0x17uLL))),
                                                                                               (int8x16_t)v26),
                                                                                *(float32x4_t *)a2,
                                                                                3)))));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v6;
      v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype3_fast_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  __int128 v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int8x16_t v66;
  int8x16_t v67;
  int8x16_t v68;
  float32x4_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t *v74;
  uint64_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v75) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *(float32x4_t *)(v7 + v10 + 32);
      v15 = *((float32x4_t *)a2 + 75);
      v16 = *((float32x4_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vminq_f32(vmaxq_f32(v12, v15), v16);
      v19 = vminq_f32(vmaxq_f32(v13, v15), v16);
      v20 = *((_OWORD *)a2 + 1);
      v21 = vminq_f32(vmaxq_f32(v14, v15), v16);
      v22 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v23 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v18, v22)));
      v24 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v19, v22)));
      v25 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v21, v22)));
      v26 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
      v27 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
      v28 = vcvtq_f32_s32(vcvtq_s32_f32(v25));
      v29 = *((float32x4_t *)a2 + 7);
      v30 = *((float32x4_t *)a2 + 8);
      v31 = vrsqrteq_f32(vaddq_f32(v29, vsubq_f32(v23, v26)));
      v32 = vrsqrteq_f32(vaddq_f32(v29, vsubq_f32(v24, v27)));
      v33 = vaddq_f32(v30, v26);
      v34 = vaddq_f32(v30, v27);
      v35 = vrsqrteq_f32(vaddq_f32(v29, vsubq_f32(v25, v28)));
      v36 = vaddq_f32(v30, v28);
      v37 = *((float32x4_t *)a2 + 9);
      v38 = *((float32x4_t *)a2 + 10);
      v39 = vmulq_n_f32(vsubq_f32(v33, vmulq_f32(v31, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v40 = vmulq_n_f32(vsubq_f32(v34, vmulq_f32(v32, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v41 = vmulq_n_f32(vsubq_f32(v36, vmulq_f32(v35, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v42 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v43 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v45 = vsubq_f32(v42, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v42, v39)));
      v46 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v43, v40)));
      v47 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v44, v41)));
      v48 = vsubq_f32(v39, v45);
      v49 = vsubq_f32(v40, v46);
      v50 = vsubq_f32(v41, v47);
      v51 = vaddq_f32(v38, v45);
      v52 = vaddq_f32(v38, v46);
      v53 = vaddq_f32(v38, v47);
      v54 = *((float32x4_t *)a2 + 11);
      v55 = *((float32x4_t *)a2 + 12);
      v56 = vmulq_f32(vrecpeq_f32(vsubq_f32(v54, v48)), v55);
      v57 = vmulq_f32(vrecpeq_f32(vsubq_f32(v54, v49)), v55);
      v58 = vmulq_f32(vrecpeq_f32(vsubq_f32(v54, v50)), v55);
      v59 = vmaxq_f32(vaddq_f32(v51, vmulq_f32(v56, v56)), v15);
      v60 = vmaxq_f32(vaddq_f32(v52, vmulq_f32(v57, v57)), v15);
      v61 = *((float32x4_t *)a2 + 13);
      v62 = *((float32x4_t *)a2 + 14);
      v63 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v59, v61), v62));
      v64 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v60, v61), v62));
      v65 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(v53, vmulq_f32(v58, v58)), v15), v61), v62));
      v66 = (int8x16_t)vmulq_n_f32(v18, *(float *)&v20);
      v67 = (int8x16_t)vmulq_n_f32(v19, *(float *)&v20);
      v68 = (int8x16_t)vmulq_n_f32(v21, *(float *)&v20);
      v69 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v20, 1);
      v70 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v15, vsubq_f32(v18, v69)), v66, (int8x16_t)vmulq_laneq_f32(v63, *(float32x4_t *)a2, 3)), v16);
      v71 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v15, vsubq_f32(v19, v69)), v67, (int8x16_t)vmulq_laneq_f32(v64, *(float32x4_t *)a2, 3)), v16);
      v72 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v15, vsubq_f32(v21, v69)), v68, (int8x16_t)vmulq_laneq_f32(v65, *(float32x4_t *)a2, 3)), v16);
      v73 = *((int8x16_t *)a2 + 15);
      v74 = (int8x16_t *)(v6 + v10);
      *v74 = vbslq_s8(v73, (int8x16_t)v12, v70);
      v74[1] = vbslq_s8(v73, (int8x16_t)v13, v71);
      v74[2] = vbslq_s8(v73, (int8x16_t)v14, v72);
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v75) = -v11;
    if ((int)v75 >= v5)
      goto LABEL_3;
LABEL_10:
    v75 = v75;
    do
    {
      v76 = *(float32x4_t *)(v7 + 16 * v75);
      v77 = *((float32x4_t *)a2 + 75);
      v78 = *((float32x4_t *)a2 + 5);
      v79 = vminq_f32(vmaxq_f32(v76, v77), v78);
      v80 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v79, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
      v81 = vcvtq_f32_s32(vcvtq_s32_f32(v80));
      v82 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v81), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v80, v81))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
      v83 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
      v84 = vsubq_f32(v83, (float32x4_t)vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v83, v82)));
      v85 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v82, v84))), *((float32x4_t *)a2 + 12));
      *(int8x16_t *)(v6 + 16 * v75++) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v76, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v77, vsubq_f32(v79, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v79, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v85, v85), vaddq_f32(*((float32x4_t *)a2 + 10), v84)), v77), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))),
                                                                                   *(float32x4_t *)a2,
                                                                                   3)),
                                                       v78));
    }
    while (v75 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype3_fixed_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  __int128 v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int8x16_t v66;
  int8x16_t v67;
  int8x16_t v68;
  float32x4_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t *v74;
  uint64_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v75) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *(float32x4_t *)(v7 + v10 + 32);
      v15 = *((float32x4_t *)a2 + 75);
      v16 = *((float32x4_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vminq_f32(vmaxq_f32(v12, v15), v16);
      v19 = vminq_f32(vmaxq_f32(v13, v15), v16);
      v20 = *((_OWORD *)a2 + 1);
      v21 = vminq_f32(vmaxq_f32(v14, v15), v16);
      v22 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v23 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v18, v22)));
      v24 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v19, v22)));
      v25 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v21, v22)));
      v26 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
      v27 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
      v28 = vcvtq_f32_s32(vcvtq_s32_f32(v25));
      v29 = *((float32x4_t *)a2 + 7);
      v30 = *((float32x4_t *)a2 + 8);
      v31 = vrsqrteq_f32(vaddq_f32(v29, vsubq_f32(v23, v26)));
      v32 = vrsqrteq_f32(vaddq_f32(v29, vsubq_f32(v24, v27)));
      v33 = vaddq_f32(v30, v26);
      v34 = vaddq_f32(v30, v27);
      v35 = vrsqrteq_f32(vaddq_f32(v29, vsubq_f32(v25, v28)));
      v36 = vaddq_f32(v30, v28);
      v37 = *((float32x4_t *)a2 + 9);
      v38 = *((float32x4_t *)a2 + 10);
      v39 = vmulq_n_f32(vsubq_f32(v33, vmulq_f32(v31, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v40 = vmulq_n_f32(vsubq_f32(v34, vmulq_f32(v32, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v41 = vmulq_n_f32(vsubq_f32(v36, vmulq_f32(v35, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v42 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v43 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v45 = vsubq_f32(v42, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v42, v39)));
      v46 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v43, v40)));
      v47 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v44, v41)));
      v48 = vsubq_f32(v39, v45);
      v49 = vsubq_f32(v40, v46);
      v50 = vsubq_f32(v41, v47);
      v51 = vaddq_f32(v38, v45);
      v52 = vaddq_f32(v38, v46);
      v53 = vaddq_f32(v38, v47);
      v54 = *((float32x4_t *)a2 + 11);
      v55 = *((float32x4_t *)a2 + 12);
      v56 = vmulq_f32(vrecpeq_f32(vsubq_f32(v54, v48)), v55);
      v57 = vmulq_f32(vrecpeq_f32(vsubq_f32(v54, v49)), v55);
      v58 = vmulq_f32(vrecpeq_f32(vsubq_f32(v54, v50)), v55);
      v59 = vmaxq_f32(vaddq_f32(v51, vmulq_f32(v56, v56)), v15);
      v60 = vmaxq_f32(vaddq_f32(v52, vmulq_f32(v57, v57)), v15);
      v61 = *((float32x4_t *)a2 + 13);
      v62 = *((float32x4_t *)a2 + 14);
      v63 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v59, v61), v62));
      v64 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v60, v61), v62));
      v65 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(v53, vmulq_f32(v58, v58)), v15), v61), v62));
      v66 = (int8x16_t)vmulq_n_f32(v18, *(float *)&v20);
      v67 = (int8x16_t)vmulq_n_f32(v19, *(float *)&v20);
      v68 = (int8x16_t)vmulq_n_f32(v21, *(float *)&v20);
      v69 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v20, 1);
      v70 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v15, vsubq_f32(v18, v69)), v66, (int8x16_t)vmulq_laneq_f32(v63, *(float32x4_t *)a2, 3)), v16);
      v71 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v15, vsubq_f32(v19, v69)), v67, (int8x16_t)vmulq_laneq_f32(v64, *(float32x4_t *)a2, 3)), v16);
      v72 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v15, vsubq_f32(v21, v69)), v68, (int8x16_t)vmulq_laneq_f32(v65, *(float32x4_t *)a2, 3)), v16);
      v73 = *((int8x16_t *)a2 + 15);
      v74 = (int8x16_t *)(v6 + v10);
      *v74 = vbslq_s8(v73, (int8x16_t)v12, v70);
      v74[1] = vbslq_s8(v73, (int8x16_t)v13, v71);
      v74[2] = vbslq_s8(v73, (int8x16_t)v14, v72);
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v75) = -v11;
    if ((int)v75 >= v5)
      goto LABEL_3;
LABEL_10:
    v75 = v75;
    do
    {
      v76 = *(float32x4_t *)(v7 + 16 * v75);
      v77 = *((float32x4_t *)a2 + 75);
      v78 = *((float32x4_t *)a2 + 5);
      v79 = vminq_f32(vmaxq_f32(v76, v77), v78);
      v80 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v79, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
      v81 = vcvtq_f32_s32(vcvtq_s32_f32(v80));
      v82 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v81), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v80, v81))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
      v83 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
      v84 = vsubq_f32(v83, (float32x4_t)vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v83, v82)));
      v85 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v82, v84))), *((float32x4_t *)a2 + 12));
      *(int8x16_t *)(v6 + 16 * v75++) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v76, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v77, vsubq_f32(v79, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v79, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v85, v85), vaddq_f32(*((float32x4_t *)a2 + 10), v84)), v77), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))),
                                                                                   *(float32x4_t *)a2,
                                                                                   3)),
                                                       v78));
    }
    while (v75 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype3_nice_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  __int128 v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int32x4_t v73;
  float32x4_t v74;
  int8x16_t v75;
  int8x16_t v76;
  int8x16_t v77;
  float32x4_t v78;
  int8x16_t v79;
  int8x16_t v80;
  int8x16_t v81;
  int8x16_t *v82;
  int v83;
  uint64_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v83 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v17 = *((_OWORD *)a2 + 1);
      v18 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v20 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v14)), v14);
      v21 = (float32x4_t)vbslq_s8(v20, (int8x16_t)v15, (int8x16_t)vaddq_f32(v16, v19));
      v22 = (float32x4_t)vbslq_s8(v20, (int8x16_t)v15, (int8x16_t)vaddq_f32(v18, v19));
      v23 = *((int8x16_t *)a2 + 19);
      v24 = *((float32x4_t *)a2 + 20);
      v25 = (float32x4_t)vorrq_s8(vandq_s8(v23, (int8x16_t)v21), (int8x16_t)v15);
      v26 = (float32x4_t)vorrq_s8(vandq_s8(v23, (int8x16_t)v22), (int8x16_t)v15);
      v27 = *((int8x16_t *)a2 + 21);
      v28 = *((float32x4_t *)a2 + 22);
      v29 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v22, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v24, v22)));
      v30 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v24, v21))), v28);
      v31 = *((float32x4_t *)a2 + 23);
      v32 = *((float32x4_t *)a2 + 24);
      v33 = vsubq_f32(v29, v28);
      v34 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v25, v31));
      v35 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v26, v31));
      v36 = vaddq_f32(v30, v34);
      v37 = vsubq_f32(vsubq_f32(v25, v15), vmulq_f32(vmulq_f32(v32, v34), v25));
      v38 = vsubq_f32(vsubq_f32(v26, v15), vmulq_f32(vmulq_f32(v32, v35), v26));
      v39 = vmulq_f32(v37, v37);
      v40 = *((float32x4_t *)a2 + 37);
      v41 = *((float32x4_t *)a2 + 38);
      v42 = *((float32x4_t *)a2 + 39);
      v43 = *((float32x4_t *)a2 + 40);
      v44 = vaddq_f32(v40, vmulq_f32(v41, v37));
      v45 = vaddq_f32(v42, vmulq_f32(v43, v37));
      v46 = vaddq_f32(v42, vmulq_f32(v43, v38));
      v47 = vaddq_f32(v40, vmulq_f32(v41, v38));
      v48 = *((float32x4_t *)a2 + 41);
      v49 = *((float32x4_t *)a2 + 42);
      v50 = vaddq_f32(v48, vmulq_f32(v49, v37));
      v51 = vaddq_f32(v48, vmulq_f32(v49, v38));
      v52 = vmulq_f32(v38, v38);
      v53 = vaddq_f32(v33, v35);
      v54 = vaddq_f32(v50, vmulq_f32(v39, vaddq_f32(v44, vmulq_f32(v39, v45))));
      v55 = vaddq_f32(v51, vmulq_f32(v52, vaddq_f32(v47, vmulq_f32(v52, v46))));
      v56 = *((float32x4_t *)a2 + 43);
      v57 = *((float32x4_t *)a2 + 44);
      v58 = vaddq_f32(v53, vmulq_f32(v38, vaddq_f32(v56, vmulq_f32(v38, v55))));
      v59 = vmulq_n_f32(vaddq_f32(v36, vmulq_f32(v37, vaddq_f32(v56, vmulq_f32(v37, v54)))), COERCE_FLOAT(*(_OWORD *)a2));
      v60 = *((float32x4_t *)a2 + 29);
      v61 = vmaxq_f32(v59, v60);
      v62 = vmaxq_f32(vmulq_n_f32(v58, COERCE_FLOAT(*(_OWORD *)a2)), v60);
      v63 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v64 = vcvtq_f32_s32(vcvtq_s32_f32(v62));
      v65 = vsubq_f32(v63, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v63, v61)));
      v66 = vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v64, v62)));
      v67 = vsubq_f32(v61, v65);
      v68 = vsubq_f32(v62, v66);
      v69 = *((float32x4_t *)a2 + 45);
      v70 = *((float32x4_t *)a2 + 46);
      v71 = *((float32x4_t *)a2 + 47);
      v72 = *((float32x4_t *)a2 + 48);
      v73 = *((int32x4_t *)a2 + 33);
      v74 = vmulq_f32(vaddq_f32(v15, vmulq_f32(v68, vaddq_f32(v72, vmulq_f32(v68, vaddq_f32(vaddq_f32(v70, vmulq_f32(v71, v68)), vmulq_f32(vmulq_f32(v68, v68), vaddq_f32(v57, vmulq_f32(v69, v68)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v73, vcvtq_s32_f32(v66)), 0x17uLL));
      v75 = (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v15, vmulq_f32(v67, vaddq_f32(v72, vmulq_f32(v67, vaddq_f32(vaddq_f32(v70, vmulq_f32(v67, v71)), vmulq_f32(vmulq_f32(v67, v67), vaddq_f32(v57, vmulq_f32(v69, v67)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v73, vcvtq_s32_f32(v65)), 0x17uLL)), *(float32x4_t *)a2, 3);
      v76 = (int8x16_t)vmulq_n_f32(v16, *(float *)&v17);
      v77 = (int8x16_t)vmulq_n_f32(v18, *(float *)&v17);
      v78 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v17, 1);
      v79 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v78)), v76, v75), v15);
      v80 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v78)), v77, (int8x16_t)vmulq_laneq_f32(v74, *(float32x4_t *)a2, 3)), v15);
      v81 = *((int8x16_t *)a2 + 15);
      v82 = (int8x16_t *)(v6 + v11);
      v82[-1] = vbslq_s8(v81, (int8x16_t)v12, v79);
      *v82 = vbslq_s8(v81, (int8x16_t)v13, v80);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v83 = -v10;
    if (v83 >= v5)
      goto LABEL_3;
LABEL_10:
    v84 = 16 * v83;
    v85 = *(float32x4_t *)(v7 + v84);
    v86 = *((float32x4_t *)a2 + 75);
    v87 = *((float32x4_t *)a2 + 5);
    v88 = vminq_f32(vmaxq_f32(v85, v86), v87);
    v89 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v86)), v86), (int8x16_t)v87, (int8x16_t)vaddq_f32(v88, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
    v90 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v89), (int8x16_t)v87);
    v91 = (float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vcgtq_f32(v90, *((float32x4_t *)a2 + 23)));
    v92 = vsubq_f32(vsubq_f32(v90, v87), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v91), v90));
    v93 = vmulq_f32(v92, v92);
    v94 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v89, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v89))), *((float32x4_t *)a2 + 22)), v91), vmulq_f32(v92, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v92, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v92)),
                        vmulq_f32(v93, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v92)), vmulq_f32(v93, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v92)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
    v95 = vcvtq_f32_s32(vcvtq_s32_f32(v94));
    v96 = vsubq_f32(v95, (float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vcgtq_f32(v95, v94)));
    v97 = vsubq_f32(v94, v96);
    *(int8x16_t *)(v6 + v84) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v85, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v86, vsubq_f32(v88, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v88, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v87, vmulq_f32(
                                                                                v97,
                                                                                vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v97, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v97)), vmulq_f32(vmulq_f32(v97, v97), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v97)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33),
                                                                                             vcvtq_s32_f32(v96)),
                                                                                           0x17uLL)),
                                                                          *(float32x4_t *)a2,
                                                                          3)),
                                              v87));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype3_half_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  __int128 v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  int32x4_t v60;
  int32x4_t v61;
  float32x4_t v62;
  int8x16_t v63;
  int8x16_t v64;
  int8x16_t v65;
  float32x4_t v66;
  int8x16_t v67;
  int8x16_t v68;
  int8x16_t v69;
  int8x16_t *v70;
  int v71;
  uint64_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v71 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = *((_OWORD *)a2 + 1);
      v17 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v18 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v19 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v20 = vaddq_f32(v18, v17);
      v21 = vaddq_f32(v19, v17);
      v22 = *((int8x16_t *)a2 + 19);
      v23 = *((float32x4_t *)a2 + 20);
      v24 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v20), (int8x16_t)v15);
      v25 = *((int8x16_t *)a2 + 21);
      v26 = *((float32x4_t *)a2 + 22);
      v27 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v21), (int8x16_t)v15);
      v28 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v23, v21)));
      v29 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v23, v20))), v26);
      v30 = *((float32x4_t *)a2 + 23);
      v31 = *((float32x4_t *)a2 + 24);
      v32 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v24, v30));
      v33 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v27, v30));
      v34 = vaddq_f32(v29, v32);
      v35 = vmulq_f32(v31, v32);
      v36 = vmulq_f32(vmulq_f32(v31, v33), v27);
      v37 = vaddq_f32(vsubq_f32(v28, v26), v33);
      v38 = vsubq_f32(vsubq_f32(v24, v15), vmulq_f32(v35, v24));
      v39 = vsubq_f32(vsubq_f32(v27, v15), v36);
      v40 = *((float32x4_t *)a2 + 25);
      v41 = *((float32x4_t *)a2 + 26);
      v42 = *((float32x4_t *)a2 + 27);
      v43 = *((float32x4_t *)a2 + 28);
      v44 = vmulq_n_f32(vaddq_f32(v34, vmulq_f32(v38, vaddq_f32(vaddq_f32(v42, vmulq_f32(v43, v38)), vmulq_f32(vmulq_f32(v38, v38), vaddq_f32(v40, vmulq_f32(v41, v38)))))), COERCE_FLOAT(*(_OWORD *)a2));
      v45 = vmulq_n_f32(vaddq_f32(v37, vmulq_f32(v39, vaddq_f32(vaddq_f32(v42, vmulq_f32(v43, v39)), vmulq_f32(vmulq_f32(v39, v39), vaddq_f32(v40, vmulq_f32(v41, v39)))))), COERCE_FLOAT(*(_OWORD *)a2));
      v46 = *((float32x4_t *)a2 + 29);
      v47 = *((float32x4_t *)a2 + 30);
      v48 = vmaxq_f32(v44, v46);
      v49 = vmaxq_f32(v45, v46);
      v50 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
      v51 = vcvtq_f32_s32(vcvtq_s32_f32(v49));
      v52 = vsubq_f32(v50, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v50, v48)));
      v53 = vsubq_f32(v51, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v51, v49)));
      v54 = vsubq_f32(v48, v52);
      v55 = vsubq_f32(v49, v53);
      v56 = *((float32x4_t *)a2 + 31);
      v57 = *((float32x4_t *)a2 + 32);
      v58 = vmulq_f32(v55, vaddq_f32(v57, vmulq_f32(v55, vaddq_f32(v47, vmulq_f32(v56, v55)))));
      v59 = vaddq_f32(v15, vmulq_f32(v54, vaddq_f32(v57, vmulq_f32(v54, vaddq_f32(v47, vmulq_f32(v56, v54))))));
      v60 = vcvtq_s32_f32(v53);
      v61 = *((int32x4_t *)a2 + 33);
      v62 = vmulq_f32(vaddq_f32(v15, v58), (float32x4_t)vshlq_n_s32(vaddq_s32(v61, v60), 0x17uLL));
      v63 = (int8x16_t)vmulq_laneq_f32(vmulq_f32(v59, (float32x4_t)vshlq_n_s32(vaddq_s32(v61, vcvtq_s32_f32(v52)), 0x17uLL)), *(float32x4_t *)a2, 3);
      v64 = (int8x16_t)vmulq_n_f32(v18, *(float *)&v16);
      v65 = (int8x16_t)vmulq_n_f32(v19, *(float *)&v16);
      v66 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v16, 1);
      v67 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v66)), v64, v63), v15);
      v68 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v19, v66)), v65, (int8x16_t)vmulq_laneq_f32(v62, *(float32x4_t *)a2, 3)), v15);
      v69 = *((int8x16_t *)a2 + 15);
      v70 = (int8x16_t *)(v6 + v11);
      v70[-1] = vbslq_s8(v69, (int8x16_t)v13, v67);
      *v70 = vbslq_s8(v69, (int8x16_t)v12, v68);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v71 = -v10;
    if (v71 >= v5)
      goto LABEL_3;
LABEL_10:
    v72 = 16 * v71;
    v73 = *(float32x4_t *)(v7 + v72);
    v74 = *((float32x4_t *)a2 + 75);
    v75 = *((float32x4_t *)a2 + 5);
    v76 = vminq_f32(vmaxq_f32(v73, v74), v75);
    v77 = vaddq_f32(v76, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v78 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v77), (int8x16_t)v75);
    v79 = (float32x4_t)vandq_s8((int8x16_t)v75, (int8x16_t)vcgtq_f32(v78, *((float32x4_t *)a2 + 23)));
    v80 = vsubq_f32(vsubq_f32(v78, v75), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v79), v78));
    v81 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v77, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v77))), *((float32x4_t *)a2 + 22)), v79), vmulq_f32(v80, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(*((float32x4_t *)a2 + 28), v80)), vmulq_f32(vmulq_f32(v80, v80), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v80)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v82 = vcvtq_f32_s32(vcvtq_s32_f32(v81));
    v83 = vsubq_f32(v82, (float32x4_t)vandq_s8((int8x16_t)v75, (int8x16_t)vcgtq_f32(v82, v81)));
    v84 = vsubq_f32(v81, v83);
    *(int8x16_t *)(v6 + v72) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v73, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v74, vsubq_f32(v76, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v76, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v75, vmulq_f32(
                                                                                v84,
                                                                                vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v84, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v84)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v83)), 0x17uLL)), *(float32x4_t *)a2, 3)), v75));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype3_half_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  __int128 v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  int32x4_t v60;
  int32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x16_t v64;
  int8x16_t *v65;
  int8x16_t v66;
  int v67;
  uint64_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v67 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = (float32x4_t)vdupq_laneq_s32((int32x4_t)vbicq_s8((int8x16_t)v14, *((int8x16_t *)a2 + 76)), 3);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = *((_OWORD *)a2 + 1);
      v18 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v20 = vaddq_f32(v16, v19);
      v21 = vaddq_f32(v18, v19);
      v22 = *((int8x16_t *)a2 + 19);
      v23 = *((float32x4_t *)a2 + 20);
      v24 = *((float32x4_t *)a2 + 5);
      v25 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v20), (int8x16_t)v24);
      v26 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v21), (int8x16_t)v24);
      v27 = *((int8x16_t *)a2 + 21);
      v28 = *((float32x4_t *)a2 + 22);
      v29 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v23, v21)));
      v30 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v23, v20))), v28);
      v31 = *((float32x4_t *)a2 + 23);
      v32 = *((float32x4_t *)a2 + 24);
      v33 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v25, v31));
      v34 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v26, v31));
      v35 = vaddq_f32(v30, v33);
      v36 = vaddq_f32(vsubq_f32(v29, v28), v34);
      v37 = vsubq_f32(vsubq_f32(v25, v24), vmulq_f32(vmulq_f32(v32, v33), v25));
      v38 = vsubq_f32(vsubq_f32(v26, v24), vmulq_f32(vmulq_f32(v32, v34), v26));
      v39 = *((float32x4_t *)a2 + 25);
      v40 = *((float32x4_t *)a2 + 26);
      v41 = vaddq_f32(v39, vmulq_f32(v40, v37));
      v42 = vaddq_f32(v39, vmulq_f32(v40, v38));
      v43 = *((float32x4_t *)a2 + 27);
      v44 = *((float32x4_t *)a2 + 28);
      v45 = vaddq_f32(v36, vmulq_f32(v38, vaddq_f32(vaddq_f32(v43, vmulq_f32(v38, v44)), vmulq_f32(vmulq_f32(v38, v38), v42))));
      v46 = *((float32x4_t *)a2 + 29);
      v47 = *((float32x4_t *)a2 + 30);
      v48 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v35, vmulq_f32(v37, vaddq_f32(vaddq_f32(v43, vmulq_f32(v37, v44)), vmulq_f32(vmulq_f32(v37, v37), v41)))), COERCE_FLOAT(*(_OWORD *)a2)), v46);
      v49 = vmaxq_f32(vmulq_n_f32(v45, COERCE_FLOAT(*(_OWORD *)a2)), v46);
      v50 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
      v51 = vcvtq_f32_s32(vcvtq_s32_f32(v49));
      v52 = vsubq_f32(v50, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v50, v48)));
      v53 = vsubq_f32(v51, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v51, v49)));
      v54 = vsubq_f32(v48, v52);
      v55 = vsubq_f32(v49, v53);
      v56 = *((float32x4_t *)a2 + 31);
      v57 = *((float32x4_t *)a2 + 32);
      v58 = vaddq_f32(v47, vmulq_f32(v56, v54));
      v59 = vmulq_f32(v55, vaddq_f32(v57, vmulq_f32(v55, vaddq_f32(v47, vmulq_f32(v56, v55)))));
      v60 = vcvtq_s32_f32(v53);
      v61 = *((int32x4_t *)a2 + 33);
      v62 = vmulq_f32(vaddq_f32(v24, v59), (float32x4_t)vshlq_n_s32(vaddq_s32(v61, v60), 0x17uLL));
      v63 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v17, 1);
      v64 = *((int8x16_t *)a2 + 15);
      v65 = (int8x16_t *)(v6 + v11);
      v66 = vbslq_s8(v64, (int8x16_t)v12, vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v63)), (int8x16_t)vmulq_n_f32(v18, *(float *)&v17), (int8x16_t)vmulq_laneq_f32(v62, *(float32x4_t *)a2, 3)));
      v65[-1] = vbslq_s8(v64, (int8x16_t)v13, vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v63)), (int8x16_t)vmulq_n_f32(v16, *(float *)&v17), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v24, vmulq_f32(v54, vaddq_f32(v57, vmulq_f32(v54, v58)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v61, vcvtq_s32_f32(v52)), 0x17uLL)), *(float32x4_t *)a2, 3)));
      *v65 = v66;
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v67 = -v10;
    if (v67 >= v5)
      goto LABEL_3;
LABEL_10:
    v68 = 16 * v67;
    v69 = *(float32x4_t *)(v7 + v68);
    v70 = *((float32x4_t *)a2 + 75);
    v71 = vminq_f32(vmaxq_f32(v69, v70), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbicq_s8((int8x16_t)v70, *((int8x16_t *)a2 + 76)), 3));
    v72 = vaddq_f32(v71, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v73 = *((float32x4_t *)a2 + 5);
    v74 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v72), (int8x16_t)v73);
    v75 = (float32x4_t)vandq_s8((int8x16_t)v73, (int8x16_t)vcgtq_f32(v74, *((float32x4_t *)a2 + 23)));
    v76 = vsubq_f32(vsubq_f32(v74, v73), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v75), v74));
    v77 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v72, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v72))), *((float32x4_t *)a2 + 22)), v75), vmulq_f32(v76, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v76, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v76, v76), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v76)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v78 = vcvtq_f32_s32(vcvtq_s32_f32(v77));
    v79 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v73, (int8x16_t)vcgtq_f32(v78, v77)));
    v80 = vsubq_f32(v77, v79);
    *(int8x16_t *)(v6 + v68) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v69, vbslq_s8((int8x16_t)vcgtq_f32(v70, vsubq_f32(v71, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v71, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v73, vmulq_f32(v80, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v80,
                                                          vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v80)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v79)), 0x17uLL)), *(float32x4_t *)a2, 3)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype3_nice_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  __int128 v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  int32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int8x16_t v78;
  int8x16_t *v79;
  int8x16_t v80;
  int v81;
  uint64_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v81 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = (float32x4_t)vdupq_laneq_s32((int32x4_t)vbicq_s8((int8x16_t)v14, *((int8x16_t *)a2 + 76)), 3);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v18 = *((_OWORD *)a2 + 1);
      v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v20 = *((float32x4_t *)a2 + 5);
      v21 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v14)), v14);
      v22 = (float32x4_t)vbslq_s8(v21, (int8x16_t)v20, (int8x16_t)vaddq_f32(v16, v19));
      v23 = (float32x4_t)vbslq_s8(v21, (int8x16_t)v20, (int8x16_t)vaddq_f32(v17, v19));
      v24 = *((int8x16_t *)a2 + 19);
      v25 = *((float32x4_t *)a2 + 20);
      v26 = (float32x4_t)vorrq_s8(vandq_s8(v24, (int8x16_t)v22), (int8x16_t)v20);
      v27 = *((int8x16_t *)a2 + 21);
      v28 = *((float32x4_t *)a2 + 22);
      v29 = (float32x4_t)vorrq_s8(vandq_s8(v24, (int8x16_t)v23), (int8x16_t)v20);
      v30 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v25, v23)));
      v31 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v22, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v25, v22))), v28);
      v32 = *((float32x4_t *)a2 + 23);
      v33 = *((float32x4_t *)a2 + 24);
      v34 = vsubq_f32(v30, v28);
      v35 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v26, v32));
      v36 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v29, v32));
      v37 = vaddq_f32(v31, v35);
      v38 = vsubq_f32(vsubq_f32(v26, v20), vmulq_f32(vmulq_f32(v33, v35), v26));
      v39 = vsubq_f32(vsubq_f32(v29, v20), vmulq_f32(vmulq_f32(v33, v36), v29));
      v40 = vmulq_f32(v38, v38);
      v41 = *((float32x4_t *)a2 + 37);
      v42 = *((float32x4_t *)a2 + 38);
      v43 = vaddq_f32(v41, vmulq_f32(v42, v38));
      v44 = vaddq_f32(v41, vmulq_f32(v42, v39));
      v45 = *((float32x4_t *)a2 + 39);
      v46 = *((float32x4_t *)a2 + 40);
      v47 = vaddq_f32(v45, vmulq_f32(v46, v38));
      v48 = vaddq_f32(v45, vmulq_f32(v46, v39));
      v49 = *((float32x4_t *)a2 + 41);
      v50 = *((float32x4_t *)a2 + 42);
      v51 = vaddq_f32(v49, vmulq_f32(v50, v38));
      v52 = vaddq_f32(v49, vmulq_f32(v50, v39));
      v53 = vmulq_f32(v39, v39);
      v54 = vaddq_f32(v52, vmulq_f32(v53, vaddq_f32(v44, vmulq_f32(v53, v48))));
      v55 = vmulq_f32(v38, vaddq_f32(v51, vmulq_f32(v40, vaddq_f32(v43, vmulq_f32(v40, v47)))));
      v56 = *((float32x4_t *)a2 + 43);
      v57 = *((float32x4_t *)a2 + 44);
      v58 = vmulq_n_f32(vaddq_f32(vaddq_f32(v34, v36), vmulq_f32(v39, vaddq_f32(v56, vmulq_f32(v39, v54)))), COERCE_FLOAT(*(_OWORD *)a2));
      v59 = *((float32x4_t *)a2 + 29);
      v60 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v37, vmulq_f32(v38, vaddq_f32(v56, v55))), COERCE_FLOAT(*(_OWORD *)a2)), v59);
      v61 = vmaxq_f32(v58, v59);
      v62 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v63 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v64 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v62, v60)));
      v65 = vsubq_f32(v63, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v63, v61)));
      v66 = vsubq_f32(v60, v64);
      v67 = vsubq_f32(v61, v65);
      v68 = *((float32x4_t *)a2 + 45);
      v69 = *((float32x4_t *)a2 + 46);
      v70 = vaddq_f32(v57, vmulq_f32(v68, v66));
      v71 = vaddq_f32(v57, vmulq_f32(v68, v67));
      v73 = *((float32x4_t *)a2 + 47);
      v72 = *((float32x4_t *)a2 + 48);
      v74 = *((int32x4_t *)a2 + 33);
      v75 = vmulq_f32(vaddq_f32(v20, vmulq_f32(v66, vaddq_f32(v72, vmulq_f32(v66, vaddq_f32(vaddq_f32(v69, vmulq_f32(v66, v73)), vmulq_f32(vmulq_f32(v66, v66), v70)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v74, vcvtq_s32_f32(v64)), 0x17uLL));
      v76 = vmulq_f32(vaddq_f32(v20, vmulq_f32(v67, vaddq_f32(v72, vmulq_f32(v67, vaddq_f32(vaddq_f32(v69, vmulq_f32(v73, v67)), vmulq_f32(vmulq_f32(v67, v67), v71)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v74, vcvtq_s32_f32(v65)), 0x17uLL));
      v77 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v18, 1);
      v78 = *((int8x16_t *)a2 + 15);
      v79 = (int8x16_t *)(v6 + v11);
      v80 = vbslq_s8(v78, (int8x16_t)v12, vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v77)), (int8x16_t)vmulq_n_f32(v17, *(float *)&v18), (int8x16_t)vmulq_laneq_f32(v76, *(float32x4_t *)a2, 3)));
      v79[-1] = vbslq_s8(v78, (int8x16_t)v13, vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v77)), (int8x16_t)vmulq_n_f32(v16, *(float *)&v18), (int8x16_t)vmulq_laneq_f32(v75, *(float32x4_t *)a2, 3)));
      *v79 = v80;
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v81 = -v10;
    if (v81 >= v5)
      goto LABEL_3;
LABEL_10:
    v82 = 16 * v81;
    v83 = *(float32x4_t *)(v7 + v82);
    v84 = *((float32x4_t *)a2 + 75);
    v85 = vminq_f32(vmaxq_f32(v83, v84), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbicq_s8((int8x16_t)v84, *((int8x16_t *)a2 + 76)), 3));
    v86 = *((float32x4_t *)a2 + 5);
    v87 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v86, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v84)), v84), (int8x16_t)v86, (int8x16_t)vaddq_f32(v85, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
    v88 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v87), (int8x16_t)v86);
    v89 = (float32x4_t)vandq_s8((int8x16_t)v86, (int8x16_t)vcgtq_f32(v88, *((float32x4_t *)a2 + 23)));
    v90 = vsubq_f32(vsubq_f32(v88, v86), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v89), v88));
    v91 = vmulq_f32(v90, v90);
    v92 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v87, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v87))), *((float32x4_t *)a2 + 22)), v89), vmulq_f32(v90, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v90, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v90)),
                        vmulq_f32(v91, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v90)), vmulq_f32(v91, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v90)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
    v93 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
    v94 = vsubq_f32(v93, (float32x4_t)vandq_s8((int8x16_t)v86, (int8x16_t)vcgtq_f32(v93, v92)));
    v95 = vsubq_f32(v92, v94);
    *(int8x16_t *)(v6 + v82) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v83, vbslq_s8((int8x16_t)vcgtq_f32(v84, vsubq_f32(v85, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v85, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vmulq_laneq_f32(vmulq_f32(vaddq_f32(v86, vmulq_f32(v95, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v95,
                                                          vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v95)), vmulq_f32(vmulq_f32(v95, v95), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v95)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v94)), 0x17uLL)), *(float32x4_t *)a2, 3)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype3_float_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = 16 * *((int *)a1 + 22);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((float32x4_t *)a2 + 75);
        v13 = vminq_f32(vmaxq_f32(v11, v12), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbicq_s8((int8x16_t)v12, *((int8x16_t *)a2 + 76)), 3));
        v14 = *((float32x4_t *)a2 + 5);
        v15 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v12)), v12), (int8x16_t)v14, (int8x16_t)vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v16 = *((int8x16_t *)a2 + 52);
        v17 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v15);
        v18 = (int8x16_t)vmulq_f32(v15, vaddq_f32(v14, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 49), v17)));
        v19 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), v18), (int8x16_t)v14);
        v20 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v15, *((float32x4_t *)a2 + 21))), vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v15, *((float32x4_t *)a2 + 50)), *((int8x16_t *)a2 + 51)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v15, *((float32x4_t *)a2 + 50)))), (float32x4_t)vandq_s8(v16, v17))), *((float32x4_t *)a2 + 22)), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)));
        v21 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v19, *((float32x4_t *)a2 + 23)));
        v22 = vaddq_f32(v20, v21);
        v23 = vsubq_f32(vsubq_f32(v19, v14), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v21), v19));
        v24 = vmulq_f32(v23, v23);
        v25 = vmulq_n_f32(vaddq_f32(v22, vmulq_f32(v23, vaddq_f32(*((float32x4_t *)a2 + 61), vmulq_f32(v23, vaddq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 59), vmulq_f32(*((float32x4_t *)a2 + 60), v23)), vmulq_f32(v24, vaddq_f32(*((float32x4_t *)a2 + 57), vmulq_f32(*((float32x4_t *)a2 + 58), v23)))), vmulq_f32(vmulq_f32(v24, v24), vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 55), vmulq_f32(*((float32x4_t *)a2 + 56), v23)), vmulq_f32(
                                v24,
                                vaddq_f32(*((float32x4_t *)a2 + 53), vmulq_f32(*((float32x4_t *)a2 + 54), v23)))))))))),
                COERCE_FLOAT(*(_OWORD *)a2));
        v26 = vminq_f32(vmaxq_f32(v25, *((float32x4_t *)a2 + 62)), *((float32x4_t *)a2 + 63));
        v27 = vcvtq_f32_s32(vcvtq_s32_f32(v26));
        v28 = vsubq_f32(v27, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v27, v26)));
        v29 = vsubq_f32(v26, v28);
        v30 = vmulq_f32(v29, v29);
        v31 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 70), v28);
        *(int8x16_t *)(v7 + v10) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32(v12, vsubq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v13, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, vorrq_s8((int8x16_t)vcltzq_f32(v25), (int8x16_t)vcgezq_f32(v25))), v12), (int8x16_t)vmulq_f32(
                                                                                vaddq_f32(v14, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 71), v31)), vmulq_f32(vaddq_f32(v14, vmulq_f32(v29, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 68), vmulq_f32(v29, *((float32x4_t *)a2 + 69))), vmulq_f32(v30, vaddq_f32(vaddq_f32(
                                                                                              *((float32x4_t *)a2 + 66),
                                                                                              vmulq_f32(*((float32x4_t *)a2 + 67), v29)), vmulq_f32(v30, vaddq_f32(*((float32x4_t *)a2 + 64), vmulq_f32(*((float32x4_t *)a2+ 65), v29)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(vaddq_f32(v28, (float32x4_t)vandq_s8(v16, v31)))), 0x17uLL))), (int8x16_t)v25), *(float32x4_t *)a2, 3)));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v6;
      v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Gettype4_fast_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  __int128 v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int8x16_t v62;
  int8x16_t v63;
  int8x16_t v64;
  float32x4_t v65;
  int8x16_t v66;
  int8x16_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  int8x16_t *v71;
  uint64_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v72) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((float32x4_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vminq_f32(vmaxq_f32(v12, v14), v16);
      v19 = vminq_f32(vmaxq_f32(v13, v14), v16);
      v20 = *((_OWORD *)a2 + 1);
      v21 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v22 = vminq_f32(vmaxq_f32(v15, v14), v16);
      v23 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v18, v21)));
      v24 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v19, v21)));
      v25 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v22, v21)));
      v26 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
      v27 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
      v28 = vcvtq_f32_s32(vcvtq_s32_f32(v25));
      v29 = *((float32x4_t *)a2 + 7);
      v30 = *((float32x4_t *)a2 + 8);
      v31 = vrsqrteq_f32(vaddq_f32(v29, vsubq_f32(v23, v26)));
      v32 = vrsqrteq_f32(vaddq_f32(v29, vsubq_f32(v24, v27)));
      v33 = vrsqrteq_f32(vaddq_f32(v29, vsubq_f32(v25, v28)));
      v34 = vaddq_f32(v30, v26);
      v35 = vaddq_f32(v30, v27);
      v36 = vaddq_f32(v30, v28);
      v37 = *((float32x4_t *)a2 + 9);
      v38 = *((float32x4_t *)a2 + 10);
      v39 = vmulq_n_f32(vsubq_f32(v34, vmulq_f32(v31, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v40 = vmulq_n_f32(vsubq_f32(v35, vmulq_f32(v32, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v41 = vmulq_n_f32(vsubq_f32(v36, vmulq_f32(v33, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v42 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v43 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v45 = vsubq_f32(v42, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v42, v39)));
      v46 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v43, v40)));
      v47 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v44, v41)));
      v48 = *((float32x4_t *)a2 + 11);
      v49 = *((float32x4_t *)a2 + 12);
      v50 = vmulq_f32(vrecpeq_f32(vsubq_f32(v48, vsubq_f32(v39, v45))), v49);
      v51 = vmulq_f32(vrecpeq_f32(vsubq_f32(v48, vsubq_f32(v40, v46))), v49);
      v52 = vmulq_f32(vrecpeq_f32(vsubq_f32(v48, vsubq_f32(v41, v47))), v49);
      v53 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v45), vmulq_f32(v50, v50)), v14);
      v54 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v46), vmulq_f32(v51, v51)), v14);
      v55 = *((float32x4_t *)a2 + 13);
      v56 = *((float32x4_t *)a2 + 14);
      v57 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v53, v55), v56));
      v58 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v54, v55), v56));
      v59 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(v38, v47), vmulq_f32(v52, v52)), v14), v55), v56));
      v60 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2);
      v61 = vmulq_laneq_f32(v59, *(float32x4_t *)a2, 3);
      v62 = (int8x16_t)vmulq_n_f32(v18, *(float *)&v20);
      v63 = (int8x16_t)vmulq_n_f32(v19, *(float *)&v20);
      v64 = (int8x16_t)vmulq_n_f32(v22, *(float *)&v20);
      v65 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v20, 1);
      v66 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v22, v65)), v64, (int8x16_t)vaddq_f32(v60, v61)), v16);
      v67 = *((int8x16_t *)a2 + 15);
      v68 = (float32x4_t)vbslq_s8(v67, (int8x16_t)v12, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v65)), v62, (int8x16_t)vaddq_f32(v60, vmulq_laneq_f32(v57, *(float32x4_t *)a2, 3))), v16));
      v69 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v70 = vmaxq_f32(vaddq_f32(v69, (float32x4_t)vbslq_s8(v67, (int8x16_t)v13, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v19, v65)), v63, (int8x16_t)vaddq_f32(v60, vmulq_laneq_f32(v58, *(float32x4_t *)a2, 3))), v16))), v14);
      v71 = (int8x16_t *)(v6 + v10);
      *v71 = vbslq_s8(v67, (int8x16_t)v12, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v69, v68), v14), v16));
      v71[1] = vbslq_s8(v67, (int8x16_t)v13, (int8x16_t)vminq_f32(v70, v16));
      v71[2] = vbslq_s8(v67, (int8x16_t)v15, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v69, (float32x4_t)vbslq_s8(v67, (int8x16_t)v15, v66)), v14), v16));
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v72) = -v11;
    if ((int)v72 >= v5)
      goto LABEL_3;
LABEL_10:
    v72 = v72;
    do
    {
      v73 = *(float32x4_t *)(v7 + 16 * v72);
      v74 = *((float32x4_t *)a2 + 75);
      v75 = *((float32x4_t *)a2 + 5);
      v76 = vminq_f32(vmaxq_f32(v73, v74), v75);
      v77 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v76, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v77));
      v79 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v78), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v77, v78))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
      v80 = vcvtq_f32_s32(vcvtq_s32_f32(v79));
      v81 = vsubq_f32(v80, (float32x4_t)vandq_s8((int8x16_t)v75, (int8x16_t)vcgtq_f32(v80, v79)));
      v82 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v79, v81))), *((float32x4_t *)a2 + 12));
      *(int8x16_t *)(v6 + 16 * v72++) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v73, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v73, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v74, vsubq_f32(v76, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v76, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2), vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v82, v82), vaddq_f32(*((float32x4_t *)a2 + 10), v81)), v74), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))), *(float32x4_t *)a2, 3))), v75))), v74), v75));
    }
    while (v72 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype4_fixed_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  __int128 v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int8x16_t v62;
  int8x16_t v63;
  int8x16_t v64;
  float32x4_t v65;
  int8x16_t v66;
  int8x16_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  int8x16_t *v71;
  uint64_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v72) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((float32x4_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vminq_f32(vmaxq_f32(v12, v14), v16);
      v19 = vminq_f32(vmaxq_f32(v13, v14), v16);
      v20 = *((_OWORD *)a2 + 1);
      v21 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v22 = vminq_f32(vmaxq_f32(v15, v14), v16);
      v23 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v18, v21)));
      v24 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v19, v21)));
      v25 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v22, v21)));
      v26 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
      v27 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
      v28 = vcvtq_f32_s32(vcvtq_s32_f32(v25));
      v29 = *((float32x4_t *)a2 + 7);
      v30 = *((float32x4_t *)a2 + 8);
      v31 = vrsqrteq_f32(vaddq_f32(v29, vsubq_f32(v23, v26)));
      v32 = vrsqrteq_f32(vaddq_f32(v29, vsubq_f32(v24, v27)));
      v33 = vrsqrteq_f32(vaddq_f32(v29, vsubq_f32(v25, v28)));
      v34 = vaddq_f32(v30, v26);
      v35 = vaddq_f32(v30, v27);
      v36 = vaddq_f32(v30, v28);
      v37 = *((float32x4_t *)a2 + 9);
      v38 = *((float32x4_t *)a2 + 10);
      v39 = vmulq_n_f32(vsubq_f32(v34, vmulq_f32(v31, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v40 = vmulq_n_f32(vsubq_f32(v35, vmulq_f32(v32, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v41 = vmulq_n_f32(vsubq_f32(v36, vmulq_f32(v33, v37)), COERCE_FLOAT(*(_OWORD *)a2));
      v42 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v43 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v45 = vsubq_f32(v42, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v42, v39)));
      v46 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v43, v40)));
      v47 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v44, v41)));
      v48 = *((float32x4_t *)a2 + 11);
      v49 = *((float32x4_t *)a2 + 12);
      v50 = vmulq_f32(vrecpeq_f32(vsubq_f32(v48, vsubq_f32(v39, v45))), v49);
      v51 = vmulq_f32(vrecpeq_f32(vsubq_f32(v48, vsubq_f32(v40, v46))), v49);
      v52 = vmulq_f32(vrecpeq_f32(vsubq_f32(v48, vsubq_f32(v41, v47))), v49);
      v53 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v45), vmulq_f32(v50, v50)), v14);
      v54 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v46), vmulq_f32(v51, v51)), v14);
      v55 = *((float32x4_t *)a2 + 13);
      v56 = *((float32x4_t *)a2 + 14);
      v57 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v53, v55), v56));
      v58 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v54, v55), v56));
      v59 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(v38, v47), vmulq_f32(v52, v52)), v14), v55), v56));
      v60 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2);
      v61 = vmulq_laneq_f32(v59, *(float32x4_t *)a2, 3);
      v62 = (int8x16_t)vmulq_n_f32(v18, *(float *)&v20);
      v63 = (int8x16_t)vmulq_n_f32(v19, *(float *)&v20);
      v64 = (int8x16_t)vmulq_n_f32(v22, *(float *)&v20);
      v65 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v20, 1);
      v66 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v22, v65)), v64, (int8x16_t)vaddq_f32(v60, v61)), v16);
      v67 = *((int8x16_t *)a2 + 15);
      v68 = (float32x4_t)vbslq_s8(v67, (int8x16_t)v12, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v65)), v62, (int8x16_t)vaddq_f32(v60, vmulq_laneq_f32(v57, *(float32x4_t *)a2, 3))), v16));
      v69 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v70 = vmaxq_f32(vaddq_f32(v69, (float32x4_t)vbslq_s8(v67, (int8x16_t)v13, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v19, v65)), v63, (int8x16_t)vaddq_f32(v60, vmulq_laneq_f32(v58, *(float32x4_t *)a2, 3))), v16))), v14);
      v71 = (int8x16_t *)(v6 + v10);
      *v71 = vbslq_s8(v67, (int8x16_t)v12, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v69, v68), v14), v16));
      v71[1] = vbslq_s8(v67, (int8x16_t)v13, (int8x16_t)vminq_f32(v70, v16));
      v71[2] = vbslq_s8(v67, (int8x16_t)v15, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v69, (float32x4_t)vbslq_s8(v67, (int8x16_t)v15, v66)), v14), v16));
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v72) = -v11;
    if ((int)v72 >= v5)
      goto LABEL_3;
LABEL_10:
    v72 = v72;
    do
    {
      v73 = *(float32x4_t *)(v7 + 16 * v72);
      v74 = *((float32x4_t *)a2 + 75);
      v75 = *((float32x4_t *)a2 + 5);
      v76 = vminq_f32(vmaxq_f32(v73, v74), v75);
      v77 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v76, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1))));
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v77));
      v79 = vmulq_n_f32(vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v78), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v77, v78))), *((float32x4_t *)a2 + 9))), COERCE_FLOAT(*(_OWORD *)a2));
      v80 = vcvtq_f32_s32(vcvtq_s32_f32(v79));
      v81 = vsubq_f32(v80, (float32x4_t)vandq_s8((int8x16_t)v75, (int8x16_t)vcgtq_f32(v80, v79)));
      v82 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v79, v81))), *((float32x4_t *)a2 + 12));
      *(int8x16_t *)(v6 + 16 * v72++) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v73, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v73, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v74, vsubq_f32(v76, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v76, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2), vmulq_laneq_f32((float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vmulq_f32(v82, v82), vaddq_f32(*((float32x4_t *)a2 + 10), v81)), v74), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))), *(float32x4_t *)a2, 3))), v75))), v74), v75));
    }
    while (v72 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype4_nice_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  __int128 v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  int32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  int8x16_t v79;
  int8x16_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int8x16_t *v83;
  int v84;
  uint64_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v84 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = *((_OWORD *)a2 + 1);
      v18 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v19 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v20 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v14)), v14);
      v21 = (float32x4_t)vbslq_s8(v20, (int8x16_t)v15, (int8x16_t)vaddq_f32(v16, v18));
      v22 = (float32x4_t)vbslq_s8(v20, (int8x16_t)v15, (int8x16_t)vaddq_f32(v19, v18));
      v23 = *((int8x16_t *)a2 + 19);
      v24 = *((float32x4_t *)a2 + 20);
      v25 = (float32x4_t)vorrq_s8(vandq_s8(v23, (int8x16_t)v21), (int8x16_t)v15);
      v26 = *((int8x16_t *)a2 + 21);
      v27 = *((float32x4_t *)a2 + 22);
      v28 = (float32x4_t)vorrq_s8(vandq_s8(v23, (int8x16_t)v22), (int8x16_t)v15);
      v29 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v22, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v24, v22)));
      v30 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v24, v21))), v27);
      v31 = *((float32x4_t *)a2 + 23);
      v32 = *((float32x4_t *)a2 + 24);
      v33 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v25, v31));
      v34 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v28, v31));
      v35 = vaddq_f32(v30, v33);
      v36 = vmulq_f32(v32, v33);
      v37 = vmulq_f32(vmulq_f32(v32, v34), v28);
      v38 = vaddq_f32(vsubq_f32(v29, v27), v34);
      v39 = vsubq_f32(vsubq_f32(v25, v15), vmulq_f32(v36, v25));
      v40 = vsubq_f32(vsubq_f32(v28, v15), v37);
      v41 = *((float32x4_t *)a2 + 37);
      v42 = *((float32x4_t *)a2 + 38);
      v43 = vmulq_f32(v39, v39);
      v44 = *((float32x4_t *)a2 + 39);
      v45 = *((float32x4_t *)a2 + 40);
      v46 = vaddq_f32(v41, vmulq_f32(v42, v39));
      v47 = vaddq_f32(v44, vmulq_f32(v45, v39));
      v48 = vaddq_f32(v44, vmulq_f32(v45, v40));
      v49 = *((float32x4_t *)a2 + 41);
      v50 = *((float32x4_t *)a2 + 42);
      v51 = vaddq_f32(v41, vmulq_f32(v42, v40));
      v52 = vaddq_f32(v49, vmulq_f32(v50, v39));
      v53 = vaddq_f32(v49, vmulq_f32(v50, v40));
      v54 = vmulq_f32(v40, v40);
      v55 = vmulq_f32(v39, vaddq_f32(v52, vmulq_f32(v43, vaddq_f32(v46, vmulq_f32(v43, v47)))));
      v56 = *((float32x4_t *)a2 + 43);
      v57 = *((float32x4_t *)a2 + 44);
      v58 = vmulq_n_f32(vaddq_f32(v38, vmulq_f32(v40, vaddq_f32(v56, vmulq_f32(v40, vaddq_f32(v53, vmulq_f32(v54, vaddq_f32(v51, vmulq_f32(v54, v48)))))))), COERCE_FLOAT(*(_OWORD *)a2));
      v59 = *((float32x4_t *)a2 + 29);
      v60 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v35, vmulq_f32(v39, vaddq_f32(v56, v55))), COERCE_FLOAT(*(_OWORD *)a2)), v59);
      v61 = vmaxq_f32(v58, v59);
      v62 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v63 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v64 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v62, v60)));
      v65 = vsubq_f32(v63, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v63, v61)));
      v66 = vsubq_f32(v60, v64);
      v67 = vsubq_f32(v61, v65);
      v68 = *((float32x4_t *)a2 + 45);
      v69 = *((float32x4_t *)a2 + 46);
      v70 = vaddq_f32(v57, vmulq_f32(v68, v66));
      v71 = vaddq_f32(v57, vmulq_f32(v68, v67));
      v72 = *((float32x4_t *)a2 + 47);
      v73 = *((float32x4_t *)a2 + 48);
      v74 = *((int32x4_t *)a2 + 33);
      v75 = vmulq_f32(vaddq_f32(v15, vmulq_f32(v66, vaddq_f32(v73, vmulq_f32(v66, vaddq_f32(vaddq_f32(v69, vmulq_f32(v66, v72)), vmulq_f32(vmulq_f32(v66, v66), v70)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v74, vcvtq_s32_f32(v64)), 0x17uLL));
      v76 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2);
      v77 = vmulq_laneq_f32(vmulq_f32(vaddq_f32(v15, vmulq_f32(v67, vaddq_f32(v73, vmulq_f32(v67, vaddq_f32(vaddq_f32(v69, vmulq_f32(v72, v67)), vmulq_f32(vmulq_f32(v67, v67), v71)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v74, vcvtq_s32_f32(v65)), 0x17uLL)), *(float32x4_t *)a2, 3);
      v78 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v17, 1);
      v79 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v19, v78)), (int8x16_t)vmulq_n_f32(v19, *(float *)&v17), (int8x16_t)vaddq_f32(v76, v77)), v15);
      v80 = *((int8x16_t *)a2 + 15);
      v81 = (float32x4_t)vbslq_s8(v80, (int8x16_t)v13, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v78)), (int8x16_t)vmulq_n_f32(v16, *(float *)&v17), (int8x16_t)vaddq_f32(v76, vmulq_laneq_f32(v75, *(float32x4_t *)a2, 3))), v15));
      v82 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v83 = (int8x16_t *)(v6 + v11);
      v83[-1] = vbslq_s8(v80, (int8x16_t)v13, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v82, v81), v14), v15));
      *v83 = vbslq_s8(v80, (int8x16_t)v12, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v82, (float32x4_t)vbslq_s8(v80, (int8x16_t)v12, v79)), v14), v15));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v84 = -v10;
    if (v84 >= v5)
      goto LABEL_3;
LABEL_10:
    v85 = 16 * v84;
    v86 = *(float32x4_t *)(v7 + v85);
    v87 = *((float32x4_t *)a2 + 75);
    v88 = *((float32x4_t *)a2 + 5);
    v89 = vminq_f32(vmaxq_f32(v86, v87), v88);
    v90 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v87)), v87), (int8x16_t)v88, (int8x16_t)vaddq_f32(v89, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
    v91 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v90), (int8x16_t)v88);
    v92 = (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v91, *((float32x4_t *)a2 + 23)));
    v93 = vsubq_f32(vsubq_f32(v91, v88), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v92), v91));
    v94 = vmulq_f32(v93, v93);
    v95 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v90, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v90))), *((float32x4_t *)a2 + 22)), v92), vmulq_f32(v93, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v93, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v93)),
                        vmulq_f32(v94, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v93)), vmulq_f32(v94, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v93)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
    v96 = vcvtq_f32_s32(vcvtq_s32_f32(v95));
    v97 = vsubq_f32(v96, (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v96, v95)));
    v98 = vsubq_f32(v95, v97);
    *(int8x16_t *)(v6 + v85) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v86, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v86, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v87, vsubq_f32(v89, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v89, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2), vmulq_laneq_f32(vmulq_f32(vaddq_f32(v88, vmulq_f32(v98, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v98, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v98)), vmulq_f32(vmulq_f32(v98, v98), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v98)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v97)), 0x17uLL)), *(float32x4_t *)a2, 3))), v88))), v87), v88));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype4_half_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  __int128 v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int32x4_t v59;
  int32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int8x16_t v65;
  int8x16_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int8x16_t *v69;
  int v70;
  uint64_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v70 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v18 = *((_OWORD *)a2 + 1);
      v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v20 = vaddq_f32(v16, v19);
      v21 = vaddq_f32(v17, v19);
      v22 = *((int8x16_t *)a2 + 19);
      v23 = *((float32x4_t *)a2 + 20);
      v24 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v20), (int8x16_t)v15);
      v25 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v21), (int8x16_t)v15);
      v26 = *((int8x16_t *)a2 + 21);
      v27 = *((float32x4_t *)a2 + 22);
      v28 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v23, v21)));
      v29 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v23, v20))), v27);
      v30 = *((float32x4_t *)a2 + 23);
      v31 = *((float32x4_t *)a2 + 24);
      v32 = vsubq_f32(v28, v27);
      v33 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v24, v30));
      v34 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v25, v30));
      v35 = vaddq_f32(v29, v33);
      v36 = vsubq_f32(vsubq_f32(v24, v15), vmulq_f32(vmulq_f32(v31, v33), v24));
      v37 = vsubq_f32(vsubq_f32(v25, v15), vmulq_f32(vmulq_f32(v31, v34), v25));
      v38 = *((float32x4_t *)a2 + 25);
      v39 = *((float32x4_t *)a2 + 26);
      v40 = vaddq_f32(v38, vmulq_f32(v39, v36));
      v41 = vaddq_f32(v38, vmulq_f32(v39, v37));
      v42 = *((float32x4_t *)a2 + 27);
      v43 = *((float32x4_t *)a2 + 28);
      v44 = vmulq_n_f32(vaddq_f32(vaddq_f32(v32, v34), vmulq_f32(v37, vaddq_f32(vaddq_f32(v42, vmulq_f32(v43, v37)), vmulq_f32(vmulq_f32(v37, v37), v41)))), COERCE_FLOAT(*(_OWORD *)a2));
      v45 = *((float32x4_t *)a2 + 29);
      v46 = *((float32x4_t *)a2 + 30);
      v47 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v35, vmulq_f32(v36, vaddq_f32(vaddq_f32(v42, vmulq_f32(v43, v36)), vmulq_f32(vmulq_f32(v36, v36), v40)))), COERCE_FLOAT(*(_OWORD *)a2)), v45);
      v48 = vmaxq_f32(v44, v45);
      v49 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      v50 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
      v51 = vsubq_f32(v49, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v49, v47)));
      v52 = vsubq_f32(v50, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v50, v48)));
      v53 = vsubq_f32(v47, v51);
      v54 = vsubq_f32(v48, v52);
      v55 = *((float32x4_t *)a2 + 31);
      v56 = *((float32x4_t *)a2 + 32);
      v57 = vmulq_f32(v54, vaddq_f32(v56, vmulq_f32(v54, vaddq_f32(v46, vmulq_f32(v55, v54)))));
      v58 = vaddq_f32(v15, vmulq_f32(v53, vaddq_f32(v56, vmulq_f32(v53, vaddq_f32(v46, vmulq_f32(v55, v53))))));
      v59 = vcvtq_s32_f32(v52);
      v60 = *((int32x4_t *)a2 + 33);
      v61 = vmulq_f32(v58, (float32x4_t)vshlq_n_s32(vaddq_s32(v60, vcvtq_s32_f32(v51)), 0x17uLL));
      v62 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2);
      v63 = vmulq_laneq_f32(vmulq_f32(vaddq_f32(v15, v57), (float32x4_t)vshlq_n_s32(vaddq_s32(v60, v59), 0x17uLL)), *(float32x4_t *)a2, 3);
      v64 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v18, 1);
      v65 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v64)), (int8x16_t)vmulq_n_f32(v17, *(float *)&v18), (int8x16_t)vaddq_f32(v62, v63)), v15);
      v66 = *((int8x16_t *)a2 + 15);
      v67 = (float32x4_t)vbslq_s8(v66, (int8x16_t)v13, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v64)), (int8x16_t)vmulq_n_f32(v16, *(float *)&v18), (int8x16_t)vaddq_f32(v62, vmulq_laneq_f32(v61, *(float32x4_t *)a2, 3))), v15));
      v68 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v69 = (int8x16_t *)(v6 + v11);
      v69[-1] = vbslq_s8(v66, (int8x16_t)v13, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v68, v67), v14), v15));
      *v69 = vbslq_s8(v66, (int8x16_t)v12, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v68, (float32x4_t)vbslq_s8(v66, (int8x16_t)v12, v65)), v14), v15));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v70 = -v10;
    if (v70 >= v5)
      goto LABEL_3;
LABEL_10:
    v71 = 16 * v70;
    v72 = *(float32x4_t *)(v7 + v71);
    v73 = *((float32x4_t *)a2 + 75);
    v74 = *((float32x4_t *)a2 + 5);
    v75 = vminq_f32(vmaxq_f32(v72, v73), v74);
    v76 = vaddq_f32(v75, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v77 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v76), (int8x16_t)v74);
    v78 = (float32x4_t)vandq_s8((int8x16_t)v74, (int8x16_t)vcgtq_f32(v77, *((float32x4_t *)a2 + 23)));
    v79 = vsubq_f32(vsubq_f32(v77, v74), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v78), v77));
    v80 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v76, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v76))), *((float32x4_t *)a2 + 22)), v78), vmulq_f32(v79, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(*((float32x4_t *)a2 + 28), v79)), vmulq_f32(vmulq_f32(v79, v79), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v79)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v81 = vcvtq_f32_s32(vcvtq_s32_f32(v80));
    v82 = vsubq_f32(v81, (float32x4_t)vandq_s8((int8x16_t)v74, (int8x16_t)vcgtq_f32(v81, v80)));
    v83 = vsubq_f32(v80, v82);
    *(int8x16_t *)(v6 + v71) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v72, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v72, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v73, vsubq_f32(v75, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v75, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2), vmulq_laneq_f32(vmulq_f32(vaddq_f32(v74, vmulq_f32(v83, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v83, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v83)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v82)), 0x17uLL)), *(float32x4_t *)a2, 3))), v74))), v73), v74));
    goto LABEL_3;
  }
  return 0;
}

